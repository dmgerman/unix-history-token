begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Expands front end tree to back end RTL for GNU C-Compiler    Copyright (C) 1987, 88, 89, 91, 92, 1993 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* This file handles the generation of rtl code from tree structure    at the level of the function as a whole.    It creates the rtl expressions for parameters and auto variables    and has full responsibility for allocating stack slots.     `expand_function_start' is called at the beginning of a function,    before the function body is parsed, and `expand_function_end' is    called after parsing the body.     Call `assign_stack_local' to allocate a stack slot for a local variable.    This is usually done during the RTL generation for the function body,    but it can also be done in the reload pass when a pseudo-register does    not get a hard register.     Call `put_var_into_stack' when you learn, belatedly, that a variable    previously given a pseudo-register must in fact go in the stack.    This function changes the DECL_RTL to be a stack slot instead of a reg    then scans all the RTL instructions so far generated to correct them.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"insn-flags.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"insn-codes.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_comment
comment|/* Round a value to the lowest integer less than it that is a multiple of    the required alignment.  Avoid using division in case the value is    negative.  Assume the alignment is a power of two.  */
end_comment

begin_define
define|#
directive|define
name|FLOOR_ROUND
parameter_list|(
name|VALUE
parameter_list|,
name|ALIGN
parameter_list|)
value|((VALUE)& ~((ALIGN) - 1))
end_define

begin_comment
comment|/* Similar, but round to the next highest integer that meets the    alignment.  */
end_comment

begin_define
define|#
directive|define
name|CEIL_ROUND
parameter_list|(
name|VALUE
parameter_list|,
name|ALIGN
parameter_list|)
value|(((VALUE) + (ALIGN) - 1)& ~((ALIGN)- 1))
end_define

begin_comment
comment|/* NEED_SEPARATE_AP means that we cannot derive ap from the value of fp    during rtl generation.  If they are different register numbers, this is    always true.  It may also be true if    FIRST_PARM_OFFSET - STARTING_FRAME_OFFSET is not a constant during rtl    generation.  See fix_lexical_addr for details.  */
end_comment

begin_if
if|#
directive|if
name|ARG_POINTER_REGNUM
operator|!=
name|FRAME_POINTER_REGNUM
end_if

begin_define
define|#
directive|define
name|NEED_SEPARATE_AP
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Number of bytes of args popped by function being compiled on its return.    Zero if no bytes are to be popped.    May affect compilation of return insn or of function epilogue.  */
end_comment

begin_decl_stmt
name|int
name|current_function_pops_args
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if function being compiled needs to be given an address    where the value should be stored.  */
end_comment

begin_decl_stmt
name|int
name|current_function_returns_struct
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if function being compiled needs to    return the address of where it has put a structure value.  */
end_comment

begin_decl_stmt
name|int
name|current_function_returns_pcc_struct
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if function being compiled needs to be passed a static chain.  */
end_comment

begin_decl_stmt
name|int
name|current_function_needs_context
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if function being compiled can call setjmp.  */
end_comment

begin_decl_stmt
name|int
name|current_function_calls_setjmp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if function being compiled can call longjmp.  */
end_comment

begin_decl_stmt
name|int
name|current_function_calls_longjmp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if function being compiled receives nonlocal gotos    from nested functions.  */
end_comment

begin_decl_stmt
name|int
name|current_function_has_nonlocal_label
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if function being compiled contains nested functions.  */
end_comment

begin_decl_stmt
name|int
name|current_function_contains_functions
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if function being compiled can call alloca,    either as a subroutine or builtin.  */
end_comment

begin_decl_stmt
name|int
name|current_function_calls_alloca
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if the current function returns a pointer type */
end_comment

begin_decl_stmt
name|int
name|current_function_returns_pointer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If some insns can be deferred to the delay slots of the epilogue, the    delay list for them is recorded here.  */
end_comment

begin_decl_stmt
name|rtx
name|current_function_epilogue_delay_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If function's args have a fixed size, this is that size, in bytes.    Otherwise, it is -1.    May affect compilation of return insn or of function epilogue.  */
end_comment

begin_decl_stmt
name|int
name|current_function_args_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # bytes the prologue should push and pretend that the caller pushed them.    The prologue must do this, but only if parms can be passed in registers.  */
end_comment

begin_decl_stmt
name|int
name|current_function_pretend_args_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # of bytes of outgoing arguments required to be pushed by the prologue.    If this is non-zero, it means that ACCUMULATE_OUTGOING_ARGS was defined    and no stack adjusts will be done on function calls.  */
end_comment

begin_decl_stmt
name|int
name|current_function_outgoing_args_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the offset from the arg pointer to the place where the first    anonymous arg can be found, if there is one.  */
end_comment

begin_decl_stmt
name|rtx
name|current_function_arg_offset_rtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if current function uses varargs.h or equivalent.    Zero for functions that use stdarg.h.  */
end_comment

begin_decl_stmt
name|int
name|current_function_varargs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Quantities of various kinds of registers    used for the current function's args.  */
end_comment

begin_decl_stmt
name|CUMULATIVE_ARGS
name|current_function_args_info
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name of function now being compiled.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|current_function_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If non-zero, an RTL expression for that location at which the current    function returns its result.  Always equal to    DECL_RTL (DECL_RESULT (current_function_decl)), but provided    independently of the tree structures.  */
end_comment

begin_decl_stmt
name|rtx
name|current_function_return_rtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if the current function uses the constant pool.  */
end_comment

begin_decl_stmt
name|int
name|current_function_uses_const_pool
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if the current function uses pic_offset_table_rtx.  */
end_comment

begin_decl_stmt
name|int
name|current_function_uses_pic_offset_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The arg pointer hard register, or the pseudo into which it was copied.  */
end_comment

begin_decl_stmt
name|rtx
name|current_function_internal_arg_pointer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The FUNCTION_DECL for an inline function currently being expanded.  */
end_comment

begin_decl_stmt
name|tree
name|inline_function_decl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of function calls seen so far in current function.  */
end_comment

begin_decl_stmt
name|int
name|function_call_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List (chain of TREE_LIST) of LABEL_DECLs for all nonlocal labels    (labels to which there can be nonlocal gotos from nested functions)    in this function.  */
end_comment

begin_decl_stmt
name|tree
name|nonlocal_labels
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* RTX for stack slot that holds the current handler for nonlocal gotos.    Zero when function does not have nonlocal labels.  */
end_comment

begin_decl_stmt
name|rtx
name|nonlocal_goto_handler_slot
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* RTX for stack slot that holds the stack pointer value to restore    for a nonlocal goto.    Zero when function does not have nonlocal labels.  */
end_comment

begin_decl_stmt
name|rtx
name|nonlocal_goto_stack_level
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Label that will go on parm cleanup code, if any.    Jumping to this label runs cleanup code for parameters, if    such code must be run.  Following this code is the logical return label.  */
end_comment

begin_decl_stmt
name|rtx
name|cleanup_label
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Label that will go on function epilogue.    Jumping to this label serves as a "return" instruction    on machines which require execution of the epilogue on all returns.  */
end_comment

begin_decl_stmt
name|rtx
name|return_label
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List (chain of EXPR_LISTs) of pseudo-regs of SAVE_EXPRs.    So we can mark them all live at the end of the function, if nonopt.  */
end_comment

begin_decl_stmt
name|rtx
name|save_expr_regs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List (chain of EXPR_LISTs) of all stack slots in this function.    Made for the sake of unshare_all_rtl.  */
end_comment

begin_decl_stmt
name|rtx
name|stack_slot_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain of all RTL_EXPRs that have insns in them.  */
end_comment

begin_decl_stmt
name|tree
name|rtl_expr_chain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Label to jump back to for tail recursion, or 0 if we have    not yet needed one for this function.  */
end_comment

begin_decl_stmt
name|rtx
name|tail_recursion_label
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Place after which to insert the tail_recursion_label if we need one.  */
end_comment

begin_decl_stmt
name|rtx
name|tail_recursion_reentry
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Location at which to save the argument pointer if it will need to be    referenced.  There are two cases where this is done: if nonlocal gotos    exist, or if vars stored at an offset from the argument pointer will be    needed by inner routines.  */
end_comment

begin_decl_stmt
name|rtx
name|arg_pointer_save_area
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Offset to end of allocated area of stack frame.    If stack grows down, this is the address of the last stack slot allocated.    If stack grows up, this is the address for the next slot.  */
end_comment

begin_decl_stmt
name|int
name|frame_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List (chain of TREE_LISTs) of static chains for containing functions.    Each link has a FUNCTION_DECL in the TREE_PURPOSE and a reg rtx    in an RTL_EXPR in the TREE_VALUE.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|context_display
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List (chain of TREE_LISTs) of trampolines for nested functions.    The trampoline sets up the static chain and jumps to the function.    We supply the trampoline's address when the function's address is requested.     Each link has a FUNCTION_DECL in the TREE_PURPOSE and a reg rtx    in an RTL_EXPR in the TREE_VALUE.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|trampoline_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Insn after which register parms and SAVE_EXPRs are born, if nonopt.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|parm_birth_insn
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Nonzero if a stack slot has been generated whose address is not    actually valid.  It means that the generated rtl must all be scanned    to detect and correct the invalid addresses where they occur.  */
end_comment

begin_endif
unit|static int invalid_stack_slot;
endif|#
directive|endif
end_endif

begin_comment
comment|/* Last insn of those whose job was to put parms into their nominal homes.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|last_parm_insn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 + last pseudo register number used for loading a copy    of a parameter of this function.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_parm_reg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Vector indexed by REGNO, containing location on stack in which    to put the parm which is nominally in pseudo register REGNO,    if we discover that that parm must go in the stack.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|parm_reg_stack_loc
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Turned off because 0 seems to work just as well.  */
end_comment

begin_comment
comment|/* Cleanup lists are required for binding levels regardless of whether    that binding level has cleanups or not.  This node serves as the    cleanup list whenever an empty list is required.  */
end_comment

begin_endif
unit|static tree empty_cleanup_list;
endif|#
directive|endif
end_endif

begin_comment
comment|/* Nonzero once virtual register instantiation has been done.    assign_stack_local uses frame_pointer_rtx when this is nonzero.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|virtuals_instantiated
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we need to distinguish between the return value of this function    and the return value of a function called by this function.  This helps    integrate.c  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|rtx_equal_function_value_matters
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|fixup_gotos
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|round_down
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|round_trampoline_addr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|fixup_stack_1
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fixup_var_refs
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fixup_var_refs_insns
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fixup_var_refs_1
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|optimize_bit_field
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|instantiate_decls
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|instantiate_decls_1
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|instantiate_decl
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|instantiate_virtual_regs_1
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|fixup_memory_subreg
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|walk_fixup_memory_subreg
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* In order to evaluate some expressions, such as function calls returning    structures in memory, we need to temporarily allocate stack locations.    We record each allocated temporary in the following structure.     Associated with each temporary slot is a nesting level.  When we pop up    one level, all temporaries associated with the previous level are freed.    Normally, all temporaries are freed after the execution of the statement    in which they were created.  However, if we are inside a ({...}) grouping,    the result may be in a temporary and hence must be preserved.  If the    result could be in a temporary, we preserve it if we can determine which    one it is in.  If we cannot determine which temporary may contain the    result, all temporaries are preserved.  A temporary is preserved by    pretending it was allocated at the previous nesting level.     Automatic variables are also assigned temporary slots, at the nesting    level where they are defined.  They are marked a "kept" so that    free_temp_slots will not free them.  */
end_comment

begin_struct
struct|struct
name|temp_slot
block|{
comment|/* Points to next temporary slot.  */
name|struct
name|temp_slot
modifier|*
name|next
decl_stmt|;
comment|/* The rtx to used to reference the slot. */
name|rtx
name|slot
decl_stmt|;
comment|/* The size, in units, of the slot.  */
name|int
name|size
decl_stmt|;
comment|/* Non-zero if this temporary is currently in use.  */
name|char
name|in_use
decl_stmt|;
comment|/* Nesting level at which this slot is being used.  */
name|int
name|level
decl_stmt|;
comment|/* Non-zero if this should survive a call to free_temp_slots.  */
name|int
name|keep
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* List of all temporaries allocated, both available and in use.  */
end_comment

begin_decl_stmt
name|struct
name|temp_slot
modifier|*
name|temp_slots
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current nesting level for temporaries.  */
end_comment

begin_decl_stmt
name|int
name|temp_slot_level
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Pointer to chain of `struct function' for containing functions.  */
end_comment

begin_decl_stmt
name|struct
name|function
modifier|*
name|outer_function_chain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Given a function decl for a containing function,    return the `struct function' for it.  */
end_comment

begin_function
name|struct
name|function
modifier|*
name|find_function_data
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|struct
name|function
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|outer_function_chain
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|p
operator|->
name|decl
operator|==
name|decl
condition|)
return|return
name|p
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Save the current context for compilation of a nested function.    This is called from language-specific code.    The caller is responsible for saving any language-specific status,    since this function knows only about language-independent variables.  */
end_comment

begin_function
name|void
name|push_function_context
parameter_list|()
block|{
name|struct
name|function
modifier|*
name|p
init|=
operator|(
expr|struct
name|function
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|function
argument_list|)
argument_list|)
decl_stmt|;
name|p
operator|->
name|next
operator|=
name|outer_function_chain
expr_stmt|;
name|outer_function_chain
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|name
operator|=
name|current_function_name
expr_stmt|;
name|p
operator|->
name|decl
operator|=
name|current_function_decl
expr_stmt|;
name|p
operator|->
name|pops_args
operator|=
name|current_function_pops_args
expr_stmt|;
name|p
operator|->
name|returns_struct
operator|=
name|current_function_returns_struct
expr_stmt|;
name|p
operator|->
name|returns_pcc_struct
operator|=
name|current_function_returns_pcc_struct
expr_stmt|;
name|p
operator|->
name|needs_context
operator|=
name|current_function_needs_context
expr_stmt|;
name|p
operator|->
name|calls_setjmp
operator|=
name|current_function_calls_setjmp
expr_stmt|;
name|p
operator|->
name|calls_longjmp
operator|=
name|current_function_calls_longjmp
expr_stmt|;
name|p
operator|->
name|calls_alloca
operator|=
name|current_function_calls_alloca
expr_stmt|;
name|p
operator|->
name|has_nonlocal_label
operator|=
name|current_function_has_nonlocal_label
expr_stmt|;
name|p
operator|->
name|args_size
operator|=
name|current_function_args_size
expr_stmt|;
name|p
operator|->
name|pretend_args_size
operator|=
name|current_function_pretend_args_size
expr_stmt|;
name|p
operator|->
name|arg_offset_rtx
operator|=
name|current_function_arg_offset_rtx
expr_stmt|;
name|p
operator|->
name|uses_const_pool
operator|=
name|current_function_uses_const_pool
expr_stmt|;
name|p
operator|->
name|uses_pic_offset_table
operator|=
name|current_function_uses_pic_offset_table
expr_stmt|;
name|p
operator|->
name|internal_arg_pointer
operator|=
name|current_function_internal_arg_pointer
expr_stmt|;
name|p
operator|->
name|max_parm_reg
operator|=
name|max_parm_reg
expr_stmt|;
name|p
operator|->
name|parm_reg_stack_loc
operator|=
name|parm_reg_stack_loc
expr_stmt|;
name|p
operator|->
name|outgoing_args_size
operator|=
name|current_function_outgoing_args_size
expr_stmt|;
name|p
operator|->
name|return_rtx
operator|=
name|current_function_return_rtx
expr_stmt|;
name|p
operator|->
name|nonlocal_goto_handler_slot
operator|=
name|nonlocal_goto_handler_slot
expr_stmt|;
name|p
operator|->
name|nonlocal_goto_stack_level
operator|=
name|nonlocal_goto_stack_level
expr_stmt|;
name|p
operator|->
name|nonlocal_labels
operator|=
name|nonlocal_labels
expr_stmt|;
name|p
operator|->
name|cleanup_label
operator|=
name|cleanup_label
expr_stmt|;
name|p
operator|->
name|return_label
operator|=
name|return_label
expr_stmt|;
name|p
operator|->
name|save_expr_regs
operator|=
name|save_expr_regs
expr_stmt|;
name|p
operator|->
name|stack_slot_list
operator|=
name|stack_slot_list
expr_stmt|;
name|p
operator|->
name|parm_birth_insn
operator|=
name|parm_birth_insn
expr_stmt|;
name|p
operator|->
name|frame_offset
operator|=
name|frame_offset
expr_stmt|;
name|p
operator|->
name|tail_recursion_label
operator|=
name|tail_recursion_label
expr_stmt|;
name|p
operator|->
name|tail_recursion_reentry
operator|=
name|tail_recursion_reentry
expr_stmt|;
name|p
operator|->
name|arg_pointer_save_area
operator|=
name|arg_pointer_save_area
expr_stmt|;
name|p
operator|->
name|rtl_expr_chain
operator|=
name|rtl_expr_chain
expr_stmt|;
name|p
operator|->
name|last_parm_insn
operator|=
name|last_parm_insn
expr_stmt|;
name|p
operator|->
name|context_display
operator|=
name|context_display
expr_stmt|;
name|p
operator|->
name|trampoline_list
operator|=
name|trampoline_list
expr_stmt|;
name|p
operator|->
name|function_call_count
operator|=
name|function_call_count
expr_stmt|;
name|p
operator|->
name|temp_slots
operator|=
name|temp_slots
expr_stmt|;
name|p
operator|->
name|temp_slot_level
operator|=
name|temp_slot_level
expr_stmt|;
name|p
operator|->
name|fixup_var_refs_queue
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|epilogue_delay_list
operator|=
name|current_function_epilogue_delay_list
expr_stmt|;
name|save_tree_status
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|save_storage_status
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|save_emit_status
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|init_emit
argument_list|()
expr_stmt|;
name|save_expr_status
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|save_stmt_status
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|save_varasm_status
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Restore the last saved context, at the end of a nested function.    This function is called from language-specific code.  */
end_comment

begin_function
name|void
name|pop_function_context
parameter_list|()
block|{
name|struct
name|function
modifier|*
name|p
init|=
name|outer_function_chain
decl_stmt|;
name|outer_function_chain
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|current_function_name
operator|=
name|p
operator|->
name|name
expr_stmt|;
name|current_function_decl
operator|=
name|p
operator|->
name|decl
expr_stmt|;
name|current_function_pops_args
operator|=
name|p
operator|->
name|pops_args
expr_stmt|;
name|current_function_returns_struct
operator|=
name|p
operator|->
name|returns_struct
expr_stmt|;
name|current_function_returns_pcc_struct
operator|=
name|p
operator|->
name|returns_pcc_struct
expr_stmt|;
name|current_function_needs_context
operator|=
name|p
operator|->
name|needs_context
expr_stmt|;
name|current_function_calls_setjmp
operator|=
name|p
operator|->
name|calls_setjmp
expr_stmt|;
name|current_function_calls_longjmp
operator|=
name|p
operator|->
name|calls_longjmp
expr_stmt|;
name|current_function_calls_alloca
operator|=
name|p
operator|->
name|calls_alloca
expr_stmt|;
name|current_function_has_nonlocal_label
operator|=
name|p
operator|->
name|has_nonlocal_label
expr_stmt|;
name|current_function_contains_functions
operator|=
literal|1
expr_stmt|;
name|current_function_args_size
operator|=
name|p
operator|->
name|args_size
expr_stmt|;
name|current_function_pretend_args_size
operator|=
name|p
operator|->
name|pretend_args_size
expr_stmt|;
name|current_function_arg_offset_rtx
operator|=
name|p
operator|->
name|arg_offset_rtx
expr_stmt|;
name|current_function_uses_const_pool
operator|=
name|p
operator|->
name|uses_const_pool
expr_stmt|;
name|current_function_uses_pic_offset_table
operator|=
name|p
operator|->
name|uses_pic_offset_table
expr_stmt|;
name|current_function_internal_arg_pointer
operator|=
name|p
operator|->
name|internal_arg_pointer
expr_stmt|;
name|max_parm_reg
operator|=
name|p
operator|->
name|max_parm_reg
expr_stmt|;
name|parm_reg_stack_loc
operator|=
name|p
operator|->
name|parm_reg_stack_loc
expr_stmt|;
name|current_function_outgoing_args_size
operator|=
name|p
operator|->
name|outgoing_args_size
expr_stmt|;
name|current_function_return_rtx
operator|=
name|p
operator|->
name|return_rtx
expr_stmt|;
name|nonlocal_goto_handler_slot
operator|=
name|p
operator|->
name|nonlocal_goto_handler_slot
expr_stmt|;
name|nonlocal_goto_stack_level
operator|=
name|p
operator|->
name|nonlocal_goto_stack_level
expr_stmt|;
name|nonlocal_labels
operator|=
name|p
operator|->
name|nonlocal_labels
expr_stmt|;
name|cleanup_label
operator|=
name|p
operator|->
name|cleanup_label
expr_stmt|;
name|return_label
operator|=
name|p
operator|->
name|return_label
expr_stmt|;
name|save_expr_regs
operator|=
name|p
operator|->
name|save_expr_regs
expr_stmt|;
name|stack_slot_list
operator|=
name|p
operator|->
name|stack_slot_list
expr_stmt|;
name|parm_birth_insn
operator|=
name|p
operator|->
name|parm_birth_insn
expr_stmt|;
name|frame_offset
operator|=
name|p
operator|->
name|frame_offset
expr_stmt|;
name|tail_recursion_label
operator|=
name|p
operator|->
name|tail_recursion_label
expr_stmt|;
name|tail_recursion_reentry
operator|=
name|p
operator|->
name|tail_recursion_reentry
expr_stmt|;
name|arg_pointer_save_area
operator|=
name|p
operator|->
name|arg_pointer_save_area
expr_stmt|;
name|rtl_expr_chain
operator|=
name|p
operator|->
name|rtl_expr_chain
expr_stmt|;
name|last_parm_insn
operator|=
name|p
operator|->
name|last_parm_insn
expr_stmt|;
name|context_display
operator|=
name|p
operator|->
name|context_display
expr_stmt|;
name|trampoline_list
operator|=
name|p
operator|->
name|trampoline_list
expr_stmt|;
name|function_call_count
operator|=
name|p
operator|->
name|function_call_count
expr_stmt|;
name|temp_slots
operator|=
name|p
operator|->
name|temp_slots
expr_stmt|;
name|temp_slot_level
operator|=
name|p
operator|->
name|temp_slot_level
expr_stmt|;
name|current_function_epilogue_delay_list
operator|=
name|p
operator|->
name|epilogue_delay_list
expr_stmt|;
name|restore_tree_status
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|restore_storage_status
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|restore_expr_status
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|restore_emit_status
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|restore_stmt_status
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|restore_varasm_status
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Finish doing put_var_into_stack for any of our variables      which became addressable during the nested function.  */
block|{
name|struct
name|var_refs_queue
modifier|*
name|queue
init|=
name|p
operator|->
name|fixup_var_refs_queue
decl_stmt|;
for|for
control|(
init|;
name|queue
condition|;
name|queue
operator|=
name|queue
operator|->
name|next
control|)
name|fixup_var_refs
argument_list|(
name|queue
operator|->
name|modified
argument_list|,
name|queue
operator|->
name|promoted_mode
argument_list|,
name|queue
operator|->
name|unsignedp
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Reset variables that have known state during rtx generation.  */
name|rtx_equal_function_value_matters
operator|=
literal|1
expr_stmt|;
name|virtuals_instantiated
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Allocate fixed slots in the stack frame of the current function.  */
end_comment

begin_comment
comment|/* Return size needed for stack frame based on slots so far allocated.    This size counts from zero.  It is not rounded to STACK_BOUNDARY;    the caller may have to do that.  */
end_comment

begin_function
name|int
name|get_frame_size
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|FRAME_GROWS_DOWNWARD
return|return
operator|-
name|frame_offset
return|;
else|#
directive|else
return|return
name|frame_offset
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Allocate a stack slot of SIZE bytes and return a MEM rtx for it    with machine mode MODE.        ALIGN controls the amount of alignment for the address of the slot:    0 means according to MODE,    -1 means use BIGGEST_ALIGNMENT and round size to multiple of that,    positive specifies alignment boundary in bits.     We do not round to stack_boundary here.  */
end_comment

begin_function
name|rtx
name|assign_stack_local
parameter_list|(
name|mode
parameter_list|,
name|size
parameter_list|,
name|align
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|align
decl_stmt|;
block|{
specifier|register
name|rtx
name|x
decl_stmt|,
name|addr
decl_stmt|;
name|int
name|bigend_correction
init|=
literal|0
decl_stmt|;
name|int
name|alignment
decl_stmt|;
if|if
condition|(
name|align
operator|==
literal|0
condition|)
block|{
name|alignment
operator|=
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
operator|/
name|BITS_PER_UNIT
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|BLKmode
condition|)
name|alignment
operator|=
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|align
operator|==
operator|-
literal|1
condition|)
block|{
name|alignment
operator|=
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
expr_stmt|;
name|size
operator|=
name|CEIL_ROUND
argument_list|(
name|size
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
block|}
else|else
name|alignment
operator|=
name|align
operator|/
name|BITS_PER_UNIT
expr_stmt|;
comment|/* Round frame offset to that alignment.      We must be careful here, since FRAME_OFFSET might be negative and      division with a negative dividend isn't as well defined as we might      like.  So we instead assume that ALIGNMENT is a power of two and      use logical operations which are unambiguous.  */
ifdef|#
directive|ifdef
name|FRAME_GROWS_DOWNWARD
name|frame_offset
operator|=
name|FLOOR_ROUND
argument_list|(
name|frame_offset
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
else|#
directive|else
name|frame_offset
operator|=
name|CEIL_ROUND
argument_list|(
name|frame_offset
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* On a big-endian machine, if we are allocating more space than we will use,      use the least significant bytes of those that are allocated.  */
if|#
directive|if
name|BYTES_BIG_ENDIAN
if|if
condition|(
name|mode
operator|!=
name|BLKmode
condition|)
name|bigend_correction
operator|=
name|size
operator|-
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|FRAME_GROWS_DOWNWARD
name|frame_offset
operator|-=
name|size
expr_stmt|;
endif|#
directive|endif
comment|/* If we have already instantiated virtual registers, return the actual      address relative to the frame pointer.  */
if|if
condition|(
name|virtuals_instantiated
condition|)
name|addr
operator|=
name|plus_constant
argument_list|(
name|frame_pointer_rtx
argument_list|,
operator|(
name|frame_offset
operator|+
name|bigend_correction
operator|+
name|STARTING_FRAME_OFFSET
operator|)
argument_list|)
expr_stmt|;
else|else
name|addr
operator|=
name|plus_constant
argument_list|(
name|virtual_stack_vars_rtx
argument_list|,
name|frame_offset
operator|+
name|bigend_correction
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|FRAME_GROWS_DOWNWARD
name|frame_offset
operator|+=
name|size
expr_stmt|;
endif|#
directive|endif
name|x
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|mode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|stack_slot_list
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|VOIDmode
argument_list|,
name|x
argument_list|,
name|stack_slot_list
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Assign a stack slot in a containing function.    First three arguments are same as in preceding function.    The last argument specifies the function to allocate in.  */
end_comment

begin_function
name|rtx
name|assign_outer_stack_local
parameter_list|(
name|mode
parameter_list|,
name|size
parameter_list|,
name|align
parameter_list|,
name|function
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|align
decl_stmt|;
name|struct
name|function
modifier|*
name|function
decl_stmt|;
block|{
specifier|register
name|rtx
name|x
decl_stmt|,
name|addr
decl_stmt|;
name|int
name|bigend_correction
init|=
literal|0
decl_stmt|;
name|int
name|alignment
decl_stmt|;
comment|/* Allocate in the memory associated with the function in whose frame      we are assigning.  */
name|push_obstacks
argument_list|(
name|function
operator|->
name|function_obstack
argument_list|,
name|function
operator|->
name|function_maybepermanent_obstack
argument_list|)
expr_stmt|;
if|if
condition|(
name|align
operator|==
literal|0
condition|)
block|{
name|alignment
operator|=
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
operator|/
name|BITS_PER_UNIT
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|BLKmode
condition|)
name|alignment
operator|=
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|align
operator|==
operator|-
literal|1
condition|)
block|{
name|alignment
operator|=
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
expr_stmt|;
name|size
operator|=
name|CEIL_ROUND
argument_list|(
name|size
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
block|}
else|else
name|alignment
operator|=
name|align
operator|/
name|BITS_PER_UNIT
expr_stmt|;
comment|/* Round frame offset to that alignment.  */
ifdef|#
directive|ifdef
name|FRAME_GROWS_DOWNWARD
name|function
operator|->
name|frame_offset
operator|=
name|FLOOR_ROUND
argument_list|(
name|function
operator|->
name|frame_offset
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
else|#
directive|else
name|function
operator|->
name|frame_offset
operator|=
name|CEIL_ROUND
argument_list|(
name|function
operator|->
name|frame_offset
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* On a big-endian machine, if we are allocating more space than we will use,      use the least significant bytes of those that are allocated.  */
if|#
directive|if
name|BYTES_BIG_ENDIAN
if|if
condition|(
name|mode
operator|!=
name|BLKmode
condition|)
name|bigend_correction
operator|=
name|size
operator|-
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|FRAME_GROWS_DOWNWARD
name|function
operator|->
name|frame_offset
operator|-=
name|size
expr_stmt|;
endif|#
directive|endif
name|addr
operator|=
name|plus_constant
argument_list|(
name|virtual_stack_vars_rtx
argument_list|,
name|function
operator|->
name|frame_offset
operator|+
name|bigend_correction
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|FRAME_GROWS_DOWNWARD
name|function
operator|->
name|frame_offset
operator|+=
name|size
expr_stmt|;
endif|#
directive|endif
name|x
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|mode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|function
operator|->
name|stack_slot_list
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|VOIDmode
argument_list|,
name|x
argument_list|,
name|function
operator|->
name|stack_slot_list
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Allocate a temporary stack slot and record it for possible later    reuse.     MODE is the machine mode to be given to the returned rtx.     SIZE is the size in units of the space required.  We do no rounding here    since assign_stack_local will do any required rounding.     KEEP is non-zero if this slot is to be retained after a call to    free_temp_slots.  Automatic variables for a block are allocated with this    flag.  */
end_comment

begin_function
name|rtx
name|assign_stack_temp
parameter_list|(
name|mode
parameter_list|,
name|size
parameter_list|,
name|keep
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|keep
decl_stmt|;
block|{
name|struct
name|temp_slot
modifier|*
name|p
decl_stmt|,
modifier|*
name|best_p
init|=
literal|0
decl_stmt|;
comment|/* First try to find an available, already-allocated temporary that is the      exact size we require.  */
for|for
control|(
name|p
operator|=
name|temp_slots
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|p
operator|->
name|size
operator|==
name|size
operator|&&
name|GET_MODE
argument_list|(
name|p
operator|->
name|slot
argument_list|)
operator|==
name|mode
operator|&&
operator|!
name|p
operator|->
name|in_use
condition|)
break|break;
comment|/* If we didn't find, one, try one that is larger than what we want.  We      find the smallest such.  */
if|if
condition|(
name|p
operator|==
literal|0
condition|)
for|for
control|(
name|p
operator|=
name|temp_slots
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|p
operator|->
name|size
operator|>
name|size
operator|&&
name|GET_MODE
argument_list|(
name|p
operator|->
name|slot
argument_list|)
operator|==
name|mode
operator|&&
operator|!
name|p
operator|->
name|in_use
operator|&&
operator|(
name|best_p
operator|==
literal|0
operator|||
name|best_p
operator|->
name|size
operator|>
name|p
operator|->
name|size
operator|)
condition|)
name|best_p
operator|=
name|p
expr_stmt|;
comment|/* Make our best, if any, the one to use.  */
if|if
condition|(
name|best_p
condition|)
name|p
operator|=
name|best_p
expr_stmt|;
comment|/* If we still didn't find one, make a new temporary.  */
if|if
condition|(
name|p
operator|==
literal|0
condition|)
block|{
name|p
operator|=
operator|(
expr|struct
name|temp_slot
operator|*
operator|)
name|oballoc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|temp_slot
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|size
operator|=
name|size
expr_stmt|;
comment|/* If the temp slot mode doesn't indicate the alignment, 	 use the largest possible, so no one will be disappointed.  */
name|p
operator|->
name|slot
operator|=
name|assign_stack_local
argument_list|(
name|mode
argument_list|,
name|size
argument_list|,
name|mode
operator|==
name|BLKmode
condition|?
operator|-
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|temp_slots
expr_stmt|;
name|temp_slots
operator|=
name|p
expr_stmt|;
block|}
name|p
operator|->
name|in_use
operator|=
literal|1
expr_stmt|;
name|p
operator|->
name|level
operator|=
name|temp_slot_level
expr_stmt|;
name|p
operator|->
name|keep
operator|=
name|keep
expr_stmt|;
return|return
name|p
operator|->
name|slot
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If X could be a reference to a temporary slot, mark that slot as belonging    to the to one level higher.  If X matched one of our slots, just mark that    one.  Otherwise, we can't easily predict which it is, so upgrade all of    them.  Kept slots need not be touched.     This is called when an ({...}) construct occurs and a statement    returns a value in memory.  */
end_comment

begin_function
name|void
name|preserve_temp_slots
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|struct
name|temp_slot
modifier|*
name|p
decl_stmt|;
comment|/* If X is not in memory or is at a constant address, it cannot be in      a temporary slot.  */
if|if
condition|(
name|x
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
operator|||
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return;
comment|/* First see if we can find a match.  */
for|for
control|(
name|p
operator|=
name|temp_slots
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|p
operator|->
name|in_use
operator|&&
name|x
operator|==
name|p
operator|->
name|slot
condition|)
block|{
name|p
operator|->
name|level
operator|--
expr_stmt|;
return|return;
block|}
comment|/* Otherwise, preserve all non-kept slots at this level.  */
for|for
control|(
name|p
operator|=
name|temp_slots
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|p
operator|->
name|in_use
operator|&&
name|p
operator|->
name|level
operator|==
name|temp_slot_level
operator|&&
operator|!
name|p
operator|->
name|keep
condition|)
name|p
operator|->
name|level
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free all temporaries used so far.  This is normally called at the end    of generating code for a statement.  */
end_comment

begin_function
name|void
name|free_temp_slots
parameter_list|()
block|{
name|struct
name|temp_slot
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|temp_slots
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|p
operator|->
name|in_use
operator|&&
name|p
operator|->
name|level
operator|==
name|temp_slot_level
operator|&&
operator|!
name|p
operator|->
name|keep
condition|)
name|p
operator|->
name|in_use
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Push deeper into the nesting level for stack temporaries.  */
end_comment

begin_function
name|void
name|push_temp_slots
parameter_list|()
block|{
comment|/* For GNU C++, we must allow a sequence to be emitted anywhere in      the level where the sequence was started.  By not changing levels      when the compiler is inside a sequence, the temporaries for the      sequence and the temporaries will not unwittingly conflict with      the temporaries for other sequences and/or code at that level.  */
if|if
condition|(
name|in_sequence_p
argument_list|()
condition|)
return|return;
name|temp_slot_level
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pop a temporary nesting level.  All slots in use in the current level    are freed.  */
end_comment

begin_function
name|void
name|pop_temp_slots
parameter_list|()
block|{
name|struct
name|temp_slot
modifier|*
name|p
decl_stmt|;
comment|/* See comment in push_temp_slots about why we don't change levels      in sequences.  */
if|if
condition|(
name|in_sequence_p
argument_list|()
condition|)
return|return;
for|for
control|(
name|p
operator|=
name|temp_slots
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|p
operator|->
name|in_use
operator|&&
name|p
operator|->
name|level
operator|==
name|temp_slot_level
condition|)
name|p
operator|->
name|in_use
operator|=
literal|0
expr_stmt|;
name|temp_slot_level
operator|--
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Retroactively move an auto variable from a register to a stack slot.    This is done when an address-reference to the variable is seen.  */
end_comment

begin_function
name|void
name|put_var_into_stack
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
specifier|register
name|rtx
name|reg
decl_stmt|;
specifier|register
name|rtx
name|new
init|=
literal|0
decl_stmt|;
name|enum
name|machine_mode
name|promoted_mode
decl_stmt|,
name|decl_mode
decl_stmt|;
name|struct
name|function
modifier|*
name|function
init|=
literal|0
decl_stmt|;
name|tree
name|context
init|=
name|decl_function_context
argument_list|(
name|decl
argument_list|)
decl_stmt|;
comment|/* Get the current rtl used for this object and it's original mode.  */
name|reg
operator|=
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|SAVE_EXPR
condition|?
name|SAVE_EXPR_RTL
argument_list|(
name|decl
argument_list|)
else|:
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* No need to do anything if decl has no rtx yet      since in that case caller is setting TREE_ADDRESSABLE      and a stack slot will be assigned when the rtl is made.  */
if|if
condition|(
name|reg
operator|==
literal|0
condition|)
return|return;
comment|/* Get the declared mode for this object.  */
name|decl_mode
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|SAVE_EXPR
condition|?
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
else|:
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
operator|)
expr_stmt|;
comment|/* Get the mode it's actually stored in.  */
name|promoted_mode
operator|=
name|GET_MODE
argument_list|(
name|reg
argument_list|)
expr_stmt|;
comment|/* If this variable comes from an outer function,      find that function's saved context.  */
if|if
condition|(
name|context
operator|!=
name|current_function_decl
condition|)
for|for
control|(
name|function
operator|=
name|outer_function_chain
init|;
name|function
condition|;
name|function
operator|=
name|function
operator|->
name|next
control|)
if|if
condition|(
name|function
operator|->
name|decl
operator|==
name|context
condition|)
break|break;
comment|/* If this is a variable-size object with a pseudo to address it,      put that pseudo into the stack, if the var is nonlocal.  */
if|if
condition|(
name|DECL_NONLOCAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>
name|LAST_VIRTUAL_REGISTER
condition|)
block|{
name|reg
operator|=
name|XEXP
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|decl_mode
operator|=
name|promoted_mode
operator|=
name|GET_MODE
argument_list|(
name|reg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|!=
name|REG
condition|)
return|return;
if|if
condition|(
name|function
condition|)
block|{
if|if
condition|(
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|<
name|function
operator|->
name|max_parm_reg
condition|)
name|new
operator|=
name|function
operator|->
name|parm_reg_stack_loc
index|[
name|REGNO
argument_list|(
name|reg
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|new
operator|==
literal|0
condition|)
name|new
operator|=
name|assign_outer_stack_local
argument_list|(
name|decl_mode
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|decl_mode
argument_list|)
argument_list|,
literal|0
argument_list|,
name|function
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|<
name|max_parm_reg
condition|)
name|new
operator|=
name|parm_reg_stack_loc
index|[
name|REGNO
argument_list|(
name|reg
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|new
operator|==
literal|0
condition|)
name|new
operator|=
name|assign_stack_local
argument_list|(
name|decl_mode
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|decl_mode
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|XEXP
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|)
operator|=
name|XEXP
argument_list|(
name|new
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* `volatil' bit means one thing for MEMs, another entirely for REGs.  */
name|REG_USERVAR_P
argument_list|(
name|reg
argument_list|)
operator|=
literal|0
expr_stmt|;
name|PUT_CODE
argument_list|(
name|reg
argument_list|,
name|MEM
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|reg
argument_list|,
name|decl_mode
argument_list|)
expr_stmt|;
comment|/* If this is a memory ref that contains aggregate components,      mark it as such for cse and loop optimize.  */
name|MEM_IN_STRUCT_P
argument_list|(
name|reg
argument_list|)
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|QUAL_UNION_TYPE
operator|)
expr_stmt|;
comment|/* Now make sure that all refs to the variable, previously made      when it was a register, are fixed up to be valid again.  */
if|if
condition|(
name|function
condition|)
block|{
name|struct
name|var_refs_queue
modifier|*
name|temp
decl_stmt|;
comment|/* Variable is inherited; fix it up when we get back to its function.  */
name|push_obstacks
argument_list|(
name|function
operator|->
name|function_obstack
argument_list|,
name|function
operator|->
name|function_maybepermanent_obstack
argument_list|)
expr_stmt|;
name|temp
operator|=
operator|(
expr|struct
name|var_refs_queue
operator|*
operator|)
name|oballoc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|var_refs_queue
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|->
name|modified
operator|=
name|reg
expr_stmt|;
name|temp
operator|->
name|promoted_mode
operator|=
name|promoted_mode
expr_stmt|;
name|temp
operator|->
name|unsignedp
operator|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|->
name|next
operator|=
name|function
operator|->
name|fixup_var_refs_queue
expr_stmt|;
name|function
operator|->
name|fixup_var_refs_queue
operator|=
name|temp
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
else|else
comment|/* Variable is local; fix it up now.  */
name|fixup_var_refs
argument_list|(
name|reg
argument_list|,
name|promoted_mode
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|fixup_var_refs
parameter_list|(
name|var
parameter_list|,
name|promoted_mode
parameter_list|,
name|unsignedp
parameter_list|)
name|rtx
name|var
decl_stmt|;
name|enum
name|machine_mode
name|promoted_mode
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
name|tree
name|pending
decl_stmt|;
name|rtx
name|first_insn
init|=
name|get_insns
argument_list|()
decl_stmt|;
name|struct
name|sequence_stack
modifier|*
name|stack
init|=
name|sequence_stack
decl_stmt|;
name|tree
name|rtl_exps
init|=
name|rtl_expr_chain
decl_stmt|;
comment|/* Must scan all insns for stack-refs that exceed the limit.  */
name|fixup_var_refs_insns
argument_list|(
name|var
argument_list|,
name|promoted_mode
argument_list|,
name|unsignedp
argument_list|,
name|first_insn
argument_list|,
name|stack
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* Scan all pending sequences too.  */
for|for
control|(
init|;
name|stack
condition|;
name|stack
operator|=
name|stack
operator|->
name|next
control|)
block|{
name|push_to_sequence
argument_list|(
name|stack
operator|->
name|first
argument_list|)
expr_stmt|;
name|fixup_var_refs_insns
argument_list|(
name|var
argument_list|,
name|promoted_mode
argument_list|,
name|unsignedp
argument_list|,
name|stack
operator|->
name|first
argument_list|,
name|stack
operator|->
name|next
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* Update remembered end of sequence 	 in case we added an insn at the end.  */
name|stack
operator|->
name|last
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
block|}
comment|/* Scan all waiting RTL_EXPRs too.  */
for|for
control|(
name|pending
operator|=
name|rtl_exps
init|;
name|pending
condition|;
name|pending
operator|=
name|TREE_CHAIN
argument_list|(
name|pending
argument_list|)
control|)
block|{
name|rtx
name|seq
init|=
name|RTL_EXPR_SEQUENCE
argument_list|(
name|TREE_VALUE
argument_list|(
name|pending
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|seq
operator|!=
name|const0_rtx
operator|&&
name|seq
operator|!=
literal|0
condition|)
block|{
name|push_to_sequence
argument_list|(
name|seq
argument_list|)
expr_stmt|;
name|fixup_var_refs_insns
argument_list|(
name|var
argument_list|,
name|promoted_mode
argument_list|,
name|unsignedp
argument_list|,
name|seq
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This structure is used by the following two functions to record MEMs or    pseudos used to replace VAR, any SUBREGs of VAR, and any MEMs containing    VAR as an address.  We need to maintain this list in case two operands of    an insn were required to match; in that case we must ensure we use the    same replacement.  */
end_comment

begin_struct
struct|struct
name|fixup_replacement
block|{
name|rtx
name|old
decl_stmt|;
name|rtx
name|new
decl_stmt|;
name|struct
name|fixup_replacement
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* REPLACEMENTS is a pointer to a list of the above structures and X is    some part of an insn.  Return a struct fixup_replacement whose OLD    value is equal to X.  Allocate a new structure if no such entry exists. */
end_comment

begin_function
specifier|static
name|struct
name|fixup_replacement
modifier|*
name|find_fixup_replacement
parameter_list|(
name|replacements
parameter_list|,
name|x
parameter_list|)
name|struct
name|fixup_replacement
modifier|*
modifier|*
name|replacements
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
name|struct
name|fixup_replacement
modifier|*
name|p
decl_stmt|;
comment|/* See if we have already replaced this.  */
for|for
control|(
name|p
operator|=
operator|*
name|replacements
init|;
name|p
operator|&&
name|p
operator|->
name|old
operator|!=
name|x
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
empty_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
block|{
name|p
operator|=
operator|(
expr|struct
name|fixup_replacement
operator|*
operator|)
name|oballoc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|fixup_replacement
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|old
operator|=
name|x
expr_stmt|;
name|p
operator|->
name|new
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|next
operator|=
operator|*
name|replacements
expr_stmt|;
operator|*
name|replacements
operator|=
name|p
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Scan the insn-chain starting with INSN for refs to VAR    and fix them up.  TOPLEVEL is nonzero if this chain is the    main chain of insns for the current function.  */
end_comment

begin_function
specifier|static
name|void
name|fixup_var_refs_insns
parameter_list|(
name|var
parameter_list|,
name|promoted_mode
parameter_list|,
name|unsignedp
parameter_list|,
name|insn
parameter_list|,
name|toplevel
parameter_list|)
name|rtx
name|var
decl_stmt|;
name|enum
name|machine_mode
name|promoted_mode
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|toplevel
decl_stmt|;
block|{
name|rtx
name|call_dest
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|insn
condition|)
block|{
name|rtx
name|next
init|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|note
decl_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
block|{
comment|/* The insn to load VAR from a home in the arglist 	     is now a no-op.  When we see it, just delete it.  */
if|if
condition|(
name|toplevel
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|var
comment|/* If this represents the result of an insn group, 		 don't delete the insn.  */
operator|&&
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
operator|==
literal|0
operator|&&
name|rtx_equal_p
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
name|var
argument_list|)
condition|)
block|{
comment|/* In unoptimized compilation, we shouldn't call delete_insn 		 except in jump.c doing warnings.  */
name|PUT_CODE
argument_list|(
name|insn
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|last_parm_insn
condition|)
name|last_parm_insn
operator|=
name|PREV_INSN
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|fixup_replacement
modifier|*
name|replacements
init|=
literal|0
decl_stmt|;
name|rtx
name|next_insn
init|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|SMALL_REGISTER_CLASSES
comment|/* If the insn that copies the results of a CALL_INSN 		 into a pseudo now references VAR, we have to use an 		 intermediate pseudo since we want the life of the 		 return value register to be only a single insn.  		 If we don't use an intermediate pseudo, such things as 		 address computations to make the address of VAR valid 		 if it is not can be placed beween the CALL_INSN and INSN.  		 To make sure this doesn't happen, we record the destination 		 of the CALL_INSN and see if the next insn uses both that 		 and VAR.  */
if|if
condition|(
name|call_dest
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|reg_mentioned_p
argument_list|(
name|var
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|&&
name|reg_mentioned_p
argument_list|(
name|call_dest
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|temp
init|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|call_dest
argument_list|)
argument_list|)
decl_stmt|;
name|emit_insn_before
argument_list|(
name|gen_move_insn
argument_list|(
name|temp
argument_list|,
name|call_dest
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|replace_rtx
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|call_dest
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
name|call_dest
operator|=
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
name|call_dest
operator|=
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|call_dest
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* See if we have to do anything to INSN now that VAR is in 		 memory.  If it needs to be loaded into a pseudo, use a single 		 pseudo for the entire insn in case there is a MATCH_DUP 		 between two operands.  We pass a pointer to the head of 		 a list of struct fixup_replacements.  If fixup_var_refs_1 		 needs to allocate pseudos or replacement MEMs (for SUBREGs), 		 it will record them in this list. 		  		 If it allocated a pseudo for any replacement, we copy into 		 it here.  */
name|fixup_var_refs_1
argument_list|(
name|var
argument_list|,
name|promoted_mode
argument_list|,
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|,
operator|&
name|replacements
argument_list|)
expr_stmt|;
comment|/* If this is last_parm_insn, and any instructions were output 		 after it to fix it up, then we must set last_parm_insn to 		 the last such instruction emitted.  */
if|if
condition|(
name|insn
operator|==
name|last_parm_insn
condition|)
name|last_parm_insn
operator|=
name|PREV_INSN
argument_list|(
name|next_insn
argument_list|)
expr_stmt|;
while|while
condition|(
name|replacements
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|replacements
operator|->
name|new
argument_list|)
operator|==
name|REG
condition|)
block|{
name|rtx
name|insert_before
decl_stmt|;
name|rtx
name|seq
decl_stmt|;
comment|/* OLD might be a (subreg (mem)).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|replacements
operator|->
name|old
argument_list|)
operator|==
name|SUBREG
condition|)
name|replacements
operator|->
name|old
operator|=
name|fixup_memory_subreg
argument_list|(
name|replacements
operator|->
name|old
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|replacements
operator|->
name|old
operator|=
name|fixup_stack_1
argument_list|(
name|replacements
operator|->
name|old
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* We can not separate USE insns from the CALL_INSN 			 that they belong to.  If this is a CALL_INSN, insert 			 the move insn before the USE insns preceding it 			 instead of immediately before the insn.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|insert_before
operator|=
name|insn
expr_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|PREV_INSN
argument_list|(
name|insert_before
argument_list|)
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|PREV_INSN
argument_list|(
name|insert_before
argument_list|)
argument_list|)
argument_list|)
operator|==
name|USE
condition|)
name|insert_before
operator|=
name|PREV_INSN
argument_list|(
name|insert_before
argument_list|)
expr_stmt|;
block|}
else|else
name|insert_before
operator|=
name|insn
expr_stmt|;
comment|/* If we are changing the mode, do a conversion. 			 This might be wasteful, but combine.c will 			 eliminate much of the waste.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|replacements
operator|->
name|new
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|replacements
operator|->
name|old
argument_list|)
condition|)
block|{
name|start_sequence
argument_list|()
expr_stmt|;
name|convert_move
argument_list|(
name|replacements
operator|->
name|new
argument_list|,
name|replacements
operator|->
name|old
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|seq
operator|=
name|gen_sequence
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
block|}
else|else
name|seq
operator|=
name|gen_move_insn
argument_list|(
name|replacements
operator|->
name|new
argument_list|,
name|replacements
operator|->
name|old
argument_list|)
expr_stmt|;
name|emit_insn_before
argument_list|(
name|seq
argument_list|,
name|insert_before
argument_list|)
expr_stmt|;
block|}
name|replacements
operator|=
name|replacements
operator|->
name|next
expr_stmt|;
block|}
block|}
comment|/* Also fix up any invalid exprs in the REG_NOTES of this insn. 	     But don't touch other insns referred to by reg-notes; 	     we will get them elsewhere.  */
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|note
argument_list|)
operator|!=
name|INSN_LIST
condition|)
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
operator|=
name|walk_fixup_memory_subreg
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|insn
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* VAR is a MEM that used to be a pseudo register with mode PROMOTED_MODE.    See if the rtx expression at *LOC in INSN needs to be changed.       REPLACEMENTS is a pointer to a list head that starts out zero, but may    contain a list of original rtx's and replacements. If we find that we need    to modify this insn by replacing a memory reference with a pseudo or by    making a new MEM to implement a SUBREG, we consult that list to see if    we have already chosen a replacement. If none has already been allocated,    we allocate it and update the list.  fixup_var_refs_insns will copy VAR    or the SUBREG, as appropriate, to the pseudo.  */
end_comment

begin_function
specifier|static
name|void
name|fixup_var_refs_1
parameter_list|(
name|var
parameter_list|,
name|promoted_mode
parameter_list|,
name|loc
parameter_list|,
name|insn
parameter_list|,
name|replacements
parameter_list|)
specifier|register
name|rtx
name|var
decl_stmt|;
name|enum
name|machine_mode
name|promoted_mode
decl_stmt|;
specifier|register
name|rtx
modifier|*
name|loc
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|struct
name|fixup_replacement
modifier|*
modifier|*
name|replacements
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|rtx
name|x
init|=
operator|*
name|loc
decl_stmt|;
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
specifier|register
name|rtx
name|tem
decl_stmt|,
name|tem1
decl_stmt|;
name|struct
name|fixup_replacement
modifier|*
name|replacement
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|MEM
case|:
if|if
condition|(
name|var
operator|==
name|x
condition|)
block|{
comment|/* If we already have a replacement, use it.  Otherwise,  	     try to fix up this address in case it is invalid.  */
name|replacement
operator|=
name|find_fixup_replacement
argument_list|(
name|replacements
argument_list|,
name|var
argument_list|)
expr_stmt|;
if|if
condition|(
name|replacement
operator|->
name|new
condition|)
block|{
operator|*
name|loc
operator|=
name|replacement
operator|->
name|new
expr_stmt|;
return|return;
block|}
operator|*
name|loc
operator|=
name|replacement
operator|->
name|new
operator|=
name|x
operator|=
name|fixup_stack_1
argument_list|(
name|x
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* Unless we are forcing memory to register or we changed the mode, 	     we can leave things the way they are if the insn is valid.  */
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|flag_force_mem
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|promoted_mode
operator|&&
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|>=
literal|0
condition|)
return|return;
operator|*
name|loc
operator|=
name|replacement
operator|->
name|new
operator|=
name|gen_reg_rtx
argument_list|(
name|promoted_mode
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If X contains VAR, we need to unshare it here so that we update 	 each occurrence separately.  But all identical MEMs in one insn 	 must be replaced with the same rtx because of the possibility of 	 MATCH_DUPs.  */
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|var
argument_list|,
name|x
argument_list|)
condition|)
block|{
name|replacement
operator|=
name|find_fixup_replacement
argument_list|(
name|replacements
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|replacement
operator|->
name|new
operator|==
literal|0
condition|)
name|replacement
operator|->
name|new
operator|=
name|copy_most_rtx
argument_list|(
name|x
argument_list|,
name|var
argument_list|)
expr_stmt|;
operator|*
name|loc
operator|=
name|x
operator|=
name|replacement
operator|->
name|new
expr_stmt|;
block|}
break|break;
case|case
name|REG
case|:
case|case
name|CC0
case|:
case|case
name|PC
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|CONST_DOUBLE
case|:
return|return;
case|case
name|SIGN_EXTRACT
case|:
case|case
name|ZERO_EXTRACT
case|:
comment|/* Note that in some cases those types of expressions are altered 	 by optimize_bit_field, and do not survive to get here.  */
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|var
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|var
operator|)
condition|)
block|{
comment|/* Get TEM as a valid MEM in the mode presently in the insn.  	     We don't worry about the possibility of MATCH_DUP here; it 	     is highly unlikely and would be tricky to handle.  */
name|tem
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|SUBREG
condition|)
name|tem
operator|=
name|fixup_memory_subreg
argument_list|(
name|tem
argument_list|,
name|insn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tem
operator|=
name|fixup_stack_1
argument_list|(
name|tem
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* Unless we want to load from memory, get TEM into the proper mode 	     for an extract from memory.  This can only be done if the 	     extract is at a constant position and length.  */
if|if
condition|(
operator|!
name|flag_force_mem
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|!
name|mode_dependent_address_p
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|!
name|MEM_VOLATILE_P
argument_list|(
name|tem
argument_list|)
condition|)
block|{
name|enum
name|machine_mode
name|wanted_mode
init|=
name|VOIDmode
decl_stmt|;
name|enum
name|machine_mode
name|is_mode
init|=
name|GET_MODE
argument_list|(
name|tem
argument_list|)
decl_stmt|;
name|int
name|width
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|pos
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_extzv
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
name|wanted_mode
operator|=
name|insn_operand_mode
index|[
operator|(
name|int
operator|)
name|CODE_FOR_extzv
index|]
index|[
literal|1
index|]
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_extv
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SIGN_EXTRACT
condition|)
name|wanted_mode
operator|=
name|insn_operand_mode
index|[
operator|(
name|int
operator|)
name|CODE_FOR_extv
index|]
index|[
literal|1
index|]
expr_stmt|;
endif|#
directive|endif
comment|/* If we have a narrower mode, we can do something.  */
if|if
condition|(
name|wanted_mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|wanted_mode
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|is_mode
argument_list|)
condition|)
block|{
name|int
name|offset
init|=
name|pos
operator|/
name|BITS_PER_UNIT
decl_stmt|;
name|rtx
name|old_pos
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|rtx
name|newmem
decl_stmt|;
comment|/* If the bytes and bits are counted differently, we 		     must adjust the offset.  */
if|#
directive|if
name|BYTES_BIG_ENDIAN
operator|!=
name|BITS_BIG_ENDIAN
name|offset
operator|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|is_mode
argument_list|)
operator|-
name|GET_MODE_SIZE
argument_list|(
name|wanted_mode
argument_list|)
operator|-
name|offset
operator|)
expr_stmt|;
endif|#
directive|endif
name|pos
operator|%=
name|GET_MODE_BITSIZE
argument_list|(
name|wanted_mode
argument_list|)
expr_stmt|;
name|newmem
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|wanted_mode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|newmem
argument_list|)
operator|=
name|RTX_UNCHANGING_P
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|newmem
argument_list|)
operator|=
name|MEM_VOLATILE_P
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|newmem
argument_list|)
operator|=
name|MEM_IN_STRUCT_P
argument_list|(
name|tem
argument_list|)
expr_stmt|;
comment|/* Make the change and see if the insn remains valid.  */
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|newmem
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
operator|=
name|GEN_INT
argument_list|(
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|>=
literal|0
condition|)
return|return;
comment|/* Otherwise, restore old position.  XEXP (x, 0) will be 		     restored later.  */
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
operator|=
name|old_pos
expr_stmt|;
block|}
block|}
comment|/* If we get here, the bitfield extract insn can't accept a memory 	     reference.  Copy the input into a register.  */
name|tem1
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|tem
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn_before
argument_list|(
name|gen_move_insn
argument_list|(
name|tem1
argument_list|,
name|tem
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|tem1
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|SUBREG
case|:
if|if
condition|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
operator|==
name|var
condition|)
block|{
comment|/* If this is a special SUBREG made because VAR was promoted 	     from a wider mode, replace it with VAR and call ourself 	     recursively, this time saying that the object previously 	     had its current mode (by virtue of the SUBREG).  */
if|if
condition|(
name|SUBREG_PROMOTED_VAR_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
operator|*
name|loc
operator|=
name|var
expr_stmt|;
name|fixup_var_refs_1
argument_list|(
name|var
argument_list|,
name|GET_MODE
argument_list|(
name|var
argument_list|)
argument_list|,
name|loc
argument_list|,
name|insn
argument_list|,
name|replacements
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If this SUBREG makes VAR wider, it has become a paradoxical 	     SUBREG with VAR in memory, but these aren't allowed at this  	     stage of the compilation.  So load VAR into a pseudo and take 	     a SUBREG of that pseudo.  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|var
argument_list|)
argument_list|)
condition|)
block|{
name|replacement
operator|=
name|find_fixup_replacement
argument_list|(
name|replacements
argument_list|,
name|var
argument_list|)
expr_stmt|;
if|if
condition|(
name|replacement
operator|->
name|new
operator|==
literal|0
condition|)
name|replacement
operator|->
name|new
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
operator|=
name|replacement
operator|->
name|new
expr_stmt|;
return|return;
block|}
comment|/* See if we have already found a replacement for this SUBREG. 	     If so, use it.  Otherwise, make a MEM and see if the insn 	     is recognized.  If not, or if we should force MEM into a register, 	     make a pseudo for this SUBREG.  */
name|replacement
operator|=
name|find_fixup_replacement
argument_list|(
name|replacements
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|replacement
operator|->
name|new
condition|)
block|{
operator|*
name|loc
operator|=
name|replacement
operator|->
name|new
expr_stmt|;
return|return;
block|}
name|replacement
operator|->
name|new
operator|=
operator|*
name|loc
operator|=
name|fixup_memory_subreg
argument_list|(
name|x
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|flag_force_mem
operator|&&
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|>=
literal|0
condition|)
return|return;
operator|*
name|loc
operator|=
name|replacement
operator|->
name|new
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|SET
case|:
comment|/* First do special simplification of bit-field references.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
name|optimize_bit_field
argument_list|(
name|x
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
name|optimize_bit_field
argument_list|(
name|x
argument_list|,
name|insn
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
comment|/* If SET_DEST is now a paradoxical SUBREG, put the result of this 	 insn into a pseudo and store the low part of the pseudo into VAR. */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_REG
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|var
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|var
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|=
name|tem
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn_after
argument_list|(
name|gen_move_insn
argument_list|(
name|var
argument_list|,
name|gen_lowpart
argument_list|(
name|GET_MODE
argument_list|(
name|var
argument_list|)
argument_list|,
name|tem
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
break|break;
block|}
block|{
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|rtx
name|src
init|=
name|SET_SRC
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|rtx
name|outerdest
init|=
name|dest
decl_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
name|dest
operator|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|SUBREG
condition|)
name|src
operator|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If VAR does not appear at the top level of the SET 	   just scan the lower levels of the tree.  */
if|if
condition|(
name|src
operator|!=
name|var
operator|&&
name|dest
operator|!=
name|var
condition|)
break|break;
comment|/* We will need to rerecognize this insn.  */
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_insv
if|if
condition|(
name|GET_CODE
argument_list|(
name|outerdest
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|&&
name|dest
operator|==
name|var
condition|)
block|{
comment|/* Since this case will return, ensure we fixup all the 	       operands here.  */
name|fixup_var_refs_1
argument_list|(
name|var
argument_list|,
name|promoted_mode
argument_list|,
operator|&
name|XEXP
argument_list|(
name|outerdest
argument_list|,
literal|1
argument_list|)
argument_list|,
name|insn
argument_list|,
name|replacements
argument_list|)
expr_stmt|;
name|fixup_var_refs_1
argument_list|(
name|var
argument_list|,
name|promoted_mode
argument_list|,
operator|&
name|XEXP
argument_list|(
name|outerdest
argument_list|,
literal|2
argument_list|)
argument_list|,
name|insn
argument_list|,
name|replacements
argument_list|)
expr_stmt|;
name|fixup_var_refs_1
argument_list|(
name|var
argument_list|,
name|promoted_mode
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|insn
argument_list|,
name|replacements
argument_list|)
expr_stmt|;
name|tem
operator|=
name|XEXP
argument_list|(
name|outerdest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Clean up (SUBREG:SI (MEM:mode ...) 0) 	       that may appear inside a ZERO_EXTRACT. 	       This was legitimate when the MEM was a REG.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_REG
argument_list|(
name|tem
argument_list|)
operator|==
name|var
condition|)
name|tem
operator|=
name|fixup_memory_subreg
argument_list|(
name|tem
argument_list|,
name|insn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|tem
operator|=
name|fixup_stack_1
argument_list|(
name|tem
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|outerdest
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|outerdest
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|!
name|mode_dependent_address_p
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|!
name|MEM_VOLATILE_P
argument_list|(
name|tem
argument_list|)
condition|)
block|{
name|enum
name|machine_mode
name|wanted_mode
init|=
name|insn_operand_mode
index|[
operator|(
name|int
operator|)
name|CODE_FOR_insv
index|]
index|[
literal|0
index|]
decl_stmt|;
name|enum
name|machine_mode
name|is_mode
init|=
name|GET_MODE
argument_list|(
name|tem
argument_list|)
decl_stmt|;
name|int
name|width
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|outerdest
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|pos
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|outerdest
argument_list|,
literal|2
argument_list|)
argument_list|)
decl_stmt|;
comment|/* If we have a narrower mode, we can do something.  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|wanted_mode
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|is_mode
argument_list|)
condition|)
block|{
name|int
name|offset
init|=
name|pos
operator|/
name|BITS_PER_UNIT
decl_stmt|;
name|rtx
name|old_pos
init|=
name|XEXP
argument_list|(
name|outerdest
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|rtx
name|newmem
decl_stmt|;
if|#
directive|if
name|BYTES_BIG_ENDIAN
operator|!=
name|BITS_BIG_ENDIAN
name|offset
operator|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|is_mode
argument_list|)
operator|-
name|GET_MODE_SIZE
argument_list|(
name|wanted_mode
argument_list|)
operator|-
name|offset
operator|)
expr_stmt|;
endif|#
directive|endif
name|pos
operator|%=
name|GET_MODE_BITSIZE
argument_list|(
name|wanted_mode
argument_list|)
expr_stmt|;
name|newmem
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|wanted_mode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|newmem
argument_list|)
operator|=
name|RTX_UNCHANGING_P
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|newmem
argument_list|)
operator|=
name|MEM_VOLATILE_P
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|newmem
argument_list|)
operator|=
name|MEM_IN_STRUCT_P
argument_list|(
name|tem
argument_list|)
expr_stmt|;
comment|/* Make the change and see if the insn remains valid.  */
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
name|XEXP
argument_list|(
name|outerdest
argument_list|,
literal|0
argument_list|)
operator|=
name|newmem
expr_stmt|;
name|XEXP
argument_list|(
name|outerdest
argument_list|,
literal|2
argument_list|)
operator|=
name|GEN_INT
argument_list|(
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|>=
literal|0
condition|)
return|return;
comment|/* Otherwise, restore old position.  XEXP (x, 0) will be 		       restored later.  */
name|XEXP
argument_list|(
name|outerdest
argument_list|,
literal|2
argument_list|)
operator|=
name|old_pos
expr_stmt|;
block|}
block|}
comment|/* If we get here, the bit-field store doesn't allow memory 	       or isn't located at a constant position.  Load the value into 	       a register, do the store, and put it back into memory.  */
name|tem1
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|tem
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn_before
argument_list|(
name|gen_move_insn
argument_list|(
name|tem1
argument_list|,
name|tem
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|emit_insn_after
argument_list|(
name|gen_move_insn
argument_list|(
name|tem
argument_list|,
name|tem1
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|outerdest
argument_list|,
literal|0
argument_list|)
operator|=
name|tem1
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* STRICT_LOW_PART is a no-op on memory references 	   and it can cause combinations to be unrecognizable, 	   so eliminate it.  */
if|if
condition|(
name|dest
operator|==
name|var
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|=
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* A valid insn to copy VAR into or out of a register 	   must be left alone, to avoid an infinite loop here. 	   If the reference to VAR is by a subreg, fix that up, 	   since SUBREG is not valid for a memref. 	   Also fix up the address of the stack slot.  	   Note that we must not try to recognize the insn until 	   after we know that we have valid addresses and no 	   (subreg (mem ...) ...) constructs, since these interfere 	   with determining the validity of the insn.  */
if|if
condition|(
operator|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
operator|==
name|var
operator|||
operator|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_REG
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|var
operator|)
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
operator|||
operator|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
operator|)
operator|)
operator|&&
name|x
operator|==
name|single_set
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|pat
decl_stmt|;
name|replacement
operator|=
name|find_fixup_replacement
argument_list|(
name|replacements
argument_list|,
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|replacement
operator|->
name|new
condition|)
name|SET_SRC
argument_list|(
name|x
argument_list|)
operator|=
name|replacement
operator|->
name|new
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|SUBREG
condition|)
name|SET_SRC
argument_list|(
name|x
argument_list|)
operator|=
name|replacement
operator|->
name|new
operator|=
name|fixup_memory_subreg
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|SET_SRC
argument_list|(
name|x
argument_list|)
operator|=
name|replacement
operator|->
name|new
operator|=
name|fixup_stack_1
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|>=
literal|0
condition|)
return|return;
comment|/* INSN is not valid, but we know that we want to 	       copy SET_SRC (x) to SET_DEST (x) in some way.  So 	       we generate the move and see whether it requires more 	       than one insn.  If it does, we emit those insns and 	       delete INSN.  Otherwise, we an just replace the pattern  	       of INSN; we have already verified above that INSN has 	       no other function that to do X.  */
name|pat
operator|=
name|gen_move_insn
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SEQUENCE
condition|)
block|{
name|emit_insn_after
argument_list|(
name|pat
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|PUT_CODE
argument_list|(
name|insn
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|pat
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|==
name|var
operator|||
operator|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_REG
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|var
operator|)
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
operator|||
operator|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
operator|)
operator|)
operator|&&
name|x
operator|==
name|single_set
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|pat
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|SUBREG
condition|)
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|=
name|fixup_memory_subreg
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|=
name|fixup_stack_1
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|>=
literal|0
condition|)
return|return;
name|pat
operator|=
name|gen_move_insn
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SEQUENCE
condition|)
block|{
name|emit_insn_after
argument_list|(
name|pat
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|PUT_CODE
argument_list|(
name|insn
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|pat
expr_stmt|;
return|return;
block|}
comment|/* Otherwise, storing into VAR must be handled specially 	   by storing into a temporary and copying that into VAR 	   with a new insn after this one.  Note that this case 	   will be used when storing into a promoted scalar since 	   the insn will now have different modes on the input 	   and output and hence will be invalid (except for the case 	   of setting it to a constant, which does not need any 	   change if it is valid).  We generate extra code in that case, 	   but combine.c will eliminate it.  */
if|if
condition|(
name|dest
operator|==
name|var
condition|)
block|{
name|rtx
name|temp
decl_stmt|;
name|rtx
name|fixeddest
init|=
name|SET_DEST
argument_list|(
name|x
argument_list|)
decl_stmt|;
comment|/* STRICT_LOW_PART can be discarded, around a MEM.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|fixeddest
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|fixeddest
operator|=
name|XEXP
argument_list|(
name|fixeddest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Convert (SUBREG (MEM)) to a MEM in a changed mode.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|fixeddest
argument_list|)
operator|==
name|SUBREG
condition|)
name|fixeddest
operator|=
name|fixup_memory_subreg
argument_list|(
name|fixeddest
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|fixeddest
operator|=
name|fixup_stack_1
argument_list|(
name|fixeddest
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|VOIDmode
condition|?
name|GET_MODE
argument_list|(
name|fixeddest
argument_list|)
else|:
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn_after
argument_list|(
name|gen_move_insn
argument_list|(
name|fixeddest
argument_list|,
name|gen_lowpart
argument_list|(
name|GET_MODE
argument_list|(
name|fixeddest
argument_list|)
argument_list|,
name|temp
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|=
name|temp
expr_stmt|;
block|}
block|}
block|}
comment|/* Nothing special about this RTX; fix its operands.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|fixup_var_refs_1
argument_list|(
name|var
argument_list|,
name|promoted_mode
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|,
name|replacements
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|fixup_var_refs_1
argument_list|(
name|var
argument_list|,
name|promoted_mode
argument_list|,
operator|&
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|insn
argument_list|,
name|replacements
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given X, an rtx of the form (SUBREG:m1 (MEM:m2 addr)),    return an rtx (MEM:m1 newaddr) which is equivalent.    If any insns must be emitted to compute NEWADDR, put them before INSN.     UNCRITICAL nonzero means accept paradoxical subregs.    This is used for subregs found inside of ZERO_EXTRACTs and in REG_NOTES. */
end_comment

begin_function
specifier|static
name|rtx
name|fixup_memory_subreg
parameter_list|(
name|x
parameter_list|,
name|insn
parameter_list|,
name|uncritical
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|uncritical
decl_stmt|;
block|{
name|int
name|offset
init|=
name|SUBREG_WORD
argument_list|(
name|x
argument_list|)
operator|*
name|UNITS_PER_WORD
decl_stmt|;
name|rtx
name|addr
init|=
name|XEXP
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|rtx
name|saved
decl_stmt|,
name|result
decl_stmt|;
comment|/* Paradoxical SUBREGs are usually invalid during RTL generation.  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|!
name|uncritical
condition|)
name|abort
argument_list|()
expr_stmt|;
if|#
directive|if
name|BYTES_BIG_ENDIAN
name|offset
operator|+=
operator|(
name|MIN
argument_list|(
name|UNITS_PER_WORD
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|-
name|MIN
argument_list|(
name|UNITS_PER_WORD
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|)
operator|)
expr_stmt|;
endif|#
directive|endif
name|addr
operator|=
name|plus_constant
argument_list|(
name|addr
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flag_force_addr
operator|&&
name|memory_address_p
argument_list|(
name|mode
argument_list|,
name|addr
argument_list|)
condition|)
comment|/* Shortcut if no insns need be emitted.  */
return|return
name|change_address
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|,
name|mode
argument_list|,
name|addr
argument_list|)
return|;
name|start_sequence
argument_list|()
expr_stmt|;
name|result
operator|=
name|change_address
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|,
name|mode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|emit_insn_before
argument_list|(
name|gen_sequence
argument_list|()
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Do fixup_memory_subreg on all (SUBREG (MEM ...) ...) contained in X.    Replace subexpressions of X in place.    If X itself is a (SUBREG (MEM ...) ...), return the replacement expression.    Otherwise return X, with its contents possibly altered.     If any insns must be emitted to compute NEWADDR, put them before INSN.      UNCRITICAL is as in fixup_memory_subreg.  */
end_comment

begin_function
specifier|static
name|rtx
name|walk_fixup_memory_subreg
parameter_list|(
name|x
parameter_list|,
name|insn
parameter_list|,
name|uncritical
parameter_list|)
specifier|register
name|rtx
name|x
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|uncritical
decl_stmt|;
block|{
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
return|return
name|fixup_memory_subreg
argument_list|(
name|x
argument_list|,
name|insn
argument_list|,
name|uncritical
argument_list|)
return|;
comment|/* Nothing special about this RTX; fix its operands.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|=
name|walk_fixup_memory_subreg
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|,
name|uncritical
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
operator|=
name|walk_fixup_memory_subreg
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|insn
argument_list|,
name|uncritical
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Fix up any references to stack slots that are invalid memory addresses    because they exceed the maximum range of a displacement.  */
end_comment

begin_comment
unit|void fixup_stack_slots () {   register rtx insn;
comment|/* Did we generate a stack slot that is out of range      or otherwise has an invalid address?  */
end_comment

begin_comment
unit|if (invalid_stack_slot)     {
comment|/* Yes.  Must scan all insns for stack-refs that exceed the limit.  */
end_comment

begin_endif
unit|for (insn = get_insns (); insn; insn = NEXT_INSN (insn)) 	if (GET_CODE (insn) == INSN || GET_CODE (insn) == CALL_INSN 	    || GET_CODE (insn) == JUMP_INSN) 	  fixup_stack_1 (PATTERN (insn), insn);     } }
endif|#
directive|endif
end_endif

begin_comment
comment|/* For each memory ref within X, if it refers to a stack slot    with an out of range displacement, put the address in a temp register    (emitting new insns before INSN to load these registers)    and alter the memory ref to use that register.    Replace each such MEM rtx with a copy, to avoid clobberage.  */
end_comment

begin_function
specifier|static
name|rtx
name|fixup_stack_1
parameter_list|(
name|x
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|MEM
condition|)
block|{
specifier|register
name|rtx
name|ad
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* If we have address of a stack slot but it's not valid 	 (displacement is too large), compute the sum in a register.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|ad
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>=
name|FIRST_VIRTUAL_REGISTER
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<=
name|LAST_VIRTUAL_REGISTER
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|rtx
name|temp
decl_stmt|,
name|seq
decl_stmt|;
if|if
condition|(
name|memory_address_p
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|ad
argument_list|)
condition|)
return|return
name|x
return|;
name|start_sequence
argument_list|()
expr_stmt|;
name|temp
operator|=
name|copy_to_reg
argument_list|(
name|ad
argument_list|)
expr_stmt|;
name|seq
operator|=
name|gen_sequence
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insn_before
argument_list|(
name|seq
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return
name|change_address
argument_list|(
name|x
argument_list|,
name|VOIDmode
argument_list|,
name|temp
argument_list|)
return|;
block|}
return|return
name|x
return|;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|=
name|fixup_stack_1
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
operator|=
name|fixup_stack_1
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Optimization: a bit-field instruction whose field    happens to be a byte or halfword in memory    can be changed to a move instruction.     We call here when INSN is an insn to examine or store into a bit-field.    BODY is the SET-rtx to be altered.     EQUIV_MEM is the table `reg_equiv_mem' if that is available; else 0.    (Currently this is called only from function.c, and EQUIV_MEM    is always 0.)  */
end_comment

begin_function
specifier|static
name|void
name|optimize_bit_field
parameter_list|(
name|body
parameter_list|,
name|insn
parameter_list|,
name|equiv_mem
parameter_list|)
name|rtx
name|body
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|rtx
modifier|*
name|equiv_mem
decl_stmt|;
block|{
specifier|register
name|rtx
name|bitfield
decl_stmt|;
name|int
name|destflag
decl_stmt|;
name|rtx
name|seq
init|=
literal|0
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
name|bitfield
operator|=
name|SET_DEST
argument_list|(
name|body
argument_list|)
operator|,
name|destflag
operator|=
literal|1
expr_stmt|;
else|else
name|bitfield
operator|=
name|SET_SRC
argument_list|(
name|body
argument_list|)
operator|,
name|destflag
operator|=
literal|0
expr_stmt|;
comment|/* First check that the field being stored has constant size and position      and is in fact a byte or halfword suitably aligned.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
operator|(
name|mode
operator|=
name|mode_for_size
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|MODE_INT
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
name|BLKmode
operator|)
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|%
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|register
name|rtx
name|memref
init|=
literal|0
decl_stmt|;
comment|/* Now check that the containing word is memory, not a register, 	 and that it is safe to change the machine mode.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
name|memref
operator|=
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|equiv_mem
operator|!=
literal|0
condition|)
name|memref
operator|=
name|equiv_mem
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
name|memref
operator|=
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|equiv_mem
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|memref
operator|=
name|equiv_mem
index|[
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|memref
operator|&&
operator|!
name|mode_dependent_address_p
argument_list|(
name|XEXP
argument_list|(
name|memref
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|!
name|MEM_VOLATILE_P
argument_list|(
name|memref
argument_list|)
condition|)
block|{
comment|/* Now adjust the address, first for any subreg'ing 	     that we are now getting rid of, 	     and then for which byte of the word is wanted.  */
specifier|register
name|int
name|offset
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|2
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Adjust OFFSET to count bits from low-address byte.  */
if|#
directive|if
name|BITS_BIG_ENDIAN
operator|!=
name|BYTES_BIG_ENDIAN
name|offset
operator|=
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|-
name|offset
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* Adjust OFFSET to count bytes from low-address byte.  */
name|offset
operator|/=
name|BITS_PER_UNIT
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|offset
operator|+=
name|SUBREG_WORD
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|*
name|UNITS_PER_WORD
expr_stmt|;
if|#
directive|if
name|BYTES_BIG_ENDIAN
name|offset
operator|-=
operator|(
name|MIN
argument_list|(
name|UNITS_PER_WORD
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|bitfield
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|-
name|MIN
argument_list|(
name|UNITS_PER_WORD
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|memref
argument_list|)
argument_list|)
argument_list|)
operator|)
expr_stmt|;
endif|#
directive|endif
block|}
name|memref
operator|=
name|change_address
argument_list|(
name|memref
argument_list|,
name|mode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|memref
argument_list|,
literal|0
argument_list|)
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Store this memory reference where 	     we found the bit field reference.  */
if|if
condition|(
name|destflag
condition|)
block|{
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|,
name|memref
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CONSTANT_ADDRESS_P
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|src
init|=
name|SET_SRC
argument_list|(
name|body
argument_list|)
decl_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_WORD
argument_list|(
name|src
argument_list|)
operator|==
literal|0
condition|)
name|src
operator|=
name|SUBREG_REG
argument_list|(
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|memref
argument_list|)
condition|)
name|src
operator|=
name|gen_lowpart
argument_list|(
name|GET_MODE
argument_list|(
name|memref
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
expr_stmt|;
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
name|src
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|memref
argument_list|)
condition|)
comment|/* This shouldn't happen because anything that didn't have 		   one of these modes should have got converted explicitly 		   and then referenced through a subreg. 		   This is so because the original bit-field was 		   handled by agg_mode and so its tree structure had 		   the same mode that memref now has.  */
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|body
argument_list|)
decl_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_WORD
argument_list|(
name|dest
argument_list|)
operator|==
literal|0
condition|)
name|dest
operator|=
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|,
name|dest
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|memref
argument_list|)
condition|)
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
name|memref
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Convert the mem ref to the destination mode.  */
name|rtx
name|newreg
init|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|convert_move
argument_list|(
name|newreg
argument_list|,
name|memref
argument_list|,
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|ZERO_EXTRACT
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
name|newreg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* See if we can convert this extraction or insertion into 	     a simple move insn.  We might not be able to do so if this 	     was, for example, part of a PARALLEL.  	     If we succeed, write out any needed conversions.  If we fail, 	     it is hard to guess why we failed, so don't do anything 	     special; just let the optimization be suppressed.  */
if|if
condition|(
name|apply_change_group
argument_list|()
operator|&&
name|seq
condition|)
name|emit_insns_before
argument_list|(
name|seq
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* These routines are responsible for converting virtual register references    to the actual hard register references once RTL generation is complete.     The following four variables are used for communication between the    routines.  They contain the offsets of the virtual registers from their    respective hard registers.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|in_arg_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|var_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dynamic_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|out_arg_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* In most machines, the stack pointer register is equivalent to the bottom    of the stack.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|STACK_POINTER_OFFSET
end_ifndef

begin_define
define|#
directive|define
name|STACK_POINTER_OFFSET
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* If not defined, pick an appropriate default for the offset of dynamically    allocated memory depending on the value of ACCUMULATE_OUTGOING_ARGS,    REG_PARM_STACK_SPACE, and OUTGOING_REG_PARM_STACK_SPACE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|STACK_DYNAMIC_OFFSET
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|ACCUMULATE_OUTGOING_ARGS
end_ifdef

begin_comment
comment|/* The bottom of the stack points to the actual arguments.  If    REG_PARM_STACK_SPACE is defined, this includes the space for the register    parameters.  However, if OUTGOING_REG_PARM_STACK space is not defined,    stack space for register parameters is not pushed by the caller, but     rather part of the fixed stack areas and hence not included in    `current_function_outgoing_args_size'.  Nevertheless, we must allow    for it when allocating stack dynamic objects.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|REG_PARM_STACK_SPACE
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|OUTGOING_REG_PARM_STACK_SPACE
argument_list|)
end_if

begin_define
define|#
directive|define
name|STACK_DYNAMIC_OFFSET
parameter_list|(
name|FNDECL
parameter_list|)
define|\
value|(current_function_outgoing_args_size	\  + REG_PARM_STACK_SPACE (FNDECL) + (STACK_POINTER_OFFSET))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|STACK_DYNAMIC_OFFSET
parameter_list|(
name|FNDECL
parameter_list|)
define|\
value|(current_function_outgoing_args_size + (STACK_POINTER_OFFSET))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|STACK_DYNAMIC_OFFSET
parameter_list|(
name|FNDECL
parameter_list|)
value|STACK_POINTER_OFFSET
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Pass through the INSNS of function FNDECL and convert virtual register    references to hard register references.  */
end_comment

begin_function
name|void
name|instantiate_virtual_regs
parameter_list|(
name|fndecl
parameter_list|,
name|insns
parameter_list|)
name|tree
name|fndecl
decl_stmt|;
name|rtx
name|insns
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
comment|/* Compute the offsets to use for this function.  */
name|in_arg_offset
operator|=
name|FIRST_PARM_OFFSET
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|var_offset
operator|=
name|STARTING_FRAME_OFFSET
expr_stmt|;
name|dynamic_offset
operator|=
name|STACK_DYNAMIC_OFFSET
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|out_arg_offset
operator|=
name|STACK_POINTER_OFFSET
expr_stmt|;
comment|/* Scan all variables and parameters of this function.  For each that is      in memory, instantiate all virtual registers if the result is a valid      address.  If not, we do it later.  That will handle most uses of virtual      regs on many machines.  */
name|instantiate_decls
argument_list|(
name|fndecl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Initialize recognition, indicating that volatile is OK.  */
name|init_recog
argument_list|()
expr_stmt|;
comment|/* Scan through all the insns, instantiating every virtual register still      present.  */
for|for
control|(
name|insn
operator|=
name|insns
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|instantiate_virtual_regs_1
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|instantiate_virtual_regs_1
argument_list|(
operator|&
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Now instantiate the remaining register equivalences for debugging info.      These will not be valid addresses.  */
name|instantiate_decls
argument_list|(
name|fndecl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Indicate that, from now on, assign_stack_local should use      frame_pointer_rtx.  */
name|virtuals_instantiated
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Scan all decls in FNDECL (both variables and parameters) and instantiate    all virtual registers in their DECL_RTL's.     If VALID_ONLY, do this only if the resulting address is still valid.    Otherwise, always do it.  */
end_comment

begin_function
specifier|static
name|void
name|instantiate_decls
parameter_list|(
name|fndecl
parameter_list|,
name|valid_only
parameter_list|)
name|tree
name|fndecl
decl_stmt|;
name|int
name|valid_only
decl_stmt|;
block|{
name|tree
name|decl
decl_stmt|;
if|if
condition|(
name|DECL_INLINE
argument_list|(
name|fndecl
argument_list|)
condition|)
comment|/* When compiling an inline function, the obstack used for        rtl allocation is the maybepermanent_obstack.  Calling        `resume_temporary_allocation' switches us back to that        obstack while we process this function's parameters.  */
name|resume_temporary_allocation
argument_list|()
expr_stmt|;
comment|/* Process all parameters of the function.  */
for|for
control|(
name|decl
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
block|{
name|instantiate_decl
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
name|valid_only
argument_list|)
expr_stmt|;
name|instantiate_decl
argument_list|(
name|DECL_INCOMING_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
name|valid_only
argument_list|)
expr_stmt|;
block|}
comment|/* Now process all variables defined in the function or its subblocks. */
name|instantiate_decls_1
argument_list|(
name|DECL_INITIAL
argument_list|(
name|fndecl
argument_list|)
argument_list|,
name|valid_only
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_INLINE
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
comment|/* Save all rtl allocated for this function by raising the 	 high-water mark on the maybepermanent_obstack.  */
name|preserve_data
argument_list|()
expr_stmt|;
comment|/* All further rtl allocation is now done in the current_obstack.  */
name|rtl_in_current_obstack
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Subroutine of instantiate_decls: Process all decls in the given    BLOCK node and all its subblocks.  */
end_comment

begin_function
specifier|static
name|void
name|instantiate_decls_1
parameter_list|(
name|let
parameter_list|,
name|valid_only
parameter_list|)
name|tree
name|let
decl_stmt|;
name|int
name|valid_only
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
name|BLOCK_VARS
argument_list|(
name|let
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
name|instantiate_decl
argument_list|(
name|DECL_RTL
argument_list|(
name|t
argument_list|)
argument_list|,
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
name|valid_only
argument_list|)
expr_stmt|;
comment|/* Process all subblocks.  */
for|for
control|(
name|t
operator|=
name|BLOCK_SUBBLOCKS
argument_list|(
name|let
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
name|instantiate_decls_1
argument_list|(
name|t
argument_list|,
name|valid_only
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Subroutine of the preceding procedures: Given RTL representing a    decl and the size of the object, do any instantiation required.     If VALID_ONLY is non-zero, it means that the RTL should only be    changed if the new address is valid.  */
end_comment

begin_function
specifier|static
name|void
name|instantiate_decl
parameter_list|(
name|x
parameter_list|,
name|size
parameter_list|,
name|valid_only
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|valid_only
decl_stmt|;
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|addr
decl_stmt|;
comment|/* If this is not a MEM, no need to do anything.  Similarly if the      address is a constant or a register that is not a virtual register.  */
if|if
condition|(
name|x
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
condition|)
return|return;
name|addr
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|addr
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|REGNO
argument_list|(
name|addr
argument_list|)
operator|<
name|FIRST_VIRTUAL_REGISTER
operator|||
name|REGNO
argument_list|(
name|addr
argument_list|)
operator|>
name|LAST_VIRTUAL_REGISTER
operator|)
operator|)
condition|)
return|return;
comment|/* If we should only do this if the address is valid, copy the address.      We need to do this so we can undo any changes that might make the      address invalid.  This copy is unfortunate, but probably can't be      avoided.  */
if|if
condition|(
name|valid_only
condition|)
name|addr
operator|=
name|copy_rtx
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|instantiate_virtual_regs_1
argument_list|(
operator|&
name|addr
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|valid_only
condition|)
return|return;
comment|/* Now verify that the resulting address is valid for every integer or      floating-point mode up to and including SIZE bytes long.  We do this      since the object might be accessed in any mode and frame addresses      are shared.  */
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_INT
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|size
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
if|if
condition|(
operator|!
name|memory_address_p
argument_list|(
name|mode
argument_list|,
name|addr
argument_list|)
condition|)
return|return;
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_FLOAT
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|size
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
if|if
condition|(
operator|!
name|memory_address_p
argument_list|(
name|mode
argument_list|,
name|addr
argument_list|)
condition|)
return|return;
comment|/* Otherwise, put back the address, now that we have updated it and we      know it is valid.  */
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|addr
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a pointer to a piece of rtx and an optional pointer to the    containing object, instantiate any virtual registers present in it.     If EXTRA_INSNS, we always do the replacement and generate    any extra insns before OBJECT.  If it zero, we do nothing if replacement    is not valid.     Return 1 if we either had nothing to do or if we were able to do the    needed replacement.  Return 0 otherwise; we only return zero if     EXTRA_INSNS is zero.     We first try some simple transformations to avoid the creation of extra    pseudos.  */
end_comment

begin_function
specifier|static
name|int
name|instantiate_virtual_regs_1
parameter_list|(
name|loc
parameter_list|,
name|object
parameter_list|,
name|extra_insns
parameter_list|)
name|rtx
modifier|*
name|loc
decl_stmt|;
name|rtx
name|object
decl_stmt|;
name|int
name|extra_insns
decl_stmt|;
block|{
name|rtx
name|x
decl_stmt|;
name|RTX_CODE
name|code
decl_stmt|;
name|rtx
name|new
init|=
literal|0
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
name|rtx
name|seq
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
modifier|*
name|fmt
decl_stmt|;
comment|/* Re-start here to avoid recursion in common cases.  */
name|restart
label|:
name|x
operator|=
operator|*
name|loc
expr_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
literal|1
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* Check for some special cases.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CODE_LABEL
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|ASM_INPUT
case|:
case|case
name|ADDR_VEC
case|:
case|case
name|ADDR_DIFF_VEC
case|:
case|case
name|RETURN
case|:
return|return
literal|1
return|;
case|case
name|SET
case|:
comment|/* We are allowed to set the virtual registers.  This means that 	 that the actual register should receive the source minus the 	 appropriate offset.  This is used, for example, in the handling 	 of non-local gotos.  */
if|if
condition|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|==
name|virtual_incoming_args_rtx
condition|)
name|new
operator|=
name|arg_pointer_rtx
operator|,
name|offset
operator|=
operator|-
name|in_arg_offset
expr_stmt|;
elseif|else
if|if
condition|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|==
name|virtual_stack_vars_rtx
condition|)
name|new
operator|=
name|frame_pointer_rtx
operator|,
name|offset
operator|=
operator|-
name|var_offset
expr_stmt|;
elseif|else
if|if
condition|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|==
name|virtual_stack_dynamic_rtx
condition|)
name|new
operator|=
name|stack_pointer_rtx
operator|,
name|offset
operator|=
operator|-
name|dynamic_offset
expr_stmt|;
elseif|else
if|if
condition|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|==
name|virtual_outgoing_args_rtx
condition|)
name|new
operator|=
name|stack_pointer_rtx
operator|,
name|offset
operator|=
operator|-
name|out_arg_offset
expr_stmt|;
if|if
condition|(
name|new
condition|)
block|{
comment|/* The only valid sources here are PLUS or REG.  Just do 	     the simplest possible thing to handle them.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|PLUS
condition|)
name|abort
argument_list|()
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
name|temp
operator|=
name|force_operand
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
else|else
name|temp
operator|=
name|SET_SRC
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|temp
operator|=
name|force_operand
argument_list|(
name|plus_constant
argument_list|(
name|temp
argument_list|,
name|offset
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insns_before
argument_list|(
name|seq
argument_list|,
name|object
argument_list|)
expr_stmt|;
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|=
name|new
expr_stmt|;
if|if
condition|(
operator|!
name|validate_change
argument_list|(
name|object
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|extra_insns
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
name|instantiate_virtual_regs_1
argument_list|(
operator|&
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|object
argument_list|,
name|extra_insns
argument_list|)
expr_stmt|;
name|loc
operator|=
operator|&
name|SET_SRC
argument_list|(
name|x
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
case|case
name|PLUS
case|:
comment|/* Handle special case of virtual register plus constant.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|old
decl_stmt|;
comment|/* Check for (plus (plus VIRT foo) (const_int)) first.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|rtx
name|inner
init|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|inner
operator|==
name|virtual_incoming_args_rtx
condition|)
name|new
operator|=
name|arg_pointer_rtx
operator|,
name|offset
operator|=
name|in_arg_offset
expr_stmt|;
elseif|else
if|if
condition|(
name|inner
operator|==
name|virtual_stack_vars_rtx
condition|)
name|new
operator|=
name|frame_pointer_rtx
operator|,
name|offset
operator|=
name|var_offset
expr_stmt|;
elseif|else
if|if
condition|(
name|inner
operator|==
name|virtual_stack_dynamic_rtx
condition|)
name|new
operator|=
name|stack_pointer_rtx
operator|,
name|offset
operator|=
name|dynamic_offset
expr_stmt|;
elseif|else
if|if
condition|(
name|inner
operator|==
name|virtual_outgoing_args_rtx
condition|)
name|new
operator|=
name|stack_pointer_rtx
operator|,
name|offset
operator|=
name|out_arg_offset
expr_stmt|;
else|else
block|{
name|loc
operator|=
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
name|instantiate_virtual_regs_1
argument_list|(
operator|&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|object
argument_list|,
name|extra_insns
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|new
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|virtual_incoming_args_rtx
condition|)
name|new
operator|=
name|arg_pointer_rtx
operator|,
name|offset
operator|=
name|in_arg_offset
expr_stmt|;
elseif|else
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|virtual_stack_vars_rtx
condition|)
name|new
operator|=
name|frame_pointer_rtx
operator|,
name|offset
operator|=
name|var_offset
expr_stmt|;
elseif|else
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|virtual_stack_dynamic_rtx
condition|)
name|new
operator|=
name|stack_pointer_rtx
operator|,
name|offset
operator|=
name|dynamic_offset
expr_stmt|;
elseif|else
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|virtual_outgoing_args_rtx
condition|)
name|new
operator|=
name|stack_pointer_rtx
operator|,
name|offset
operator|=
name|out_arg_offset
expr_stmt|;
else|else
block|{
comment|/* We know the second operand is a constant.  Unless the 		 first operand is a REG (which has been already checked), 		 it needs to be checked.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
block|{
name|loc
operator|=
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
return|return
literal|1
return|;
block|}
name|old
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|new
expr_stmt|;
name|new
operator|=
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|offset
argument_list|)
expr_stmt|;
comment|/* If the new constant is zero, try to replace the sum with its 	     first operand.  */
if|if
condition|(
name|new
operator|==
name|const0_rtx
operator|&&
name|validate_change
argument_list|(
name|object
argument_list|,
name|loc
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Next try to replace constant with new one.  */
if|if
condition|(
operator|!
name|validate_change
argument_list|(
name|object
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|new
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|extra_insns
condition|)
block|{
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|old
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Otherwise copy the new constant into a register and replace 		 constant with that register.  */
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|validate_change
argument_list|(
name|object
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
condition|)
name|emit_insn_before
argument_list|(
name|gen_move_insn
argument_list|(
name|temp
argument_list|,
name|new
argument_list|)
argument_list|,
name|object
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* If that didn't work, replace this expression with a 		     register containing the sum.  */
name|new
operator|=
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|old
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|temp
operator|=
name|force_operand
argument_list|(
name|new
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insns_before
argument_list|(
name|seq
argument_list|,
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|validate_change
argument_list|(
name|object
argument_list|,
name|loc
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
operator|&&
operator|!
name|validate_replace_rtx
argument_list|(
name|x
argument_list|,
name|temp
argument_list|,
name|object
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
comment|/* Fall through to generic two-operand expression case.  */
case|case
name|EXPR_LIST
case|:
case|case
name|CALL
case|:
case|case
name|COMPARE
case|:
case|case
name|MINUS
case|:
case|case
name|MULT
case|:
case|case
name|DIV
case|:
case|case
name|UDIV
case|:
case|case
name|MOD
case|:
case|case
name|UMOD
case|:
case|case
name|AND
case|:
case|case
name|IOR
case|:
case|case
name|XOR
case|:
case|case
name|LSHIFT
case|:
case|case
name|ASHIFT
case|:
case|case
name|ROTATE
case|:
case|case
name|ASHIFTRT
case|:
case|case
name|LSHIFTRT
case|:
case|case
name|ROTATERT
case|:
case|case
name|NE
case|:
case|case
name|EQ
case|:
case|case
name|GE
case|:
case|case
name|GT
case|:
case|case
name|GEU
case|:
case|case
name|GTU
case|:
case|case
name|LE
case|:
case|case
name|LT
case|:
case|case
name|LEU
case|:
case|case
name|LTU
case|:
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|&&
operator|!
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|instantiate_virtual_regs_1
argument_list|(
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|object
argument_list|,
name|extra_insns
argument_list|)
expr_stmt|;
name|loc
operator|=
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
case|case
name|MEM
case|:
comment|/* Most cases of MEM that convert to valid addresses have already been 	 handled by our scan of regno_reg_rtx.  The only special handling we 	 need here is to make a copy of the rtx to ensure it isn't being 	 shared if we have to change it to a pseudo.   	 If the rtx is a simple reference to an address via a virtual register, 	 it can potentially be shared.  In such cases, first try to make it 	 a valid address, which can also be shared.  Otherwise, copy it and 	 proceed normally.   	 First check for common cases that need no processing.  These are 	 usually due to instantiation already being done on a previous instance 	 of a shared rtx.  */
name|temp
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|temp
argument_list|)
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|ARG_POINTER_REGNUM
operator|||
name|temp
operator|==
name|arg_pointer_rtx
endif|#
directive|endif
operator|||
name|temp
operator|==
name|frame_pointer_rtx
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|PLUS
operator|&&
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
operator|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
operator|==
name|frame_pointer_rtx
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|ARG_POINTER_REGNUM
operator|||
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
operator|==
name|arg_pointer_rtx
endif|#
directive|endif
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|temp
operator|==
name|virtual_stack_vars_rtx
operator|||
name|temp
operator|==
name|virtual_incoming_args_rtx
operator|||
operator|(
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|PLUS
operator|&&
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
operator|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
operator|==
name|virtual_stack_vars_rtx
operator|||
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
operator|==
name|virtual_incoming_args_rtx
operator|)
operator|)
condition|)
block|{
comment|/* This MEM may be shared.  If the substitution can be done without 	     the need to generate new pseudos, we want to do it in place 	     so all copies of the shared rtx benefit.  The call below will 	     only make substitutions if the resulting address is still 	     valid.  	     Note that we cannot pass X as the object in the recursive call 	     since the insn being processed may not allow all valid 	     addresses.  However, if we were not passed on object, we can 	     only modify X without copying it if X will have a valid 	     address.  	     ??? Also note that this can still lose if OBJECT is an insn that 	     has less restrictions on an address that some other insn. 	     In that case, we will modify the shared address.  This case 	     doesn't seem very likely, though.  */
if|if
condition|(
name|instantiate_virtual_regs_1
argument_list|(
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|object
condition|?
name|object
else|:
name|x
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Otherwise make a copy and process that copy.  We copy the entire 	     RTL expression since it might be a PLUS which could also be 	     shared.  */
operator|*
name|loc
operator|=
name|x
operator|=
name|copy_rtx
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
comment|/* Fall through to generic unary operation case.  */
case|case
name|USE
case|:
case|case
name|CLOBBER
case|:
case|case
name|SUBREG
case|:
case|case
name|STRICT_LOW_PART
case|:
case|case
name|NEG
case|:
case|case
name|NOT
case|:
case|case
name|PRE_DEC
case|:
case|case
name|PRE_INC
case|:
case|case
name|POST_DEC
case|:
case|case
name|POST_INC
case|:
case|case
name|SIGN_EXTEND
case|:
case|case
name|ZERO_EXTEND
case|:
case|case
name|TRUNCATE
case|:
case|case
name|FLOAT_EXTEND
case|:
case|case
name|FLOAT_TRUNCATE
case|:
case|case
name|FLOAT
case|:
case|case
name|FIX
case|:
case|case
name|UNSIGNED_FIX
case|:
case|case
name|UNSIGNED_FLOAT
case|:
case|case
name|ABS
case|:
case|case
name|SQRT
case|:
case|case
name|FFS
case|:
comment|/* These case either have just one operand or we know that we need not 	 check the rest of the operands.  */
name|loc
operator|=
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
case|case
name|REG
case|:
comment|/* Try to replace with a PLUS.  If that doesn't work, compute the sum 	 in front of this insn and substitute the temporary.  */
if|if
condition|(
name|x
operator|==
name|virtual_incoming_args_rtx
condition|)
name|new
operator|=
name|arg_pointer_rtx
operator|,
name|offset
operator|=
name|in_arg_offset
expr_stmt|;
elseif|else
if|if
condition|(
name|x
operator|==
name|virtual_stack_vars_rtx
condition|)
name|new
operator|=
name|frame_pointer_rtx
operator|,
name|offset
operator|=
name|var_offset
expr_stmt|;
elseif|else
if|if
condition|(
name|x
operator|==
name|virtual_stack_dynamic_rtx
condition|)
name|new
operator|=
name|stack_pointer_rtx
operator|,
name|offset
operator|=
name|dynamic_offset
expr_stmt|;
elseif|else
if|if
condition|(
name|x
operator|==
name|virtual_outgoing_args_rtx
condition|)
name|new
operator|=
name|stack_pointer_rtx
operator|,
name|offset
operator|=
name|out_arg_offset
expr_stmt|;
if|if
condition|(
name|new
condition|)
block|{
name|temp
operator|=
name|plus_constant
argument_list|(
name|new
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|validate_change
argument_list|(
name|object
argument_list|,
name|loc
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|extra_insns
condition|)
return|return
literal|0
return|;
name|start_sequence
argument_list|()
expr_stmt|;
name|temp
operator|=
name|force_operand
argument_list|(
name|temp
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insns_before
argument_list|(
name|seq
argument_list|,
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|validate_change
argument_list|(
name|object
argument_list|,
name|loc
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
operator|&&
operator|!
name|validate_replace_rtx
argument_list|(
name|x
argument_list|,
name|temp
argument_list|,
name|object
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
comment|/* Scan all subexpressions.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
condition|;
name|i
operator|++
operator|,
name|fmt
operator|++
control|)
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'e'
condition|)
block|{
if|if
condition|(
operator|!
name|instantiate_virtual_regs_1
argument_list|(
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|object
argument_list|,
name|extra_insns
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|instantiate_virtual_regs_1
argument_list|(
operator|&
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|object
argument_list|,
name|extra_insns
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Optimization: assuming this function does not receive nonlocal gotos,    delete the handlers for such, as well as the insns to establish    and disestablish them.  */
end_comment

begin_function
specifier|static
name|void
name|delete_handlers
parameter_list|()
block|{
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
comment|/* Delete the handler by turning off the flag that would 	 prevent jump_optimize from deleting it. 	 Also permit deletion of the nonlocal labels themselves 	 if nothing local refers to them.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|LABEL_PRESERVE_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
operator|(
operator|(
name|nonlocal_goto_handler_slot
operator|!=
literal|0
operator|&&
name|reg_mentioned_p
argument_list|(
name|nonlocal_goto_handler_slot
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|nonlocal_goto_stack_level
operator|!=
literal|0
operator|&&
name|reg_mentioned_p
argument_list|(
name|nonlocal_goto_stack_level
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return a list (chain of EXPR_LIST nodes) for the nonlocal labels    of the current function.  */
end_comment

begin_function
name|rtx
name|nonlocal_label_rtx_list
parameter_list|()
block|{
name|tree
name|t
decl_stmt|;
name|rtx
name|x
init|=
literal|0
decl_stmt|;
for|for
control|(
name|t
operator|=
name|nonlocal_labels
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
name|x
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|VOIDmode
argument_list|,
name|label_rtx
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output a USE for any register use in RTL.    This is used with -noreg to mark the extent of lifespan    of any registers used in a user-visible variable's DECL_RTL.  */
end_comment

begin_function
name|void
name|use_variable
parameter_list|(
name|rtl
parameter_list|)
name|rtx
name|rtl
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|rtl
argument_list|)
operator|==
name|REG
condition|)
comment|/* This is a register variable.  */
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|USE
argument_list|,
name|VOIDmode
argument_list|,
name|rtl
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|rtl
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<
name|FIRST_VIRTUAL_REGISTER
operator|||
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>
name|LAST_VIRTUAL_REGISTER
operator|)
operator|&&
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
operator|!=
name|current_function_internal_arg_pointer
condition|)
comment|/* This is a variable-sized structure.  */
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|USE
argument_list|,
name|VOIDmode
argument_list|,
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Like use_variable except that it outputs the USEs after INSN    instead of at the end of the insn-chain.  */
end_comment

begin_function
name|void
name|use_variable_after
parameter_list|(
name|rtl
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|rtl
decl_stmt|,
name|insn
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|rtl
argument_list|)
operator|==
name|REG
condition|)
comment|/* This is a register variable.  */
name|emit_insn_after
argument_list|(
name|gen_rtx
argument_list|(
name|USE
argument_list|,
name|VOIDmode
argument_list|,
name|rtl
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|rtl
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<
name|FIRST_VIRTUAL_REGISTER
operator|||
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>
name|LAST_VIRTUAL_REGISTER
operator|)
operator|&&
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
operator|!=
name|current_function_internal_arg_pointer
condition|)
comment|/* This is a variable-sized structure.  */
name|emit_insn_after
argument_list|(
name|gen_rtx
argument_list|(
name|USE
argument_list|,
name|VOIDmode
argument_list|,
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|max_parm_reg_num
parameter_list|()
block|{
return|return
name|max_parm_reg
return|;
block|}
end_function

begin_comment
comment|/* Return the first insn following those generated by `assign_parms'.  */
end_comment

begin_function
name|rtx
name|get_first_nonparm_insn
parameter_list|()
block|{
if|if
condition|(
name|last_parm_insn
condition|)
return|return
name|NEXT_INSN
argument_list|(
name|last_parm_insn
argument_list|)
return|;
return|return
name|get_insns
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/* Return the first NOTE_INSN_BLOCK_BEG note in the function.    Crash if there is none.  */
end_comment

begin_function
name|rtx
name|get_first_block_beg
parameter_list|()
block|{
specifier|register
name|rtx
name|searcher
decl_stmt|;
specifier|register
name|rtx
name|insn
init|=
name|get_first_nonparm_insn
argument_list|()
decl_stmt|;
for|for
control|(
name|searcher
operator|=
name|insn
init|;
name|searcher
condition|;
name|searcher
operator|=
name|NEXT_INSN
argument_list|(
name|searcher
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|searcher
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|searcher
argument_list|)
operator|==
name|NOTE_INSN_BLOCK_BEG
condition|)
return|return
name|searcher
return|;
name|abort
argument_list|()
expr_stmt|;
comment|/* Invalid call to this function.  (See comments above.)  */
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if EXP returns an aggregate value, for which an address    must be passed to the function or returned by the function.  */
end_comment

begin_function
name|int
name|aggregate_value_p
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|regno
decl_stmt|,
name|nregs
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
if|if
condition|(
name|RETURN_IN_MEMORY
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|flag_pcc_struct_return
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|QUAL_UNION_TYPE
operator|)
condition|)
return|return
literal|1
return|;
comment|/* Make sure we have suitable call-clobbered regs to return      the value in; if not, we must return it in memory.  */
name|reg
operator|=
name|hard_function_value
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|regno
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|nregs
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nregs
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|call_used_regs
index|[
name|regno
operator|+
name|i
index|]
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Assign RTL expressions to the function's parameters.    This may involve copying them into registers and using    those registers as the RTL for them.     If SECOND_TIME is non-zero it means that this function is being    called a second time.  This is done by integrate.c when a function's    compilation is deferred.  We need to come back here in case the    FUNCTION_ARG macro computes items needed for the rest of the compilation    (such as changing which registers are fixed or caller-saved).  But suppress    writing any insns or setting DECL_RTL of anything in this case.  */
end_comment

begin_function
name|void
name|assign_parms
parameter_list|(
name|fndecl
parameter_list|,
name|second_time
parameter_list|)
name|tree
name|fndecl
decl_stmt|;
name|int
name|second_time
decl_stmt|;
block|{
specifier|register
name|tree
name|parm
decl_stmt|;
specifier|register
name|rtx
name|entry_parm
init|=
literal|0
decl_stmt|;
specifier|register
name|rtx
name|stack_parm
init|=
literal|0
decl_stmt|;
name|CUMULATIVE_ARGS
name|args_so_far
decl_stmt|;
name|enum
name|machine_mode
name|promoted_mode
decl_stmt|,
name|passed_mode
decl_stmt|,
name|nominal_mode
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
comment|/* Total space needed so far for args on the stack,      given as a constant and a tree-expression.  */
name|struct
name|args_size
name|stack_args_size
decl_stmt|;
name|tree
name|fntype
init|=
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|tree
name|fnargs
init|=
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
comment|/* This is used for the arg pointer when referring to stack args.  */
name|rtx
name|internal_arg_pointer
decl_stmt|;
comment|/* This is a dummy PARM_DECL that we used for the function result if       the function returns a structure.  */
name|tree
name|function_result_decl
init|=
literal|0
decl_stmt|;
name|int
name|nparmregs
init|=
name|list_length
argument_list|(
name|fnargs
argument_list|)
operator|+
name|LAST_VIRTUAL_REGISTER
operator|+
literal|1
decl_stmt|;
name|int
name|varargs_setup
init|=
literal|0
decl_stmt|;
name|rtx
name|conversion_insns
init|=
literal|0
decl_stmt|;
comment|/* FUNCTION_ARG may look at this variable.  Since this is not      expanding a call it will always be zero in this function.  */
name|int
name|current_call_is_indirect
init|=
literal|0
decl_stmt|;
comment|/* Nonzero if the last arg is named `__builtin_va_alist',      which is used on some machines for old-fashioned non-ANSI varargs.h;      this should be stuck onto the stack as if it had arrived there.  */
name|int
name|vararg
init|=
operator|(
name|fnargs
operator|&&
operator|(
name|parm
operator|=
name|tree_last
argument_list|(
name|fnargs
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|DECL_NAME
argument_list|(
name|parm
argument_list|)
operator|&&
operator|(
operator|!
name|strcmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|parm
argument_list|)
argument_list|)
argument_list|,
literal|"__builtin_va_alist"
argument_list|)
operator|)
operator|)
decl_stmt|;
comment|/* Nonzero if function takes extra anonymous args.      This means the last named arg must be on the stack      right before the anonymous ones. */
name|int
name|stdarg
init|=
operator|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|TREE_VALUE
argument_list|(
name|tree_last
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|void_type_node
operator|)
operator|)
decl_stmt|;
comment|/* If the reg that the virtual arg pointer will be translated into is      not a fixed reg or is the stack pointer, make a copy of the virtual      arg pointer, and address parms via the copy.  The frame pointer is      considered fixed even though it is not marked as such.       The second time through, simply use ap to avoid generating rtx.  */
if|if
condition|(
operator|(
name|ARG_POINTER_REGNUM
operator|==
name|STACK_POINTER_REGNUM
operator|||
operator|!
operator|(
name|fixed_regs
index|[
name|ARG_POINTER_REGNUM
index|]
operator|||
name|ARG_POINTER_REGNUM
operator|==
name|FRAME_POINTER_REGNUM
operator|)
operator|)
operator|&&
operator|!
name|second_time
condition|)
name|internal_arg_pointer
operator|=
name|copy_to_reg
argument_list|(
name|virtual_incoming_args_rtx
argument_list|)
expr_stmt|;
else|else
name|internal_arg_pointer
operator|=
name|virtual_incoming_args_rtx
expr_stmt|;
name|current_function_internal_arg_pointer
operator|=
name|internal_arg_pointer
expr_stmt|;
name|stack_args_size
operator|.
name|constant
operator|=
literal|0
expr_stmt|;
name|stack_args_size
operator|.
name|var
operator|=
literal|0
expr_stmt|;
comment|/* If struct value address is treated as the first argument, make it so.  */
if|if
condition|(
name|aggregate_value_p
argument_list|(
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|&&
operator|!
name|current_function_returns_pcc_struct
operator|&&
name|struct_value_incoming_rtx
operator|==
literal|0
condition|)
block|{
name|tree
name|type
init|=
name|build_pointer_type
argument_list|(
name|fntype
argument_list|)
decl_stmt|;
name|function_result_decl
operator|=
name|build_decl
argument_list|(
name|PARM_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|DECL_ARG_TYPE
argument_list|(
name|function_result_decl
argument_list|)
operator|=
name|type
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|function_result_decl
argument_list|)
operator|=
name|fnargs
expr_stmt|;
name|fnargs
operator|=
name|function_result_decl
expr_stmt|;
block|}
name|parm_reg_stack_loc
operator|=
operator|(
name|rtx
operator|*
operator|)
name|oballoc
argument_list|(
name|nparmregs
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|parm_reg_stack_loc
argument_list|,
name|nparmregs
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INIT_CUMULATIVE_INCOMING_ARGS
name|INIT_CUMULATIVE_INCOMING_ARGS
argument_list|(
name|args_so_far
argument_list|,
name|fntype
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
else|#
directive|else
name|INIT_CUMULATIVE_ARGS
argument_list|(
name|args_so_far
argument_list|,
name|fntype
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* We haven't yet found an argument that we must push and pretend the      caller did.  */
name|current_function_pretend_args_size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|parm
operator|=
name|fnargs
init|;
name|parm
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
control|)
block|{
name|int
name|aggregate
init|=
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|QUAL_UNION_TYPE
operator|)
decl_stmt|;
name|struct
name|args_size
name|stack_offset
decl_stmt|;
name|struct
name|args_size
name|arg_size
decl_stmt|;
name|int
name|passed_pointer
init|=
literal|0
decl_stmt|;
name|tree
name|passed_type
init|=
name|DECL_ARG_TYPE
argument_list|(
name|parm
argument_list|)
decl_stmt|;
comment|/* Set LAST_NAMED if this is last named arg before some 	 anonymous args.  We treat it as if it were anonymous too.  */
name|int
name|last_named
init|=
operator|(
operator|(
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
operator|==
literal|0
operator|||
name|DECL_NAME
argument_list|(
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|vararg
operator|||
name|stdarg
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
operator|==
name|error_mark_node
comment|/* This can happen after weird syntax errors 	     or if an enum type is defined among the parms.  */
operator|||
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|!=
name|PARM_DECL
operator|||
name|passed_type
operator|==
name|NULL
condition|)
block|{
name|DECL_INCOMING_RTL
argument_list|(
name|parm
argument_list|)
operator|=
name|DECL_RTL
argument_list|(
name|parm
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|BLKmode
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|parm
argument_list|)
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
comment|/* For varargs.h function, save info about regs and stack space 	 used by the individual args, not including the va_alist arg.  */
if|if
condition|(
name|vararg
operator|&&
name|last_named
condition|)
name|current_function_args_info
operator|=
name|args_so_far
expr_stmt|;
comment|/* Find mode of arg as it is passed, and mode of arg 	 as it should be during execution of this function.  */
name|passed_mode
operator|=
name|TYPE_MODE
argument_list|(
name|passed_type
argument_list|)
expr_stmt|;
name|nominal_mode
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the parm's mode is VOID, its value doesn't matter, 	 and avoid the usual things like emit_move_insn that could crash.  */
if|if
condition|(
name|nominal_mode
operator|==
name|VOIDmode
condition|)
block|{
name|DECL_INCOMING_RTL
argument_list|(
name|parm
argument_list|)
operator|=
name|DECL_RTL
argument_list|(
name|parm
argument_list|)
operator|=
name|const0_rtx
expr_stmt|;
continue|continue;
block|}
ifdef|#
directive|ifdef
name|FUNCTION_ARG_PASS_BY_REFERENCE
comment|/* See if this arg was passed by invisible reference.  */
if|if
condition|(
name|FUNCTION_ARG_PASS_BY_REFERENCE
argument_list|(
name|args_so_far
argument_list|,
name|passed_mode
argument_list|,
name|passed_type
argument_list|,
operator|!
name|last_named
argument_list|)
condition|)
block|{
name|passed_type
operator|=
name|build_pointer_type
argument_list|(
name|passed_type
argument_list|)
expr_stmt|;
name|passed_pointer
operator|=
literal|1
expr_stmt|;
name|passed_mode
operator|=
name|nominal_mode
operator|=
name|Pmode
expr_stmt|;
block|}
endif|#
directive|endif
name|promoted_mode
operator|=
name|passed_mode
expr_stmt|;
ifdef|#
directive|ifdef
name|PROMOTE_FUNCTION_ARGS
comment|/* Compute the mode in which the arg is actually extended to.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|passed_type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|passed_type
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|passed_type
argument_list|)
operator|==
name|BOOLEAN_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|passed_type
argument_list|)
operator|==
name|CHAR_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|passed_type
argument_list|)
operator|==
name|REAL_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|passed_type
argument_list|)
operator|==
name|POINTER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|passed_type
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
block|{
name|unsignedp
operator|=
name|TREE_UNSIGNED
argument_list|(
name|passed_type
argument_list|)
expr_stmt|;
name|PROMOTE_MODE
argument_list|(
name|promoted_mode
argument_list|,
name|unsignedp
argument_list|,
name|passed_type
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Let machine desc say which reg (if any) the parm arrives in. 	 0 means it arrives on the stack.  */
ifdef|#
directive|ifdef
name|FUNCTION_INCOMING_ARG
name|entry_parm
operator|=
name|FUNCTION_INCOMING_ARG
argument_list|(
name|args_so_far
argument_list|,
name|promoted_mode
argument_list|,
name|passed_type
argument_list|,
operator|!
name|last_named
argument_list|)
expr_stmt|;
else|#
directive|else
name|entry_parm
operator|=
name|FUNCTION_ARG
argument_list|(
name|args_so_far
argument_list|,
name|promoted_mode
argument_list|,
name|passed_type
argument_list|,
operator|!
name|last_named
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|entry_parm
condition|)
name|passed_mode
operator|=
name|promoted_mode
expr_stmt|;
ifdef|#
directive|ifdef
name|SETUP_INCOMING_VARARGS
comment|/* If this is the last named parameter, do any required setup for 	 varargs or stdargs.  We need to know about the case of this being an 	 addressable type, in which case we skip the registers it 	 would have arrived in.  	 For stdargs, LAST_NAMED will be set for two parameters, the one that 	 is actually the last named, and the dummy parameter.  We only 	 want to do this action once.  	 Also, indicate when RTL generation is to be suppressed.  */
if|if
condition|(
name|last_named
operator|&&
operator|!
name|varargs_setup
condition|)
block|{
name|SETUP_INCOMING_VARARGS
argument_list|(
name|args_so_far
argument_list|,
name|passed_mode
argument_list|,
name|passed_type
argument_list|,
name|current_function_pretend_args_size
argument_list|,
name|second_time
argument_list|)
expr_stmt|;
name|varargs_setup
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Determine parm's home in the stack, 	 in case it arrives in the stack or we should pretend it did.  	 Compute the stack position and rtx where the argument arrives 	 and its size.  	 There is one complexity here:  If this was a parameter that would 	 have been passed in registers, but wasn't only because it is 	 __builtin_va_alist, we want locate_and_pad_parm to treat it as if 	 it came in a register so that REG_PARM_STACK_SPACE isn't skipped. 	 In this case, we call FUNCTION_ARG with NAMED set to 1 instead of 	 0 as it was the previous time.  */
name|locate_and_pad_parm
argument_list|(
name|passed_mode
argument_list|,
name|passed_type
argument_list|,
ifdef|#
directive|ifdef
name|STACK_PARMS_IN_REG_PARM_AREA
literal|1
argument_list|,
else|#
directive|else
ifdef|#
directive|ifdef
name|FUNCTION_INCOMING_ARG
name|FUNCTION_INCOMING_ARG
argument_list|(
name|args_so_far
argument_list|,
name|passed_mode
argument_list|,
name|passed_type
argument_list|,
operator|(
operator|!
name|last_named
operator|||
name|varargs_setup
operator|)
argument_list|)
operator|!=
literal|0
argument_list|,
else|#
directive|else
name|FUNCTION_ARG
argument_list|(
name|args_so_far
argument_list|,
name|passed_mode
argument_list|,
name|passed_type
argument_list|,
operator|!
name|last_named
operator|||
name|varargs_setup
argument_list|)
operator|!=
literal|0
argument_list|,
endif|#
directive|endif
endif|#
directive|endif
name|fndecl
argument_list|,
operator|&
name|stack_args_size
argument_list|,
operator|&
name|stack_offset
argument_list|,
operator|&
name|arg_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|second_time
condition|)
block|{
name|rtx
name|offset_rtx
init|=
name|ARGS_SIZE_RTX
argument_list|(
name|stack_offset
argument_list|)
decl_stmt|;
if|if
condition|(
name|offset_rtx
operator|==
name|const0_rtx
condition|)
name|stack_parm
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|passed_mode
argument_list|,
name|internal_arg_pointer
argument_list|)
expr_stmt|;
else|else
name|stack_parm
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|passed_mode
argument_list|,
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|internal_arg_pointer
argument_list|,
name|offset_rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this is a memory ref that contains aggregate components, 	     mark it as such for cse and loop optimize.  */
name|MEM_IN_STRUCT_P
argument_list|(
name|stack_parm
argument_list|)
operator|=
name|aggregate
expr_stmt|;
block|}
comment|/* If this parameter was passed both in registers and in the stack, 	 use the copy on the stack.  */
if|if
condition|(
name|MUST_PASS_IN_STACK
argument_list|(
name|passed_mode
argument_list|,
name|passed_type
argument_list|)
condition|)
name|entry_parm
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|FUNCTION_ARG_PARTIAL_NREGS
comment|/* If this parm was passed part in regs and part in memory, 	 pretend it arrived entirely in memory 	 by pushing the register-part onto the stack.  	 In the special case of a DImode or DFmode that is split, 	 we could put it together in a pseudoreg directly, 	 but for now that's not worth bothering with.  */
if|if
condition|(
name|entry_parm
condition|)
block|{
name|int
name|nregs
init|=
name|FUNCTION_ARG_PARTIAL_NREGS
argument_list|(
name|args_so_far
argument_list|,
name|passed_mode
argument_list|,
name|passed_type
argument_list|,
operator|!
name|last_named
argument_list|)
decl_stmt|;
if|if
condition|(
name|nregs
operator|>
literal|0
condition|)
block|{
name|current_function_pretend_args_size
operator|=
operator|(
operator|(
operator|(
name|nregs
operator|*
name|UNITS_PER_WORD
operator|)
operator|+
operator|(
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
operator|)
operator|-
literal|1
operator|)
operator|/
operator|(
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
operator|)
operator|*
operator|(
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|second_time
condition|)
name|move_block_from_reg
argument_list|(
name|REGNO
argument_list|(
name|entry_parm
argument_list|)
argument_list|,
name|validize_mem
argument_list|(
name|stack_parm
argument_list|)
argument_list|,
name|nregs
argument_list|)
expr_stmt|;
name|entry_parm
operator|=
name|stack_parm
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* If we didn't decide this parm came in a register, 	 by default it came on the stack.  */
if|if
condition|(
name|entry_parm
operator|==
literal|0
condition|)
name|entry_parm
operator|=
name|stack_parm
expr_stmt|;
comment|/* Record permanently how this parm was passed.  */
if|if
condition|(
operator|!
name|second_time
condition|)
name|DECL_INCOMING_RTL
argument_list|(
name|parm
argument_list|)
operator|=
name|entry_parm
expr_stmt|;
comment|/* If there is actually space on the stack for this parm, 	 count it in stack_args_size; otherwise set stack_parm to 0 	 to indicate there is no preallocated stack slot for the parm.  */
if|if
condition|(
name|entry_parm
operator|==
name|stack_parm
if|#
directive|if
name|defined
argument_list|(
name|REG_PARM_STACK_SPACE
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|MAYBE_REG_PARM_STACK_SPACE
argument_list|)
comment|/* On some machines, even if a parm value arrives in a register 	     there is still an (uninitialized) stack slot allocated for it.  	     ??? When MAYBE_REG_PARM_STACK_SPACE is defined, we can't tell 	     whether this parameter already has a stack slot allocated, 	     because an arg block exists only if current_function_args_size 	     is larger than some threshhold, and we haven't calculated that 	     yet.  So, for now, we just assume that stack slots never exist 	     in this case.  */
operator|||
name|REG_PARM_STACK_SPACE
argument_list|(
name|fndecl
argument_list|)
operator|>
literal|0
endif|#
directive|endif
condition|)
block|{
name|stack_args_size
operator|.
name|constant
operator|+=
name|arg_size
operator|.
name|constant
expr_stmt|;
if|if
condition|(
name|arg_size
operator|.
name|var
condition|)
name|ADD_PARM_SIZE
argument_list|(
name|stack_args_size
argument_list|,
name|arg_size
operator|.
name|var
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* No stack slot was pushed for this parm.  */
name|stack_parm
operator|=
literal|0
expr_stmt|;
comment|/* Update info on where next arg arrives in registers.  */
name|FUNCTION_ARG_ADVANCE
argument_list|(
name|args_so_far
argument_list|,
name|passed_mode
argument_list|,
name|passed_type
argument_list|,
operator|!
name|last_named
argument_list|)
expr_stmt|;
comment|/* If this is our second time through, we are done with this parm. */
if|if
condition|(
name|second_time
condition|)
continue|continue;
comment|/* If we can't trust the parm stack slot to be aligned enough 	 for its ultimate type, don't use that slot after entry. 	 We'll make another stack slot, if we need one.  */
block|{
name|int
name|thisparm_boundary
init|=
name|FUNCTION_ARG_BOUNDARY
argument_list|(
name|passed_mode
argument_list|,
name|passed_type
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_MODE_ALIGNMENT
argument_list|(
name|nominal_mode
argument_list|)
operator|>
name|thisparm_boundary
condition|)
name|stack_parm
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Now adjust STACK_PARM to the mode and precise location 	 where this parameter should live during execution, 	 if we discover that it must live in the stack during execution. 	 To make debuggers happier on big-endian machines, we store 	 the value in the last bytes of the space available.  */
if|if
condition|(
name|nominal_mode
operator|!=
name|BLKmode
operator|&&
name|nominal_mode
operator|!=
name|passed_mode
operator|&&
name|stack_parm
operator|!=
literal|0
condition|)
block|{
name|rtx
name|offset_rtx
decl_stmt|;
if|#
directive|if
name|BYTES_BIG_ENDIAN
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|nominal_mode
argument_list|)
operator|<
name|UNITS_PER_WORD
condition|)
name|stack_offset
operator|.
name|constant
operator|+=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|passed_mode
argument_list|)
operator|-
name|GET_MODE_SIZE
argument_list|(
name|nominal_mode
argument_list|)
operator|)
expr_stmt|;
endif|#
directive|endif
name|offset_rtx
operator|=
name|ARGS_SIZE_RTX
argument_list|(
name|stack_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset_rtx
operator|==
name|const0_rtx
condition|)
name|stack_parm
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|nominal_mode
argument_list|,
name|internal_arg_pointer
argument_list|)
expr_stmt|;
else|else
name|stack_parm
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|nominal_mode
argument_list|,
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|internal_arg_pointer
argument_list|,
name|offset_rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this is a memory ref that contains aggregate components, 	     mark it as such for cse and loop optimize.  */
name|MEM_IN_STRUCT_P
argument_list|(
name|stack_parm
argument_list|)
operator|=
name|aggregate
expr_stmt|;
block|}
comment|/* ENTRY_PARM is an RTX for the parameter as it arrives, 	 in the mode in which it arrives. 	 STACK_PARM is an RTX for a stack slot where the parameter can live 	 during the function (in case we want to put it there). 	 STACK_PARM is 0 if no stack slot was pushed for it.  	 Now output code if necessary to convert ENTRY_PARM to 	 the type in which this function declares it, 	 and store that result in an appropriate place, 	 which may be a pseudo reg, may be STACK_PARM, 	 or may be a local stack slot if STACK_PARM is 0.  	 Set DECL_RTL to that place.  */
if|if
condition|(
name|nominal_mode
operator|==
name|BLKmode
condition|)
block|{
comment|/* If a BLKmode arrives in registers, copy it to a stack slot.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|entry_parm
argument_list|)
operator|==
name|REG
condition|)
block|{
name|int
name|size_stored
init|=
name|CEIL_ROUND
argument_list|(
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
argument_list|,
name|UNITS_PER_WORD
argument_list|)
decl_stmt|;
comment|/* Note that we will be storing an integral number of words. 		 So we have to be careful to ensure that we allocate an 		 integral number of words.  We do this below in the 		 assign_stack_local if space was not allocated in the argument 		 list.  If it was, this will not work if PARM_BOUNDARY is not 		 a multiple of BITS_PER_WORD.  It isn't clear how to fix this 		 if it becomes a problem.  */
if|if
condition|(
name|stack_parm
operator|==
literal|0
condition|)
block|{
name|stack_parm
operator|=
name|assign_stack_local
argument_list|(
name|GET_MODE
argument_list|(
name|entry_parm
argument_list|)
argument_list|,
name|size_stored
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If this is a memory ref that contains aggregate components, 		     mark it as such for cse and loop optimize.  */
name|MEM_IN_STRUCT_P
argument_list|(
name|stack_parm
argument_list|)
operator|=
name|aggregate
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|PARM_BOUNDARY
operator|%
name|BITS_PER_WORD
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|move_block_from_reg
argument_list|(
name|REGNO
argument_list|(
name|entry_parm
argument_list|)
argument_list|,
name|validize_mem
argument_list|(
name|stack_parm
argument_list|)
argument_list|,
name|size_stored
operator|/
name|UNITS_PER_WORD
argument_list|)
expr_stmt|;
block|}
name|DECL_RTL
argument_list|(
name|parm
argument_list|)
operator|=
name|stack_parm
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
operator|(
name|obey_regdecls
operator|&&
operator|!
name|DECL_REGISTER
argument_list|(
name|parm
argument_list|)
operator|&&
operator|!
name|DECL_INLINE
argument_list|(
name|fndecl
argument_list|)
operator|)
comment|/* layout_decl may set this.  */
operator|||
name|TREE_ADDRESSABLE
argument_list|(
name|parm
argument_list|)
operator|||
name|TREE_SIDE_EFFECTS
argument_list|(
name|parm
argument_list|)
comment|/* If -ffloat-store specified, don't put explicit 		     float variables into registers.  */
operator|||
operator|(
name|flag_float_store
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|REAL_TYPE
operator|)
operator|)
comment|/* Always assign pseudo to structure return or item passed 		  by invisible reference.  */
operator|||
name|passed_pointer
operator|||
name|parm
operator|==
name|function_result_decl
condition|)
block|{
comment|/* Store the parm in a pseudoregister during the function, but we 	     may need to do it in a wider mode.  */
specifier|register
name|rtx
name|parmreg
decl_stmt|;
name|unsignedp
operator|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|BOOLEAN_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|CHAR_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|REAL_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
block|{
name|PROMOTE_MODE
argument_list|(
name|nominal_mode
argument_list|,
name|unsignedp
argument_list|,
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|parmreg
operator|=
name|gen_reg_rtx
argument_list|(
name|nominal_mode
argument_list|)
expr_stmt|;
name|REG_USERVAR_P
argument_list|(
name|parmreg
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* If this was an item that we received a pointer to, set DECL_RTL 	     appropriately.  */
if|if
condition|(
name|passed_pointer
condition|)
block|{
name|DECL_RTL
argument_list|(
name|parm
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|passed_type
argument_list|)
argument_list|)
argument_list|,
name|parmreg
argument_list|)
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|DECL_RTL
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|=
name|aggregate
expr_stmt|;
block|}
else|else
name|DECL_RTL
argument_list|(
name|parm
argument_list|)
operator|=
name|parmreg
expr_stmt|;
comment|/* Copy the value into the register.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|parmreg
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|entry_parm
argument_list|)
condition|)
block|{
comment|/* If ENTRY_PARM is a hard register, it might be in a register 		 not valid for operating in its mode (e.g., an odd-numbered 		 register for a DFmode).  In that case, moves are the only 		 thing valid, so we can't do a convert from there.  This 		 occurs when the calling sequence allow such misaligned 		 usages.  		 In addition, the conversion may involve a call, which could 		 clobber parameters which haven't been copied to pseudo 		 registers yet.  Therefore, we must first copy the parm to 		 a pseudo reg here, and save the conversion until after all 		 parameters have been moved.  */
name|rtx
name|tempreg
init|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|entry_parm
argument_list|)
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|tempreg
argument_list|,
name|validize_mem
argument_list|(
name|entry_parm
argument_list|)
argument_list|)
expr_stmt|;
name|push_to_sequence
argument_list|(
name|conversion_insns
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|parmreg
argument_list|,
name|tempreg
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|conversion_insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
block|}
else|else
name|emit_move_insn
argument_list|(
name|parmreg
argument_list|,
name|validize_mem
argument_list|(
name|entry_parm
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we were passed a pointer but the actual value 	     can safely live in a register, put it in one.  */
if|if
condition|(
name|passed_pointer
operator|&&
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|!=
name|BLKmode
operator|&&
operator|!
operator|(
operator|(
name|obey_regdecls
operator|&&
operator|!
name|DECL_REGISTER
argument_list|(
name|parm
argument_list|)
operator|&&
operator|!
name|DECL_INLINE
argument_list|(
name|fndecl
argument_list|)
operator|)
comment|/* layout_decl may set this.  */
operator|||
name|TREE_ADDRESSABLE
argument_list|(
name|parm
argument_list|)
operator|||
name|TREE_SIDE_EFFECTS
argument_list|(
name|parm
argument_list|)
comment|/* If -ffloat-store specified, don't put explicit 		       float variables into registers.  */
operator|||
operator|(
name|flag_float_store
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|REAL_TYPE
operator|)
operator|)
condition|)
block|{
comment|/* We can't use nominal_mode, because it will have been set to 		 Pmode above.  We must use the actual mode of the parm.  */
name|parmreg
operator|=
name|gen_reg_rtx
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|parmreg
argument_list|,
name|DECL_RTL
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_RTL
argument_list|(
name|parm
argument_list|)
operator|=
name|parmreg
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|FUNCTION_ARG_CALLEE_COPIES
comment|/* If we are passed an arg by reference and it is our responsibility 	     to make a copy, do it now. 	     PASSED_TYPE and PASSED mode now refer to the pointer, not the 	     original argument, so we must recreate them in the call to 	     FUNCTION_ARG_CALLEE_COPIES.  */
comment|/* ??? Later add code to handle the case that if the argument isn't 	     modified, don't do the copy.  */
elseif|else
if|if
condition|(
name|passed_pointer
operator|&&
name|FUNCTION_ARG_CALLEE_COPIES
argument_list|(
name|args_so_far
argument_list|,
name|TYPE_MODE
argument_list|(
name|DECL_ARG_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
argument_list|,
name|DECL_ARG_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
operator|!
name|last_named
argument_list|)
condition|)
block|{
name|rtx
name|copy
decl_stmt|;
name|tree
name|type
init|=
name|DECL_ARG_TYPE
argument_list|(
name|parm
argument_list|)
decl_stmt|;
comment|/* This sequence may involve a library call perhaps clobbering 		 registers that haven't been copied to pseudos yet.  */
name|push_to_sequence
argument_list|(
name|conversion_insns
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|==
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
comment|/* This is a variable sized object.  */
comment|/* ??? Can we use expr_size here?  */
name|rtx
name|size_rtx
init|=
name|expand_expr
argument_list|(
name|size_in_bytes
argument_list|(
name|type
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|copy
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|BLKmode
argument_list|,
name|allocate_dynamic_stack_space
argument_list|(
name|size_rtx
argument_list|,
name|NULL_RTX
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|size
init|=
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|copy
operator|=
name|assign_stack_temp
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|store_expr
argument_list|(
name|parm
argument_list|,
name|copy
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|parmreg
argument_list|,
name|XEXP
argument_list|(
name|copy
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|conversion_insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* FUNCTION_ARG_CALLEE_COPIES */
comment|/* In any case, record the parm's desired stack location 	     in case we later discover it must live in the stack.  */
if|if
condition|(
name|REGNO
argument_list|(
name|parmreg
argument_list|)
operator|>=
name|nparmregs
condition|)
block|{
name|rtx
modifier|*
name|new
decl_stmt|;
name|nparmregs
operator|=
name|REGNO
argument_list|(
name|parmreg
argument_list|)
operator|+
literal|5
expr_stmt|;
name|new
operator|=
operator|(
name|rtx
operator|*
operator|)
name|oballoc
argument_list|(
name|nparmregs
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|parm_reg_stack_loc
argument_list|,
name|new
argument_list|,
name|nparmregs
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|parm_reg_stack_loc
operator|=
name|new
expr_stmt|;
block|}
name|parm_reg_stack_loc
index|[
name|REGNO
argument_list|(
name|parmreg
argument_list|)
index|]
operator|=
name|stack_parm
expr_stmt|;
comment|/* Mark the register as eliminable if we did no conversion 	     and it was copied from memory at a fixed offset, 	     and the arg pointer was not copied to a pseudo-reg. 	     If the arg pointer is a pseudo reg or the offset formed 	     an invalid address, such memory-equivalences 	     as we make here would screw up life analysis for it.  */
if|if
condition|(
name|nominal_mode
operator|==
name|passed_mode
operator|&&
name|GET_CODE
argument_list|(
name|entry_parm
argument_list|)
operator|==
name|MEM
operator|&&
name|entry_parm
operator|==
name|stack_parm
operator|&&
name|stack_offset
operator|.
name|var
operator|==
literal|0
operator|&&
name|reg_mentioned_p
argument_list|(
name|virtual_incoming_args_rtx
argument_list|,
name|XEXP
argument_list|(
name|entry_parm
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|REG_NOTES
argument_list|(
name|get_last_insn
argument_list|()
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|REG_EQUIV
argument_list|,
name|entry_parm
argument_list|,
name|REG_NOTES
argument_list|(
name|get_last_insn
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For pointer data type, suggest pointer register.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
name|mark_reg_pointer
argument_list|(
name|parmreg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Value must be stored in the stack slot STACK_PARM 	     during function execution.  */
if|if
condition|(
name|passed_mode
operator|!=
name|nominal_mode
condition|)
block|{
comment|/* Conversion is required.   */
name|rtx
name|tempreg
init|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|entry_parm
argument_list|)
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|tempreg
argument_list|,
name|validize_mem
argument_list|(
name|entry_parm
argument_list|)
argument_list|)
expr_stmt|;
name|push_to_sequence
argument_list|(
name|conversion_insns
argument_list|)
expr_stmt|;
name|entry_parm
operator|=
name|convert_to_mode
argument_list|(
name|nominal_mode
argument_list|,
name|tempreg
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|conversion_insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|entry_parm
operator|!=
name|stack_parm
condition|)
block|{
if|if
condition|(
name|stack_parm
operator|==
literal|0
condition|)
block|{
name|stack_parm
operator|=
name|assign_stack_local
argument_list|(
name|GET_MODE
argument_list|(
name|entry_parm
argument_list|)
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|entry_parm
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If this is a memory ref that contains aggregate components, 		     mark it as such for cse and loop optimize.  */
name|MEM_IN_STRUCT_P
argument_list|(
name|stack_parm
argument_list|)
operator|=
name|aggregate
expr_stmt|;
block|}
if|if
condition|(
name|passed_mode
operator|!=
name|nominal_mode
condition|)
block|{
name|push_to_sequence
argument_list|(
name|conversion_insns
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|validize_mem
argument_list|(
name|stack_parm
argument_list|)
argument_list|,
name|validize_mem
argument_list|(
name|entry_parm
argument_list|)
argument_list|)
expr_stmt|;
name|conversion_insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
block|}
else|else
name|emit_move_insn
argument_list|(
name|validize_mem
argument_list|(
name|stack_parm
argument_list|)
argument_list|,
name|validize_mem
argument_list|(
name|entry_parm
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|DECL_RTL
argument_list|(
name|parm
argument_list|)
operator|=
name|stack_parm
expr_stmt|;
block|}
comment|/* If this "parameter" was the place where we are receiving the 	 function's incoming structure pointer, set up the result.  */
if|if
condition|(
name|parm
operator|==
name|function_result_decl
condition|)
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|DECL_MODE
argument_list|(
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|,
name|DECL_RTL
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|parm
argument_list|)
condition|)
name|MEM_VOLATILE_P
argument_list|(
name|DECL_RTL
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|parm
argument_list|)
condition|)
name|RTX_UNCHANGING_P
argument_list|(
name|DECL_RTL
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Output all parameter conversion instructions (possibly including calls)      now that all parameters have been copied out of hard registers.  */
name|emit_insns
argument_list|(
name|conversion_insns
argument_list|)
expr_stmt|;
name|max_parm_reg
operator|=
name|max_reg_num
argument_list|()
expr_stmt|;
name|last_parm_insn
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|current_function_args_size
operator|=
name|stack_args_size
operator|.
name|constant
expr_stmt|;
comment|/* Adjust function incoming argument size for alignment and      minimum length.  */
ifdef|#
directive|ifdef
name|REG_PARM_STACK_SPACE
ifndef|#
directive|ifndef
name|MAYBE_REG_PARM_STACK_SPACE
name|current_function_args_size
operator|=
name|MAX
argument_list|(
name|current_function_args_size
argument_list|,
name|REG_PARM_STACK_SPACE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|STACK_BOUNDARY
define|#
directive|define
name|STACK_BYTES
value|(STACK_BOUNDARY / BITS_PER_UNIT)
name|current_function_args_size
operator|=
operator|(
operator|(
name|current_function_args_size
operator|+
name|STACK_BYTES
operator|-
literal|1
operator|)
operator|/
name|STACK_BYTES
operator|)
operator|*
name|STACK_BYTES
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ARGS_GROW_DOWNWARD
name|current_function_arg_offset_rtx
operator|=
operator|(
name|stack_args_size
operator|.
name|var
operator|==
literal|0
condition|?
name|GEN_INT
argument_list|(
operator|-
name|stack_args_size
operator|.
name|constant
argument_list|)
else|:
name|expand_expr
argument_list|(
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|stack_args_size
operator|.
name|var
argument_list|,
name|size_int
argument_list|(
operator|-
name|stack_args_size
operator|.
name|constant
argument_list|)
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
operator|)
expr_stmt|;
else|#
directive|else
name|current_function_arg_offset_rtx
operator|=
name|ARGS_SIZE_RTX
argument_list|(
name|stack_args_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* See how many bytes, if any, of its args a function should try to pop      on return.  */
name|current_function_pops_args
operator|=
name|RETURN_POPS_ARGS
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|,
name|current_function_args_size
argument_list|)
expr_stmt|;
comment|/* For stdarg.h function, save info about regs and stack space      used by the named args.  */
if|if
condition|(
name|stdarg
condition|)
name|current_function_args_info
operator|=
name|args_so_far
expr_stmt|;
comment|/* Set the rtx used for the function return value.  Put this in its      own variable so any optimizers that need this information don't have      to include tree.h.  Do this here so it gets done when an inlined      function gets output.  */
name|current_function_return_rtx
operator|=
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Indicate whether REGNO is an incoming argument to the current function    that was promoted to a wider mode.  If so, return the RTX for the    register (to get its mode).  PMODE and PUNSIGNEDP are set to the mode    that REGNO is promoted from and whether the promotion was signed or    unsigned.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PROMOTE_FUNCTION_ARGS
end_ifdef

begin_function
name|rtx
name|promoted_input_arg
parameter_list|(
name|regno
parameter_list|,
name|pmode
parameter_list|,
name|punsignedp
parameter_list|)
name|int
name|regno
decl_stmt|;
name|enum
name|machine_mode
modifier|*
name|pmode
decl_stmt|;
name|int
modifier|*
name|punsignedp
decl_stmt|;
block|{
name|tree
name|arg
decl_stmt|;
for|for
control|(
name|arg
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|current_function_decl
argument_list|)
init|;
name|arg
condition|;
name|arg
operator|=
name|TREE_CHAIN
argument_list|(
name|arg
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_INCOMING_RTL
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|DECL_INCOMING_RTL
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|regno
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|BOOLEAN_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|CHAR_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|REAL_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|OFFSET_TYPE
operator|)
condition|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|unsignedp
init|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
decl_stmt|;
name|PROMOTE_MODE
argument_list|(
name|mode
argument_list|,
name|unsignedp
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|GET_MODE
argument_list|(
name|DECL_INCOMING_RTL
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|&&
name|mode
operator|!=
name|DECL_MODE
argument_list|(
name|arg
argument_list|)
condition|)
block|{
operator|*
name|pmode
operator|=
name|DECL_MODE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
operator|*
name|punsignedp
operator|=
name|unsignedp
expr_stmt|;
return|return
name|DECL_INCOMING_RTL
argument_list|(
name|arg
argument_list|)
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Compute the size and offset from the start of the stacked arguments for a    parm passed in mode PASSED_MODE and with type TYPE.     INITIAL_OFFSET_PTR points to the current offset into the stacked    arguments.     The starting offset and size for this parm are returned in *OFFSET_PTR    and *ARG_SIZE_PTR, respectively.     IN_REGS is non-zero if the argument will be passed in registers.  It will    never be set if REG_PARM_STACK_SPACE is not defined.     FNDECL is the function in which the argument was defined.     There are two types of rounding that are done.  The first, controlled by    FUNCTION_ARG_BOUNDARY, forces the offset from the start of the argument    list to be aligned to the specific boundary (in bits).  This rounding    affects the initial and starting offsets, but not the argument size.     The second, controlled by FUNCTION_ARG_PADDING and PARM_BOUNDARY,    optionally rounds the size of the parm to PARM_BOUNDARY.  The    initial offset is not affected by this rounding, while the size always    is and the starting offset may be.  */
end_comment

begin_comment
comment|/*  offset_ptr will be negative for ARGS_GROW_DOWNWARD case;      initial_offset_ptr is positive because locate_and_pad_parm's     callers pass in the total size of args so far as     initial_offset_ptr. arg_size_ptr is always positive.*/
end_comment

begin_decl_stmt
specifier|static
name|void
name|pad_to_arg_alignment
argument_list|()
decl_stmt|,
name|pad_below
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|locate_and_pad_parm
parameter_list|(
name|passed_mode
parameter_list|,
name|type
parameter_list|,
name|in_regs
parameter_list|,
name|fndecl
parameter_list|,
name|initial_offset_ptr
parameter_list|,
name|offset_ptr
parameter_list|,
name|arg_size_ptr
parameter_list|)
name|enum
name|machine_mode
name|passed_mode
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|int
name|in_regs
decl_stmt|;
name|tree
name|fndecl
decl_stmt|;
name|struct
name|args_size
modifier|*
name|initial_offset_ptr
decl_stmt|;
name|struct
name|args_size
modifier|*
name|offset_ptr
decl_stmt|;
name|struct
name|args_size
modifier|*
name|arg_size_ptr
decl_stmt|;
block|{
name|tree
name|sizetree
init|=
name|type
condition|?
name|size_in_bytes
argument_list|(
name|type
argument_list|)
else|:
name|size_int
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|passed_mode
argument_list|)
argument_list|)
decl_stmt|;
name|enum
name|direction
name|where_pad
init|=
name|FUNCTION_ARG_PADDING
argument_list|(
name|passed_mode
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|int
name|boundary
init|=
name|FUNCTION_ARG_BOUNDARY
argument_list|(
name|passed_mode
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|int
name|boundary_in_bytes
init|=
name|boundary
operator|/
name|BITS_PER_UNIT
decl_stmt|;
name|int
name|reg_parm_stack_space
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|REG_PARM_STACK_SPACE
comment|/* If we have found a stack parm before we reach the end of the      area reserved for registers, skip that area.  */
if|if
condition|(
operator|!
name|in_regs
condition|)
block|{
ifdef|#
directive|ifdef
name|MAYBE_REG_PARM_STACK_SPACE
name|reg_parm_stack_space
operator|=
name|MAYBE_REG_PARM_STACK_SPACE
expr_stmt|;
else|#
directive|else
name|reg_parm_stack_space
operator|=
name|REG_PARM_STACK_SPACE
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|reg_parm_stack_space
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|initial_offset_ptr
operator|->
name|var
condition|)
block|{
name|initial_offset_ptr
operator|->
name|var
operator|=
name|size_binop
argument_list|(
name|MAX_EXPR
argument_list|,
name|ARGS_SIZE_TREE
argument_list|(
operator|*
name|initial_offset_ptr
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|reg_parm_stack_space
argument_list|)
argument_list|)
expr_stmt|;
name|initial_offset_ptr
operator|->
name|constant
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|initial_offset_ptr
operator|->
name|constant
operator|<
name|reg_parm_stack_space
condition|)
name|initial_offset_ptr
operator|->
name|constant
operator|=
name|reg_parm_stack_space
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* REG_PARM_STACK_SPACE */
name|arg_size_ptr
operator|->
name|var
operator|=
literal|0
expr_stmt|;
name|arg_size_ptr
operator|->
name|constant
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|ARGS_GROW_DOWNWARD
if|if
condition|(
name|initial_offset_ptr
operator|->
name|var
condition|)
block|{
name|offset_ptr
operator|->
name|constant
operator|=
literal|0
expr_stmt|;
name|offset_ptr
operator|->
name|var
operator|=
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|integer_zero_node
argument_list|,
name|initial_offset_ptr
operator|->
name|var
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|offset_ptr
operator|->
name|constant
operator|=
operator|-
name|initial_offset_ptr
operator|->
name|constant
expr_stmt|;
name|offset_ptr
operator|->
name|var
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|where_pad
operator|==
name|upward
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|sizetree
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
operator|(
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|sizetree
argument_list|)
operator|*
name|BITS_PER_UNIT
operator|)
operator|%
name|PARM_BOUNDARY
operator|)
operator|)
condition|)
name|sizetree
operator|=
name|round_up
argument_list|(
name|sizetree
argument_list|,
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|SUB_PARM_SIZE
argument_list|(
operator|*
name|offset_ptr
argument_list|,
name|sizetree
argument_list|)
expr_stmt|;
if|if
condition|(
name|where_pad
operator|!=
name|downward
condition|)
name|pad_to_arg_alignment
argument_list|(
name|offset_ptr
argument_list|,
name|boundary
argument_list|)
expr_stmt|;
if|if
condition|(
name|initial_offset_ptr
operator|->
name|var
condition|)
block|{
name|arg_size_ptr
operator|->
name|var
operator|=
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|integer_zero_node
argument_list|,
name|initial_offset_ptr
operator|->
name|var
argument_list|)
argument_list|,
name|offset_ptr
operator|->
name|var
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arg_size_ptr
operator|->
name|constant
operator|=
operator|(
operator|-
name|initial_offset_ptr
operator|->
name|constant
operator|-
name|offset_ptr
operator|->
name|constant
operator|)
expr_stmt|;
block|}
comment|/*  ADD_PARM_SIZE (*arg_size_ptr, sizetree); */
if|if
condition|(
name|where_pad
operator|==
name|downward
condition|)
name|pad_below
argument_list|(
name|arg_size_ptr
argument_list|,
name|passed_mode
argument_list|,
name|sizetree
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !ARGS_GROW_DOWNWARD */
name|pad_to_arg_alignment
argument_list|(
name|initial_offset_ptr
argument_list|,
name|boundary
argument_list|)
expr_stmt|;
operator|*
name|offset_ptr
operator|=
operator|*
name|initial_offset_ptr
expr_stmt|;
if|if
condition|(
name|where_pad
operator|==
name|downward
condition|)
name|pad_below
argument_list|(
name|offset_ptr
argument_list|,
name|passed_mode
argument_list|,
name|sizetree
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PUSH_ROUNDING
if|if
condition|(
name|passed_mode
operator|!=
name|BLKmode
condition|)
name|sizetree
operator|=
name|size_int
argument_list|(
name|PUSH_ROUNDING
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|sizetree
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|where_pad
operator|!=
name|none
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|sizetree
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
operator|(
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|sizetree
argument_list|)
operator|*
name|BITS_PER_UNIT
operator|)
operator|%
name|PARM_BOUNDARY
operator|)
operator|)
condition|)
name|sizetree
operator|=
name|round_up
argument_list|(
name|sizetree
argument_list|,
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|ADD_PARM_SIZE
argument_list|(
operator|*
name|arg_size_ptr
argument_list|,
name|sizetree
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ARGS_GROW_DOWNWARD */
block|}
end_function

begin_comment
comment|/* Round the stack offset in *OFFSET_PTR up to a multiple of BOUNDARY.    BOUNDARY is measured in bits, but must be a multiple of a storage unit.  */
end_comment

begin_function
specifier|static
name|void
name|pad_to_arg_alignment
parameter_list|(
name|offset_ptr
parameter_list|,
name|boundary
parameter_list|)
name|struct
name|args_size
modifier|*
name|offset_ptr
decl_stmt|;
name|int
name|boundary
decl_stmt|;
block|{
name|int
name|boundary_in_bytes
init|=
name|boundary
operator|/
name|BITS_PER_UNIT
decl_stmt|;
if|if
condition|(
name|boundary
operator|>
name|BITS_PER_UNIT
condition|)
block|{
if|if
condition|(
name|offset_ptr
operator|->
name|var
condition|)
block|{
name|offset_ptr
operator|->
name|var
operator|=
ifdef|#
directive|ifdef
name|ARGS_GROW_DOWNWARD
name|round_down
else|#
directive|else
name|round_up
endif|#
directive|endif
argument_list|(
name|ARGS_SIZE_TREE
argument_list|(
operator|*
name|offset_ptr
argument_list|)
argument_list|,
name|boundary
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|offset_ptr
operator|->
name|constant
operator|=
literal|0
expr_stmt|;
comment|/*?*/
block|}
else|else
name|offset_ptr
operator|->
name|constant
operator|=
ifdef|#
directive|ifdef
name|ARGS_GROW_DOWNWARD
name|FLOOR_ROUND
argument_list|(
name|offset_ptr
operator|->
name|constant
argument_list|,
name|boundary_in_bytes
argument_list|)
expr_stmt|;
else|#
directive|else
name|CEIL_ROUND
argument_list|(
name|offset_ptr
operator|->
name|constant
argument_list|,
name|boundary_in_bytes
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|pad_below
parameter_list|(
name|offset_ptr
parameter_list|,
name|passed_mode
parameter_list|,
name|sizetree
parameter_list|)
name|struct
name|args_size
modifier|*
name|offset_ptr
decl_stmt|;
name|enum
name|machine_mode
name|passed_mode
decl_stmt|;
name|tree
name|sizetree
decl_stmt|;
block|{
if|if
condition|(
name|passed_mode
operator|!=
name|BLKmode
condition|)
block|{
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|passed_mode
argument_list|)
operator|%
name|PARM_BOUNDARY
condition|)
name|offset_ptr
operator|->
name|constant
operator|+=
operator|(
operator|(
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|passed_mode
argument_list|)
operator|+
name|PARM_BOUNDARY
operator|-
literal|1
operator|)
operator|/
name|PARM_BOUNDARY
operator|*
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
operator|)
operator|-
name|GET_MODE_SIZE
argument_list|(
name|passed_mode
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|sizetree
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|sizetree
argument_list|)
operator|*
name|BITS_PER_UNIT
operator|)
operator|%
name|PARM_BOUNDARY
condition|)
block|{
comment|/* Round the size up to multiple of PARM_BOUNDARY bits.  */
name|tree
name|s2
init|=
name|round_up
argument_list|(
name|sizetree
argument_list|,
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
argument_list|)
decl_stmt|;
comment|/* Add it in.  */
name|ADD_PARM_SIZE
argument_list|(
operator|*
name|offset_ptr
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|SUB_PARM_SIZE
argument_list|(
operator|*
name|offset_ptr
argument_list|,
name|sizetree
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|tree
name|round_down
parameter_list|(
name|value
parameter_list|,
name|divisor
parameter_list|)
name|tree
name|value
decl_stmt|;
name|int
name|divisor
decl_stmt|;
block|{
return|return
name|size_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|size_binop
argument_list|(
name|FLOOR_DIV_EXPR
argument_list|,
name|value
argument_list|,
name|size_int
argument_list|(
name|divisor
argument_list|)
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|divisor
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Walk the tree of blocks describing the binding levels within a function    and warn about uninitialized variables.    This is done after calling flow_analysis and before global_alloc    clobbers the pseudo-regs to hard regs.  */
end_comment

begin_function
name|void
name|uninitialized_vars_warning
parameter_list|(
name|block
parameter_list|)
name|tree
name|block
decl_stmt|;
block|{
specifier|register
name|tree
name|decl
decl_stmt|,
name|sub
decl_stmt|;
for|for
control|(
name|decl
operator|=
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
comment|/* These warnings are unreliable for and aggregates 	     because assigning the fields one by one can fail to convince 	     flow.c that the entire aggregate was initialized. 	     Unions are troublesome because members may be shorter.  */
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|RECORD_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|UNION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|QUAL_UNION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|ARRAY_TYPE
operator|&&
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|regno_uninitialized
argument_list|(
name|REGNO
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
condition|)
name|warning_with_decl
argument_list|(
name|decl
argument_list|,
literal|"`%s' may be used uninitialized in this function"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|regno_clobbered_at_setjmp
argument_list|(
name|REGNO
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
condition|)
name|warning_with_decl
argument_list|(
name|decl
argument_list|,
literal|"variable `%s' may be clobbered by `longjmp' or `vfork'"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|sub
operator|=
name|BLOCK_SUBBLOCKS
argument_list|(
name|block
argument_list|)
init|;
name|sub
condition|;
name|sub
operator|=
name|TREE_CHAIN
argument_list|(
name|sub
argument_list|)
control|)
name|uninitialized_vars_warning
argument_list|(
name|sub
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Do the appropriate part of uninitialized_vars_warning    but for arguments instead of local variables.  */
end_comment

begin_function
name|void
name|setjmp_args_warning
parameter_list|(
name|block
parameter_list|)
name|tree
name|block
decl_stmt|;
block|{
specifier|register
name|tree
name|decl
decl_stmt|;
for|for
control|(
name|decl
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|current_function_decl
argument_list|)
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
if|if
condition|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|regno_clobbered_at_setjmp
argument_list|(
name|REGNO
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
condition|)
name|warning_with_decl
argument_list|(
name|decl
argument_list|,
literal|"argument `%s' may be clobbered by `longjmp' or `vfork'"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If this function call setjmp, put all vars into the stack    unless they were declared `register'.  */
end_comment

begin_function
name|void
name|setjmp_protect
parameter_list|(
name|block
parameter_list|)
name|tree
name|block
decl_stmt|;
block|{
specifier|register
name|tree
name|decl
decl_stmt|,
name|sub
decl_stmt|;
for|for
control|(
name|decl
operator|=
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|PARM_DECL
operator|)
operator|&&
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|REG
comment|/* If this variable came from an inline function, it must be 	   that it's life doesn't overlap the setjmp.  If there was a 	   setjmp in the function, it would already be in memory.  We 	   must exclude such variable because their DECL_RTL might be 	   set to strange things such as virtual_stack_vars_rtx.  */
operator|&&
operator|!
name|DECL_FROM_INLINE
argument_list|(
name|decl
argument_list|)
operator|&&
operator|(
ifdef|#
directive|ifdef
name|NON_SAVING_SETJMP
comment|/* If longjmp doesn't restore the registers, 	       don't put anything in them.  */
name|NON_SAVING_SETJMP
operator|||
endif|#
directive|endif
operator|!
name|DECL_REGISTER
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
name|put_var_into_stack
argument_list|(
name|decl
argument_list|)
expr_stmt|;
for|for
control|(
name|sub
operator|=
name|BLOCK_SUBBLOCKS
argument_list|(
name|block
argument_list|)
init|;
name|sub
condition|;
name|sub
operator|=
name|TREE_CHAIN
argument_list|(
name|sub
argument_list|)
control|)
name|setjmp_protect
argument_list|(
name|sub
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Like the previous function, but for args instead of local variables.  */
end_comment

begin_function
name|void
name|setjmp_protect_args
parameter_list|()
block|{
specifier|register
name|tree
name|decl
decl_stmt|,
name|sub
decl_stmt|;
for|for
control|(
name|decl
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|current_function_decl
argument_list|)
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|PARM_DECL
operator|)
operator|&&
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
comment|/* If longjmp doesn't restore the registers, 	       don't put anything in them.  */
ifdef|#
directive|ifdef
name|NON_SAVING_SETJMP
name|NON_SAVING_SETJMP
operator|||
endif|#
directive|endif
operator|!
name|DECL_REGISTER
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
name|put_var_into_stack
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the context-pointer register corresponding to DECL,    or 0 if it does not need one.  */
end_comment

begin_function
name|rtx
name|lookup_static_chain
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|tree
name|context
init|=
name|decl_function_context
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|tree
name|link
decl_stmt|;
if|if
condition|(
name|context
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* We treat inline_function_decl as an alias for the current function      because that is the inline function whose vars, types, etc.      are being merged into the current function.      See expand_inline_function.  */
if|if
condition|(
name|context
operator|==
name|current_function_decl
operator|||
name|context
operator|==
name|inline_function_decl
condition|)
return|return
name|virtual_stack_vars_rtx
return|;
for|for
control|(
name|link
operator|=
name|context_display
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
operator|==
name|context
condition|)
return|return
name|RTL_EXPR_RTL
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Convert a stack slot address ADDR for variable VAR    (from a containing function)    into an address valid in this function (using a static chain).  */
end_comment

begin_function
name|rtx
name|fix_lexical_addr
parameter_list|(
name|addr
parameter_list|,
name|var
parameter_list|)
name|rtx
name|addr
decl_stmt|;
name|tree
name|var
decl_stmt|;
block|{
name|rtx
name|basereg
decl_stmt|;
name|int
name|displacement
decl_stmt|;
name|tree
name|context
init|=
name|decl_function_context
argument_list|(
name|var
argument_list|)
decl_stmt|;
name|struct
name|function
modifier|*
name|fp
decl_stmt|;
name|rtx
name|base
init|=
literal|0
decl_stmt|;
comment|/* If this is the present function, we need not do anything.  */
if|if
condition|(
name|context
operator|==
name|current_function_decl
operator|||
name|context
operator|==
name|inline_function_decl
condition|)
return|return
name|addr
return|;
for|for
control|(
name|fp
operator|=
name|outer_function_chain
init|;
name|fp
condition|;
name|fp
operator|=
name|fp
operator|->
name|next
control|)
if|if
condition|(
name|fp
operator|->
name|decl
operator|==
name|context
condition|)
break|break;
if|if
condition|(
name|fp
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Decode given address as base reg plus displacement.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|REG
condition|)
name|basereg
operator|=
name|addr
operator|,
name|displacement
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
name|basereg
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
operator|,
name|displacement
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* We accept vars reached via the containing function's      incoming arg pointer and via its stack variables pointer.  */
if|if
condition|(
name|basereg
operator|==
name|fp
operator|->
name|internal_arg_pointer
condition|)
block|{
comment|/* If reached via arg pointer, get the arg pointer value 	 out of that function's stack frame.  	 There are two cases:  If a separate ap is needed, allocate a 	 slot in the outer function for it and dereference it that way. 	 This is correct even if the real ap is actually a pseudo. 	 Otherwise, just adjust the offset from the frame pointer to 	 compensate.  */
ifdef|#
directive|ifdef
name|NEED_SEPARATE_AP
name|rtx
name|addr
decl_stmt|;
if|if
condition|(
name|fp
operator|->
name|arg_pointer_save_area
operator|==
literal|0
condition|)
name|fp
operator|->
name|arg_pointer_save_area
operator|=
name|assign_outer_stack_local
argument_list|(
name|Pmode
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
argument_list|,
literal|0
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|addr
operator|=
name|fix_lexical_addr
argument_list|(
name|XEXP
argument_list|(
name|fp
operator|->
name|arg_pointer_save_area
argument_list|,
literal|0
argument_list|)
argument_list|,
name|var
argument_list|)
expr_stmt|;
name|addr
operator|=
name|memory_address
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|base
operator|=
name|copy_to_reg
argument_list|(
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|Pmode
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|displacement
operator|+=
operator|(
name|FIRST_PARM_OFFSET
argument_list|(
name|context
argument_list|)
operator|-
name|STARTING_FRAME_OFFSET
operator|)
expr_stmt|;
name|base
operator|=
name|lookup_static_chain
argument_list|(
name|var
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|basereg
operator|==
name|virtual_stack_vars_rtx
condition|)
block|{
comment|/* This is the same code as lookup_static_chain, duplicated here to 	 avoid an extra call to decl_function_context.  */
name|tree
name|link
decl_stmt|;
for|for
control|(
name|link
operator|=
name|context_display
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
operator|==
name|context
condition|)
block|{
name|base
operator|=
name|RTL_EXPR_RTL
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|base
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Use same offset, relative to appropriate static chain or argument      pointer.  */
return|return
name|plus_constant
argument_list|(
name|base
argument_list|,
name|displacement
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the address of the trampoline for entering nested fn FUNCTION.    If necessary, allocate a trampoline (in the stack frame)    and emit rtl to initialize its contents (at entry to this function).  */
end_comment

begin_function
name|rtx
name|trampoline_address
parameter_list|(
name|function
parameter_list|)
name|tree
name|function
decl_stmt|;
block|{
name|tree
name|link
decl_stmt|;
name|tree
name|rtlexp
decl_stmt|;
name|rtx
name|tramp
decl_stmt|;
name|struct
name|function
modifier|*
name|fp
decl_stmt|;
name|tree
name|fn_context
decl_stmt|;
comment|/* Find an existing trampoline and return it.  */
for|for
control|(
name|link
operator|=
name|trampoline_list
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
operator|==
name|function
condition|)
return|return
name|XEXP
argument_list|(
name|RTL_EXPR_RTL
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
for|for
control|(
name|fp
operator|=
name|outer_function_chain
init|;
name|fp
condition|;
name|fp
operator|=
name|fp
operator|->
name|next
control|)
for|for
control|(
name|link
operator|=
name|fp
operator|->
name|trampoline_list
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
operator|==
name|function
condition|)
block|{
name|tramp
operator|=
name|fix_lexical_addr
argument_list|(
name|XEXP
argument_list|(
name|RTL_EXPR_RTL
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|function
argument_list|)
expr_stmt|;
return|return
name|round_trampoline_addr
argument_list|(
name|tramp
argument_list|)
return|;
block|}
comment|/* None exists; we must make one.  */
comment|/* Find the `struct function' for the function containing FUNCTION.  */
name|fp
operator|=
literal|0
expr_stmt|;
name|fn_context
operator|=
name|decl_function_context
argument_list|(
name|function
argument_list|)
expr_stmt|;
if|if
condition|(
name|fn_context
operator|!=
name|current_function_decl
condition|)
for|for
control|(
name|fp
operator|=
name|outer_function_chain
init|;
name|fp
condition|;
name|fp
operator|=
name|fp
operator|->
name|next
control|)
if|if
condition|(
name|fp
operator|->
name|decl
operator|==
name|fn_context
condition|)
break|break;
comment|/* Allocate run-time space for this trampoline      (usually in the defining function's stack frame).  */
ifdef|#
directive|ifdef
name|ALLOCATE_TRAMPOLINE
name|tramp
operator|=
name|ALLOCATE_TRAMPOLINE
argument_list|(
name|fp
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* If rounding needed, allocate extra space      to ensure we have TRAMPOLINE_SIZE bytes left after rounding up.  */
ifdef|#
directive|ifdef
name|TRAMPOLINE_ALIGNMENT
define|#
directive|define
name|TRAMPOLINE_REAL_SIZE
value|(TRAMPOLINE_SIZE + TRAMPOLINE_ALIGNMENT - 1)
else|#
directive|else
define|#
directive|define
name|TRAMPOLINE_REAL_SIZE
value|(TRAMPOLINE_SIZE)
endif|#
directive|endif
if|if
condition|(
name|fp
operator|!=
literal|0
condition|)
name|tramp
operator|=
name|assign_outer_stack_local
argument_list|(
name|BLKmode
argument_list|,
name|TRAMPOLINE_REAL_SIZE
argument_list|,
literal|0
argument_list|,
name|fp
argument_list|)
expr_stmt|;
else|else
name|tramp
operator|=
name|assign_stack_local
argument_list|(
name|BLKmode
argument_list|,
name|TRAMPOLINE_REAL_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Record the trampoline for reuse and note it for later initialization      by expand_function_end.  */
if|if
condition|(
name|fp
operator|!=
literal|0
condition|)
block|{
name|push_obstacks
argument_list|(
name|fp
operator|->
name|current_obstack
argument_list|,
name|fp
operator|->
name|function_maybepermanent_obstack
argument_list|)
expr_stmt|;
name|rtlexp
operator|=
name|make_node
argument_list|(
name|RTL_EXPR
argument_list|)
expr_stmt|;
name|RTL_EXPR_RTL
argument_list|(
name|rtlexp
argument_list|)
operator|=
name|tramp
expr_stmt|;
name|fp
operator|->
name|trampoline_list
operator|=
name|tree_cons
argument_list|(
name|function
argument_list|,
name|rtlexp
argument_list|,
name|fp
operator|->
name|trampoline_list
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* Make the RTL_EXPR node temporary, not momentary, so that the 	 trampoline_list doesn't become garbage.  */
name|int
name|momentary
init|=
name|suspend_momentary
argument_list|()
decl_stmt|;
name|rtlexp
operator|=
name|make_node
argument_list|(
name|RTL_EXPR
argument_list|)
expr_stmt|;
name|resume_momentary
argument_list|(
name|momentary
argument_list|)
expr_stmt|;
name|RTL_EXPR_RTL
argument_list|(
name|rtlexp
argument_list|)
operator|=
name|tramp
expr_stmt|;
name|trampoline_list
operator|=
name|tree_cons
argument_list|(
name|function
argument_list|,
name|rtlexp
argument_list|,
name|trampoline_list
argument_list|)
expr_stmt|;
block|}
name|tramp
operator|=
name|fix_lexical_addr
argument_list|(
name|XEXP
argument_list|(
name|tramp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|function
argument_list|)
expr_stmt|;
return|return
name|round_trampoline_addr
argument_list|(
name|tramp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given a trampoline address,    round it to multiple of TRAMPOLINE_ALIGNMENT.  */
end_comment

begin_function
specifier|static
name|rtx
name|round_trampoline_addr
parameter_list|(
name|tramp
parameter_list|)
name|rtx
name|tramp
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|TRAMPOLINE_ALIGNMENT
comment|/* Round address up to desired boundary.  */
name|rtx
name|temp
init|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
name|temp
operator|=
name|expand_binop
argument_list|(
name|Pmode
argument_list|,
name|add_optab
argument_list|,
name|tramp
argument_list|,
name|GEN_INT
argument_list|(
name|TRAMPOLINE_ALIGNMENT
operator|-
literal|1
argument_list|)
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
name|tramp
operator|=
name|expand_binop
argument_list|(
name|Pmode
argument_list|,
name|and_optab
argument_list|,
name|temp
argument_list|,
name|GEN_INT
argument_list|(
operator|-
name|TRAMPOLINE_ALIGNMENT
argument_list|)
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|tramp
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The functions identify_blocks and reorder_blocks provide a way to    reorder the tree of BLOCK nodes, for optimizers that reshuffle or    duplicate portions of the RTL code.  Call identify_blocks before    changing the RTL, and call reorder_blocks after.  */
end_comment

begin_function_decl
specifier|static
name|int
name|all_blocks
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|blocks_nreverse
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Put all this function's BLOCK nodes into a vector, and return it.    Also store in each NOTE for the beginning or end of a block    the index of that block in the vector.    The arguments are TOP_BLOCK, the top-level block of the function,    and INSNS, the insn chain of the function.  */
end_comment

begin_function
name|tree
modifier|*
name|identify_blocks
parameter_list|(
name|top_block
parameter_list|,
name|insns
parameter_list|)
name|tree
name|top_block
decl_stmt|;
name|rtx
name|insns
decl_stmt|;
block|{
name|int
name|n_blocks
decl_stmt|;
name|tree
modifier|*
name|block_vector
decl_stmt|;
name|int
modifier|*
name|block_stack
decl_stmt|;
name|int
name|depth
init|=
literal|0
decl_stmt|;
name|int
name|next_block_number
init|=
literal|0
decl_stmt|;
name|int
name|current_block_number
init|=
literal|0
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
name|top_block
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|n_blocks
operator|=
name|all_blocks
argument_list|(
name|top_block
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|block_vector
operator|=
operator|(
name|tree
operator|*
operator|)
name|xmalloc
argument_list|(
name|n_blocks
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
name|block_stack
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|n_blocks
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|all_blocks
argument_list|(
name|top_block
argument_list|,
name|block_vector
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|insns
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
block|{
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_BLOCK_BEG
condition|)
block|{
name|block_stack
index|[
name|depth
operator|++
index|]
operator|=
name|current_block_number
expr_stmt|;
name|current_block_number
operator|=
name|next_block_number
expr_stmt|;
name|NOTE_BLOCK_NUMBER
argument_list|(
name|insn
argument_list|)
operator|=
name|next_block_number
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_BLOCK_END
condition|)
block|{
name|current_block_number
operator|=
name|block_stack
index|[
operator|--
name|depth
index|]
expr_stmt|;
name|NOTE_BLOCK_NUMBER
argument_list|(
name|insn
argument_list|)
operator|=
name|current_block_number
expr_stmt|;
block|}
block|}
return|return
name|block_vector
return|;
block|}
end_function

begin_comment
comment|/* Given BLOCK_VECTOR which was returned by identify_blocks,    and a revised instruction chain, rebuild the tree structure    of BLOCK nodes to correspond to the new order of RTL.    The new block tree is inserted below TOP_BLOCK.    Returns the current top-level block.  */
end_comment

begin_function
name|tree
name|reorder_blocks
parameter_list|(
name|block_vector
parameter_list|,
name|top_block
parameter_list|,
name|insns
parameter_list|)
name|tree
modifier|*
name|block_vector
decl_stmt|;
name|tree
name|top_block
decl_stmt|;
name|rtx
name|insns
decl_stmt|;
block|{
name|tree
name|current_block
init|=
name|top_block
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
name|block_vector
operator|==
literal|0
condition|)
return|return
name|top_block
return|;
comment|/* Prune the old tree away, so that it doesn't get in the way.  */
name|BLOCK_SUBBLOCKS
argument_list|(
name|current_block
argument_list|)
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|insns
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
block|{
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_BLOCK_BEG
condition|)
block|{
name|tree
name|block
init|=
name|block_vector
index|[
name|NOTE_BLOCK_NUMBER
argument_list|(
name|insn
argument_list|)
index|]
decl_stmt|;
comment|/* If we have seen this block before, copy it.  */
if|if
condition|(
name|TREE_ASM_WRITTEN
argument_list|(
name|block
argument_list|)
condition|)
name|block
operator|=
name|copy_node
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|BLOCK_SUBBLOCKS
argument_list|(
name|block
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_ASM_WRITTEN
argument_list|(
name|block
argument_list|)
operator|=
literal|1
expr_stmt|;
name|BLOCK_SUPERCONTEXT
argument_list|(
name|block
argument_list|)
operator|=
name|current_block
expr_stmt|;
name|BLOCK_CHAIN
argument_list|(
name|block
argument_list|)
operator|=
name|BLOCK_SUBBLOCKS
argument_list|(
name|current_block
argument_list|)
expr_stmt|;
name|BLOCK_SUBBLOCKS
argument_list|(
name|current_block
argument_list|)
operator|=
name|block
expr_stmt|;
name|current_block
operator|=
name|block
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_BLOCK_END
condition|)
block|{
name|BLOCK_SUBBLOCKS
argument_list|(
name|current_block
argument_list|)
operator|=
name|blocks_nreverse
argument_list|(
name|BLOCK_SUBBLOCKS
argument_list|(
name|current_block
argument_list|)
argument_list|)
expr_stmt|;
name|current_block
operator|=
name|BLOCK_SUPERCONTEXT
argument_list|(
name|current_block
argument_list|)
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|current_block
return|;
block|}
end_function

begin_comment
comment|/* Reverse the order of elements in the chain T of blocks,    and return the new head of the chain (old last element).  */
end_comment

begin_function
specifier|static
name|tree
name|blocks_nreverse
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
specifier|register
name|tree
name|prev
init|=
literal|0
decl_stmt|,
name|decl
decl_stmt|,
name|next
decl_stmt|;
for|for
control|(
name|decl
operator|=
name|t
init|;
name|decl
condition|;
name|decl
operator|=
name|next
control|)
block|{
name|next
operator|=
name|BLOCK_CHAIN
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|BLOCK_CHAIN
argument_list|(
name|decl
argument_list|)
operator|=
name|prev
expr_stmt|;
name|prev
operator|=
name|decl
expr_stmt|;
block|}
return|return
name|prev
return|;
block|}
end_function

begin_comment
comment|/* Count the subblocks of BLOCK, and list them all into the vector VECTOR.    Also clear TREE_ASM_WRITTEN in all blocks.  */
end_comment

begin_function
specifier|static
name|int
name|all_blocks
parameter_list|(
name|block
parameter_list|,
name|vector
parameter_list|)
name|tree
name|block
decl_stmt|;
name|tree
modifier|*
name|vector
decl_stmt|;
block|{
name|int
name|n_blocks
init|=
literal|1
decl_stmt|;
name|tree
name|subblocks
decl_stmt|;
name|TREE_ASM_WRITTEN
argument_list|(
name|block
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Record this block.  */
if|if
condition|(
name|vector
condition|)
name|vector
index|[
literal|0
index|]
operator|=
name|block
expr_stmt|;
comment|/* Record the subblocks, and their subblocks.  */
for|for
control|(
name|subblocks
operator|=
name|BLOCK_SUBBLOCKS
argument_list|(
name|block
argument_list|)
init|;
name|subblocks
condition|;
name|subblocks
operator|=
name|BLOCK_CHAIN
argument_list|(
name|subblocks
argument_list|)
control|)
name|n_blocks
operator|+=
name|all_blocks
argument_list|(
name|subblocks
argument_list|,
name|vector
condition|?
name|vector
operator|+
name|n_blocks
else|:
literal|0
argument_list|)
expr_stmt|;
return|return
name|n_blocks
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate RTL for the start of the function SUBR (a FUNCTION_DECL tree node)    and initialize static variables for generating RTL for the statements    of the function.  */
end_comment

begin_function
name|void
name|init_function_start
parameter_list|(
name|subr
parameter_list|,
name|filename
parameter_list|,
name|line
parameter_list|)
name|tree
name|subr
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
name|char
modifier|*
name|junk
decl_stmt|;
name|init_stmt_for_function
argument_list|()
expr_stmt|;
name|cse_not_expected
operator|=
operator|!
name|optimize
expr_stmt|;
comment|/* Caller save not needed yet.  */
name|caller_save_needed
operator|=
literal|0
expr_stmt|;
comment|/* No stack slots have been made yet.  */
name|stack_slot_list
operator|=
literal|0
expr_stmt|;
comment|/* There is no stack slot for handling nonlocal gotos.  */
name|nonlocal_goto_handler_slot
operator|=
literal|0
expr_stmt|;
name|nonlocal_goto_stack_level
operator|=
literal|0
expr_stmt|;
comment|/* No labels have been declared for nonlocal use.  */
name|nonlocal_labels
operator|=
literal|0
expr_stmt|;
comment|/* No function calls so far in this function.  */
name|function_call_count
operator|=
literal|0
expr_stmt|;
comment|/* No parm regs have been allocated.      (This is important for output_inline_function.)  */
name|max_parm_reg
operator|=
name|LAST_VIRTUAL_REGISTER
operator|+
literal|1
expr_stmt|;
comment|/* Initialize the RTL mechanism.  */
name|init_emit
argument_list|()
expr_stmt|;
comment|/* Initialize the queue of pending postincrement and postdecrements,      and some other info in expr.c.  */
name|init_expr
argument_list|()
expr_stmt|;
comment|/* We haven't done register allocation yet.  */
name|reg_renumber
operator|=
literal|0
expr_stmt|;
name|init_const_rtx_hash_table
argument_list|()
expr_stmt|;
name|current_function_name
operator|=
call|(
modifier|*
name|decl_printable_name
call|)
argument_list|(
name|subr
argument_list|,
operator|&
name|junk
argument_list|)
expr_stmt|;
comment|/* Nonzero if this is a nested function that uses a static chain.  */
name|current_function_needs_context
operator|=
operator|(
name|decl_function_context
argument_list|(
name|current_function_decl
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
comment|/* Set if a call to setjmp is seen.  */
name|current_function_calls_setjmp
operator|=
literal|0
expr_stmt|;
comment|/* Set if a call to longjmp is seen.  */
name|current_function_calls_longjmp
operator|=
literal|0
expr_stmt|;
name|current_function_calls_alloca
operator|=
literal|0
expr_stmt|;
name|current_function_has_nonlocal_label
operator|=
literal|0
expr_stmt|;
name|current_function_contains_functions
operator|=
literal|0
expr_stmt|;
name|current_function_returns_pcc_struct
operator|=
literal|0
expr_stmt|;
name|current_function_returns_struct
operator|=
literal|0
expr_stmt|;
name|current_function_epilogue_delay_list
operator|=
literal|0
expr_stmt|;
name|current_function_uses_const_pool
operator|=
literal|0
expr_stmt|;
name|current_function_uses_pic_offset_table
operator|=
literal|0
expr_stmt|;
comment|/* We have not yet needed to make a label to jump to for tail-recursion.  */
name|tail_recursion_label
operator|=
literal|0
expr_stmt|;
comment|/* We haven't had a need to make a save area for ap yet.  */
name|arg_pointer_save_area
operator|=
literal|0
expr_stmt|;
comment|/* No stack slots allocated yet.  */
name|frame_offset
operator|=
literal|0
expr_stmt|;
comment|/* No SAVE_EXPRs in this function yet.  */
name|save_expr_regs
operator|=
literal|0
expr_stmt|;
comment|/* No RTL_EXPRs in this function yet.  */
name|rtl_expr_chain
operator|=
literal|0
expr_stmt|;
comment|/* We have not allocated any temporaries yet.  */
name|temp_slots
operator|=
literal|0
expr_stmt|;
name|temp_slot_level
operator|=
literal|0
expr_stmt|;
comment|/* Within function body, compute a type's size as soon it is laid out.  */
name|immediate_size_expand
operator|++
expr_stmt|;
name|init_pending_stack_adjust
argument_list|()
expr_stmt|;
name|inhibit_defer_pop
operator|=
literal|0
expr_stmt|;
name|current_function_outgoing_args_size
operator|=
literal|0
expr_stmt|;
comment|/* Initialize the insn lengths.  */
name|init_insn_lengths
argument_list|()
expr_stmt|;
comment|/* Prevent ever trying to delete the first instruction of a function.      Also tell final how to output a linenum before the function prologue.  */
name|emit_line_note
argument_list|(
name|filename
argument_list|,
name|line
argument_list|)
expr_stmt|;
comment|/* Make sure first insn is a note even if we don't want linenums.      This makes sure the first insn will never be deleted.      Also, final expects a note to appear there.  */
name|emit_note
argument_list|(
name|NULL_PTR
argument_list|,
name|NOTE_INSN_DELETED
argument_list|)
expr_stmt|;
comment|/* Set flags used by final.c.  */
if|if
condition|(
name|aggregate_value_p
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|PCC_STATIC_STRUCT_RETURN
name|current_function_returns_pcc_struct
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|current_function_returns_struct
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Warn if this value is an aggregate type,      regardless of which calling convention we are using for it.  */
if|if
condition|(
name|warn_aggregate_return
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|)
argument_list|)
operator|==
name|QUAL_UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|)
condition|)
name|warning
argument_list|(
literal|"function returns an aggregate"
argument_list|)
expr_stmt|;
name|current_function_returns_pointer
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
operator|)
expr_stmt|;
comment|/* Indicate that we need to distinguish between the return value of the      present function and the return value of a function being called.  */
name|rtx_equal_function_value_matters
operator|=
literal|1
expr_stmt|;
comment|/* Indicate that we have not instantiated virtual registers yet.  */
name|virtuals_instantiated
operator|=
literal|0
expr_stmt|;
comment|/* Indicate we have no need of a frame pointer yet.  */
name|frame_pointer_needed
operator|=
literal|0
expr_stmt|;
comment|/* By default assume not varargs.  */
name|current_function_varargs
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Indicate that the current function uses extra args    not explicitly mentioned in the argument list in any fashion.  */
end_comment

begin_function
name|void
name|mark_varargs
parameter_list|()
block|{
name|current_function_varargs
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Expand a call to __main at the beginning of a possible main function.  */
end_comment

begin_function
name|void
name|expand_main_function
parameter_list|()
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|INIT_SECTION_ASM_OP
argument_list|)
operator|||
name|defined
argument_list|(
name|INVOKE__main
argument_list|)
name|emit_library_call
argument_list|(
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__main"
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not INIT_SECTION_ASM_OP or INVOKE__main */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Start the RTL for a new function, and set variables used for    emitting RTL.    SUBR is the FUNCTION_DECL node.    PARMS_HAVE_CLEANUPS is nonzero if there are cleanups associated with    the function's parameters, which must be run at any return statement.  */
end_comment

begin_function
name|void
name|expand_function_start
parameter_list|(
name|subr
parameter_list|,
name|parms_have_cleanups
parameter_list|)
name|tree
name|subr
decl_stmt|;
name|int
name|parms_have_cleanups
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|tree
name|tem
decl_stmt|;
name|rtx
name|last_ptr
decl_stmt|;
comment|/* Make sure volatile mem refs aren't considered      valid operands of arithmetic insns.  */
name|init_recog_no_volatile
argument_list|()
expr_stmt|;
comment|/* If function gets a static chain arg, store it in the stack frame.      Do this first, so it gets the first stack slot offset.  */
if|if
condition|(
name|current_function_needs_context
condition|)
block|{
name|last_ptr
operator|=
name|assign_stack_local
argument_list|(
name|Pmode
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|last_ptr
argument_list|,
name|static_chain_incoming_rtx
argument_list|)
expr_stmt|;
block|}
comment|/* If the parameters of this function need cleaning up, get a label      for the beginning of the code which executes those cleanups.  This must      be done before doing anything with return_label.  */
if|if
condition|(
name|parms_have_cleanups
condition|)
name|cleanup_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
else|else
name|cleanup_label
operator|=
literal|0
expr_stmt|;
comment|/* Make the label for return statements to jump to, if this machine      does not have a one-instruction return and uses an epilogue,      or if it returns a structure, or if it has parm cleanups.  */
ifdef|#
directive|ifdef
name|HAVE_return
if|if
condition|(
name|cleanup_label
operator|==
literal|0
operator|&&
name|HAVE_return
operator|&&
operator|!
name|current_function_returns_pcc_struct
operator|&&
operator|!
operator|(
name|current_function_returns_struct
operator|&&
operator|!
name|optimize
operator|)
condition|)
name|return_label
operator|=
literal|0
expr_stmt|;
else|else
name|return_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
else|#
directive|else
name|return_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* Initialize rtx used to return the value.  */
comment|/* Do this before assign_parms so that we copy the struct value address      before any library calls that assign parms might generate.  */
comment|/* Decide whether to return the value in memory or in a register.  */
if|if
condition|(
name|aggregate_value_p
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Returning something that won't go in a register.  */
specifier|register
name|rtx
name|value_address
decl_stmt|;
ifdef|#
directive|ifdef
name|PCC_STATIC_STRUCT_RETURN
if|if
condition|(
name|current_function_returns_pcc_struct
condition|)
block|{
name|int
name|size
init|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|value_address
operator|=
name|assemble_static_space
argument_list|(
name|size
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
comment|/* Expect to be passed the address of a place to store the value. 	     If it is passed as an argument, assign_parms will take care of 	     it.  */
if|if
condition|(
name|struct_value_incoming_rtx
condition|)
block|{
name|value_address
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|value_address
argument_list|,
name|struct_value_incoming_rtx
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|value_address
condition|)
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|DECL_MODE
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|)
argument_list|,
name|value_address
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_MODE
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|)
operator|==
name|VOIDmode
condition|)
comment|/* If return mode is void, this decl rtl should not be used.  */
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|parms_have_cleanups
condition|)
block|{
comment|/* If function will end with cleanup code for parms, 	 compute the return values into a pseudo reg, 	 which we will copy into the true return register 	 after the cleanups are done.  */
name|enum
name|machine_mode
name|mode
init|=
name|DECL_MODE
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|PROMOTE_FUNCTION_RETURN
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|unsignedp
init|=
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|BOOLEAN_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|CHAR_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REAL_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
block|{
name|PROMOTE_MODE
argument_list|(
name|mode
argument_list|,
name|unsignedp
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|)
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Scalar, returned in a register.  */
block|{
ifdef|#
directive|ifdef
name|FUNCTION_OUTGOING_VALUE
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|)
operator|=
name|FUNCTION_OUTGOING_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|)
argument_list|,
name|subr
argument_list|)
expr_stmt|;
else|#
directive|else
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|)
operator|=
name|FUNCTION_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|)
argument_list|,
name|subr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Mark this reg as the function's return value.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|REG_FUNCTION_VALUE_P
argument_list|(
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Needed because we may need to move this to memory 	     in case it's a named return value whose address is taken.  */
name|DECL_REGISTER
argument_list|(
name|DECL_RESULT
argument_list|(
name|subr
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Initialize rtx for parameters and local variables.      In some cases this requires emitting insns.  */
name|assign_parms
argument_list|(
name|subr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* The following was moved from init_function_start.      The move is supposed to make sdb output more accurate.  */
comment|/* Indicate the beginning of the function body,      as opposed to parm setup.  */
name|emit_note
argument_list|(
name|NULL_PTR
argument_list|,
name|NOTE_INSN_FUNCTION_BEG
argument_list|)
expr_stmt|;
comment|/* If doing stupid allocation, mark parms as born here.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|get_last_insn
argument_list|()
argument_list|)
operator|!=
name|NOTE
condition|)
name|emit_note
argument_list|(
name|NULL_PTR
argument_list|,
name|NOTE_INSN_DELETED
argument_list|)
expr_stmt|;
name|parm_birth_insn
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
if|if
condition|(
name|obey_regdecls
condition|)
block|{
for|for
control|(
name|i
operator|=
name|LAST_VIRTUAL_REGISTER
operator|+
literal|1
init|;
name|i
operator|<
name|max_parm_reg
condition|;
name|i
operator|++
control|)
name|use_variable
argument_list|(
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_function_internal_arg_pointer
operator|!=
name|virtual_incoming_args_rtx
condition|)
name|use_variable
argument_list|(
name|current_function_internal_arg_pointer
argument_list|)
expr_stmt|;
block|}
comment|/* Fetch static chain values for containing functions.  */
name|tem
operator|=
name|decl_function_context
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
comment|/* If not doing stupid register allocation, then start off with the static      chain pointer in a pseudo register.  Otherwise, we use the stack      address that was generated above.  */
if|if
condition|(
name|tem
operator|&&
operator|!
name|obey_regdecls
condition|)
name|last_ptr
operator|=
name|copy_to_reg
argument_list|(
name|static_chain_incoming_rtx
argument_list|)
expr_stmt|;
name|context_display
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|tem
condition|)
block|{
name|tree
name|rtlexp
init|=
name|make_node
argument_list|(
name|RTL_EXPR
argument_list|)
decl_stmt|;
name|RTL_EXPR_RTL
argument_list|(
name|rtlexp
argument_list|)
operator|=
name|last_ptr
expr_stmt|;
name|context_display
operator|=
name|tree_cons
argument_list|(
name|tem
argument_list|,
name|rtlexp
argument_list|,
name|context_display
argument_list|)
expr_stmt|;
name|tem
operator|=
name|decl_function_context
argument_list|(
name|tem
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|==
literal|0
condition|)
break|break;
comment|/* Chain thru stack frames, assuming pointer to next lexical frame 	 is found at the place we always store it.  */
ifdef|#
directive|ifdef
name|FRAME_GROWS_DOWNWARD
name|last_ptr
operator|=
name|plus_constant
argument_list|(
name|last_ptr
argument_list|,
operator|-
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|last_ptr
operator|=
name|copy_to_reg
argument_list|(
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|Pmode
argument_list|,
name|memory_address
argument_list|(
name|Pmode
argument_list|,
name|last_ptr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* After the display initializations is where the tail-recursion label      should go, if we end up needing one.   Ensure we have a NOTE here      since some things (like trampolines) get placed before this.  */
name|tail_recursion_reentry
operator|=
name|emit_note
argument_list|(
name|NULL_PTR
argument_list|,
name|NOTE_INSN_DELETED
argument_list|)
expr_stmt|;
comment|/* Evaluate now the sizes of any types declared among the arguments.  */
for|for
control|(
name|tem
operator|=
name|nreverse
argument_list|(
name|get_pending_sizes
argument_list|()
argument_list|)
init|;
name|tem
condition|;
name|tem
operator|=
name|TREE_CHAIN
argument_list|(
name|tem
argument_list|)
control|)
name|expand_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|tem
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Make sure there is a line number after the function entry setup code.  */
name|force_next_line_note
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate RTL for the end of the current function.    FILENAME and LINE are the current position in the source file.  */
end_comment

begin_comment
comment|/* It is up to language-specific callers to do cleanups for parameters.  */
end_comment

begin_function
name|void
name|expand_function_end
parameter_list|(
name|filename
parameter_list|,
name|line
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|tree
name|link
decl_stmt|;
specifier|static
name|rtx
name|initial_trampoline
decl_stmt|;
ifdef|#
directive|ifdef
name|NON_SAVING_SETJMP
comment|/* Don't put any variables in registers if we call setjmp      on a machine that fails to restore the registers.  */
if|if
condition|(
name|NON_SAVING_SETJMP
operator|&&
name|current_function_calls_setjmp
condition|)
block|{
name|setjmp_protect
argument_list|(
name|DECL_INITIAL
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
name|setjmp_protect_args
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Save the argument pointer if a save area was made for it.  */
if|if
condition|(
name|arg_pointer_save_area
condition|)
block|{
name|rtx
name|x
init|=
name|gen_move_insn
argument_list|(
name|arg_pointer_save_area
argument_list|,
name|virtual_incoming_args_rtx
argument_list|)
decl_stmt|;
name|emit_insn_before
argument_list|(
name|x
argument_list|,
name|tail_recursion_reentry
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize any trampolines required by this function.  */
for|for
control|(
name|link
operator|=
name|trampoline_list
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
block|{
name|tree
name|function
init|=
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
decl_stmt|;
name|rtx
name|context
init|=
name|lookup_static_chain
argument_list|(
name|function
argument_list|)
decl_stmt|;
name|rtx
name|tramp
init|=
name|RTL_EXPR_RTL
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|seq
decl_stmt|;
comment|/* First make sure this compilation has a template for 	 initializing trampolines.  */
if|if
condition|(
name|initial_trampoline
operator|==
literal|0
condition|)
block|{
name|end_temporary_allocation
argument_list|()
expr_stmt|;
name|initial_trampoline
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|BLKmode
argument_list|,
name|assemble_trampoline_template
argument_list|()
argument_list|)
expr_stmt|;
name|resume_temporary_allocation
argument_list|()
expr_stmt|;
block|}
comment|/* Generate insns to initialize the trampoline.  */
name|start_sequence
argument_list|()
expr_stmt|;
name|tramp
operator|=
name|change_address
argument_list|(
name|initial_trampoline
argument_list|,
name|BLKmode
argument_list|,
name|round_trampoline_addr
argument_list|(
name|XEXP
argument_list|(
name|tramp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_block_move
argument_list|(
name|tramp
argument_list|,
name|initial_trampoline
argument_list|,
name|GEN_INT
argument_list|(
name|TRAMPOLINE_SIZE
argument_list|)
argument_list|,
name|FUNCTION_BOUNDARY
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|INITIALIZE_TRAMPOLINE
argument_list|(
name|XEXP
argument_list|(
name|tramp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|function
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|context
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
comment|/* Put those insns at entry to the containing function (this one).  */
name|emit_insns_before
argument_list|(
name|seq
argument_list|,
name|tail_recursion_reentry
argument_list|)
expr_stmt|;
block|}
comment|/* Clear the trampoline_list for the next function.  */
name|trampoline_list
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
comment|/* I think unused parms are legitimate enough.  */
comment|/* Warn about unused parms.  */
block|if (warn_unused)     {       rtx decl;        for (decl = DECL_ARGUMENTS (current_function_decl); 	   decl; decl = TREE_CHAIN (decl)) 	if (! TREE_USED (decl)&& TREE_CODE (decl) == VAR_DECL) 	  warning_with_decl (decl, "unused parameter `%s'");     }
endif|#
directive|endif
comment|/* Delete handlers for nonlocal gotos if nothing uses them.  */
if|if
condition|(
name|nonlocal_goto_handler_slot
operator|!=
literal|0
operator|&&
operator|!
name|current_function_has_nonlocal_label
condition|)
name|delete_handlers
argument_list|()
expr_stmt|;
comment|/* End any sequences that failed to be closed due to syntax errors.  */
while|while
condition|(
name|in_sequence_p
argument_list|()
condition|)
name|end_sequence
argument_list|()
expr_stmt|;
comment|/* Outside function body, can't compute type's actual size      until next function's body starts.  */
name|immediate_size_expand
operator|--
expr_stmt|;
comment|/* If doing stupid register allocation,      mark register parms as dying here.  */
if|if
condition|(
name|obey_regdecls
condition|)
block|{
name|rtx
name|tem
decl_stmt|;
for|for
control|(
name|i
operator|=
name|LAST_VIRTUAL_REGISTER
operator|+
literal|1
init|;
name|i
operator|<
name|max_parm_reg
condition|;
name|i
operator|++
control|)
name|use_variable
argument_list|(
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Likewise for the regs of all the SAVE_EXPRs in the function.  */
for|for
control|(
name|tem
operator|=
name|save_expr_regs
init|;
name|tem
condition|;
name|tem
operator|=
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|use_variable
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|use_variable_after
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|parm_birth_insn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|current_function_internal_arg_pointer
operator|!=
name|virtual_incoming_args_rtx
condition|)
name|use_variable
argument_list|(
name|current_function_internal_arg_pointer
argument_list|)
expr_stmt|;
block|}
name|clear_pending_stack_adjust
argument_list|()
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
comment|/* Mark the end of the function body.      If control reaches this insn, the function can drop through      without returning a value.  */
name|emit_note
argument_list|(
name|NULL_PTR
argument_list|,
name|NOTE_INSN_FUNCTION_END
argument_list|)
expr_stmt|;
comment|/* Output a linenumber for the end of the function.      SDB depends on this.  */
name|emit_line_note_force
argument_list|(
name|filename
argument_list|,
name|line
argument_list|)
expr_stmt|;
comment|/* Output the label for the actual return from the function,      if one is expected.  This happens either because a function epilogue      is used instead of a return instruction, or because a return was done      with a goto in order to run local cleanups, or because of pcc-style      structure returning.  */
if|if
condition|(
name|return_label
condition|)
name|emit_label
argument_list|(
name|return_label
argument_list|)
expr_stmt|;
comment|/* If we had calls to alloca, and this machine needs      an accurate stack pointer to exit the function,      insert some code to save and restore the stack pointer.  */
ifdef|#
directive|ifdef
name|EXIT_IGNORE_STACK
if|if
condition|(
operator|!
name|EXIT_IGNORE_STACK
condition|)
endif|#
directive|endif
if|if
condition|(
name|current_function_calls_alloca
condition|)
block|{
name|rtx
name|tem
init|=
literal|0
decl_stmt|;
name|emit_stack_save
argument_list|(
name|SAVE_FUNCTION
argument_list|,
operator|&
name|tem
argument_list|,
name|parm_birth_insn
argument_list|)
expr_stmt|;
name|emit_stack_restore
argument_list|(
name|SAVE_FUNCTION
argument_list|,
name|tem
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
comment|/* If scalar return value was computed in a pseudo-reg,      copy that to the hard return register.  */
if|if
condition|(
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|REGNO
argument_list|(
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
condition|)
block|{
name|rtx
name|real_decl_result
decl_stmt|;
ifdef|#
directive|ifdef
name|FUNCTION_OUTGOING_VALUE
name|real_decl_result
operator|=
name|FUNCTION_OUTGOING_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|,
name|current_function_decl
argument_list|)
expr_stmt|;
else|#
directive|else
name|real_decl_result
operator|=
name|FUNCTION_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|,
name|current_function_decl
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|REG_FUNCTION_VALUE_P
argument_list|(
name|real_decl_result
argument_list|)
operator|=
literal|1
expr_stmt|;
name|emit_move_insn
argument_list|(
name|real_decl_result
argument_list|,
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|USE
argument_list|,
name|VOIDmode
argument_list|,
name|real_decl_result
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If returning a structure, arrange to return the address of the value      in a place where debuggers expect to find it.       If returning a structure PCC style,      the caller also depends on this value.      And current_function_returns_pcc_struct is not necessarily set.  */
if|if
condition|(
name|current_function_returns_struct
operator|||
name|current_function_returns_pcc_struct
condition|)
block|{
name|rtx
name|value_address
init|=
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|FUNCTION_OUTGOING_VALUE
name|rtx
name|outgoing
init|=
name|FUNCTION_OUTGOING_VALUE
argument_list|(
name|build_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|current_function_decl
argument_list|)
decl_stmt|;
else|#
directive|else
name|rtx
name|outgoing
init|=
name|FUNCTION_VALUE
argument_list|(
name|build_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|current_function_decl
argument_list|)
decl_stmt|;
endif|#
directive|endif
comment|/* Mark this as a function return value so integrate will delete the 	 assignment and USE below when inlining this function.  */
name|REG_FUNCTION_VALUE_P
argument_list|(
name|outgoing
argument_list|)
operator|=
literal|1
expr_stmt|;
name|emit_move_insn
argument_list|(
name|outgoing
argument_list|,
name|value_address
argument_list|)
expr_stmt|;
name|use_variable
argument_list|(
name|outgoing
argument_list|)
expr_stmt|;
block|}
comment|/* Output a return insn if we are using one.      Otherwise, let the rtl chain end here, to drop through      into the epilogue.  */
ifdef|#
directive|ifdef
name|HAVE_return
if|if
condition|(
name|HAVE_return
condition|)
block|{
name|emit_jump_insn
argument_list|(
name|gen_return
argument_list|()
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Fix up any gotos that jumped out to the outermost      binding level of the function.      Must follow emitting RETURN_LABEL.  */
comment|/* If you have any cleanups to do at this point,      and they need to create temporary variables,      then you will lose.  */
name|fixup_gotos
argument_list|(
name|NULL_PTR
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_TREE
argument_list|,
name|get_insns
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* These arrays record the INSN_UIDs of the prologue and epilogue insns.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|prologue
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
modifier|*
name|epilogue
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Create an array that records the INSN_UIDs of INSNS (either a sequence    or a single insn).  */
end_comment

begin_function
specifier|static
name|int
modifier|*
name|record_insns
parameter_list|(
name|insns
parameter_list|)
name|rtx
name|insns
decl_stmt|;
block|{
name|int
modifier|*
name|vec
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insns
argument_list|)
operator|==
name|SEQUENCE
condition|)
block|{
name|int
name|len
init|=
name|XVECLEN
argument_list|(
name|insns
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|vec
operator|=
operator|(
name|int
operator|*
operator|)
name|oballoc
argument_list|(
operator|(
name|len
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|vec
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|--
name|len
operator|>=
literal|0
condition|)
name|vec
index|[
name|len
index|]
operator|=
name|INSN_UID
argument_list|(
name|XVECEXP
argument_list|(
name|insns
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vec
operator|=
operator|(
name|int
operator|*
operator|)
name|oballoc
argument_list|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|vec
index|[
literal|0
index|]
operator|=
name|INSN_UID
argument_list|(
name|insns
argument_list|)
expr_stmt|;
name|vec
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|vec
return|;
block|}
end_function

begin_comment
comment|/* Determine how many INSN_UIDs in VEC are part of INSN.  */
end_comment

begin_function
specifier|static
name|int
name|contains
parameter_list|(
name|insn
parameter_list|,
name|vec
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|int
modifier|*
name|vec
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
condition|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|vec
index|[
name|j
index|]
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|INSN_UID
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|vec
index|[
name|j
index|]
condition|)
name|count
operator|++
expr_stmt|;
return|return
name|count
return|;
block|}
else|else
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|vec
index|[
name|j
index|]
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|==
name|vec
index|[
name|j
index|]
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Generate the prologe and epilogue RTL if the machine supports it.  Thread    this into place with notes indicating where the prologue ends and where    the epilogue begins.  Update the basic block information when possible.  */
end_comment

begin_function
name|void
name|thread_prologue_and_epilogue_insns
parameter_list|(
name|f
parameter_list|)
name|rtx
name|f
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|HAVE_prologue
if|if
condition|(
name|HAVE_prologue
condition|)
block|{
name|rtx
name|head
decl_stmt|,
name|seq
decl_stmt|,
name|insn
decl_stmt|;
comment|/* The first insn (a NOTE_INSN_DELETED) is followed by zero or more 	 prologue insns and a NOTE_INSN_PROLOGUE_END.  */
name|emit_note_after
argument_list|(
name|NOTE_INSN_PROLOGUE_END
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|seq
operator|=
name|gen_prologue
argument_list|()
expr_stmt|;
name|head
operator|=
name|emit_insn_after
argument_list|(
name|seq
argument_list|,
name|f
argument_list|)
expr_stmt|;
comment|/* Include the new prologue insns in the first block.  Ignore them 	 if they form a basic block unto themselves.  */
if|if
condition|(
name|basic_block_head
operator|&&
name|n_basic_blocks
operator|&&
name|GET_CODE
argument_list|(
name|basic_block_head
index|[
literal|0
index|]
argument_list|)
operator|!=
name|CODE_LABEL
condition|)
name|basic_block_head
index|[
literal|0
index|]
operator|=
name|NEXT_INSN
argument_list|(
name|f
argument_list|)
expr_stmt|;
comment|/* Retain a map of the prologue insns.  */
name|prologue
operator|=
name|record_insns
argument_list|(
name|GET_CODE
argument_list|(
name|seq
argument_list|)
operator|==
name|SEQUENCE
condition|?
name|seq
else|:
name|head
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|prologue
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_epilogue
if|if
condition|(
name|HAVE_epilogue
condition|)
block|{
name|rtx
name|insn
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
name|rtx
name|prev
init|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* If we end with a BARRIER, we don't need an epilogue.  */
if|if
condition|(
operator|!
operator|(
name|prev
operator|&&
name|GET_CODE
argument_list|(
name|prev
argument_list|)
operator|==
name|BARRIER
operator|)
condition|)
block|{
name|rtx
name|tail
decl_stmt|,
name|seq
decl_stmt|;
comment|/* The last basic block ends with a NOTE_INSN_EPILOGUE_BEG, 	     the epilogue insns (this must include the jump insn that 	     returns), USE insns ad the end of a function, and a BARRIER.  */
name|emit_barrier_after
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Place the epilogue before the USE insns at the end of a 	     function.  */
while|while
condition|(
name|prev
operator|&&
name|GET_CODE
argument_list|(
name|prev
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|prev
argument_list|)
argument_list|)
operator|==
name|USE
condition|)
block|{
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|prev
argument_list|)
expr_stmt|;
name|prev
operator|=
name|prev_nonnote_insn
argument_list|(
name|prev
argument_list|)
expr_stmt|;
block|}
name|seq
operator|=
name|gen_epilogue
argument_list|()
expr_stmt|;
name|tail
operator|=
name|emit_jump_insn_after
argument_list|(
name|seq
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|emit_note_after
argument_list|(
name|NOTE_INSN_EPILOGUE_BEG
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* Include the new epilogue insns in the last block.  Ignore 	     them if they form a basic block unto themselves.  */
if|if
condition|(
name|basic_block_end
operator|&&
name|n_basic_blocks
operator|&&
name|GET_CODE
argument_list|(
name|basic_block_end
index|[
name|n_basic_blocks
operator|-
literal|1
index|]
argument_list|)
operator|!=
name|JUMP_INSN
condition|)
name|basic_block_end
index|[
name|n_basic_blocks
operator|-
literal|1
index|]
operator|=
name|tail
expr_stmt|;
comment|/* Retain a map of the epilogue insns.  */
name|epilogue
operator|=
name|record_insns
argument_list|(
name|GET_CODE
argument_list|(
name|seq
argument_list|)
operator|==
name|SEQUENCE
condition|?
name|seq
else|:
name|tail
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
endif|#
directive|endif
name|epilogue
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Reposition the prologue-end and epilogue-begin notes after instruction    scheduling and delayed branch scheduling.  */
end_comment

begin_function
name|void
name|reposition_prologue_and_epilogue_notes
parameter_list|(
name|f
parameter_list|)
name|rtx
name|f
decl_stmt|;
block|{
if|#
directive|if
name|defined
argument_list|(
name|HAVE_prologue
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_epilogue
argument_list|)
comment|/* Reposition the prologue and epilogue notes.  */
if|if
condition|(
name|n_basic_blocks
condition|)
block|{
name|rtx
name|next
decl_stmt|,
name|prev
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|prologue
condition|)
block|{
specifier|register
name|rtx
name|insn
decl_stmt|,
name|note
init|=
literal|0
decl_stmt|;
comment|/* Scan from the beginning until we reach the last prologue insn. 	     We apparently can't depend on basic_block_{head,end} after 	     reorg has run.  */
for|for
control|(
name|len
operator|=
literal|0
init|;
name|prologue
index|[
name|len
index|]
condition|;
name|len
operator|++
control|)
empty_stmt|;
for|for
control|(
name|insn
operator|=
name|f
init|;
name|len
operator|&&
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
block|{
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_PROLOGUE_END
condition|)
name|note
operator|=
name|insn
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|len
operator|-=
name|contains
argument_list|(
name|insn
argument_list|,
name|prologue
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Find the prologue-end note if we haven't already, and 		     move it to just after the last prologue insn.  */
if|if
condition|(
name|note
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|note
operator|=
name|insn
init|;
name|note
operator|=
name|NEXT_INSN
argument_list|(
name|note
argument_list|)
condition|;
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|note
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|note
argument_list|)
operator|==
name|NOTE_INSN_PROLOGUE_END
condition|)
break|break;
block|}
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|note
argument_list|)
expr_stmt|;
name|prev
operator|=
name|PREV_INSN
argument_list|(
name|note
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
condition|)
name|NEXT_INSN
argument_list|(
name|prev
argument_list|)
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|next
condition|)
name|PREV_INSN
argument_list|(
name|next
argument_list|)
operator|=
name|prev
expr_stmt|;
name|add_insn_after
argument_list|(
name|note
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|epilogue
condition|)
block|{
specifier|register
name|rtx
name|insn
decl_stmt|,
name|note
init|=
literal|0
decl_stmt|;
comment|/* Scan from the end until we reach the first epilogue insn. 	     We apparently can't depend on basic_block_{head,end} after 	     reorg has run.  */
for|for
control|(
name|len
operator|=
literal|0
init|;
name|epilogue
index|[
name|len
index|]
condition|;
name|len
operator|++
control|)
empty_stmt|;
for|for
control|(
name|insn
operator|=
name|get_last_insn
argument_list|()
init|;
name|len
operator|&&
name|insn
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
block|{
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_EPILOGUE_BEG
condition|)
name|note
operator|=
name|insn
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|len
operator|-=
name|contains
argument_list|(
name|insn
argument_list|,
name|epilogue
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Find the epilogue-begin note if we haven't already, and 		     move it to just before the first epilogue insn.  */
if|if
condition|(
name|note
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|note
operator|=
name|insn
init|;
name|note
operator|=
name|PREV_INSN
argument_list|(
name|note
argument_list|)
condition|;
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|note
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|note
argument_list|)
operator|==
name|NOTE_INSN_EPILOGUE_BEG
condition|)
break|break;
block|}
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|note
argument_list|)
expr_stmt|;
name|prev
operator|=
name|PREV_INSN
argument_list|(
name|note
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
condition|)
name|NEXT_INSN
argument_list|(
name|prev
argument_list|)
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|next
condition|)
name|PREV_INSN
argument_list|(
name|next
argument_list|)
operator|=
name|prev
expr_stmt|;
name|add_insn_after
argument_list|(
name|note
argument_list|,
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
endif|#
directive|endif
comment|/* HAVE_prologue or HAVE_epilogue */
block|}
end_function

end_unit

