begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* real.c - implementation of REAL_ARITHMETIC, REAL_VALUE_ATOF, and support for XFmode IEEE extended real floating point arithmetic. Contributed by Stephen L. Moshier (moshier@world.std.com).     Copyright (C) 1993 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|errno
end_ifndef

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* To enable support of XFmode extended real floating point, define LONG_DOUBLE_TYPE_SIZE 96 in the tm.h file (m68k.h or i386.h).  To support cross compilation between IEEE and VAX floating point formats, define REAL_ARITHMETIC in the tm.h file.  In either case the machine files (tm.h) must not contain any code that tries to use host floating point arithmetic to convert REAL_VALUE_TYPEs from `double' to `float', pass them to fprintf, etc.  In cross-compile situations a REAL_VALUE_TYPE may not be intelligible to the host computer's native arithmetic.  The emulator defaults to the host's floating point format so that its decimal conversion functions can be used if desired (see real.h).  The first part of this file interfaces gcc to ieee.c, which is a floating point arithmetic suite that was not written with gcc in mind.  The interface is followed by ieee.c itself and related items. Avoid changing ieee.c unless you have suitable test programs available.  A special version of the PARANOIA floating point arithmetic tester, modified for this purpose, can be found on usc.edu : /pub/C-numanal/ieeetest.zoo.  Some tutorial information on ieee.c is given in my book: S. L. Moshier, _Methods and Programs for Mathematical Functions_, Prentice-Hall or Simon& Schuster Int'l, 1989.  A library of XFmode elementary transcendental functions can be obtained by ftp from research.att.com: netlib/cephes/ldouble.shar.Z  */
end_comment

begin_comment
comment|/* Type of computer arithmetic.  * Only one of DEC, MIEEE, IBMPC, or UNK should get defined.  */
end_comment

begin_comment
comment|/* `MIEEE' refers generically to big-endian IEEE floating-point data    structure.  This definition should work in SFmode `float' type and    DFmode `double' type on virtually all big-endian IEEE machines.    If LONG_DOUBLE_TYPE_SIZE has been defined to be 96, then MIEEE    also invokes the particular XFmode (`long double' type) data    structure used by the Motorola 680x0 series processors.     `IBMPC' refers generally to little-endian IEEE machines. In this    case, if LONG_DOUBLE_TYPE_SIZE has been defined to be 96, then    IBMPC also invokes the particular XFmode `long double' data    structure used by the Intel 80x86 series processors.     `DEC' refers specifically to the Digital Equipment Corp PDP-11    and VAX floating point data structure.  This model currently    supports no type wider than DFmode.     If LONG_DOUBLE_TYPE_SIZE = 64 (the default, unless tm.h defines it)    then `long double' and `double' are both implemented, but they    both mean DFmode.  In this case, the software floating-point    support available here is activated by writing       #define REAL_ARITHMETIC    in tm.h.      The case LONG_DOUBLE_TYPE_SIZE = 128 activates TFmode support    (Not Yet Implemented) and may deactivate XFmode since    `long double' is used to refer to both modes.    */
end_comment

begin_comment
comment|/* The following converts gcc macros into the ones used by this file.  */
end_comment

begin_comment
comment|/* REAL_ARITHMETIC defined means that macros in real.h are    defined to call emulator functions.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|REAL_ARITHMETIC
end_ifdef

begin_if
if|#
directive|if
name|TARGET_FLOAT_FORMAT
operator|==
name|VAX_FLOAT_FORMAT
end_if

begin_comment
comment|/* PDP-11, Pro350, VAX: */
end_comment

begin_define
define|#
directive|define
name|DEC
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* it's not VAX */
end_comment

begin_if
if|#
directive|if
name|TARGET_FLOAT_FORMAT
operator|==
name|IEEE_FLOAT_FORMAT
end_if

begin_if
if|#
directive|if
name|WORDS_BIG_ENDIAN
end_if

begin_comment
comment|/* Motorola IEEE, high order words come first (Sun workstation): */
end_comment

begin_define
define|#
directive|define
name|MIEEE
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not big-endian */
end_comment

begin_comment
comment|/* Intel IEEE, low order words come first:  */
end_comment

begin_define
define|#
directive|define
name|IBMPC
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  big-endian */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* it's not IEEE either */
end_comment

begin_comment
comment|/* UNKnown arithmetic.  We don't support this and can't go on. */
end_comment

begin_function_decl
name|unknown
name|arithmetic
name|type
define|#
directive|define
name|UNK
value|1
endif|#
directive|endif
comment|/* not IEEE */
endif|#
directive|endif
comment|/* not VAX */
else|#
directive|else
comment|/* REAL_ARITHMETIC not defined means that the *host's* data    structure will be used.  It may differ by endian-ness from the    target machine's structure and will get its ends swapped    accordingly (but not here).  Probably only the decimal<-> binary    functions in this file will actually be used in this case.  */
if|#
directive|if
name|HOST_FLOAT_FORMAT
operator|==
name|VAX_FLOAT_FORMAT
define|#
directive|define
name|DEC
value|1
else|#
directive|else
comment|/* it's not VAX */
if|#
directive|if
name|HOST_FLOAT_FORMAT
operator|==
name|IEEE_FLOAT_FORMAT
ifdef|#
directive|ifdef
name|HOST_WORDS_BIG_ENDIAN
define|#
directive|define
name|MIEEE
value|1
else|#
directive|else
comment|/* not big-endian */
define|#
directive|define
name|IBMPC
value|1
endif|#
directive|endif
comment|/*  big-endian */
else|#
directive|else
comment|/* it's not IEEE either */
name|unknown
name|arithmetic
name|type
define|#
directive|define
name|UNK
value|1
endif|#
directive|endif
comment|/* not IEEE */
endif|#
directive|endif
comment|/* not VAX */
endif|#
directive|endif
comment|/* REAL_ARITHMETIC not defined */
comment|/* Define INFINITY for support of infinity.    Define NANS for support of Not-a-Number's (NaN's).  */
ifndef|#
directive|ifndef
name|DEC
define|#
directive|define
name|INFINITY
define|#
directive|define
name|NANS
endif|#
directive|endif
comment|/* Support of NaNs requires support of infinity. */
ifdef|#
directive|ifdef
name|NANS
ifndef|#
directive|ifndef
name|INFINITY
define|#
directive|define
name|INFINITY
endif|#
directive|endif
endif|#
directive|endif
comment|/* ehead.h  *  * Include file for extended precision arithmetic programs.  */
comment|/* Number of 16 bit words in external e type format */
define|#
directive|define
name|NE
value|6
comment|/* Number of 16 bit words in internal format */
define|#
directive|define
name|NI
value|(NE+3)
comment|/* Array offset to exponent */
define|#
directive|define
name|E
value|1
comment|/* Array offset to high guard word */
define|#
directive|define
name|M
value|2
comment|/* Number of bits of precision */
define|#
directive|define
name|NBITS
value|((NI-4)*16)
comment|/* Maximum number of decimal digits in ASCII conversion  * = NBITS*log10(2)  */
define|#
directive|define
name|NDEC
value|(NBITS*8/27)
comment|/* The exponent of 1.0 */
define|#
directive|define
name|EXONE
value|(0x3fff)
comment|/* Find a host integer type that is at least 16 bits wide,    and another type at least twice whatever that size is. */
if|#
directive|if
name|HOST_BITS_PER_CHAR
operator|>=
literal|16
define|#
directive|define
name|EMUSHORT
value|char
define|#
directive|define
name|EMUSHORT_SIZE
value|HOST_BITS_PER_CHAR
define|#
directive|define
name|EMULONG_SIZE
value|(2 * HOST_BITS_PER_CHAR)
else|#
directive|else
if|#
directive|if
name|HOST_BITS_PER_SHORT
operator|>=
literal|16
define|#
directive|define
name|EMUSHORT
value|short
define|#
directive|define
name|EMUSHORT_SIZE
value|HOST_BITS_PER_SHORT
define|#
directive|define
name|EMULONG_SIZE
value|(2 * HOST_BITS_PER_SHORT)
else|#
directive|else
if|#
directive|if
name|HOST_BITS_PER_INT
operator|>=
literal|16
define|#
directive|define
name|EMUSHORT
value|int
define|#
directive|define
name|EMUSHORT_SIZE
value|HOST_BITS_PER_INT
define|#
directive|define
name|EMULONG_SIZE
value|(2 * HOST_BITS_PER_INT)
else|#
directive|else
if|#
directive|if
name|HOST_BITS_PER_LONG
operator|>=
literal|16
define|#
directive|define
name|EMUSHORT
value|long
define|#
directive|define
name|EMUSHORT_SIZE
value|HOST_BITS_PER_LONG
define|#
directive|define
name|EMULONG_SIZE
value|(2 * HOST_BITS_PER_LONG)
else|#
directive|else
comment|/*  You will have to modify this program to have a smaller unit size. */
define|#
directive|define
name|EMU_NON_COMPILE
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
if|#
directive|if
name|HOST_BITS_PER_SHORT
operator|>=
name|EMULONG_SIZE
define|#
directive|define
name|EMULONG
value|short
else|#
directive|else
if|#
directive|if
name|HOST_BITS_PER_INT
operator|>=
name|EMULONG_SIZE
define|#
directive|define
name|EMULONG
value|int
else|#
directive|else
if|#
directive|if
name|HOST_BITS_PER_LONG
operator|>=
name|EMULONG_SIZE
define|#
directive|define
name|EMULONG
value|long
else|#
directive|else
if|#
directive|if
name|HOST_BITS_PER_LONG_LONG
operator|>=
name|EMULONG_SIZE
define|#
directive|define
name|EMULONG
value|long long int
else|#
directive|else
comment|/*  You will have to modify this program to have a smaller unit size. */
define|#
directive|define
name|EMU_NON_COMPILE
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
comment|/* The host interface doesn't work if no 16-bit size exists. */
if|#
directive|if
name|EMUSHORT_SIZE
operator|!=
literal|16
define|#
directive|define
name|EMU_NON_COMPILE
endif|#
directive|endif
comment|/* OK to continue compilation. */
ifndef|#
directive|ifndef
name|EMU_NON_COMPILE
comment|/* Construct macros to translate between REAL_VALUE_TYPE and e type.    In GET_REAL and PUT_REAL, r and e are pointers.    A REAL_VALUE_TYPE is guaranteed to occupy contiguous locations    in memory, with no holes.  */
if|#
directive|if
name|LONG_DOUBLE_TYPE_SIZE
operator|==
literal|96
define|#
directive|define
name|GET_REAL
parameter_list|(
name|r
parameter_list|,
name|e
parameter_list|)
value|bcopy (r, e, 2*NE)
define|#
directive|define
name|PUT_REAL
parameter_list|(
name|e
parameter_list|,
name|r
parameter_list|)
value|bcopy (e, r, 2*NE)
else|#
directive|else
comment|/* no XFmode */
ifdef|#
directive|ifdef
name|REAL_ARITHMETIC
comment|/* Emulator uses target format internally    but host stores it in host endian-ness. */
if|#
directive|if
name|defined
argument_list|(
name|HOST_WORDS_BIG_ENDIAN
argument_list|)
operator|==
name|WORDS_BIG_ENDIAN
define|#
directive|define
name|GET_REAL
parameter_list|(
name|r
parameter_list|,
name|e
parameter_list|)
value|e53toe ((r), (e))
define|#
directive|define
name|PUT_REAL
parameter_list|(
name|e
parameter_list|,
name|r
parameter_list|)
value|etoe53 ((e), (r))
else|#
directive|else
comment|/* endian-ness differs */
comment|/* emulator uses target endian-ness internally */
define|#
directive|define
name|GET_REAL
parameter_list|(
name|r
parameter_list|,
name|e
parameter_list|)
define|\
value|do { EMUSHORT w[4];		\  w[3] = ((EMUSHORT *) r)[0];	\  w[2] = ((EMUSHORT *) r)[1];	\  w[1] = ((EMUSHORT *) r)[2];	\  w[0] = ((EMUSHORT *) r)[3];	\  e53toe (w, (e)); } while (0)
define|#
directive|define
name|PUT_REAL
parameter_list|(
name|e
parameter_list|,
name|r
parameter_list|)
define|\
value|do { EMUSHORT w[4];		\  etoe53 ((e), w);		\  *((EMUSHORT *) r) = w[3];	\  *((EMUSHORT *) r + 1) = w[2];	\  *((EMUSHORT *) r + 2) = w[1];	\  *((EMUSHORT *) r + 3) = w[0]; } while (0)
endif|#
directive|endif
comment|/* endian-ness differs */
else|#
directive|else
comment|/* not REAL_ARITHMETIC */
comment|/* emulator uses host format */
define|#
directive|define
name|GET_REAL
parameter_list|(
name|r
parameter_list|,
name|e
parameter_list|)
value|e53toe ((r), (e))
define|#
directive|define
name|PUT_REAL
parameter_list|(
name|e
parameter_list|,
name|r
parameter_list|)
value|etoe53 ((e), (r))
endif|#
directive|endif
comment|/* not REAL_ARITHMETIC */
endif|#
directive|endif
comment|/* no XFmode */
name|void
name|warning
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|int
name|extra_warnings
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ecmp
argument_list|()
decl_stmt|,
name|enormlz
argument_list|()
decl_stmt|,
name|eshift
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|eisneg
argument_list|()
decl_stmt|,
name|eisinf
argument_list|()
decl_stmt|,
name|eisnan
argument_list|()
decl_stmt|,
name|eiisinf
argument_list|()
decl_stmt|,
name|eiisnan
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|eadd
argument_list|()
decl_stmt|,
name|esub
argument_list|()
decl_stmt|,
name|emul
argument_list|()
decl_stmt|,
name|ediv
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|eshup1
argument_list|()
decl_stmt|,
name|eshup8
argument_list|()
decl_stmt|,
name|eshup6
argument_list|()
decl_stmt|,
name|eshdn1
argument_list|()
decl_stmt|,
name|eshdn8
argument_list|()
decl_stmt|,
name|eshdn6
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|eabs
argument_list|()
decl_stmt|,
name|eneg
argument_list|()
decl_stmt|,
name|emov
argument_list|()
decl_stmt|,
name|eclear
argument_list|()
decl_stmt|,
name|einfin
argument_list|()
decl_stmt|,
name|efloor
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|eldexp
argument_list|()
decl_stmt|,
name|efrexp
argument_list|()
decl_stmt|,
name|eifrac
argument_list|()
decl_stmt|,
name|euifrac
argument_list|()
decl_stmt|,
name|ltoe
argument_list|()
decl_stmt|,
name|ultoe
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|eround
argument_list|()
decl_stmt|,
name|ereal_to_decimal
argument_list|()
decl_stmt|,
name|eiinfin
argument_list|()
decl_stmt|,
name|einan
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|esqrt
argument_list|()
decl_stmt|,
name|elog
argument_list|()
decl_stmt|,
name|eexp
argument_list|()
decl_stmt|,
name|etanh
argument_list|()
decl_stmt|,
name|epow
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|asctoe
argument_list|()
decl_stmt|,
name|asctoe24
argument_list|()
decl_stmt|,
name|asctoe53
argument_list|()
decl_stmt|,
name|asctoe64
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|etoasc
argument_list|()
decl_stmt|,
name|e24toasc
argument_list|()
decl_stmt|,
name|e53toasc
argument_list|()
decl_stmt|,
name|e64toasc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|etoe64
argument_list|()
decl_stmt|,
name|etoe53
argument_list|()
decl_stmt|,
name|etoe24
argument_list|()
decl_stmt|,
name|e64toe
argument_list|()
decl_stmt|,
name|e53toe
argument_list|()
decl_stmt|,
name|e24toe
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|mtherr
argument_list|()
decl_stmt|,
name|make_nan
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|enan
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|unsigned
name|EMUSHORT
name|ezero
index|[]
decl_stmt|,
name|ehalf
index|[]
decl_stmt|,
name|eone
index|[]
decl_stmt|,
name|etwo
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
name|EMUSHORT
name|elog2
index|[]
decl_stmt|,
name|esqrt2
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pack output array with 32-bit numbers obtained from    array containing 16-bit numbers, swapping ends if required. */
end_comment

begin_function
name|void
name|endian
parameter_list|(
name|e
parameter_list|,
name|x
parameter_list|,
name|mode
parameter_list|)
name|unsigned
name|EMUSHORT
name|e
index|[]
decl_stmt|;
name|long
name|x
index|[]
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|unsigned
name|long
name|th
decl_stmt|,
name|t
decl_stmt|;
if|#
directive|if
name|WORDS_BIG_ENDIAN
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|XFmode
case|:
comment|/* Swap halfwords in the third long. */
name|th
operator|=
operator|(
name|unsigned
name|long
operator|)
name|e
index|[
literal|4
index|]
operator|&
literal|0xffff
expr_stmt|;
name|t
operator|=
operator|(
name|unsigned
name|long
operator|)
name|e
index|[
literal|5
index|]
operator|&
literal|0xffff
expr_stmt|;
name|t
operator||=
name|th
operator|<<
literal|16
expr_stmt|;
name|x
index|[
literal|2
index|]
operator|=
operator|(
name|long
operator|)
name|t
expr_stmt|;
comment|/* fall into the double case */
case|case
name|DFmode
case|:
comment|/* swap halfwords in the second word */
name|th
operator|=
operator|(
name|unsigned
name|long
operator|)
name|e
index|[
literal|2
index|]
operator|&
literal|0xffff
expr_stmt|;
name|t
operator|=
operator|(
name|unsigned
name|long
operator|)
name|e
index|[
literal|3
index|]
operator|&
literal|0xffff
expr_stmt|;
name|t
operator||=
name|th
operator|<<
literal|16
expr_stmt|;
name|x
index|[
literal|1
index|]
operator|=
operator|(
name|long
operator|)
name|t
expr_stmt|;
comment|/* fall into the float case */
case|case
name|SFmode
case|:
comment|/* swap halfwords in the first word */
name|th
operator|=
operator|(
name|unsigned
name|long
operator|)
name|e
index|[
literal|0
index|]
operator|&
literal|0xffff
expr_stmt|;
name|t
operator|=
operator|(
name|unsigned
name|long
operator|)
name|e
index|[
literal|1
index|]
operator|&
literal|0xffff
expr_stmt|;
name|t
operator||=
name|th
operator|<<
literal|16
expr_stmt|;
name|x
index|[
literal|0
index|]
operator|=
name|t
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
else|#
directive|else
comment|/* Pack the output array without swapping. */
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|XFmode
case|:
comment|/* Pack the third long. 	 Each element of the input REAL_VALUE_TYPE array has 16 bit useful bits 	 in it.  */
name|th
operator|=
operator|(
name|unsigned
name|long
operator|)
name|e
index|[
literal|5
index|]
operator|&
literal|0xffff
expr_stmt|;
name|t
operator|=
operator|(
name|unsigned
name|long
operator|)
name|e
index|[
literal|4
index|]
operator|&
literal|0xffff
expr_stmt|;
name|t
operator||=
name|th
operator|<<
literal|16
expr_stmt|;
name|x
index|[
literal|2
index|]
operator|=
operator|(
name|long
operator|)
name|t
expr_stmt|;
comment|/* fall into the double case */
case|case
name|DFmode
case|:
comment|/* pack the second long */
name|th
operator|=
operator|(
name|unsigned
name|long
operator|)
name|e
index|[
literal|3
index|]
operator|&
literal|0xffff
expr_stmt|;
name|t
operator|=
operator|(
name|unsigned
name|long
operator|)
name|e
index|[
literal|2
index|]
operator|&
literal|0xffff
expr_stmt|;
name|t
operator||=
name|th
operator|<<
literal|16
expr_stmt|;
name|x
index|[
literal|1
index|]
operator|=
operator|(
name|long
operator|)
name|t
expr_stmt|;
comment|/* fall into the float case */
case|case
name|SFmode
case|:
comment|/* pack the first long */
name|th
operator|=
operator|(
name|unsigned
name|long
operator|)
name|e
index|[
literal|1
index|]
operator|&
literal|0xffff
expr_stmt|;
name|t
operator|=
operator|(
name|unsigned
name|long
operator|)
name|e
index|[
literal|0
index|]
operator|&
literal|0xffff
expr_stmt|;
name|t
operator||=
name|th
operator|<<
literal|16
expr_stmt|;
name|x
index|[
literal|0
index|]
operator|=
name|t
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* This is the implementation of the REAL_ARITHMETIC macro.  */
end_comment

begin_function
name|void
name|earith
parameter_list|(
name|value
parameter_list|,
name|icode
parameter_list|,
name|r1
parameter_list|,
name|r2
parameter_list|)
name|REAL_VALUE_TYPE
modifier|*
name|value
decl_stmt|;
name|int
name|icode
decl_stmt|;
name|REAL_VALUE_TYPE
modifier|*
name|r1
decl_stmt|;
name|REAL_VALUE_TYPE
modifier|*
name|r2
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|d1
index|[
name|NE
index|]
decl_stmt|,
name|d2
index|[
name|NE
index|]
decl_stmt|,
name|v
index|[
name|NE
index|]
decl_stmt|;
name|enum
name|tree_code
name|code
decl_stmt|;
name|GET_REAL
argument_list|(
name|r1
argument_list|,
name|d1
argument_list|)
expr_stmt|;
name|GET_REAL
argument_list|(
name|r2
argument_list|,
name|d2
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NANS
comment|/*  Return NaN input back to the caller. */
if|if
condition|(
name|eisnan
argument_list|(
name|d1
argument_list|)
condition|)
block|{
name|PUT_REAL
argument_list|(
name|d1
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|eisnan
argument_list|(
name|d2
argument_list|)
condition|)
block|{
name|PUT_REAL
argument_list|(
name|d2
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|code
operator|=
operator|(
expr|enum
name|tree_code
operator|)
name|icode
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PLUS_EXPR
case|:
name|eadd
argument_list|(
name|d2
argument_list|,
name|d1
argument_list|,
name|v
argument_list|)
expr_stmt|;
break|break;
case|case
name|MINUS_EXPR
case|:
name|esub
argument_list|(
name|d2
argument_list|,
name|d1
argument_list|,
name|v
argument_list|)
expr_stmt|;
comment|/* d1 - d2 */
break|break;
case|case
name|MULT_EXPR
case|:
name|emul
argument_list|(
name|d2
argument_list|,
name|d1
argument_list|,
name|v
argument_list|)
expr_stmt|;
break|break;
case|case
name|RDIV_EXPR
case|:
ifndef|#
directive|ifndef
name|REAL_INFINITY
if|if
condition|(
name|ecmp
argument_list|(
name|d2
argument_list|,
name|ezero
argument_list|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|NANS
name|enan
argument_list|(
name|v
argument_list|)
expr_stmt|;
break|break;
else|#
directive|else
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
name|ediv
argument_list|(
name|d2
argument_list|,
name|d1
argument_list|,
name|v
argument_list|)
expr_stmt|;
comment|/* d1/d2 */
break|break;
case|case
name|MIN_EXPR
case|:
comment|/* min (d1,d2) */
if|if
condition|(
name|ecmp
argument_list|(
name|d1
argument_list|,
name|d2
argument_list|)
operator|<
literal|0
condition|)
name|emov
argument_list|(
name|d1
argument_list|,
name|v
argument_list|)
expr_stmt|;
else|else
name|emov
argument_list|(
name|d2
argument_list|,
name|v
argument_list|)
expr_stmt|;
break|break;
case|case
name|MAX_EXPR
case|:
comment|/* max (d1,d2) */
if|if
condition|(
name|ecmp
argument_list|(
name|d1
argument_list|,
name|d2
argument_list|)
operator|>
literal|0
condition|)
name|emov
argument_list|(
name|d1
argument_list|,
name|v
argument_list|)
expr_stmt|;
else|else
name|emov
argument_list|(
name|d2
argument_list|,
name|v
argument_list|)
expr_stmt|;
break|break;
default|default:
name|emov
argument_list|(
name|ezero
argument_list|,
name|v
argument_list|)
expr_stmt|;
break|break;
block|}
name|PUT_REAL
argument_list|(
name|v
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Truncate REAL_VALUE_TYPE toward zero to signed HOST_WIDE_INT  * implements REAL_VALUE_RNDZINT (x) (etrunci (x))  */
end_comment

begin_function
name|REAL_VALUE_TYPE
name|etrunci
parameter_list|(
name|x
parameter_list|)
name|REAL_VALUE_TYPE
name|x
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|f
index|[
name|NE
index|]
decl_stmt|,
name|g
index|[
name|NE
index|]
decl_stmt|;
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|long
name|l
decl_stmt|;
name|GET_REAL
argument_list|(
operator|&
name|x
argument_list|,
name|g
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NANS
if|if
condition|(
name|eisnan
argument_list|(
name|g
argument_list|)
condition|)
return|return
operator|(
name|x
operator|)
return|;
endif|#
directive|endif
name|eifrac
argument_list|(
name|g
argument_list|,
operator|&
name|l
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|ltoe
argument_list|(
operator|&
name|l
argument_list|,
name|g
argument_list|)
expr_stmt|;
name|PUT_REAL
argument_list|(
name|g
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Truncate REAL_VALUE_TYPE toward zero to unsigned HOST_WIDE_INT  * implements REAL_VALUE_UNSIGNED_RNDZINT (x) (etruncui (x))  */
end_comment

begin_function
name|REAL_VALUE_TYPE
name|etruncui
parameter_list|(
name|x
parameter_list|)
name|REAL_VALUE_TYPE
name|x
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|f
index|[
name|NE
index|]
decl_stmt|,
name|g
index|[
name|NE
index|]
decl_stmt|;
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|unsigned
name|long
name|l
decl_stmt|;
name|GET_REAL
argument_list|(
operator|&
name|x
argument_list|,
name|g
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NANS
if|if
condition|(
name|eisnan
argument_list|(
name|g
argument_list|)
condition|)
return|return
operator|(
name|x
operator|)
return|;
endif|#
directive|endif
name|euifrac
argument_list|(
name|g
argument_list|,
operator|&
name|l
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|ultoe
argument_list|(
operator|&
name|l
argument_list|,
name|g
argument_list|)
expr_stmt|;
name|PUT_REAL
argument_list|(
name|g
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_comment
comment|/* This is the REAL_VALUE_ATOF function.  * It converts a decimal string to binary, rounding off  * as indicated by the machine_mode argument.  Then it  * promotes the rounded value to REAL_VALUE_TYPE.  */
end_comment

begin_function
name|REAL_VALUE_TYPE
name|ereal_atof
parameter_list|(
name|s
parameter_list|,
name|t
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|enum
name|machine_mode
name|t
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|tem
index|[
name|NE
index|]
decl_stmt|,
name|e
index|[
name|NE
index|]
decl_stmt|;
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
switch|switch
condition|(
name|t
condition|)
block|{
case|case
name|SFmode
case|:
name|asctoe24
argument_list|(
name|s
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|e24toe
argument_list|(
name|tem
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|DFmode
case|:
name|asctoe53
argument_list|(
name|s
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|e53toe
argument_list|(
name|tem
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|XFmode
case|:
name|asctoe64
argument_list|(
name|s
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|e64toe
argument_list|(
name|tem
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
default|default:
name|asctoe
argument_list|(
name|s
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|PUT_REAL
argument_list|(
name|e
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Expansion of REAL_NEGATE.  */
end_comment

begin_function
name|REAL_VALUE_TYPE
name|ereal_negate
parameter_list|(
name|x
parameter_list|)
name|REAL_VALUE_TYPE
name|x
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|e
index|[
name|NE
index|]
decl_stmt|;
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|GET_REAL
argument_list|(
operator|&
name|x
argument_list|,
name|e
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NANS
if|if
condition|(
name|eisnan
argument_list|(
name|e
argument_list|)
condition|)
return|return
operator|(
name|x
operator|)
return|;
endif|#
directive|endif
name|eneg
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|PUT_REAL
argument_list|(
name|e
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Round real to int  * implements REAL_VALUE_FIX (x) (eroundi (x))  * The type of rounding is left unspecified by real.h.  * It is implemented here as round to nearest (add .5 and chop).  */
end_comment

begin_function
name|int
name|eroundi
parameter_list|(
name|x
parameter_list|)
name|REAL_VALUE_TYPE
name|x
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|f
index|[
name|NE
index|]
decl_stmt|,
name|g
index|[
name|NE
index|]
decl_stmt|;
name|EMULONG
name|l
decl_stmt|;
name|GET_REAL
argument_list|(
operator|&
name|x
argument_list|,
name|f
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NANS
if|if
condition|(
name|eisnan
argument_list|(
name|f
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"conversion from NaN to int"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
name|eround
argument_list|(
name|f
argument_list|,
name|g
argument_list|)
expr_stmt|;
name|eifrac
argument_list|(
name|g
argument_list|,
operator|&
name|l
argument_list|,
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|l
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Round real to nearest unsigned int  * implements  REAL_VALUE_UNSIGNED_FIX (x) ((unsigned int) eroundi (x))  * Negative input returns zero.  * The type of rounding is left unspecified by real.h.  * It is implemented here as round to nearest (add .5 and chop).  */
end_comment

begin_function
name|unsigned
name|int
name|eroundui
parameter_list|(
name|x
parameter_list|)
name|REAL_VALUE_TYPE
name|x
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|f
index|[
name|NE
index|]
decl_stmt|,
name|g
index|[
name|NE
index|]
decl_stmt|;
name|unsigned
name|EMULONG
name|l
decl_stmt|;
name|GET_REAL
argument_list|(
operator|&
name|x
argument_list|,
name|f
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NANS
if|if
condition|(
name|eisnan
argument_list|(
name|f
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"conversion from NaN to unsigned int"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
name|eround
argument_list|(
name|f
argument_list|,
name|g
argument_list|)
expr_stmt|;
name|euifrac
argument_list|(
name|g
argument_list|,
operator|&
name|l
argument_list|,
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|unsigned
name|int
operator|)
name|l
operator|)
return|;
block|}
end_function

begin_comment
comment|/* REAL_VALUE_FROM_INT macro.  */
end_comment

begin_function
name|void
name|ereal_from_int
parameter_list|(
name|d
parameter_list|,
name|i
parameter_list|,
name|j
parameter_list|)
name|REAL_VALUE_TYPE
modifier|*
name|d
decl_stmt|;
name|long
name|i
decl_stmt|,
name|j
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|df
index|[
name|NE
index|]
decl_stmt|,
name|dg
index|[
name|NE
index|]
decl_stmt|;
name|long
name|low
decl_stmt|,
name|high
decl_stmt|;
name|int
name|sign
decl_stmt|;
name|sign
operator|=
literal|0
expr_stmt|;
name|low
operator|=
name|i
expr_stmt|;
if|if
condition|(
operator|(
name|high
operator|=
name|j
operator|)
operator|<
literal|0
condition|)
block|{
name|sign
operator|=
literal|1
expr_stmt|;
comment|/* complement and add 1 */
name|high
operator|=
operator|~
name|high
expr_stmt|;
if|if
condition|(
name|low
condition|)
name|low
operator|=
operator|-
name|low
expr_stmt|;
else|else
name|high
operator|+=
literal|1
expr_stmt|;
block|}
name|eldexp
argument_list|(
name|eone
argument_list|,
name|HOST_BITS_PER_LONG
argument_list|,
name|df
argument_list|)
expr_stmt|;
name|ultoe
argument_list|(
operator|&
name|high
argument_list|,
name|dg
argument_list|)
expr_stmt|;
name|emul
argument_list|(
name|dg
argument_list|,
name|df
argument_list|,
name|dg
argument_list|)
expr_stmt|;
name|ultoe
argument_list|(
operator|&
name|low
argument_list|,
name|df
argument_list|)
expr_stmt|;
name|eadd
argument_list|(
name|df
argument_list|,
name|dg
argument_list|,
name|dg
argument_list|)
expr_stmt|;
if|if
condition|(
name|sign
condition|)
name|eneg
argument_list|(
name|dg
argument_list|)
expr_stmt|;
name|PUT_REAL
argument_list|(
name|dg
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* REAL_VALUE_FROM_UNSIGNED_INT macro.  */
end_comment

begin_function
name|void
name|ereal_from_uint
parameter_list|(
name|d
parameter_list|,
name|i
parameter_list|,
name|j
parameter_list|)
name|REAL_VALUE_TYPE
modifier|*
name|d
decl_stmt|;
name|unsigned
name|long
name|i
decl_stmt|,
name|j
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|df
index|[
name|NE
index|]
decl_stmt|,
name|dg
index|[
name|NE
index|]
decl_stmt|;
name|unsigned
name|long
name|low
decl_stmt|,
name|high
decl_stmt|;
name|low
operator|=
name|i
expr_stmt|;
name|high
operator|=
name|j
expr_stmt|;
name|eldexp
argument_list|(
name|eone
argument_list|,
name|HOST_BITS_PER_LONG
argument_list|,
name|df
argument_list|)
expr_stmt|;
name|ultoe
argument_list|(
operator|&
name|high
argument_list|,
name|dg
argument_list|)
expr_stmt|;
name|emul
argument_list|(
name|dg
argument_list|,
name|df
argument_list|,
name|dg
argument_list|)
expr_stmt|;
name|ultoe
argument_list|(
operator|&
name|low
argument_list|,
name|df
argument_list|)
expr_stmt|;
name|eadd
argument_list|(
name|df
argument_list|,
name|dg
argument_list|,
name|dg
argument_list|)
expr_stmt|;
name|PUT_REAL
argument_list|(
name|dg
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* REAL_VALUE_TO_INT macro  */
end_comment

begin_function
name|void
name|ereal_to_int
parameter_list|(
name|low
parameter_list|,
name|high
parameter_list|,
name|rr
parameter_list|)
name|long
modifier|*
name|low
decl_stmt|,
decl|*
name|high
decl_stmt|;
end_function

begin_decl_stmt
name|REAL_VALUE_TYPE
name|rr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|unsigned
name|EMUSHORT
name|d
index|[
name|NE
index|]
decl_stmt|,
name|df
index|[
name|NE
index|]
decl_stmt|,
name|dg
index|[
name|NE
index|]
decl_stmt|,
name|dh
index|[
name|NE
index|]
decl_stmt|;
name|int
name|s
decl_stmt|;
name|GET_REAL
argument_list|(
operator|&
name|rr
argument_list|,
name|d
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NANS
if|if
condition|(
name|eisnan
argument_list|(
name|d
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"conversion from NaN to int"
argument_list|)
expr_stmt|;
operator|*
name|low
operator|=
operator|-
literal|1
expr_stmt|;
operator|*
name|high
operator|=
operator|-
literal|1
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* convert positive value */
name|s
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|eisneg
argument_list|(
name|d
argument_list|)
condition|)
block|{
name|eneg
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|s
operator|=
literal|1
expr_stmt|;
block|}
name|eldexp
argument_list|(
name|eone
argument_list|,
name|HOST_BITS_PER_LONG
argument_list|,
name|df
argument_list|)
expr_stmt|;
name|ediv
argument_list|(
name|df
argument_list|,
name|d
argument_list|,
name|dg
argument_list|)
expr_stmt|;
comment|/* dg = d / 2^32 is the high word */
name|euifrac
argument_list|(
name|dg
argument_list|,
name|high
argument_list|,
name|dh
argument_list|)
expr_stmt|;
name|emul
argument_list|(
name|df
argument_list|,
name|dh
argument_list|,
name|dg
argument_list|)
expr_stmt|;
comment|/* fractional part is the low word */
name|euifrac
argument_list|(
name|dg
argument_list|,
name|low
argument_list|,
name|dh
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
condition|)
block|{
comment|/* complement and add 1 */
operator|*
name|high
operator|=
operator|~
operator|(
operator|*
name|high
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|low
condition|)
operator|*
name|low
operator|=
operator|-
operator|(
operator|*
name|low
operator|)
expr_stmt|;
else|else
operator|*
name|high
operator|+=
literal|1
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* REAL_VALUE_LDEXP macro.  */
end_comment

begin_function
name|REAL_VALUE_TYPE
name|ereal_ldexp
parameter_list|(
name|x
parameter_list|,
name|n
parameter_list|)
name|REAL_VALUE_TYPE
name|x
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|e
index|[
name|NE
index|]
decl_stmt|,
name|y
index|[
name|NE
index|]
decl_stmt|;
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|GET_REAL
argument_list|(
operator|&
name|x
argument_list|,
name|e
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NANS
if|if
condition|(
name|eisnan
argument_list|(
name|e
argument_list|)
condition|)
return|return
operator|(
name|x
operator|)
return|;
endif|#
directive|endif
name|eldexp
argument_list|(
name|e
argument_list|,
name|n
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|PUT_REAL
argument_list|(
name|y
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_comment
comment|/* These routines are conditionally compiled because functions  * of the same names may be defined in fold-const.c.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|REAL_ARITHMETIC
end_ifdef

begin_comment
comment|/* Check for infinity in a REAL_VALUE_TYPE. */
end_comment

begin_function
name|int
name|target_isinf
parameter_list|(
name|x
parameter_list|)
name|REAL_VALUE_TYPE
name|x
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|e
index|[
name|NE
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|INFINITY
name|GET_REAL
argument_list|(
operator|&
name|x
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
operator|(
name|eisinf
argument_list|(
name|e
argument_list|)
operator|)
return|;
else|#
directive|else
return|return
literal|0
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Check whether a REAL_VALUE_TYPE item is a NaN. */
end_comment

begin_function
name|int
name|target_isnan
parameter_list|(
name|x
parameter_list|)
name|REAL_VALUE_TYPE
name|x
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|e
index|[
name|NE
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|NANS
name|GET_REAL
argument_list|(
operator|&
name|x
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
operator|(
name|eisnan
argument_list|(
name|e
argument_list|)
operator|)
return|;
else|#
directive|else
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Check for a negative REAL_VALUE_TYPE number.  * this means strictly less than zero, not -0.  */
end_comment

begin_function
name|int
name|target_negative
parameter_list|(
name|x
parameter_list|)
name|REAL_VALUE_TYPE
name|x
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|e
index|[
name|NE
index|]
decl_stmt|;
name|GET_REAL
argument_list|(
operator|&
name|x
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecmp
argument_list|(
name|e
argument_list|,
name|ezero
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Expansion of REAL_VALUE_TRUNCATE.  * The result is in floating point, rounded to nearest or even.  */
end_comment

begin_function
name|REAL_VALUE_TYPE
name|real_value_truncate
parameter_list|(
name|mode
parameter_list|,
name|arg
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|REAL_VALUE_TYPE
name|arg
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|e
index|[
name|NE
index|]
decl_stmt|,
name|t
index|[
name|NE
index|]
decl_stmt|;
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|GET_REAL
argument_list|(
operator|&
name|arg
argument_list|,
name|e
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NANS
if|if
condition|(
name|eisnan
argument_list|(
name|e
argument_list|)
condition|)
return|return
operator|(
name|arg
operator|)
return|;
endif|#
directive|endif
name|eclear
argument_list|(
name|t
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|XFmode
case|:
name|etoe64
argument_list|(
name|e
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|e64toe
argument_list|(
name|t
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|DFmode
case|:
name|etoe53
argument_list|(
name|e
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|e53toe
argument_list|(
name|t
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|SFmode
case|:
name|etoe24
argument_list|(
name|e
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|e24toe
argument_list|(
name|t
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|SImode
case|:
name|r
operator|=
name|etrunci
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|PUT_REAL
argument_list|(
name|t
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* REAL_ARITHMETIC defined */
end_comment

begin_comment
comment|/* Target values are arrays of host longs. A long is guaranteed    to be at least 32 bits wide. */
end_comment

begin_function
name|void
name|etarldouble
parameter_list|(
name|r
parameter_list|,
name|l
parameter_list|)
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|long
name|l
index|[]
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|e
index|[
name|NE
index|]
decl_stmt|;
name|GET_REAL
argument_list|(
operator|&
name|r
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|etoe64
argument_list|(
name|e
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|endian
argument_list|(
name|e
argument_list|,
name|l
argument_list|,
name|XFmode
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|etardouble
parameter_list|(
name|r
parameter_list|,
name|l
parameter_list|)
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|long
name|l
index|[]
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|e
index|[
name|NE
index|]
decl_stmt|;
name|GET_REAL
argument_list|(
operator|&
name|r
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|etoe53
argument_list|(
name|e
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|endian
argument_list|(
name|e
argument_list|,
name|l
argument_list|,
name|DFmode
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|long
name|etarsingle
parameter_list|(
name|r
parameter_list|)
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|e
index|[
name|NE
index|]
decl_stmt|;
name|unsigned
name|long
name|l
decl_stmt|;
name|GET_REAL
argument_list|(
operator|&
name|r
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|etoe24
argument_list|(
name|e
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|endian
argument_list|(
name|e
argument_list|,
operator|&
name|l
argument_list|,
name|SFmode
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|long
operator|)
name|l
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ereal_to_decimal
parameter_list|(
name|x
parameter_list|,
name|s
parameter_list|)
name|REAL_VALUE_TYPE
name|x
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|e
index|[
name|NE
index|]
decl_stmt|;
name|GET_REAL
argument_list|(
operator|&
name|x
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|etoasc
argument_list|(
name|e
argument_list|,
name|s
argument_list|,
literal|20
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ereal_cmp
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|REAL_VALUE_TYPE
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|ex
index|[
name|NE
index|]
decl_stmt|,
name|ey
index|[
name|NE
index|]
decl_stmt|;
name|GET_REAL
argument_list|(
operator|&
name|x
argument_list|,
name|ex
argument_list|)
expr_stmt|;
name|GET_REAL
argument_list|(
operator|&
name|y
argument_list|,
name|ey
argument_list|)
expr_stmt|;
return|return
operator|(
name|ecmp
argument_list|(
name|ex
argument_list|,
name|ey
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ereal_isneg
parameter_list|(
name|x
parameter_list|)
name|REAL_VALUE_TYPE
name|x
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|ex
index|[
name|NE
index|]
decl_stmt|;
name|GET_REAL
argument_list|(
operator|&
name|x
argument_list|,
name|ex
argument_list|)
expr_stmt|;
return|return
operator|(
name|eisneg
argument_list|(
name|ex
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* End of REAL_ARITHMETIC interface */
end_comment

begin_comment
comment|/*							ieee.c  *  *    Extended precision IEEE binary floating point arithmetic routines  *  * Numbers are stored in C language as arrays of 16-bit unsigned  * short integers.  The arguments of the routines are pointers to  * the arrays.  *  *  * External e type data structure, simulates Intel 8087 chip  * temporary real format but possibly with a larger significand:  *  *	NE-1 significand words	(least significant word first,  *				 most significant bit is normally set)  *	exponent		(value = EXONE for 1.0,  *				top bit is the sign)  *  *  * Internal data structure of a number (a "word" is 16 bits):  *  * ei[0]	sign word	(0 for positive, 0xffff for negative)  * ei[1]	biased exponent	(value = EXONE for the number 1.0)  * ei[2]	high guard word	(always zero after normalization)  * ei[3]  * to ei[NI-2]	significand	(NI-4 significand words,  *				 most significant word first,  *				 most significant bit is set)  * ei[NI-1]	low guard word	(0x8000 bit is rounding place)  *  *  *  *		Routines for external format numbers  *  *	asctoe (string, e)	ASCII string to extended double e type  *	asctoe64 (string,&d)	ASCII string to long double  *	asctoe53 (string,&d)	ASCII string to double  *	asctoe24 (string,&f)	ASCII string to single  *	asctoeg (string, e, prec) ASCII string to specified precision  *	e24toe (&f, e)		IEEE single precision to e type  *	e53toe (&d, e)		IEEE double precision to e type  *	e64toe (&d, e)		IEEE long double precision to e type  *	eabs (e)			absolute value  *	eadd (a, b, c)		c = b + a  *	eclear (e)		e = 0  *	ecmp (a, b)		Returns 1 if a> b, 0 if a == b,  *				-1 if a< b, -2 if either a or b is a NaN.  *	ediv (a, b, c)		c = b / a  *	efloor (a, b)		truncate to integer, toward -infinity  *	efrexp (a, exp, s)	extract exponent and significand  *	eifrac (e,&l, frac)    e to long integer and e type fraction  *	euifrac (e,&l, frac)   e to unsigned long integer and e type fraction  *	einfin (e)		set e to infinity, leaving its sign alone  *	eldexp (a, n, b)	multiply by 2**n  *	emov (a, b)		b = a  *	emul (a, b, c)		c = b * a  *	eneg (e)			e = -e  *	eround (a, b)		b = nearest integer value to a  *	esub (a, b, c)		c = b - a  *	e24toasc (&f, str, n)	single to ASCII string, n digits after decimal  *	e53toasc (&d, str, n)	double to ASCII string, n digits after decimal  *	e64toasc (&d, str, n)	long double to ASCII string  *	etoasc (e, str, n)	e to ASCII string, n digits after decimal  *	etoe24 (e,&f)		convert e type to IEEE single precision  *	etoe53 (e,&d)		convert e type to IEEE double precision  *	etoe64 (e,&d)		convert e type to IEEE long double precision  *	ltoe (&l, e)		long (32 bit) integer to e type  *	ultoe (&l, e)		unsigned long (32 bit) integer to e type  *      eisneg (e)              1 if sign bit of e != 0, else 0  *      eisinf (e)              1 if e has maximum exponent (non-IEEE)  *				or is infinite (IEEE)  *      eisnan (e)              1 if e is a NaN  *  *  *		Routines for internal format numbers  *  *	eaddm (ai, bi)		add significands, bi = bi + ai  *	ecleaz (ei)		ei = 0  *	ecleazs (ei)		set ei = 0 but leave its sign alone  *	ecmpm (ai, bi)		compare significands, return 1, 0, or -1  *	edivm (ai, bi)		divide  significands, bi = bi / ai  *	emdnorm (ai,l,s,exp)	normalize and round off  *	emovi (a, ai)		convert external a to internal ai  *	emovo (ai, a)		convert internal ai to external a  *	emovz (ai, bi)		bi = ai, low guard word of bi = 0  *	emulm (ai, bi)		multiply significands, bi = bi * ai  *	enormlz (ei)		left-justify the significand  *	eshdn1 (ai)		shift significand and guards down 1 bit  *	eshdn8 (ai)		shift down 8 bits  *	eshdn6 (ai)		shift down 16 bits  *	eshift (ai, n)		shift ai n bits up (or down if n< 0)  *	eshup1 (ai)		shift significand and guards up 1 bit  *	eshup8 (ai)		shift up 8 bits  *	eshup6 (ai)		shift up 16 bits  *	esubm (ai, bi)		subtract significands, bi = bi - ai  *      eiisinf (ai)            1 if infinite  *      eiisnan (ai)            1 if a NaN  *      einan (ai)              set ai = NaN  *      eiinfin (ai)            set ai = infinity  *  *  * The result is always normalized and rounded to NI-4 word precision  * after each arithmetic operation.  *  * Exception flags are NOT fully supported.  *  * Signaling NaN's are NOT supported; they are treated the same  * as quiet NaN's.  *  * Define INFINITY for support of infinity; otherwise a  * saturation arithmetic is implemented.  *  * Define NANS for support of Not-a-Number items; otherwise the  * arithmetic will never produce a NaN output, and might be confused  * by a NaN input.  * If NaN's are supported, the output of `ecmp (a,b)' is -2 if  * either a or b is a NaN. This means asking `if (ecmp (a,b)< 0)'  * may not be legitimate. Use `if (ecmp (a,b) == -1)' for `less than'  * if in doubt.  *  * Denormals are always supported here where appropriate (e.g., not  * for conversion to DEC numbers).  *  */
end_comment

begin_comment
comment|/*							mconf.h  *  *	Common include file for math routines  *  *  *  * SYNOPSIS:  *  * #include "mconf.h"  *  *  *  * DESCRIPTION:  *  * This file contains definitions for error codes that are  * passed to the common error handling routine mtherr  * (which see).  *  * The file also includes a conditional assembly definition  * for the type of computer arithmetic (Intel IEEE, DEC, Motorola  * IEEE, or UNKnown).  *  * For Digital Equipment PDP-11 and VAX computers, certain  * IBM systems, and others that use numbers with a 56-bit  * significand, the symbol DEC should be defined.  In this  * mode, most floating point constants are given as arrays  * of octal integers to eliminate decimal to binary conversion  * errors that might be introduced by the compiler.  *  * For computers, such as IBM PC, that follow the IEEE  * Standard for Binary Floating Point Arithmetic (ANSI/IEEE  * Std 754-1985), the symbol IBMPC or MIEEE should be defined.  * These numbers have 53-bit significands.  In this mode, constants  * are provided as arrays of hexadecimal 16 bit integers.  *  * To accommodate other types of computer arithmetic, all  * constants are also provided in a normal decimal radix  * which one can hope are correctly converted to a suitable  * format by the available C language compiler.  To invoke  * this mode, the symbol UNK is defined.  *  * An important difference among these modes is a predefined  * set of machine arithmetic constants for each.  The numbers  * MACHEP (the machine roundoff error), MAXNUM (largest number  * represented), and several other parameters are preset by  * the configuration symbol.  Check the file const.c to  * ensure that these values are correct for your computer.  *  * For ANSI C compatibility, define ANSIC equal to 1.  Currently  * this affects only the atan2 function and others that use it.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Constant definitions for math error conditions.  */
end_comment

begin_define
define|#
directive|define
name|DOMAIN
value|1
end_define

begin_comment
comment|/* argument domain error */
end_comment

begin_define
define|#
directive|define
name|SING
value|2
end_define

begin_comment
comment|/* argument singularity */
end_comment

begin_define
define|#
directive|define
name|OVERFLOW
value|3
end_define

begin_comment
comment|/* overflow range error */
end_comment

begin_define
define|#
directive|define
name|UNDERFLOW
value|4
end_define

begin_comment
comment|/* underflow range error */
end_comment

begin_define
define|#
directive|define
name|TLOSS
value|5
end_define

begin_comment
comment|/* total loss of precision */
end_comment

begin_define
define|#
directive|define
name|PLOSS
value|6
end_define

begin_comment
comment|/* partial loss of precision */
end_comment

begin_define
define|#
directive|define
name|INVALID
value|7
end_define

begin_comment
comment|/* NaN-producing operation */
end_comment

begin_comment
comment|/*  e type constants used by high precision check routines */
end_comment

begin_comment
comment|/*include "ehead.h"*/
end_comment

begin_comment
comment|/* 0.0 */
end_comment

begin_decl_stmt
name|unsigned
name|EMUSHORT
name|ezero
index|[
name|NE
index|]
init|=
block|{
literal|0
block|,
literal|0000000
block|,
literal|0000000
block|,
literal|0000000
block|,
literal|0000000
block|,
literal|0000000
block|,}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
name|EMUSHORT
name|ezero
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 5.0E-1 */
end_comment

begin_decl_stmt
name|unsigned
name|EMUSHORT
name|ehalf
index|[
name|NE
index|]
init|=
block|{
literal|0
block|,
literal|0000000
block|,
literal|0000000
block|,
literal|0000000
block|,
literal|0100000
block|,
literal|0x3ffe
block|,}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
name|EMUSHORT
name|ehalf
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1.0E0 */
end_comment

begin_decl_stmt
name|unsigned
name|EMUSHORT
name|eone
index|[
name|NE
index|]
init|=
block|{
literal|0
block|,
literal|0000000
block|,
literal|0000000
block|,
literal|0000000
block|,
literal|0100000
block|,
literal|0x3fff
block|,}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
name|EMUSHORT
name|eone
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 2.0E0 */
end_comment

begin_decl_stmt
name|unsigned
name|EMUSHORT
name|etwo
index|[
name|NE
index|]
init|=
block|{
literal|0
block|,
literal|0000000
block|,
literal|0000000
block|,
literal|0000000
block|,
literal|0100000
block|,
literal|0040000
block|,}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
name|EMUSHORT
name|etwo
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 3.2E1 */
end_comment

begin_decl_stmt
name|unsigned
name|EMUSHORT
name|e32
index|[
name|NE
index|]
init|=
block|{
literal|0
block|,
literal|0000000
block|,
literal|0000000
block|,
literal|0000000
block|,
literal|0100000
block|,
literal|0040004
block|,}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
name|EMUSHORT
name|e32
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 6.93147180559945309417232121458176568075500134360255E-1 */
end_comment

begin_decl_stmt
name|unsigned
name|EMUSHORT
name|elog2
index|[
name|NE
index|]
init|=
block|{
literal|0xc9e4
block|,
literal|0x79ab
block|,
literal|0150717
block|,
literal|0013767
block|,
literal|0130562
block|,
literal|0x3ffe
block|,}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
name|EMUSHORT
name|elog2
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1.41421356237309504880168872420969807856967187537695E0 */
end_comment

begin_decl_stmt
name|unsigned
name|EMUSHORT
name|esqrt2
index|[
name|NE
index|]
init|=
block|{
literal|0x597e
block|,
literal|0x6484
block|,
literal|0174736
block|,
literal|0171463
block|,
literal|0132404
block|,
literal|0x3fff
block|,}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
name|EMUSHORT
name|esqrt2
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 2/sqrt (PI) =  * 1.12837916709551257389615890312154517168810125865800E0 */
end_comment

begin_decl_stmt
name|unsigned
name|EMUSHORT
name|eoneopi
index|[
name|NE
index|]
init|=
block|{
literal|0x71d5
block|,
literal|0x688d
block|,
literal|0012333
block|,
literal|0135202
block|,
literal|0110156
block|,
literal|0x3fff
block|,}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
name|EMUSHORT
name|eoneopi
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 3.14159265358979323846264338327950288419716939937511E0 */
end_comment

begin_decl_stmt
name|unsigned
name|EMUSHORT
name|epi
index|[
name|NE
index|]
init|=
block|{
literal|0xc4c6
block|,
literal|0xc234
block|,
literal|0020550
block|,
literal|0155242
block|,
literal|0144417
block|,
literal|0040000
block|,}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
name|EMUSHORT
name|epi
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 5.7721566490153286060651209008240243104215933593992E-1 */
end_comment

begin_decl_stmt
name|unsigned
name|EMUSHORT
name|eeul
index|[
name|NE
index|]
init|=
block|{
literal|0xd1be
block|,
literal|0xc7a4
block|,
literal|0076660
block|,
literal|0063743
block|,
literal|0111704
block|,
literal|0x3ffe
block|,}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
name|EMUSHORT
name|eeul
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* include "ehead.h" include "mconf.h" */
end_comment

begin_comment
comment|/* Control register for rounding precision.  * This can be set to 80 (if NE=6), 64, 56, 53, or 24 bits.  */
end_comment

begin_decl_stmt
name|int
name|rndprc
init|=
name|NBITS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|rndprc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|eaddm
argument_list|()
decl_stmt|,
name|esubm
argument_list|()
decl_stmt|,
name|emdnorm
argument_list|()
decl_stmt|,
name|asctoeg
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|toe24
argument_list|()
decl_stmt|,
name|toe53
argument_list|()
decl_stmt|,
name|toe64
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|eremain
argument_list|()
decl_stmt|,
name|einit
argument_list|()
decl_stmt|,
name|eiremain
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ecmpm
argument_list|()
decl_stmt|,
name|edivm
argument_list|()
decl_stmt|,
name|emulm
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|emovi
argument_list|()
decl_stmt|,
name|emovo
argument_list|()
decl_stmt|,
name|emovz
argument_list|()
decl_stmt|,
name|ecleaz
argument_list|()
decl_stmt|,
name|ecleazs
argument_list|()
decl_stmt|,
name|eadd1
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|etodec
argument_list|()
decl_stmt|,
name|todec
argument_list|()
decl_stmt|,
name|dectoe
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|einit
parameter_list|()
block|{ }
end_function

begin_comment
comment|/* ; Clear out entire external format number. ; ; unsigned EMUSHORT x[]; ; eclear (x); */
end_comment

begin_function
name|void
name|eclear
parameter_list|(
name|x
parameter_list|)
specifier|register
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NE
condition|;
name|i
operator|++
control|)
operator|*
name|x
operator|++
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Move external format number from a to b.  *  * emov (a, b);  */
end_comment

begin_function
name|void
name|emov
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
specifier|register
name|unsigned
name|EMUSHORT
modifier|*
name|a
decl_stmt|,
decl|*
name|b
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NE
condition|;
name|i
operator|++
control|)
operator|*
name|b
operator|++
operator|=
operator|*
name|a
operator|++
expr_stmt|;
block|}
end_block

begin_comment
comment|/* ;	Absolute value of external format number ; ;	EMUSHORT x[NE]; ;	eabs (x); */
end_comment

begin_function
name|void
name|eabs
parameter_list|(
name|x
parameter_list|)
name|unsigned
name|EMUSHORT
name|x
index|[]
decl_stmt|;
comment|/* x is the memory address of a short */
block|{
name|x
index|[
name|NE
operator|-
literal|1
index|]
operator|&=
literal|0x7fff
expr_stmt|;
comment|/* sign is top bit of last word of external format */
block|}
end_function

begin_comment
comment|/* ;	Negate external format number ; ;	unsigned EMUSHORT x[NE]; ;	eneg (x); */
end_comment

begin_function
name|void
name|eneg
parameter_list|(
name|x
parameter_list|)
name|unsigned
name|EMUSHORT
name|x
index|[]
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|NANS
if|if
condition|(
name|eisnan
argument_list|(
name|x
argument_list|)
condition|)
return|return;
endif|#
directive|endif
name|x
index|[
name|NE
operator|-
literal|1
index|]
operator|^=
literal|0x8000
expr_stmt|;
comment|/* Toggle the sign bit */
block|}
end_function

begin_comment
comment|/* Return 1 if external format number is negative,  * else return zero, including when it is a NaN.  */
end_comment

begin_function
name|int
name|eisneg
parameter_list|(
name|x
parameter_list|)
name|unsigned
name|EMUSHORT
name|x
index|[]
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|NANS
if|if
condition|(
name|eisnan
argument_list|(
name|x
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
if|if
condition|(
name|x
index|[
name|NE
operator|-
literal|1
index|]
operator|&
literal|0x8000
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if external format number is infinity.  * else return zero.  */
end_comment

begin_function
name|int
name|eisinf
parameter_list|(
name|x
parameter_list|)
name|unsigned
name|EMUSHORT
name|x
index|[]
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|NANS
if|if
condition|(
name|eisnan
argument_list|(
name|x
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|x
index|[
name|NE
operator|-
literal|1
index|]
operator|&
literal|0x7fff
operator|)
operator|==
literal|0x7fff
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Check if e-type number is not a number.    The bit pattern is one that we defined, so we know for sure how to    detect it.  */
end_comment

begin_function
name|int
name|eisnan
parameter_list|(
name|x
parameter_list|)
name|unsigned
name|EMUSHORT
name|x
index|[]
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|NANS
name|int
name|i
decl_stmt|;
comment|/* NaN has maximum exponent */
if|if
condition|(
operator|(
name|x
index|[
name|NE
operator|-
literal|1
index|]
operator|&
literal|0x7fff
operator|)
operator|!=
literal|0x7fff
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* ... and non-zero significand field. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NE
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|x
operator|++
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  Fill external format number with infinity pattern (IEEE)     or largest possible number (non-IEEE).     Before calling einfin, you should either call eclear      or set up the sign bit by hand.  */
end_comment

begin_function
name|void
name|einfin
parameter_list|(
name|x
parameter_list|)
specifier|register
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|INFINITY
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NE
operator|-
literal|1
condition|;
name|i
operator|++
control|)
operator|*
name|x
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|x
operator||=
literal|32767
expr_stmt|;
else|#
directive|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NE
operator|-
literal|1
condition|;
name|i
operator|++
control|)
operator|*
name|x
operator|++
operator|=
literal|0xffff
expr_stmt|;
operator|*
name|x
operator||=
literal|32766
expr_stmt|;
if|if
condition|(
name|rndprc
operator|<
name|NBITS
condition|)
block|{
if|if
condition|(
name|rndprc
operator|==
literal|64
condition|)
block|{
operator|*
operator|(
name|x
operator|-
literal|5
operator|)
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|rndprc
operator|==
literal|53
condition|)
block|{
operator|*
operator|(
name|x
operator|-
literal|4
operator|)
operator|=
literal|0xf800
expr_stmt|;
block|}
else|else
block|{
operator|*
operator|(
name|x
operator|-
literal|4
operator|)
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
name|x
operator|-
literal|3
operator|)
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
name|x
operator|-
literal|2
operator|)
operator|=
literal|0xff00
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Output an e-type NaN.    This generates Intel's quiet NaN pattern for extended real.    The exponent is 7fff, the leading mantissa word is c000.  */
end_comment

begin_function
name|void
name|enan
parameter_list|(
name|x
parameter_list|)
specifier|register
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NE
operator|-
literal|2
condition|;
name|i
operator|++
control|)
operator|*
name|x
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|x
operator|++
operator|=
literal|0xc000
expr_stmt|;
operator|*
name|x
operator|=
literal|0x7fff
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Move in external format number,  * converting it to internal format.  */
end_comment

begin_function
name|void
name|emovi
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|a
decl_stmt|,
decl|*
name|b
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|unsigned
name|EMUSHORT
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|int
name|i
decl_stmt|;
name|q
operator|=
name|b
expr_stmt|;
name|p
operator|=
name|a
operator|+
operator|(
name|NE
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* point to last word of external number */
comment|/* get the sign bit */
if|if
condition|(
operator|*
name|p
operator|&
literal|0x8000
condition|)
operator|*
name|q
operator|++
operator|=
literal|0xffff
expr_stmt|;
else|else
operator|*
name|q
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* get the exponent */
operator|*
name|q
operator|=
operator|*
name|p
operator|--
expr_stmt|;
operator|*
name|q
operator|++
operator|&=
literal|0x7fff
expr_stmt|;
comment|/* delete the sign bit */
ifdef|#
directive|ifdef
name|INFINITY
if|if
condition|(
operator|(
operator|*
operator|(
name|q
operator|-
literal|1
operator|)
operator|&
literal|0x7fff
operator|)
operator|==
literal|0x7fff
condition|)
block|{
ifdef|#
directive|ifdef
name|NANS
if|if
condition|(
name|eisnan
argument_list|(
name|a
argument_list|)
condition|)
block|{
operator|*
name|q
operator|++
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|3
init|;
name|i
operator|<
name|NI
condition|;
name|i
operator|++
control|)
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|--
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|NI
condition|;
name|i
operator|++
control|)
operator|*
name|q
operator|++
operator|=
literal|0
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* clear high guard word */
operator|*
name|q
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* move in the significand */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NE
operator|-
literal|1
condition|;
name|i
operator|++
control|)
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|--
expr_stmt|;
comment|/* clear low guard word */
operator|*
name|q
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Move internal format number out,  * converting it to external format.  */
end_comment

begin_function
name|void
name|emovo
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|a
decl_stmt|,
decl|*
name|b
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|unsigned
name|EMUSHORT
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|unsigned
name|EMUSHORT
name|i
decl_stmt|;
name|p
operator|=
name|a
expr_stmt|;
name|q
operator|=
name|b
operator|+
operator|(
name|NE
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* point to output exponent */
comment|/* combine sign and exponent */
name|i
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|i
condition|)
operator|*
name|q
operator|--
operator|=
operator|*
name|p
operator|++
operator||
literal|0x8000
expr_stmt|;
else|else
operator|*
name|q
operator|--
operator|=
operator|*
name|p
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|INFINITY
if|if
condition|(
operator|*
operator|(
name|p
operator|-
literal|1
operator|)
operator|==
literal|0x7fff
condition|)
block|{
ifdef|#
directive|ifdef
name|NANS
if|if
condition|(
name|eiisnan
argument_list|(
name|a
argument_list|)
condition|)
block|{
name|enan
argument_list|(
name|b
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|einfin
argument_list|(
name|b
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* skip over guard word */
operator|++
name|p
expr_stmt|;
comment|/* move the significand */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NE
operator|-
literal|1
condition|;
name|i
operator|++
control|)
operator|*
name|q
operator|--
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Clear out internal format number.  */
end_comment

begin_function
name|void
name|ecleaz
parameter_list|(
name|xi
parameter_list|)
specifier|register
name|unsigned
name|EMUSHORT
modifier|*
name|xi
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NI
condition|;
name|i
operator|++
control|)
operator|*
name|xi
operator|++
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* same, but don't touch the sign. */
end_comment

begin_function
name|void
name|ecleazs
parameter_list|(
name|xi
parameter_list|)
specifier|register
name|unsigned
name|EMUSHORT
modifier|*
name|xi
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
operator|++
name|xi
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NI
operator|-
literal|1
condition|;
name|i
operator|++
control|)
operator|*
name|xi
operator|++
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Move internal format number from a to b.  */
end_comment

begin_function
name|void
name|emovz
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
specifier|register
name|unsigned
name|EMUSHORT
modifier|*
name|a
decl_stmt|,
decl|*
name|b
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NI
operator|-
literal|1
condition|;
name|i
operator|++
control|)
operator|*
name|b
operator|++
operator|=
operator|*
name|a
operator|++
expr_stmt|;
comment|/* clear low guard word */
operator|*
name|b
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Generate internal format NaN.    The explicit pattern for this is maximum exponent and    top two significand bits set.  */
end_comment

begin_function
name|void
name|einan
parameter_list|(
name|x
parameter_list|)
name|unsigned
name|EMUSHORT
name|x
index|[]
decl_stmt|;
block|{
name|ecleaz
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|x
index|[
name|E
index|]
operator|=
literal|0x7fff
expr_stmt|;
name|x
index|[
name|M
operator|+
literal|1
index|]
operator|=
literal|0xc000
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return nonzero if internal format number is a NaN. */
end_comment

begin_function
name|int
name|eiisnan
parameter_list|(
name|x
parameter_list|)
name|unsigned
name|EMUSHORT
name|x
index|[]
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|x
index|[
name|E
index|]
operator|&
literal|0x7fff
operator|)
operator|==
literal|0x7fff
condition|)
block|{
for|for
control|(
name|i
operator|=
name|M
operator|+
literal|1
init|;
name|i
operator|<
name|NI
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|x
index|[
name|i
index|]
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Fill internal format number with infinity pattern.    This has maximum exponent and significand all zeros.  */
end_comment

begin_function
name|void
name|eiinfin
parameter_list|(
name|x
parameter_list|)
name|unsigned
name|EMUSHORT
name|x
index|[]
decl_stmt|;
block|{
name|ecleaz
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|x
index|[
name|E
index|]
operator|=
literal|0x7fff
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return nonzero if internal format number is infinite. */
end_comment

begin_function
name|int
name|eiisinf
parameter_list|(
name|x
parameter_list|)
name|unsigned
name|EMUSHORT
name|x
index|[]
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|NANS
if|if
condition|(
name|eiisnan
argument_list|(
name|x
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|x
index|[
name|E
index|]
operator|&
literal|0x7fff
operator|)
operator|==
literal|0x7fff
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ;	Compare significands of numbers in internal format. ;	Guard words are included in the comparison. ; ;	unsigned EMUSHORT a[NI], b[NI]; ;	cmpm (a, b); ; ;	for the significands: ;	returns	+1 if a> b ;		 0 if a == b ;		-1 if a< b */
end_comment

begin_function
name|int
name|ecmpm
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
specifier|register
name|unsigned
name|EMUSHORT
modifier|*
name|a
decl_stmt|,
decl|*
name|b
decl_stmt|;
end_function

begin_block
block|{
name|int
name|i
decl_stmt|;
name|a
operator|+=
name|M
expr_stmt|;
comment|/* skip up to significand area */
name|b
operator|+=
name|M
expr_stmt|;
for|for
control|(
name|i
operator|=
name|M
init|;
name|i
operator|<
name|NI
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|a
operator|++
operator|!=
operator|*
name|b
operator|++
condition|)
goto|goto
name|difrnt
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|difrnt
label|:
if|if
condition|(
operator|*
operator|(
operator|--
name|a
operator|)
operator|>
operator|*
operator|(
operator|--
name|b
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/* ;	Shift significand down by 1 bit */
end_comment

begin_function
name|void
name|eshdn1
parameter_list|(
name|x
parameter_list|)
specifier|register
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|;
block|{
specifier|register
name|unsigned
name|EMUSHORT
name|bits
decl_stmt|;
name|int
name|i
decl_stmt|;
name|x
operator|+=
name|M
expr_stmt|;
comment|/* point to significand area */
name|bits
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|M
init|;
name|i
operator|<
name|NI
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|x
operator|&
literal|1
condition|)
name|bits
operator||=
literal|1
expr_stmt|;
operator|*
name|x
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|bits
operator|&
literal|2
condition|)
operator|*
name|x
operator||=
literal|0x8000
expr_stmt|;
name|bits
operator|<<=
literal|1
expr_stmt|;
operator|++
name|x
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ;	Shift significand up by 1 bit */
end_comment

begin_function
name|void
name|eshup1
parameter_list|(
name|x
parameter_list|)
specifier|register
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|;
block|{
specifier|register
name|unsigned
name|EMUSHORT
name|bits
decl_stmt|;
name|int
name|i
decl_stmt|;
name|x
operator|+=
name|NI
operator|-
literal|1
expr_stmt|;
name|bits
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|M
init|;
name|i
operator|<
name|NI
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|x
operator|&
literal|0x8000
condition|)
name|bits
operator||=
literal|1
expr_stmt|;
operator|*
name|x
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|bits
operator|&
literal|2
condition|)
operator|*
name|x
operator||=
literal|1
expr_stmt|;
name|bits
operator|<<=
literal|1
expr_stmt|;
operator|--
name|x
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ;	Shift significand down by 8 bits */
end_comment

begin_function
name|void
name|eshdn8
parameter_list|(
name|x
parameter_list|)
specifier|register
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|;
block|{
specifier|register
name|unsigned
name|EMUSHORT
name|newbyt
decl_stmt|,
name|oldbyt
decl_stmt|;
name|int
name|i
decl_stmt|;
name|x
operator|+=
name|M
expr_stmt|;
name|oldbyt
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|M
init|;
name|i
operator|<
name|NI
condition|;
name|i
operator|++
control|)
block|{
name|newbyt
operator|=
operator|*
name|x
operator|<<
literal|8
expr_stmt|;
operator|*
name|x
operator|>>=
literal|8
expr_stmt|;
operator|*
name|x
operator||=
name|oldbyt
expr_stmt|;
name|oldbyt
operator|=
name|newbyt
expr_stmt|;
operator|++
name|x
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ;	Shift significand up by 8 bits */
end_comment

begin_function
name|void
name|eshup8
parameter_list|(
name|x
parameter_list|)
specifier|register
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
specifier|register
name|unsigned
name|EMUSHORT
name|newbyt
decl_stmt|,
name|oldbyt
decl_stmt|;
name|x
operator|+=
name|NI
operator|-
literal|1
expr_stmt|;
name|oldbyt
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|M
init|;
name|i
operator|<
name|NI
condition|;
name|i
operator|++
control|)
block|{
name|newbyt
operator|=
operator|*
name|x
operator|>>
literal|8
expr_stmt|;
operator|*
name|x
operator|<<=
literal|8
expr_stmt|;
operator|*
name|x
operator||=
name|oldbyt
expr_stmt|;
name|oldbyt
operator|=
name|newbyt
expr_stmt|;
operator|--
name|x
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ;	Shift significand up by 16 bits */
end_comment

begin_function
name|void
name|eshup6
parameter_list|(
name|x
parameter_list|)
specifier|register
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
specifier|register
name|unsigned
name|EMUSHORT
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|x
operator|+
name|M
expr_stmt|;
name|x
operator|+=
name|M
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|M
init|;
name|i
operator|<
name|NI
operator|-
literal|1
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
operator|*
name|x
operator|++
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ;	Shift significand down by 16 bits */
end_comment

begin_function
name|void
name|eshdn6
parameter_list|(
name|x
parameter_list|)
specifier|register
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
specifier|register
name|unsigned
name|EMUSHORT
modifier|*
name|p
decl_stmt|;
name|x
operator|+=
name|NI
operator|-
literal|1
expr_stmt|;
name|p
operator|=
name|x
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|M
init|;
name|i
operator|<
name|NI
operator|-
literal|1
condition|;
name|i
operator|++
control|)
operator|*
operator|(
operator|--
name|p
operator|)
operator|=
operator|*
operator|(
operator|--
name|x
operator|)
expr_stmt|;
operator|*
operator|(
operator|--
name|p
operator|)
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ;	Add significands ;	x + y replaces y */
end_comment

begin_function
name|void
name|eaddm
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|,
decl|*
name|y
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|unsigned
name|EMULONG
name|a
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|carry
decl_stmt|;
name|x
operator|+=
name|NI
operator|-
literal|1
expr_stmt|;
name|y
operator|+=
name|NI
operator|-
literal|1
expr_stmt|;
name|carry
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|M
init|;
name|i
operator|<
name|NI
condition|;
name|i
operator|++
control|)
block|{
name|a
operator|=
call|(
name|unsigned
name|EMULONG
call|)
argument_list|(
operator|*
name|x
argument_list|)
operator|+
call|(
name|unsigned
name|EMULONG
call|)
argument_list|(
operator|*
name|y
argument_list|)
operator|+
name|carry
expr_stmt|;
if|if
condition|(
name|a
operator|&
literal|0x10000
condition|)
name|carry
operator|=
literal|1
expr_stmt|;
else|else
name|carry
operator|=
literal|0
expr_stmt|;
operator|*
name|y
operator|=
operator|(
name|unsigned
name|EMUSHORT
operator|)
name|a
expr_stmt|;
operator|--
name|x
expr_stmt|;
operator|--
name|y
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* ;	Subtract significands ;	y - x replaces y */
end_comment

begin_function
name|void
name|esubm
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|,
decl|*
name|y
decl_stmt|;
end_function

begin_block
block|{
name|unsigned
name|EMULONG
name|a
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|carry
decl_stmt|;
name|x
operator|+=
name|NI
operator|-
literal|1
expr_stmt|;
name|y
operator|+=
name|NI
operator|-
literal|1
expr_stmt|;
name|carry
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|M
init|;
name|i
operator|<
name|NI
condition|;
name|i
operator|++
control|)
block|{
name|a
operator|=
call|(
name|unsigned
name|EMULONG
call|)
argument_list|(
operator|*
name|y
argument_list|)
operator|-
call|(
name|unsigned
name|EMULONG
call|)
argument_list|(
operator|*
name|x
argument_list|)
operator|-
name|carry
expr_stmt|;
if|if
condition|(
name|a
operator|&
literal|0x10000
condition|)
name|carry
operator|=
literal|1
expr_stmt|;
else|else
name|carry
operator|=
literal|0
expr_stmt|;
operator|*
name|y
operator|=
operator|(
name|unsigned
name|EMUSHORT
operator|)
name|a
expr_stmt|;
operator|--
name|x
expr_stmt|;
operator|--
name|y
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Divide significands */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|EMUSHORT
name|equot
index|[
name|NI
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|edivm
argument_list|(
name|den
argument_list|,
name|num
argument_list|)
name|unsigned
name|EMUSHORT
name|den
index|[]
decl_stmt|,
name|num
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
specifier|register
name|unsigned
name|EMUSHORT
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|unsigned
name|EMUSHORT
name|j
decl_stmt|;
name|p
operator|=
operator|&
name|equot
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|num
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|num
index|[
literal|1
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|M
init|;
name|i
operator|<
name|NI
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Use faster compare and subtraction if denominator    * has only 15 bits of significance.    */
name|p
operator|=
operator|&
name|den
index|[
name|M
operator|+
literal|2
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
name|M
operator|+
literal|3
init|;
name|i
operator|<
name|NI
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
literal|0
condition|)
goto|goto
name|fulldiv
goto|;
block|}
if|if
condition|(
operator|(
name|den
index|[
name|M
operator|+
literal|1
index|]
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fulldiv
goto|;
name|eshdn1
argument_list|(
name|num
argument_list|)
expr_stmt|;
name|eshdn1
argument_list|(
name|den
argument_list|)
expr_stmt|;
name|p
operator|=
operator|&
name|den
index|[
name|M
operator|+
literal|1
index|]
expr_stmt|;
name|q
operator|=
operator|&
name|num
index|[
name|M
operator|+
literal|1
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NBITS
operator|+
literal|2
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|<=
operator|*
name|q
condition|)
block|{
operator|*
name|q
operator|-=
operator|*
name|p
expr_stmt|;
name|j
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|j
operator|=
literal|0
expr_stmt|;
block|}
name|eshup1
argument_list|(
name|equot
argument_list|)
expr_stmt|;
name|equot
index|[
name|NI
operator|-
literal|2
index|]
operator||=
name|j
expr_stmt|;
name|eshup1
argument_list|(
name|num
argument_list|)
expr_stmt|;
block|}
goto|goto
name|divdon
goto|;
block|}
comment|/* The number of quotient bits to calculate is    * NBITS + 1 scaling guard bit + 1 roundoff bit.    */
name|fulldiv
label|:
name|p
operator|=
operator|&
name|equot
index|[
name|NI
operator|-
literal|2
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NBITS
operator|+
literal|2
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ecmpm
argument_list|(
name|den
argument_list|,
name|num
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|esubm
argument_list|(
name|den
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|j
operator|=
literal|1
expr_stmt|;
comment|/* quotient bit = 1 */
block|}
else|else
name|j
operator|=
literal|0
expr_stmt|;
name|eshup1
argument_list|(
name|equot
argument_list|)
expr_stmt|;
operator|*
name|p
operator||=
name|j
expr_stmt|;
name|eshup1
argument_list|(
name|num
argument_list|)
expr_stmt|;
block|}
name|divdon
label|:
name|eshdn1
argument_list|(
name|equot
argument_list|)
expr_stmt|;
name|eshdn1
argument_list|(
name|equot
argument_list|)
expr_stmt|;
comment|/* test for nonzero remainder after roundoff bit */
name|p
operator|=
operator|&
name|num
index|[
name|M
index|]
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|M
init|;
name|i
operator|<
name|NI
condition|;
name|i
operator|++
control|)
block|{
name|j
operator||=
operator|*
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|j
condition|)
name|j
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NI
condition|;
name|i
operator|++
control|)
name|num
index|[
name|i
index|]
operator|=
name|equot
index|[
name|i
index|]
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|j
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Multiply significands */
end_comment

begin_decl_stmt
name|int
name|emulm
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
name|unsigned
name|EMUSHORT
name|a
index|[]
decl_stmt|,
name|b
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|unsigned
name|EMUSHORT
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|equot
index|[
literal|0
index|]
operator|=
name|b
index|[
literal|0
index|]
expr_stmt|;
name|equot
index|[
literal|1
index|]
operator|=
name|b
index|[
literal|1
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|M
init|;
name|i
operator|<
name|NI
condition|;
name|i
operator|++
control|)
name|equot
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|p
operator|=
operator|&
name|a
index|[
name|NI
operator|-
literal|2
index|]
expr_stmt|;
name|k
operator|=
name|NBITS
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
comment|/* significand is not supposed to be all zero */
block|{
name|eshdn6
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|k
operator|-=
literal|16
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|p
operator|&
literal|0xff
operator|)
operator|==
literal|0
condition|)
block|{
name|eshdn8
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|k
operator|-=
literal|8
expr_stmt|;
block|}
name|q
operator|=
operator|&
name|equot
index|[
name|NI
operator|-
literal|1
index|]
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|k
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|&
literal|1
condition|)
name|eaddm
argument_list|(
name|b
argument_list|,
name|equot
argument_list|)
expr_stmt|;
comment|/* remember if there were any nonzero bits shifted out */
if|if
condition|(
operator|*
name|q
operator|&
literal|1
condition|)
name|j
operator||=
literal|1
expr_stmt|;
name|eshdn1
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|eshdn1
argument_list|(
name|equot
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NI
condition|;
name|i
operator|++
control|)
name|b
index|[
name|i
index|]
operator|=
name|equot
index|[
name|i
index|]
expr_stmt|;
comment|/* return flag for lost nonzero bits */
return|return
operator|(
name|j
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Normalize and round off.  *  * The internal format number to be rounded is "s".  * Input "lost" indicates whether or not the number is exact.  * This is the so-called sticky bit.  *  * Input "subflg" indicates whether the number was obtained  * by a subtraction operation.  In that case if lost is nonzero  * then the number is slightly smaller than indicated.  *  * Input "exp" is the biased exponent, which may be negative.  * the exponent field of "s" is ignored but is replaced by  * "exp" as adjusted by normalization and rounding.  *  * Input "rcntrl" is the rounding control.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|rlast
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rw
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|EMUSHORT
name|rmsk
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|EMUSHORT
name|rmbit
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|EMUSHORT
name|rebit
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|re
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|EMUSHORT
name|rbit
index|[
name|NI
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|emdnorm
parameter_list|(
name|s
parameter_list|,
name|lost
parameter_list|,
name|subflg
parameter_list|,
name|exp
parameter_list|,
name|rcntrl
parameter_list|)
name|unsigned
name|EMUSHORT
name|s
index|[]
decl_stmt|;
name|int
name|lost
decl_stmt|;
name|int
name|subflg
decl_stmt|;
name|EMULONG
name|exp
decl_stmt|;
name|int
name|rcntrl
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|unsigned
name|EMUSHORT
name|r
decl_stmt|;
comment|/* Normalize */
name|j
operator|=
name|enormlz
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* a blank significand could mean either zero or infinity. */
ifndef|#
directive|ifndef
name|INFINITY
if|if
condition|(
name|j
operator|>
name|NBITS
condition|)
block|{
name|ecleazs
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|exp
operator|-=
name|j
expr_stmt|;
ifndef|#
directive|ifndef
name|INFINITY
if|if
condition|(
name|exp
operator|>=
literal|32767L
condition|)
goto|goto
name|overf
goto|;
else|#
directive|else
if|if
condition|(
operator|(
name|j
operator|>
name|NBITS
operator|)
operator|&&
operator|(
name|exp
operator|<
literal|32767
operator|)
condition|)
block|{
name|ecleazs
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
if|if
condition|(
name|exp
operator|<
literal|0L
condition|)
block|{
if|if
condition|(
name|exp
operator|>
call|(
name|EMULONG
call|)
argument_list|(
operator|-
name|NBITS
operator|-
literal|1
argument_list|)
condition|)
block|{
name|j
operator|=
operator|(
name|int
operator|)
name|exp
expr_stmt|;
name|i
operator|=
name|eshift
argument_list|(
name|s
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
name|lost
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ecleazs
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Round off, unless told not to by rcntrl. */
if|if
condition|(
name|rcntrl
operator|==
literal|0
condition|)
goto|goto
name|mdfin
goto|;
comment|/* Set up rounding parameters if the control register changed. */
if|if
condition|(
name|rndprc
operator|!=
name|rlast
condition|)
block|{
name|ecleaz
argument_list|(
name|rbit
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rndprc
condition|)
block|{
default|default:
case|case
name|NBITS
case|:
name|rw
operator|=
name|NI
operator|-
literal|1
expr_stmt|;
comment|/* low guard word */
name|rmsk
operator|=
literal|0xffff
expr_stmt|;
name|rmbit
operator|=
literal|0x8000
expr_stmt|;
name|rbit
index|[
name|rw
operator|-
literal|1
index|]
operator|=
literal|1
expr_stmt|;
name|re
operator|=
name|NI
operator|-
literal|2
expr_stmt|;
name|rebit
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|64
case|:
name|rw
operator|=
literal|7
expr_stmt|;
name|rmsk
operator|=
literal|0xffff
expr_stmt|;
name|rmbit
operator|=
literal|0x8000
expr_stmt|;
name|rbit
index|[
name|rw
operator|-
literal|1
index|]
operator|=
literal|1
expr_stmt|;
name|re
operator|=
name|rw
operator|-
literal|1
expr_stmt|;
name|rebit
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* For DEC arithmetic */
case|case
literal|56
case|:
name|rw
operator|=
literal|6
expr_stmt|;
name|rmsk
operator|=
literal|0xff
expr_stmt|;
name|rmbit
operator|=
literal|0x80
expr_stmt|;
name|rbit
index|[
name|rw
index|]
operator|=
literal|0x100
expr_stmt|;
name|re
operator|=
name|rw
expr_stmt|;
name|rebit
operator|=
literal|0x100
expr_stmt|;
break|break;
case|case
literal|53
case|:
name|rw
operator|=
literal|6
expr_stmt|;
name|rmsk
operator|=
literal|0x7ff
expr_stmt|;
name|rmbit
operator|=
literal|0x0400
expr_stmt|;
name|rbit
index|[
name|rw
index|]
operator|=
literal|0x800
expr_stmt|;
name|re
operator|=
name|rw
expr_stmt|;
name|rebit
operator|=
literal|0x800
expr_stmt|;
break|break;
case|case
literal|24
case|:
name|rw
operator|=
literal|4
expr_stmt|;
name|rmsk
operator|=
literal|0xff
expr_stmt|;
name|rmbit
operator|=
literal|0x80
expr_stmt|;
name|rbit
index|[
name|rw
index|]
operator|=
literal|0x100
expr_stmt|;
name|re
operator|=
name|rw
expr_stmt|;
name|rebit
operator|=
literal|0x100
expr_stmt|;
break|break;
block|}
name|rlast
operator|=
name|rndprc
expr_stmt|;
block|}
if|if
condition|(
name|rndprc
operator|>=
literal|64
condition|)
block|{
name|r
operator|=
name|s
index|[
name|rw
index|]
operator|&
name|rmsk
expr_stmt|;
if|if
condition|(
name|rndprc
operator|==
literal|64
condition|)
block|{
name|i
operator|=
name|rw
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|NI
condition|)
block|{
if|if
condition|(
name|s
index|[
name|i
index|]
condition|)
name|r
operator||=
literal|1
expr_stmt|;
name|s
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|exp
operator|<=
literal|0
condition|)
name|eshdn1
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|r
operator|=
name|s
index|[
name|rw
index|]
operator|&
name|rmsk
expr_stmt|;
comment|/* These tests assume NI = 8 */
name|i
operator|=
name|rw
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|NI
condition|)
block|{
if|if
condition|(
name|s
index|[
name|i
index|]
condition|)
name|r
operator||=
literal|1
expr_stmt|;
name|s
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
comment|/* 	 if (rndprc == 24) 	 { 	 if (s[5] || s[6]) 	 r |= 1; 	 s[5] = 0; 	 s[6] = 0; 	 } 	 */
block|}
name|s
index|[
name|rw
index|]
operator|&=
operator|~
name|rmsk
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|&
name|rmbit
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|r
operator|==
name|rmbit
condition|)
block|{
if|if
condition|(
name|lost
operator|==
literal|0
condition|)
block|{
comment|/* round to even */
if|if
condition|(
operator|(
name|s
index|[
name|re
index|]
operator|&
name|rebit
operator|)
operator|==
literal|0
condition|)
goto|goto
name|mddone
goto|;
block|}
else|else
block|{
if|if
condition|(
name|subflg
operator|!=
literal|0
condition|)
goto|goto
name|mddone
goto|;
block|}
block|}
name|eaddm
argument_list|(
name|rbit
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
name|mddone
label|:
if|if
condition|(
operator|(
name|rndprc
operator|<
literal|64
operator|)
operator|&&
operator|(
name|exp
operator|<=
literal|0
operator|)
condition|)
block|{
name|eshup1
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s
index|[
literal|2
index|]
operator|!=
literal|0
condition|)
block|{
comment|/* overflow on roundoff */
name|eshdn1
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|exp
operator|+=
literal|1
expr_stmt|;
block|}
name|mdfin
label|:
name|s
index|[
name|NI
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|exp
operator|>=
literal|32767L
condition|)
block|{
ifndef|#
directive|ifndef
name|INFINITY
name|overf
label|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INFINITY
name|s
index|[
literal|1
index|]
operator|=
literal|32767
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|NI
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|s
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|extra_warnings
condition|)
name|warning
argument_list|(
literal|"floating point overflow"
argument_list|)
expr_stmt|;
else|#
directive|else
name|s
index|[
literal|1
index|]
operator|=
literal|32766
expr_stmt|;
name|s
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|M
operator|+
literal|1
init|;
name|i
operator|<
name|NI
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|s
index|[
name|i
index|]
operator|=
literal|0xffff
expr_stmt|;
name|s
index|[
name|NI
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rndprc
operator|<
literal|64
condition|)
block|{
name|s
index|[
name|rw
index|]
operator|&=
operator|~
name|rmsk
expr_stmt|;
if|if
condition|(
name|rndprc
operator|==
literal|24
condition|)
block|{
name|s
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
name|s
index|[
literal|6
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
endif|#
directive|endif
return|return;
block|}
if|if
condition|(
name|exp
operator|<
literal|0
condition|)
name|s
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
else|else
name|s
index|[
literal|1
index|]
operator|=
operator|(
name|unsigned
name|EMUSHORT
operator|)
name|exp
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ;	Subtract external format numbers. ; ;	unsigned EMUSHORT a[NE], b[NE], c[NE]; ;	esub (a, b, c);	 c = b - a */
end_comment

begin_decl_stmt
specifier|static
name|int
name|subflg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|esub
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|a
decl_stmt|,
decl|*
name|b
decl_stmt|,
modifier|*
name|c
decl_stmt|;
end_function

begin_block
block|{
ifdef|#
directive|ifdef
name|NANS
if|if
condition|(
name|eisnan
argument_list|(
name|a
argument_list|)
condition|)
block|{
name|emov
argument_list|(
name|a
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|eisnan
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|emov
argument_list|(
name|b
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Infinity minus infinity is a NaN.    Test for subtracting infinities of the same sign. */
if|if
condition|(
name|eisinf
argument_list|(
name|a
argument_list|)
operator|&&
name|eisinf
argument_list|(
name|b
argument_list|)
operator|&&
operator|(
operator|(
name|eisneg
argument_list|(
name|a
argument_list|)
operator|^
name|eisneg
argument_list|(
name|b
argument_list|)
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|mtherr
argument_list|(
literal|"esub"
argument_list|,
name|INVALID
argument_list|)
expr_stmt|;
name|enan
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|subflg
operator|=
literal|1
expr_stmt|;
name|eadd1
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* ;	Add. ; ;	unsigned EMUSHORT a[NE], b[NE], c[NE]; ;	eadd (a, b, c);	 c = b + a */
end_comment

begin_function
name|void
name|eadd
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|a
decl_stmt|,
decl|*
name|b
decl_stmt|,
modifier|*
name|c
decl_stmt|;
end_function

begin_block
block|{
ifdef|#
directive|ifdef
name|NANS
comment|/* NaN plus anything is a NaN. */
if|if
condition|(
name|eisnan
argument_list|(
name|a
argument_list|)
condition|)
block|{
name|emov
argument_list|(
name|a
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|eisnan
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|emov
argument_list|(
name|b
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Infinity minus infinity is a NaN.    Test for adding infinities of opposite signs. */
if|if
condition|(
name|eisinf
argument_list|(
name|a
argument_list|)
operator|&&
name|eisinf
argument_list|(
name|b
argument_list|)
operator|&&
operator|(
operator|(
name|eisneg
argument_list|(
name|a
argument_list|)
operator|^
name|eisneg
argument_list|(
name|b
argument_list|)
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|mtherr
argument_list|(
literal|"esub"
argument_list|,
name|INVALID
argument_list|)
expr_stmt|;
name|enan
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|subflg
operator|=
literal|0
expr_stmt|;
name|eadd1
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|void
name|eadd1
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|a
decl_stmt|,
decl|*
name|b
decl_stmt|,
modifier|*
name|c
decl_stmt|;
end_function

begin_block
block|{
name|unsigned
name|EMUSHORT
name|ai
index|[
name|NI
index|]
decl_stmt|,
name|bi
index|[
name|NI
index|]
decl_stmt|,
name|ci
index|[
name|NI
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|lost
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|EMULONG
name|lt
decl_stmt|,
name|lta
decl_stmt|,
name|ltb
decl_stmt|;
ifdef|#
directive|ifdef
name|INFINITY
if|if
condition|(
name|eisinf
argument_list|(
name|a
argument_list|)
condition|)
block|{
name|emov
argument_list|(
name|a
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|subflg
condition|)
name|eneg
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|eisinf
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|emov
argument_list|(
name|b
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|emovi
argument_list|(
name|a
argument_list|,
name|ai
argument_list|)
expr_stmt|;
name|emovi
argument_list|(
name|b
argument_list|,
name|bi
argument_list|)
expr_stmt|;
if|if
condition|(
name|subflg
condition|)
name|ai
index|[
literal|0
index|]
operator|=
operator|~
name|ai
index|[
literal|0
index|]
expr_stmt|;
comment|/* compare exponents */
name|lta
operator|=
name|ai
index|[
name|E
index|]
expr_stmt|;
name|ltb
operator|=
name|bi
index|[
name|E
index|]
expr_stmt|;
name|lt
operator|=
name|lta
operator|-
name|ltb
expr_stmt|;
if|if
condition|(
name|lt
operator|>
literal|0L
condition|)
block|{
comment|/* put the larger number in bi */
name|emovz
argument_list|(
name|bi
argument_list|,
name|ci
argument_list|)
expr_stmt|;
name|emovz
argument_list|(
name|ai
argument_list|,
name|bi
argument_list|)
expr_stmt|;
name|emovz
argument_list|(
name|ci
argument_list|,
name|ai
argument_list|)
expr_stmt|;
name|ltb
operator|=
name|bi
index|[
name|E
index|]
expr_stmt|;
name|lt
operator|=
operator|-
name|lt
expr_stmt|;
block|}
name|lost
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|lt
operator|!=
literal|0L
condition|)
block|{
if|if
condition|(
name|lt
operator|<
call|(
name|EMULONG
call|)
argument_list|(
operator|-
name|NBITS
operator|-
literal|1
argument_list|)
condition|)
goto|goto
name|done
goto|;
comment|/* answer same as larger addend */
name|k
operator|=
operator|(
name|int
operator|)
name|lt
expr_stmt|;
name|lost
operator|=
name|eshift
argument_list|(
name|ai
argument_list|,
name|k
argument_list|)
expr_stmt|;
comment|/* shift the smaller number down */
block|}
else|else
block|{
comment|/* exponents were the same, so must compare significands */
name|i
operator|=
name|ecmpm
argument_list|(
name|ai
argument_list|,
name|bi
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
comment|/* the numbers are identical in magnitude */
comment|/* if different signs, result is zero */
if|if
condition|(
name|ai
index|[
literal|0
index|]
operator|!=
name|bi
index|[
literal|0
index|]
condition|)
block|{
name|eclear
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* if same sign, result is double */
comment|/* double denomalized tiny number */
if|if
condition|(
operator|(
name|bi
index|[
name|E
index|]
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|bi
index|[
literal|3
index|]
operator|&
literal|0x8000
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|eshup1
argument_list|(
name|bi
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* add 1 to exponent unless both are zero! */
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|NI
operator|-
literal|1
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|bi
index|[
name|j
index|]
operator|!=
literal|0
condition|)
block|{
comment|/* This could overflow, but let emovo take care of that. */
name|ltb
operator|+=
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|bi
index|[
name|E
index|]
operator|=
operator|(
name|unsigned
name|EMUSHORT
operator|)
name|ltb
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
comment|/* put the larger number in bi */
name|emovz
argument_list|(
name|bi
argument_list|,
name|ci
argument_list|)
expr_stmt|;
name|emovz
argument_list|(
name|ai
argument_list|,
name|bi
argument_list|)
expr_stmt|;
name|emovz
argument_list|(
name|ci
argument_list|,
name|ai
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ai
index|[
literal|0
index|]
operator|==
name|bi
index|[
literal|0
index|]
condition|)
block|{
name|eaddm
argument_list|(
name|ai
argument_list|,
name|bi
argument_list|)
expr_stmt|;
name|subflg
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|esubm
argument_list|(
name|ai
argument_list|,
name|bi
argument_list|)
expr_stmt|;
name|subflg
operator|=
literal|1
expr_stmt|;
block|}
name|emdnorm
argument_list|(
name|bi
argument_list|,
name|lost
argument_list|,
name|subflg
argument_list|,
name|ltb
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|done
label|:
name|emovo
argument_list|(
name|bi
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* ;	Divide. ; ;	unsigned EMUSHORT a[NE], b[NE], c[NE]; ;	ediv (a, b, c);	c = b / a */
end_comment

begin_function
name|void
name|ediv
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|a
decl_stmt|,
decl|*
name|b
decl_stmt|,
modifier|*
name|c
decl_stmt|;
end_function

begin_block
block|{
name|unsigned
name|EMUSHORT
name|ai
index|[
name|NI
index|]
decl_stmt|,
name|bi
index|[
name|NI
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|EMULONG
name|lt
decl_stmt|,
name|lta
decl_stmt|,
name|ltb
decl_stmt|;
ifdef|#
directive|ifdef
name|NANS
comment|/* Return any NaN input. */
if|if
condition|(
name|eisnan
argument_list|(
name|a
argument_list|)
condition|)
block|{
name|emov
argument_list|(
name|a
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|eisnan
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|emov
argument_list|(
name|b
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Zero over zero, or infinity over infinity, is a NaN. */
if|if
condition|(
operator|(
operator|(
name|ecmp
argument_list|(
name|a
argument_list|,
name|ezero
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|ecmp
argument_list|(
name|b
argument_list|,
name|ezero
argument_list|)
operator|==
literal|0
operator|)
operator|)
operator|||
operator|(
name|eisinf
argument_list|(
name|a
argument_list|)
operator|&&
name|eisinf
argument_list|(
name|b
argument_list|)
operator|)
condition|)
block|{
name|mtherr
argument_list|(
literal|"ediv"
argument_list|,
name|INVALID
argument_list|)
expr_stmt|;
name|enan
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* Infinity over anything else is infinity. */
ifdef|#
directive|ifdef
name|INFINITY
if|if
condition|(
name|eisinf
argument_list|(
name|b
argument_list|)
condition|)
block|{
if|if
condition|(
name|eisneg
argument_list|(
name|a
argument_list|)
operator|^
name|eisneg
argument_list|(
name|b
argument_list|)
condition|)
operator|*
operator|(
name|c
operator|+
operator|(
name|NE
operator|-
literal|1
operator|)
operator|)
operator|=
literal|0x8000
expr_stmt|;
else|else
operator|*
operator|(
name|c
operator|+
operator|(
name|NE
operator|-
literal|1
operator|)
operator|)
operator|=
literal|0
expr_stmt|;
name|einfin
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Anything else over infinity is zero. */
if|if
condition|(
name|eisinf
argument_list|(
name|a
argument_list|)
condition|)
block|{
name|eclear
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|emovi
argument_list|(
name|a
argument_list|,
name|ai
argument_list|)
expr_stmt|;
name|emovi
argument_list|(
name|b
argument_list|,
name|bi
argument_list|)
expr_stmt|;
name|lta
operator|=
name|ai
index|[
name|E
index|]
expr_stmt|;
name|ltb
operator|=
name|bi
index|[
name|E
index|]
expr_stmt|;
if|if
condition|(
name|bi
index|[
name|E
index|]
operator|==
literal|0
condition|)
block|{
comment|/* See if numerator is zero. */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NI
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bi
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|ltb
operator|-=
name|enormlz
argument_list|(
name|bi
argument_list|)
expr_stmt|;
goto|goto
name|dnzro1
goto|;
block|}
block|}
name|eclear
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
name|dnzro1
label|:
if|if
condition|(
name|ai
index|[
name|E
index|]
operator|==
literal|0
condition|)
block|{
comment|/* possible divide by zero */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NI
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ai
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|lta
operator|-=
name|enormlz
argument_list|(
name|ai
argument_list|)
expr_stmt|;
goto|goto
name|dnzro2
goto|;
block|}
block|}
if|if
condition|(
name|ai
index|[
literal|0
index|]
operator|==
name|bi
index|[
literal|0
index|]
condition|)
operator|*
operator|(
name|c
operator|+
operator|(
name|NE
operator|-
literal|1
operator|)
operator|)
operator|=
literal|0
expr_stmt|;
else|else
operator|*
operator|(
name|c
operator|+
operator|(
name|NE
operator|-
literal|1
operator|)
operator|)
operator|=
literal|0x8000
expr_stmt|;
comment|/* Divide by zero is not an invalid operation.    It is a divide-by-zero operation!   */
name|einfin
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|mtherr
argument_list|(
literal|"ediv"
argument_list|,
name|SING
argument_list|)
expr_stmt|;
return|return;
block|}
name|dnzro2
label|:
name|i
operator|=
name|edivm
argument_list|(
name|ai
argument_list|,
name|bi
argument_list|)
expr_stmt|;
comment|/* calculate exponent */
name|lt
operator|=
name|ltb
operator|-
name|lta
operator|+
name|EXONE
expr_stmt|;
name|emdnorm
argument_list|(
name|bi
argument_list|,
name|i
argument_list|,
literal|0
argument_list|,
name|lt
argument_list|,
literal|64
argument_list|)
expr_stmt|;
comment|/* set the sign */
if|if
condition|(
name|ai
index|[
literal|0
index|]
operator|==
name|bi
index|[
literal|0
index|]
condition|)
name|bi
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
else|else
name|bi
index|[
literal|0
index|]
operator|=
literal|0Xffff
expr_stmt|;
name|emovo
argument_list|(
name|bi
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* ;	Multiply. ; ;	unsigned EMUSHORT a[NE], b[NE], c[NE]; ;	emul (a, b, c);	c = b * a */
end_comment

begin_function
name|void
name|emul
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|a
decl_stmt|,
decl|*
name|b
decl_stmt|,
modifier|*
name|c
decl_stmt|;
end_function

begin_block
block|{
name|unsigned
name|EMUSHORT
name|ai
index|[
name|NI
index|]
decl_stmt|,
name|bi
index|[
name|NI
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|EMULONG
name|lt
decl_stmt|,
name|lta
decl_stmt|,
name|ltb
decl_stmt|;
ifdef|#
directive|ifdef
name|NANS
comment|/* NaN times anything is the same NaN. */
if|if
condition|(
name|eisnan
argument_list|(
name|a
argument_list|)
condition|)
block|{
name|emov
argument_list|(
name|a
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|eisnan
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|emov
argument_list|(
name|b
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Zero times infinity is a NaN. */
if|if
condition|(
operator|(
name|eisinf
argument_list|(
name|a
argument_list|)
operator|&&
operator|(
name|ecmp
argument_list|(
name|b
argument_list|,
name|ezero
argument_list|)
operator|==
literal|0
operator|)
operator|)
operator|||
operator|(
name|eisinf
argument_list|(
name|b
argument_list|)
operator|&&
operator|(
name|ecmp
argument_list|(
name|a
argument_list|,
name|ezero
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|mtherr
argument_list|(
literal|"emul"
argument_list|,
name|INVALID
argument_list|)
expr_stmt|;
name|enan
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* Infinity times anything else is infinity. */
ifdef|#
directive|ifdef
name|INFINITY
if|if
condition|(
name|eisinf
argument_list|(
name|a
argument_list|)
operator|||
name|eisinf
argument_list|(
name|b
argument_list|)
condition|)
block|{
if|if
condition|(
name|eisneg
argument_list|(
name|a
argument_list|)
operator|^
name|eisneg
argument_list|(
name|b
argument_list|)
condition|)
operator|*
operator|(
name|c
operator|+
operator|(
name|NE
operator|-
literal|1
operator|)
operator|)
operator|=
literal|0x8000
expr_stmt|;
else|else
operator|*
operator|(
name|c
operator|+
operator|(
name|NE
operator|-
literal|1
operator|)
operator|)
operator|=
literal|0
expr_stmt|;
name|einfin
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|emovi
argument_list|(
name|a
argument_list|,
name|ai
argument_list|)
expr_stmt|;
name|emovi
argument_list|(
name|b
argument_list|,
name|bi
argument_list|)
expr_stmt|;
name|lta
operator|=
name|ai
index|[
name|E
index|]
expr_stmt|;
name|ltb
operator|=
name|bi
index|[
name|E
index|]
expr_stmt|;
if|if
condition|(
name|ai
index|[
name|E
index|]
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NI
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ai
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|lta
operator|-=
name|enormlz
argument_list|(
name|ai
argument_list|)
expr_stmt|;
goto|goto
name|mnzer1
goto|;
block|}
block|}
name|eclear
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
name|mnzer1
label|:
if|if
condition|(
name|bi
index|[
name|E
index|]
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NI
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bi
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|ltb
operator|-=
name|enormlz
argument_list|(
name|bi
argument_list|)
expr_stmt|;
goto|goto
name|mnzer2
goto|;
block|}
block|}
name|eclear
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
name|mnzer2
label|:
comment|/* Multiply significands */
name|j
operator|=
name|emulm
argument_list|(
name|ai
argument_list|,
name|bi
argument_list|)
expr_stmt|;
comment|/* calculate exponent */
name|lt
operator|=
name|lta
operator|+
name|ltb
operator|-
operator|(
name|EXONE
operator|-
literal|1
operator|)
expr_stmt|;
name|emdnorm
argument_list|(
name|bi
argument_list|,
name|j
argument_list|,
literal|0
argument_list|,
name|lt
argument_list|,
literal|64
argument_list|)
expr_stmt|;
comment|/* calculate sign of product */
if|if
condition|(
name|ai
index|[
literal|0
index|]
operator|==
name|bi
index|[
literal|0
index|]
condition|)
name|bi
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
else|else
name|bi
index|[
literal|0
index|]
operator|=
literal|0xffff
expr_stmt|;
name|emovo
argument_list|(
name|bi
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* ; Convert IEEE double precision to e type ;	double d; ;	unsigned EMUSHORT x[N+2]; ;	e53toe (&d, x); */
end_comment

begin_function
name|void
name|e53toe
parameter_list|(
name|pe
parameter_list|,
name|y
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|pe
decl_stmt|,
decl|*
name|y
decl_stmt|;
end_function

begin_block
block|{
ifdef|#
directive|ifdef
name|DEC
name|dectoe
argument_list|(
name|pe
argument_list|,
name|y
argument_list|)
expr_stmt|;
comment|/* see etodec.c */
else|#
directive|else
specifier|register
name|unsigned
name|EMUSHORT
name|r
decl_stmt|;
specifier|register
name|unsigned
name|EMUSHORT
modifier|*
name|e
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|unsigned
name|EMUSHORT
name|yy
index|[
name|NI
index|]
decl_stmt|;
name|int
name|denorm
decl_stmt|,
name|k
decl_stmt|;
name|e
operator|=
name|pe
expr_stmt|;
name|denorm
operator|=
literal|0
expr_stmt|;
comment|/* flag if denormalized number */
name|ecleaz
argument_list|(
name|yy
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IBMPC
name|e
operator|+=
literal|3
expr_stmt|;
endif|#
directive|endif
name|r
operator|=
operator|*
name|e
expr_stmt|;
name|yy
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|r
operator|&
literal|0x8000
condition|)
name|yy
index|[
literal|0
index|]
operator|=
literal|0xffff
expr_stmt|;
name|yy
index|[
name|M
index|]
operator|=
operator|(
name|r
operator|&
literal|0x0f
operator|)
operator||
literal|0x10
expr_stmt|;
name|r
operator|&=
operator|~
literal|0x800f
expr_stmt|;
comment|/* strip sign and 4 significand bits */
ifdef|#
directive|ifdef
name|INFINITY
if|if
condition|(
name|r
operator|==
literal|0x7ff0
condition|)
block|{
ifdef|#
directive|ifdef
name|NANS
ifdef|#
directive|ifdef
name|IBMPC
if|if
condition|(
operator|(
operator|(
name|pe
index|[
literal|3
index|]
operator|&
literal|0xf
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|pe
index|[
literal|2
index|]
operator|!=
literal|0
operator|)
operator|||
operator|(
name|pe
index|[
literal|1
index|]
operator|!=
literal|0
operator|)
operator|||
operator|(
name|pe
index|[
literal|0
index|]
operator|!=
literal|0
operator|)
condition|)
block|{
name|enan
argument_list|(
name|y
argument_list|)
expr_stmt|;
return|return;
block|}
else|#
directive|else
if|if
condition|(
operator|(
operator|(
name|pe
index|[
literal|0
index|]
operator|&
literal|0xf
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|pe
index|[
literal|1
index|]
operator|!=
literal|0
operator|)
operator|||
operator|(
name|pe
index|[
literal|2
index|]
operator|!=
literal|0
operator|)
operator|||
operator|(
name|pe
index|[
literal|3
index|]
operator|!=
literal|0
operator|)
condition|)
block|{
name|enan
argument_list|(
name|y
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
endif|#
directive|endif
comment|/* NANS */
name|eclear
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|einfin
argument_list|(
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|yy
index|[
literal|0
index|]
condition|)
name|eneg
argument_list|(
name|y
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* INFINITY */
name|r
operator|>>=
literal|4
expr_stmt|;
comment|/* If zero exponent, then the significand is denormalized.    * So, take back the understood high significand bit. */
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
name|denorm
operator|=
literal|1
expr_stmt|;
name|yy
index|[
name|M
index|]
operator|&=
operator|~
literal|0x10
expr_stmt|;
block|}
name|r
operator|+=
name|EXONE
operator|-
literal|01777
expr_stmt|;
name|yy
index|[
name|E
index|]
operator|=
name|r
expr_stmt|;
name|p
operator|=
operator|&
name|yy
index|[
name|M
operator|+
literal|1
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|IBMPC
operator|*
name|p
operator|++
operator|=
operator|*
operator|(
operator|--
name|e
operator|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|*
operator|(
operator|--
name|e
operator|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|*
operator|(
operator|--
name|e
operator|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MIEEE
operator|++
name|e
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|*
name|e
operator|++
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|*
name|e
operator|++
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|*
name|e
operator|++
expr_stmt|;
endif|#
directive|endif
name|eshift
argument_list|(
name|yy
argument_list|,
operator|-
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|denorm
condition|)
block|{
comment|/* if zero exponent, then normalize the significand */
if|if
condition|(
operator|(
name|k
operator|=
name|enormlz
argument_list|(
name|yy
argument_list|)
operator|)
operator|>
name|NBITS
condition|)
name|ecleazs
argument_list|(
name|yy
argument_list|)
expr_stmt|;
else|else
name|yy
index|[
name|E
index|]
operator|-=
call|(
name|unsigned
name|EMUSHORT
call|)
argument_list|(
name|k
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|emovo
argument_list|(
name|yy
argument_list|,
name|y
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not DEC */
block|}
end_block

begin_function
name|void
name|e64toe
parameter_list|(
name|pe
parameter_list|,
name|y
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|pe
decl_stmt|,
decl|*
name|y
decl_stmt|;
end_function

begin_block
block|{
name|unsigned
name|EMUSHORT
name|yy
index|[
name|NI
index|]
decl_stmt|;
name|unsigned
name|EMUSHORT
modifier|*
name|e
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|int
name|i
decl_stmt|;
name|e
operator|=
name|pe
expr_stmt|;
name|p
operator|=
name|yy
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NE
operator|-
literal|5
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|IBMPC
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
operator|*
name|e
operator|++
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEC
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
operator|*
name|e
operator|++
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MIEEE
name|p
operator|=
operator|&
name|yy
index|[
literal|0
index|]
operator|+
operator|(
name|NE
operator|-
literal|1
operator|)
expr_stmt|;
operator|*
name|p
operator|--
operator|=
operator|*
name|e
operator|++
expr_stmt|;
operator|++
name|e
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|--
operator|=
operator|*
name|e
operator|++
expr_stmt|;
endif|#
directive|endif
name|p
operator|=
name|yy
expr_stmt|;
name|q
operator|=
name|y
expr_stmt|;
ifdef|#
directive|ifdef
name|INFINITY
if|if
condition|(
operator|*
name|p
operator|==
literal|0x7fff
condition|)
block|{
ifdef|#
directive|ifdef
name|NANS
ifdef|#
directive|ifdef
name|IBMPC
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pe
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|enan
argument_list|(
name|y
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|#
directive|else
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
literal|4
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pe
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|enan
argument_list|(
name|y
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
endif|#
directive|endif
endif|#
directive|endif
comment|/* NANS */
name|eclear
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|einfin
argument_list|(
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|&
literal|0x8000
condition|)
name|eneg
argument_list|(
name|y
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* INFINITY */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NE
condition|;
name|i
operator|++
control|)
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
end_block

begin_comment
comment|/* ; Convert IEEE single precision to e type ;	float d; ;	unsigned EMUSHORT x[N+2]; ;	dtox (&d, x); */
end_comment

begin_function
name|void
name|e24toe
parameter_list|(
name|pe
parameter_list|,
name|y
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|pe
decl_stmt|,
decl|*
name|y
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|unsigned
name|EMUSHORT
name|r
decl_stmt|;
specifier|register
name|unsigned
name|EMUSHORT
modifier|*
name|e
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|unsigned
name|EMUSHORT
name|yy
index|[
name|NI
index|]
decl_stmt|;
name|int
name|denorm
decl_stmt|,
name|k
decl_stmt|;
name|e
operator|=
name|pe
expr_stmt|;
name|denorm
operator|=
literal|0
expr_stmt|;
comment|/* flag if denormalized number */
name|ecleaz
argument_list|(
name|yy
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IBMPC
name|e
operator|+=
literal|1
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEC
name|e
operator|+=
literal|1
expr_stmt|;
endif|#
directive|endif
name|r
operator|=
operator|*
name|e
expr_stmt|;
name|yy
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|r
operator|&
literal|0x8000
condition|)
name|yy
index|[
literal|0
index|]
operator|=
literal|0xffff
expr_stmt|;
name|yy
index|[
name|M
index|]
operator|=
operator|(
name|r
operator|&
literal|0x7f
operator|)
operator||
literal|0200
expr_stmt|;
name|r
operator|&=
operator|~
literal|0x807f
expr_stmt|;
comment|/* strip sign and 7 significand bits */
ifdef|#
directive|ifdef
name|INFINITY
if|if
condition|(
name|r
operator|==
literal|0x7f80
condition|)
block|{
ifdef|#
directive|ifdef
name|NANS
ifdef|#
directive|ifdef
name|MIEEE
if|if
condition|(
operator|(
operator|(
name|pe
index|[
literal|0
index|]
operator|&
literal|0x7f
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|pe
index|[
literal|1
index|]
operator|!=
literal|0
operator|)
condition|)
block|{
name|enan
argument_list|(
name|y
argument_list|)
expr_stmt|;
return|return;
block|}
else|#
directive|else
if|if
condition|(
operator|(
operator|(
name|pe
index|[
literal|1
index|]
operator|&
literal|0x7f
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|pe
index|[
literal|0
index|]
operator|!=
literal|0
operator|)
condition|)
block|{
name|enan
argument_list|(
name|y
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
endif|#
directive|endif
comment|/* NANS */
name|eclear
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|einfin
argument_list|(
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|yy
index|[
literal|0
index|]
condition|)
name|eneg
argument_list|(
name|y
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* INFINITY */
name|r
operator|>>=
literal|7
expr_stmt|;
comment|/* If zero exponent, then the significand is denormalized.    * So, take back the understood high significand bit. */
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
name|denorm
operator|=
literal|1
expr_stmt|;
name|yy
index|[
name|M
index|]
operator|&=
operator|~
literal|0200
expr_stmt|;
block|}
name|r
operator|+=
name|EXONE
operator|-
literal|0177
expr_stmt|;
name|yy
index|[
name|E
index|]
operator|=
name|r
expr_stmt|;
name|p
operator|=
operator|&
name|yy
index|[
name|M
operator|+
literal|1
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|IBMPC
operator|*
name|p
operator|++
operator|=
operator|*
operator|(
operator|--
name|e
operator|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEC
operator|*
name|p
operator|++
operator|=
operator|*
operator|(
operator|--
name|e
operator|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MIEEE
operator|++
name|e
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|*
name|e
operator|++
expr_stmt|;
endif|#
directive|endif
name|eshift
argument_list|(
name|yy
argument_list|,
operator|-
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|denorm
condition|)
block|{
comment|/* if zero exponent, then normalize the significand */
if|if
condition|(
operator|(
name|k
operator|=
name|enormlz
argument_list|(
name|yy
argument_list|)
operator|)
operator|>
name|NBITS
condition|)
name|ecleazs
argument_list|(
name|yy
argument_list|)
expr_stmt|;
else|else
name|yy
index|[
name|E
index|]
operator|-=
call|(
name|unsigned
name|EMUSHORT
call|)
argument_list|(
name|k
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|emovo
argument_list|(
name|yy
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|void
name|etoe64
parameter_list|(
name|x
parameter_list|,
name|e
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|,
decl|*
name|e
decl_stmt|;
end_function

begin_block
block|{
name|unsigned
name|EMUSHORT
name|xi
index|[
name|NI
index|]
decl_stmt|;
name|EMULONG
name|exp
decl_stmt|;
name|int
name|rndsav
decl_stmt|;
ifdef|#
directive|ifdef
name|NANS
if|if
condition|(
name|eisnan
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|make_nan
argument_list|(
name|e
argument_list|,
name|XFmode
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|emovi
argument_list|(
name|x
argument_list|,
name|xi
argument_list|)
expr_stmt|;
comment|/* adjust exponent for offset */
name|exp
operator|=
operator|(
name|EMULONG
operator|)
name|xi
index|[
name|E
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|INFINITY
if|if
condition|(
name|eisinf
argument_list|(
name|x
argument_list|)
condition|)
goto|goto
name|nonorm
goto|;
endif|#
directive|endif
comment|/* round off to nearest or even */
name|rndsav
operator|=
name|rndprc
expr_stmt|;
name|rndprc
operator|=
literal|64
expr_stmt|;
name|emdnorm
argument_list|(
name|xi
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|exp
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|rndprc
operator|=
name|rndsav
expr_stmt|;
name|nonorm
label|:
name|toe64
argument_list|(
name|xi
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* move out internal format to ieee long double */
end_comment

begin_function
specifier|static
name|void
name|toe64
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|a
decl_stmt|,
decl|*
name|b
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|unsigned
name|EMUSHORT
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|unsigned
name|EMUSHORT
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|NANS
if|if
condition|(
name|eiisnan
argument_list|(
name|a
argument_list|)
condition|)
block|{
name|make_nan
argument_list|(
name|b
argument_list|,
name|XFmode
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|p
operator|=
name|a
expr_stmt|;
ifdef|#
directive|ifdef
name|MIEEE
name|q
operator|=
name|b
expr_stmt|;
else|#
directive|else
name|q
operator|=
name|b
operator|+
literal|4
expr_stmt|;
comment|/* point to output exponent */
if|#
directive|if
name|LONG_DOUBLE_TYPE_SIZE
operator|==
literal|96
comment|/* Clear the last two bytes of 12-byte Intel format */
operator|*
operator|(
name|q
operator|+
literal|1
operator|)
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* combine sign and exponent */
name|i
operator|=
operator|*
name|p
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|MIEEE
if|if
condition|(
name|i
condition|)
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
operator||
literal|0x8000
expr_stmt|;
else|else
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|q
operator|++
operator|=
literal|0
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|i
condition|)
operator|*
name|q
operator|--
operator|=
operator|*
name|p
operator|++
operator||
literal|0x8000
expr_stmt|;
else|else
operator|*
name|q
operator|--
operator|=
operator|*
name|p
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* skip over guard word */
operator|++
name|p
expr_stmt|;
comment|/* move the significand */
ifdef|#
directive|ifdef
name|MIEEE
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
else|#
directive|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
operator|*
name|q
operator|--
operator|=
operator|*
name|p
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/* ; e type to IEEE double precision ;	double d; ;	unsigned EMUSHORT x[NE]; ;	etoe53 (x,&d); */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEC
end_ifdef

begin_function
name|void
name|etoe53
parameter_list|(
name|x
parameter_list|,
name|e
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|,
decl|*
name|e
decl_stmt|;
end_function

begin_block
block|{
name|etodec
argument_list|(
name|x
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|/* see etodec.c */
block|}
end_block

begin_function
specifier|static
name|void
name|toe53
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|,
decl|*
name|y
decl_stmt|;
end_function

begin_block
block|{
name|todec
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_function
name|void
name|etoe53
parameter_list|(
name|x
parameter_list|,
name|e
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|,
decl|*
name|e
decl_stmt|;
end_function

begin_block
block|{
name|unsigned
name|EMUSHORT
name|xi
index|[
name|NI
index|]
decl_stmt|;
name|EMULONG
name|exp
decl_stmt|;
name|int
name|rndsav
decl_stmt|;
ifdef|#
directive|ifdef
name|NANS
if|if
condition|(
name|eisnan
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|make_nan
argument_list|(
name|e
argument_list|,
name|DFmode
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|emovi
argument_list|(
name|x
argument_list|,
name|xi
argument_list|)
expr_stmt|;
comment|/* adjust exponent for offsets */
name|exp
operator|=
operator|(
name|EMULONG
operator|)
name|xi
index|[
name|E
index|]
operator|-
operator|(
name|EXONE
operator|-
literal|0x3ff
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INFINITY
if|if
condition|(
name|eisinf
argument_list|(
name|x
argument_list|)
condition|)
goto|goto
name|nonorm
goto|;
endif|#
directive|endif
comment|/* round off to nearest or even */
name|rndsav
operator|=
name|rndprc
expr_stmt|;
name|rndprc
operator|=
literal|53
expr_stmt|;
name|emdnorm
argument_list|(
name|xi
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|exp
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|rndprc
operator|=
name|rndsav
expr_stmt|;
name|nonorm
label|:
name|toe53
argument_list|(
name|xi
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|void
name|toe53
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|,
decl|*
name|y
decl_stmt|;
end_function

begin_block
block|{
name|unsigned
name|EMUSHORT
name|i
decl_stmt|;
name|unsigned
name|EMUSHORT
modifier|*
name|p
decl_stmt|;
ifdef|#
directive|ifdef
name|NANS
if|if
condition|(
name|eiisnan
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|make_nan
argument_list|(
name|y
argument_list|,
name|DFmode
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|p
operator|=
operator|&
name|x
index|[
literal|0
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|IBMPC
name|y
operator|+=
literal|3
expr_stmt|;
endif|#
directive|endif
operator|*
name|y
operator|=
literal|0
expr_stmt|;
comment|/* output high order */
if|if
condition|(
operator|*
name|p
operator|++
condition|)
operator|*
name|y
operator|=
literal|0x8000
expr_stmt|;
comment|/* output sign bit */
name|i
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>=
operator|(
name|unsigned
name|int
operator|)
literal|2047
condition|)
block|{
comment|/* Saturate at largest number less than infinity. */
ifdef|#
directive|ifdef
name|INFINITY
operator|*
name|y
operator||=
literal|0x7ff0
expr_stmt|;
ifdef|#
directive|ifdef
name|IBMPC
operator|*
operator|(
operator|--
name|y
operator|)
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
operator|--
name|y
operator|)
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
operator|--
name|y
operator|)
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MIEEE
operator|++
name|y
expr_stmt|;
operator|*
name|y
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|y
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|y
operator|++
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
operator|*
name|y
operator||=
operator|(
name|unsigned
name|EMUSHORT
operator|)
literal|0x7fef
expr_stmt|;
ifdef|#
directive|ifdef
name|IBMPC
operator|*
operator|(
operator|--
name|y
operator|)
operator|=
literal|0xffff
expr_stmt|;
operator|*
operator|(
operator|--
name|y
operator|)
operator|=
literal|0xffff
expr_stmt|;
operator|*
operator|(
operator|--
name|y
operator|)
operator|=
literal|0xffff
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MIEEE
operator|++
name|y
expr_stmt|;
operator|*
name|y
operator|++
operator|=
literal|0xffff
expr_stmt|;
operator|*
name|y
operator|++
operator|=
literal|0xffff
expr_stmt|;
operator|*
name|y
operator|++
operator|=
literal|0xffff
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
return|return;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|eshift
argument_list|(
name|x
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|i
operator|<<=
literal|4
expr_stmt|;
name|eshift
argument_list|(
name|x
argument_list|,
literal|5
argument_list|)
expr_stmt|;
block|}
name|i
operator||=
operator|*
name|p
operator|++
operator|&
operator|(
name|unsigned
name|EMUSHORT
operator|)
literal|0x0f
expr_stmt|;
comment|/* *p = xi[M] */
operator|*
name|y
operator||=
operator|(
name|unsigned
name|EMUSHORT
operator|)
name|i
expr_stmt|;
comment|/* high order output already has sign bit set */
ifdef|#
directive|ifdef
name|IBMPC
operator|*
operator|(
operator|--
name|y
operator|)
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
operator|(
operator|--
name|y
operator|)
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
operator|(
operator|--
name|y
operator|)
operator|=
operator|*
name|p
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MIEEE
operator|++
name|y
expr_stmt|;
operator|*
name|y
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|y
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|y
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not DEC */
end_comment

begin_comment
comment|/* ; e type to IEEE single precision ;	float d; ;	unsigned EMUSHORT x[N+2]; ;	xtod (x,&d); */
end_comment

begin_function
name|void
name|etoe24
parameter_list|(
name|x
parameter_list|,
name|e
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|,
decl|*
name|e
decl_stmt|;
end_function

begin_block
block|{
name|EMULONG
name|exp
decl_stmt|;
name|unsigned
name|EMUSHORT
name|xi
index|[
name|NI
index|]
decl_stmt|;
name|int
name|rndsav
decl_stmt|;
ifdef|#
directive|ifdef
name|NANS
if|if
condition|(
name|eisnan
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|make_nan
argument_list|(
name|e
argument_list|,
name|SFmode
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|emovi
argument_list|(
name|x
argument_list|,
name|xi
argument_list|)
expr_stmt|;
comment|/* adjust exponent for offsets */
name|exp
operator|=
operator|(
name|EMULONG
operator|)
name|xi
index|[
name|E
index|]
operator|-
operator|(
name|EXONE
operator|-
literal|0177
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INFINITY
if|if
condition|(
name|eisinf
argument_list|(
name|x
argument_list|)
condition|)
goto|goto
name|nonorm
goto|;
endif|#
directive|endif
comment|/* round off to nearest or even */
name|rndsav
operator|=
name|rndprc
expr_stmt|;
name|rndprc
operator|=
literal|24
expr_stmt|;
name|emdnorm
argument_list|(
name|xi
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|exp
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|rndprc
operator|=
name|rndsav
expr_stmt|;
name|nonorm
label|:
name|toe24
argument_list|(
name|xi
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|void
name|toe24
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|,
decl|*
name|y
decl_stmt|;
end_function

begin_block
block|{
name|unsigned
name|EMUSHORT
name|i
decl_stmt|;
name|unsigned
name|EMUSHORT
modifier|*
name|p
decl_stmt|;
ifdef|#
directive|ifdef
name|NANS
if|if
condition|(
name|eiisnan
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|make_nan
argument_list|(
name|y
argument_list|,
name|SFmode
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|p
operator|=
operator|&
name|x
index|[
literal|0
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|IBMPC
name|y
operator|+=
literal|1
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEC
name|y
operator|+=
literal|1
expr_stmt|;
endif|#
directive|endif
operator|*
name|y
operator|=
literal|0
expr_stmt|;
comment|/* output high order */
if|if
condition|(
operator|*
name|p
operator|++
condition|)
operator|*
name|y
operator|=
literal|0x8000
expr_stmt|;
comment|/* output sign bit */
name|i
operator|=
operator|*
name|p
operator|++
expr_stmt|;
comment|/* Handle overflow cases. */
if|if
condition|(
name|i
operator|>=
literal|255
condition|)
block|{
ifdef|#
directive|ifdef
name|INFINITY
operator|*
name|y
operator||=
operator|(
name|unsigned
name|EMUSHORT
operator|)
literal|0x7f80
expr_stmt|;
ifdef|#
directive|ifdef
name|IBMPC
operator|*
operator|(
operator|--
name|y
operator|)
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEC
operator|*
operator|(
operator|--
name|y
operator|)
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MIEEE
operator|++
name|y
expr_stmt|;
operator|*
name|y
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
comment|/* no INFINITY */
operator|*
name|y
operator||=
operator|(
name|unsigned
name|EMUSHORT
operator|)
literal|0x7f7f
expr_stmt|;
ifdef|#
directive|ifdef
name|IBMPC
operator|*
operator|(
operator|--
name|y
operator|)
operator|=
literal|0xffff
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEC
operator|*
operator|(
operator|--
name|y
operator|)
operator|=
literal|0xffff
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MIEEE
operator|++
name|y
expr_stmt|;
operator|*
name|y
operator|=
literal|0xffff
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ERANGE
name|errno
operator|=
name|ERANGE
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* no INFINITY */
return|return;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|eshift
argument_list|(
name|x
argument_list|,
literal|7
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|i
operator|<<=
literal|7
expr_stmt|;
name|eshift
argument_list|(
name|x
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
name|i
operator||=
operator|*
name|p
operator|++
operator|&
operator|(
name|unsigned
name|EMUSHORT
operator|)
literal|0x7f
expr_stmt|;
comment|/* *p = xi[M] */
operator|*
name|y
operator||=
name|i
expr_stmt|;
comment|/* high order output already has sign bit set */
ifdef|#
directive|ifdef
name|IBMPC
operator|*
operator|(
operator|--
name|y
operator|)
operator|=
operator|*
name|p
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEC
operator|*
operator|(
operator|--
name|y
operator|)
operator|=
operator|*
name|p
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MIEEE
operator|++
name|y
expr_stmt|;
operator|*
name|y
operator|=
operator|*
name|p
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/* Compare two e type numbers.  *  * unsigned EMUSHORT a[NE], b[NE];  * ecmp (a, b);  *  *  returns +1 if a> b  *           0 if a == b  *          -1 if a< b  *          -2 if either a or b is a NaN.  */
end_comment

begin_function
name|int
name|ecmp
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|a
decl_stmt|,
decl|*
name|b
decl_stmt|;
end_function

begin_block
block|{
name|unsigned
name|EMUSHORT
name|ai
index|[
name|NI
index|]
decl_stmt|,
name|bi
index|[
name|NI
index|]
decl_stmt|;
specifier|register
name|unsigned
name|EMUSHORT
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|msign
decl_stmt|;
ifdef|#
directive|ifdef
name|NANS
if|if
condition|(
name|eisnan
argument_list|(
name|a
argument_list|)
operator|||
name|eisnan
argument_list|(
name|b
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|2
operator|)
return|;
endif|#
directive|endif
name|emovi
argument_list|(
name|a
argument_list|,
name|ai
argument_list|)
expr_stmt|;
name|p
operator|=
name|ai
expr_stmt|;
name|emovi
argument_list|(
name|b
argument_list|,
name|bi
argument_list|)
expr_stmt|;
name|q
operator|=
name|bi
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
operator|*
name|q
condition|)
block|{
comment|/* the signs are different */
comment|/* -0 equals + 0 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NI
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ai
index|[
name|i
index|]
operator|!=
literal|0
condition|)
goto|goto
name|nzro
goto|;
if|if
condition|(
name|bi
index|[
name|i
index|]
operator|!=
literal|0
condition|)
goto|goto
name|nzro
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|nzro
label|:
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* both are the same sign */
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
name|msign
operator|=
literal|1
expr_stmt|;
else|else
name|msign
operator|=
operator|-
literal|1
expr_stmt|;
name|i
operator|=
name|NI
operator|-
literal|1
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
operator|*
name|q
operator|++
condition|)
block|{
goto|goto
name|diff
goto|;
block|}
block|}
do|while
condition|(
operator|--
name|i
operator|>
literal|0
condition|)
do|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* equality */
name|diff
label|:
if|if
condition|(
operator|*
operator|(
operator|--
name|p
operator|)
operator|>
operator|*
operator|(
operator|--
name|q
operator|)
condition|)
return|return
operator|(
name|msign
operator|)
return|;
comment|/* p is bigger */
else|else
return|return
operator|(
operator|-
name|msign
operator|)
return|;
comment|/* p is littler */
block|}
end_block

begin_comment
comment|/* Find nearest integer to x = floor (x + 0.5)  *  * unsigned EMUSHORT x[NE], y[NE]  * eround (x, y);  */
end_comment

begin_function
name|void
name|eround
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|,
decl|*
name|y
decl_stmt|;
end_function

begin_block
block|{
name|eadd
argument_list|(
name|ehalf
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|efloor
argument_list|(
name|y
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* ; convert long integer to e type ; ;	long l; ;	unsigned EMUSHORT x[NE]; ;	ltoe (&l, x); ; note&l is the memory address of l */
end_comment

begin_function
name|void
name|ltoe
parameter_list|(
name|lp
parameter_list|,
name|y
parameter_list|)
name|long
modifier|*
name|lp
decl_stmt|;
comment|/* lp is the memory address of a long integer */
name|unsigned
name|EMUSHORT
modifier|*
name|y
decl_stmt|;
comment|/* y is the address of a short */
block|{
name|unsigned
name|EMUSHORT
name|yi
index|[
name|NI
index|]
decl_stmt|;
name|unsigned
name|long
name|ll
decl_stmt|;
name|int
name|k
decl_stmt|;
name|ecleaz
argument_list|(
name|yi
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|lp
operator|<
literal|0
condition|)
block|{
comment|/* make it positive */
name|ll
operator|=
call|(
name|unsigned
name|long
call|)
argument_list|(
operator|-
operator|(
operator|*
name|lp
operator|)
argument_list|)
expr_stmt|;
name|yi
index|[
literal|0
index|]
operator|=
literal|0xffff
expr_stmt|;
comment|/* put correct sign in the e type number */
block|}
else|else
block|{
name|ll
operator|=
call|(
name|unsigned
name|long
call|)
argument_list|(
operator|*
name|lp
argument_list|)
expr_stmt|;
block|}
comment|/* move the long integer to yi significand area */
if|#
directive|if
name|HOST_BITS_PER_LONG
operator|==
literal|64
name|yi
index|[
name|M
index|]
operator|=
call|(
name|unsigned
name|EMUSHORT
call|)
argument_list|(
name|ll
operator|>>
literal|48
argument_list|)
expr_stmt|;
name|yi
index|[
name|M
operator|+
literal|1
index|]
operator|=
call|(
name|unsigned
name|EMUSHORT
call|)
argument_list|(
name|ll
operator|>>
literal|32
argument_list|)
expr_stmt|;
name|yi
index|[
name|M
operator|+
literal|2
index|]
operator|=
call|(
name|unsigned
name|EMUSHORT
call|)
argument_list|(
name|ll
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|yi
index|[
name|M
operator|+
literal|3
index|]
operator|=
operator|(
name|unsigned
name|EMUSHORT
operator|)
name|ll
expr_stmt|;
name|yi
index|[
name|E
index|]
operator|=
name|EXONE
operator|+
literal|47
expr_stmt|;
comment|/* exponent if normalize shift count were 0 */
else|#
directive|else
name|yi
index|[
name|M
index|]
operator|=
call|(
name|unsigned
name|EMUSHORT
call|)
argument_list|(
name|ll
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|yi
index|[
name|M
operator|+
literal|1
index|]
operator|=
operator|(
name|unsigned
name|EMUSHORT
operator|)
name|ll
expr_stmt|;
name|yi
index|[
name|E
index|]
operator|=
name|EXONE
operator|+
literal|15
expr_stmt|;
comment|/* exponent if normalize shift count were 0 */
endif|#
directive|endif
if|if
condition|(
operator|(
name|k
operator|=
name|enormlz
argument_list|(
name|yi
argument_list|)
operator|)
operator|>
name|NBITS
condition|)
comment|/* normalize the significand */
name|ecleaz
argument_list|(
name|yi
argument_list|)
expr_stmt|;
comment|/* it was zero */
else|else
name|yi
index|[
name|E
index|]
operator|-=
operator|(
name|unsigned
name|EMUSHORT
operator|)
name|k
expr_stmt|;
comment|/* subtract shift count from exponent */
name|emovo
argument_list|(
name|yi
argument_list|,
name|y
argument_list|)
expr_stmt|;
comment|/* output the answer */
block|}
end_function

begin_comment
comment|/* ; convert unsigned long integer to e type ; ;	unsigned long l; ;	unsigned EMUSHORT x[NE]; ;	ltox (&l, x); ; note&l is the memory address of l */
end_comment

begin_function
name|void
name|ultoe
parameter_list|(
name|lp
parameter_list|,
name|y
parameter_list|)
name|unsigned
name|long
modifier|*
name|lp
decl_stmt|;
comment|/* lp is the memory address of a long integer */
name|unsigned
name|EMUSHORT
modifier|*
name|y
decl_stmt|;
comment|/* y is the address of a short */
block|{
name|unsigned
name|EMUSHORT
name|yi
index|[
name|NI
index|]
decl_stmt|;
name|unsigned
name|long
name|ll
decl_stmt|;
name|int
name|k
decl_stmt|;
name|ecleaz
argument_list|(
name|yi
argument_list|)
expr_stmt|;
name|ll
operator|=
operator|*
name|lp
expr_stmt|;
comment|/* move the long integer to ayi significand area */
if|#
directive|if
name|HOST_BITS_PER_LONG
operator|==
literal|64
name|yi
index|[
name|M
index|]
operator|=
call|(
name|unsigned
name|EMUSHORT
call|)
argument_list|(
name|ll
operator|>>
literal|48
argument_list|)
expr_stmt|;
name|yi
index|[
name|M
operator|+
literal|1
index|]
operator|=
call|(
name|unsigned
name|EMUSHORT
call|)
argument_list|(
name|ll
operator|>>
literal|32
argument_list|)
expr_stmt|;
name|yi
index|[
name|M
operator|+
literal|2
index|]
operator|=
call|(
name|unsigned
name|EMUSHORT
call|)
argument_list|(
name|ll
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|yi
index|[
name|M
operator|+
literal|3
index|]
operator|=
operator|(
name|unsigned
name|EMUSHORT
operator|)
name|ll
expr_stmt|;
name|yi
index|[
name|E
index|]
operator|=
name|EXONE
operator|+
literal|47
expr_stmt|;
comment|/* exponent if normalize shift count were 0 */
else|#
directive|else
name|yi
index|[
name|M
index|]
operator|=
call|(
name|unsigned
name|EMUSHORT
call|)
argument_list|(
name|ll
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|yi
index|[
name|M
operator|+
literal|1
index|]
operator|=
operator|(
name|unsigned
name|EMUSHORT
operator|)
name|ll
expr_stmt|;
name|yi
index|[
name|E
index|]
operator|=
name|EXONE
operator|+
literal|15
expr_stmt|;
comment|/* exponent if normalize shift count were 0 */
endif|#
directive|endif
if|if
condition|(
operator|(
name|k
operator|=
name|enormlz
argument_list|(
name|yi
argument_list|)
operator|)
operator|>
name|NBITS
condition|)
comment|/* normalize the significand */
name|ecleaz
argument_list|(
name|yi
argument_list|)
expr_stmt|;
comment|/* it was zero */
else|else
name|yi
index|[
name|E
index|]
operator|-=
operator|(
name|unsigned
name|EMUSHORT
operator|)
name|k
expr_stmt|;
comment|/* subtract shift count from exponent */
name|emovo
argument_list|(
name|yi
argument_list|,
name|y
argument_list|)
expr_stmt|;
comment|/* output the answer */
block|}
end_function

begin_comment
comment|/* ;	Find long integer and fractional parts  ;	long i; ;	unsigned EMUSHORT x[NE], frac[NE]; ;	xifrac (x,&i, frac);    The integer output has the sign of the input.  The fraction is the positive fractional part of abs (x). */
end_comment

begin_function
name|void
name|eifrac
parameter_list|(
name|x
parameter_list|,
name|i
parameter_list|,
name|frac
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|;
name|long
modifier|*
name|i
decl_stmt|;
name|unsigned
name|EMUSHORT
modifier|*
name|frac
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|xi
index|[
name|NI
index|]
decl_stmt|;
name|int
name|j
decl_stmt|,
name|k
decl_stmt|;
name|unsigned
name|long
name|ll
decl_stmt|;
name|emovi
argument_list|(
name|x
argument_list|,
name|xi
argument_list|)
expr_stmt|;
name|k
operator|=
operator|(
name|int
operator|)
name|xi
index|[
name|E
index|]
operator|-
operator|(
name|EXONE
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|k
operator|<=
literal|0
condition|)
block|{
comment|/* if exponent<= 0, integer = 0 and real output is fraction */
operator|*
name|i
operator|=
literal|0L
expr_stmt|;
name|emovo
argument_list|(
name|xi
argument_list|,
name|frac
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|k
operator|>
operator|(
name|HOST_BITS_PER_LONG
operator|-
literal|1
operator|)
condition|)
block|{
comment|/* long integer overflow: output large integer 	 and correct fraction  */
if|if
condition|(
name|xi
index|[
literal|0
index|]
condition|)
operator|*
name|i
operator|=
operator|(
operator|(
name|unsigned
name|long
operator|)
literal|1
operator|)
operator|<<
operator|(
name|HOST_BITS_PER_LONG
operator|-
literal|1
operator|)
expr_stmt|;
else|else
operator|*
name|i
operator|=
operator|(
operator|(
operator|(
name|unsigned
name|long
operator|)
literal|1
operator|)
operator|<<
operator|(
name|HOST_BITS_PER_LONG
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
name|eshift
argument_list|(
name|xi
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|extra_warnings
condition|)
name|warning
argument_list|(
literal|"overflow on truncation to integer"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|k
operator|>
literal|16
condition|)
block|{
comment|/* Shift more than 16 bits: first shift up k-16 mod 16, 	 then shift up by 16's.  */
name|j
operator|=
name|k
operator|-
operator|(
operator|(
name|k
operator|>>
literal|4
operator|)
operator|<<
literal|4
operator|)
expr_stmt|;
name|eshift
argument_list|(
name|xi
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|ll
operator|=
name|xi
index|[
name|M
index|]
expr_stmt|;
name|k
operator|-=
name|j
expr_stmt|;
do|do
block|{
name|eshup6
argument_list|(
name|xi
argument_list|)
expr_stmt|;
name|ll
operator|=
operator|(
name|ll
operator|<<
literal|16
operator|)
operator||
name|xi
index|[
name|M
index|]
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|k
operator|-=
literal|16
operator|)
operator|>
literal|0
condition|)
do|;
operator|*
name|i
operator|=
name|ll
expr_stmt|;
if|if
condition|(
name|xi
index|[
literal|0
index|]
condition|)
operator|*
name|i
operator|=
operator|-
operator|(
operator|*
name|i
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* shift not more than 16 bits */
name|eshift
argument_list|(
name|xi
argument_list|,
name|k
argument_list|)
expr_stmt|;
operator|*
name|i
operator|=
operator|(
name|long
operator|)
name|xi
index|[
name|M
index|]
operator|&
literal|0xffff
expr_stmt|;
if|if
condition|(
name|xi
index|[
literal|0
index|]
condition|)
operator|*
name|i
operator|=
operator|-
operator|(
operator|*
name|i
operator|)
expr_stmt|;
block|}
name|xi
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|xi
index|[
name|E
index|]
operator|=
name|EXONE
operator|-
literal|1
expr_stmt|;
name|xi
index|[
name|M
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|k
operator|=
name|enormlz
argument_list|(
name|xi
argument_list|)
operator|)
operator|>
name|NBITS
condition|)
name|ecleaz
argument_list|(
name|xi
argument_list|)
expr_stmt|;
else|else
name|xi
index|[
name|E
index|]
operator|-=
operator|(
name|unsigned
name|EMUSHORT
operator|)
name|k
expr_stmt|;
name|emovo
argument_list|(
name|xi
argument_list|,
name|frac
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find unsigned long integer and fractional parts.    A negative e type input yields integer output = 0    but correct fraction.  */
end_comment

begin_function
name|void
name|euifrac
parameter_list|(
name|x
parameter_list|,
name|i
parameter_list|,
name|frac
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|;
name|unsigned
name|long
modifier|*
name|i
decl_stmt|;
name|unsigned
name|EMUSHORT
modifier|*
name|frac
decl_stmt|;
block|{
name|unsigned
name|long
name|ll
decl_stmt|;
name|unsigned
name|EMUSHORT
name|xi
index|[
name|NI
index|]
decl_stmt|;
name|int
name|j
decl_stmt|,
name|k
decl_stmt|;
name|emovi
argument_list|(
name|x
argument_list|,
name|xi
argument_list|)
expr_stmt|;
name|k
operator|=
operator|(
name|int
operator|)
name|xi
index|[
name|E
index|]
operator|-
operator|(
name|EXONE
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|k
operator|<=
literal|0
condition|)
block|{
comment|/* if exponent<= 0, integer = 0 and argument is fraction */
operator|*
name|i
operator|=
literal|0L
expr_stmt|;
name|emovo
argument_list|(
name|xi
argument_list|,
name|frac
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|k
operator|>
name|HOST_BITS_PER_LONG
condition|)
block|{
comment|/* Long integer overflow: output large integer 	 and correct fraction. 	 Note, the BSD microvax compiler says that ~(0UL) 	 is a syntax error.  */
operator|*
name|i
operator|=
operator|~
operator|(
literal|0L
operator|)
expr_stmt|;
name|eshift
argument_list|(
name|xi
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|extra_warnings
condition|)
name|warning
argument_list|(
literal|"overflow on truncation to unsigned integer"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|k
operator|>
literal|16
condition|)
block|{
comment|/* Shift more than 16 bits: first shift up k-16 mod 16, 	 then shift up by 16's.  */
name|j
operator|=
name|k
operator|-
operator|(
operator|(
name|k
operator|>>
literal|4
operator|)
operator|<<
literal|4
operator|)
expr_stmt|;
name|eshift
argument_list|(
name|xi
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|ll
operator|=
name|xi
index|[
name|M
index|]
expr_stmt|;
name|k
operator|-=
name|j
expr_stmt|;
do|do
block|{
name|eshup6
argument_list|(
name|xi
argument_list|)
expr_stmt|;
name|ll
operator|=
operator|(
name|ll
operator|<<
literal|16
operator|)
operator||
name|xi
index|[
name|M
index|]
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|k
operator|-=
literal|16
operator|)
operator|>
literal|0
condition|)
do|;
operator|*
name|i
operator|=
name|ll
expr_stmt|;
block|}
else|else
block|{
comment|/* shift not more than 16 bits */
name|eshift
argument_list|(
name|xi
argument_list|,
name|k
argument_list|)
expr_stmt|;
operator|*
name|i
operator|=
operator|(
name|long
operator|)
name|xi
index|[
name|M
index|]
operator|&
literal|0xffff
expr_stmt|;
block|}
if|if
condition|(
name|xi
index|[
literal|0
index|]
condition|)
comment|/* A negative value yields unsigned integer 0. */
operator|*
name|i
operator|=
literal|0L
expr_stmt|;
name|xi
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|xi
index|[
name|E
index|]
operator|=
name|EXONE
operator|-
literal|1
expr_stmt|;
name|xi
index|[
name|M
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|k
operator|=
name|enormlz
argument_list|(
name|xi
argument_list|)
operator|)
operator|>
name|NBITS
condition|)
name|ecleaz
argument_list|(
name|xi
argument_list|)
expr_stmt|;
else|else
name|xi
index|[
name|E
index|]
operator|-=
operator|(
name|unsigned
name|EMUSHORT
operator|)
name|k
expr_stmt|;
name|emovo
argument_list|(
name|xi
argument_list|,
name|frac
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ;	Shift significand ; ;	Shifts significand area up or down by the number of bits ;	given by the variable sc. */
end_comment

begin_function
name|int
name|eshift
parameter_list|(
name|x
parameter_list|,
name|sc
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|;
name|int
name|sc
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|lost
decl_stmt|;
name|unsigned
name|EMUSHORT
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|sc
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|lost
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|x
operator|+
name|NI
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|sc
operator|<
literal|0
condition|)
block|{
name|sc
operator|=
operator|-
name|sc
expr_stmt|;
while|while
condition|(
name|sc
operator|>=
literal|16
condition|)
block|{
name|lost
operator||=
operator|*
name|p
expr_stmt|;
comment|/* remember lost bits */
name|eshdn6
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|sc
operator|-=
literal|16
expr_stmt|;
block|}
while|while
condition|(
name|sc
operator|>=
literal|8
condition|)
block|{
name|lost
operator||=
operator|*
name|p
operator|&
literal|0xff
expr_stmt|;
name|eshdn8
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|sc
operator|-=
literal|8
expr_stmt|;
block|}
while|while
condition|(
name|sc
operator|>
literal|0
condition|)
block|{
name|lost
operator||=
operator|*
name|p
operator|&
literal|1
expr_stmt|;
name|eshdn1
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|sc
operator|-=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|sc
operator|>=
literal|16
condition|)
block|{
name|eshup6
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|sc
operator|-=
literal|16
expr_stmt|;
block|}
while|while
condition|(
name|sc
operator|>=
literal|8
condition|)
block|{
name|eshup8
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|sc
operator|-=
literal|8
expr_stmt|;
block|}
while|while
condition|(
name|sc
operator|>
literal|0
condition|)
block|{
name|eshup1
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|sc
operator|-=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|lost
condition|)
name|lost
operator|=
literal|1
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|lost
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ;	normalize ; ; Shift normalizes the significand area pointed to by argument ; shift count (up = positive) is returned. */
end_comment

begin_function
name|int
name|enormlz
parameter_list|(
name|x
parameter_list|)
name|unsigned
name|EMUSHORT
name|x
index|[]
decl_stmt|;
block|{
specifier|register
name|unsigned
name|EMUSHORT
modifier|*
name|p
decl_stmt|;
name|int
name|sc
decl_stmt|;
name|sc
operator|=
literal|0
expr_stmt|;
name|p
operator|=
operator|&
name|x
index|[
name|M
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|0
condition|)
goto|goto
name|normdn
goto|;
operator|++
name|p
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|&
literal|0x8000
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* already normalized */
while|while
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
block|{
name|eshup6
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|sc
operator|+=
literal|16
expr_stmt|;
comment|/* With guard word, there are NBITS+16 bits available.        * return true if all are zero.        */
if|if
condition|(
name|sc
operator|>
name|NBITS
condition|)
return|return
operator|(
name|sc
operator|)
return|;
block|}
comment|/* see if high byte is zero */
while|while
condition|(
operator|(
operator|*
name|p
operator|&
literal|0xff00
operator|)
operator|==
literal|0
condition|)
block|{
name|eshup8
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|sc
operator|+=
literal|8
expr_stmt|;
block|}
comment|/* now shift 1 bit at a time */
while|while
condition|(
operator|(
operator|*
name|p
operator|&
literal|0x8000
operator|)
operator|==
literal|0
condition|)
block|{
name|eshup1
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|sc
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|sc
operator|>
name|NBITS
condition|)
block|{
name|mtherr
argument_list|(
literal|"enormlz"
argument_list|,
name|UNDERFLOW
argument_list|)
expr_stmt|;
return|return
operator|(
name|sc
operator|)
return|;
block|}
block|}
return|return
operator|(
name|sc
operator|)
return|;
comment|/* Normalize by shifting down out of the high guard word      of the significand */
name|normdn
label|:
if|if
condition|(
operator|*
name|p
operator|&
literal|0xff00
condition|)
block|{
name|eshdn8
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|sc
operator|-=
literal|8
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|p
operator|!=
literal|0
condition|)
block|{
name|eshdn1
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|sc
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|sc
operator|<
operator|-
name|NBITS
condition|)
block|{
name|mtherr
argument_list|(
literal|"enormlz"
argument_list|,
name|OVERFLOW
argument_list|)
expr_stmt|;
return|return
operator|(
name|sc
operator|)
return|;
block|}
block|}
return|return
operator|(
name|sc
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Convert e type number to decimal format ASCII string.  * The constants are for 64 bit precision.  */
end_comment

begin_define
define|#
directive|define
name|NTEN
value|12
end_define

begin_define
define|#
directive|define
name|MAXP
value|4096
end_define

begin_decl_stmt
specifier|static
name|unsigned
name|EMUSHORT
name|etens
index|[
name|NTEN
operator|+
literal|1
index|]
index|[
name|NE
index|]
init|=
block|{
block|{
literal|0xc94c
block|,
literal|0x979a
block|,
literal|0x8a20
block|,
literal|0x5202
block|,
literal|0xc460
block|,
literal|0x7525
block|,}
block|,
comment|/* 10**4096 */
block|{
literal|0xa74d
block|,
literal|0x5de4
block|,
literal|0xc53d
block|,
literal|0x3b5d
block|,
literal|0x9e8b
block|,
literal|0x5a92
block|,}
block|,
comment|/* 10**2048 */
block|{
literal|0x650d
block|,
literal|0x0c17
block|,
literal|0x8175
block|,
literal|0x7586
block|,
literal|0xc976
block|,
literal|0x4d48
block|,}
block|,
block|{
literal|0xcc65
block|,
literal|0x91c6
block|,
literal|0xa60e
block|,
literal|0xa0ae
block|,
literal|0xe319
block|,
literal|0x46a3
block|,}
block|,
block|{
literal|0xddbc
block|,
literal|0xde8d
block|,
literal|0x9df9
block|,
literal|0xebfb
block|,
literal|0xaa7e
block|,
literal|0x4351
block|,}
block|,
block|{
literal|0xc66f
block|,
literal|0x8cdf
block|,
literal|0x80e9
block|,
literal|0x47c9
block|,
literal|0x93ba
block|,
literal|0x41a8
block|,}
block|,
block|{
literal|0x3cbf
block|,
literal|0xa6d5
block|,
literal|0xffcf
block|,
literal|0x1f49
block|,
literal|0xc278
block|,
literal|0x40d3
block|,}
block|,
block|{
literal|0xf020
block|,
literal|0xb59d
block|,
literal|0x2b70
block|,
literal|0xada8
block|,
literal|0x9dc5
block|,
literal|0x4069
block|,}
block|,
block|{
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0400
block|,
literal|0xc9bf
block|,
literal|0x8e1b
block|,
literal|0x4034
block|,}
block|,
block|{
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x2000
block|,
literal|0xbebc
block|,
literal|0x4019
block|,}
block|,
block|{
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x9c40
block|,
literal|0x400c
block|,}
block|,
block|{
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0xc800
block|,
literal|0x4005
block|,}
block|,
block|{
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0xa000
block|,
literal|0x4002
block|,}
block|,
comment|/* 10**1 */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|EMUSHORT
name|emtens
index|[
name|NTEN
operator|+
literal|1
index|]
index|[
name|NE
index|]
init|=
block|{
block|{
literal|0x2de4
block|,
literal|0x9fde
block|,
literal|0xd2ce
block|,
literal|0x04c8
block|,
literal|0xa6dd
block|,
literal|0x0ad8
block|,}
block|,
comment|/* 10**-4096 */
block|{
literal|0x4925
block|,
literal|0x2de4
block|,
literal|0x3436
block|,
literal|0x534f
block|,
literal|0xceae
block|,
literal|0x256b
block|,}
block|,
comment|/* 10**-2048 */
block|{
literal|0x87a6
block|,
literal|0xc0bd
block|,
literal|0xda57
block|,
literal|0x82a5
block|,
literal|0xa2a6
block|,
literal|0x32b5
block|,}
block|,
block|{
literal|0x7133
block|,
literal|0xd21c
block|,
literal|0xdb23
block|,
literal|0xee32
block|,
literal|0x9049
block|,
literal|0x395a
block|,}
block|,
block|{
literal|0xfa91
block|,
literal|0x1939
block|,
literal|0x637a
block|,
literal|0x4325
block|,
literal|0xc031
block|,
literal|0x3cac
block|,}
block|,
block|{
literal|0xac7d
block|,
literal|0xe4a0
block|,
literal|0x64bc
block|,
literal|0x467c
block|,
literal|0xddd0
block|,
literal|0x3e55
block|,}
block|,
block|{
literal|0x3f24
block|,
literal|0xe9a5
block|,
literal|0xa539
block|,
literal|0xea27
block|,
literal|0xa87f
block|,
literal|0x3f2a
block|,}
block|,
block|{
literal|0x67de
block|,
literal|0x94ba
block|,
literal|0x4539
block|,
literal|0x1ead
block|,
literal|0xcfb1
block|,
literal|0x3f94
block|,}
block|,
block|{
literal|0x4c2f
block|,
literal|0xe15b
block|,
literal|0xc44d
block|,
literal|0x94be
block|,
literal|0xe695
block|,
literal|0x3fc9
block|,}
block|,
block|{
literal|0xfdc2
block|,
literal|0xcefc
block|,
literal|0x8461
block|,
literal|0x7711
block|,
literal|0xabcc
block|,
literal|0x3fe4
block|,}
block|,
block|{
literal|0xd3c3
block|,
literal|0x652b
block|,
literal|0xe219
block|,
literal|0x1758
block|,
literal|0xd1b7
block|,
literal|0x3ff1
block|,}
block|,
block|{
literal|0x3d71
block|,
literal|0xd70a
block|,
literal|0x70a3
block|,
literal|0x0a3d
block|,
literal|0xa3d7
block|,
literal|0x3ff8
block|,}
block|,
block|{
literal|0xcccd
block|,
literal|0xcccc
block|,
literal|0xcccc
block|,
literal|0xcccc
block|,
literal|0xcccc
block|,
literal|0x3ffb
block|,}
block|,
comment|/* 10**-1 */
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|e24toasc
parameter_list|(
name|x
parameter_list|,
name|string
parameter_list|,
name|ndigs
parameter_list|)
name|unsigned
name|EMUSHORT
name|x
index|[]
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|ndigs
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|w
index|[
name|NI
index|]
decl_stmt|;
name|e24toe
argument_list|(
name|x
argument_list|,
name|w
argument_list|)
expr_stmt|;
name|etoasc
argument_list|(
name|w
argument_list|,
name|string
argument_list|,
name|ndigs
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|e53toasc
parameter_list|(
name|x
parameter_list|,
name|string
parameter_list|,
name|ndigs
parameter_list|)
name|unsigned
name|EMUSHORT
name|x
index|[]
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|ndigs
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|w
index|[
name|NI
index|]
decl_stmt|;
name|e53toe
argument_list|(
name|x
argument_list|,
name|w
argument_list|)
expr_stmt|;
name|etoasc
argument_list|(
name|w
argument_list|,
name|string
argument_list|,
name|ndigs
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|e64toasc
parameter_list|(
name|x
parameter_list|,
name|string
parameter_list|,
name|ndigs
parameter_list|)
name|unsigned
name|EMUSHORT
name|x
index|[]
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|ndigs
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|w
index|[
name|NI
index|]
decl_stmt|;
name|e64toe
argument_list|(
name|x
argument_list|,
name|w
argument_list|)
expr_stmt|;
name|etoasc
argument_list|(
name|w
argument_list|,
name|string
argument_list|,
name|ndigs
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
name|wstring
index|[
literal|80
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* working storage for ASCII output */
end_comment

begin_function
name|void
name|etoasc
parameter_list|(
name|x
parameter_list|,
name|string
parameter_list|,
name|ndigs
parameter_list|)
name|unsigned
name|EMUSHORT
name|x
index|[]
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|ndigs
decl_stmt|;
block|{
name|EMUSHORT
name|digit
decl_stmt|;
name|unsigned
name|EMUSHORT
name|y
index|[
name|NI
index|]
decl_stmt|,
name|t
index|[
name|NI
index|]
decl_stmt|,
name|u
index|[
name|NI
index|]
decl_stmt|,
name|w
index|[
name|NI
index|]
decl_stmt|;
name|unsigned
name|EMUSHORT
modifier|*
name|p
decl_stmt|,
modifier|*
name|r
decl_stmt|,
modifier|*
name|ten
decl_stmt|;
name|unsigned
name|EMUSHORT
name|sign
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|expon
decl_stmt|,
name|rndsav
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|ss
decl_stmt|;
name|unsigned
name|EMUSHORT
name|m
decl_stmt|;
name|rndsav
operator|=
name|rndprc
expr_stmt|;
name|ss
operator|=
name|string
expr_stmt|;
name|s
operator|=
name|wstring
expr_stmt|;
operator|*
name|ss
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
ifdef|#
directive|ifdef
name|NANS
if|if
condition|(
name|eisnan
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|sprintf
argument_list|(
name|wstring
argument_list|,
literal|" NaN "
argument_list|)
expr_stmt|;
goto|goto
name|bxit
goto|;
block|}
endif|#
directive|endif
name|rndprc
operator|=
name|NBITS
expr_stmt|;
comment|/* set to full precision */
name|emov
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
comment|/* retain external format */
if|if
condition|(
name|y
index|[
name|NE
operator|-
literal|1
index|]
operator|&
literal|0x8000
condition|)
block|{
name|sign
operator|=
literal|0xffff
expr_stmt|;
name|y
index|[
name|NE
operator|-
literal|1
index|]
operator|&=
literal|0x7fff
expr_stmt|;
block|}
else|else
block|{
name|sign
operator|=
literal|0
expr_stmt|;
block|}
name|expon
operator|=
literal|0
expr_stmt|;
name|ten
operator|=
operator|&
name|etens
index|[
name|NTEN
index|]
index|[
literal|0
index|]
expr_stmt|;
name|emov
argument_list|(
name|eone
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* Test for zero exponent */
if|if
condition|(
name|y
index|[
name|NE
operator|-
literal|1
index|]
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|NE
operator|-
literal|1
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|y
index|[
name|k
index|]
operator|!=
literal|0
condition|)
goto|goto
name|tnzro
goto|;
comment|/* denormalized number */
block|}
goto|goto
name|isone
goto|;
comment|/* legal all zeros */
block|}
name|tnzro
label|:
comment|/* Test for infinity. */
if|if
condition|(
name|y
index|[
name|NE
operator|-
literal|1
index|]
operator|==
literal|0x7fff
condition|)
block|{
if|if
condition|(
name|sign
condition|)
name|sprintf
argument_list|(
name|wstring
argument_list|,
literal|" -Infinity "
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|wstring
argument_list|,
literal|" Infinity "
argument_list|)
expr_stmt|;
goto|goto
name|bxit
goto|;
block|}
comment|/* Test for exponent nonzero but significand denormalized.    * This is an error condition.    */
if|if
condition|(
operator|(
name|y
index|[
name|NE
operator|-
literal|1
index|]
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|y
index|[
name|NE
operator|-
literal|2
index|]
operator|&
literal|0x8000
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|mtherr
argument_list|(
literal|"etoasc"
argument_list|,
name|DOMAIN
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|wstring
argument_list|,
literal|"NaN"
argument_list|)
expr_stmt|;
goto|goto
name|bxit
goto|;
block|}
comment|/* Compare to 1.0 */
name|i
operator|=
name|ecmp
argument_list|(
name|eone
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
goto|goto
name|isone
goto|;
if|if
condition|(
name|i
operator|==
operator|-
literal|2
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
comment|/* Number is greater than 1 */
comment|/* Convert significand to an integer and strip trailing decimal zeros. */
name|emov
argument_list|(
name|y
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|u
index|[
name|NE
operator|-
literal|1
index|]
operator|=
name|EXONE
operator|+
name|NBITS
operator|-
literal|1
expr_stmt|;
name|p
operator|=
operator|&
name|etens
index|[
name|NTEN
operator|-
literal|4
index|]
index|[
literal|0
index|]
expr_stmt|;
name|m
operator|=
literal|16
expr_stmt|;
do|do
block|{
name|ediv
argument_list|(
name|p
argument_list|,
name|u
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|efloor
argument_list|(
name|t
argument_list|,
name|w
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NE
operator|-
literal|1
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|t
index|[
name|j
index|]
operator|!=
name|w
index|[
name|j
index|]
condition|)
goto|goto
name|noint
goto|;
block|}
name|emov
argument_list|(
name|t
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|expon
operator|+=
operator|(
name|int
operator|)
name|m
expr_stmt|;
name|noint
label|:
name|p
operator|+=
name|NE
expr_stmt|;
name|m
operator|>>=
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|m
operator|!=
literal|0
condition|)
do|;
comment|/* Rescale from integer significand */
name|u
index|[
name|NE
operator|-
literal|1
index|]
operator|+=
name|y
index|[
name|NE
operator|-
literal|1
index|]
operator|-
call|(
name|unsigned
name|int
call|)
argument_list|(
name|EXONE
operator|+
name|NBITS
operator|-
literal|1
argument_list|)
expr_stmt|;
name|emov
argument_list|(
name|u
argument_list|,
name|y
argument_list|)
expr_stmt|;
comment|/* Find power of 10 */
name|emov
argument_list|(
name|eone
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|m
operator|=
name|MAXP
expr_stmt|;
name|p
operator|=
operator|&
name|etens
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
comment|/* An unordered compare result shouldn't happen here. */
while|while
condition|(
name|ecmp
argument_list|(
name|ten
argument_list|,
name|u
argument_list|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|ecmp
argument_list|(
name|p
argument_list|,
name|u
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|ediv
argument_list|(
name|p
argument_list|,
name|u
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|emul
argument_list|(
name|p
argument_list|,
name|t
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|expon
operator|+=
operator|(
name|int
operator|)
name|m
expr_stmt|;
block|}
name|m
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
break|break;
name|p
operator|+=
name|NE
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Number is less than 1.0 */
comment|/* Pad significand with trailing decimal zeros. */
if|if
condition|(
name|y
index|[
name|NE
operator|-
literal|1
index|]
operator|==
literal|0
condition|)
block|{
while|while
condition|(
operator|(
name|y
index|[
name|NE
operator|-
literal|2
index|]
operator|&
literal|0x8000
operator|)
operator|==
literal|0
condition|)
block|{
name|emul
argument_list|(
name|ten
argument_list|,
name|y
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|expon
operator|-=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|emovi
argument_list|(
name|y
argument_list|,
name|w
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NDEC
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|w
index|[
name|NI
operator|-
literal|1
index|]
operator|&
literal|0x7
operator|)
operator|!=
literal|0
condition|)
break|break;
comment|/* multiply by 10 */
name|emovz
argument_list|(
name|w
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|eshdn1
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|eshdn1
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|eaddm
argument_list|(
name|w
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|u
index|[
literal|1
index|]
operator|+=
literal|3
expr_stmt|;
while|while
condition|(
name|u
index|[
literal|2
index|]
operator|!=
literal|0
condition|)
block|{
name|eshdn1
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|u
index|[
literal|1
index|]
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|u
index|[
name|NI
operator|-
literal|1
index|]
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|eone
index|[
name|NE
operator|-
literal|1
index|]
operator|<=
name|u
index|[
literal|1
index|]
condition|)
break|break;
name|emovz
argument_list|(
name|u
argument_list|,
name|w
argument_list|)
expr_stmt|;
name|expon
operator|-=
literal|1
expr_stmt|;
block|}
name|emovo
argument_list|(
name|w
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
name|k
operator|=
operator|-
name|MAXP
expr_stmt|;
name|p
operator|=
operator|&
name|emtens
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
name|r
operator|=
operator|&
name|etens
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
name|emov
argument_list|(
name|y
argument_list|,
name|w
argument_list|)
expr_stmt|;
name|emov
argument_list|(
name|eone
argument_list|,
name|t
argument_list|)
expr_stmt|;
while|while
condition|(
name|ecmp
argument_list|(
name|eone
argument_list|,
name|w
argument_list|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|ecmp
argument_list|(
name|p
argument_list|,
name|w
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|emul
argument_list|(
name|r
argument_list|,
name|w
argument_list|,
name|w
argument_list|)
expr_stmt|;
name|emul
argument_list|(
name|r
argument_list|,
name|t
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|expon
operator|+=
name|k
expr_stmt|;
block|}
name|k
operator|/=
literal|2
expr_stmt|;
if|if
condition|(
name|k
operator|==
literal|0
condition|)
break|break;
name|p
operator|+=
name|NE
expr_stmt|;
name|r
operator|+=
name|NE
expr_stmt|;
block|}
name|ediv
argument_list|(
name|t
argument_list|,
name|eone
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
name|isone
label|:
comment|/* Find the first (leading) digit. */
name|emovi
argument_list|(
name|t
argument_list|,
name|w
argument_list|)
expr_stmt|;
name|emovz
argument_list|(
name|w
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|emovi
argument_list|(
name|y
argument_list|,
name|w
argument_list|)
expr_stmt|;
name|emovz
argument_list|(
name|w
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|eiremain
argument_list|(
name|t
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|digit
operator|=
name|equot
index|[
name|NI
operator|-
literal|1
index|]
expr_stmt|;
while|while
condition|(
operator|(
name|digit
operator|==
literal|0
operator|)
operator|&&
operator|(
name|ecmp
argument_list|(
name|y
argument_list|,
name|ezero
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|eshup1
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|emovz
argument_list|(
name|y
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|eshup1
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|eshup1
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|eaddm
argument_list|(
name|u
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|eiremain
argument_list|(
name|t
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|digit
operator|=
name|equot
index|[
name|NI
operator|-
literal|1
index|]
expr_stmt|;
name|expon
operator|-=
literal|1
expr_stmt|;
block|}
name|s
operator|=
name|wstring
expr_stmt|;
if|if
condition|(
name|sign
condition|)
operator|*
name|s
operator|++
operator|=
literal|'-'
expr_stmt|;
else|else
operator|*
name|s
operator|++
operator|=
literal|' '
expr_stmt|;
comment|/* Examine number of digits requested by caller. */
if|if
condition|(
name|ndigs
operator|<
literal|0
condition|)
name|ndigs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ndigs
operator|>
name|NDEC
condition|)
name|ndigs
operator|=
name|NDEC
expr_stmt|;
if|if
condition|(
name|digit
operator|==
literal|10
condition|)
block|{
operator|*
name|s
operator|++
operator|=
literal|'1'
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|'.'
expr_stmt|;
if|if
condition|(
name|ndigs
operator|>
literal|0
condition|)
block|{
operator|*
name|s
operator|++
operator|=
literal|'0'
expr_stmt|;
name|ndigs
operator|-=
literal|1
expr_stmt|;
block|}
name|expon
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
operator|*
name|s
operator|++
operator|=
operator|(
name|char
operator|)
name|digit
operator|+
literal|'0'
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|'.'
expr_stmt|;
block|}
comment|/* Generate digits after the decimal point. */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<=
name|ndigs
condition|;
name|k
operator|++
control|)
block|{
comment|/* multiply current number by 10, without normalizing */
name|eshup1
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|emovz
argument_list|(
name|y
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|eshup1
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|eshup1
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|eaddm
argument_list|(
name|u
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|eiremain
argument_list|(
name|t
argument_list|,
name|y
argument_list|)
expr_stmt|;
operator|*
name|s
operator|++
operator|=
operator|(
name|char
operator|)
name|equot
index|[
name|NI
operator|-
literal|1
index|]
operator|+
literal|'0'
expr_stmt|;
block|}
name|digit
operator|=
name|equot
index|[
name|NI
operator|-
literal|1
index|]
expr_stmt|;
operator|--
name|s
expr_stmt|;
name|ss
operator|=
name|s
expr_stmt|;
comment|/* round off the ASCII string */
if|if
condition|(
name|digit
operator|>
literal|4
condition|)
block|{
comment|/* Test for critical rounding case in ASCII output. */
if|if
condition|(
name|digit
operator|==
literal|5
condition|)
block|{
name|emovo
argument_list|(
name|y
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecmp
argument_list|(
name|t
argument_list|,
name|ezero
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|roun
goto|;
comment|/* round to nearest */
if|if
condition|(
operator|(
operator|*
operator|(
name|s
operator|-
literal|1
operator|)
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
goto|goto
name|doexp
goto|;
comment|/* round to even */
block|}
comment|/* Round up and propagate carry-outs */
name|roun
label|:
operator|--
name|s
expr_stmt|;
name|k
operator|=
operator|*
name|s
operator|&
literal|0x7f
expr_stmt|;
comment|/* Carry out to most significant digit? */
if|if
condition|(
name|k
operator|==
literal|'.'
condition|)
block|{
operator|--
name|s
expr_stmt|;
name|k
operator|=
operator|*
name|s
expr_stmt|;
name|k
operator|+=
literal|1
expr_stmt|;
operator|*
name|s
operator|=
operator|(
name|char
operator|)
name|k
expr_stmt|;
comment|/* Most significant digit carries to 10? */
if|if
condition|(
name|k
operator|>
literal|'9'
condition|)
block|{
name|expon
operator|+=
literal|1
expr_stmt|;
operator|*
name|s
operator|=
literal|'1'
expr_stmt|;
block|}
goto|goto
name|doexp
goto|;
block|}
comment|/* Round up and carry out from less significant digits */
name|k
operator|+=
literal|1
expr_stmt|;
operator|*
name|s
operator|=
operator|(
name|char
operator|)
name|k
expr_stmt|;
if|if
condition|(
name|k
operator|>
literal|'9'
condition|)
block|{
operator|*
name|s
operator|=
literal|'0'
expr_stmt|;
goto|goto
name|roun
goto|;
block|}
block|}
name|doexp
label|:
comment|/*      if (expon>= 0)      sprintf (ss, "e+%d", expon);      else      sprintf (ss, "e%d", expon);      */
name|sprintf
argument_list|(
name|ss
argument_list|,
literal|"e%d"
argument_list|,
name|expon
argument_list|)
expr_stmt|;
name|bxit
label|:
name|rndprc
operator|=
name|rndsav
expr_stmt|;
comment|/* copy out the working string */
name|s
operator|=
name|string
expr_stmt|;
name|ss
operator|=
name|wstring
expr_stmt|;
while|while
condition|(
operator|*
name|ss
operator|==
literal|' '
condition|)
comment|/* strip possible leading space */
operator|++
name|ss
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|s
operator|++
operator|=
operator|*
name|ss
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
empty_stmt|;
block|}
end_function

begin_comment
comment|/* ;								ASCTOQ ;		ASCTOQ.MAC		LATEST REV: 11 JAN 84 ;					SLM, 3 JAN 78 ; ;	Convert ASCII string to quadruple precision floating point ; ;		Numeric input is free field decimal number ;		with max of 15 digits with or without ;		decimal point entered as ASCII from teletype. ;	Entering E after the number followed by a second ;	number causes the second number to be interpreted ;	as a power of 10 to be multiplied by the first number ;	(i.e., "scientific" notation). ; ;	Usage: ;		asctoq (string, q); */
end_comment

begin_comment
comment|/* ASCII to single */
end_comment

begin_function
name|void
name|asctoe24
parameter_list|(
name|s
parameter_list|,
name|y
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|unsigned
name|EMUSHORT
modifier|*
name|y
decl_stmt|;
block|{
name|asctoeg
argument_list|(
name|s
argument_list|,
name|y
argument_list|,
literal|24
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ASCII to double */
end_comment

begin_function
name|void
name|asctoe53
parameter_list|(
name|s
parameter_list|,
name|y
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|unsigned
name|EMUSHORT
modifier|*
name|y
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DEC
name|asctoeg
argument_list|(
name|s
argument_list|,
name|y
argument_list|,
literal|56
argument_list|)
expr_stmt|;
else|#
directive|else
name|asctoeg
argument_list|(
name|s
argument_list|,
name|y
argument_list|,
literal|53
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ASCII to long double */
end_comment

begin_function
name|void
name|asctoe64
parameter_list|(
name|s
parameter_list|,
name|y
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|unsigned
name|EMUSHORT
modifier|*
name|y
decl_stmt|;
block|{
name|asctoeg
argument_list|(
name|s
argument_list|,
name|y
argument_list|,
literal|64
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ASCII to super double */
end_comment

begin_function
name|void
name|asctoe
parameter_list|(
name|s
parameter_list|,
name|y
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|unsigned
name|EMUSHORT
modifier|*
name|y
decl_stmt|;
block|{
name|asctoeg
argument_list|(
name|s
argument_list|,
name|y
argument_list|,
name|NBITS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Space to make a copy of the input string: */
end_comment

begin_decl_stmt
specifier|static
name|char
name|lstr
index|[
literal|82
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|asctoeg
parameter_list|(
name|ss
parameter_list|,
name|y
parameter_list|,
name|oprec
parameter_list|)
name|char
modifier|*
name|ss
decl_stmt|;
name|unsigned
name|EMUSHORT
modifier|*
name|y
decl_stmt|;
name|int
name|oprec
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|yy
index|[
name|NI
index|]
decl_stmt|,
name|xt
index|[
name|NI
index|]
decl_stmt|,
name|tt
index|[
name|NI
index|]
decl_stmt|;
name|int
name|esign
decl_stmt|,
name|decflg
decl_stmt|,
name|sgnflg
decl_stmt|,
name|nexp
decl_stmt|,
name|exp
decl_stmt|,
name|prec
decl_stmt|,
name|lost
decl_stmt|;
name|int
name|k
decl_stmt|,
name|trail
decl_stmt|,
name|c
decl_stmt|,
name|rndsav
decl_stmt|;
name|EMULONG
name|lexp
decl_stmt|;
name|unsigned
name|EMUSHORT
name|nsign
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|sp
decl_stmt|,
modifier|*
name|s
decl_stmt|;
comment|/* Copy the input string. */
name|s
operator|=
name|ss
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|==
literal|' '
condition|)
comment|/* skip leading spaces */
operator|++
name|s
expr_stmt|;
name|sp
operator|=
name|lstr
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
literal|79
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|sp
operator|++
operator|=
operator|*
name|s
operator|++
operator|)
operator|==
literal|'\0'
condition|)
break|break;
block|}
operator|*
name|sp
operator|=
literal|'\0'
expr_stmt|;
name|s
operator|=
name|lstr
expr_stmt|;
name|rndsav
operator|=
name|rndprc
expr_stmt|;
name|rndprc
operator|=
name|NBITS
expr_stmt|;
comment|/* Set to full precision */
name|lost
operator|=
literal|0
expr_stmt|;
name|nsign
operator|=
literal|0
expr_stmt|;
name|decflg
operator|=
literal|0
expr_stmt|;
name|sgnflg
operator|=
literal|0
expr_stmt|;
name|nexp
operator|=
literal|0
expr_stmt|;
name|exp
operator|=
literal|0
expr_stmt|;
name|prec
operator|=
literal|0
expr_stmt|;
name|ecleaz
argument_list|(
name|yy
argument_list|)
expr_stmt|;
name|trail
operator|=
literal|0
expr_stmt|;
name|nxtcom
label|:
name|k
operator|=
operator|*
name|s
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
operator|(
name|k
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|k
operator|<=
literal|9
operator|)
condition|)
block|{
comment|/* Ignore leading zeros */
if|if
condition|(
operator|(
name|prec
operator|==
literal|0
operator|)
operator|&&
operator|(
name|decflg
operator|==
literal|0
operator|)
operator|&&
operator|(
name|k
operator|==
literal|0
operator|)
condition|)
goto|goto
name|donchr
goto|;
comment|/* Identify and strip trailing zeros after the decimal point. */
if|if
condition|(
operator|(
name|trail
operator|==
literal|0
operator|)
operator|&&
operator|(
name|decflg
operator|!=
literal|0
operator|)
condition|)
block|{
name|sp
operator|=
name|s
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|sp
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
operator|*
name|sp
operator|<=
literal|'9'
operator|)
condition|)
operator|++
name|sp
expr_stmt|;
comment|/* Check for syntax error */
name|c
operator|=
operator|*
name|sp
operator|&
literal|0x7f
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|!=
literal|'e'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'E'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'\0'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'\n'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'\r'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|' '
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|','
operator|)
condition|)
goto|goto
name|error
goto|;
operator|--
name|sp
expr_stmt|;
while|while
condition|(
operator|*
name|sp
operator|==
literal|'0'
condition|)
operator|*
name|sp
operator|--
operator|=
literal|'z'
expr_stmt|;
name|trail
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'z'
condition|)
goto|goto
name|donchr
goto|;
block|}
comment|/* If enough digits were given to more than fill up the yy register,        * continuing until overflow into the high guard word yy[2]        * guarantees that there will be a roundoff bit at the top        * of the low guard word after normalization.        */
if|if
condition|(
name|yy
index|[
literal|2
index|]
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|decflg
condition|)
name|nexp
operator|+=
literal|1
expr_stmt|;
comment|/* count digits after decimal point */
name|eshup1
argument_list|(
name|yy
argument_list|)
expr_stmt|;
comment|/* multiply current number by 10 */
name|emovz
argument_list|(
name|yy
argument_list|,
name|xt
argument_list|)
expr_stmt|;
name|eshup1
argument_list|(
name|xt
argument_list|)
expr_stmt|;
name|eshup1
argument_list|(
name|xt
argument_list|)
expr_stmt|;
name|eaddm
argument_list|(
name|xt
argument_list|,
name|yy
argument_list|)
expr_stmt|;
name|ecleaz
argument_list|(
name|xt
argument_list|)
expr_stmt|;
name|xt
index|[
name|NI
operator|-
literal|2
index|]
operator|=
operator|(
name|unsigned
name|EMUSHORT
operator|)
name|k
expr_stmt|;
name|eaddm
argument_list|(
name|xt
argument_list|,
name|yy
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lost
operator||=
name|k
expr_stmt|;
block|}
name|prec
operator|+=
literal|1
expr_stmt|;
goto|goto
name|donchr
goto|;
block|}
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'z'
case|:
break|break;
case|case
literal|'E'
case|:
case|case
literal|'e'
case|:
goto|goto
name|expnt
goto|;
case|case
literal|'.'
case|:
comment|/* decimal point */
if|if
condition|(
name|decflg
condition|)
goto|goto
name|error
goto|;
operator|++
name|decflg
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
name|nsign
operator|=
literal|0xffff
expr_stmt|;
if|if
condition|(
name|sgnflg
condition|)
goto|goto
name|error
goto|;
operator|++
name|sgnflg
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
if|if
condition|(
name|sgnflg
condition|)
goto|goto
name|error
goto|;
operator|++
name|sgnflg
expr_stmt|;
break|break;
case|case
literal|','
case|:
case|case
literal|' '
case|:
case|case
literal|'\0'
case|:
case|case
literal|'\n'
case|:
case|case
literal|'\r'
case|:
goto|goto
name|daldone
goto|;
case|case
literal|'i'
case|:
case|case
literal|'I'
case|:
goto|goto
name|infinite
goto|;
default|default:
name|error
label|:
ifdef|#
directive|ifdef
name|NANS
name|einan
argument_list|(
name|yy
argument_list|)
expr_stmt|;
else|#
directive|else
name|mtherr
argument_list|(
literal|"asctoe"
argument_list|,
name|DOMAIN
argument_list|)
expr_stmt|;
name|eclear
argument_list|(
name|yy
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|aexit
goto|;
block|}
name|donchr
label|:
operator|++
name|s
expr_stmt|;
goto|goto
name|nxtcom
goto|;
comment|/* Exponent interpretation */
name|expnt
label|:
name|esign
operator|=
literal|1
expr_stmt|;
name|exp
operator|=
literal|0
expr_stmt|;
operator|++
name|s
expr_stmt|;
comment|/* check for + or - */
if|if
condition|(
operator|*
name|s
operator|==
literal|'-'
condition|)
block|{
name|esign
operator|=
operator|-
literal|1
expr_stmt|;
operator|++
name|s
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|'+'
condition|)
operator|++
name|s
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|s
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
operator|*
name|s
operator|<=
literal|'9'
operator|)
condition|)
block|{
name|exp
operator|*=
literal|10
expr_stmt|;
name|exp
operator|+=
operator|*
name|s
operator|++
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|exp
operator|>
literal|4956
condition|)
block|{
if|if
condition|(
name|esign
operator|<
literal|0
condition|)
goto|goto
name|zero
goto|;
else|else
goto|goto
name|infinite
goto|;
block|}
block|}
if|if
condition|(
name|esign
operator|<
literal|0
condition|)
name|exp
operator|=
operator|-
name|exp
expr_stmt|;
if|if
condition|(
name|exp
operator|>
literal|4932
condition|)
block|{
name|infinite
label|:
name|ecleaz
argument_list|(
name|yy
argument_list|)
expr_stmt|;
name|yy
index|[
name|E
index|]
operator|=
literal|0x7fff
expr_stmt|;
comment|/* infinity */
goto|goto
name|aexit
goto|;
block|}
if|if
condition|(
name|exp
operator|<
operator|-
literal|4956
condition|)
block|{
name|zero
label|:
name|ecleaz
argument_list|(
name|yy
argument_list|)
expr_stmt|;
goto|goto
name|aexit
goto|;
block|}
name|daldone
label|:
name|nexp
operator|=
name|exp
operator|-
name|nexp
expr_stmt|;
comment|/* Pad trailing zeros to minimize power of 10, per IEEE spec. */
while|while
condition|(
operator|(
name|nexp
operator|>
literal|0
operator|)
operator|&&
operator|(
name|yy
index|[
literal|2
index|]
operator|==
literal|0
operator|)
condition|)
block|{
name|emovz
argument_list|(
name|yy
argument_list|,
name|xt
argument_list|)
expr_stmt|;
name|eshup1
argument_list|(
name|xt
argument_list|)
expr_stmt|;
name|eshup1
argument_list|(
name|xt
argument_list|)
expr_stmt|;
name|eaddm
argument_list|(
name|yy
argument_list|,
name|xt
argument_list|)
expr_stmt|;
name|eshup1
argument_list|(
name|xt
argument_list|)
expr_stmt|;
if|if
condition|(
name|xt
index|[
literal|2
index|]
operator|!=
literal|0
condition|)
break|break;
name|nexp
operator|-=
literal|1
expr_stmt|;
name|emovz
argument_list|(
name|xt
argument_list|,
name|yy
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|k
operator|=
name|enormlz
argument_list|(
name|yy
argument_list|)
operator|)
operator|>
name|NBITS
condition|)
block|{
name|ecleaz
argument_list|(
name|yy
argument_list|)
expr_stmt|;
goto|goto
name|aexit
goto|;
block|}
name|lexp
operator|=
operator|(
name|EXONE
operator|-
literal|1
operator|+
name|NBITS
operator|)
operator|-
name|k
expr_stmt|;
name|emdnorm
argument_list|(
name|yy
argument_list|,
name|lost
argument_list|,
literal|0
argument_list|,
name|lexp
argument_list|,
literal|64
argument_list|)
expr_stmt|;
comment|/* convert to external format */
comment|/* Multiply by 10**nexp.  If precision is 64 bits,    * the maximum relative error incurred in forming 10**n    * for 0<= n<= 324 is 8.2e-20, at 10**180.    * For 0<= n<= 999, the peak relative error is 1.4e-19 at 10**947.    * For 0>= n>= -999, it is -1.55e-19 at 10**-435.    */
name|lexp
operator|=
name|yy
index|[
name|E
index|]
expr_stmt|;
if|if
condition|(
name|nexp
operator|==
literal|0
condition|)
block|{
name|k
operator|=
literal|0
expr_stmt|;
goto|goto
name|expdon
goto|;
block|}
name|esign
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|nexp
operator|<
literal|0
condition|)
block|{
name|nexp
operator|=
operator|-
name|nexp
expr_stmt|;
name|esign
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|nexp
operator|>
literal|4096
condition|)
block|{
comment|/* Punt.  Can't handle this without 2 divides. */
name|emovi
argument_list|(
name|etens
index|[
literal|0
index|]
argument_list|,
name|tt
argument_list|)
expr_stmt|;
name|lexp
operator|-=
name|tt
index|[
name|E
index|]
expr_stmt|;
name|k
operator|=
name|edivm
argument_list|(
name|tt
argument_list|,
name|yy
argument_list|)
expr_stmt|;
name|lexp
operator|+=
name|EXONE
expr_stmt|;
name|nexp
operator|-=
literal|4096
expr_stmt|;
block|}
block|}
name|p
operator|=
operator|&
name|etens
index|[
name|NTEN
index|]
index|[
literal|0
index|]
expr_stmt|;
name|emov
argument_list|(
name|eone
argument_list|,
name|xt
argument_list|)
expr_stmt|;
name|exp
operator|=
literal|1
expr_stmt|;
do|do
block|{
if|if
condition|(
name|exp
operator|&
name|nexp
condition|)
name|emul
argument_list|(
name|p
argument_list|,
name|xt
argument_list|,
name|xt
argument_list|)
expr_stmt|;
name|p
operator|-=
name|NE
expr_stmt|;
name|exp
operator|=
name|exp
operator|+
name|exp
expr_stmt|;
block|}
do|while
condition|(
name|exp
operator|<=
name|MAXP
condition|)
do|;
name|emovi
argument_list|(
name|xt
argument_list|,
name|tt
argument_list|)
expr_stmt|;
if|if
condition|(
name|esign
operator|<
literal|0
condition|)
block|{
name|lexp
operator|-=
name|tt
index|[
name|E
index|]
expr_stmt|;
name|k
operator|=
name|edivm
argument_list|(
name|tt
argument_list|,
name|yy
argument_list|)
expr_stmt|;
name|lexp
operator|+=
name|EXONE
expr_stmt|;
block|}
else|else
block|{
name|lexp
operator|+=
name|tt
index|[
name|E
index|]
expr_stmt|;
name|k
operator|=
name|emulm
argument_list|(
name|tt
argument_list|,
name|yy
argument_list|)
expr_stmt|;
name|lexp
operator|-=
name|EXONE
operator|-
literal|1
expr_stmt|;
block|}
name|expdon
label|:
comment|/* Round and convert directly to the destination type */
if|if
condition|(
name|oprec
operator|==
literal|53
condition|)
name|lexp
operator|-=
name|EXONE
operator|-
literal|0x3ff
expr_stmt|;
elseif|else
if|if
condition|(
name|oprec
operator|==
literal|24
condition|)
name|lexp
operator|-=
name|EXONE
operator|-
literal|0177
expr_stmt|;
ifdef|#
directive|ifdef
name|DEC
elseif|else
if|if
condition|(
name|oprec
operator|==
literal|56
condition|)
name|lexp
operator|-=
name|EXONE
operator|-
literal|0201
expr_stmt|;
endif|#
directive|endif
name|rndprc
operator|=
name|oprec
expr_stmt|;
name|emdnorm
argument_list|(
name|yy
argument_list|,
name|k
argument_list|,
literal|0
argument_list|,
name|lexp
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|aexit
label|:
name|rndprc
operator|=
name|rndsav
expr_stmt|;
name|yy
index|[
literal|0
index|]
operator|=
name|nsign
expr_stmt|;
switch|switch
condition|(
name|oprec
condition|)
block|{
ifdef|#
directive|ifdef
name|DEC
case|case
literal|56
case|:
name|todec
argument_list|(
name|yy
argument_list|,
name|y
argument_list|)
expr_stmt|;
comment|/* see etodec.c */
break|break;
endif|#
directive|endif
case|case
literal|53
case|:
name|toe53
argument_list|(
name|yy
argument_list|,
name|y
argument_list|)
expr_stmt|;
break|break;
case|case
literal|24
case|:
name|toe24
argument_list|(
name|yy
argument_list|,
name|y
argument_list|)
expr_stmt|;
break|break;
case|case
literal|64
case|:
name|toe64
argument_list|(
name|yy
argument_list|,
name|y
argument_list|)
expr_stmt|;
break|break;
case|case
name|NBITS
case|:
name|emovo
argument_list|(
name|yy
argument_list|,
name|y
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* y = largest integer not greater than x  * (truncated toward minus infinity)  *  * unsigned EMUSHORT x[NE], y[NE]  *  * efloor (x, y);  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|EMUSHORT
name|bmask
index|[]
init|=
block|{
literal|0xffff
block|,
literal|0xfffe
block|,
literal|0xfffc
block|,
literal|0xfff8
block|,
literal|0xfff0
block|,
literal|0xffe0
block|,
literal|0xffc0
block|,
literal|0xff80
block|,
literal|0xff00
block|,
literal|0xfe00
block|,
literal|0xfc00
block|,
literal|0xf800
block|,
literal|0xf000
block|,
literal|0xe000
block|,
literal|0xc000
block|,
literal|0x8000
block|,
literal|0x0000
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|efloor
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
name|unsigned
name|EMUSHORT
name|x
index|[]
decl_stmt|,
name|y
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|unsigned
name|EMUSHORT
modifier|*
name|p
decl_stmt|;
name|int
name|e
decl_stmt|,
name|expon
decl_stmt|,
name|i
decl_stmt|;
name|unsigned
name|EMUSHORT
name|f
index|[
name|NE
index|]
decl_stmt|;
name|emov
argument_list|(
name|x
argument_list|,
name|f
argument_list|)
expr_stmt|;
comment|/* leave in external format */
name|expon
operator|=
operator|(
name|int
operator|)
name|f
index|[
name|NE
operator|-
literal|1
index|]
expr_stmt|;
name|e
operator|=
operator|(
name|expon
operator|&
literal|0x7fff
operator|)
operator|-
operator|(
name|EXONE
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|e
operator|<=
literal|0
condition|)
block|{
name|eclear
argument_list|(
name|y
argument_list|)
expr_stmt|;
goto|goto
name|isitneg
goto|;
block|}
comment|/* number of bits to clear out */
name|e
operator|=
name|NBITS
operator|-
name|e
expr_stmt|;
name|emov
argument_list|(
name|f
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|<=
literal|0
condition|)
return|return;
name|p
operator|=
operator|&
name|y
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
name|e
operator|>=
literal|16
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
name|e
operator|-=
literal|16
expr_stmt|;
block|}
comment|/* clear the remaining bits */
operator|*
name|p
operator|&=
name|bmask
index|[
name|e
index|]
expr_stmt|;
comment|/* truncate negatives toward minus infinity */
name|isitneg
label|:
if|if
condition|(
operator|(
name|unsigned
name|EMUSHORT
operator|)
name|expon
operator|&
operator|(
name|unsigned
name|EMUSHORT
operator|)
literal|0x8000
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NE
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|f
index|[
name|i
index|]
operator|!=
name|y
index|[
name|i
index|]
condition|)
block|{
name|esub
argument_list|(
name|eone
argument_list|,
name|y
argument_list|,
name|y
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_block

begin_comment
comment|/* unsigned EMUSHORT x[], s[];  * int *exp;  *  * efrexp (x, exp, s);  *  * Returns s and exp such that  s * 2**exp = x and .5<= s< 1.  * For example, 1.1 = 0.55 * 2**1  * Handles denormalized numbers properly using long integer exp.  */
end_comment

begin_function
name|void
name|efrexp
parameter_list|(
name|x
parameter_list|,
name|exp
parameter_list|,
name|s
parameter_list|)
name|unsigned
name|EMUSHORT
name|x
index|[]
decl_stmt|;
name|int
modifier|*
name|exp
decl_stmt|;
name|unsigned
name|EMUSHORT
name|s
index|[]
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|xi
index|[
name|NI
index|]
decl_stmt|;
name|EMULONG
name|li
decl_stmt|;
name|emovi
argument_list|(
name|x
argument_list|,
name|xi
argument_list|)
expr_stmt|;
name|li
operator|=
call|(
name|EMULONG
call|)
argument_list|(
operator|(
name|EMUSHORT
operator|)
name|xi
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|li
operator|==
literal|0
condition|)
block|{
name|li
operator|-=
name|enormlz
argument_list|(
name|xi
argument_list|)
expr_stmt|;
block|}
name|xi
index|[
literal|1
index|]
operator|=
literal|0x3ffe
expr_stmt|;
name|emovo
argument_list|(
name|xi
argument_list|,
name|s
argument_list|)
expr_stmt|;
operator|*
name|exp
operator|=
call|(
name|int
call|)
argument_list|(
name|li
operator|-
literal|0x3ffe
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* unsigned EMUSHORT x[], y[];  * long pwr2;  *  * eldexp (x, pwr2, y);  *  * Returns y = x * 2**pwr2.  */
end_comment

begin_function
name|void
name|eldexp
parameter_list|(
name|x
parameter_list|,
name|pwr2
parameter_list|,
name|y
parameter_list|)
name|unsigned
name|EMUSHORT
name|x
index|[]
decl_stmt|;
name|int
name|pwr2
decl_stmt|;
name|unsigned
name|EMUSHORT
name|y
index|[]
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|xi
index|[
name|NI
index|]
decl_stmt|;
name|EMULONG
name|li
decl_stmt|;
name|int
name|i
decl_stmt|;
name|emovi
argument_list|(
name|x
argument_list|,
name|xi
argument_list|)
expr_stmt|;
name|li
operator|=
name|xi
index|[
literal|1
index|]
expr_stmt|;
name|li
operator|+=
name|pwr2
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|emdnorm
argument_list|(
name|xi
argument_list|,
name|i
argument_list|,
name|i
argument_list|,
name|li
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|emovo
argument_list|(
name|xi
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* c = remainder after dividing b by a  * Least significant integer quotient bits left in equot[].  */
end_comment

begin_decl_stmt
name|void
name|eremain
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|)
name|unsigned
name|EMUSHORT
name|a
index|[]
decl_stmt|,
name|b
index|[]
decl_stmt|,
name|c
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|unsigned
name|EMUSHORT
name|den
index|[
name|NI
index|]
decl_stmt|,
name|num
index|[
name|NI
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|NANS
if|if
condition|(
name|eisinf
argument_list|(
name|b
argument_list|)
operator|||
operator|(
name|ecmp
argument_list|(
name|a
argument_list|,
name|ezero
argument_list|)
operator|==
literal|0
operator|)
operator|||
name|eisnan
argument_list|(
name|a
argument_list|)
operator|||
name|eisnan
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|enan
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
if|if
condition|(
name|ecmp
argument_list|(
name|a
argument_list|,
name|ezero
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mtherr
argument_list|(
literal|"eremain"
argument_list|,
name|SING
argument_list|)
expr_stmt|;
name|eclear
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
name|emovi
argument_list|(
name|a
argument_list|,
name|den
argument_list|)
expr_stmt|;
name|emovi
argument_list|(
name|b
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|eiremain
argument_list|(
name|den
argument_list|,
name|num
argument_list|)
expr_stmt|;
comment|/* Sign of remainder = sign of quotient */
if|if
condition|(
name|a
index|[
literal|0
index|]
operator|==
name|b
index|[
literal|0
index|]
condition|)
name|num
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
else|else
name|num
index|[
literal|0
index|]
operator|=
literal|0xffff
expr_stmt|;
name|emovo
argument_list|(
name|num
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|void
name|eiremain
argument_list|(
name|den
argument_list|,
name|num
argument_list|)
name|unsigned
name|EMUSHORT
name|den
index|[]
decl_stmt|,
name|num
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|EMULONG
name|ld
decl_stmt|,
name|ln
decl_stmt|;
name|unsigned
name|EMUSHORT
name|j
decl_stmt|;
name|ld
operator|=
name|den
index|[
name|E
index|]
expr_stmt|;
name|ld
operator|-=
name|enormlz
argument_list|(
name|den
argument_list|)
expr_stmt|;
name|ln
operator|=
name|num
index|[
name|E
index|]
expr_stmt|;
name|ln
operator|-=
name|enormlz
argument_list|(
name|num
argument_list|)
expr_stmt|;
name|ecleaz
argument_list|(
name|equot
argument_list|)
expr_stmt|;
while|while
condition|(
name|ln
operator|>=
name|ld
condition|)
block|{
if|if
condition|(
name|ecmpm
argument_list|(
name|den
argument_list|,
name|num
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|esubm
argument_list|(
name|den
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|j
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|j
operator|=
literal|0
expr_stmt|;
block|}
name|eshup1
argument_list|(
name|equot
argument_list|)
expr_stmt|;
name|equot
index|[
name|NI
operator|-
literal|1
index|]
operator||=
name|j
expr_stmt|;
name|eshup1
argument_list|(
name|num
argument_list|)
expr_stmt|;
name|ln
operator|-=
literal|1
expr_stmt|;
block|}
name|emdnorm
argument_list|(
name|num
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|ln
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*							mtherr.c  *  *	Library common error handling routine  *  *  *  * SYNOPSIS:  *  * char *fctnam;  * int code;  * void mtherr ();  *  * mtherr (fctnam, code);  *  *  *  * DESCRIPTION:  *  * This routine may be called to report one of the following  * error conditions (in the include file mconf.h).  *  *   Mnemonic        Value          Significance  *  *    DOMAIN            1       argument domain error  *    SING              2       function singularity  *    OVERFLOW          3       overflow range error  *    UNDERFLOW         4       underflow range error  *    TLOSS             5       total loss of precision  *    PLOSS             6       partial loss of precision  *    INVALID           7       NaN - producing operation  *    EDOM             33       Unix domain error code  *    ERANGE           34       Unix range error code  *  * The default version of the file prints the function name,  * passed to it by the pointer fctnam, followed by the  * error condition.  The display is directed to the standard  * output device.  The routine then returns to the calling  * program.  Users may wish to modify the program to abort by  * calling exit under severe error conditions such as domain  * errors.  *  * Since all error conditions pass control to this function,  * the display may be easily changed, eliminated, or directed  * to an error logging device.  *  * SEE ALSO:  *  * mconf.h  *  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Cephes Math Library Release 2.0:  April, 1987 Copyright 1984, 1987 by Stephen L. Moshier Direct inquiries to 30 Frost Street, Cambridge, MA 02140 */
end_comment

begin_comment
comment|/* include "mconf.h" */
end_comment

begin_comment
comment|/* Notice: the order of appearance of the following  * messages is bound to the error codes defined  * in mconf.h.  */
end_comment

begin_define
define|#
directive|define
name|NMSGS
value|8
end_define

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ermsg
index|[
name|NMSGS
index|]
init|=
block|{
literal|"unknown"
block|,
comment|/* error code 0 */
literal|"domain"
block|,
comment|/* error code 1 */
literal|"singularity"
block|,
comment|/* et seq.      */
literal|"overflow"
block|,
literal|"underflow"
block|,
literal|"total loss of precision"
block|,
literal|"partial loss of precision"
block|,
literal|"invalid operation"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|merror
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|merror
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|mtherr
parameter_list|(
name|name
parameter_list|,
name|code
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|code
decl_stmt|;
block|{
name|char
name|errstr
index|[
literal|80
index|]
decl_stmt|;
comment|/* Display string passed by calling program,    * which is supposed to be the name of the    * function in which the error occurred.    */
comment|/* Display error message defined    * by the code argument.    */
if|if
condition|(
operator|(
name|code
operator|<=
literal|0
operator|)
operator|||
operator|(
name|code
operator|>=
name|NMSGS
operator|)
condition|)
name|code
operator|=
literal|0
expr_stmt|;
name|sprintf
argument_list|(
name|errstr
argument_list|,
literal|" %s %s error"
argument_list|,
name|name
argument_list|,
name|ermsg
index|[
name|code
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|extra_warnings
condition|)
name|warning
argument_list|(
name|errstr
argument_list|)
expr_stmt|;
comment|/* Set global error message word */
name|merror
operator|=
name|code
operator|+
literal|1
expr_stmt|;
comment|/* Return to calling    * program    */
block|}
end_function

begin_comment
comment|/* Here is etodec.c .  *  */
end_comment

begin_comment
comment|/* ;	convert DEC double precision to e type ;	double d; ;	EMUSHORT e[NE]; ;	dectoe (&d, e); */
end_comment

begin_function
name|void
name|dectoe
parameter_list|(
name|d
parameter_list|,
name|e
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|d
decl_stmt|;
name|unsigned
name|EMUSHORT
modifier|*
name|e
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|y
index|[
name|NI
index|]
decl_stmt|;
specifier|register
name|unsigned
name|EMUSHORT
name|r
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|ecleaz
argument_list|(
name|y
argument_list|)
expr_stmt|;
comment|/* start with a zero */
name|p
operator|=
name|y
expr_stmt|;
comment|/* point to our number */
name|r
operator|=
operator|*
name|d
expr_stmt|;
comment|/* get DEC exponent word */
if|if
condition|(
operator|*
name|d
operator|&
operator|(
name|unsigned
name|int
operator|)
literal|0x8000
condition|)
operator|*
name|p
operator|=
literal|0xffff
expr_stmt|;
comment|/* fill in our sign */
operator|++
name|p
expr_stmt|;
comment|/* bump pointer to our exponent word */
name|r
operator|&=
literal|0x7fff
expr_stmt|;
comment|/* strip the sign bit */
if|if
condition|(
name|r
operator|==
literal|0
condition|)
comment|/* answer = 0 if high order DEC word = 0 */
goto|goto
name|done
goto|;
name|r
operator|>>=
literal|7
expr_stmt|;
comment|/* shift exponent word down 7 bits */
name|r
operator|+=
name|EXONE
operator|-
literal|0201
expr_stmt|;
comment|/* subtract DEC exponent offset */
comment|/* add our e type exponent offset */
operator|*
name|p
operator|++
operator|=
name|r
expr_stmt|;
comment|/* to form our exponent */
name|r
operator|=
operator|*
name|d
operator|++
expr_stmt|;
comment|/* now do the high order mantissa */
name|r
operator|&=
literal|0177
expr_stmt|;
comment|/* strip off the DEC exponent and sign bits */
name|r
operator||=
literal|0200
expr_stmt|;
comment|/* the DEC understood high order mantissa bit */
operator|*
name|p
operator|++
operator|=
name|r
expr_stmt|;
comment|/* put result in our high guard word */
operator|*
name|p
operator|++
operator|=
operator|*
name|d
operator|++
expr_stmt|;
comment|/* fill in the rest of our mantissa */
operator|*
name|p
operator|++
operator|=
operator|*
name|d
operator|++
expr_stmt|;
operator|*
name|p
operator|=
operator|*
name|d
expr_stmt|;
name|eshdn8
argument_list|(
name|y
argument_list|)
expr_stmt|;
comment|/* shift our mantissa down 8 bits */
name|done
label|:
name|emovo
argument_list|(
name|y
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ;	convert e type to DEC double precision ;	double d; ;	EMUSHORT e[NE]; ;	etodec (e,&d); */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|static unsigned EMUSHORT decbit[NI] = {0, 0, 0, 0, 0, 0, 0200, 0};  void  etodec (x, d)      unsigned EMUSHORT *x, *d; {   unsigned EMUSHORT xi[NI];   register unsigned EMUSHORT r;   int i, j;    emovi (x, xi);   *d = 0;   if (xi[0] != 0)     *d = 0100000;   r = xi[E];   if (r< (EXONE - 128))     goto zout;   i = xi[M + 4];   if ((i& 0200) != 0)     {       if ((i& 0377) == 0200) 	{ 	  if ((i& 0400) != 0) 	    {
comment|/* check all less significant bits */
end_comment

begin_else
unit|for (j = M + 5; j< NI; j++) 		{ 		  if (xi[j] != 0) 		    goto yesrnd; 		} 	    } 	  goto nornd; 	}     yesrnd:       eaddm (decbit, xi);       r -= enormlz (xi);     }   nornd:    r -= EXONE;   r += 0201;   if (r< 0)     {     zout:       *d++ = 0;       *d++ = 0;       *d++ = 0;       *d++ = 0;       return;     }   if (r>= 0377)     {       *d++ = 077777;       *d++ = -1;       *d++ = -1;       *d++ = -1;       return;     }   r&= 0377;   r<<= 7;   eshup8 (xi);   xi[M]&= 0177;   r |= xi[M];   *d++ |= r;   *d++ = xi[M + 1];   *d++ = xi[M + 2];   *d++ = xi[M + 3]; }
else|#
directive|else
end_else

begin_function
name|void
name|etodec
parameter_list|(
name|x
parameter_list|,
name|d
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|,
decl|*
name|d
decl_stmt|;
end_function

begin_block
block|{
name|unsigned
name|EMUSHORT
name|xi
index|[
name|NI
index|]
decl_stmt|;
name|EMULONG
name|exp
decl_stmt|;
name|int
name|rndsav
decl_stmt|;
name|emovi
argument_list|(
name|x
argument_list|,
name|xi
argument_list|)
expr_stmt|;
name|exp
operator|=
operator|(
name|EMULONG
operator|)
name|xi
index|[
name|E
index|]
operator|-
operator|(
name|EXONE
operator|-
literal|0201
operator|)
expr_stmt|;
comment|/* adjust exponent for offsets */
comment|/* round off to nearest or even */
name|rndsav
operator|=
name|rndprc
expr_stmt|;
name|rndprc
operator|=
literal|56
expr_stmt|;
name|emdnorm
argument_list|(
name|xi
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|exp
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|rndprc
operator|=
name|rndsav
expr_stmt|;
name|todec
argument_list|(
name|xi
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|void
name|todec
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|,
decl|*
name|y
decl_stmt|;
end_function

begin_block
block|{
name|unsigned
name|EMUSHORT
name|i
decl_stmt|;
name|unsigned
name|EMUSHORT
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|x
expr_stmt|;
operator|*
name|y
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
condition|)
operator|*
name|y
operator|=
literal|0100000
expr_stmt|;
name|i
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
operator|*
name|y
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|y
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|y
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|y
operator|++
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|i
operator|>
literal|0377
condition|)
block|{
operator|*
name|y
operator|++
operator||=
literal|077777
expr_stmt|;
operator|*
name|y
operator|++
operator|=
literal|0xffff
expr_stmt|;
operator|*
name|y
operator|++
operator|=
literal|0xffff
expr_stmt|;
operator|*
name|y
operator|++
operator|=
literal|0xffff
expr_stmt|;
ifdef|#
directive|ifdef
name|ERANGE
name|errno
operator|=
name|ERANGE
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
name|i
operator|&=
literal|0377
expr_stmt|;
name|i
operator|<<=
literal|7
expr_stmt|;
name|eshup8
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|x
index|[
name|M
index|]
operator|&=
literal|0177
expr_stmt|;
name|i
operator||=
name|x
index|[
name|M
index|]
expr_stmt|;
operator|*
name|y
operator|++
operator||=
name|i
expr_stmt|;
operator|*
name|y
operator|++
operator|=
name|x
index|[
name|M
operator|+
literal|1
index|]
expr_stmt|;
operator|*
name|y
operator|++
operator|=
name|x
index|[
name|M
operator|+
literal|2
index|]
expr_stmt|;
operator|*
name|y
operator|++
operator|=
name|x
index|[
name|M
operator|+
literal|3
index|]
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not 0 */
end_comment

begin_comment
comment|/* Output a binary NaN bit pattern in the target machine's format.  */
end_comment

begin_comment
comment|/* If special NaN bit patterns are required, define them in tm.h    as arrays of unsigned 16-bit shorts.  Otherwise, use the default    patterns here. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TFMODE_NAN
end_ifdef

begin_expr_stmt
name|TFMODE_NAN
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|MIEEE
end_ifdef

begin_decl_stmt
name|unsigned
name|EMUSHORT
name|TFnan
index|[
literal|8
index|]
init|=
block|{
literal|0x7fff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|IBMPC
end_ifdef

begin_decl_stmt
name|unsigned
name|EMUSHORT
name|TFnan
index|[
literal|8
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0x8000
block|,
literal|0xffff
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|XFMODE_NAN
end_ifdef

begin_expr_stmt
name|XFMODE_NAN
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|MIEEE
end_ifdef

begin_decl_stmt
name|unsigned
name|EMUSHORT
name|XFnan
index|[
literal|6
index|]
init|=
block|{
literal|0x7fff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|IBMPC
end_ifdef

begin_decl_stmt
name|unsigned
name|EMUSHORT
name|XFnan
index|[
literal|6
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0xc000
block|,
literal|0xffff
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DFMODE_NAN
end_ifdef

begin_expr_stmt
name|DFMODE_NAN
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|MIEEE
end_ifdef

begin_decl_stmt
name|unsigned
name|EMUSHORT
name|DFnan
index|[
literal|4
index|]
init|=
block|{
literal|0x7fff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|IBMPC
end_ifdef

begin_decl_stmt
name|unsigned
name|EMUSHORT
name|DFnan
index|[
literal|4
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0xfff8
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SFMODE_NAN
end_ifdef

begin_expr_stmt
name|SFMODE_NAN
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|MIEEE
end_ifdef

begin_decl_stmt
name|unsigned
name|EMUSHORT
name|SFnan
index|[
literal|2
index|]
init|=
block|{
literal|0x7fff
block|,
literal|0xffff
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|IBMPC
end_ifdef

begin_decl_stmt
name|unsigned
name|EMUSHORT
name|SFnan
index|[
literal|2
index|]
init|=
block|{
literal|0
block|,
literal|0xffc0
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|make_nan
parameter_list|(
name|nan
parameter_list|,
name|mode
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|nan
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|unsigned
name|EMUSHORT
modifier|*
name|p
decl_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
comment|/* Possibly the `reserved operand' patterns on a VAX can be    used like NaN's, but probably not in the same way as IEEE. */
ifndef|#
directive|ifndef
name|DEC
case|case
name|TFmode
case|:
name|n
operator|=
literal|8
expr_stmt|;
name|p
operator|=
name|TFnan
expr_stmt|;
break|break;
case|case
name|XFmode
case|:
name|n
operator|=
literal|6
expr_stmt|;
name|p
operator|=
name|XFnan
expr_stmt|;
break|break;
case|case
name|DFmode
case|:
name|n
operator|=
literal|4
expr_stmt|;
name|p
operator|=
name|DFnan
expr_stmt|;
break|break;
case|case
name|SFmode
case|:
name|n
operator|=
literal|2
expr_stmt|;
name|p
operator|=
name|SFnan
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
operator|*
name|nan
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Convert an SFmode target `float' value to a REAL_VALUE_TYPE.    This is the inverse of the function `etarsingle' invoked by    REAL_VALUE_TO_TARGET_SINGLE.  */
end_comment

begin_function
name|REAL_VALUE_TYPE
name|ereal_from_float
parameter_list|(
name|f
parameter_list|)
name|unsigned
name|long
name|f
decl_stmt|;
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|unsigned
name|EMUSHORT
name|s
index|[
literal|2
index|]
decl_stmt|;
name|unsigned
name|EMUSHORT
name|e
index|[
name|NE
index|]
decl_stmt|;
comment|/* Convert 32 bit integer to array of 16 bit pieces in target machine order.    This is the inverse operation to what the function `endian' does.  */
if|#
directive|if
name|WORDS_BIG_ENDIAN
name|s
index|[
literal|0
index|]
operator|=
call|(
name|unsigned
name|EMUSHORT
call|)
argument_list|(
name|f
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|s
index|[
literal|1
index|]
operator|=
operator|(
name|unsigned
name|EMUSHORT
operator|)
name|f
expr_stmt|;
else|#
directive|else
name|s
index|[
literal|0
index|]
operator|=
operator|(
name|unsigned
name|EMUSHORT
operator|)
name|f
expr_stmt|;
name|s
index|[
literal|1
index|]
operator|=
call|(
name|unsigned
name|EMUSHORT
call|)
argument_list|(
name|f
operator|>>
literal|16
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Convert and promote the target float to E-type. */
name|e24toe
argument_list|(
name|s
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|/* Output E-type to REAL_VALUE_TYPE. */
name|PUT_REAL
argument_list|(
name|e
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Convert a DFmode target `double' value to a REAL_VALUE_TYPE.    This is the inverse of the function `etardouble' invoked by    REAL_VALUE_TO_TARGET_DOUBLE.     The DFmode is stored as an array of longs (i.e., HOST_WIDE_INTs)    with 32 bits of the value per each long.  The first element    of the input array holds the bits that would come first in the    target computer's memory.  */
end_comment

begin_function
name|REAL_VALUE_TYPE
name|ereal_from_double
parameter_list|(
name|d
parameter_list|)
name|unsigned
name|long
name|d
index|[]
decl_stmt|;
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|unsigned
name|EMUSHORT
name|s
index|[
literal|4
index|]
decl_stmt|;
name|unsigned
name|EMUSHORT
name|e
index|[
name|NE
index|]
decl_stmt|;
comment|/* Convert array of 32 bit pieces to equivalent array of 16 bit pieces.      This is the inverse of `endian'.   */
if|#
directive|if
name|WORDS_BIG_ENDIAN
name|s
index|[
literal|0
index|]
operator|=
call|(
name|unsigned
name|EMUSHORT
call|)
argument_list|(
name|d
index|[
literal|0
index|]
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|s
index|[
literal|1
index|]
operator|=
operator|(
name|unsigned
name|EMUSHORT
operator|)
name|d
index|[
literal|0
index|]
expr_stmt|;
name|s
index|[
literal|2
index|]
operator|=
call|(
name|unsigned
name|EMUSHORT
call|)
argument_list|(
name|d
index|[
literal|1
index|]
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|s
index|[
literal|3
index|]
operator|=
operator|(
name|unsigned
name|EMUSHORT
operator|)
name|d
index|[
literal|1
index|]
expr_stmt|;
else|#
directive|else
name|s
index|[
literal|0
index|]
operator|=
operator|(
name|unsigned
name|EMUSHORT
operator|)
name|d
index|[
literal|0
index|]
expr_stmt|;
name|s
index|[
literal|1
index|]
operator|=
call|(
name|unsigned
name|EMUSHORT
call|)
argument_list|(
name|d
index|[
literal|0
index|]
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|s
index|[
literal|2
index|]
operator|=
operator|(
name|unsigned
name|EMUSHORT
operator|)
name|d
index|[
literal|1
index|]
expr_stmt|;
name|s
index|[
literal|3
index|]
operator|=
call|(
name|unsigned
name|EMUSHORT
call|)
argument_list|(
name|d
index|[
literal|1
index|]
operator|>>
literal|16
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Convert target double to E-type. */
name|e53toe
argument_list|(
name|s
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|/* Output E-type to REAL_VALUE_TYPE. */
name|PUT_REAL
argument_list|(
name|e
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EMU_NON_COMPILE not defined */
end_comment

end_unit

