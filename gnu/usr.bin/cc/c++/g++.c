begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* G++ preliminary semantic processing for the compiler driver.    Copyright (C) 1993, 1994 Free Software Foundation, Inc.    Contributed by Brendan Kehoe (brendan@cygnus.com).  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* This program is a wrapper to the main `gcc' driver.  For GNU C++,    we need to do two special things: a) append `-lg++' in situations    where it's appropriate, to link in libg++, and b) add `-xc++'..`-xnone'    around file arguments named `foo.c' or `foo.i'.  So, we do all of    this semantic processing then just exec gcc with the new argument    list.     We used to do all of this in a small shell script, but many users    found the performance of this as a shell script to be unacceptable.    In situations where your PATH has a lot of NFS-mounted directories,    using a script that runs sed and other things would be a nasty    performance hit.  With this program, we never search the PATH at all.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_comment
comment|/* May get R_OK, etc. on some systems.  */
end_comment

begin_comment
comment|/* Defined to the name of the compiler; if using a cross compiler, the    Makefile should compile this file with the proper name    (e.g., "i386-aout-gcc").  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|GCC_NAME
end_ifndef

begin_define
define|#
directive|define
name|GCC_NAME
value|"gcc"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This bit is set if we saw a `-xfoo' language specification.  */
end_comment

begin_define
define|#
directive|define
name|LANGSPEC
value|(1<<1)
end_define

begin_comment
comment|/* This bit is set if they did `-lm' or `-lmath'.  */
end_comment

begin_define
define|#
directive|define
name|MATHLIB
value|(1<<2)
end_define

begin_comment
comment|/* On MSDOS, write temp files in current dir    because there's no place else we can expect to use.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__MSDOS__
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|P_tmpdir
end_ifndef

begin_define
define|#
directive|define
name|P_tmpdir
value|"."
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|R_OK
end_ifndef

begin_define
define|#
directive|define
name|R_OK
value|4
end_define

begin_define
define|#
directive|define
name|W_OK
value|2
end_define

begin_define
define|#
directive|define
name|X_OK
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|VPROTO
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_define
define|#
directive|define
name|PVPROTO
parameter_list|(
name|ARGS
parameter_list|)
value|ARGS
end_define

begin_define
define|#
directive|define
name|VPROTO
parameter_list|(
name|ARGS
parameter_list|)
value|ARGS
end_define

begin_define
define|#
directive|define
name|VA_START
parameter_list|(
name|va_list
parameter_list|,
name|var
parameter_list|)
value|va_start(va_list,var)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PVPROTO
parameter_list|(
name|ARGS
parameter_list|)
value|()
end_define

begin_define
define|#
directive|define
name|VPROTO
parameter_list|(
name|ARGS
parameter_list|)
value|(va_alist) va_dcl
end_define

begin_define
define|#
directive|define
name|VA_START
parameter_list|(
name|va_list
parameter_list|,
name|var
parameter_list|)
value|va_start(va_list)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|,
name|sys_nerr
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|bsd4_4
argument_list|)
operator|||
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_decl_stmt
specifier|extern
specifier|const
name|char
modifier|*
specifier|const
name|sys_errlist
index|[]
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|sys_errlist
index|[]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Name with which this program was invoked.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|programname
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_VPRINTF
end_ifdef

begin_comment
comment|/* Output an error message and exit */
end_comment

begin_decl_stmt
specifier|static
name|void
name|fatal
name|VPROTO
argument_list|(
operator|(
name|char
operator|*
name|format
operator|,
operator|...
operator|)
argument_list|)
block|{
ifndef|#
directive|ifndef
name|__STDC__
name|char
modifier|*
name|format
decl_stmt|;
endif|#
directive|endif
name|va_list
name|ap
decl_stmt|;
name|VA_START
argument_list|(
name|ap
argument_list|,
name|format
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|__STDC__
name|format
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|programname
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* XXX Not needed for g++ driver.  */
block|delete_temp_files ();
endif|#
directive|endif
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|error
name|VPROTO
argument_list|(
operator|(
name|char
operator|*
name|format
operator|,
operator|...
operator|)
argument_list|)
block|{
ifndef|#
directive|ifndef
name|__STDC__
name|char
modifier|*
name|format
decl_stmt|;
endif|#
directive|endif
name|va_list
name|ap
decl_stmt|;
name|VA_START
argument_list|(
name|ap
argument_list|,
name|format
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|__STDC__
name|format
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|programname
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not HAVE_VPRINTF */
end_comment

begin_function
specifier|static
name|void
name|error
parameter_list|(
name|msg
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|)
name|char
modifier|*
name|msg
decl_stmt|,
decl|*
name|arg1
decl_stmt|,
modifier|*
name|arg2
decl_stmt|;
end_function

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|programname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|msg
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|void
name|fatal
parameter_list|(
name|msg
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|)
name|char
modifier|*
name|msg
decl_stmt|,
decl|*
name|arg1
decl_stmt|,
modifier|*
name|arg2
decl_stmt|;
end_function

begin_block
block|{
name|error
argument_list|(
name|msg
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* XXX Not needed for g++ driver.  */
block|delete_temp_files ();
endif|#
directive|endif
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not HAVE_VPRINTF */
end_comment

begin_comment
comment|/* More 'friendly' abort that prints the line and file.    config.h can #define abort fancy_abort if you like that sort of thing.  */
end_comment

begin_function
name|void
name|fancy_abort
parameter_list|()
block|{
name|fatal
argument_list|(
literal|"Internal g++ abort."
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|xmalloc
parameter_list|(
name|size
parameter_list|)
name|unsigned
name|size
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|value
init|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"virtual memory exhausted"
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/* Return a newly-allocated string whose contents concatenate those    of s1, s2, s3.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|concat
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|,
name|s3
parameter_list|)
name|char
modifier|*
name|s1
decl_stmt|,
decl|*
name|s2
decl_stmt|,
modifier|*
name|s3
decl_stmt|;
end_function

begin_block
block|{
name|int
name|len1
init|=
name|strlen
argument_list|(
name|s1
argument_list|)
decl_stmt|,
name|len2
init|=
name|strlen
argument_list|(
name|s2
argument_list|)
decl_stmt|,
name|len3
init|=
name|strlen
argument_list|(
name|s3
argument_list|)
decl_stmt|;
name|char
modifier|*
name|result
init|=
name|xmalloc
argument_list|(
name|len1
operator|+
name|len2
operator|+
name|len3
operator|+
literal|1
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|result
argument_list|,
name|s1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|result
operator|+
name|len1
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|result
operator|+
name|len1
operator|+
name|len2
argument_list|,
name|s3
argument_list|)
expr_stmt|;
operator|*
operator|(
name|result
operator|+
name|len1
operator|+
name|len2
operator|+
name|len3
operator|)
operator|=
literal|0
expr_stmt|;
return|return
name|result
return|;
block|}
end_block

begin_function
specifier|static
name|void
name|pfatal_with_name
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|errno
operator|<
name|sys_nerr
condition|)
name|s
operator|=
name|concat
argument_list|(
literal|"%s: "
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|,
literal|""
argument_list|)
expr_stmt|;
else|else
name|s
operator|=
literal|"cannot open %s"
expr_stmt|;
name|fatal
argument_list|(
name|s
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__MSDOS__
end_ifdef

begin_comment
comment|/* This is the common prefix we use to make temp file names.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|temp_filename
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Length of the prefix.  */
end_comment

begin_decl_stmt
name|int
name|temp_filename_length
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Compute a string to use as the base of all temporary file names.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|choose_temp_base_try
parameter_list|(
name|try
parameter_list|,
name|base
parameter_list|)
name|char
modifier|*
name|try
decl_stmt|;
name|char
modifier|*
name|base
decl_stmt|;
block|{
name|char
modifier|*
name|rv
decl_stmt|;
if|if
condition|(
name|base
condition|)
name|rv
operator|=
name|base
expr_stmt|;
elseif|else
if|if
condition|(
name|try
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
name|rv
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|access
argument_list|(
name|try
argument_list|,
name|R_OK
operator||
name|W_OK
argument_list|)
operator|!=
literal|0
condition|)
name|rv
operator|=
literal|0
expr_stmt|;
else|else
name|rv
operator|=
name|try
expr_stmt|;
return|return
name|rv
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|choose_temp_base
parameter_list|()
block|{
name|char
modifier|*
name|base
init|=
literal|0
decl_stmt|;
name|int
name|len
decl_stmt|;
name|base
operator|=
name|choose_temp_base_try
argument_list|(
name|getenv
argument_list|(
literal|"TMPDIR"
argument_list|)
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|base
operator|=
name|choose_temp_base_try
argument_list|(
name|getenv
argument_list|(
literal|"TMP"
argument_list|)
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|base
operator|=
name|choose_temp_base_try
argument_list|(
name|getenv
argument_list|(
literal|"TEMP"
argument_list|)
argument_list|,
name|base
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|P_tmpdir
name|base
operator|=
name|choose_temp_base_try
argument_list|(
name|P_tmpdir
argument_list|,
name|base
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|base
operator|=
name|choose_temp_base_try
argument_list|(
literal|"/usr/tmp"
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|base
operator|=
name|choose_temp_base_try
argument_list|(
literal|"/tmp"
argument_list|,
name|base
argument_list|)
expr_stmt|;
comment|/* If all else fails, use the current directory! */
if|if
condition|(
name|base
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
name|base
operator|=
literal|"./"
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|temp_filename
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
sizeof|sizeof
argument_list|(
literal|"/ccXXXXXX"
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|temp_filename
argument_list|,
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
operator|&&
name|temp_filename
index|[
name|len
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
name|temp_filename
index|[
name|len
operator|++
index|]
operator|=
literal|'/'
expr_stmt|;
name|strcpy
argument_list|(
name|temp_filename
operator|+
name|len
argument_list|,
literal|"ccXXXXXX"
argument_list|)
expr_stmt|;
name|mktemp
argument_list|(
name|temp_filename
argument_list|)
expr_stmt|;
name|temp_filename_length
operator|=
name|strlen
argument_list|(
name|temp_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp_filename_length
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|perror_exec
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|errno
operator|<
name|sys_nerr
condition|)
name|s
operator|=
name|concat
argument_list|(
literal|"installation problem, cannot exec %s: "
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|,
literal|""
argument_list|)
expr_stmt|;
else|else
name|s
operator|=
literal|"installation problem, cannot exec %s"
expr_stmt|;
name|error
argument_list|(
name|s
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is almost exactly what's in gcc.c:pexecute for MSDOS.  */
end_comment

begin_function
name|void
name|run_dos
parameter_list|(
name|program
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
name|program
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|char
modifier|*
name|scmd
decl_stmt|,
modifier|*
name|rf
decl_stmt|;
name|FILE
modifier|*
name|argfile
decl_stmt|;
name|int
name|i
decl_stmt|;
name|choose_temp_base
argument_list|()
expr_stmt|;
comment|/* not in gcc.c */
name|scmd
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|program
argument_list|)
operator|+
name|strlen
argument_list|(
name|temp_filename
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
name|rf
operator|=
name|scmd
operator|+
name|strlen
argument_list|(
name|program
argument_list|)
operator|+
literal|6
expr_stmt|;
name|sprintf
argument_list|(
name|scmd
argument_list|,
literal|"%s.exe @%s.gp"
argument_list|,
name|program
argument_list|,
name|temp_filename
argument_list|)
expr_stmt|;
name|argfile
operator|=
name|fopen
argument_list|(
name|rf
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|argfile
operator|==
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|rf
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|argv
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|argv
index|[
name|i
index|]
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'"'
operator|||
operator|*
name|cp
operator|==
literal|'\''
operator|||
operator|*
name|cp
operator|==
literal|'\\'
operator|||
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|fputc
argument_list|(
literal|'\\'
argument_list|,
name|argfile
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
operator|*
name|cp
argument_list|,
name|argfile
argument_list|)
expr_stmt|;
block|}
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|argfile
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|argfile
argument_list|)
expr_stmt|;
name|i
operator|=
name|system
argument_list|(
name|scmd
argument_list|)
expr_stmt|;
name|remove
argument_list|(
name|rf
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
name|perror_exec
argument_list|(
name|program
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __MSDOS__ */
end_comment

begin_escape
end_escape

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|verbose
init|=
literal|0
decl_stmt|;
comment|/* This will be NULL if we encounter a situation where we should not      link in libg++.  */
name|char
modifier|*
name|library
init|=
literal|"-lg++"
decl_stmt|;
comment|/* Used to track options that take arguments, so we don't go wrapping      those with -xc++/-xnone.  */
name|char
modifier|*
name|quote
init|=
name|NULL
decl_stmt|;
comment|/* The new argument list will be contained in this.  */
name|char
modifier|*
modifier|*
name|arglist
decl_stmt|;
comment|/* The name of the compiler we will want to run---by default, it      will be the definition of `GCC_NAME', e.g., `gcc'.  */
name|char
modifier|*
name|gcc
init|=
name|GCC_NAME
decl_stmt|;
comment|/* Non-zero if we saw a `-xfoo' language specification on the      command line.  Used to avoid adding our own -xc++ if the user      already gave a language for the file.  */
name|int
name|saw_speclang
init|=
literal|0
decl_stmt|;
comment|/* Non-zero if we saw `-lm' or `-lmath' on the command line.  */
name|int
name|saw_math
init|=
literal|0
decl_stmt|;
comment|/* The number of arguments being added to what's in argv.  By      default it's one new argument (adding `-lg++').  We use this      to track the number of times we've inserted -xc++/-xnone as well.  */
name|int
name|added
init|=
literal|1
decl_stmt|;
comment|/* An array used to flag each argument that needs a bit set for      LANGSPEC or MATHLIB.  */
name|int
modifier|*
name|args
decl_stmt|;
name|p
operator|=
name|argv
index|[
literal|0
index|]
operator|+
name|strlen
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|argv
index|[
literal|0
index|]
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
operator|--
name|p
expr_stmt|;
name|programname
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
name|fatal
argument_list|(
literal|"No input files specified.\n"
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|__MSDOS__
comment|/* We do a little magic to find out where the main gcc executable      is.  If they ran us as /usr/local/bin/g++, then we will look      for /usr/local/bin/gcc; similarly, if they just ran us as `g++',      we'll just look for `gcc'.  */
if|if
condition|(
name|p
operator|!=
name|argv
index|[
literal|0
index|]
condition|)
block|{
operator|*
operator|--
name|p
operator|=
literal|'\0'
expr_stmt|;
name|gcc
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|strlen
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|GCC_NAME
argument_list|)
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|gcc
argument_list|,
literal|"%s/%s"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|GCC_NAME
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|args
operator|=
operator|(
name|int
operator|*
operator|)
name|malloc
argument_list|(
name|argc
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|args
argument_list|,
name|argc
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
comment|/* If the previous option took an argument, we swallow it here.  */
if|if
condition|(
name|quote
condition|)
block|{
name|quote
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
continue|continue;
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-nostdlib"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|added
operator|--
expr_stmt|;
name|library
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-lm"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-lmath"
argument_list|)
operator|==
literal|0
condition|)
name|args
index|[
name|i
index|]
operator||=
name|MATHLIB
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-v"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|verbose
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|2
condition|)
block|{
comment|/* If they only gave us `-v', don't try to link 		     in libg++.  */
name|added
operator|--
expr_stmt|;
name|library
operator|=
name|NULL
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-x"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
name|saw_speclang
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|(
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|&&
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
literal|"bBVDUoeTuIYmLiA"
argument_list|,
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
argument_list|)
operator|!=
name|NULL
operator|)
operator|||
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Tdata"
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|quote
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|(
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|&&
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
literal|"cSEM"
argument_list|,
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
argument_list|)
operator|!=
name|NULL
operator|)
operator|||
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-MM"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* Don't specify libraries if we won't link, since that would 		 cause a warning.  */
name|added
operator|--
expr_stmt|;
name|library
operator|=
name|NULL
expr_stmt|;
block|}
else|else
comment|/* Pass other options through.  */
continue|continue;
block|}
else|else
block|{
name|int
name|len
decl_stmt|;
if|if
condition|(
name|saw_speclang
condition|)
continue|continue;
comment|/* If the filename ends in .c or .i, put options around it. 	     But not if a specified -x option is currently active.  */
name|len
operator|=
name|strlen
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|2
operator|&&
operator|(
name|argv
index|[
name|i
index|]
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'c'
operator|||
name|argv
index|[
name|i
index|]
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'i'
operator|)
operator|&&
name|argv
index|[
name|i
index|]
index|[
name|len
operator|-
literal|2
index|]
operator|==
literal|'.'
condition|)
block|{
name|args
index|[
name|i
index|]
operator||=
name|LANGSPEC
expr_stmt|;
name|added
operator|+=
literal|2
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|quote
condition|)
name|fatal
argument_list|(
literal|"argument to `%s' missing\n"
argument_list|,
name|quote
argument_list|)
expr_stmt|;
if|if
condition|(
name|added
condition|)
block|{
name|arglist
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|argc
operator|+
name|added
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|j
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
name|arglist
index|[
name|j
index|]
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
comment|/* Make sure -lg++ is before the math library, since libg++ 	     itself uses those math routines.  */
if|if
condition|(
operator|!
name|saw_math
operator|&&
operator|(
name|args
index|[
name|i
index|]
operator|&
name|MATHLIB
operator|)
operator|&&
name|library
condition|)
block|{
name|saw_math
operator|=
literal|1
expr_stmt|;
name|arglist
index|[
name|j
index|]
operator|=
name|library
expr_stmt|;
name|arglist
index|[
operator|++
name|j
index|]
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* Wrap foo.c and foo.i files in a language specification to 	     force the gcc compiler driver to run cc1plus on them.  */
if|if
condition|(
name|args
index|[
name|i
index|]
operator|&
name|LANGSPEC
condition|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'i'
condition|)
name|arglist
index|[
name|j
operator|++
index|]
operator|=
literal|"-xc++-cpp-output"
expr_stmt|;
else|else
name|arglist
index|[
name|j
operator|++
index|]
operator|=
literal|"-xc++"
expr_stmt|;
name|arglist
index|[
name|j
operator|++
index|]
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
name|arglist
index|[
name|j
index|]
operator|=
literal|"-xnone"
expr_stmt|;
block|}
block|}
comment|/* Add `-lg++' if we haven't already done so.  */
if|if
condition|(
name|library
operator|&&
operator|!
name|saw_math
condition|)
name|arglist
index|[
name|j
operator|++
index|]
operator|=
name|library
expr_stmt|;
name|arglist
index|[
name|j
index|]
operator|=
name|NULL
expr_stmt|;
block|}
else|else
comment|/* No need to copy 'em all.  */
name|arglist
operator|=
name|argv
expr_stmt|;
name|arglist
index|[
literal|0
index|]
operator|=
name|gcc
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
if|if
condition|(
name|j
operator|==
literal|0
condition|)
name|j
operator|=
name|argc
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|j
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %s"
argument_list|,
name|arglist
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|OS2
ifdef|#
directive|ifdef
name|__MSDOS__
name|run_dos
argument_list|(
name|gcc
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !__MSDOS__ */
if|if
condition|(
name|execvp
argument_list|(
name|gcc
argument_list|,
name|arglist
argument_list|)
operator|<
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|gcc
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* __MSDOS__ */
else|#
directive|else
comment|/* OS2 */
if|if
condition|(
name|spawnvp
argument_list|(
name|gcc
argument_list|,
name|arglist
argument_list|)
operator|<
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|gcc
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

end_unit

