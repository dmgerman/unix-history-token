begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Instruction scheduling pass.    Copyright (C) 1992 Free Software Foundation, Inc.    Contributed by Michael Tiemann (tiemann@cygnus.com)    Enhanced by, and currently maintained by, Jim Wilson (wilson@cygnus.com)  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* Instruction scheduling pass.     This pass implements list scheduling within basic blocks.  It is    run after flow analysis, but before register allocation.  The    scheduler works as follows:     We compute insn priorities based on data dependencies.  Flow    analysis only creates a fraction of the data-dependencies we must    observe: namely, only those dependencies which the combiner can be    expected to use.  For this pass, we must therefore create the    remaining dependencies we need to observe: register dependencies,    memory dependencies, dependencies to keep function calls in order,    and the dependence between a conditional branch and the setting of    condition codes are all dealt with here.     The scheduler first traverses the data flow graph, starting with    the last instruction, and proceeding to the first, assigning    values to insn_priority as it goes.  This sorts the instructions    topologically by data dependence.     Once priorities have been established, we order the insns using    list scheduling.  This works as follows: starting with a list of    all the ready insns, and sorted according to priority number, we    schedule the insn from the end of the list by placing its    predecessors in the list according to their priority order.  We    consider this insn scheduled by setting the pointer to the "end" of    the list to point to the previous insn.  When an insn has no    predecessors, we either queue it until sufficient time has elapsed    or add it to the ready list.  As the instructions are scheduled or    when stalls are introduced, the queue advances and dumps insns into    the ready list.  When all insns down to the lowest priority have    been scheduled, the critical path of the basic block has been made    as short as possible.  The remaining insns are then scheduled in    remaining slots.     Function unit conflicts are resolved during reverse list scheduling    by tracking the time when each insn is committed to the schedule    and from that, the time the function units it uses must be free.    As insns on the ready list are considered for scheduling, those    that would result in a blockage of the already committed insns are    queued until no blockage will result.  Among the remaining insns on    the ready list to be considered, the first one with the largest    potential for causing a subsequent blockage is chosen.     The following list shows the order in which we want to break ties    among insns in the ready list:  	1.  choose insn with lowest conflict cost, ties broken by 	2.  choose insn with the longest path to end of bb, ties broken by 	3.  choose insn that kills the most registers, ties broken by 	4.  choose insn that conflicts with the most ready insns, or finally 	5.  choose insn with lowest UID.     Memory references complicate matters.  Only if we can be certain    that memory references are not part of the data dependency graph    (via true, anti, or output dependence), can we move operations past    memory references.  To first approximation, reads can be done    independently, while writes introduce dependencies.  Better    approximations will yield fewer dependencies.     Dependencies set up by memory references are treated in exactly the    same way as other dependencies, by using LOG_LINKS.     Having optimized the critical path, we may have also unduly    extended the lifetimes of some registers.  If an operation requires    that constants be loaded into registers, it is certainly desirable    to load those constants as early as necessary, but no earlier.    I.e., it will not do to load up a bunch of registers at the    beginning of a basic block only to use them at the end, if they    could be loaded later, since this may result in excessive register    utilization.     Note that since branches are never in basic blocks, but only end    basic blocks, this pass will not do any branch scheduling.  But    that is ok, since we can use GNU's delayed branch scheduling    pass to take care of this case.     Also note that no further optimizations based on algebraic identities    are performed, so this pass would be a good one to perform instruction    splitting, such as breaking up a multiply instruction into shifts    and adds where that is profitable.     Given the memory aliasing analysis that this pass should perform,    it should be possible to remove redundant stores to memory, and to    load values from registers instead of hitting memory.     This pass must update information that subsequent passes expect to be    correct.  Namely: reg_n_refs, reg_n_sets, reg_n_deaths,    reg_n_calls_crossed, and reg_live_length.  Also, basic_block_head,    basic_block_end.     The information in the line number notes is carefully retained by this    pass.  All other NOTE insns are grouped in their same relative order at    the beginning of basic blocks that have been scheduled.  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INSN_SCHEDULING
end_ifdef

begin_comment
comment|/* Arrays set up by scheduling for the same respective purposes as    similar-named arrays set up by flow analysis.  We work with these    arrays during the scheduling pass so we can compare values against    unscheduled code.     Values of these arrays are copied at the end of this pass into the    arrays set up by flow analysis.  */
end_comment

begin_decl_stmt
specifier|static
name|short
modifier|*
name|sched_reg_n_deaths
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
modifier|*
name|sched_reg_n_calls_crossed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
modifier|*
name|sched_reg_live_length
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Element N is the next insn that sets (hard or pseudo) register    N within the current basic block; or zero, if there is no    such insn.  Needed for new registers which may be introduced    by splitting insns.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|reg_last_uses
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|reg_last_sets
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Vector indexed by INSN_UID giving the original ordering of the insns.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|insn_luid
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|INSN_LUID
parameter_list|(
name|INSN
parameter_list|)
value|(insn_luid[INSN_UID (INSN)])
end_define

begin_comment
comment|/* Vector indexed by INSN_UID giving each instruction a priority.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|insn_priority
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|INSN_PRIORITY
parameter_list|(
name|INSN
parameter_list|)
value|(insn_priority[INSN_UID (INSN)])
end_define

begin_decl_stmt
specifier|static
name|short
modifier|*
name|insn_costs
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|INSN_COST
parameter_list|(
name|INSN
parameter_list|)
value|insn_costs[INSN_UID (INSN)]
end_define

begin_comment
comment|/* Vector indexed by INSN_UID giving an encoding of the function units    used.  */
end_comment

begin_decl_stmt
specifier|static
name|short
modifier|*
name|insn_units
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|INSN_UNIT
parameter_list|(
name|INSN
parameter_list|)
value|insn_units[INSN_UID (INSN)]
end_define

begin_comment
comment|/* Vector indexed by INSN_UID giving an encoding of the blockage range    function.  The unit and the range are encoded.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
modifier|*
name|insn_blockage
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|INSN_BLOCKAGE
parameter_list|(
name|INSN
parameter_list|)
value|insn_blockage[INSN_UID (INSN)]
end_define

begin_define
define|#
directive|define
name|UNIT_BITS
value|5
end_define

begin_define
define|#
directive|define
name|BLOCKAGE_MASK
value|((1<< BLOCKAGE_BITS) - 1)
end_define

begin_define
define|#
directive|define
name|ENCODE_BLOCKAGE
parameter_list|(
name|U
parameter_list|,
name|R
parameter_list|)
define|\
value|((((U)<< UNIT_BITS)<< BLOCKAGE_BITS			\     | MIN_BLOCKAGE_COST (R))<< BLOCKAGE_BITS		\    | MAX_BLOCKAGE_COST (R))
end_define

begin_define
define|#
directive|define
name|UNIT_BLOCKED
parameter_list|(
name|B
parameter_list|)
value|((B)>> (2 * BLOCKAGE_BITS))
end_define

begin_define
define|#
directive|define
name|BLOCKAGE_RANGE
parameter_list|(
name|B
parameter_list|)
define|\
value|(((((B)>> BLOCKAGE_BITS)& BLOCKAGE_MASK)<< (HOST_BITS_PER_INT / 2)) \    | (B)& BLOCKAGE_MASK)
end_define

begin_comment
comment|/* Encodings of the `<name>_unit_blockage_range' function.  */
end_comment

begin_define
define|#
directive|define
name|MIN_BLOCKAGE_COST
parameter_list|(
name|R
parameter_list|)
value|((R)>> (HOST_BITS_PER_INT / 2))
end_define

begin_define
define|#
directive|define
name|MAX_BLOCKAGE_COST
parameter_list|(
name|R
parameter_list|)
value|((R)& ((1<< (HOST_BITS_PER_INT / 2)) - 1))
end_define

begin_define
define|#
directive|define
name|DONE_PRIORITY
value|-1
end_define

begin_define
define|#
directive|define
name|MAX_PRIORITY
value|0x7fffffff
end_define

begin_define
define|#
directive|define
name|TAIL_PRIORITY
value|0x7ffffffe
end_define

begin_define
define|#
directive|define
name|LAUNCH_PRIORITY
value|0x7f000001
end_define

begin_define
define|#
directive|define
name|DONE_PRIORITY_P
parameter_list|(
name|INSN
parameter_list|)
value|(INSN_PRIORITY (INSN)< 0)
end_define

begin_define
define|#
directive|define
name|LOW_PRIORITY_P
parameter_list|(
name|INSN
parameter_list|)
value|((INSN_PRIORITY (INSN)& 0x7f000000) == 0)
end_define

begin_comment
comment|/* Vector indexed by INSN_UID giving number of insns referring to this insn.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|insn_ref_count
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|INSN_REF_COUNT
parameter_list|(
name|INSN
parameter_list|)
value|(insn_ref_count[INSN_UID (INSN)])
end_define

begin_comment
comment|/* Vector indexed by INSN_UID giving line-number note in effect for each    insn.  For line-number notes, this indicates whether the note may be    reused.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|line_note
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|LINE_NOTE
parameter_list|(
name|INSN
parameter_list|)
value|(line_note[INSN_UID (INSN)])
end_define

begin_comment
comment|/* Vector indexed by basic block number giving the starting line-number    for each basic block.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|line_note_head
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of important notes we must keep around.  This is a pointer to the    last element in the list.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|note_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Regsets telling whether a given register is live or dead before the last    scheduled insn.  Must scan the instructions once before scheduling to    determine what registers are live or dead at the end of the block.  */
end_comment

begin_decl_stmt
specifier|static
name|regset
name|bb_dead_regs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|regset
name|bb_live_regs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Regset telling whether a given register is live after the insn currently    being scheduled.  Before processing an insn, this is equal to bb_live_regs    above.  This is used so that we can find registers that are newly born/dead    after processing an insn.  */
end_comment

begin_decl_stmt
specifier|static
name|regset
name|old_live_regs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The chain of REG_DEAD notes.  REG_DEAD notes are removed from all insns    during the initial scan and reused later.  If there are not exactly as    many REG_DEAD notes in the post scheduled code as there were in the    prescheduled code then we trigger an abort because this indicates a bug.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|dead_notes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Queues, etc.  */
end_comment

begin_comment
comment|/* An instruction is ready to be scheduled when all insns following it    have already been scheduled.  It is important to ensure that all    insns which use its result will not be executed until its result    has been computed.  An insn is maintained in one of four structures:     (P) the "Pending" set of insns which cannot be scheduled until    their dependencies have been satisfied.    (Q) the "Queued" set of insns that can be scheduled when sufficient    time has passed.    (R) the "Ready" list of unscheduled, uncommitted insns.    (S) the "Scheduled" list of insns.     Initially, all insns are either "Pending" or "Ready" depending on    whether their dependencies are satisfied.     Insns move from the "Ready" list to the "Scheduled" list as they    are committed to the schedule.  As this occurs, the insns in the    "Pending" list have their dependencies satisfied and move to either    the "Ready" list or the "Queued" set depending on whether    sufficient time has passed to make them ready.  As time passes,    insns move from the "Queued" set to the "Ready" list.  Insns may    move from the "Ready" list to the "Queued" set if they are blocked    due to a function unit conflict.     The "Pending" list (P) are the insns in the LOG_LINKS of the unscheduled    insns, i.e., those that are ready, queued, and pending.    The "Queued" set (Q) is implemented by the variable `insn_queue'.    The "Ready" list (R) is implemented by the variables `ready' and    `n_ready'.    The "Scheduled" list (S) is the new insn chain built by this pass.     The transition (R->S) is implemented in the scheduling loop in    `schedule_block' when the best insn to schedule is chosen.    The transition (R->Q) is implemented in `schedule_select' when an    insn is found to to have a function unit conflict with the already    committed insns.    The transitions (P->R and P->Q) are implemented in `schedule_insn' as    insns move from the ready list to the scheduled list.    The transition (Q->R) is implemented at the top of the scheduling    loop in `schedule_block' as time passes or stalls are introduced.  */
end_comment

begin_comment
comment|/* Implement a circular buffer to delay instructions until sufficient    time has passed.  INSN_QUEUE_SIZE is a power of two larger than    MAX_BLOCKAGE and MAX_READY_COST computed by genattr.c.  This is the    longest time an isnsn may be queued.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|insn_queue
index|[
name|INSN_QUEUE_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|q_ptr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|q_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NEXT_Q
parameter_list|(
name|X
parameter_list|)
value|(((X)+1)& (INSN_QUEUE_SIZE-1))
end_define

begin_define
define|#
directive|define
name|NEXT_Q_AFTER
parameter_list|(
name|X
parameter_list|,
name|C
parameter_list|)
value|(((X)+C)& (INSN_QUEUE_SIZE-1))
end_define

begin_comment
comment|/* Vector indexed by INSN_UID giving the minimum clock tick at which    the insn becomes ready.  This is used to note timing constraints for    insns in the pending list.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|insn_tick
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|INSN_TICK
parameter_list|(
name|INSN
parameter_list|)
value|(insn_tick[INSN_UID (INSN)])
end_define

begin_comment
comment|/* Forward declarations.  */
end_comment

begin_function_decl
specifier|static
name|void
name|sched_analyze_2
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|schedule_block
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Main entry point of this file.  */
end_comment

begin_function_decl
name|void
name|schedule_insns
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INSN_SCHEDULING */
end_comment

begin_escape
end_escape

begin_define
define|#
directive|define
name|SIZE_FOR_MODE
parameter_list|(
name|X
parameter_list|)
value|(GET_MODE_SIZE (GET_MODE (X)))
end_define

begin_comment
comment|/* Vector indexed by N giving the initial (unchanging) value known    for pseudo-register N.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|reg_known_value
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Vector recording for each reg_known_value whether it is due to a    REG_EQUIV note.  Future passes (viz., reload) may replace the    pseudo with the equivalent expression and so we account for the    dependences that would be introduced if that happens. */
end_comment

begin_comment
comment|/* ??? This is a problem only on the Convex.  The REG_EQUIV notes created in    assign_parms mention the arg pointer, and there are explicit insns in the    RTL that modify the arg pointer.  Thus we must ensure that such insns don't    get scheduled across each other because that would invalidate the REG_EQUIV    notes.  One could argue that the REG_EQUIV notes are wrong, but solving    the problem in the scheduler will likely give better code, so we do it    here.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|reg_known_equiv_p
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indicates number of valid entries in reg_known_value.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|reg_known_value_size
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|rtx
name|canon_rtx
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<=
name|reg_known_value_size
condition|)
return|return
name|reg_known_value
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|rtx
name|x0
init|=
name|canon_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|x1
init|=
name|canon_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|x0
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|||
name|x1
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|)
block|{
comment|/* We can tolerate LO_SUMs being offset here; these 	     rtl are used for nothing other than comparisons.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x0
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|plus_constant_for_output
argument_list|(
name|x1
argument_list|,
name|INTVAL
argument_list|(
name|x0
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x1
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|plus_constant_for_output
argument_list|(
name|x0
argument_list|,
name|INTVAL
argument_list|(
name|x1
argument_list|)
argument_list|)
return|;
return|return
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|x0
argument_list|,
name|x1
argument_list|)
return|;
block|}
block|}
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Set up all info needed to perform alias analysis on memory references.  */
end_comment

begin_function
name|void
name|init_alias_analysis
parameter_list|()
block|{
name|int
name|maxreg
init|=
name|max_reg_num
argument_list|()
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|rtx
name|note
decl_stmt|;
name|rtx
name|set
decl_stmt|;
name|reg_known_value_size
operator|=
name|maxreg
expr_stmt|;
name|reg_known_value
operator|=
operator|(
name|rtx
operator|*
operator|)
name|oballoc
argument_list|(
operator|(
name|maxreg
operator|-
name|FIRST_PSEUDO_REGISTER
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
operator|-
name|FIRST_PSEUDO_REGISTER
expr_stmt|;
name|bzero
argument_list|(
name|reg_known_value
operator|+
name|FIRST_PSEUDO_REGISTER
argument_list|,
operator|(
name|maxreg
operator|-
name|FIRST_PSEUDO_REGISTER
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|reg_known_equiv_p
operator|=
operator|(
name|char
operator|*
operator|)
name|oballoc
argument_list|(
operator|(
name|maxreg
operator|-
name|FIRST_PSEUDO_REGISTER
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
operator|-
name|FIRST_PSEUDO_REGISTER
expr_stmt|;
name|bzero
argument_list|(
name|reg_known_equiv_p
operator|+
name|FIRST_PSEUDO_REGISTER
argument_list|,
operator|(
name|maxreg
operator|-
name|FIRST_PSEUDO_REGISTER
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fill in the entries with known constant values.  */
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|(
operator|(
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EQUAL
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|reg_n_sets
index|[
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
index|]
operator|==
literal|1
operator|)
operator|||
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EQUIV
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
operator|!=
literal|0
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|EXPR_LIST
condition|)
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
decl_stmt|;
name|reg_known_value
index|[
name|regno
index|]
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|reg_known_equiv_p
index|[
name|regno
index|]
operator|=
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_EQUIV
expr_stmt|;
block|}
comment|/* Fill in the remaining entries.  */
while|while
condition|(
operator|--
name|maxreg
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
if|if
condition|(
name|reg_known_value
index|[
name|maxreg
index|]
operator|==
literal|0
condition|)
name|reg_known_value
index|[
name|maxreg
index|]
operator|=
name|regno_reg_rtx
index|[
name|maxreg
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return 1 if X and Y are identical-looking rtx's.     We use the data in reg_known_value above to see if two registers with    different numbers are, in fact, equivalent.  */
end_comment

begin_function
specifier|static
name|int
name|rtx_equal_for_memref_p
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
operator|&&
name|y
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|x
operator|==
literal|0
operator|||
name|y
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|x
operator|=
name|canon_rtx
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|y
operator|=
name|canon_rtx
argument_list|(
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|y
condition|)
return|return
literal|1
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* Rtx's of different codes cannot be equal.  */
if|if
condition|(
name|code
operator|!=
name|GET_CODE
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* (MULT:SI x y) and (MULT:HI x y) are NOT equivalent.      (REG:SI x) and (REG:HI x) are NOT equivalent.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* REG, LABEL_REF, and SYMBOL_REF can be compared nonrecursively.  */
if|if
condition|(
name|code
operator|==
name|REG
condition|)
return|return
name|REGNO
argument_list|(
name|x
argument_list|)
operator|==
name|REGNO
argument_list|(
name|y
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|LABEL_REF
condition|)
return|return
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|SYMBOL_REF
condition|)
return|return
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|XSTR
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
return|;
comment|/* Compare the elements.  If any pair of corresponding elements      fail to match, return 0 for the whole things.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
switch|switch
condition|(
name|fmt
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'w'
case|:
if|if
condition|(
name|XWINT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XWINT
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'n'
case|:
case|case
literal|'i'
case|:
if|if
condition|(
name|XINT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XINT
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'V'
case|:
case|case
literal|'E'
case|:
comment|/* Two vectors must have the same length.  */
if|if
condition|(
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XVECLEN
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* And the corresponding elements must match.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|rtx_equal_for_memref_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|XVECEXP
argument_list|(
name|y
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'e'
case|:
if|if
condition|(
name|rtx_equal_for_memref_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'S'
case|:
case|case
literal|'s'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|XSTR
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|XSTR
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'u'
case|:
comment|/* These are just backpointers, so they don't matter.  */
break|break;
case|case
literal|'0'
case|:
break|break;
comment|/* It is believed that rtx's at this level will never 	     contain anything but integers and other rtx's, 	     except for within LABEL_REFs and SYMBOL_REFs.  */
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Given an rtx X, find a SYMBOL_REF or LABEL_REF within    X and return it, or return 0 if none found.  */
end_comment

begin_function
specifier|static
name|rtx
name|find_symbolic_term
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|SYMBOL_REF
operator|||
name|code
operator|==
name|LABEL_REF
condition|)
return|return
name|x
return|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'o'
condition|)
return|return
literal|0
return|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|rtx
name|t
decl_stmt|;
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
name|t
operator|=
name|find_symbolic_term
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
literal|0
condition|)
return|return
name|t
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if X and Y (memory addresses) could reference the    same location in memory.  C is an offset accumulator.  When    C is nonzero, we are testing aliases between X and Y + C.    XSIZE is the size in bytes of the X reference,    similarly YSIZE is the size in bytes for Y.     If XSIZE or YSIZE is zero, we do not know the amount of memory being    referenced (the reference was BLKmode), so make the most pessimistic    assumptions.     We recognize the following cases of non-conflicting memory:  	(1) addresses involving the frame pointer cannot conflict 	    with addresses involving static variables. 	(2) static variables with different addresses cannot conflict.     Nice to notice that varying addresses cannot conflict with fp if no    local variables had their addresses taken, but that's too hard now.  */
end_comment

begin_comment
comment|/* ??? In Fortran, references to a array parameter can never conflict with    another array parameter.  */
end_comment

begin_function
specifier|static
name|int
name|memrefs_conflict_p
parameter_list|(
name|xsize
parameter_list|,
name|x
parameter_list|,
name|ysize
parameter_list|,
name|y
parameter_list|,
name|c
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
name|int
name|xsize
decl_stmt|,
name|ysize
decl_stmt|;
name|HOST_WIDE_INT
name|c
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|HIGH
condition|)
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LO_SUM
condition|)
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|x
operator|=
name|canon_rtx
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|HIGH
condition|)
name|y
operator|=
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|LO_SUM
condition|)
name|y
operator|=
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|y
operator|=
name|canon_rtx
argument_list|(
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtx_equal_for_memref_p
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
condition|)
return|return
operator|(
name|xsize
operator|==
literal|0
operator|||
name|ysize
operator|==
literal|0
operator|||
operator|(
name|c
operator|>=
literal|0
operator|&&
name|xsize
operator|>
name|c
operator|)
operator|||
operator|(
name|c
operator|<
literal|0
operator|&&
name|ysize
operator|+
name|c
operator|>
literal|0
operator|)
operator|)
return|;
if|if
condition|(
name|y
operator|==
name|frame_pointer_rtx
operator|||
name|y
operator|==
name|stack_pointer_rtx
condition|)
block|{
name|rtx
name|t
init|=
name|y
decl_stmt|;
name|int
name|tsize
init|=
name|ysize
decl_stmt|;
name|y
operator|=
name|x
expr_stmt|;
name|ysize
operator|=
name|xsize
expr_stmt|;
name|x
operator|=
name|t
expr_stmt|;
name|xsize
operator|=
name|tsize
expr_stmt|;
block|}
if|if
condition|(
name|x
operator|==
name|frame_pointer_rtx
operator|||
name|x
operator|==
name|stack_pointer_rtx
condition|)
block|{
name|rtx
name|y1
decl_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|PLUS
operator|&&
name|canon_rtx
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|x
operator|&&
operator|(
name|y1
operator|=
name|canon_rtx
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|y1
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|c
operator|+=
name|INTVAL
argument_list|(
name|y1
argument_list|)
expr_stmt|;
return|return
operator|(
name|xsize
operator|==
literal|0
operator|||
name|ysize
operator|==
literal|0
operator|||
operator|(
name|c
operator|>=
literal|0
operator|&&
name|xsize
operator|>
name|c
operator|)
operator|||
operator|(
name|c
operator|<
literal|0
operator|&&
name|ysize
operator|+
name|c
operator|>
literal|0
operator|)
operator|)
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|PLUS
operator|&&
operator|(
name|y1
operator|=
name|canon_rtx
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|&&
name|CONSTANT_P
argument_list|(
name|y1
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
condition|)
block|{
comment|/* The fact that X is canonicalized means that this 	 PLUS rtx is canonicalized.  */
name|rtx
name|x0
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|x1
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|PLUS
condition|)
block|{
comment|/* The fact that Y is canonicalized means that this 	     PLUS rtx is canonicalized.  */
name|rtx
name|y0
init|=
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|y1
init|=
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|rtx_equal_for_memref_p
argument_list|(
name|x1
argument_list|,
name|y1
argument_list|)
condition|)
return|return
name|memrefs_conflict_p
argument_list|(
name|xsize
argument_list|,
name|x0
argument_list|,
name|ysize
argument_list|,
name|y0
argument_list|,
name|c
argument_list|)
return|;
if|if
condition|(
name|rtx_equal_for_memref_p
argument_list|(
name|x0
argument_list|,
name|y0
argument_list|)
condition|)
return|return
name|memrefs_conflict_p
argument_list|(
name|xsize
argument_list|,
name|x1
argument_list|,
name|ysize
argument_list|,
name|y1
argument_list|,
name|c
argument_list|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x1
argument_list|)
operator|==
name|CONST_INT
condition|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|y1
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|memrefs_conflict_p
argument_list|(
name|xsize
argument_list|,
name|x0
argument_list|,
name|ysize
argument_list|,
name|y0
argument_list|,
name|c
operator|-
name|INTVAL
argument_list|(
name|x1
argument_list|)
operator|+
name|INTVAL
argument_list|(
name|y1
argument_list|)
argument_list|)
return|;
else|else
return|return
name|memrefs_conflict_p
argument_list|(
name|xsize
argument_list|,
name|x0
argument_list|,
name|ysize
argument_list|,
name|y
argument_list|,
name|c
operator|-
name|INTVAL
argument_list|(
name|x1
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|y1
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|memrefs_conflict_p
argument_list|(
name|xsize
argument_list|,
name|x
argument_list|,
name|ysize
argument_list|,
name|y0
argument_list|,
name|c
operator|+
name|INTVAL
argument_list|(
name|y1
argument_list|)
argument_list|)
return|;
comment|/* Handle case where we cannot understand iteration operators, 	     but we notice that the base addresses are distinct objects.  */
name|x
operator|=
name|find_symbolic_term
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
literal|1
return|;
name|y
operator|=
name|find_symbolic_term
argument_list|(
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|==
literal|0
condition|)
return|return
literal|1
return|;
return|return
name|rtx_equal_for_memref_p
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x1
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|memrefs_conflict_p
argument_list|(
name|xsize
argument_list|,
name|x0
argument_list|,
name|ysize
argument_list|,
name|y
argument_list|,
name|c
operator|-
name|INTVAL
argument_list|(
name|x1
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|PLUS
condition|)
block|{
comment|/* The fact that Y is canonicalized means that this 	 PLUS rtx is canonicalized.  */
name|rtx
name|y0
init|=
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|y1
init|=
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|y1
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|memrefs_conflict_p
argument_list|(
name|xsize
argument_list|,
name|x
argument_list|,
name|ysize
argument_list|,
name|y0
argument_list|,
name|c
operator|+
name|INTVAL
argument_list|(
name|y1
argument_list|)
argument_list|)
return|;
else|else
return|return
literal|1
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|GET_CODE
argument_list|(
name|y
argument_list|)
condition|)
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|MULT
case|:
block|{
comment|/* Handle cases where we expect the second operands to be the 	     same, and check only whether the first operand would conflict 	     or not.  */
name|rtx
name|x0
decl_stmt|,
name|y0
decl_stmt|;
name|rtx
name|x1
init|=
name|canon_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|y1
init|=
name|canon_rtx
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|rtx_equal_for_memref_p
argument_list|(
name|x1
argument_list|,
name|y1
argument_list|)
condition|)
return|return
literal|1
return|;
name|x0
operator|=
name|canon_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|y0
operator|=
name|canon_rtx
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtx_equal_for_memref_p
argument_list|(
name|x0
argument_list|,
name|y0
argument_list|)
condition|)
return|return
operator|(
name|xsize
operator|==
literal|0
operator|||
name|ysize
operator|==
literal|0
operator|||
operator|(
name|c
operator|>=
literal|0
operator|&&
name|xsize
operator|>
name|c
operator|)
operator|||
operator|(
name|c
operator|<
literal|0
operator|&&
name|ysize
operator|+
name|c
operator|>
literal|0
operator|)
operator|)
return|;
comment|/* Can't properly adjust our sizes.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x1
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
literal|1
return|;
name|xsize
operator|/=
name|INTVAL
argument_list|(
name|x1
argument_list|)
expr_stmt|;
name|ysize
operator|/=
name|INTVAL
argument_list|(
name|x1
argument_list|)
expr_stmt|;
name|c
operator|/=
name|INTVAL
argument_list|(
name|x1
argument_list|)
expr_stmt|;
return|return
name|memrefs_conflict_p
argument_list|(
name|xsize
argument_list|,
name|x0
argument_list|,
name|ysize
argument_list|,
name|y0
argument_list|,
name|c
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|c
operator|+=
operator|(
name|INTVAL
argument_list|(
name|y
argument_list|)
operator|-
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|)
expr_stmt|;
return|return
operator|(
name|xsize
operator|==
literal|0
operator|||
name|ysize
operator|==
literal|0
operator|||
operator|(
name|c
operator|>=
literal|0
operator|&&
name|xsize
operator|>
name|c
operator|)
operator|||
operator|(
name|c
operator|<
literal|0
operator|&&
name|ysize
operator|+
name|c
operator|>
literal|0
operator|)
operator|)
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|CONST
condition|)
return|return
name|memrefs_conflict_p
argument_list|(
name|xsize
argument_list|,
name|canon_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|ysize
argument_list|,
name|canon_rtx
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|c
argument_list|)
return|;
else|else
return|return
name|memrefs_conflict_p
argument_list|(
name|xsize
argument_list|,
name|canon_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|ysize
argument_list|,
name|y
argument_list|,
name|c
argument_list|)
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|CONST
condition|)
return|return
name|memrefs_conflict_p
argument_list|(
name|xsize
argument_list|,
name|x
argument_list|,
name|ysize
argument_list|,
name|canon_rtx
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|c
argument_list|)
return|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|y
argument_list|)
condition|)
return|return
operator|(
name|rtx_equal_for_memref_p
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
operator|&&
operator|(
name|xsize
operator|==
literal|0
operator|||
name|ysize
operator|==
literal|0
operator|||
operator|(
name|c
operator|>=
literal|0
operator|&&
name|xsize
operator|>
name|c
operator|)
operator|||
operator|(
name|c
operator|<
literal|0
operator|&&
name|ysize
operator|+
name|c
operator|>
literal|0
operator|)
operator|)
operator|)
return|;
return|return
literal|1
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Functions to compute memory dependencies.     Since we process the insns in execution order, we can build tables    to keep track of what registers are fixed (and not aliased), what registers    are varying in known ways, and what registers are varying in unknown    ways.     If both memory references are volatile, then there must always be a    dependence between the two references, since their order can not be    changed.  A volatile and non-volatile reference can be interchanged    though.      A MEM_IN_STRUCT reference at a non-QImode varying address can never    conflict with a non-MEM_IN_STRUCT reference at a fixed address.   We must    allow QImode aliasing because the ANSI C standard allows character    pointers to alias anything.  We are assuming that characters are    always QImode here.  */
end_comment

begin_comment
comment|/* Read dependence: X is read after read in MEM takes place.  There can    only be a dependence here if both reads are volatile.  */
end_comment

begin_function
name|int
name|read_dependence
parameter_list|(
name|mem
parameter_list|,
name|x
parameter_list|)
name|rtx
name|mem
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
return|return
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
operator|&&
name|MEM_VOLATILE_P
argument_list|(
name|mem
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* True dependence: X is read after store in MEM takes place.  */
end_comment

begin_function
name|int
name|true_dependence
parameter_list|(
name|mem
parameter_list|,
name|x
parameter_list|)
name|rtx
name|mem
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
comment|/* If X is an unchanging read, then it can't possibly conflict with any      non-unchanging store.  It may conflict with an unchanging write though,      because there may be a single store to this address to initialize it.      Just fall through to the code below to resolve the case where we have      both an unchanging read and an unchanging write.  This won't handle all      cases optimally, but the possible performance loss should be      negligible.  */
if|if
condition|(
name|RTX_UNCHANGING_P
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|RTX_UNCHANGING_P
argument_list|(
name|mem
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
operator|(
operator|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
operator|&&
name|MEM_VOLATILE_P
argument_list|(
name|mem
argument_list|)
operator|)
operator|||
operator|(
name|memrefs_conflict_p
argument_list|(
name|SIZE_FOR_MODE
argument_list|(
name|mem
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|SIZE_FOR_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|&&
operator|!
operator|(
name|MEM_IN_STRUCT_P
argument_list|(
name|mem
argument_list|)
operator|&&
name|rtx_addr_varies_p
argument_list|(
name|mem
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|mem
argument_list|)
operator|!=
name|QImode
operator|&&
operator|!
name|MEM_IN_STRUCT_P
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|rtx_addr_varies_p
argument_list|(
name|x
argument_list|)
operator|)
operator|&&
operator|!
operator|(
name|MEM_IN_STRUCT_P
argument_list|(
name|x
argument_list|)
operator|&&
name|rtx_addr_varies_p
argument_list|(
name|x
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|QImode
operator|&&
operator|!
name|MEM_IN_STRUCT_P
argument_list|(
name|mem
argument_list|)
operator|&&
operator|!
name|rtx_addr_varies_p
argument_list|(
name|mem
argument_list|)
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Anti dependence: X is written after read in MEM takes place.  */
end_comment

begin_function
name|int
name|anti_dependence
parameter_list|(
name|mem
parameter_list|,
name|x
parameter_list|)
name|rtx
name|mem
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
comment|/* If MEM is an unchanging read, then it can't possibly conflict with      the store to X, because there is at most one store to MEM, and it must      have occured somewhere before MEM.  */
if|if
condition|(
name|RTX_UNCHANGING_P
argument_list|(
name|mem
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
operator|(
operator|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
operator|&&
name|MEM_VOLATILE_P
argument_list|(
name|mem
argument_list|)
operator|)
operator|||
operator|(
name|memrefs_conflict_p
argument_list|(
name|SIZE_FOR_MODE
argument_list|(
name|mem
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|SIZE_FOR_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|&&
operator|!
operator|(
name|MEM_IN_STRUCT_P
argument_list|(
name|mem
argument_list|)
operator|&&
name|rtx_addr_varies_p
argument_list|(
name|mem
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|mem
argument_list|)
operator|!=
name|QImode
operator|&&
operator|!
name|MEM_IN_STRUCT_P
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|rtx_addr_varies_p
argument_list|(
name|x
argument_list|)
operator|)
operator|&&
operator|!
operator|(
name|MEM_IN_STRUCT_P
argument_list|(
name|x
argument_list|)
operator|&&
name|rtx_addr_varies_p
argument_list|(
name|x
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|QImode
operator|&&
operator|!
name|MEM_IN_STRUCT_P
argument_list|(
name|mem
argument_list|)
operator|&&
operator|!
name|rtx_addr_varies_p
argument_list|(
name|mem
argument_list|)
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Output dependence: X is written after store in MEM takes place.  */
end_comment

begin_function
name|int
name|output_dependence
parameter_list|(
name|mem
parameter_list|,
name|x
parameter_list|)
name|rtx
name|mem
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
operator|&&
name|MEM_VOLATILE_P
argument_list|(
name|mem
argument_list|)
operator|)
operator|||
operator|(
name|memrefs_conflict_p
argument_list|(
name|SIZE_FOR_MODE
argument_list|(
name|mem
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|SIZE_FOR_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|&&
operator|!
operator|(
name|MEM_IN_STRUCT_P
argument_list|(
name|mem
argument_list|)
operator|&&
name|rtx_addr_varies_p
argument_list|(
name|mem
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|mem
argument_list|)
operator|!=
name|QImode
operator|&&
operator|!
name|MEM_IN_STRUCT_P
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|rtx_addr_varies_p
argument_list|(
name|x
argument_list|)
operator|)
operator|&&
operator|!
operator|(
name|MEM_IN_STRUCT_P
argument_list|(
name|x
argument_list|)
operator|&&
name|rtx_addr_varies_p
argument_list|(
name|x
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|QImode
operator|&&
operator|!
name|MEM_IN_STRUCT_P
argument_list|(
name|mem
argument_list|)
operator|&&
operator|!
name|rtx_addr_varies_p
argument_list|(
name|mem
argument_list|)
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Helper functions for instruction scheduling.  */
end_comment

begin_comment
comment|/* Add ELEM wrapped in an INSN_LIST with reg note kind DEP_TYPE to the    LOG_LINKS of INSN, if not already there.  DEP_TYPE indicates the type    of dependence that this link represents.  */
end_comment

begin_function
name|void
name|add_dependence
parameter_list|(
name|insn
parameter_list|,
name|elem
parameter_list|,
name|dep_type
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|elem
decl_stmt|;
name|enum
name|reg_note
name|dep_type
decl_stmt|;
block|{
name|rtx
name|link
decl_stmt|,
name|next
decl_stmt|;
comment|/* Don't depend an insn on itself.  */
if|if
condition|(
name|insn
operator|==
name|elem
condition|)
return|return;
comment|/* If elem is part of a sequence that must be scheduled together, then      make the dependence point to the last insn of the sequence.      When HAVE_cc0, it is possible for NOTEs to exist between users and      setters of the condition codes, so we must skip past notes here.      Otherwise, NOTEs are impossible here.  */
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|elem
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
while|while
condition|(
name|next
operator|&&
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|NOTE
condition|)
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|next
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|next
operator|&&
name|SCHED_GROUP_P
argument_list|(
name|next
argument_list|)
condition|)
block|{
comment|/* Notes will never intervene here though, so don't bother checking 	 for them.  */
comment|/* We must reject CODE_LABELs, so that we don't get confused by one 	 that has LABEL_PRESERVE_P set, which is represented by the same 	 bit in the rtl as SCHED_GROUP_P.  A CODE_LABEL can never be 	 SCHED_GROUP_P.  */
while|while
condition|(
name|NEXT_INSN
argument_list|(
name|next
argument_list|)
operator|&&
name|SCHED_GROUP_P
argument_list|(
name|NEXT_INSN
argument_list|(
name|next
argument_list|)
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|NEXT_INSN
argument_list|(
name|next
argument_list|)
argument_list|)
operator|!=
name|CODE_LABEL
condition|)
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|next
argument_list|)
expr_stmt|;
comment|/* Again, don't depend an insn on itself.  */
if|if
condition|(
name|insn
operator|==
name|next
condition|)
return|return;
comment|/* Make the dependence to NEXT, the last insn of the group, instead 	 of the original ELEM.  */
name|elem
operator|=
name|next
expr_stmt|;
block|}
comment|/* Check that we don't already have this dependence.  */
for|for
control|(
name|link
operator|=
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
operator|==
name|elem
condition|)
block|{
comment|/* If this is a more restrictive type of dependence than the existing 	   one, then change the existing dependence to this type.  */
if|if
condition|(
operator|(
name|int
operator|)
name|dep_type
operator|<
operator|(
name|int
operator|)
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
condition|)
name|PUT_REG_NOTE_KIND
argument_list|(
name|link
argument_list|,
name|dep_type
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Might want to check one level of transitivity to save conses.  */
name|link
operator|=
name|rtx_alloc
argument_list|(
name|INSN_LIST
argument_list|)
expr_stmt|;
comment|/* Insn dependency, not data dependency.  */
name|PUT_REG_NOTE_KIND
argument_list|(
name|link
argument_list|,
name|dep_type
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
operator|=
name|elem
expr_stmt|;
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
operator|=
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
operator|=
name|link
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove ELEM wrapped in an INSN_LIST from the LOG_LINKS    of INSN.  Abort if not found.  */
end_comment

begin_function
name|void
name|remove_dependence
parameter_list|(
name|insn
parameter_list|,
name|elem
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|elem
decl_stmt|;
block|{
name|rtx
name|prev
decl_stmt|,
name|link
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
for|for
control|(
name|prev
operator|=
literal|0
operator|,
name|link
operator|=
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|prev
operator|=
name|link
operator|,
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
block|{
if|if
condition|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
operator|==
name|elem
condition|)
block|{
if|if
condition|(
name|prev
condition|)
name|XEXP
argument_list|(
name|prev
argument_list|,
literal|1
argument_list|)
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

begin_escape
end_escape

begin_ifndef
ifndef|#
directive|ifndef
name|INSN_SCHEDULING
end_ifndef

begin_function
name|void
name|schedule_insns
parameter_list|()
block|{}
end_function

begin_else
else|#
directive|else
end_else

begin_ifndef
ifndef|#
directive|ifndef
name|__GNUC__
end_ifndef

begin_define
define|#
directive|define
name|__inline
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Computation of memory dependencies.  */
end_comment

begin_comment
comment|/* The *_insns and *_mems are paired lists.  Each pending memory operation    will have a pointer to the MEM rtx on one list and a pointer to the    containing insn on the other list in the same place in the list.  */
end_comment

begin_comment
comment|/* We can't use add_dependence like the old code did, because a single insn    may have multiple memory accesses, and hence needs to be on the list    once for each memory access.  Add_dependence won't let you add an insn    to a list more than once.  */
end_comment

begin_comment
comment|/* An INSN_LIST containing all insns with pending read operations.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|pending_read_insns
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* An EXPR_LIST containing all MEM rtx's which are pending reads.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|pending_read_mems
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* An INSN_LIST containing all insns with pending write operations.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|pending_write_insns
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* An EXPR_LIST containing all MEM rtx's which are pending writes.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|pending_write_mems
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indicates the combined length of the two pending lists.  We must prevent    these lists from ever growing too large since the number of dependencies    produced is at least O(N*N), and execution time is at least O(4*N*N), as    a function of the length of these pending lists.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pending_lists_length
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* An INSN_LIST containing all INSN_LISTs allocated but currently unused.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|unused_insn_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* An EXPR_LIST containing all EXPR_LISTs allocated but currently unused.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|unused_expr_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The last insn upon which all memory references must depend.    This is an insn which flushed the pending lists, creating a dependency    between it and all previously pending memory references.  This creates    a barrier (or a checkpoint) which no memory reference is allowed to cross.     This includes all non constant CALL_INSNs.  When we do interprocedural    alias analysis, this restriction can be relaxed.    This may also be an INSN that writes memory if the pending lists grow    too large.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|last_pending_memory_flush
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The last function call we have seen.  All hard regs, and, of course,    the last function call, must depend on this.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|last_function_call
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The LOG_LINKS field of this is a list of insns which use a pseudo register    that does not already cross a call.  We create dependencies between each    of those insn and the next call insn, to ensure that they won't cross a call    after scheduling is done.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|sched_before_next_call
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to the last instruction scheduled.  Used by rank_for_schedule,    so that insns independent of the last scheduled insn will be preferred    over dependent instructions.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|last_scheduled_insn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Process an insn's memory dependencies.  There are four kinds of    dependencies:     (0) read dependence: read follows read    (1) true dependence: read follows write    (2) anti dependence: write follows read    (3) output dependence: write follows write     We are careful to build only dependencies which actually exist, and    use transitivity to avoid building too many links.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Return the INSN_LIST containing INSN in LIST, or NULL    if LIST does not contain INSN.  */
end_comment

begin_function
name|__inline
specifier|static
name|rtx
name|find_insn_list
parameter_list|(
name|insn
parameter_list|,
name|list
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|list
decl_stmt|;
block|{
while|while
condition|(
name|list
condition|)
block|{
if|if
condition|(
name|XEXP
argument_list|(
name|list
argument_list|,
literal|0
argument_list|)
operator|==
name|insn
condition|)
return|return
name|list
return|;
name|list
operator|=
name|XEXP
argument_list|(
name|list
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Compute the function units used by INSN.  This caches the value    returned by function_units_used.  A function unit is encoded as the    unit number if the value is non-negative and the compliment of a    mask if the value is negative.  A function unit index is the    non-negative encoding.  */
end_comment

begin_function
name|__inline
specifier|static
name|int
name|insn_unit
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
specifier|register
name|int
name|unit
init|=
name|INSN_UNIT
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|unit
operator|==
literal|0
condition|)
block|{
name|recog_memoized
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* A USE insn, or something else we don't need to understand. 	 We can't pass these directly to function_units_used because it will 	 trigger a fatal error for unrecognizable insns.  */
if|if
condition|(
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|<
literal|0
condition|)
name|unit
operator|=
operator|-
literal|1
expr_stmt|;
else|else
block|{
name|unit
operator|=
name|function_units_used
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Increment non-negative values so we can cache zero.  */
if|if
condition|(
name|unit
operator|>=
literal|0
condition|)
name|unit
operator|++
expr_stmt|;
block|}
comment|/* We only cache 16 bits of the result, so if the value is out of 	 range, don't cache it.  */
if|if
condition|(
name|FUNCTION_UNITS_SIZE
operator|<
name|HOST_BITS_PER_SHORT
operator|||
name|unit
operator|>=
literal|0
operator|||
operator|(
operator|~
name|unit
operator|&
operator|(
operator|(
literal|1
operator|<<
operator|(
name|HOST_BITS_PER_SHORT
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
name|INSN_UNIT
argument_list|(
name|insn
argument_list|)
operator|=
name|unit
expr_stmt|;
block|}
return|return
operator|(
name|unit
operator|>
literal|0
condition|?
name|unit
operator|-
literal|1
else|:
name|unit
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Compute the blockage range for executing INSN on UNIT.  This caches    the value returned by the blockage_range_function for the unit.    These values are encoded in an int where the upper half gives the    minimum value and the lower half gives the maximum value.  */
end_comment

begin_function
name|__inline
specifier|static
name|unsigned
name|int
name|blockage_range
parameter_list|(
name|unit
parameter_list|,
name|insn
parameter_list|)
name|int
name|unit
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|unsigned
name|int
name|blockage
init|=
name|INSN_BLOCKAGE
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|range
decl_stmt|;
if|if
condition|(
name|UNIT_BLOCKED
argument_list|(
name|blockage
argument_list|)
operator|!=
name|unit
operator|+
literal|1
condition|)
block|{
name|range
operator|=
name|function_units
index|[
name|unit
index|]
operator|.
name|blockage_range_function
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* We only cache the blockage range for one unit and then only if 	 the values fit.  */
if|if
condition|(
name|HOST_BITS_PER_INT
operator|>=
name|UNIT_BITS
operator|+
literal|2
operator|*
name|BLOCKAGE_BITS
condition|)
name|INSN_BLOCKAGE
argument_list|(
name|insn
argument_list|)
operator|=
name|ENCODE_BLOCKAGE
argument_list|(
name|unit
operator|+
literal|1
argument_list|,
name|range
argument_list|)
expr_stmt|;
block|}
else|else
name|range
operator|=
name|BLOCKAGE_RANGE
argument_list|(
name|blockage
argument_list|)
expr_stmt|;
return|return
name|range
return|;
block|}
end_function

begin_comment
comment|/* A vector indexed by function unit instance giving the last insn to use    the unit.  The value of the function unit instance index for unit U    instance I is (U + I * FUNCTION_UNITS_SIZE).  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|unit_last_insn
index|[
name|FUNCTION_UNITS_SIZE
operator|*
name|MAX_MULTIPLICITY
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A vector indexed by function unit instance giving the minimum time when    the unit will unblock based on the maximum blockage cost.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|unit_tick
index|[
name|FUNCTION_UNITS_SIZE
operator|*
name|MAX_MULTIPLICITY
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A vector indexed by function unit number giving the number of insns    that remain to use the unit.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|unit_n_insns
index|[
name|FUNCTION_UNITS_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Reset the function unit state to the null state.  */
end_comment

begin_function
specifier|static
name|void
name|clear_units
parameter_list|()
block|{
name|int
name|unit
decl_stmt|;
name|bzero
argument_list|(
name|unit_last_insn
argument_list|,
sizeof|sizeof
argument_list|(
name|unit_last_insn
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|unit_tick
argument_list|,
sizeof|sizeof
argument_list|(
name|unit_tick
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|unit_n_insns
argument_list|,
sizeof|sizeof
argument_list|(
name|unit_n_insns
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record an insn as one that will use the units encoded by UNIT.  */
end_comment

begin_function
name|__inline
specifier|static
name|void
name|prepare_unit
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
literal|0
condition|)
name|unit_n_insns
index|[
name|unit
index|]
operator|++
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|unit
operator|=
operator|~
name|unit
init|;
name|unit
condition|;
name|i
operator|++
operator|,
name|unit
operator|>>=
literal|1
control|)
if|if
condition|(
operator|(
name|unit
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|prepare_unit
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the actual hazard cost of executing INSN on the unit UNIT,    instance INSTANCE at time CLOCK if the previous actual hazard cost    was COST.  */
end_comment

begin_function
name|__inline
specifier|static
name|int
name|actual_hazard_this_instance
parameter_list|(
name|unit
parameter_list|,
name|instance
parameter_list|,
name|insn
parameter_list|,
name|clock
parameter_list|,
name|cost
parameter_list|)
name|int
name|unit
decl_stmt|,
name|instance
decl_stmt|,
name|clock
decl_stmt|,
name|cost
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|tick
init|=
name|unit_tick
index|[
name|instance
index|]
decl_stmt|;
if|if
condition|(
name|tick
operator|-
name|clock
operator|>
name|cost
condition|)
block|{
comment|/* The scheduler is operating in reverse, so INSN is the executing 	 insn and the unit's last insn is the candidate insn.  We want a 	 more exact measure of the blockage if we execute INSN at CLOCK 	 given when we committed the execution of the unit's last insn.  	 The blockage value is given by either the unit's max blockage 	 constant, blockage range function, or blockage function.  Use 	 the most exact form for the given unit.  */
if|if
condition|(
name|function_units
index|[
name|unit
index|]
operator|.
name|blockage_range_function
condition|)
block|{
if|if
condition|(
name|function_units
index|[
name|unit
index|]
operator|.
name|blockage_function
condition|)
name|tick
operator|+=
operator|(
name|function_units
index|[
name|unit
index|]
operator|.
name|blockage_function
argument_list|(
name|insn
argument_list|,
name|unit_last_insn
index|[
name|instance
index|]
argument_list|)
operator|-
name|function_units
index|[
name|unit
index|]
operator|.
name|max_blockage
operator|)
expr_stmt|;
else|else
name|tick
operator|+=
operator|(
operator|(
name|int
operator|)
name|MAX_BLOCKAGE_COST
argument_list|(
name|blockage_range
argument_list|(
name|unit
argument_list|,
name|insn
argument_list|)
argument_list|)
operator|-
name|function_units
index|[
name|unit
index|]
operator|.
name|max_blockage
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|tick
operator|-
name|clock
operator|>
name|cost
condition|)
name|cost
operator|=
name|tick
operator|-
name|clock
expr_stmt|;
block|}
return|return
name|cost
return|;
block|}
end_function

begin_comment
comment|/* Record INSN as having begun execution on the units encoded by UNIT at    time CLOCK.  */
end_comment

begin_function
name|__inline
specifier|static
name|void
name|schedule_unit
parameter_list|(
name|unit
parameter_list|,
name|insn
parameter_list|,
name|clock
parameter_list|)
name|int
name|unit
decl_stmt|,
name|clock
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
literal|0
condition|)
block|{
name|int
name|instance
init|=
name|unit
decl_stmt|;
if|#
directive|if
name|MAX_MULTIPLICITY
operator|>
literal|1
comment|/* Find the first free instance of the function unit and use that 	 one.  We assume that one is free.  */
for|for
control|(
name|i
operator|=
name|function_units
index|[
name|unit
index|]
operator|.
name|multiplicity
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
operator|!
name|actual_hazard_this_instance
argument_list|(
name|unit
argument_list|,
name|instance
argument_list|,
name|insn
argument_list|,
name|clock
argument_list|,
literal|0
argument_list|)
condition|)
break|break;
name|instance
operator|+=
name|FUNCTION_UNITS_SIZE
expr_stmt|;
block|}
endif|#
directive|endif
name|unit_last_insn
index|[
name|instance
index|]
operator|=
name|insn
expr_stmt|;
name|unit_tick
index|[
name|instance
index|]
operator|=
operator|(
name|clock
operator|+
name|function_units
index|[
name|unit
index|]
operator|.
name|max_blockage
operator|)
expr_stmt|;
block|}
else|else
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|unit
operator|=
operator|~
name|unit
init|;
name|unit
condition|;
name|i
operator|++
operator|,
name|unit
operator|>>=
literal|1
control|)
if|if
condition|(
operator|(
name|unit
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|schedule_unit
argument_list|(
name|i
argument_list|,
name|insn
argument_list|,
name|clock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the actual hazard cost of executing INSN on the units encoded by    UNIT at time CLOCK if the previous actual hazard cost was COST.  */
end_comment

begin_function
name|__inline
specifier|static
name|int
name|actual_hazard
parameter_list|(
name|unit
parameter_list|,
name|insn
parameter_list|,
name|clock
parameter_list|,
name|cost
parameter_list|)
name|int
name|unit
decl_stmt|,
name|clock
decl_stmt|,
name|cost
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
literal|0
condition|)
block|{
comment|/* Find the instance of the function unit with the minimum hazard.  */
name|int
name|instance
init|=
name|unit
decl_stmt|;
name|int
name|best
init|=
name|instance
decl_stmt|;
name|int
name|best_cost
init|=
name|actual_hazard_this_instance
argument_list|(
name|unit
argument_list|,
name|instance
argument_list|,
name|insn
argument_list|,
name|clock
argument_list|,
name|cost
argument_list|)
decl_stmt|;
name|int
name|this_cost
decl_stmt|;
if|#
directive|if
name|MAX_MULTIPLICITY
operator|>
literal|1
if|if
condition|(
name|best_cost
operator|>
name|cost
condition|)
block|{
for|for
control|(
name|i
operator|=
name|function_units
index|[
name|unit
index|]
operator|.
name|multiplicity
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|instance
operator|+=
name|FUNCTION_UNITS_SIZE
expr_stmt|;
name|this_cost
operator|=
name|actual_hazard_this_instance
argument_list|(
name|unit
argument_list|,
name|instance
argument_list|,
name|insn
argument_list|,
name|clock
argument_list|,
name|cost
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_cost
operator|<
name|best_cost
condition|)
block|{
name|best
operator|=
name|instance
expr_stmt|;
name|best_cost
operator|=
name|this_cost
expr_stmt|;
if|if
condition|(
name|this_cost
operator|<=
name|cost
condition|)
break|break;
block|}
block|}
block|}
endif|#
directive|endif
name|cost
operator|=
name|MAX
argument_list|(
name|cost
argument_list|,
name|best_cost
argument_list|)
expr_stmt|;
block|}
else|else
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|unit
operator|=
operator|~
name|unit
init|;
name|unit
condition|;
name|i
operator|++
operator|,
name|unit
operator|>>=
literal|1
control|)
if|if
condition|(
operator|(
name|unit
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|cost
operator|=
name|actual_hazard
argument_list|(
name|i
argument_list|,
name|insn
argument_list|,
name|clock
argument_list|,
name|cost
argument_list|)
expr_stmt|;
return|return
name|cost
return|;
block|}
end_function

begin_comment
comment|/* Return the potential hazard cost of executing an instruction on the    units encoded by UNIT if the previous potential hazard cost was COST.    An insn with a large blockage time is chosen in preference to one    with a smaller time; an insn that uses a unit that is more likely    to be used is chosen in preference to one with a unit that is less    used.  We are trying to minimize a subsequent actual hazard.  */
end_comment

begin_function
name|__inline
specifier|static
name|int
name|potential_hazard
parameter_list|(
name|unit
parameter_list|,
name|insn
parameter_list|,
name|cost
parameter_list|)
name|int
name|unit
decl_stmt|,
name|cost
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|ncost
decl_stmt|;
name|unsigned
name|int
name|minb
decl_stmt|,
name|maxb
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
literal|0
condition|)
block|{
name|minb
operator|=
name|maxb
operator|=
name|function_units
index|[
name|unit
index|]
operator|.
name|max_blockage
expr_stmt|;
if|if
condition|(
name|maxb
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|function_units
index|[
name|unit
index|]
operator|.
name|blockage_range_function
condition|)
block|{
name|maxb
operator|=
name|minb
operator|=
name|blockage_range
argument_list|(
name|unit
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|maxb
operator|=
name|MAX_BLOCKAGE_COST
argument_list|(
name|maxb
argument_list|)
expr_stmt|;
name|minb
operator|=
name|MIN_BLOCKAGE_COST
argument_list|(
name|minb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|maxb
operator|>
literal|1
condition|)
block|{
comment|/* Make the number of instructions left dominate.  Make the 		 minimum delay dominate the maximum delay.  If all these 		 are the same, use the unit number to add an arbitrary 		 ordering.  Other terms can be added.  */
name|ncost
operator|=
name|minb
operator|*
literal|0x40
operator|+
name|maxb
expr_stmt|;
name|ncost
operator|*=
operator|(
name|unit_n_insns
index|[
name|unit
index|]
operator|-
literal|1
operator|)
operator|*
literal|0x1000
operator|+
name|unit
expr_stmt|;
if|if
condition|(
name|ncost
operator|>
name|cost
condition|)
name|cost
operator|=
name|ncost
expr_stmt|;
block|}
block|}
block|}
else|else
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|unit
operator|=
operator|~
name|unit
init|;
name|unit
condition|;
name|i
operator|++
operator|,
name|unit
operator|>>=
literal|1
control|)
if|if
condition|(
operator|(
name|unit
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|cost
operator|=
name|potential_hazard
argument_list|(
name|i
argument_list|,
name|insn
argument_list|,
name|cost
argument_list|)
expr_stmt|;
return|return
name|cost
return|;
block|}
end_function

begin_comment
comment|/* Compute cost of executing INSN given the dependence LINK on the insn USED.    This is the number of virtual cycles taken between instruction issue and    instruction results.  */
end_comment

begin_function
name|__inline
specifier|static
name|int
name|insn_cost
parameter_list|(
name|insn
parameter_list|,
name|link
parameter_list|,
name|used
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|link
decl_stmt|,
name|used
decl_stmt|;
block|{
specifier|register
name|int
name|cost
init|=
name|INSN_COST
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|cost
operator|==
literal|0
condition|)
block|{
name|recog_memoized
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* A USE insn, or something else we don't need to understand. 	 We can't pass these directly to result_ready_cost because it will 	 trigger a fatal error for unrecognizable insns.  */
if|if
condition|(
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|<
literal|0
condition|)
block|{
name|INSN_COST
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
name|cost
operator|=
name|result_ready_cost
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|cost
operator|<
literal|1
condition|)
name|cost
operator|=
literal|1
expr_stmt|;
name|INSN_COST
argument_list|(
name|insn
argument_list|)
operator|=
name|cost
expr_stmt|;
block|}
block|}
comment|/* A USE insn should never require the value used to be computed.  This      allows the computation of a function's result and parameter values to      overlap the return and call.  */
name|recog_memoized
argument_list|(
name|used
argument_list|)
expr_stmt|;
if|if
condition|(
name|INSN_CODE
argument_list|(
name|used
argument_list|)
operator|<
literal|0
condition|)
name|LINK_COST_FREE
argument_list|(
name|link
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* If some dependencies vary the cost, compute the adjustment.  Most      commonly, the adjustment is complete: either the cost is ignored      (in the case of an output- or anti-dependence), or the cost is      unchanged.  These values are cached in the link as LINK_COST_FREE      and LINK_COST_ZERO.  */
if|if
condition|(
name|LINK_COST_FREE
argument_list|(
name|link
argument_list|)
condition|)
name|cost
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|ADJUST_COST
elseif|else
if|if
condition|(
operator|!
name|LINK_COST_ZERO
argument_list|(
name|link
argument_list|)
condition|)
block|{
name|int
name|ncost
init|=
name|cost
decl_stmt|;
name|ADJUST_COST
argument_list|(
name|used
argument_list|,
name|link
argument_list|,
name|insn
argument_list|,
name|ncost
argument_list|)
expr_stmt|;
if|if
condition|(
name|ncost
operator|<=
literal|1
condition|)
name|LINK_COST_FREE
argument_list|(
name|link
argument_list|)
operator|=
name|ncost
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|cost
operator|==
name|ncost
condition|)
name|LINK_COST_ZERO
argument_list|(
name|link
argument_list|)
operator|=
literal|1
expr_stmt|;
name|cost
operator|=
name|ncost
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|cost
return|;
block|}
end_function

begin_comment
comment|/* Compute the priority number for INSN.  */
end_comment

begin_function
specifier|static
name|int
name|priority
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
if|if
condition|(
name|insn
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
block|{
name|int
name|prev_priority
decl_stmt|;
name|int
name|max_priority
decl_stmt|;
name|int
name|this_priority
init|=
name|INSN_PRIORITY
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|prev
decl_stmt|;
if|if
condition|(
name|this_priority
operator|>
literal|0
condition|)
return|return
name|this_priority
return|;
name|max_priority
operator|=
literal|1
expr_stmt|;
comment|/* Nonzero if these insns must be scheduled together.  */
if|if
condition|(
name|SCHED_GROUP_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|prev
operator|=
name|insn
expr_stmt|;
while|while
condition|(
name|SCHED_GROUP_P
argument_list|(
name|prev
argument_list|)
condition|)
block|{
name|prev
operator|=
name|PREV_INSN
argument_list|(
name|prev
argument_list|)
expr_stmt|;
name|INSN_REF_COUNT
argument_list|(
name|prev
argument_list|)
operator|+=
literal|1
expr_stmt|;
block|}
block|}
for|for
control|(
name|prev
operator|=
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
init|;
name|prev
condition|;
name|prev
operator|=
name|XEXP
argument_list|(
name|prev
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|rtx
name|x
init|=
name|XEXP
argument_list|(
name|prev
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* A dependence pointing to a note is always obsolete, because 	     sched_analyze_insn will have created any necessary new dependences 	     which replace it.  Notes can be created when instructions are 	     deleted by insn splitting, or by register allocation.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|NOTE
condition|)
block|{
name|remove_dependence
argument_list|(
name|insn
argument_list|,
name|x
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Clear the link cost adjustment bits.  */
name|LINK_COST_FREE
argument_list|(
name|prev
argument_list|)
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|ADJUST_COST
name|LINK_COST_ZERO
argument_list|(
name|prev
argument_list|)
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* This priority calculation was chosen because it results in the 	     least instruction movement, and does not hurt the performance 	     of the resulting code compared to the old algorithm. 	     This makes the sched algorithm more stable, which results 	     in better code, because there is less register pressure, 	     cross jumping is more likely to work, and debugging is easier.  	     When all instructions have a latency of 1, there is no need to 	     move any instructions.  Subtracting one here ensures that in such 	     cases all instructions will end up with a priority of one, and 	     hence no scheduling will be done.  	     The original code did not subtract the one, and added the 	     insn_cost of the current instruction to its priority (e.g. 	     move the insn_cost call down to the end).  */
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|prev
argument_list|)
operator|==
literal|0
condition|)
comment|/* Data dependence.  */
name|prev_priority
operator|=
name|priority
argument_list|(
name|x
argument_list|)
operator|+
name|insn_cost
argument_list|(
name|x
argument_list|,
name|prev
argument_list|,
name|insn
argument_list|)
operator|-
literal|1
expr_stmt|;
else|else
comment|/* Anti or output dependence.  Don't add the latency of this 	       insn's result, because it isn't being used.  */
name|prev_priority
operator|=
name|priority
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev_priority
operator|>
name|max_priority
condition|)
name|max_priority
operator|=
name|prev_priority
expr_stmt|;
name|INSN_REF_COUNT
argument_list|(
name|x
argument_list|)
operator|+=
literal|1
expr_stmt|;
block|}
name|prepare_unit
argument_list|(
name|insn_unit
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|INSN_PRIORITY
argument_list|(
name|insn
argument_list|)
operator|=
name|max_priority
expr_stmt|;
return|return
name|INSN_PRIORITY
argument_list|(
name|insn
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Remove all INSN_LISTs and EXPR_LISTs from the pending lists and add    them to the unused_*_list variables, so that they can be reused.  */
end_comment

begin_function
specifier|static
name|void
name|free_pending_lists
parameter_list|()
block|{
specifier|register
name|rtx
name|link
decl_stmt|,
name|prev_link
decl_stmt|;
if|if
condition|(
name|pending_read_insns
condition|)
block|{
name|prev_link
operator|=
name|pending_read_insns
expr_stmt|;
name|link
operator|=
name|XEXP
argument_list|(
name|prev_link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|link
condition|)
block|{
name|prev_link
operator|=
name|link
expr_stmt|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|XEXP
argument_list|(
name|prev_link
argument_list|,
literal|1
argument_list|)
operator|=
name|unused_insn_list
expr_stmt|;
name|unused_insn_list
operator|=
name|pending_read_insns
expr_stmt|;
name|pending_read_insns
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|pending_write_insns
condition|)
block|{
name|prev_link
operator|=
name|pending_write_insns
expr_stmt|;
name|link
operator|=
name|XEXP
argument_list|(
name|prev_link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|link
condition|)
block|{
name|prev_link
operator|=
name|link
expr_stmt|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|XEXP
argument_list|(
name|prev_link
argument_list|,
literal|1
argument_list|)
operator|=
name|unused_insn_list
expr_stmt|;
name|unused_insn_list
operator|=
name|pending_write_insns
expr_stmt|;
name|pending_write_insns
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|pending_read_mems
condition|)
block|{
name|prev_link
operator|=
name|pending_read_mems
expr_stmt|;
name|link
operator|=
name|XEXP
argument_list|(
name|prev_link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|link
condition|)
block|{
name|prev_link
operator|=
name|link
expr_stmt|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|XEXP
argument_list|(
name|prev_link
argument_list|,
literal|1
argument_list|)
operator|=
name|unused_expr_list
expr_stmt|;
name|unused_expr_list
operator|=
name|pending_read_mems
expr_stmt|;
name|pending_read_mems
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|pending_write_mems
condition|)
block|{
name|prev_link
operator|=
name|pending_write_mems
expr_stmt|;
name|link
operator|=
name|XEXP
argument_list|(
name|prev_link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|link
condition|)
block|{
name|prev_link
operator|=
name|link
expr_stmt|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|XEXP
argument_list|(
name|prev_link
argument_list|,
literal|1
argument_list|)
operator|=
name|unused_expr_list
expr_stmt|;
name|unused_expr_list
operator|=
name|pending_write_mems
expr_stmt|;
name|pending_write_mems
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Add an INSN and MEM reference pair to a pending INSN_LIST and MEM_LIST.    The MEM is a memory reference contained within INSN, which we are saving    so that we can do memory aliasing on it.  */
end_comment

begin_function
specifier|static
name|void
name|add_insn_mem_dependence
parameter_list|(
name|insn_list
parameter_list|,
name|mem_list
parameter_list|,
name|insn
parameter_list|,
name|mem
parameter_list|)
name|rtx
modifier|*
name|insn_list
decl_stmt|,
decl|*
name|mem_list
decl_stmt|,
name|insn
decl_stmt|,
name|mem
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|rtx
name|link
decl_stmt|;
if|if
condition|(
name|unused_insn_list
condition|)
block|{
name|link
operator|=
name|unused_insn_list
expr_stmt|;
name|unused_insn_list
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|link
operator|=
name|rtx_alloc
argument_list|(
name|INSN_LIST
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
operator|=
name|insn
expr_stmt|;
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
operator|=
operator|*
name|insn_list
expr_stmt|;
operator|*
name|insn_list
operator|=
name|link
expr_stmt|;
if|if
condition|(
name|unused_expr_list
condition|)
block|{
name|link
operator|=
name|unused_expr_list
expr_stmt|;
name|unused_expr_list
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|link
operator|=
name|rtx_alloc
argument_list|(
name|EXPR_LIST
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
operator|=
name|mem
expr_stmt|;
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
operator|=
operator|*
name|mem_list
expr_stmt|;
operator|*
name|mem_list
operator|=
name|link
expr_stmt|;
name|pending_lists_length
operator|++
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Make a dependency between every memory reference on the pending lists    and INSN, thus flushing the pending lists.  */
end_comment

begin_function
specifier|static
name|void
name|flush_pending_lists
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|link
decl_stmt|;
while|while
condition|(
name|pending_read_insns
condition|)
block|{
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|pending_read_insns
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
name|link
operator|=
name|pending_read_insns
expr_stmt|;
name|pending_read_insns
operator|=
name|XEXP
argument_list|(
name|pending_read_insns
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
operator|=
name|unused_insn_list
expr_stmt|;
name|unused_insn_list
operator|=
name|link
expr_stmt|;
name|link
operator|=
name|pending_read_mems
expr_stmt|;
name|pending_read_mems
operator|=
name|XEXP
argument_list|(
name|pending_read_mems
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
operator|=
name|unused_expr_list
expr_stmt|;
name|unused_expr_list
operator|=
name|link
expr_stmt|;
block|}
while|while
condition|(
name|pending_write_insns
condition|)
block|{
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|pending_write_insns
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
name|link
operator|=
name|pending_write_insns
expr_stmt|;
name|pending_write_insns
operator|=
name|XEXP
argument_list|(
name|pending_write_insns
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
operator|=
name|unused_insn_list
expr_stmt|;
name|unused_insn_list
operator|=
name|link
expr_stmt|;
name|link
operator|=
name|pending_write_mems
expr_stmt|;
name|pending_write_mems
operator|=
name|XEXP
argument_list|(
name|pending_write_mems
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
operator|=
name|unused_expr_list
expr_stmt|;
name|unused_expr_list
operator|=
name|link
expr_stmt|;
block|}
name|pending_lists_length
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|last_pending_memory_flush
condition|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|last_pending_memory_flush
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
name|last_pending_memory_flush
operator|=
name|insn
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Analyze a single SET or CLOBBER rtx, X, creating all dependencies generated    by the write to the destination of X, and reads of everything mentioned.  */
end_comment

begin_function
specifier|static
name|void
name|sched_analyze_1
parameter_list|(
name|x
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
specifier|register
name|int
name|regno
decl_stmt|;
specifier|register
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|dest
operator|==
literal|0
condition|)
return|return;
while|while
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SIGN_EXTRACT
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SIGN_EXTRACT
condition|)
block|{
comment|/* The second and third arguments are values read by this insn.  */
name|sched_analyze_2
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|1
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|sched_analyze_2
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|2
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
name|dest
operator|=
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
condition|)
block|{
specifier|register
name|int
name|offset
decl_stmt|,
name|bit
decl_stmt|,
name|i
decl_stmt|;
name|regno
operator|=
name|REGNO
argument_list|(
name|dest
argument_list|)
expr_stmt|;
comment|/* A hard reg in a wide mode may really be multiple registers. 	 If so, mark all of them just like the first.  */
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|i
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
block|{
name|rtx
name|u
decl_stmt|;
for|for
control|(
name|u
operator|=
name|reg_last_uses
index|[
name|regno
operator|+
name|i
index|]
init|;
name|u
condition|;
name|u
operator|=
name|XEXP
argument_list|(
name|u
argument_list|,
literal|1
argument_list|)
control|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|u
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
name|reg_last_uses
index|[
name|regno
operator|+
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|reg_last_sets
index|[
name|regno
operator|+
name|i
index|]
condition|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|reg_last_sets
index|[
name|regno
operator|+
name|i
index|]
argument_list|,
name|REG_DEP_OUTPUT
argument_list|)
expr_stmt|;
name|reg_last_sets
index|[
name|regno
operator|+
name|i
index|]
operator|=
name|insn
expr_stmt|;
if|if
condition|(
operator|(
name|call_used_regs
index|[
name|i
index|]
operator|||
name|global_regs
index|[
name|i
index|]
operator|)
operator|&&
name|last_function_call
condition|)
comment|/* Function calls clobber all call_used regs.  */
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|last_function_call
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|rtx
name|u
decl_stmt|;
for|for
control|(
name|u
operator|=
name|reg_last_uses
index|[
name|regno
index|]
init|;
name|u
condition|;
name|u
operator|=
name|XEXP
argument_list|(
name|u
argument_list|,
literal|1
argument_list|)
control|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|u
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
name|reg_last_uses
index|[
name|regno
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|reg_last_sets
index|[
name|regno
index|]
condition|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|reg_last_sets
index|[
name|regno
index|]
argument_list|,
name|REG_DEP_OUTPUT
argument_list|)
expr_stmt|;
name|reg_last_sets
index|[
name|regno
index|]
operator|=
name|insn
expr_stmt|;
comment|/* Pseudos that are REG_EQUIV to something may be replaced 	     by that during reloading.  We need only add dependencies for 	     the address in the REG_EQUIV note.  */
if|if
condition|(
operator|!
name|reload_completed
operator|&&
name|reg_known_equiv_p
index|[
name|regno
index|]
operator|&&
name|GET_CODE
argument_list|(
name|reg_known_value
index|[
name|regno
index|]
argument_list|)
operator|==
name|MEM
condition|)
name|sched_analyze_2
argument_list|(
name|XEXP
argument_list|(
name|reg_known_value
index|[
name|regno
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* Don't let it cross a call after scheduling if it doesn't 	     already cross one.  */
if|if
condition|(
name|reg_n_calls_crossed
index|[
name|regno
index|]
operator|==
literal|0
operator|&&
name|last_function_call
condition|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|last_function_call
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|MEM
condition|)
block|{
comment|/* Writing memory.  */
if|if
condition|(
name|pending_lists_length
operator|>
literal|32
condition|)
block|{
comment|/* Flush all pending reads and writes to prevent the pending lists 	     from getting any larger.  Insn scheduling runs too slowly when 	     these lists get long.  The number 32 was chosen because it 	     seems like a reasonable number.  When compiling GCC with itself, 	     this flush occurs 8 times for sparc, and 10 times for m88k using 	     the number 32.  */
name|flush_pending_lists
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|pending
decl_stmt|,
name|pending_mem
decl_stmt|;
name|pending
operator|=
name|pending_read_insns
expr_stmt|;
name|pending_mem
operator|=
name|pending_read_mems
expr_stmt|;
while|while
condition|(
name|pending
condition|)
block|{
comment|/* If a dependency already exists, don't create a new one.  */
if|if
condition|(
operator|!
name|find_insn_list
argument_list|(
name|XEXP
argument_list|(
name|pending
argument_list|,
literal|0
argument_list|)
argument_list|,
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
if|if
condition|(
name|anti_dependence
argument_list|(
name|XEXP
argument_list|(
name|pending_mem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|dest
argument_list|)
condition|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|pending
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
name|pending
operator|=
name|XEXP
argument_list|(
name|pending
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pending_mem
operator|=
name|XEXP
argument_list|(
name|pending_mem
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|pending
operator|=
name|pending_write_insns
expr_stmt|;
name|pending_mem
operator|=
name|pending_write_mems
expr_stmt|;
while|while
condition|(
name|pending
condition|)
block|{
comment|/* If a dependency already exists, don't create a new one.  */
if|if
condition|(
operator|!
name|find_insn_list
argument_list|(
name|XEXP
argument_list|(
name|pending
argument_list|,
literal|0
argument_list|)
argument_list|,
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
if|if
condition|(
name|output_dependence
argument_list|(
name|XEXP
argument_list|(
name|pending_mem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|dest
argument_list|)
condition|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|pending
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_DEP_OUTPUT
argument_list|)
expr_stmt|;
name|pending
operator|=
name|XEXP
argument_list|(
name|pending
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pending_mem
operator|=
name|XEXP
argument_list|(
name|pending_mem
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|last_pending_memory_flush
condition|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|last_pending_memory_flush
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
name|add_insn_mem_dependence
argument_list|(
operator|&
name|pending_write_insns
argument_list|,
operator|&
name|pending_write_mems
argument_list|,
name|insn
argument_list|,
name|dest
argument_list|)
expr_stmt|;
block|}
name|sched_analyze_2
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* Analyze reads.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SET
condition|)
name|sched_analyze_2
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Analyze the uses of memory and registers in rtx X in INSN.  */
end_comment

begin_function
specifier|static
name|void
name|sched_analyze_2
parameter_list|(
name|x
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CONST
case|:
case|case
name|LABEL_REF
case|:
comment|/* Ignore constants.  Note that we must handle CONST_DOUBLE here 	 because it may have a cc0_rtx in its CONST_DOUBLE_CHAIN field, but 	 this does not mean that this insn is using cc0.  */
return|return;
ifdef|#
directive|ifdef
name|HAVE_cc0
case|case
name|CC0
case|:
block|{
name|rtx
name|link
decl_stmt|,
name|prev
decl_stmt|;
comment|/* There may be a note before this insn now, but all notes will 	   be removed before we actually try to schedule the insns, so 	   it won't cause a problem later.  We must avoid it here though.  */
comment|/* User of CC0 depends on immediately preceding insn.  */
name|SCHED_GROUP_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Make a copy of all dependencies on the immediately previous insn, 	   and add to this insn.  This is so that all the dependencies will 	   apply to the group.  Remove an explicit dependence on this insn 	   as SCHED_GROUP_P now represents it.  */
name|prev
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|prev
argument_list|)
operator|==
name|NOTE
condition|)
name|prev
operator|=
name|PREV_INSN
argument_list|(
name|prev
argument_list|)
expr_stmt|;
if|if
condition|(
name|find_insn_list
argument_list|(
name|prev
argument_list|,
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
name|remove_dependence
argument_list|(
name|insn
argument_list|,
name|prev
argument_list|)
expr_stmt|;
for|for
control|(
name|link
operator|=
name|LOG_LINKS
argument_list|(
name|prev
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
case|case
name|REG
case|:
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|int
name|i
decl_stmt|;
name|i
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
block|{
name|reg_last_uses
index|[
name|regno
operator|+
name|i
index|]
operator|=
name|gen_rtx
argument_list|(
name|INSN_LIST
argument_list|,
name|VOIDmode
argument_list|,
name|insn
argument_list|,
name|reg_last_uses
index|[
name|regno
operator|+
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_last_sets
index|[
name|regno
operator|+
name|i
index|]
condition|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|reg_last_sets
index|[
name|regno
operator|+
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|call_used_regs
index|[
name|regno
operator|+
name|i
index|]
operator|||
name|global_regs
index|[
name|regno
operator|+
name|i
index|]
operator|)
operator|&&
name|last_function_call
condition|)
comment|/* Function calls clobber all call_used regs.  */
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|last_function_call
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|reg_last_uses
index|[
name|regno
index|]
operator|=
name|gen_rtx
argument_list|(
name|INSN_LIST
argument_list|,
name|VOIDmode
argument_list|,
name|insn
argument_list|,
name|reg_last_uses
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_last_sets
index|[
name|regno
index|]
condition|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|reg_last_sets
index|[
name|regno
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Pseudos that are REG_EQUIV to something may be replaced 	       by that during reloading.  We need only add dependencies for 	       the address in the REG_EQUIV note.  */
if|if
condition|(
operator|!
name|reload_completed
operator|&&
name|reg_known_equiv_p
index|[
name|regno
index|]
operator|&&
name|GET_CODE
argument_list|(
name|reg_known_value
index|[
name|regno
index|]
argument_list|)
operator|==
name|MEM
condition|)
name|sched_analyze_2
argument_list|(
name|XEXP
argument_list|(
name|reg_known_value
index|[
name|regno
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* If the register does not already cross any calls, then add this 	       insn to the sched_before_next_call list so that it will still 	       not cross calls after scheduling.  */
if|if
condition|(
name|reg_n_calls_crossed
index|[
name|regno
index|]
operator|==
literal|0
condition|)
name|add_dependence
argument_list|(
name|sched_before_next_call
argument_list|,
name|insn
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
case|case
name|MEM
case|:
block|{
comment|/* Reading memory.  */
name|rtx
name|pending
decl_stmt|,
name|pending_mem
decl_stmt|;
name|pending
operator|=
name|pending_read_insns
expr_stmt|;
name|pending_mem
operator|=
name|pending_read_mems
expr_stmt|;
while|while
condition|(
name|pending
condition|)
block|{
comment|/* If a dependency already exists, don't create a new one.  */
if|if
condition|(
operator|!
name|find_insn_list
argument_list|(
name|XEXP
argument_list|(
name|pending
argument_list|,
literal|0
argument_list|)
argument_list|,
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
if|if
condition|(
name|read_dependence
argument_list|(
name|XEXP
argument_list|(
name|pending_mem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|x
argument_list|)
condition|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|pending
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
name|pending
operator|=
name|XEXP
argument_list|(
name|pending
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pending_mem
operator|=
name|XEXP
argument_list|(
name|pending_mem
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|pending
operator|=
name|pending_write_insns
expr_stmt|;
name|pending_mem
operator|=
name|pending_write_mems
expr_stmt|;
while|while
condition|(
name|pending
condition|)
block|{
comment|/* If a dependency already exists, don't create a new one.  */
if|if
condition|(
operator|!
name|find_insn_list
argument_list|(
name|XEXP
argument_list|(
name|pending
argument_list|,
literal|0
argument_list|)
argument_list|,
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
if|if
condition|(
name|true_dependence
argument_list|(
name|XEXP
argument_list|(
name|pending_mem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|x
argument_list|)
condition|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|pending
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pending
operator|=
name|XEXP
argument_list|(
name|pending
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pending_mem
operator|=
name|XEXP
argument_list|(
name|pending_mem
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|last_pending_memory_flush
condition|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|last_pending_memory_flush
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
comment|/* Always add these dependencies to pending_reads, since 	   this insn may be followed by a write.  */
name|add_insn_mem_dependence
argument_list|(
operator|&
name|pending_read_insns
argument_list|,
operator|&
name|pending_read_mems
argument_list|,
name|insn
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* Take advantage of tail recursion here.  */
name|sched_analyze_2
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|ASM_OPERANDS
case|:
case|case
name|ASM_INPUT
case|:
case|case
name|UNSPEC_VOLATILE
case|:
case|case
name|TRAP_IF
case|:
block|{
name|rtx
name|u
decl_stmt|;
comment|/* Traditional and volatile asm instructions must be considered to use 	   and clobber all hard registers and all of memory.  So must 	   TRAP_IF and UNSPEC_VOLATILE operations.  */
if|if
condition|(
name|code
operator|!=
name|ASM_OPERANDS
operator|||
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|u
operator|=
name|reg_last_uses
index|[
name|i
index|]
init|;
name|u
condition|;
name|u
operator|=
name|XEXP
argument_list|(
name|u
argument_list|,
literal|1
argument_list|)
control|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|u
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
name|reg_last_uses
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|reg_last_sets
index|[
name|i
index|]
condition|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|reg_last_sets
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|reg_last_sets
index|[
name|i
index|]
operator|=
name|insn
expr_stmt|;
block|}
name|flush_pending_lists
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* For all ASM_OPERANDS, we must traverse the vector of input operands. 	   We can not just fall through here since then we would be confused 	   by the ASM_INPUT rtx inside ASM_OPERANDS, which do not indicate 	   traditional asms unlike their normal usage.  */
if|if
condition|(
name|code
operator|==
name|ASM_OPERANDS
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|x
argument_list|)
condition|;
name|j
operator|++
control|)
name|sched_analyze_2
argument_list|(
name|ASM_OPERANDS_INPUT
argument_list|(
name|x
argument_list|,
name|j
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
block|}
case|case
name|PRE_DEC
case|:
case|case
name|POST_DEC
case|:
case|case
name|PRE_INC
case|:
case|case
name|POST_INC
case|:
comment|/* These both read and modify the result.  We must handle them as writes 	 to get proper dependencies for following instructions.  We must handle 	 them as reads to get proper dependencies from this to previous 	 instructions.  Thus we need to pass them to both sched_analyze_1 	 and sched_analyze_2.  We must call sched_analyze_2 first in order 	 to get the proper antecedent for the read.  */
name|sched_analyze_2
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|sched_analyze_1
argument_list|(
name|x
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Other cases: walk the insn.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|sched_analyze_2
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|sched_analyze_2
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Analyze an INSN with pattern X to find all dependencies.  */
end_comment

begin_function
specifier|static
name|void
name|sched_analyze_insn
parameter_list|(
name|x
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|insn
decl_stmt|;
block|{
specifier|register
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|rtx
name|link
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|SET
operator|||
name|code
operator|==
name|CLOBBER
condition|)
name|sched_analyze_1
argument_list|(
name|x
argument_list|,
name|insn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|PARALLEL
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|code
operator|=
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|SET
operator|||
name|code
operator|==
name|CLOBBER
condition|)
name|sched_analyze_1
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
else|else
name|sched_analyze_2
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|sched_analyze_2
argument_list|(
name|x
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* Handle function calls.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|rtx
name|dep_insn
decl_stmt|;
name|rtx
name|prev_dep_insn
decl_stmt|;
comment|/* When scheduling instructions, we make sure calls don't lose their 	 accompanying USE insns by depending them one on another in order.   */
name|prev_dep_insn
operator|=
name|insn
expr_stmt|;
name|dep_insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|dep_insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|dep_insn
argument_list|)
argument_list|)
operator|==
name|USE
condition|)
block|{
name|SCHED_GROUP_P
argument_list|(
name|prev_dep_insn
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Make a copy of all dependencies on dep_insn, and add to insn. 	     This is so that all of the dependencies will apply to the 	     group.  */
for|for
control|(
name|link
operator|=
name|LOG_LINKS
argument_list|(
name|dep_insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
argument_list|)
expr_stmt|;
name|prev_dep_insn
operator|=
name|dep_insn
expr_stmt|;
name|dep_insn
operator|=
name|PREV_INSN
argument_list|(
name|dep_insn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Analyze every insn between HEAD and TAIL inclusive, creating LOG_LINKS    for every dependency.  */
end_comment

begin_function
specifier|static
name|int
name|sched_analyze
parameter_list|(
name|head
parameter_list|,
name|tail
parameter_list|)
name|rtx
name|head
decl_stmt|,
name|tail
decl_stmt|;
block|{
specifier|register
name|rtx
name|insn
decl_stmt|;
specifier|register
name|int
name|n_insns
init|=
literal|0
decl_stmt|;
specifier|register
name|rtx
name|u
decl_stmt|;
specifier|register
name|int
name|luid
init|=
literal|0
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|head
init|;
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
operator|=
name|luid
operator|++
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
name|sched_analyze_insn
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|n_insns
operator|+=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|rtx
name|dest
init|=
literal|0
decl_stmt|;
name|rtx
name|x
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Any instruction using a hard register which may get clobbered 	     by a call needs to be marked as dependent on this call. 	     This prevents a use of a hard return reg from being moved 	     past a void call (i.e. it does not explicitly set the hard 	     return reg).  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|call_used_regs
index|[
name|i
index|]
operator|||
name|global_regs
index|[
name|i
index|]
condition|)
block|{
for|for
control|(
name|u
operator|=
name|reg_last_uses
index|[
name|i
index|]
init|;
name|u
condition|;
name|u
operator|=
name|XEXP
argument_list|(
name|u
argument_list|,
literal|1
argument_list|)
control|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|u
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
name|reg_last_uses
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|reg_last_sets
index|[
name|i
index|]
condition|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|reg_last_sets
index|[
name|i
index|]
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
name|reg_last_sets
index|[
name|i
index|]
operator|=
name|insn
expr_stmt|;
comment|/* Insn, being a CALL_INSN, magically depends on 		   `last_function_call' already.  */
block|}
comment|/* For each insn which shouldn't cross a call, add a dependence 	     between that insn and this call insn.  */
name|x
operator|=
name|LOG_LINKS
argument_list|(
name|sched_before_next_call
argument_list|)
expr_stmt|;
while|while
condition|(
name|x
condition|)
block|{
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|LOG_LINKS
argument_list|(
name|sched_before_next_call
argument_list|)
operator|=
literal|0
expr_stmt|;
name|sched_analyze_insn
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* We don't need to flush memory for a function call which does 	     not involve memory.  */
if|if
condition|(
operator|!
name|CONST_CALL_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
comment|/* In the absence of interprocedural alias analysis, 		 we must flush all pending reads and writes, and 		 start new dependencies starting from here.  */
name|flush_pending_lists
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* Depend this function call (actually, the user of this 	     function call) on all hard register clobberage.  */
name|last_function_call
operator|=
name|insn
expr_stmt|;
name|n_insns
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|insn
operator|==
name|tail
condition|)
return|return
name|n_insns
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Called when we see a set of a register.  If death is true, then we are    scanning backwards.  Mark that register as unborn.  If nobody says    otherwise, that is how things will remain.  If death is false, then we    are scanning forwards.  Mark that register as being born.  */
end_comment

begin_function
specifier|static
name|void
name|sched_note_set
parameter_list|(
name|b
parameter_list|,
name|x
parameter_list|,
name|death
parameter_list|)
name|int
name|b
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|int
name|death
decl_stmt|;
block|{
specifier|register
name|int
name|regno
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|rtx
name|reg
init|=
name|SET_DEST
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|int
name|subreg_p
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|reg
operator|==
literal|0
condition|)
return|return;
while|while
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
block|{
comment|/* Must treat modification of just one hardware register of a multi-reg 	 value or just a byte field of a register exactly the same way that 	 mark_set_1 in flow.c does, i.e. anything except a paradoxical subreg 	 does not kill the entire register.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|!=
name|SUBREG
operator|||
name|REG_SIZE
argument_list|(
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|>
name|REG_SIZE
argument_list|(
name|reg
argument_list|)
condition|)
name|subreg_p
operator|=
literal|1
expr_stmt|;
name|reg
operator|=
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|!=
name|REG
condition|)
return|return;
comment|/* Global registers are always live, so the code below does not apply      to them.  */
name|regno
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
operator|!
name|global_regs
index|[
name|regno
index|]
condition|)
block|{
specifier|register
name|int
name|offset
init|=
name|regno
operator|/
name|REGSET_ELT_BITS
decl_stmt|;
specifier|register
name|REGSET_ELT_TYPE
name|bit
init|=
operator|(
name|REGSET_ELT_TYPE
operator|)
literal|1
operator|<<
operator|(
name|regno
operator|%
name|REGSET_ELT_BITS
operator|)
decl_stmt|;
if|if
condition|(
name|death
condition|)
block|{
comment|/* If we only set part of the register, then this set does not 	     kill it.  */
if|if
condition|(
name|subreg_p
condition|)
return|return;
comment|/* Try killing this register.  */
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|int
name|j
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
operator|--
name|j
operator|>=
literal|0
condition|)
block|{
name|offset
operator|=
operator|(
name|regno
operator|+
name|j
operator|)
operator|/
name|REGSET_ELT_BITS
expr_stmt|;
name|bit
operator|=
operator|(
name|REGSET_ELT_TYPE
operator|)
literal|1
operator|<<
operator|(
operator|(
name|regno
operator|+
name|j
operator|)
operator|%
name|REGSET_ELT_BITS
operator|)
expr_stmt|;
name|bb_live_regs
index|[
name|offset
index|]
operator|&=
operator|~
name|bit
expr_stmt|;
name|bb_dead_regs
index|[
name|offset
index|]
operator||=
name|bit
expr_stmt|;
block|}
block|}
else|else
block|{
name|bb_live_regs
index|[
name|offset
index|]
operator|&=
operator|~
name|bit
expr_stmt|;
name|bb_dead_regs
index|[
name|offset
index|]
operator||=
name|bit
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Make the register live again.  */
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|int
name|j
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
operator|--
name|j
operator|>=
literal|0
condition|)
block|{
name|offset
operator|=
operator|(
name|regno
operator|+
name|j
operator|)
operator|/
name|REGSET_ELT_BITS
expr_stmt|;
name|bit
operator|=
operator|(
name|REGSET_ELT_TYPE
operator|)
literal|1
operator|<<
operator|(
operator|(
name|regno
operator|+
name|j
operator|)
operator|%
name|REGSET_ELT_BITS
operator|)
expr_stmt|;
name|bb_live_regs
index|[
name|offset
index|]
operator||=
name|bit
expr_stmt|;
name|bb_dead_regs
index|[
name|offset
index|]
operator|&=
operator|~
name|bit
expr_stmt|;
block|}
block|}
else|else
block|{
name|bb_live_regs
index|[
name|offset
index|]
operator||=
name|bit
expr_stmt|;
name|bb_dead_regs
index|[
name|offset
index|]
operator|&=
operator|~
name|bit
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Macros and functions for keeping the priority queue sorted, and    dealing with queueing and unqueueing of instructions.  */
end_comment

begin_define
define|#
directive|define
name|SCHED_SORT
parameter_list|(
name|READY
parameter_list|,
name|NEW_READY
parameter_list|,
name|OLD_READY
parameter_list|)
define|\
value|do { if ((NEW_READY) - (OLD_READY) == 1)				\ 	 swap_sort (READY, NEW_READY);					\        else if ((NEW_READY) - (OLD_READY)> 1)				\ 	 qsort (READY, NEW_READY, sizeof (rtx), rank_for_schedule); }	\   while (0)
end_define

begin_comment
comment|/* Returns a positive value if y is preferred; returns a negative value if    x is preferred.  Should never return 0, since that will make the sort    unstable.  */
end_comment

begin_function
specifier|static
name|int
name|rank_for_schedule
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|rtx
modifier|*
name|x
decl_stmt|,
decl|*
name|y
decl_stmt|;
end_function

begin_block
block|{
name|rtx
name|tmp
init|=
operator|*
name|y
decl_stmt|;
name|rtx
name|tmp2
init|=
operator|*
name|x
decl_stmt|;
name|rtx
name|link
decl_stmt|;
name|int
name|tmp_class
decl_stmt|,
name|tmp2_class
decl_stmt|;
name|int
name|value
decl_stmt|;
comment|/* Choose the instruction with the highest priority, if different.  */
if|if
condition|(
name|value
operator|=
name|INSN_PRIORITY
argument_list|(
name|tmp
argument_list|)
operator|-
name|INSN_PRIORITY
argument_list|(
name|tmp2
argument_list|)
condition|)
return|return
name|value
return|;
if|if
condition|(
name|last_scheduled_insn
condition|)
block|{
comment|/* Classify the instructions into three classes: 	 1) Data dependent on last schedule insn. 	 2) Anti/Output dependent on last scheduled insn. 	 3) Independent of last scheduled insn, or has latency of one. 	 Choose the insn from the highest numbered class if different.  */
name|link
operator|=
name|find_insn_list
argument_list|(
name|tmp
argument_list|,
name|LOG_LINKS
argument_list|(
name|last_scheduled_insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|link
operator|==
literal|0
operator|||
name|insn_cost
argument_list|(
name|tmp
argument_list|,
name|link
argument_list|,
name|last_scheduled_insn
argument_list|)
operator|==
literal|1
condition|)
name|tmp_class
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
literal|0
condition|)
comment|/* Data dependence.  */
name|tmp_class
operator|=
literal|1
expr_stmt|;
else|else
name|tmp_class
operator|=
literal|2
expr_stmt|;
name|link
operator|=
name|find_insn_list
argument_list|(
name|tmp2
argument_list|,
name|LOG_LINKS
argument_list|(
name|last_scheduled_insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|link
operator|==
literal|0
operator|||
name|insn_cost
argument_list|(
name|tmp2
argument_list|,
name|link
argument_list|,
name|last_scheduled_insn
argument_list|)
operator|==
literal|1
condition|)
name|tmp2_class
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
literal|0
condition|)
comment|/* Data dependence.  */
name|tmp2_class
operator|=
literal|1
expr_stmt|;
else|else
name|tmp2_class
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|value
operator|=
name|tmp_class
operator|-
name|tmp2_class
condition|)
return|return
name|value
return|;
block|}
comment|/* If insns are equally good, sort by INSN_LUID (original insn order),      so that we make the sort stable.  This minimizes instruction movement,      thus minimizing sched's effect on debugging and cross-jumping.  */
return|return
name|INSN_LUID
argument_list|(
name|tmp
argument_list|)
operator|-
name|INSN_LUID
argument_list|(
name|tmp2
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/* Resort the array A in which only element at index N may be out of order.  */
end_comment

begin_function
name|__inline
specifier|static
name|void
name|swap_sort
parameter_list|(
name|a
parameter_list|,
name|n
parameter_list|)
name|rtx
modifier|*
name|a
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
name|rtx
name|insn
init|=
name|a
index|[
name|n
operator|-
literal|1
index|]
decl_stmt|;
name|int
name|i
init|=
name|n
operator|-
literal|2
decl_stmt|;
while|while
condition|(
name|i
operator|>=
literal|0
operator|&&
name|rank_for_schedule
argument_list|(
name|a
operator|+
name|i
argument_list|,
operator|&
name|insn
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|a
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|a
index|[
name|i
index|]
expr_stmt|;
name|i
operator|-=
literal|1
expr_stmt|;
block|}
name|a
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|insn
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|max_priority
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Add INSN to the insn queue so that it fires at least N_CYCLES    before the currently executing insn.  */
end_comment

begin_function
name|__inline
specifier|static
name|void
name|queue_insn
parameter_list|(
name|insn
parameter_list|,
name|n_cycles
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|int
name|n_cycles
decl_stmt|;
block|{
name|int
name|next_q
init|=
name|NEXT_Q_AFTER
argument_list|(
name|q_ptr
argument_list|,
name|n_cycles
argument_list|)
decl_stmt|;
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|insn_queue
index|[
name|next_q
index|]
expr_stmt|;
name|insn_queue
index|[
name|next_q
index|]
operator|=
name|insn
expr_stmt|;
name|q_size
operator|+=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return nonzero if PAT is the pattern of an insn which makes a    register live.  */
end_comment

begin_function
name|__inline
specifier|static
name|int
name|birthing_insn_p
parameter_list|(
name|pat
parameter_list|)
name|rtx
name|pat
decl_stmt|;
block|{
name|int
name|j
decl_stmt|;
if|if
condition|(
name|reload_completed
operator|==
literal|1
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|pat
argument_list|)
decl_stmt|;
name|int
name|i
init|=
name|REGNO
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|int
name|offset
init|=
name|i
operator|/
name|REGSET_ELT_BITS
decl_stmt|;
name|REGSET_ELT_TYPE
name|bit
init|=
operator|(
name|REGSET_ELT_TYPE
operator|)
literal|1
operator|<<
operator|(
name|i
operator|%
name|REGSET_ELT_BITS
operator|)
decl_stmt|;
comment|/* It would be more accurate to use refers_to_regno_p or 	 reg_mentioned_p to determine when the dest is not live before this 	 insn.  */
if|if
condition|(
name|bb_live_regs
index|[
name|offset
index|]
operator|&
name|bit
condition|)
return|return
operator|(
name|reg_n_sets
index|[
name|i
index|]
operator|==
literal|1
operator|)
return|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|birthing_insn_p
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* PREV is an insn that is ready to execute.  Adjust its priority if that    will help shorten register lifetimes.  */
end_comment

begin_function
name|__inline
specifier|static
name|void
name|adjust_priority
parameter_list|(
name|prev
parameter_list|)
name|rtx
name|prev
decl_stmt|;
block|{
comment|/* Trying to shorten register lives after reload has completed      is useless and wrong.  It gives inaccurate schedules.  */
if|if
condition|(
name|reload_completed
operator|==
literal|0
condition|)
block|{
name|rtx
name|note
decl_stmt|;
name|int
name|n_deaths
init|=
literal|0
decl_stmt|;
comment|/* ??? This code has no effect, because REG_DEAD notes are removed 	 before we ever get here.  */
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|prev
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_DEAD
condition|)
name|n_deaths
operator|+=
literal|1
expr_stmt|;
comment|/* Defer scheduling insns which kill registers, since that 	 shortens register lives.  Prefer scheduling insns which 	 make registers live for the same reason.  */
switch|switch
condition|(
name|n_deaths
condition|)
block|{
default|default:
name|INSN_PRIORITY
argument_list|(
name|prev
argument_list|)
operator|>>=
literal|3
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|INSN_PRIORITY
argument_list|(
name|prev
argument_list|)
operator|>>=
literal|2
expr_stmt|;
break|break;
case|case
literal|2
case|:
case|case
literal|1
case|:
name|INSN_PRIORITY
argument_list|(
name|prev
argument_list|)
operator|>>=
literal|1
expr_stmt|;
break|break;
case|case
literal|0
case|:
if|if
condition|(
name|birthing_insn_p
argument_list|(
name|PATTERN
argument_list|(
name|prev
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|max
init|=
name|max_priority
decl_stmt|;
if|if
condition|(
name|max
operator|>
name|INSN_PRIORITY
argument_list|(
name|prev
argument_list|)
condition|)
name|INSN_PRIORITY
argument_list|(
name|prev
argument_list|)
operator|=
name|max
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* INSN is the "currently executing insn".  Launch each insn which was    waiting on INSN (in the backwards dataflow sense).  READY is a    vector of insns which are ready to fire.  N_READY is the number of    elements in READY.  CLOCK is the current virtual cycle.  */
end_comment

begin_function
specifier|static
name|int
name|schedule_insn
parameter_list|(
name|insn
parameter_list|,
name|ready
parameter_list|,
name|n_ready
parameter_list|,
name|clock
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
modifier|*
name|ready
decl_stmt|;
name|int
name|n_ready
decl_stmt|;
name|int
name|clock
decl_stmt|;
block|{
name|rtx
name|link
decl_stmt|;
name|int
name|new_ready
init|=
name|n_ready
decl_stmt|;
if|if
condition|(
name|MAX_BLOCKAGE
operator|>
literal|1
condition|)
name|schedule_unit
argument_list|(
name|insn_unit
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|,
name|clock
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
operator|==
literal|0
condition|)
return|return
name|n_ready
return|;
comment|/* This is used by the function adjust_priority above.  */
if|if
condition|(
name|n_ready
operator|>
literal|0
condition|)
name|max_priority
operator|=
name|MAX
argument_list|(
name|INSN_PRIORITY
argument_list|(
name|ready
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|INSN_PRIORITY
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|max_priority
operator|=
name|INSN_PRIORITY
argument_list|(
name|insn
argument_list|)
expr_stmt|;
for|for
control|(
name|link
operator|=
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
init|;
name|link
operator|!=
literal|0
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|rtx
name|prev
init|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|cost
init|=
name|insn_cost
argument_list|(
name|prev
argument_list|,
name|link
argument_list|,
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|INSN_REF_COUNT
argument_list|(
name|prev
argument_list|)
operator|-=
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* We satisfied one requirement to fire PREV.  Record the earliest 	     time when PREV can fire.  No need to do this if the cost is 1, 	     because PREV can fire no sooner than the next cycle.  */
if|if
condition|(
name|cost
operator|>
literal|1
condition|)
name|INSN_TICK
argument_list|(
name|prev
argument_list|)
operator|=
name|MAX
argument_list|(
name|INSN_TICK
argument_list|(
name|prev
argument_list|)
argument_list|,
name|clock
operator|+
name|cost
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We satisfied the last requirement to fire PREV.  Ensure that all 	     timing requirements are satisfied.  */
if|if
condition|(
name|INSN_TICK
argument_list|(
name|prev
argument_list|)
operator|-
name|clock
operator|>
name|cost
condition|)
name|cost
operator|=
name|INSN_TICK
argument_list|(
name|prev
argument_list|)
operator|-
name|clock
expr_stmt|;
comment|/* Adjust the priority of PREV and either put it on the ready 	     list or queue it.  */
name|adjust_priority
argument_list|(
name|prev
argument_list|)
expr_stmt|;
if|if
condition|(
name|cost
operator|<=
literal|1
condition|)
name|ready
index|[
name|new_ready
operator|++
index|]
operator|=
name|prev
expr_stmt|;
else|else
name|queue_insn
argument_list|(
name|prev
argument_list|,
name|cost
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|new_ready
return|;
block|}
end_function

begin_comment
comment|/* Given N_READY insns in the ready list READY at time CLOCK, queue    those that are blocked due to function unit hazards and rearrange    the remaining ones to minimize subsequent function unit hazards.  */
end_comment

begin_function
specifier|static
name|int
name|schedule_select
parameter_list|(
name|ready
parameter_list|,
name|n_ready
parameter_list|,
name|clock
parameter_list|,
name|file
parameter_list|)
name|rtx
modifier|*
name|ready
decl_stmt|;
name|int
name|n_ready
decl_stmt|,
name|clock
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|int
name|pri
init|=
name|INSN_PRIORITY
argument_list|(
name|ready
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|q
decl_stmt|,
name|cost
decl_stmt|,
name|best_cost
decl_stmt|,
name|best_insn
init|=
literal|0
decl_stmt|,
name|new_ready
init|=
name|n_ready
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
comment|/* Work down the ready list in groups of instructions with the same      priority value.  Queue insns in the group that are blocked and      select among those that remain for the one with the largest      potential hazard.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_ready
condition|;
name|i
operator|=
name|j
control|)
block|{
name|int
name|opri
init|=
name|pri
decl_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|n_ready
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|(
name|pri
operator|=
name|INSN_PRIORITY
argument_list|(
name|ready
index|[
name|j
index|]
argument_list|)
operator|)
operator|!=
name|opri
condition|)
break|break;
comment|/* Queue insns in the group that are blocked.  */
for|for
control|(
name|k
operator|=
name|i
operator|,
name|q
operator|=
literal|0
init|;
name|k
operator|<
name|j
condition|;
name|k
operator|++
control|)
block|{
name|insn
operator|=
name|ready
index|[
name|k
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|cost
operator|=
name|actual_hazard
argument_list|(
name|insn_unit
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|,
name|clock
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|q
operator|++
expr_stmt|;
name|ready
index|[
name|k
index|]
operator|=
literal|0
expr_stmt|;
name|queue_insn
argument_list|(
name|insn
argument_list|,
name|cost
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n;; blocking insn %d for %d cycles"
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|,
name|cost
argument_list|)
expr_stmt|;
block|}
block|}
name|new_ready
operator|-=
name|q
expr_stmt|;
comment|/* Check the next group if all insns were queued.  */
if|if
condition|(
name|j
operator|-
name|i
operator|-
name|q
operator|==
literal|0
condition|)
continue|continue;
comment|/* If more than one remains, select the first one with the largest 	 potential hazard.  */
elseif|else
if|if
condition|(
name|j
operator|-
name|i
operator|-
name|q
operator|>
literal|1
condition|)
block|{
name|best_cost
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|k
operator|=
name|i
init|;
name|k
operator|<
name|j
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|insn
operator|=
name|ready
index|[
name|k
index|]
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|cost
operator|=
name|potential_hazard
argument_list|(
name|insn_unit
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
operator|)
operator|>
name|best_cost
condition|)
block|{
name|best_cost
operator|=
name|cost
expr_stmt|;
name|best_insn
operator|=
name|k
expr_stmt|;
block|}
block|}
block|}
comment|/* We have found a suitable insn to schedule.  */
break|break;
block|}
comment|/* Move the best insn to be front of the ready list.  */
if|if
condition|(
name|best_insn
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|file
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|", now"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_ready
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ready
index|[
name|i
index|]
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %d"
argument_list|,
name|INSN_UID
argument_list|(
name|ready
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n;; insn %d has a greater potential hazard"
argument_list|,
name|INSN_UID
argument_list|(
name|ready
index|[
name|best_insn
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|best_insn
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|insn
operator|=
name|ready
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|ready
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|ready
index|[
name|i
index|]
expr_stmt|;
name|ready
index|[
name|i
index|]
operator|=
name|insn
expr_stmt|;
block|}
block|}
comment|/* Compact the ready list.  */
if|if
condition|(
name|new_ready
operator|<
name|n_ready
condition|)
for|for
control|(
name|i
operator|=
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|n_ready
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ready
index|[
name|i
index|]
condition|)
name|ready
index|[
name|j
operator|++
index|]
operator|=
name|ready
index|[
name|i
index|]
expr_stmt|;
return|return
name|new_ready
return|;
block|}
end_function

begin_comment
comment|/* Add a REG_DEAD note for REG to INSN, reusing a REG_DEAD note from the    dead_notes list.  */
end_comment

begin_function
specifier|static
name|void
name|create_reg_dead_note
parameter_list|(
name|reg
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|reg
decl_stmt|,
name|insn
decl_stmt|;
block|{
name|rtx
name|link
decl_stmt|,
name|backlink
decl_stmt|;
comment|/* The number of registers killed after scheduling must be the same as the      number of registers killed before scheduling.  The number of REG_DEAD      notes may not be conserved, i.e. two SImode hard register REG_DEAD notes      might become one DImode hard register REG_DEAD note, but the number of      registers killed will be conserved.            We carefully remove REG_DEAD notes from the dead_notes list, so that      there will be none left at the end.  If we run out early, then there      is a bug somewhere in flow, combine and/or sched.  */
if|if
condition|(
name|dead_notes
operator|==
literal|0
condition|)
block|{
if|#
directive|if
literal|1
name|abort
argument_list|()
expr_stmt|;
else|#
directive|else
name|link
operator|=
name|rtx_alloc
argument_list|(
name|EXPR_LIST
argument_list|)
expr_stmt|;
name|PUT_REG_NOTE_KIND
argument_list|(
name|link
argument_list|,
name|REG_DEAD
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* Number of regs killed by REG.  */
name|int
name|regs_killed
init|=
operator|(
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|?
literal|1
else|:
name|HARD_REGNO_NREGS
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|)
decl_stmt|;
comment|/* Number of regs killed by REG_DEAD notes taken off the list.  */
name|int
name|reg_note_regs
decl_stmt|;
name|link
operator|=
name|dead_notes
expr_stmt|;
name|reg_note_regs
operator|=
operator|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|?
literal|1
else|:
name|HARD_REGNO_NREGS
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
expr_stmt|;
while|while
condition|(
name|reg_note_regs
operator|<
name|regs_killed
condition|)
block|{
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|reg_note_regs
operator|+=
operator|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|?
literal|1
else|:
name|HARD_REGNO_NREGS
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
expr_stmt|;
block|}
name|dead_notes
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* If we took too many regs kills off, put the extra ones back.  */
while|while
condition|(
name|reg_note_regs
operator|>
name|regs_killed
condition|)
block|{
name|rtx
name|temp_reg
decl_stmt|,
name|temp_link
decl_stmt|;
name|temp_reg
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|word_mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|temp_link
operator|=
name|rtx_alloc
argument_list|(
name|EXPR_LIST
argument_list|)
expr_stmt|;
name|PUT_REG_NOTE_KIND
argument_list|(
name|temp_link
argument_list|,
name|REG_DEAD
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|temp_link
argument_list|,
literal|0
argument_list|)
operator|=
name|temp_reg
expr_stmt|;
name|XEXP
argument_list|(
name|temp_link
argument_list|,
literal|1
argument_list|)
operator|=
name|dead_notes
expr_stmt|;
name|dead_notes
operator|=
name|temp_link
expr_stmt|;
name|reg_note_regs
operator|--
expr_stmt|;
block|}
block|}
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
operator|=
name|reg
expr_stmt|;
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|link
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Subroutine on attach_deaths_insn--handles the recursive search    through INSN.  If SET_P is true, then x is being modified by the insn.  */
end_comment

begin_function
specifier|static
name|void
name|attach_deaths
parameter_list|(
name|x
parameter_list|,
name|insn
parameter_list|,
name|set_p
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|set_p
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|LABEL_REF
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CONST
case|:
case|case
name|CODE_LABEL
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
comment|/* Get rid of the easy cases first.  */
return|return;
case|case
name|REG
case|:
block|{
comment|/* If the register dies in this insn, queue that note, and mark 	   this register as needing to die.  */
comment|/* This code is very similar to mark_used_1 (if set_p is false) 	   and mark_set_1 (if set_p is true) in flow.c.  */
specifier|register
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|x
argument_list|)
decl_stmt|;
specifier|register
name|int
name|offset
init|=
name|regno
operator|/
name|REGSET_ELT_BITS
decl_stmt|;
specifier|register
name|REGSET_ELT_TYPE
name|bit
init|=
operator|(
name|REGSET_ELT_TYPE
operator|)
literal|1
operator|<<
operator|(
name|regno
operator|%
name|REGSET_ELT_BITS
operator|)
decl_stmt|;
name|REGSET_ELT_TYPE
name|all_needed
init|=
operator|(
name|old_live_regs
index|[
name|offset
index|]
operator|&
name|bit
operator|)
decl_stmt|;
name|REGSET_ELT_TYPE
name|some_needed
init|=
operator|(
name|old_live_regs
index|[
name|offset
index|]
operator|&
name|bit
operator|)
decl_stmt|;
if|if
condition|(
name|set_p
condition|)
return|return;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|int
name|n
decl_stmt|;
name|n
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|n
operator|>
literal|0
condition|)
block|{
name|some_needed
operator||=
operator|(
name|old_live_regs
index|[
operator|(
name|regno
operator|+
name|n
operator|)
operator|/
name|REGSET_ELT_BITS
index|]
operator|&
operator|(
operator|(
name|REGSET_ELT_TYPE
operator|)
literal|1
operator|<<
operator|(
operator|(
name|regno
operator|+
name|n
operator|)
operator|%
name|REGSET_ELT_BITS
operator|)
operator|)
operator|)
expr_stmt|;
name|all_needed
operator|&=
operator|(
name|old_live_regs
index|[
operator|(
name|regno
operator|+
name|n
operator|)
operator|/
name|REGSET_ELT_BITS
index|]
operator|&
operator|(
operator|(
name|REGSET_ELT_TYPE
operator|)
literal|1
operator|<<
operator|(
operator|(
name|regno
operator|+
name|n
operator|)
operator|%
name|REGSET_ELT_BITS
operator|)
operator|)
operator|)
expr_stmt|;
block|}
block|}
comment|/* If it wasn't live before we started, then add a REG_DEAD note. 	   We must check the previous lifetime info not the current info, 	   because we may have to execute this code several times, e.g. 	   once for a clobber (which doesn't add a note) and later 	   for a use (which does add a note). 	    	   Always make the register live.  We must do this even if it was 	   live before, because this may be an insn which sets and uses 	   the same register, in which case the register has already been 	   killed, so we must make it live again.  	   Global registers are always live, and should never have a REG_DEAD 	   note added for them, so none of the code below applies to them.  */
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
operator|!
name|global_regs
index|[
name|regno
index|]
condition|)
block|{
comment|/* Never add REG_DEAD notes for the FRAME_POINTER_REGNUM or the 	       STACK_POINTER_REGNUM, since these are always considered to be 	       live.  Similarly for ARG_POINTER_REGNUM if it is fixed.  */
if|if
condition|(
name|regno
operator|!=
name|FRAME_POINTER_REGNUM
if|#
directive|if
name|ARG_POINTER_REGNUM
operator|!=
name|FRAME_POINTER_REGNUM
operator|&&
operator|!
operator|(
name|regno
operator|==
name|ARG_POINTER_REGNUM
operator|&&
name|fixed_regs
index|[
name|regno
index|]
operator|)
endif|#
directive|endif
operator|&&
name|regno
operator|!=
name|STACK_POINTER_REGNUM
condition|)
block|{
if|if
condition|(
operator|!
name|all_needed
operator|&&
operator|!
name|dead_or_set_p
argument_list|(
name|insn
argument_list|,
name|x
argument_list|)
condition|)
block|{
comment|/* If none of the words in X is needed, make a REG_DEAD 		       note.  Otherwise, we must make partial REG_DEAD 		       notes.  */
if|if
condition|(
operator|!
name|some_needed
condition|)
name|create_reg_dead_note
argument_list|(
name|x
argument_list|,
name|insn
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|i
decl_stmt|;
comment|/* Don't make a REG_DEAD note for a part of a 			   register that is set in the insn.  */
for|for
control|(
name|i
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
operator|(
name|old_live_regs
index|[
operator|(
name|regno
operator|+
name|i
operator|)
operator|/
name|REGSET_ELT_BITS
index|]
operator|&
operator|(
operator|(
name|REGSET_ELT_TYPE
operator|)
literal|1
operator|<<
operator|(
operator|(
name|regno
operator|+
name|i
operator|)
operator|%
name|REGSET_ELT_BITS
operator|)
operator|)
operator|)
operator|==
literal|0
operator|&&
operator|!
name|dead_or_set_regno_p
argument_list|(
name|insn
argument_list|,
name|regno
operator|+
name|i
argument_list|)
condition|)
name|create_reg_dead_note
argument_list|(
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|word_mode
argument_list|,
name|regno
operator|+
name|i
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|int
name|j
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
operator|--
name|j
operator|>=
literal|0
condition|)
block|{
name|offset
operator|=
operator|(
name|regno
operator|+
name|j
operator|)
operator|/
name|REGSET_ELT_BITS
expr_stmt|;
name|bit
operator|=
operator|(
name|REGSET_ELT_TYPE
operator|)
literal|1
operator|<<
operator|(
operator|(
name|regno
operator|+
name|j
operator|)
operator|%
name|REGSET_ELT_BITS
operator|)
expr_stmt|;
name|bb_dead_regs
index|[
name|offset
index|]
operator|&=
operator|~
name|bit
expr_stmt|;
name|bb_live_regs
index|[
name|offset
index|]
operator||=
name|bit
expr_stmt|;
block|}
block|}
else|else
block|{
name|bb_dead_regs
index|[
name|offset
index|]
operator|&=
operator|~
name|bit
expr_stmt|;
name|bb_live_regs
index|[
name|offset
index|]
operator||=
name|bit
expr_stmt|;
block|}
block|}
return|return;
block|}
case|case
name|MEM
case|:
comment|/* Handle tail-recursive case.  */
name|attach_deaths
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
name|SUBREG
case|:
case|case
name|STRICT_LOW_PART
case|:
comment|/* These two cases preserve the value of SET_P, so handle them 	 separately.  */
name|attach_deaths
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|,
name|set_p
argument_list|)
expr_stmt|;
return|return;
case|case
name|ZERO_EXTRACT
case|:
case|case
name|SIGN_EXTRACT
case|:
comment|/* This case preserves the value of SET_P for the first operand, but 	 clears it for the other two.  */
name|attach_deaths
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|,
name|set_p
argument_list|)
expr_stmt|;
name|attach_deaths
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|attach_deaths
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
default|default:
comment|/* Other cases: walk the insn.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|attach_deaths
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|attach_deaths
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* After INSN has executed, add register death notes for each register    that is dead after INSN.  */
end_comment

begin_function
specifier|static
name|void
name|attach_deaths_insn
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|x
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
specifier|register
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|SET
condition|)
block|{
name|attach_deaths
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* A register might die here even if it is the destination, e.g. 	 it is the target of a volatile read and is otherwise unused. 	 Hence we must always call attach_deaths for the SET_DEST.  */
name|attach_deaths
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|PARALLEL
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|code
operator|=
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|SET
condition|)
block|{
name|attach_deaths
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|attach_deaths
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Flow does not add REG_DEAD notes to registers that die in 	     clobbers, so we can't either.  */
elseif|else
if|if
condition|(
name|code
operator|!=
name|CLOBBER
condition|)
name|attach_deaths
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Flow does not add REG_DEAD notes to registers that die in      clobbers, so we can't either.  */
elseif|else
if|if
condition|(
name|code
operator|!=
name|CLOBBER
condition|)
name|attach_deaths
argument_list|(
name|x
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Delete notes beginning with INSN and maybe put them in the chain    of notes ended by NOTE_LIST.    Returns the insn following the notes.  */
end_comment

begin_function
specifier|static
name|rtx
name|unlink_notes
parameter_list|(
name|insn
parameter_list|,
name|tail
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|tail
decl_stmt|;
block|{
name|rtx
name|prev
init|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
while|while
condition|(
name|insn
operator|!=
name|tail
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
block|{
name|rtx
name|next
init|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* Delete the note from its current position.  */
if|if
condition|(
name|prev
condition|)
name|NEXT_INSN
argument_list|(
name|prev
argument_list|)
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|next
condition|)
name|PREV_INSN
argument_list|(
name|next
argument_list|)
operator|=
name|prev
expr_stmt|;
if|if
condition|(
name|write_symbols
operator|!=
name|NO_DEBUG
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|>
literal|0
condition|)
comment|/* Record line-number notes so they can be reused.  */
name|LINE_NOTE
argument_list|(
name|insn
argument_list|)
operator|=
name|insn
expr_stmt|;
else|else
block|{
comment|/* Insert the note at the end of the notes list.  */
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|note_list
expr_stmt|;
if|if
condition|(
name|note_list
condition|)
name|NEXT_INSN
argument_list|(
name|note_list
argument_list|)
operator|=
name|insn
expr_stmt|;
name|note_list
operator|=
name|insn
expr_stmt|;
block|}
name|insn
operator|=
name|next
expr_stmt|;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Data structure for keeping track of register information    during that register's life.  */
end_comment

begin_struct
struct|struct
name|sometimes
block|{
name|short
name|offset
decl_stmt|;
name|short
name|bit
decl_stmt|;
name|short
name|live_length
decl_stmt|;
name|short
name|calls_crossed
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Constructor for `sometimes' data structure.  */
end_comment

begin_function
specifier|static
name|int
name|new_sometimes_live
parameter_list|(
name|regs_sometimes_live
parameter_list|,
name|offset
parameter_list|,
name|bit
parameter_list|,
name|sometimes_max
parameter_list|)
name|struct
name|sometimes
modifier|*
name|regs_sometimes_live
decl_stmt|;
name|int
name|offset
decl_stmt|,
name|bit
decl_stmt|;
name|int
name|sometimes_max
decl_stmt|;
block|{
specifier|register
name|struct
name|sometimes
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|regno
init|=
name|offset
operator|*
name|REGSET_ELT_BITS
operator|+
name|bit
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* There should never be a register greater than max_regno here.  If there      is, it means that a define_split has created a new pseudo reg.  This      is not allowed, since there will not be flow info available for any      new register, so catch the error here.  */
if|if
condition|(
name|regno
operator|>=
name|max_regno
condition|)
name|abort
argument_list|()
expr_stmt|;
name|p
operator|=
operator|&
name|regs_sometimes_live
index|[
name|sometimes_max
index|]
expr_stmt|;
name|p
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
name|p
operator|->
name|bit
operator|=
name|bit
expr_stmt|;
name|p
operator|->
name|live_length
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|calls_crossed
operator|=
literal|0
expr_stmt|;
name|sometimes_max
operator|++
expr_stmt|;
return|return
name|sometimes_max
return|;
block|}
end_function

begin_comment
comment|/* Count lengths of all regs we are currently tracking,    and find new registers no longer live.  */
end_comment

begin_function
specifier|static
name|void
name|finish_sometimes_live
parameter_list|(
name|regs_sometimes_live
parameter_list|,
name|sometimes_max
parameter_list|)
name|struct
name|sometimes
modifier|*
name|regs_sometimes_live
decl_stmt|;
name|int
name|sometimes_max
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sometimes_max
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|struct
name|sometimes
modifier|*
name|p
init|=
operator|&
name|regs_sometimes_live
index|[
name|i
index|]
decl_stmt|;
name|int
name|regno
decl_stmt|;
name|regno
operator|=
name|p
operator|->
name|offset
operator|*
name|REGSET_ELT_BITS
operator|+
name|p
operator|->
name|bit
expr_stmt|;
name|sched_reg_live_length
index|[
name|regno
index|]
operator|+=
name|p
operator|->
name|live_length
expr_stmt|;
name|sched_reg_n_calls_crossed
index|[
name|regno
index|]
operator|+=
name|p
operator|->
name|calls_crossed
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Use modified list scheduling to rearrange insns in basic block    B.  FILE, if nonzero, is where we dump interesting output about    this pass.  */
end_comment

begin_function
specifier|static
name|void
name|schedule_block
parameter_list|(
name|b
parameter_list|,
name|file
parameter_list|)
name|int
name|b
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|,
name|last
decl_stmt|;
name|rtx
name|last_note
init|=
literal|0
decl_stmt|;
name|rtx
modifier|*
name|ready
decl_stmt|,
name|link
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|n_ready
init|=
literal|0
decl_stmt|,
name|new_ready
decl_stmt|,
name|n_insns
init|=
literal|0
decl_stmt|;
name|int
name|sched_n_insns
init|=
literal|0
decl_stmt|;
name|int
name|clock
decl_stmt|;
define|#
directive|define
name|NEED_NOTHING
value|0
define|#
directive|define
name|NEED_HEAD
value|1
define|#
directive|define
name|NEED_TAIL
value|2
name|int
name|new_needs
decl_stmt|;
comment|/* HEAD and TAIL delimit the region being scheduled.  */
name|rtx
name|head
init|=
name|basic_block_head
index|[
name|b
index|]
decl_stmt|;
name|rtx
name|tail
init|=
name|basic_block_end
index|[
name|b
index|]
decl_stmt|;
comment|/* PREV_HEAD and NEXT_TAIL are the boundaries of the insns      being scheduled.  When the insns have been ordered,      these insns delimit where the new insns are to be      spliced back into the insn chain.  */
name|rtx
name|next_tail
decl_stmt|;
name|rtx
name|prev_head
decl_stmt|;
comment|/* Keep life information accurate.  */
specifier|register
name|struct
name|sometimes
modifier|*
name|regs_sometimes_live
decl_stmt|;
name|int
name|sometimes_max
decl_stmt|;
if|if
condition|(
name|file
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";;\t -- basic block number %d from %d to %d --\n"
argument_list|,
name|b
argument_list|,
name|INSN_UID
argument_list|(
name|basic_block_head
index|[
name|b
index|]
argument_list|)
argument_list|,
name|INSN_UID
argument_list|(
name|basic_block_end
index|[
name|b
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|max_reg_num
argument_list|()
expr_stmt|;
name|reg_last_uses
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|i
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|reg_last_uses
argument_list|,
name|i
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|reg_last_sets
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|i
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|reg_last_sets
argument_list|,
name|i
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|clear_units
argument_list|()
expr_stmt|;
comment|/* Remove certain insns at the beginning from scheduling,      by advancing HEAD.  */
comment|/* At the start of a function, before reload has run, don't delay getting      parameters from hard registers into pseudo registers.  */
if|if
condition|(
name|reload_completed
operator|==
literal|0
operator|&&
name|b
operator|==
literal|0
condition|)
block|{
while|while
condition|(
name|head
operator|!=
name|tail
operator|&&
name|GET_CODE
argument_list|(
name|head
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|head
argument_list|)
operator|!=
name|NOTE_INSN_FUNCTION_BEG
condition|)
name|head
operator|=
name|NEXT_INSN
argument_list|(
name|head
argument_list|)
expr_stmt|;
while|while
condition|(
name|head
operator|!=
name|tail
operator|&&
name|GET_CODE
argument_list|(
name|head
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|head
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
block|{
name|rtx
name|src
init|=
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|head
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|SIGN_EXTEND
operator|||
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|ZERO_EXTEND
operator|||
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
name|src
operator|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|src
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
break|break;
comment|/* Keep this insn from ever being scheduled.  */
name|INSN_REF_COUNT
argument_list|(
name|head
argument_list|)
operator|=
literal|1
expr_stmt|;
name|head
operator|=
name|NEXT_INSN
argument_list|(
name|head
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Don't include any notes or labels at the beginning of the      basic block, or notes at the ends of basic blocks.  */
while|while
condition|(
name|head
operator|!=
name|tail
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|head
argument_list|)
operator|==
name|NOTE
condition|)
name|head
operator|=
name|NEXT_INSN
argument_list|(
name|head
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|tail
argument_list|)
operator|==
name|NOTE
condition|)
name|tail
operator|=
name|PREV_INSN
argument_list|(
name|tail
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|head
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|head
operator|=
name|NEXT_INSN
argument_list|(
name|head
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
comment|/* If the only insn left is a NOTE or a CODE_LABEL, then there is no need      to schedule this block.  */
if|if
condition|(
name|head
operator|==
name|tail
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|head
argument_list|)
operator|==
name|NOTE
operator|||
name|GET_CODE
argument_list|(
name|head
argument_list|)
operator|==
name|CODE_LABEL
operator|)
condition|)
return|return;
if|#
directive|if
literal|0
comment|/* This short-cut doesn't work.  It does not count call insns crossed by      registers in reg_sometimes_live.  It does not mark these registers as      dead if they die in this block.  It does not mark these registers live      (or create new reg_sometimes_live entries if necessary) if they are born      in this block.       The easy solution is to just always schedule a block.  This block only      has one insn, so this won't slow down this pass by much.  */
block|if (head == tail)     return;
endif|#
directive|endif
comment|/* Now HEAD through TAIL are the insns actually to be rearranged;      Let PREV_HEAD and NEXT_TAIL enclose them.  */
name|prev_head
operator|=
name|PREV_INSN
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|next_tail
operator|=
name|NEXT_INSN
argument_list|(
name|tail
argument_list|)
expr_stmt|;
comment|/* Initialize basic block data structures.  */
name|dead_notes
operator|=
literal|0
expr_stmt|;
name|pending_read_insns
operator|=
literal|0
expr_stmt|;
name|pending_read_mems
operator|=
literal|0
expr_stmt|;
name|pending_write_insns
operator|=
literal|0
expr_stmt|;
name|pending_write_mems
operator|=
literal|0
expr_stmt|;
name|pending_lists_length
operator|=
literal|0
expr_stmt|;
name|last_pending_memory_flush
operator|=
literal|0
expr_stmt|;
name|last_function_call
operator|=
literal|0
expr_stmt|;
name|last_scheduled_insn
operator|=
literal|0
expr_stmt|;
name|LOG_LINKS
argument_list|(
name|sched_before_next_call
argument_list|)
operator|=
literal|0
expr_stmt|;
name|n_insns
operator|+=
name|sched_analyze
argument_list|(
name|head
argument_list|,
name|tail
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_insns
operator|==
literal|0
condition|)
block|{
name|free_pending_lists
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* Allocate vector to hold insns to be rearranged (except those      insns which are controlled by an insn with SCHED_GROUP_P set).      All these insns are included between ORIG_HEAD and ORIG_TAIL,      as those variables ultimately are set up.  */
name|ready
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|n_insns
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* TAIL is now the last of the insns to be rearranged.      Put those insns into the READY vector.  */
name|insn
operator|=
name|tail
expr_stmt|;
comment|/* For all branches, calls, uses, and cc0 setters, force them to remain      in order at the end of the block by adding dependencies and giving      the last a high priority.  There may be notes present, and prev_head      may also be a note.       Branches must obviously remain at the end.  Calls should remain at the      end since moving them results in worse register allocation.  Uses remain      at the end to ensure proper register allocation.  cc0 setters remaim      at the end because they can't be moved away from their cc0 user.  */
name|last
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|||
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|USE
ifdef|#
directive|ifdef
name|HAVE_cc0
operator|||
name|sets_cc0_p
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
endif|#
directive|endif
operator|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
condition|)
block|{
name|priority
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|last
operator|==
literal|0
condition|)
block|{
name|ready
index|[
name|n_ready
operator|++
index|]
operator|=
name|insn
expr_stmt|;
name|INSN_PRIORITY
argument_list|(
name|insn
argument_list|)
operator|=
name|TAIL_PRIORITY
operator|-
name|i
expr_stmt|;
name|INSN_REF_COUNT
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|find_insn_list
argument_list|(
name|insn
argument_list|,
name|LOG_LINKS
argument_list|(
name|last
argument_list|)
argument_list|)
condition|)
block|{
name|add_dependence
argument_list|(
name|last
argument_list|,
name|insn
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
name|INSN_REF_COUNT
argument_list|(
name|insn
argument_list|)
operator|++
expr_stmt|;
block|}
name|last
operator|=
name|insn
expr_stmt|;
comment|/* Skip over insns that are part of a group.  */
while|while
condition|(
name|SCHED_GROUP_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|insn
operator|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|priority
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Don't overrun the bounds of the basic block.  */
if|if
condition|(
name|insn
operator|==
name|prev_head
condition|)
break|break;
block|}
comment|/* Assign priorities to instructions.  Also check whether they      are in priority order already.  If so then I will be nonnegative.      We use this shortcut only before reloading.  */
if|#
directive|if
literal|0
block|i = reload_completed ? DONE_PRIORITY : MAX_PRIORITY;
endif|#
directive|endif
for|for
control|(
init|;
name|insn
operator|!=
name|prev_head
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
block|{
name|priority
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|INSN_REF_COUNT
argument_list|(
name|insn
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|last
operator|==
literal|0
condition|)
name|ready
index|[
name|n_ready
operator|++
index|]
operator|=
name|insn
expr_stmt|;
else|else
block|{
comment|/* Make this dependent on the last of the instructions 		     that must remain in order at the end of the block.  */
name|add_dependence
argument_list|(
name|last
argument_list|,
name|insn
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
name|INSN_REF_COUNT
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|SCHED_GROUP_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
while|while
condition|(
name|SCHED_GROUP_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|priority
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
if|#
directive|if
literal|0
block|if (i< 0) 	    continue; 	  if (INSN_PRIORITY (insn)< i) 	    i = INSN_PRIORITY (insn); 	  else if (INSN_PRIORITY (insn)> i) 	    i = DONE_PRIORITY;
endif|#
directive|endif
block|}
block|}
if|#
directive|if
literal|0
comment|/* This short-cut doesn't work.  It does not count call insns crossed by      registers in reg_sometimes_live.  It does not mark these registers as      dead if they die in this block.  It does not mark these registers live      (or create new reg_sometimes_live entries if necessary) if they are born      in this block.       The easy solution is to just always schedule a block.  These blocks tend      to be very short, so this doesn't slow down this pass by much.  */
comment|/* If existing order is good, don't bother to reorder.  */
block|if (i != DONE_PRIORITY)     {       if (file) 	fprintf (file, ";; already scheduled\n");        if (reload_completed == 0) 	{ 	  for (i = 0; i< sometimes_max; i++) 	    regs_sometimes_live[i].live_length += n_insns;  	  finish_sometimes_live (regs_sometimes_live, sometimes_max); 	}       free_pending_lists ();       return;     }
endif|#
directive|endif
comment|/* Scan all the insns to be scheduled, removing NOTE insns      and register death notes.      Line number NOTE insns end up in NOTE_LIST.      Register death notes end up in DEAD_NOTES.       Recreate the register life information for the end of this basic      block.  */
if|if
condition|(
name|reload_completed
operator|==
literal|0
condition|)
block|{
name|bcopy
argument_list|(
name|basic_block_live_at_start
index|[
name|b
index|]
argument_list|,
name|bb_live_regs
argument_list|,
name|regset_bytes
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|bb_dead_regs
argument_list|,
name|regset_bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|==
literal|0
condition|)
block|{
comment|/* This is the first block in the function.  There may be insns 	     before head that we can't schedule.   We still need to examine 	     them though for accurate register lifetime analysis.  */
comment|/* We don't want to remove any REG_DEAD notes as the code below 	     does.  */
for|for
control|(
name|insn
operator|=
name|basic_block_head
index|[
name|b
index|]
init|;
name|insn
operator|!=
name|head
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
block|{
comment|/* See if the register gets born here.  */
comment|/* We must check for registers being born before we check for 		   registers dying.  It is possible for a register to be born 		   and die in the same insn, e.g. reading from a volatile 		   memory location into an otherwise unused register.  Such 		   a register must be marked as dead after this insn.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
name|sched_note_set
argument_list|(
name|b
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|)
operator|==
name|SET
operator|||
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
name|sched_note_set
argument_list|(
name|b
argument_list|,
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* ??? This code is obsolete and should be deleted.  It 		       is harmless though, so we will leave it in for now.  */
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|)
operator|==
name|USE
condition|)
name|sched_note_set
argument_list|(
name|b
argument_list|,
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_DEAD
operator|||
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_UNUSED
operator|)
comment|/* Verify that the REG_NOTE has a legal value.  */
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
specifier|register
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
specifier|register
name|int
name|offset
init|=
name|regno
operator|/
name|REGSET_ELT_BITS
decl_stmt|;
specifier|register
name|REGSET_ELT_TYPE
name|bit
init|=
operator|(
name|REGSET_ELT_TYPE
operator|)
literal|1
operator|<<
operator|(
name|regno
operator|%
name|REGSET_ELT_BITS
operator|)
decl_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|int
name|j
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
operator|--
name|j
operator|>=
literal|0
condition|)
block|{
name|offset
operator|=
operator|(
name|regno
operator|+
name|j
operator|)
operator|/
name|REGSET_ELT_BITS
expr_stmt|;
name|bit
operator|=
operator|(
operator|(
name|REGSET_ELT_TYPE
operator|)
literal|1
operator|<<
operator|(
operator|(
name|regno
operator|+
name|j
operator|)
operator|%
name|REGSET_ELT_BITS
operator|)
operator|)
expr_stmt|;
name|bb_live_regs
index|[
name|offset
index|]
operator|&=
operator|~
name|bit
expr_stmt|;
name|bb_dead_regs
index|[
name|offset
index|]
operator||=
name|bit
expr_stmt|;
block|}
block|}
else|else
block|{
name|bb_live_regs
index|[
name|offset
index|]
operator|&=
operator|~
name|bit
expr_stmt|;
name|bb_dead_regs
index|[
name|offset
index|]
operator||=
name|bit
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
comment|/* If debugging information is being produced, keep track of the line      number notes for each insn.  */
if|if
condition|(
name|write_symbols
operator|!=
name|NO_DEBUG
condition|)
block|{
comment|/* We must use the true line number for the first insn in the block 	 that was computed and saved at the start of this pass.  We can't 	 use the current line number, because scheduling of the previous 	 block may have changed the current line number.  */
name|rtx
name|line
init|=
name|line_note_head
index|[
name|b
index|]
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|basic_block_head
index|[
name|b
index|]
init|;
name|insn
operator|!=
name|next_tail
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|>
literal|0
condition|)
name|line
operator|=
name|insn
expr_stmt|;
else|else
name|LINE_NOTE
argument_list|(
name|insn
argument_list|)
operator|=
name|line
expr_stmt|;
block|}
for|for
control|(
name|insn
operator|=
name|head
init|;
name|insn
operator|!=
name|next_tail
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|rtx
name|prev
decl_stmt|,
name|next
decl_stmt|,
name|link
decl_stmt|;
comment|/* Farm out notes.  This is needed to keep the debugger from 	 getting completely deranged.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
block|{
name|prev
operator|=
name|insn
expr_stmt|;
name|insn
operator|=
name|unlink_notes
argument_list|(
name|insn
argument_list|,
name|next_tail
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|==
name|tail
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|prev
operator|==
name|head
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|next_tail
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|reload_completed
operator|==
literal|0
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
block|{
comment|/* See if the register gets born here.  */
comment|/* We must check for registers being born before we check for 	     registers dying.  It is possible for a register to be born and 	     die in the same insn, e.g. reading from a volatile memory 	     location into an otherwise unused register.  Such a register 	     must be marked as dead after this insn.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
name|sched_note_set
argument_list|(
name|b
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|)
operator|==
name|SET
operator|||
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
name|sched_note_set
argument_list|(
name|b
argument_list|,
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* ??? This code is obsolete and should be deleted.  It 		 is harmless though, so we will leave it in for now.  */
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|)
operator|==
name|USE
condition|)
name|sched_note_set
argument_list|(
name|b
argument_list|,
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Need to know what registers this insn kills.  */
for|for
control|(
name|prev
operator|=
literal|0
operator|,
name|link
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|next
control|)
block|{
name|int
name|regno
decl_stmt|;
name|next
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_DEAD
operator|||
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_UNUSED
operator|)
comment|/* Verify that the REG_NOTE has a legal value.  */
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
specifier|register
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
specifier|register
name|int
name|offset
init|=
name|regno
operator|/
name|REGSET_ELT_BITS
decl_stmt|;
specifier|register
name|REGSET_ELT_TYPE
name|bit
init|=
operator|(
name|REGSET_ELT_TYPE
operator|)
literal|1
operator|<<
operator|(
name|regno
operator|%
name|REGSET_ELT_BITS
operator|)
decl_stmt|;
comment|/* Only unlink REG_DEAD notes; leave REG_UNUSED notes 		     alone.  */
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_DEAD
condition|)
block|{
if|if
condition|(
name|prev
condition|)
name|XEXP
argument_list|(
name|prev
argument_list|,
literal|1
argument_list|)
operator|=
name|next
expr_stmt|;
else|else
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|next
expr_stmt|;
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
operator|=
name|dead_notes
expr_stmt|;
name|dead_notes
operator|=
name|link
expr_stmt|;
block|}
else|else
name|prev
operator|=
name|link
expr_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|int
name|j
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
operator|--
name|j
operator|>=
literal|0
condition|)
block|{
name|offset
operator|=
operator|(
name|regno
operator|+
name|j
operator|)
operator|/
name|REGSET_ELT_BITS
expr_stmt|;
name|bit
operator|=
operator|(
operator|(
name|REGSET_ELT_TYPE
operator|)
literal|1
operator|<<
operator|(
operator|(
name|regno
operator|+
name|j
operator|)
operator|%
name|REGSET_ELT_BITS
operator|)
operator|)
expr_stmt|;
name|bb_live_regs
index|[
name|offset
index|]
operator|&=
operator|~
name|bit
expr_stmt|;
name|bb_dead_regs
index|[
name|offset
index|]
operator||=
name|bit
expr_stmt|;
block|}
block|}
else|else
block|{
name|bb_live_regs
index|[
name|offset
index|]
operator|&=
operator|~
name|bit
expr_stmt|;
name|bb_dead_regs
index|[
name|offset
index|]
operator||=
name|bit
expr_stmt|;
block|}
block|}
else|else
name|prev
operator|=
name|link
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|reload_completed
operator|==
literal|0
condition|)
block|{
comment|/* Keep track of register lives.  */
name|old_live_regs
operator|=
operator|(
name|regset
operator|)
name|alloca
argument_list|(
name|regset_bytes
argument_list|)
expr_stmt|;
name|regs_sometimes_live
operator|=
operator|(
expr|struct
name|sometimes
operator|*
operator|)
name|alloca
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sometimes
argument_list|)
argument_list|)
expr_stmt|;
name|sometimes_max
operator|=
literal|0
expr_stmt|;
comment|/* Start with registers live at end.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|regset_size
condition|;
name|j
operator|++
control|)
block|{
name|REGSET_ELT_TYPE
name|live
init|=
name|bb_live_regs
index|[
name|j
index|]
decl_stmt|;
name|old_live_regs
index|[
name|j
index|]
operator|=
name|live
expr_stmt|;
if|if
condition|(
name|live
condition|)
block|{
specifier|register
name|REGSET_ELT_TYPE
name|bit
decl_stmt|;
for|for
control|(
name|bit
operator|=
literal|0
init|;
name|bit
operator|<
name|REGSET_ELT_BITS
condition|;
name|bit
operator|++
control|)
if|if
condition|(
name|live
operator|&
operator|(
operator|(
name|REGSET_ELT_TYPE
operator|)
literal|1
operator|<<
name|bit
operator|)
condition|)
name|sometimes_max
operator|=
name|new_sometimes_live
argument_list|(
name|regs_sometimes_live
argument_list|,
name|j
argument_list|,
name|bit
argument_list|,
name|sometimes_max
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|SCHED_SORT
argument_list|(
name|ready
argument_list|,
name|n_ready
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";; ready list initially:\n;; "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_ready
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d "
argument_list|,
name|INSN_UID
argument_list|(
name|ready
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|head
init|;
name|insn
operator|!=
name|next_tail
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_PRIORITY
argument_list|(
name|insn
argument_list|)
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";; insn[%4d]: priority = %4d, ref_count = %4d\n"
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|,
name|INSN_PRIORITY
argument_list|(
name|insn
argument_list|)
argument_list|,
name|INSN_REF_COUNT
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Now HEAD and TAIL are going to become disconnected      entirely from the insn chain.  */
name|tail
operator|=
literal|0
expr_stmt|;
comment|/* Q_SIZE will always be zero here.  */
name|q_ptr
operator|=
literal|0
expr_stmt|;
name|clock
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
name|insn_queue
argument_list|,
sizeof|sizeof
argument_list|(
name|insn_queue
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now, perform list scheduling.  */
comment|/* Where we start inserting insns is after TAIL.  */
name|last
operator|=
name|next_tail
expr_stmt|;
name|new_needs
operator|=
operator|(
name|NEXT_INSN
argument_list|(
name|prev_head
argument_list|)
operator|==
name|basic_block_head
index|[
name|b
index|]
condition|?
name|NEED_HEAD
else|:
name|NEED_NOTHING
operator|)
expr_stmt|;
if|if
condition|(
name|PREV_INSN
argument_list|(
name|next_tail
argument_list|)
operator|==
name|basic_block_end
index|[
name|b
index|]
condition|)
name|new_needs
operator||=
name|NEED_TAIL
expr_stmt|;
name|new_ready
operator|=
name|n_ready
expr_stmt|;
while|while
condition|(
name|sched_n_insns
operator|<
name|n_insns
condition|)
block|{
name|q_ptr
operator|=
name|NEXT_Q
argument_list|(
name|q_ptr
argument_list|)
expr_stmt|;
name|clock
operator|++
expr_stmt|;
comment|/* Add all pending insns that can be scheduled without stalls to the 	 ready list.  */
for|for
control|(
name|insn
operator|=
name|insn_queue
index|[
name|q_ptr
index|]
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|file
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";; launching %d before %d with no stalls at T-%d\n"
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|,
name|INSN_UID
argument_list|(
name|last
argument_list|)
argument_list|,
name|clock
argument_list|)
expr_stmt|;
name|ready
index|[
name|new_ready
operator|++
index|]
operator|=
name|insn
expr_stmt|;
name|q_size
operator|-=
literal|1
expr_stmt|;
block|}
name|insn_queue
index|[
name|q_ptr
index|]
operator|=
literal|0
expr_stmt|;
comment|/* If there are no ready insns, stall until one is ready and add all 	 of the pending insns at that point to the ready list.  */
if|if
condition|(
name|new_ready
operator|==
literal|0
condition|)
block|{
specifier|register
name|int
name|stalls
decl_stmt|;
for|for
control|(
name|stalls
operator|=
literal|1
init|;
name|stalls
operator|<
name|INSN_QUEUE_SIZE
condition|;
name|stalls
operator|++
control|)
if|if
condition|(
name|insn
operator|=
name|insn_queue
index|[
name|NEXT_Q_AFTER
argument_list|(
name|q_ptr
argument_list|,
name|stalls
argument_list|)
index|]
condition|)
block|{
for|for
control|(
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|file
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";; launching %d before %d with %d stalls at T-%d\n"
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|,
name|INSN_UID
argument_list|(
name|last
argument_list|)
argument_list|,
name|stalls
argument_list|,
name|clock
argument_list|)
expr_stmt|;
name|ready
index|[
name|new_ready
operator|++
index|]
operator|=
name|insn
expr_stmt|;
name|q_size
operator|-=
literal|1
expr_stmt|;
block|}
name|insn_queue
index|[
name|NEXT_Q_AFTER
argument_list|(
name|q_ptr
argument_list|,
name|stalls
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|q_ptr
operator|=
name|NEXT_Q_AFTER
argument_list|(
name|q_ptr
argument_list|,
name|stalls
argument_list|)
expr_stmt|;
name|clock
operator|+=
name|stalls
expr_stmt|;
block|}
comment|/* There should be some instructions waiting to fire.  */
if|if
condition|(
name|new_ready
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|file
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";; ready list at T-%d:"
argument_list|,
name|clock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|new_ready
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %d (%x)"
argument_list|,
name|INSN_UID
argument_list|(
name|ready
index|[
name|i
index|]
argument_list|)
argument_list|,
name|INSN_PRIORITY
argument_list|(
name|ready
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Sort the ready list and choose the best insn to schedule.  Select 	 which insn should issue in this cycle and queue those that are 	 blocked by function unit hazards.  	 N_READY holds the number of items that were scheduled the last time, 	 minus the one instruction scheduled on the last loop iteration; it 	 is not modified for any other reason in this loop.  */
name|SCHED_SORT
argument_list|(
name|ready
argument_list|,
name|new_ready
argument_list|,
name|n_ready
argument_list|)
expr_stmt|;
if|if
condition|(
name|MAX_BLOCKAGE
operator|>
literal|1
condition|)
block|{
name|new_ready
operator|=
name|schedule_select
argument_list|(
name|ready
argument_list|,
name|new_ready
argument_list|,
name|clock
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_ready
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|file
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* We must set n_ready here, to ensure that sorting always 		 occurs when we come back to the SCHED_SORT line above.  */
name|n_ready
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
block|}
name|n_ready
operator|=
name|new_ready
expr_stmt|;
name|last_scheduled_insn
operator|=
name|insn
operator|=
name|ready
index|[
literal|0
index|]
expr_stmt|;
comment|/* The first insn scheduled becomes the new tail.  */
if|if
condition|(
name|tail
operator|==
literal|0
condition|)
name|tail
operator|=
name|insn
expr_stmt|;
if|if
condition|(
name|file
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|", now"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_ready
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %d"
argument_list|,
name|INSN_UID
argument_list|(
name|ready
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DONE_PRIORITY_P
argument_list|(
name|insn
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|reload_completed
operator|==
literal|0
condition|)
block|{
comment|/* Process this insn, and each insn linked to this one which must 	     be immediately output after this insn.  */
do|do
block|{
comment|/* First we kill registers set by this insn, and then we 		 make registers used by this insn live.  This is the opposite 		 order used above because we are traversing the instructions 		 backwards.  */
comment|/* Strictly speaking, we should scan REG_UNUSED notes and make 		 every register mentioned there live, however, we will just 		 kill them again immediately below, so there doesn't seem to 		 be any reason why we bother to do this.  */
comment|/* See if this is the last notice we must take of a register.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
name|sched_note_set
argument_list|(
name|b
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|)
operator|==
name|SET
operator|||
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
name|sched_note_set
argument_list|(
name|b
argument_list|,
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* This code keeps life analysis information up to date.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
specifier|register
name|struct
name|sometimes
modifier|*
name|p
decl_stmt|;
comment|/* A call kills all call used and global registers, except 		     for those mentioned in the call pattern which will be 		     made live again later.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|call_used_regs
index|[
name|i
index|]
operator|||
name|global_regs
index|[
name|i
index|]
condition|)
block|{
specifier|register
name|int
name|offset
init|=
name|i
operator|/
name|REGSET_ELT_BITS
decl_stmt|;
specifier|register
name|REGSET_ELT_TYPE
name|bit
init|=
operator|(
name|REGSET_ELT_TYPE
operator|)
literal|1
operator|<<
operator|(
name|i
operator|%
name|REGSET_ELT_BITS
operator|)
decl_stmt|;
name|bb_live_regs
index|[
name|offset
index|]
operator|&=
operator|~
name|bit
expr_stmt|;
name|bb_dead_regs
index|[
name|offset
index|]
operator||=
name|bit
expr_stmt|;
block|}
comment|/* Regs live at the time of a call instruction must not 		     go in a register clobbered by calls.  Record this for 		     all regs now live.  Note that insns which are born or 		     die in a call do not cross a call, so this must be done 		     after the killings (above) and before the births 		     (below).  */
name|p
operator|=
name|regs_sometimes_live
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sometimes_max
condition|;
name|i
operator|++
operator|,
name|p
operator|++
control|)
if|if
condition|(
name|bb_live_regs
index|[
name|p
operator|->
name|offset
index|]
operator|&
operator|(
operator|(
name|REGSET_ELT_TYPE
operator|)
literal|1
operator|<<
name|p
operator|->
name|bit
operator|)
condition|)
name|p
operator|->
name|calls_crossed
operator|+=
literal|1
expr_stmt|;
block|}
comment|/* Make every register used live, and add REG_DEAD notes for 		 registers which were not live before we started.  */
name|attach_deaths_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Find registers now made live by that instruction.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|regset_size
condition|;
name|i
operator|++
control|)
block|{
name|REGSET_ELT_TYPE
name|diff
init|=
name|bb_live_regs
index|[
name|i
index|]
operator|&
operator|~
name|old_live_regs
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|diff
condition|)
block|{
specifier|register
name|int
name|bit
decl_stmt|;
name|old_live_regs
index|[
name|i
index|]
operator||=
name|diff
expr_stmt|;
for|for
control|(
name|bit
operator|=
literal|0
init|;
name|bit
operator|<
name|REGSET_ELT_BITS
condition|;
name|bit
operator|++
control|)
if|if
condition|(
name|diff
operator|&
operator|(
operator|(
name|REGSET_ELT_TYPE
operator|)
literal|1
operator|<<
name|bit
operator|)
condition|)
name|sometimes_max
operator|=
name|new_sometimes_live
argument_list|(
name|regs_sometimes_live
argument_list|,
name|i
argument_list|,
name|bit
argument_list|,
name|sometimes_max
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Count lengths of all regs we are worrying about now, 		 and handle registers no longer live.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sometimes_max
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|struct
name|sometimes
modifier|*
name|p
init|=
operator|&
name|regs_sometimes_live
index|[
name|i
index|]
decl_stmt|;
name|int
name|regno
init|=
name|p
operator|->
name|offset
operator|*
name|REGSET_ELT_BITS
operator|+
name|p
operator|->
name|bit
decl_stmt|;
name|p
operator|->
name|live_length
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|bb_live_regs
index|[
name|p
operator|->
name|offset
index|]
operator|&
operator|(
operator|(
name|REGSET_ELT_TYPE
operator|)
literal|1
operator|<<
name|p
operator|->
name|bit
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* This is the end of one of this register's lifetime 			 segments.  Save the lifetime info collected so far, 			 and clear its bit in the old_live_regs entry.  */
name|sched_reg_live_length
index|[
name|regno
index|]
operator|+=
name|p
operator|->
name|live_length
expr_stmt|;
name|sched_reg_n_calls_crossed
index|[
name|regno
index|]
operator|+=
name|p
operator|->
name|calls_crossed
expr_stmt|;
name|old_live_regs
index|[
name|p
operator|->
name|offset
index|]
operator|&=
operator|~
operator|(
operator|(
name|REGSET_ELT_TYPE
operator|)
literal|1
operator|<<
name|p
operator|->
name|bit
operator|)
expr_stmt|;
comment|/* Delete the reg_sometimes_live entry for this reg by 			 copying the last entry over top of it.  */
operator|*
name|p
operator|=
name|regs_sometimes_live
index|[
operator|--
name|sometimes_max
index|]
expr_stmt|;
comment|/* ...and decrement i so that this newly copied entry 			 will be processed.  */
name|i
operator|--
expr_stmt|;
block|}
block|}
name|link
operator|=
name|insn
expr_stmt|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|SCHED_GROUP_P
argument_list|(
name|link
argument_list|)
condition|)
do|;
comment|/* Set INSN back to the insn we are scheduling now.  */
name|insn
operator|=
name|ready
index|[
literal|0
index|]
expr_stmt|;
block|}
comment|/* Schedule INSN.  Remove it from the ready list.  */
name|ready
operator|+=
literal|1
expr_stmt|;
name|n_ready
operator|-=
literal|1
expr_stmt|;
name|sched_n_insns
operator|+=
literal|1
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|last
expr_stmt|;
name|PREV_INSN
argument_list|(
name|last
argument_list|)
operator|=
name|insn
expr_stmt|;
name|last
operator|=
name|insn
expr_stmt|;
comment|/* Everything that precedes INSN now either becomes "ready", if 	 it can execute immediately before INSN, or "pending", if 	 there must be a delay.  Give INSN high enough priority that 	 at least one (maybe more) reg-killing insns can be launched 	 ahead of all others.  Mark INSN as scheduled by changing its 	 priority to -1.  */
name|INSN_PRIORITY
argument_list|(
name|insn
argument_list|)
operator|=
name|LAUNCH_PRIORITY
expr_stmt|;
name|new_ready
operator|=
name|schedule_insn
argument_list|(
name|insn
argument_list|,
name|ready
argument_list|,
name|n_ready
argument_list|,
name|clock
argument_list|)
expr_stmt|;
name|INSN_PRIORITY
argument_list|(
name|insn
argument_list|)
operator|=
name|DONE_PRIORITY
expr_stmt|;
comment|/* Schedule all prior insns that must not be moved.  */
if|if
condition|(
name|SCHED_GROUP_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
comment|/* Disable these insns from being launched.  */
name|link
operator|=
name|insn
expr_stmt|;
while|while
condition|(
name|SCHED_GROUP_P
argument_list|(
name|link
argument_list|)
condition|)
block|{
comment|/* Disable these insns from being launched by anybody.  */
name|link
operator|=
name|PREV_INSN
argument_list|(
name|link
argument_list|)
expr_stmt|;
name|INSN_REF_COUNT
argument_list|(
name|link
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
comment|/* None of these insns can move forward into delay slots.  */
while|while
condition|(
name|SCHED_GROUP_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|new_ready
operator|=
name|schedule_insn
argument_list|(
name|insn
argument_list|,
name|ready
argument_list|,
name|new_ready
argument_list|,
name|clock
argument_list|)
expr_stmt|;
name|INSN_PRIORITY
argument_list|(
name|insn
argument_list|)
operator|=
name|DONE_PRIORITY
expr_stmt|;
name|sched_n_insns
operator|+=
literal|1
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|last
expr_stmt|;
name|PREV_INSN
argument_list|(
name|last
argument_list|)
operator|=
name|insn
expr_stmt|;
name|last
operator|=
name|insn
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|q_size
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|reload_completed
operator|==
literal|0
condition|)
name|finish_sometimes_live
argument_list|(
name|regs_sometimes_live
argument_list|,
name|sometimes_max
argument_list|)
expr_stmt|;
comment|/* HEAD is now the first insn in the chain of insns that      been scheduled by the loop above.      TAIL is the last of those insns.  */
name|head
operator|=
name|insn
expr_stmt|;
comment|/* NOTE_LIST is the end of a chain of notes previously found      among the insns.  Insert them at the beginning of the insns.  */
if|if
condition|(
name|note_list
operator|!=
literal|0
condition|)
block|{
name|rtx
name|note_head
init|=
name|note_list
decl_stmt|;
while|while
condition|(
name|PREV_INSN
argument_list|(
name|note_head
argument_list|)
condition|)
name|note_head
operator|=
name|PREV_INSN
argument_list|(
name|note_head
argument_list|)
expr_stmt|;
name|PREV_INSN
argument_list|(
name|head
argument_list|)
operator|=
name|note_list
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|note_list
argument_list|)
operator|=
name|head
expr_stmt|;
name|head
operator|=
name|note_head
expr_stmt|;
block|}
comment|/* There should be no REG_DEAD notes leftover at the end.      In practice, this can occur as the result of bugs in flow, combine.c,      and/or sched.c.  The values of the REG_DEAD notes remaining are      meaningless, because dead_notes is just used as a free list.  */
if|#
directive|if
literal|1
if|if
condition|(
name|dead_notes
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|new_needs
operator|&
name|NEED_HEAD
condition|)
name|basic_block_head
index|[
name|b
index|]
operator|=
name|head
expr_stmt|;
name|PREV_INSN
argument_list|(
name|head
argument_list|)
operator|=
name|prev_head
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|prev_head
argument_list|)
operator|=
name|head
expr_stmt|;
if|if
condition|(
name|new_needs
operator|&
name|NEED_TAIL
condition|)
name|basic_block_end
index|[
name|b
index|]
operator|=
name|tail
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|tail
argument_list|)
operator|=
name|next_tail
expr_stmt|;
name|PREV_INSN
argument_list|(
name|next_tail
argument_list|)
operator|=
name|tail
expr_stmt|;
comment|/* Restore the line-number notes of each insn.  */
if|if
condition|(
name|write_symbols
operator|!=
name|NO_DEBUG
condition|)
block|{
name|rtx
name|line
decl_stmt|,
name|note
decl_stmt|,
name|prev
decl_stmt|,
name|new
decl_stmt|;
name|int
name|notes
init|=
literal|0
decl_stmt|;
name|head
operator|=
name|basic_block_head
index|[
name|b
index|]
expr_stmt|;
name|next_tail
operator|=
name|NEXT_INSN
argument_list|(
name|basic_block_end
index|[
name|b
index|]
argument_list|)
expr_stmt|;
comment|/* Determine the current line-number.  We want to know the current 	 line number of the first insn of the block here, in case it is 	 different from the true line number that was saved earlier.  If 	 different, then we need a line number note before the first insn 	 of this block.  If it happens to be the same, then we don't want to 	 emit another line number note here.  */
for|for
control|(
name|line
operator|=
name|head
init|;
name|line
condition|;
name|line
operator|=
name|PREV_INSN
argument_list|(
name|line
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|line
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|line
argument_list|)
operator|>
literal|0
condition|)
break|break;
comment|/* Walk the insns keeping track of the current line-number and inserting 	 the line-number notes as needed.  */
for|for
control|(
name|insn
operator|=
name|head
init|;
name|insn
operator|!=
name|next_tail
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|>
literal|0
condition|)
name|line
operator|=
name|insn
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_DELETED
operator|)
operator|&&
operator|(
name|note
operator|=
name|LINE_NOTE
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|note
operator|!=
name|line
operator|&&
operator|(
name|line
operator|==
literal|0
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|note
argument_list|)
operator|!=
name|NOTE_LINE_NUMBER
argument_list|(
name|line
argument_list|)
operator|||
name|NOTE_SOURCE_FILE
argument_list|(
name|note
argument_list|)
operator|!=
name|NOTE_SOURCE_FILE
argument_list|(
name|line
argument_list|)
operator|)
condition|)
block|{
name|line
operator|=
name|note
expr_stmt|;
name|prev
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|LINE_NOTE
argument_list|(
name|note
argument_list|)
condition|)
block|{
comment|/* Re-use the original line-number note. */
name|LINE_NOTE
argument_list|(
name|note
argument_list|)
operator|=
literal|0
expr_stmt|;
name|PREV_INSN
argument_list|(
name|note
argument_list|)
operator|=
name|prev
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|prev
argument_list|)
operator|=
name|note
expr_stmt|;
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|note
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|note
argument_list|)
operator|=
name|insn
expr_stmt|;
block|}
else|else
block|{
name|notes
operator|++
expr_stmt|;
name|new
operator|=
name|emit_note_after
argument_list|(
name|NOTE_LINE_NUMBER
argument_list|(
name|note
argument_list|)
argument_list|,
name|prev
argument_list|)
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|new
argument_list|)
operator|=
name|NOTE_SOURCE_FILE
argument_list|(
name|note
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|file
operator|&&
name|notes
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";; added %d line-number notes\n"
argument_list|,
name|notes
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|file
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";; total time = %d\n;; new basic block head = %d\n;; new basic block end = %d\n\n"
argument_list|,
name|clock
argument_list|,
name|INSN_UID
argument_list|(
name|basic_block_head
index|[
name|b
index|]
argument_list|)
argument_list|,
name|INSN_UID
argument_list|(
name|basic_block_end
index|[
name|b
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Yow! We're done!  */
name|free_pending_lists
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutine of split_hard_reg_notes.  Searches X for any reference to    REGNO, returning the rtx of the reference found if any.  Otherwise,    returns 0.  */
end_comment

begin_function
name|rtx
name|regno_use_in
parameter_list|(
name|regno
parameter_list|,
name|x
parameter_list|)
name|int
name|regno
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|==
name|regno
condition|)
return|return
name|x
return|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
if|if
condition|(
name|tem
operator|=
name|regno_use_in
argument_list|(
name|regno
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
name|tem
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|tem
operator|=
name|regno_use_in
argument_list|(
name|regno
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
name|tem
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of update_flow_info.  Determines whether any new REG_NOTEs are    needed for the hard register mentioned in the note.  This can happen    if the reference to the hard register in the original insn was split into    several smaller hard register references in the split insns.  */
end_comment

begin_function
specifier|static
name|void
name|split_hard_reg_notes
parameter_list|(
name|note
parameter_list|,
name|first
parameter_list|,
name|last
parameter_list|,
name|orig_insn
parameter_list|)
name|rtx
name|note
decl_stmt|,
name|first
decl_stmt|,
name|last
decl_stmt|,
name|orig_insn
decl_stmt|;
block|{
name|rtx
name|reg
decl_stmt|,
name|temp
decl_stmt|,
name|link
decl_stmt|;
name|int
name|n_regs
decl_stmt|,
name|i
decl_stmt|,
name|new_reg
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
comment|/* Assume that this is a REG_DEAD note.  */
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|!=
name|REG_DEAD
condition|)
name|abort
argument_list|()
expr_stmt|;
name|reg
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|n_regs
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_regs
condition|;
name|i
operator|++
control|)
block|{
name|new_reg
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|+
name|i
expr_stmt|;
comment|/* Check for references to new_reg in the split insns.  */
for|for
control|(
name|insn
operator|=
name|last
init|;
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
operator|&&
operator|(
name|temp
operator|=
name|regno_use_in
argument_list|(
name|new_reg
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|)
condition|)
block|{
comment|/* Create a new reg dead note here.  */
name|link
operator|=
name|rtx_alloc
argument_list|(
name|EXPR_LIST
argument_list|)
expr_stmt|;
name|PUT_REG_NOTE_KIND
argument_list|(
name|link
argument_list|,
name|REG_DEAD
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
operator|=
name|temp
expr_stmt|;
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|link
expr_stmt|;
comment|/* If killed multiple registers here, then add in the excess.  */
name|i
operator|+=
name|HARD_REGNO_NREGS
argument_list|(
name|REGNO
argument_list|(
name|temp
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|temp
argument_list|)
argument_list|)
operator|-
literal|1
expr_stmt|;
break|break;
block|}
comment|/* It isn't mentioned anywhere, so no new reg note is needed for 	     this register.  */
if|if
condition|(
name|insn
operator|==
name|first
condition|)
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Subroutine of update_flow_info.  Determines whether a SET or CLOBBER in an    insn created by splitting needs a REG_DEAD or REG_UNUSED note added.  */
end_comment

begin_function
specifier|static
name|void
name|new_insn_dead_notes
parameter_list|(
name|pat
parameter_list|,
name|insn
parameter_list|,
name|last
parameter_list|,
name|orig_insn
parameter_list|)
name|rtx
name|pat
decl_stmt|,
name|insn
decl_stmt|,
name|last
decl_stmt|,
name|orig_insn
decl_stmt|;
block|{
name|rtx
name|dest
decl_stmt|,
name|tem
decl_stmt|,
name|set
decl_stmt|;
comment|/* PAT is either a CLOBBER or a SET here.  */
name|dest
operator|=
name|XEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SIGN_EXTRACT
condition|)
name|dest
operator|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
condition|)
block|{
for|for
control|(
name|tem
operator|=
name|last
init|;
name|tem
operator|!=
name|insn
condition|;
name|tem
operator|=
name|PREV_INSN
argument_list|(
name|tem
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|==
literal|'i'
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|dest
argument_list|,
name|PATTERN
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|&&
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|tem
argument_list|)
operator|)
condition|)
block|{
name|rtx
name|tem_dest
init|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
decl_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|tem_dest
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|tem_dest
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|tem_dest
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|tem_dest
argument_list|)
operator|==
name|SIGN_EXTRACT
condition|)
name|tem_dest
operator|=
name|XEXP
argument_list|(
name|tem_dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem_dest
operator|!=
name|dest
condition|)
block|{
comment|/* Use the same scheme as combine.c, don't put both REG_DEAD 		     and REG_UNUSED notes on the same insn.  */
if|if
condition|(
operator|!
name|find_regno_note
argument_list|(
name|tem
argument_list|,
name|REG_UNUSED
argument_list|,
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|&&
operator|!
name|find_regno_note
argument_list|(
name|tem
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|note
init|=
name|rtx_alloc
argument_list|(
name|EXPR_LIST
argument_list|)
decl_stmt|;
name|PUT_REG_NOTE_KIND
argument_list|(
name|note
argument_list|,
name|REG_DEAD
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
operator|=
name|dest
expr_stmt|;
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
operator|=
name|REG_NOTES
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|tem
argument_list|)
operator|=
name|note
expr_stmt|;
block|}
comment|/* The reg only dies in one insn, the last one that uses 		     it.  */
break|break;
block|}
elseif|else
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|dest
argument_list|,
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
condition|)
comment|/* We found an instruction that both uses the register, 		   and sets it, so no new REG_NOTE is needed for this set.  */
break|break;
block|}
block|}
comment|/* If this is a set, it must die somewhere, unless it is the dest of 	 the original insn, and hence is live after the original insn.  Abort 	 if it isn't supposed to be live after the original insn.  	 If this is a clobber, then just add a REG_UNUSED note.  */
if|if
condition|(
name|tem
operator|==
name|insn
condition|)
block|{
name|int
name|live_after_orig_insn
init|=
literal|0
decl_stmt|;
name|rtx
name|pattern
init|=
name|PATTERN
argument_list|(
name|orig_insn
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|CLOBBER
condition|)
block|{
name|rtx
name|note
init|=
name|rtx_alloc
argument_list|(
name|EXPR_LIST
argument_list|)
decl_stmt|;
name|PUT_REG_NOTE_KIND
argument_list|(
name|note
argument_list|,
name|REG_UNUSED
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
operator|=
name|dest
expr_stmt|;
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|note
expr_stmt|;
return|return;
block|}
comment|/* The original insn could have multiple sets, so search the 	     insn for all sets.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
operator|==
name|SET
condition|)
block|{
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|dest
argument_list|,
name|SET_DEST
argument_list|(
name|pattern
argument_list|)
argument_list|)
condition|)
name|live_after_orig_insn
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|dest
argument_list|,
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
condition|)
name|live_after_orig_insn
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|live_after_orig_insn
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Subroutine of update_flow_info.  Update the value of reg_n_sets for all    registers modified by X.  INC is -1 if the containing insn is being deleted,    and is 1 if the containing insn is a newly generated insn.  */
end_comment

begin_function
specifier|static
name|void
name|update_n_sets
parameter_list|(
name|x
parameter_list|,
name|inc
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|int
name|inc
decl_stmt|;
block|{
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|x
argument_list|)
decl_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SIGN_EXTRACT
condition|)
name|dest
operator|=
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
condition|)
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|endregno
init|=
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
name|regno
init|;
name|i
operator|<
name|endregno
condition|;
name|i
operator|++
control|)
name|reg_n_sets
index|[
name|i
index|]
operator|+=
name|inc
expr_stmt|;
block|}
else|else
name|reg_n_sets
index|[
name|regno
index|]
operator|+=
name|inc
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Updates all flow-analysis related quantities (including REG_NOTES) for    the insns from FIRST to LAST inclusive that were created by splitting    ORIG_INSN.  NOTES are the original REG_NOTES.  */
end_comment

begin_function
specifier|static
name|void
name|update_flow_info
parameter_list|(
name|notes
parameter_list|,
name|first
parameter_list|,
name|last
parameter_list|,
name|orig_insn
parameter_list|)
name|rtx
name|notes
decl_stmt|;
name|rtx
name|first
decl_stmt|,
name|last
decl_stmt|;
name|rtx
name|orig_insn
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|,
name|note
decl_stmt|;
name|rtx
name|next
decl_stmt|;
name|rtx
name|orig_dest
decl_stmt|,
name|temp
decl_stmt|;
name|rtx
name|set
decl_stmt|;
comment|/* Get and save the destination set by the original insn.  */
name|orig_dest
operator|=
name|single_set
argument_list|(
name|orig_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|orig_dest
condition|)
name|orig_dest
operator|=
name|SET_DEST
argument_list|(
name|orig_dest
argument_list|)
expr_stmt|;
comment|/* Move REG_NOTES from the original insn to where they now belong.  */
for|for
control|(
name|note
operator|=
name|notes
init|;
name|note
condition|;
name|note
operator|=
name|next
control|)
block|{
name|next
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
condition|)
block|{
case|case
name|REG_DEAD
case|:
case|case
name|REG_UNUSED
case|:
comment|/* Move these notes from the original insn to the last new insn where 	     the register is now set.  */
for|for
control|(
name|insn
operator|=
name|last
init|;
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
operator|&&
name|reg_mentioned_p
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
block|{
comment|/* If this note refers to a multiple word hard register, it 		     may have been split into several smaller hard register 		     references, so handle it specially.  */
name|temp
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_DEAD
operator|&&
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|temp
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|HARD_REGNO_NREGS
argument_list|(
name|REGNO
argument_list|(
name|temp
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|temp
argument_list|)
argument_list|)
operator|>
literal|1
condition|)
name|split_hard_reg_notes
argument_list|(
name|note
argument_list|,
name|first
argument_list|,
name|last
argument_list|,
name|orig_insn
argument_list|)
expr_stmt|;
else|else
block|{
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|note
expr_stmt|;
block|}
comment|/* Sometimes need to convert REG_UNUSED notes to REG_DEAD 		     notes.  */
comment|/* ??? This won't handle multiple word registers correctly, 		     but should be good enough for now.  */
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_UNUSED
operator|&&
operator|!
name|dead_or_set_p
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|PUT_REG_NOTE_KIND
argument_list|(
name|note
argument_list|,
name|REG_DEAD
argument_list|)
expr_stmt|;
comment|/* The reg only dies in one insn, the last one that uses 		     it.  */
break|break;
block|}
comment|/* It must die somewhere, fail it we couldn't find where it died.  		 If this is a REG_UNUSED note, then it must be a temporary 		 register that was not needed by this instantiation of the 		 pattern, so we can safely ignore it.  */
if|if
condition|(
name|insn
operator|==
name|first
condition|)
block|{
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|!=
name|REG_UNUSED
condition|)
name|abort
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
name|REG_WAS_0
case|:
comment|/* This note applies to the dest of the original insn.  Find the 	     first new insn that now has the same dest, and move the note 	     there.  */
if|if
condition|(
operator|!
name|orig_dest
condition|)
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|first
init|;
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
operator|&&
operator|(
name|temp
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
operator|)
operator|&&
name|rtx_equal_p
argument_list|(
name|SET_DEST
argument_list|(
name|temp
argument_list|)
argument_list|,
name|orig_dest
argument_list|)
condition|)
block|{
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|note
expr_stmt|;
comment|/* The reg is only zero before one insn, the first that 		     uses it.  */
break|break;
block|}
comment|/* It must be set somewhere, fail if we couldn't find where it 		 was set.  */
if|if
condition|(
name|insn
operator|==
name|last
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|REG_EQUAL
case|:
case|case
name|REG_EQUIV
case|:
comment|/* A REG_EQUIV or REG_EQUAL note on an insn with more than one 	     set is meaningless.  Just drop the note.  */
if|if
condition|(
operator|!
name|orig_dest
condition|)
break|break;
case|case
name|REG_NO_CONFLICT
case|:
comment|/* These notes apply to the dest of the original insn.  Find the last 	     new insn that now has the same dest, and move the note there.  */
if|if
condition|(
operator|!
name|orig_dest
condition|)
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|last
init|;
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
operator|&&
operator|(
name|temp
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
operator|)
operator|&&
name|rtx_equal_p
argument_list|(
name|SET_DEST
argument_list|(
name|temp
argument_list|)
argument_list|,
name|orig_dest
argument_list|)
condition|)
block|{
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|note
expr_stmt|;
comment|/* Only put this note on one of the new insns.  */
break|break;
block|}
comment|/* The original dest must still be set someplace.  Abort if we 		 couldn't find it.  */
if|if
condition|(
name|insn
operator|==
name|first
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|REG_LIBCALL
case|:
comment|/* Move a REG_LIBCALL note to the first insn created, and update 	     the corresponding REG_RETVAL note.  */
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
operator|=
name|REG_NOTES
argument_list|(
name|first
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|first
argument_list|)
operator|=
name|note
expr_stmt|;
name|insn
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|note
condition|)
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
operator|=
name|first
expr_stmt|;
break|break;
case|case
name|REG_RETVAL
case|:
comment|/* Move a REG_RETVAL note to the last insn created, and update 	     the corresponding REG_LIBCALL note.  */
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
operator|=
name|REG_NOTES
argument_list|(
name|last
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|last
argument_list|)
operator|=
name|note
expr_stmt|;
name|insn
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_LIBCALL
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|note
condition|)
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
operator|=
name|last
expr_stmt|;
break|break;
case|case
name|REG_NONNEG
case|:
comment|/* This should be moved to whichever instruction is a JUMP_INSN.  */
for|for
control|(
name|insn
operator|=
name|last
init|;
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|note
expr_stmt|;
comment|/* Only put this note on one of the new insns.  */
break|break;
block|}
comment|/* Fail if we couldn't find a JUMP_INSN.  */
if|if
condition|(
name|insn
operator|==
name|first
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|REG_INC
case|:
comment|/* This should be moved to whichever instruction now has the 	     increment operation.  */
name|abort
argument_list|()
expr_stmt|;
case|case
name|REG_LABEL
case|:
comment|/* Should be moved to the new insn(s) which use the label.  */
for|for
control|(
name|insn
operator|=
name|first
init|;
name|insn
operator|!=
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
operator|&&
name|reg_mentioned_p
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|REG_LABEL
argument_list|,
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG_CC_SETTER
case|:
case|case
name|REG_CC_USER
case|:
comment|/* These two notes will never appear until after reorg, so we don't 	     have to handle them here.  */
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Each new insn created, except the last, has a new set.  If the destination      is a register, then this reg is now live across several insns, whereas      previously the dest reg was born and died within the same insn.  To      reflect this, we now need a REG_DEAD note on the insn where this      dest reg dies.       Similarly, the new insns may have clobbers that need REG_UNUSED notes.  */
for|for
control|(
name|insn
operator|=
name|first
init|;
name|insn
operator|!=
name|last
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|rtx
name|pat
decl_stmt|;
name|int
name|i
decl_stmt|;
name|pat
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SET
operator|||
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|CLOBBER
condition|)
name|new_insn_dead_notes
argument_list|(
name|pat
argument_list|,
name|insn
argument_list|,
name|last
argument_list|,
name|orig_insn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|SET
operator|||
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
name|new_insn_dead_notes
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|,
name|last
argument_list|,
name|orig_insn
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If any insn, except the last, uses the register set by the last insn,      then we need a new REG_DEAD note on that insn.  In this case, there      would not have been a REG_DEAD note for this register in the original      insn because it was used and set within one insn.       There is no new REG_DEAD note needed if the last insn uses the register      that it is setting.  */
name|set
operator|=
name|single_set
argument_list|(
name|last
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
condition|)
block|{
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
decl_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SIGN_EXTRACT
condition|)
name|dest
operator|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
operator|&&
operator|!
name|reg_overlap_mentioned_p
argument_list|(
name|dest
argument_list|,
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
condition|)
block|{
for|for
control|(
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|last
argument_list|)
init|;
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
operator|&&
name|reg_mentioned_p
argument_list|(
name|dest
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|&&
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
operator|)
condition|)
block|{
name|rtx
name|insn_dest
init|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
decl_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|insn_dest
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|insn_dest
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|insn_dest
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|insn_dest
argument_list|)
operator|==
name|SIGN_EXTRACT
condition|)
name|insn_dest
operator|=
name|XEXP
argument_list|(
name|insn_dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn_dest
operator|!=
name|dest
condition|)
block|{
name|note
operator|=
name|rtx_alloc
argument_list|(
name|EXPR_LIST
argument_list|)
expr_stmt|;
name|PUT_REG_NOTE_KIND
argument_list|(
name|note
argument_list|,
name|REG_DEAD
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
operator|=
name|dest
expr_stmt|;
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|note
expr_stmt|;
comment|/* The reg only dies in one insn, the last one 			 that uses it.  */
break|break;
block|}
block|}
if|if
condition|(
name|insn
operator|==
name|first
condition|)
break|break;
block|}
block|}
block|}
comment|/* If the original dest is modifying a multiple register target, and the      original instruction was split such that the original dest is now set      by two or more SUBREG sets, then the split insns no longer kill the      destination of the original insn.       In this case, if there exists an instruction in the same basic block,      before the split insn, which uses the original dest, and this use is      killed by the original insn, then we must remove the REG_DEAD note on      this insn, because it is now superfluous.       This does not apply when a hard register gets split, because the code      knows how to handle overlapping hard registers properly.  */
if|if
condition|(
name|orig_dest
operator|&&
name|GET_CODE
argument_list|(
name|orig_dest
argument_list|)
operator|==
name|REG
condition|)
block|{
name|int
name|found_orig_dest
init|=
literal|0
decl_stmt|;
name|int
name|found_split_dest
init|=
literal|0
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|first
init|;
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REGNO
argument_list|(
name|orig_dest
argument_list|)
condition|)
block|{
name|found_orig_dest
operator|=
literal|1
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_REG
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|orig_dest
condition|)
block|{
name|found_split_dest
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|insn
operator|==
name|last
condition|)
break|break;
block|}
if|if
condition|(
name|found_split_dest
condition|)
block|{
comment|/* Search backwards from FIRST, looking for the first insn that uses 	     the original dest.  Stop if we pass a CODE_LABEL or a JUMP_INSN. 	     If we find an insn, and it has a REG_DEAD note, then delete the 	     note.  */
for|for
control|(
name|insn
operator|=
name|first
init|;
name|insn
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
break|break;
elseif|else
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
operator|&&
name|reg_mentioned_p
argument_list|(
name|orig_dest
argument_list|,
name|insn
argument_list|)
condition|)
block|{
name|note
operator|=
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
name|orig_dest
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|note
condition|)
name|remove_note
argument_list|(
name|insn
argument_list|,
name|note
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|found_orig_dest
condition|)
block|{
comment|/* This should never happen.  */
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Update reg_n_sets.  This is necessary to prevent local alloc from      converting REG_EQUAL notes to REG_EQUIV when splitting has modified      a reg from set once to set multiple times.  */
block|{
name|rtx
name|x
init|=
name|PATTERN
argument_list|(
name|orig_insn
argument_list|)
decl_stmt|;
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|SET
operator|||
name|code
operator|==
name|CLOBBER
condition|)
name|update_n_sets
argument_list|(
name|x
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|code
operator|=
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|SET
operator|||
name|code
operator|==
name|CLOBBER
condition|)
name|update_n_sets
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|insn
operator|=
name|first
init|;
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|x
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|SET
operator|||
name|code
operator|==
name|CLOBBER
condition|)
name|update_n_sets
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|code
operator|=
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|SET
operator|||
name|code
operator|==
name|CLOBBER
condition|)
name|update_n_sets
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|insn
operator|==
name|last
condition|)
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* The one entry point in this file.  DUMP_FILE is the dump file for    this pass.  */
end_comment

begin_function
name|void
name|schedule_insns
parameter_list|(
name|dump_file
parameter_list|)
name|FILE
modifier|*
name|dump_file
decl_stmt|;
block|{
name|int
name|max_uid
init|=
name|MAX_INSNS_PER_SPLIT
operator|*
operator|(
name|get_max_uid
argument_list|()
operator|+
literal|1
operator|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|b
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
comment|/* Taking care of this degenerate case makes the rest of      this code simpler.  */
if|if
condition|(
name|n_basic_blocks
operator|==
literal|0
condition|)
return|return;
comment|/* Create an insn here so that we can hang dependencies off of it later.  */
name|sched_before_next_call
operator|=
name|gen_rtx
argument_list|(
name|INSN
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Initialize the unused_*_lists.  We can't use the ones left over from      the previous function, because gcc has freed that memory.  We can use      the ones left over from the first sched pass in the second pass however,      so only clear them on the first sched pass.  The first pass is before      reload if flag_schedule_insns is set, otherwise it is afterwards.  */
if|if
condition|(
name|reload_completed
operator|==
literal|0
operator|||
operator|!
name|flag_schedule_insns
condition|)
block|{
name|unused_insn_list
operator|=
literal|0
expr_stmt|;
name|unused_expr_list
operator|=
literal|0
expr_stmt|;
block|}
comment|/* We create no insns here, only reorder them, so we      remember how far we can cut back the stack on exit.  */
comment|/* Allocate data for this pass.  See comments, above,      for what these vectors do.  */
name|insn_luid
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|insn_priority
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|insn_tick
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|insn_costs
operator|=
operator|(
name|short
operator|*
operator|)
name|alloca
argument_list|(
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|insn_units
operator|=
operator|(
name|short
operator|*
operator|)
name|alloca
argument_list|(
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|insn_blockage
operator|=
operator|(
name|unsigned
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|max_uid
operator|*
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
argument_list|)
expr_stmt|;
name|insn_ref_count
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reload_completed
operator|==
literal|0
condition|)
block|{
name|sched_reg_n_deaths
operator|=
operator|(
name|short
operator|*
operator|)
name|alloca
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|sched_reg_n_calls_crossed
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|sched_reg_live_length
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bb_dead_regs
operator|=
operator|(
name|regset
operator|)
name|alloca
argument_list|(
name|regset_bytes
argument_list|)
expr_stmt|;
name|bb_live_regs
operator|=
operator|(
name|regset
operator|)
name|alloca
argument_list|(
name|regset_bytes
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|sched_reg_n_calls_crossed
argument_list|,
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|sched_reg_live_length
argument_list|,
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|reg_n_deaths
argument_list|,
name|sched_reg_n_deaths
argument_list|,
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|init_alias_analysis
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|sched_reg_n_deaths
operator|=
literal|0
expr_stmt|;
name|sched_reg_n_calls_crossed
operator|=
literal|0
expr_stmt|;
name|sched_reg_live_length
operator|=
literal|0
expr_stmt|;
name|bb_dead_regs
operator|=
literal|0
expr_stmt|;
name|bb_live_regs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|flag_schedule_insns
condition|)
name|init_alias_analysis
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|write_symbols
operator|!=
name|NO_DEBUG
condition|)
block|{
name|rtx
name|line
decl_stmt|;
name|line_note
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|line_note
argument_list|,
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|line_note_head
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|n_basic_blocks
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|line_note_head
argument_list|,
name|n_basic_blocks
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Determine the line-number at the start of each basic block. 	 This must be computed and saved now, because after a basic block's 	 predecessor has been scheduled, it is impossible to accurately 	 determine the correct line number for the first insn of the block.  */
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|n_basic_blocks
condition|;
name|b
operator|++
control|)
for|for
control|(
name|line
operator|=
name|basic_block_head
index|[
name|b
index|]
init|;
name|line
condition|;
name|line
operator|=
name|PREV_INSN
argument_list|(
name|line
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|line
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|line
argument_list|)
operator|>
literal|0
condition|)
block|{
name|line_note_head
index|[
name|b
index|]
operator|=
name|line
expr_stmt|;
break|break;
block|}
block|}
name|bzero
argument_list|(
name|insn_luid
argument_list|,
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|insn_priority
argument_list|,
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|insn_tick
argument_list|,
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|insn_costs
argument_list|,
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|insn_units
argument_list|,
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|insn_blockage
argument_list|,
name|max_uid
operator|*
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|insn_ref_count
argument_list|,
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Schedule each basic block, block by block.  */
if|if
condition|(
name|NEXT_INSN
argument_list|(
name|basic_block_end
index|[
name|n_basic_blocks
operator|-
literal|1
index|]
argument_list|)
operator|==
literal|0
operator|||
operator|(
name|GET_CODE
argument_list|(
name|basic_block_end
index|[
name|n_basic_blocks
operator|-
literal|1
index|]
argument_list|)
operator|!=
name|NOTE
operator|&&
name|GET_CODE
argument_list|(
name|basic_block_end
index|[
name|n_basic_blocks
operator|-
literal|1
index|]
argument_list|)
operator|!=
name|CODE_LABEL
operator|)
condition|)
name|emit_note_after
argument_list|(
name|NOTE_INSN_DELETED
argument_list|,
name|basic_block_end
index|[
name|n_basic_blocks
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|n_basic_blocks
condition|;
name|b
operator|++
control|)
block|{
name|rtx
name|insn
decl_stmt|,
name|next
decl_stmt|;
name|rtx
name|insns
decl_stmt|;
name|note_list
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|basic_block_head
index|[
name|b
index|]
init|;
condition|;
name|insn
operator|=
name|next
control|)
block|{
name|rtx
name|prev
decl_stmt|;
name|rtx
name|set
decl_stmt|;
comment|/* Can't use `next_real_insn' because that 	     might go across CODE_LABELS and short-out basic blocks.  */
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|INSN
condition|)
block|{
if|if
condition|(
name|insn
operator|==
name|basic_block_end
index|[
name|b
index|]
condition|)
break|break;
continue|continue;
block|}
comment|/* Don't split no-op move insns.  These should silently disappear 	     later in final.  Splitting such insns would break the code 	     that handles REG_NO_CONFLICT blocks.  */
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
operator|&&
name|rtx_equal_p
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|insn
operator|==
name|basic_block_end
index|[
name|b
index|]
condition|)
break|break;
comment|/* Nops get in the way while scheduling, so delete them now if 		 register allocation has already been done.  It is too risky 		 to try to do this before register allocation, and there are 		 unlikely to be very many nops then anyways.  */
if|if
condition|(
name|reload_completed
condition|)
block|{
name|PUT_CODE
argument_list|(
name|insn
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* Split insns here to get max fine-grain parallelism.  */
name|prev
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|reload_completed
operator|==
literal|0
condition|)
block|{
name|rtx
name|last
decl_stmt|,
name|first
init|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|notes
init|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|last
operator|=
name|try_split
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|last
operator|!=
name|insn
condition|)
block|{
comment|/* try_split returns the NOTE that INSN became.  */
name|first
operator|=
name|NEXT_INSN
argument_list|(
name|first
argument_list|)
expr_stmt|;
name|update_flow_info
argument_list|(
name|notes
argument_list|,
name|first
argument_list|,
name|last
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|PUT_CODE
argument_list|(
name|insn
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|basic_block_head
index|[
name|b
index|]
condition|)
name|basic_block_head
index|[
name|b
index|]
operator|=
name|first
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|basic_block_end
index|[
name|b
index|]
condition|)
block|{
name|basic_block_end
index|[
name|b
index|]
operator|=
name|last
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|insn
operator|==
name|basic_block_end
index|[
name|b
index|]
condition|)
break|break;
block|}
name|schedule_block
argument_list|(
name|b
argument_list|,
name|dump_file
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_C_ALLOCA
name|alloca
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Reposition the prologue and epilogue notes in case we moved the      prologue/epilogue insns.  */
if|if
condition|(
name|reload_completed
condition|)
name|reposition_prologue_and_epilogue_notes
argument_list|(
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_symbols
operator|!=
name|NO_DEBUG
condition|)
block|{
name|rtx
name|line
init|=
literal|0
decl_stmt|;
name|rtx
name|insn
init|=
name|get_insns
argument_list|()
decl_stmt|;
name|int
name|active_insn
init|=
literal|0
decl_stmt|;
name|int
name|notes
init|=
literal|0
decl_stmt|;
comment|/* Walk the insns deleting redundant line-number notes.  Many of these 	 are already present.  The remainder tend to occur at basic 	 block boundaries.  */
for|for
control|(
name|insn
operator|=
name|get_last_insn
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|/* If there are no active insns following, INSN is redundant.  */
if|if
condition|(
name|active_insn
operator|==
literal|0
condition|)
block|{
name|notes
operator|++
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
block|}
comment|/* If the line number is unchanged, LINE is redundant.  */
elseif|else
if|if
condition|(
name|line
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|line
argument_list|)
operator|==
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|&&
name|NOTE_SOURCE_FILE
argument_list|(
name|line
argument_list|)
operator|==
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|notes
operator|++
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|line
argument_list|)
operator|=
literal|0
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|line
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|line
operator|=
name|insn
expr_stmt|;
block|}
else|else
name|line
operator|=
name|insn
expr_stmt|;
name|active_insn
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_DELETED
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
operator|)
operator|)
operator|)
condition|)
name|active_insn
operator|++
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
name|notes
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|";; deleted %d line-number notes\n"
argument_list|,
name|notes
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reload_completed
operator|==
literal|0
condition|)
block|{
name|int
name|regno
decl_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|max_regno
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|sched_reg_live_length
index|[
name|regno
index|]
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
block|{
if|if
condition|(
name|reg_live_length
index|[
name|regno
index|]
operator|>
name|sched_reg_live_length
index|[
name|regno
index|]
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|";; register %d life shortened from %d to %d\n"
argument_list|,
name|regno
argument_list|,
name|reg_live_length
index|[
name|regno
index|]
argument_list|,
name|sched_reg_live_length
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
comment|/* Negative values are special; don't overwrite the current 		   reg_live_length value if it is negative.  */
elseif|else
if|if
condition|(
name|reg_live_length
index|[
name|regno
index|]
operator|<
name|sched_reg_live_length
index|[
name|regno
index|]
operator|&&
name|reg_live_length
index|[
name|regno
index|]
operator|>=
literal|0
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|";; register %d life extended from %d to %d\n"
argument_list|,
name|regno
argument_list|,
name|reg_live_length
index|[
name|regno
index|]
argument_list|,
name|sched_reg_live_length
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_n_calls_crossed
index|[
name|regno
index|]
operator|&&
operator|!
name|sched_reg_n_calls_crossed
index|[
name|regno
index|]
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|";; register %d no longer crosses calls\n"
argument_list|,
name|regno
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|reg_n_calls_crossed
index|[
name|regno
index|]
operator|&&
name|sched_reg_n_calls_crossed
index|[
name|regno
index|]
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|";; register %d now crosses calls\n"
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
comment|/* Negative values are special; don't overwrite the current 	       reg_live_length value if it is negative.  */
if|if
condition|(
name|reg_live_length
index|[
name|regno
index|]
operator|>=
literal|0
condition|)
name|reg_live_length
index|[
name|regno
index|]
operator|=
name|sched_reg_live_length
index|[
name|regno
index|]
expr_stmt|;
name|reg_n_calls_crossed
index|[
name|regno
index|]
operator|=
name|sched_reg_n_calls_crossed
index|[
name|regno
index|]
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INSN_SCHEDULING */
end_comment

end_unit

