begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Procedure integration for GNU CC.    Copyright (C) 1988, 1991, 1993 Free Software Foundation, Inc.    Contributed by Michael Tiemann (tiemann@cygnus.com)  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"insn-flags.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"integrate.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_decl_stmt
specifier|extern
name|struct
name|obstack
modifier|*
name|function_maybepermanent_obstack
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|tree
name|pushdecl
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|tree
name|poplevel
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Similar, but round to the next highest integer that meets the    alignment.  */
end_comment

begin_define
define|#
directive|define
name|CEIL_ROUND
parameter_list|(
name|VALUE
parameter_list|,
name|ALIGN
parameter_list|)
value|(((VALUE) + (ALIGN) - 1)& ~((ALIGN)- 1))
end_define

begin_comment
comment|/* Default max number of insns a function can have and still be inline.    This is overridden on RISC machines.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|INTEGRATE_THRESHOLD
end_ifndef

begin_define
define|#
directive|define
name|INTEGRATE_THRESHOLD
parameter_list|(
name|DECL
parameter_list|)
define|\
value|(8 * (8 + list_length (DECL_ARGUMENTS (DECL))))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Save any constant pool constants in an insn.  */
end_comment

begin_function_decl
specifier|static
name|void
name|save_constants
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Note when parameter registers are the destination of a SET.  */
end_comment

begin_function_decl
specifier|static
name|void
name|note_modified_parmregs
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Copy an rtx for save_for_inline_copying.  */
end_comment

begin_function_decl
specifier|static
name|rtx
name|copy_for_inline
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Make copies of MEMs in DECL_RTLs.  */
end_comment

begin_function_decl
specifier|static
name|void
name|copy_decl_rtls
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|copy_decl_tree
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|copy_decl_list
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|integrate_parm_decls
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|integrate_decl_tree
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|subst_constants
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Zero if the current function (whose FUNCTION_DECL is FNDECL)    is safe and reasonable to integrate into other functions.    Nonzero means value is a warning message with a single %s    for the function's name.  */
end_comment

begin_function
name|char
modifier|*
name|function_cannot_inline_p
parameter_list|(
name|fndecl
parameter_list|)
specifier|register
name|tree
name|fndecl
decl_stmt|;
block|{
specifier|register
name|rtx
name|insn
decl_stmt|;
name|tree
name|last
init|=
name|tree_last
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|max_insns
init|=
name|INTEGRATE_THRESHOLD
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
specifier|register
name|int
name|ninsns
init|=
literal|0
decl_stmt|;
specifier|register
name|tree
name|parms
decl_stmt|;
comment|/* No inlines with varargs.  `grokdeclarator' gives a warning      message about that if `inline' is specified.  This code      it put in to catch the volunteers.  */
if|if
condition|(
operator|(
name|last
operator|&&
name|TREE_VALUE
argument_list|(
name|last
argument_list|)
operator|!=
name|void_type_node
operator|)
operator|||
operator|(
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
operator|&&
name|DECL_NAME
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"__builtin_va_alist"
argument_list|)
operator|)
condition|)
return|return
literal|"varargs function cannot be inline"
return|;
if|if
condition|(
name|current_function_calls_alloca
condition|)
return|return
literal|"function using alloca cannot be inline"
return|;
if|if
condition|(
name|current_function_contains_functions
condition|)
return|return
literal|"function with nested functions cannot be inline"
return|;
comment|/* This restriction may be eliminated sometime soon.  But for now, don't      worry about remapping the static chain.  */
if|if
condition|(
name|current_function_needs_context
condition|)
return|return
literal|"nested function cannot be inline"
return|;
comment|/* If its not even close, don't even look.  */
if|if
condition|(
operator|!
name|DECL_INLINE
argument_list|(
name|fndecl
argument_list|)
operator|&&
name|get_max_uid
argument_list|()
operator|>
literal|3
operator|*
name|max_insns
condition|)
return|return
literal|"function too large to be inline"
return|;
if|#
directive|if
literal|0
comment|/* Large stacks are OK now that inlined functions can share them.  */
comment|/* Don't inline functions with large stack usage,      since they can make other recursive functions burn up stack.  */
block|if (!DECL_INLINE (fndecl)&& get_frame_size ()> 100)     return "function stack frame for inlining";
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/* Don't inline functions which do not specify a function prototype and      have BLKmode argument or take the address of a parameter.  */
block|for (parms = DECL_ARGUMENTS (fndecl); parms; parms = TREE_CHAIN (parms))     {       if (TYPE_MODE (TREE_TYPE (parms)) == BLKmode) 	TREE_ADDRESSABLE (parms) = 1;       if (last == NULL_TREE&& TREE_ADDRESSABLE (parms)) 	return "no prototype, and parameter address used; cannot be inline";     }
endif|#
directive|endif
comment|/* We can't inline functions that return structures      the old-fashioned PCC way, copying into a static block.  */
if|if
condition|(
name|current_function_returns_pcc_struct
condition|)
return|return
literal|"inline functions not supported for this return value type"
return|;
comment|/* We can't inline functions that return structures of varying size.  */
if|if
condition|(
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|"function with varying-size return value cannot be inline"
return|;
comment|/* Cannot inline a function with a varying size argument.  */
for|for
control|(
name|parms
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
init|;
name|parms
condition|;
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
control|)
if|if
condition|(
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|"function with varying-size parameter cannot be inline"
return|;
if|if
condition|(
operator|!
name|DECL_INLINE
argument_list|(
name|fndecl
argument_list|)
operator|&&
name|get_max_uid
argument_list|()
operator|>
name|max_insns
condition|)
block|{
for|for
control|(
name|ninsns
operator|=
literal|0
operator|,
name|insn
operator|=
name|get_first_nonparm_insn
argument_list|()
init|;
name|insn
operator|&&
name|ninsns
operator|<
name|max_insns
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
name|ninsns
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|ninsns
operator|>=
name|max_insns
condition|)
return|return
literal|"function too large to be inline"
return|;
block|}
comment|/* We cannot inline this function if forced_labels is non-zero.  This      implies that a label in this function was used as an initializer.      Because labels can not be duplicated, all labels in the function      will be renamed when it is inlined.  However, there is no way to find      and fix all variables initialized with addresses of labels in this      function, hence inlining is impossible.  */
if|if
condition|(
name|forced_labels
condition|)
return|return
literal|"function with label addresses used in initializers cannot inline"
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Variables used within save_for_inline.  */
end_comment

begin_comment
comment|/* Mapping from old pseudo-register to new pseudo-registers.    The first element of this map is reg_map[FIRST_PSEUDO_REGISTER].    It is allocated in `save_for_inline' and `expand_inline_function',    and deallocated on exit from each of those routines.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|reg_map
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Mapping from old code-labels to new code-labels.    The first element of this map is label_map[min_labelno].    It is allocated in `save_for_inline' and `expand_inline_function',    and deallocated on exit from each of those routines.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|label_map
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Mapping from old insn uid's to copied insns.    It is allocated in `save_for_inline' and `expand_inline_function',    and deallocated on exit from each of those routines.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|insn_map
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Map pseudo reg number into the PARM_DECL for the parm living in the reg.    Zero for a reg that isn't a parm's home.    Only reg numbers less than max_parm_reg are mapped here.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
modifier|*
name|parmdecl_map
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Keep track of first pseudo-register beyond those that are parms.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_parm_reg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When an insn is being copied by copy_for_inline,    this is nonzero if we have copied an ASM_OPERANDS.    In that case, it is the original input-operand vector.  */
end_comment

begin_decl_stmt
specifier|static
name|rtvec
name|orig_asm_operands_vector
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When an insn is being copied by copy_for_inline,    this is nonzero if we have copied an ASM_OPERANDS.    In that case, it is the copied input-operand vector.  */
end_comment

begin_decl_stmt
specifier|static
name|rtvec
name|copy_asm_operands_vector
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Likewise, this is the copied constraints vector.  */
end_comment

begin_decl_stmt
specifier|static
name|rtvec
name|copy_asm_constraints_vector
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* In save_for_inline, nonzero if past the parm-initialization insns.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|in_nonparm_insns
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Subroutine for `save_for_inline{copying,nocopy}'.  Performs initialization    needed to save FNDECL's insns and info for future inline expansion.  */
end_comment

begin_function
specifier|static
name|rtx
name|initialize_for_inline
parameter_list|(
name|fndecl
parameter_list|,
name|min_labelno
parameter_list|,
name|max_labelno
parameter_list|,
name|max_reg
parameter_list|,
name|copy
parameter_list|)
name|tree
name|fndecl
decl_stmt|;
name|int
name|min_labelno
decl_stmt|;
name|int
name|max_labelno
decl_stmt|;
name|int
name|max_reg
decl_stmt|;
name|int
name|copy
decl_stmt|;
block|{
name|int
name|function_flags
decl_stmt|,
name|i
decl_stmt|;
name|rtvec
name|arg_vector
decl_stmt|;
name|tree
name|parms
decl_stmt|;
comment|/* Compute the values of any flags we must restore when inlining this.  */
name|function_flags
operator|=
operator|(
name|current_function_calls_alloca
operator|*
name|FUNCTION_FLAGS_CALLS_ALLOCA
operator|+
name|current_function_calls_setjmp
operator|*
name|FUNCTION_FLAGS_CALLS_SETJMP
operator|+
name|current_function_calls_longjmp
operator|*
name|FUNCTION_FLAGS_CALLS_LONGJMP
operator|+
name|current_function_returns_struct
operator|*
name|FUNCTION_FLAGS_RETURNS_STRUCT
operator|+
name|current_function_returns_pcc_struct
operator|*
name|FUNCTION_FLAGS_RETURNS_PCC_STRUCT
operator|+
name|current_function_needs_context
operator|*
name|FUNCTION_FLAGS_NEEDS_CONTEXT
operator|+
name|current_function_has_nonlocal_label
operator|*
name|FUNCTION_FLAGS_HAS_NONLOCAL_LABEL
operator|+
name|current_function_returns_pointer
operator|*
name|FUNCTION_FLAGS_RETURNS_POINTER
operator|+
name|current_function_uses_const_pool
operator|*
name|FUNCTION_FLAGS_USES_CONST_POOL
operator|+
name|current_function_uses_pic_offset_table
operator|*
name|FUNCTION_FLAGS_USES_PIC_OFFSET_TABLE
operator|)
expr_stmt|;
comment|/* Clear out PARMDECL_MAP.  It was allocated in the caller's frame.  */
name|bzero
argument_list|(
name|parmdecl_map
argument_list|,
name|max_parm_reg
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
name|arg_vector
operator|=
name|rtvec_alloc
argument_list|(
name|list_length
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|parms
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
operator|,
name|i
operator|=
literal|0
init|;
name|parms
condition|;
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
name|rtx
name|p
init|=
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|MEM
operator|&&
name|copy
condition|)
block|{
comment|/* Copy the rtl so that modifications of the addresses 	     later in compilation won't affect this arg_vector. 	     Virtual register instantiation can screw the address 	     of the rtl.  */
name|rtx
name|new
init|=
name|copy_rtx
argument_list|(
name|p
argument_list|)
decl_stmt|;
comment|/* Don't leave the old copy anywhere in this decl.  */
if|if
condition|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
operator|==
name|DECL_INCOMING_RTL
argument_list|(
name|parms
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|DECL_INCOMING_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|XEXP
argument_list|(
name|DECL_INCOMING_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
operator|)
condition|)
name|DECL_INCOMING_RTL
argument_list|(
name|parms
argument_list|)
operator|=
name|new
expr_stmt|;
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
operator|=
name|new
expr_stmt|;
block|}
name|RTVEC_ELT
argument_list|(
name|arg_vector
argument_list|,
name|i
argument_list|)
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|REG
condition|)
name|parmdecl_map
index|[
name|REGNO
argument_list|(
name|p
argument_list|)
index|]
operator|=
name|parms
expr_stmt|;
comment|/* This flag is cleared later 	 if the function ever modifies the value of the parm.  */
name|TREE_READONLY
argument_list|(
name|parms
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Assume we start out in the insns that set up the parameters.  */
name|in_nonparm_insns
operator|=
literal|0
expr_stmt|;
comment|/* The list of DECL_SAVED_INSNS, starts off with a header which      contains the following information:       the first insn of the function (not including the insns that copy      parameters into registers).      the first parameter insn of the function,      the first label used by that function,      the last label used by that function,      the highest register number used for parameters,      the total number of registers used,      the size of the incoming stack area for parameters,      the number of bytes popped on return,      the stack slot list,      some flags that are used to restore compiler globals,      the value of current_function_outgoing_args_size,      the original argument vector,      and the original DECL_INITIAL.  */
return|return
name|gen_inline_header_rtx
argument_list|(
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|,
name|min_labelno
argument_list|,
name|max_labelno
argument_list|,
name|max_parm_reg
argument_list|,
name|max_reg
argument_list|,
name|current_function_args_size
argument_list|,
name|current_function_pops_args
argument_list|,
name|stack_slot_list
argument_list|,
name|function_flags
argument_list|,
name|current_function_outgoing_args_size
argument_list|,
name|arg_vector
argument_list|,
operator|(
name|rtx
operator|)
name|DECL_INITIAL
argument_list|(
name|fndecl
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Subroutine for `save_for_inline{copying,nocopy}'.  Finishes up the    things that must be done to make FNDECL expandable as an inline function.    HEAD contains the chain of insns to which FNDECL will expand.  */
end_comment

begin_function
specifier|static
name|void
name|finish_inline
parameter_list|(
name|fndecl
parameter_list|,
name|head
parameter_list|)
name|tree
name|fndecl
decl_stmt|;
name|rtx
name|head
decl_stmt|;
block|{
name|NEXT_INSN
argument_list|(
name|head
argument_list|)
operator|=
name|get_first_nonparm_insn
argument_list|()
expr_stmt|;
name|FIRST_PARM_INSN
argument_list|(
name|head
argument_list|)
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|DECL_SAVED_INSNS
argument_list|(
name|fndecl
argument_list|)
operator|=
name|head
expr_stmt|;
name|DECL_FRAME_SIZE
argument_list|(
name|fndecl
argument_list|)
operator|=
name|get_frame_size
argument_list|()
expr_stmt|;
name|DECL_INLINE
argument_list|(
name|fndecl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Adjust the BLOCK_END_NOTE pointers in a given copied DECL tree so that    they all point to the new (copied) rtxs.  */
end_comment

begin_function
specifier|static
name|void
name|adjust_copied_decl_tree
parameter_list|(
name|block
parameter_list|)
specifier|register
name|tree
name|block
decl_stmt|;
block|{
specifier|register
name|tree
name|subblock
decl_stmt|;
specifier|register
name|rtx
name|original_end
decl_stmt|;
name|original_end
operator|=
name|BLOCK_END_NOTE
argument_list|(
name|block
argument_list|)
expr_stmt|;
if|if
condition|(
name|original_end
condition|)
block|{
name|BLOCK_END_NOTE
argument_list|(
name|block
argument_list|)
operator|=
operator|(
name|rtx
operator|)
name|NOTE_SOURCE_FILE
argument_list|(
name|original_end
argument_list|)
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|original_end
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Process all subblocks.  */
for|for
control|(
name|subblock
operator|=
name|BLOCK_SUBBLOCKS
argument_list|(
name|block
argument_list|)
init|;
name|subblock
condition|;
name|subblock
operator|=
name|TREE_CHAIN
argument_list|(
name|subblock
argument_list|)
control|)
name|adjust_copied_decl_tree
argument_list|(
name|subblock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make the insns and PARM_DECLs of the current function permanent    and record other information in DECL_SAVED_INSNS to allow inlining    of this function in subsequent calls.     This function is called when we are going to immediately compile    the insns for FNDECL.  The insns in maybepermanent_obstack cannot be    modified by the compilation process, so we copy all of them to    new storage and consider the new insns to be the insn chain to be    compiled.  Our caller (rest_of_compilation) saves the original    DECL_INITIAL and DECL_ARGUMENTS; here we copy them.  */
end_comment

begin_function
name|void
name|save_for_inline_copying
parameter_list|(
name|fndecl
parameter_list|)
name|tree
name|fndecl
decl_stmt|;
block|{
name|rtx
name|first_insn
decl_stmt|,
name|last_insn
decl_stmt|,
name|insn
decl_stmt|;
name|rtx
name|head
decl_stmt|,
name|copy
decl_stmt|;
name|int
name|max_labelno
decl_stmt|,
name|min_labelno
decl_stmt|,
name|i
decl_stmt|,
name|len
decl_stmt|;
name|int
name|max_reg
decl_stmt|;
name|int
name|max_uid
decl_stmt|;
name|rtx
name|first_nonparm_insn
decl_stmt|;
comment|/* Make and emit a return-label if we have not already done so.       Do this before recording the bounds on label numbers. */
if|if
condition|(
name|return_label
operator|==
literal|0
condition|)
block|{
name|return_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|return_label
argument_list|)
expr_stmt|;
block|}
comment|/* Get some bounds on the labels and registers used.  */
name|max_labelno
operator|=
name|max_label_num
argument_list|()
expr_stmt|;
name|min_labelno
operator|=
name|get_first_label_num
argument_list|()
expr_stmt|;
name|max_reg
operator|=
name|max_reg_num
argument_list|()
expr_stmt|;
comment|/* Set up PARMDECL_MAP which maps pseudo-reg number to its PARM_DECL.      Later we set TREE_READONLY to 0 if the parm is modified inside the fn.      Also set up ARG_VECTOR, which holds the unmodified DECL_RTX values      for the parms, prior to elimination of virtual registers.      These values are needed for substituting parms properly.  */
name|max_parm_reg
operator|=
name|max_parm_reg_num
argument_list|()
expr_stmt|;
name|parmdecl_map
operator|=
operator|(
name|tree
operator|*
operator|)
name|alloca
argument_list|(
name|max_parm_reg
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
name|head
operator|=
name|initialize_for_inline
argument_list|(
name|fndecl
argument_list|,
name|min_labelno
argument_list|,
name|max_labelno
argument_list|,
name|max_reg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_function_uses_const_pool
condition|)
block|{
comment|/* Replace any constant pool references with the actual constant.  We 	 will put the constants back in the copy made below.  */
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
block|{
name|save_constants
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
condition|)
name|save_constants
argument_list|(
operator|&
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Clear out the constant pool so that we can recreate it with the 	 copied constants below.  */
name|init_const_rtx_hash_table
argument_list|()
expr_stmt|;
name|clear_const_double_mem
argument_list|()
expr_stmt|;
block|}
name|max_uid
operator|=
name|INSN_UID
argument_list|(
name|head
argument_list|)
expr_stmt|;
comment|/* We have now allocated all that needs to be allocated permanently      on the rtx obstack.  Set our high-water mark, so that we      can free the rest of this when the time comes.  */
name|preserve_data
argument_list|()
expr_stmt|;
comment|/* Copy the chain insns of this function.      Install the copied chain as the insns of this function,      for continued compilation;      the original chain is recorded as the DECL_SAVED_INSNS      for inlining future calls.  */
comment|/* If there are insns that copy parms from the stack into pseudo registers,      those insns are not copied.  `expand_inline_function' must      emit the correct code to handle such things.  */
name|insn
operator|=
name|get_insns
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
condition|)
name|abort
argument_list|()
expr_stmt|;
name|first_insn
operator|=
name|rtx_alloc
argument_list|(
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|first_insn
argument_list|)
operator|=
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|first_insn
argument_list|)
operator|=
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|INSN_UID
argument_list|(
name|first_insn
argument_list|)
operator|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|PREV_INSN
argument_list|(
name|first_insn
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|first_insn
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|last_insn
operator|=
name|first_insn
expr_stmt|;
comment|/* Each pseudo-reg in the old insn chain must have a unique rtx in the copy.      Make these new rtx's now, and install them in regno_reg_rtx, so they      will be the official pseudo-reg rtx's for the rest of compilation.  */
name|reg_map
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|max_reg
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|rtx_def
argument_list|)
operator|+
operator|(
name|GET_RTX_LENGTH
argument_list|(
name|REG
argument_list|)
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|rtunion
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|max_reg
operator|-
literal|1
init|;
name|i
operator|>
name|LAST_VIRTUAL_REGISTER
condition|;
name|i
operator|--
control|)
name|reg_map
index|[
name|i
index|]
operator|=
operator|(
name|rtx
operator|)
name|obstack_copy
argument_list|(
name|function_maybepermanent_obstack
argument_list|,
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|reg_map
operator|+
name|LAST_VIRTUAL_REGISTER
operator|+
literal|1
argument_list|,
name|regno_reg_rtx
operator|+
name|LAST_VIRTUAL_REGISTER
operator|+
literal|1
argument_list|,
operator|(
name|max_reg
operator|-
operator|(
name|LAST_VIRTUAL_REGISTER
operator|+
literal|1
operator|)
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Likewise each label rtx must have a unique rtx as its copy.  */
name|label_map
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|max_labelno
operator|-
name|min_labelno
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|label_map
operator|-=
name|min_labelno
expr_stmt|;
for|for
control|(
name|i
operator|=
name|min_labelno
init|;
name|i
operator|<
name|max_labelno
condition|;
name|i
operator|++
control|)
name|label_map
index|[
name|i
index|]
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
comment|/* Record the mapping of old insns to copied insns.  */
name|insn_map
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|insn_map
argument_list|,
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get the insn which signals the end of parameter setup code.  */
name|first_nonparm_insn
operator|=
name|get_first_nonparm_insn
argument_list|()
expr_stmt|;
comment|/* Copy any entries in regno_reg_rtx or DECL_RTLs that reference MEM      (the former occurs when a variable has its address taken)      since these may be shared and can be changed by virtual      register instantiation.  DECL_RTL values for our arguments      have already been copied by initialize_for_inline.  */
for|for
control|(
name|i
operator|=
name|LAST_VIRTUAL_REGISTER
operator|+
literal|1
init|;
name|i
operator|<
name|max_reg
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|)
operator|==
name|MEM
condition|)
name|XEXP
argument_list|(
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
operator|=
name|copy_for_inline
argument_list|(
name|XEXP
argument_list|(
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Copy the tree of subblocks of the function, and the decls in them.      We will use the copy for compiling this function, then restore the original      subblocks and decls for use when inlining this function.       Several parts of the compiler modify BLOCK trees.  In particular,      instantiate_virtual_regs will instantiate any virtual regs      mentioned in the DECL_RTLs of the decls, and loop      unrolling will replicate any BLOCK trees inside an unrolled loop.       The modified subblocks or DECL_RTLs would be incorrect for the original rtl      which we will use for inlining.  The rtl might even contain pseudoregs      whose space has been freed.  */
name|DECL_INITIAL
argument_list|(
name|fndecl
argument_list|)
operator|=
name|copy_decl_tree
argument_list|(
name|DECL_INITIAL
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
operator|=
name|copy_decl_list
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now copy each DECL_RTL which is a MEM,      so it is safe to modify their addresses.  */
name|copy_decl_rtls
argument_list|(
name|DECL_INITIAL
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The fndecl node acts as its own progenitor, so mark it as such.  */
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|fndecl
argument_list|)
operator|=
name|fndecl
expr_stmt|;
comment|/* Now copy the chain of insns.  Do this twice.  The first copy the insn      itself and its body.  The second time copy of REG_NOTES.  This is because      a REG_NOTE may have a forward pointer to another insn.  */
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|orig_asm_operands_vector
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|first_nonparm_insn
condition|)
name|in_nonparm_insns
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|NOTE
case|:
comment|/* No need to keep these.  */
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_DELETED
condition|)
continue|continue;
name|copy
operator|=
name|rtx_alloc
argument_list|(
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|copy
argument_list|)
operator|=
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE_INSN_BLOCK_END
condition|)
name|NOTE_SOURCE_FILE
argument_list|(
name|copy
argument_list|)
operator|=
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
expr_stmt|;
else|else
block|{
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|=
operator|(
name|char
operator|*
operator|)
name|copy
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|copy
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|INSN
case|:
case|case
name|CALL_INSN
case|:
case|case
name|JUMP_INSN
case|:
name|copy
operator|=
name|rtx_alloc
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|PATTERN
argument_list|(
name|copy
argument_list|)
operator|=
name|copy_for_inline
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|INSN_CODE
argument_list|(
name|copy
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
name|LOG_LINKS
argument_list|(
name|copy
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|RTX_INTEGRATED_P
argument_list|(
name|copy
argument_list|)
operator|=
name|RTX_INTEGRATED_P
argument_list|(
name|insn
argument_list|)
expr_stmt|;
break|break;
case|case
name|CODE_LABEL
case|:
name|copy
operator|=
name|label_map
index|[
name|CODE_LABEL_NUMBER
argument_list|(
name|insn
argument_list|)
index|]
expr_stmt|;
name|LABEL_NAME
argument_list|(
name|copy
argument_list|)
operator|=
name|LABEL_NAME
argument_list|(
name|insn
argument_list|)
expr_stmt|;
break|break;
case|case
name|BARRIER
case|:
name|copy
operator|=
name|rtx_alloc
argument_list|(
name|BARRIER
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|INSN_UID
argument_list|(
name|copy
argument_list|)
operator|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|insn_map
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
operator|=
name|copy
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|last_insn
argument_list|)
operator|=
name|copy
expr_stmt|;
name|PREV_INSN
argument_list|(
name|copy
argument_list|)
operator|=
name|last_insn
expr_stmt|;
name|last_insn
operator|=
name|copy
expr_stmt|;
block|}
name|adjust_copied_decl_tree
argument_list|(
name|DECL_INITIAL
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now copy the REG_NOTES.  */
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|get_insns
argument_list|()
argument_list|)
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
operator|&&
name|insn_map
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
condition|)
name|REG_NOTES
argument_list|(
name|insn_map
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
argument_list|)
operator|=
name|copy_for_inline
argument_list|(
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|last_insn
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|finish_inline
argument_list|(
name|fndecl
argument_list|,
name|head
argument_list|)
expr_stmt|;
name|set_new_first_and_last_insn
argument_list|(
name|first_insn
argument_list|,
name|last_insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a copy of a chain of nodes, chained through the TREE_CHAIN field.    For example, this can copy a list made of TREE_LIST nodes.  While copying,    for each node copied which doesn't already have is DECL_ABSTRACT_ORIGIN    set to some non-zero value, set the DECL_ABSTRACT_ORIGIN of the copy to    point to the corresponding (abstract) original node.  */
end_comment

begin_function
specifier|static
name|tree
name|copy_decl_list
parameter_list|(
name|list
parameter_list|)
name|tree
name|list
decl_stmt|;
block|{
name|tree
name|head
decl_stmt|;
specifier|register
name|tree
name|prev
decl_stmt|,
name|next
decl_stmt|;
if|if
condition|(
name|list
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|head
operator|=
name|prev
operator|=
name|copy_node
argument_list|(
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|head
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|head
argument_list|)
operator|=
name|list
expr_stmt|;
name|next
operator|=
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
expr_stmt|;
while|while
condition|(
name|next
condition|)
block|{
specifier|register
name|tree
name|copy
decl_stmt|;
name|copy
operator|=
name|copy_node
argument_list|(
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|copy
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|copy
argument_list|)
operator|=
name|next
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|prev
argument_list|)
operator|=
name|copy
expr_stmt|;
name|prev
operator|=
name|copy
expr_stmt|;
name|next
operator|=
name|TREE_CHAIN
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
return|return
name|head
return|;
block|}
end_function

begin_comment
comment|/* Make a copy of the entire tree of blocks BLOCK, and return it.  */
end_comment

begin_function
specifier|static
name|tree
name|copy_decl_tree
parameter_list|(
name|block
parameter_list|)
name|tree
name|block
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|,
name|vars
decl_stmt|,
name|subblocks
decl_stmt|;
name|vars
operator|=
name|copy_decl_list
argument_list|(
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
argument_list|)
expr_stmt|;
name|subblocks
operator|=
literal|0
expr_stmt|;
comment|/* Process all subblocks.  */
for|for
control|(
name|t
operator|=
name|BLOCK_SUBBLOCKS
argument_list|(
name|block
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|tree
name|copy
init|=
name|copy_decl_tree
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|TREE_CHAIN
argument_list|(
name|copy
argument_list|)
operator|=
name|subblocks
expr_stmt|;
name|subblocks
operator|=
name|copy
expr_stmt|;
block|}
name|t
operator|=
name|copy_node
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|BLOCK_VARS
argument_list|(
name|t
argument_list|)
operator|=
name|vars
expr_stmt|;
name|BLOCK_SUBBLOCKS
argument_list|(
name|t
argument_list|)
operator|=
name|nreverse
argument_list|(
name|subblocks
argument_list|)
expr_stmt|;
comment|/* If the BLOCK being cloned is already marked as having been instantiated      from something else, then leave that `origin' marking alone.  Elsewise,      mark the clone as having originated from the BLOCK we are cloning.  */
if|if
condition|(
name|BLOCK_ABSTRACT_ORIGIN
argument_list|(
name|t
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|BLOCK_ABSTRACT_ORIGIN
argument_list|(
name|t
argument_list|)
operator|=
name|block
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Copy DECL_RTLs in all decls in the given BLOCK node.  */
end_comment

begin_function
specifier|static
name|void
name|copy_decl_rtls
parameter_list|(
name|block
parameter_list|)
name|tree
name|block
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|DECL_RTL
argument_list|(
name|t
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
name|DECL_RTL
argument_list|(
name|t
argument_list|)
operator|=
name|copy_for_inline
argument_list|(
name|DECL_RTL
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Process all subblocks.  */
for|for
control|(
name|t
operator|=
name|BLOCK_SUBBLOCKS
argument_list|(
name|block
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
name|copy_decl_rtls
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make the insns and PARM_DECLs of the current function permanent    and record other information in DECL_SAVED_INSNS to allow inlining    of this function in subsequent calls.     This routine need not copy any insns because we are not going    to immediately compile the insns in the insn chain.  There    are two cases when we would compile the insns for FNDECL:    (1) when FNDECL is expanded inline, and (2) when FNDECL needs to    be output at the end of other compilation, because somebody took    its address.  In the first case, the insns of FNDECL are copied    as it is expanded inline, so FNDECL's saved insns are not    modified.  In the second case, FNDECL is used for the last time,    so modifying the rtl is not a problem.     ??? Actually, we do not verify that FNDECL is not inline expanded    by other functions which must also be written down at the end    of compilation.  We could set flag_no_inline to nonzero when    the time comes to write down such functions.  */
end_comment

begin_function
name|void
name|save_for_inline_nocopy
parameter_list|(
name|fndecl
parameter_list|)
name|tree
name|fndecl
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
name|rtx
name|head
decl_stmt|,
name|copy
decl_stmt|;
name|tree
name|parms
decl_stmt|;
name|int
name|max_labelno
decl_stmt|,
name|min_labelno
decl_stmt|,
name|i
decl_stmt|,
name|len
decl_stmt|;
name|int
name|max_reg
decl_stmt|;
name|int
name|max_uid
decl_stmt|;
name|rtx
name|first_nonparm_insn
decl_stmt|;
name|int
name|function_flags
decl_stmt|;
comment|/* Set up PARMDECL_MAP which maps pseudo-reg number to its PARM_DECL.      Later we set TREE_READONLY to 0 if the parm is modified inside the fn.      Also set up ARG_VECTOR, which holds the unmodified DECL_RTX values      for the parms, prior to elimination of virtual registers.      These values are needed for substituting parms properly.  */
name|max_parm_reg
operator|=
name|max_parm_reg_num
argument_list|()
expr_stmt|;
name|parmdecl_map
operator|=
operator|(
name|tree
operator|*
operator|)
name|alloca
argument_list|(
name|max_parm_reg
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make and emit a return-label if we have not already done so.  */
if|if
condition|(
name|return_label
operator|==
literal|0
condition|)
block|{
name|return_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|return_label
argument_list|)
expr_stmt|;
block|}
name|head
operator|=
name|initialize_for_inline
argument_list|(
name|fndecl
argument_list|,
name|get_first_label_num
argument_list|()
argument_list|,
name|max_label_num
argument_list|()
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If there are insns that copy parms from the stack into pseudo registers,      those insns are not copied.  `expand_inline_function' must      emit the correct code to handle such things.  */
name|insn
operator|=
name|get_insns
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Get the insn which signals the end of parameter setup code.  */
name|first_nonparm_insn
operator|=
name|get_first_nonparm_insn
argument_list|()
expr_stmt|;
comment|/* Now just scan the chain of insns to see what happens to our      PARM_DECLs.  If a PARM_DECL is used but never modified, we      can substitute its rtl directly when expanding inline (and      perform constant folding when its incoming value is constant).      Otherwise, we have to copy its value into a new register and track      the new register's life.  */
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|insn
operator|==
name|first_nonparm_insn
condition|)
name|in_nonparm_insns
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
block|{
if|if
condition|(
name|current_function_uses_const_pool
condition|)
block|{
comment|/* Replace any constant pool references with the actual constant. 		 We will put the constant back if we need to write the 		 function out after all.  */
name|save_constants
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
condition|)
name|save_constants
argument_list|(
operator|&
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Record what interesting things happen to our parameters.  */
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|note_modified_parmregs
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* We have now allocated all that needs to be allocated permanently      on the rtx obstack.  Set our high-water mark, so that we      can free the rest of this when the time comes.  */
name|preserve_data
argument_list|()
expr_stmt|;
name|finish_inline
argument_list|(
name|fndecl
argument_list|,
name|head
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given PX, a pointer into an insn, search for references to the constant    pool.  Replace each with a CONST that has the mode of the original    constant, contains the constant, and has RTX_INTEGRATED_P set.    Similarly, constant pool addresses not enclosed in a MEM are replaced    with an ADDRESS rtx which also gives the constant, mode, and has    RTX_INTEGRATED_P set.  */
end_comment

begin_function
specifier|static
name|void
name|save_constants
parameter_list|(
name|px
parameter_list|)
name|rtx
modifier|*
name|px
decl_stmt|;
block|{
name|rtx
name|x
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|again
label|:
name|x
operator|=
operator|*
name|px
expr_stmt|;
comment|/* If this is a CONST_DOUBLE, don't try to fix things up in       CONST_DOUBLE_MEM, because this is an infinite recursion.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
return|return;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|enum
name|machine_mode
name|const_mode
init|=
name|get_pool_mode
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|new
init|=
name|gen_rtx
argument_list|(
name|CONST
argument_list|,
name|const_mode
argument_list|,
name|get_pool_constant
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|RTX_INTEGRATED_P
argument_list|(
name|new
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* If the MEM was in a different mode than the constant (perhaps we 	 were only looking at the low-order part), surround it with a  	 SUBREG so we can save both modes.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|const_mode
condition|)
block|{
name|new
operator|=
name|gen_rtx
argument_list|(
name|SUBREG
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|new
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|RTX_INTEGRATED_P
argument_list|(
name|new
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
operator|*
name|px
operator|=
name|new
expr_stmt|;
name|save_constants
argument_list|(
operator|&
name|XEXP
argument_list|(
operator|*
name|px
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
operator|*
name|px
operator|=
name|gen_rtx
argument_list|(
name|ADDRESS
argument_list|,
name|get_pool_mode
argument_list|(
name|x
argument_list|)
argument_list|,
name|get_pool_constant
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|save_constants
argument_list|(
operator|&
name|XEXP
argument_list|(
operator|*
name|px
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_INTEGRATED_P
argument_list|(
operator|*
name|px
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|fmt
init|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
name|len
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
switch|switch
condition|(
name|fmt
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'E'
case|:
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|save_constants
argument_list|(
operator|&
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
comment|/* Hack tail-recursion here.  */
name|px
operator|=
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
name|save_constants
argument_list|(
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Note whether a parameter is modified or not.  */
end_comment

begin_function
specifier|static
name|void
name|note_modified_parmregs
parameter_list|(
name|reg
parameter_list|,
name|x
parameter_list|)
name|rtx
name|reg
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|REG
operator|&&
name|in_nonparm_insns
operator|&&
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|<
name|max_parm_reg
operator|&&
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|parmdecl_map
index|[
name|REGNO
argument_list|(
name|reg
argument_list|)
index|]
operator|!=
literal|0
condition|)
name|TREE_READONLY
argument_list|(
name|parmdecl_map
index|[
name|REGNO
argument_list|(
name|reg
argument_list|)
index|]
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy the rtx ORIG recursively, replacing pseudo-regs and labels    according to `reg_map' and `label_map'.  The original rtl insns    will be saved for inlining; this is used to make a copy    which is used to finish compiling the inline function itself.     If we find a "saved" constant pool entry, one which was replaced with    the value of the constant, convert it back to a constant pool entry.    Since the pool wasn't touched, this should simply restore the old    address.     All other kinds of rtx are copied except those that can never be    changed during compilation.  */
end_comment

begin_function
specifier|static
name|rtx
name|copy_for_inline
parameter_list|(
name|orig
parameter_list|)
name|rtx
name|orig
decl_stmt|;
block|{
specifier|register
name|rtx
name|x
init|=
name|orig
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|register
name|char
modifier|*
name|format_ptr
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
name|x
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* These types may be freely shared.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|QUEUED
case|:
case|case
name|CONST_INT
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
return|return
name|x
return|;
case|case
name|CONST_DOUBLE
case|:
comment|/* We have to make a new CONST_DOUBLE to ensure that we account for 	 it correctly.  Using the old CONST_DOUBLE_MEM data is wrong.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
block|{
name|REAL_VALUE_TYPE
name|d
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|d
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
name|immed_real_const_1
argument_list|(
name|d
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
return|;
block|}
else|else
return|return
name|immed_double_const
argument_list|(
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
argument_list|,
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
argument_list|,
name|VOIDmode
argument_list|)
return|;
case|case
name|CONST
case|:
comment|/* Get constant pool entry for constant in the pool.  */
if|if
condition|(
name|RTX_INTEGRATED_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|validize_mem
argument_list|(
name|force_const_mem
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|copy_for_inline
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
break|break;
case|case
name|SUBREG
case|:
comment|/* Get constant pool entry, but access in different mode.  */
if|if
condition|(
name|RTX_INTEGRATED_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|rtx
name|new
init|=
name|force_const_mem
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|copy_for_inline
argument_list|(
name|XEXP
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|PUT_MODE
argument_list|(
name|new
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|validize_mem
argument_list|(
name|new
argument_list|)
return|;
block|}
break|break;
case|case
name|ADDRESS
case|:
comment|/* If not special for constant pool error.  Else get constant pool 	 address.  */
if|if
condition|(
operator|!
name|RTX_INTEGRATED_P
argument_list|(
name|x
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|XEXP
argument_list|(
name|force_const_mem
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|copy_for_inline
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|ASM_OPERANDS
case|:
comment|/* If a single asm insn contains multiple output operands 	 then it contains multiple ASM_OPERANDS rtx's that share operand 3. 	 We must make sure that the copied insn continues to share it.  */
if|if
condition|(
name|orig_asm_operands_vector
operator|==
name|XVEC
argument_list|(
name|orig
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|x
operator|=
name|rtx_alloc
argument_list|(
name|ASM_OPERANDS
argument_list|)
expr_stmt|;
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|XSTR
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XSTR
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|=
name|XSTR
argument_list|(
name|orig
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XINT
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
operator|=
name|XINT
argument_list|(
name|orig
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|XVEC
argument_list|(
name|x
argument_list|,
literal|3
argument_list|)
operator|=
name|copy_asm_operands_vector
expr_stmt|;
name|XVEC
argument_list|(
name|x
argument_list|,
literal|4
argument_list|)
operator|=
name|copy_asm_constraints_vector
expr_stmt|;
name|XSTR
argument_list|(
name|x
argument_list|,
literal|5
argument_list|)
operator|=
name|XSTR
argument_list|(
name|orig
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|XINT
argument_list|(
name|x
argument_list|,
literal|6
argument_list|)
operator|=
name|XINT
argument_list|(
name|orig
argument_list|,
literal|6
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
break|break;
case|case
name|MEM
case|:
comment|/* A MEM is usually allowed to be shared if its address is constant 	 or is a constant plus one of the special registers.  	 We do not allow sharing of addresses that are either a special 	 register or the sum of a constant and a special register because 	 it is possible for unshare_all_rtl to copy the address, into memory 	 that won't be saved.  Although the MEM can safely be shared, and 	 won't be copied there, the address itself cannot be shared, and may 	 need to be copied.   	 There are also two exceptions with constants: The first is if the 	 constant is a LABEL_REF or the sum of the LABEL_REF 	 and an integer.  This case can happen if we have an inline 	 function that supplies a constant operand to the call of another 	 inline function that uses it in a switch statement.  In this case, 	 we will be replacing the LABEL_REF, so we have to replace this MEM 	 as well.  	 The second case is if we have a (const (plus (address ..) ...)). 	 In that case we need to put back the address of the constant pool 	 entry.  */
if|if
condition|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|LABEL_REF
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDRESS
operator|)
operator|)
operator|)
operator|)
condition|)
return|return
name|x
return|;
break|break;
case|case
name|LABEL_REF
case|:
block|{
comment|/* Must point to the new insn.  */
return|return
name|gen_rtx
argument_list|(
name|LABEL_REF
argument_list|,
name|GET_MODE
argument_list|(
name|orig
argument_list|)
argument_list|,
name|label_map
index|[
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
argument_list|)
return|;
block|}
case|case
name|REG
case|:
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|>
name|LAST_VIRTUAL_REGISTER
condition|)
return|return
name|reg_map
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
return|;
else|else
return|return
name|x
return|;
case|case
name|SET
case|:
comment|/* If a parm that gets modified lives in a pseudo-reg, 	 clear its TREE_READONLY to prevent certain optimizations.  */
block|{
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|x
argument_list|)
decl_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
condition|)
name|dest
operator|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|dest
argument_list|)
operator|<
name|max_parm_reg
operator|&&
name|REGNO
argument_list|(
name|dest
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|parmdecl_map
index|[
name|REGNO
argument_list|(
name|dest
argument_list|)
index|]
operator|!=
literal|0
comment|/* The insn to load an arg pseudo from a stack slot 	       does not count as modifying it.  */
operator|&&
name|in_nonparm_insns
condition|)
name|TREE_READONLY
argument_list|(
name|parmdecl_map
index|[
name|REGNO
argument_list|(
name|dest
argument_list|)
index|]
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
break|break;
if|#
directive|if
literal|0
comment|/* This is a good idea, but here is the wrong place for it.  */
comment|/* Arrange that CONST_INTs always appear as the second operand 	 if they appear, and that `frame_pointer_rtx' or `arg_pointer_rtx' 	 always appear as the first.  */
block|case PLUS:       if (GET_CODE (XEXP (x, 0)) == CONST_INT 	  || (XEXP (x, 1) == frame_pointer_rtx 	      || (ARG_POINTER_REGNUM != FRAME_POINTER_REGNUM&& XEXP (x, 1) == arg_pointer_rtx))) 	{ 	  rtx t = XEXP (x, 0); 	  XEXP (x, 0) = XEXP (x, 1); 	  XEXP (x, 1) = t; 	}       break;
endif|#
directive|endif
block|}
comment|/* Replace this rtx with a copy of itself.  */
name|x
operator|=
name|rtx_alloc
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|orig
argument_list|,
name|x
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|x
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|x
operator|->
name|fld
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|x
operator|->
name|fld
index|[
literal|0
index|]
argument_list|)
operator|*
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Now scan the subexpressions recursively.      We can store any replaced subexpressions directly into X      since we know X is not shared!  Any vectors in X      must be copied if X was copied.  */
name|format_ptr
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|format_ptr
operator|++
condition|)
block|{
case|case
literal|'e'
case|:
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|=
name|copy_for_inline
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
comment|/* Change any references to old-insns to point to the 	     corresponding copied insns.  */
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|=
name|insn_map
index|[
name|INSN_UID
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
index|]
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
if|if
condition|(
name|XVEC
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|NULL
operator|&&
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
literal|0
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
name|XVEC
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|=
name|gen_rtvec_v
argument_list|(
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
operator|&
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
operator|=
name|copy_for_inline
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|code
operator|==
name|ASM_OPERANDS
operator|&&
name|orig_asm_operands_vector
operator|==
literal|0
condition|)
block|{
name|orig_asm_operands_vector
operator|=
name|XVEC
argument_list|(
name|orig
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|copy_asm_operands_vector
operator|=
name|XVEC
argument_list|(
name|x
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|copy_asm_constraints_vector
operator|=
name|XVEC
argument_list|(
name|x
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Unfortunately, we need a global copy of const_equiv map for communication    with a function called from note_stores.  Be *very* careful that this    is used properly in the presence of recursion.  */
end_comment

begin_decl_stmt
name|rtx
modifier|*
name|global_const_equiv_map
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_define
define|#
directive|define
name|FIXED_BASE_PLUS_P
parameter_list|(
name|X
parameter_list|)
define|\
value|(GET_CODE (X) == PLUS&& GET_CODE (XEXP (X, 1)) == CONST_INT	\&& GET_CODE (XEXP (X, 0)) == REG				\&& REGNO (XEXP (X, 0))>= FIRST_VIRTUAL_REGISTER		\&& REGNO (XEXP (X, 0))<= LAST_VIRTUAL_REGISTER)
end_define

begin_comment
comment|/* Integrate the procedure defined by FNDECL.  Note that this function    may wind up calling itself.  Since the static variables are not    reentrant, we do not assign them until after the possibility    of recursion is eliminated.     If IGNORE is nonzero, do not produce a value.    Otherwise store the value in TARGET if it is nonzero and that is convenient.     Value is:    (rtx)-1 if we could not substitute the function    0 if we substituted it and it does not produce a value    else an rtx for where the value is stored.  */
end_comment

begin_function
name|rtx
name|expand_inline_function
parameter_list|(
name|fndecl
parameter_list|,
name|parms
parameter_list|,
name|target
parameter_list|,
name|ignore
parameter_list|,
name|type
parameter_list|,
name|structure_value_addr
parameter_list|)
name|tree
name|fndecl
decl_stmt|,
name|parms
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|int
name|ignore
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|rtx
name|structure_value_addr
decl_stmt|;
block|{
name|tree
name|formal
decl_stmt|,
name|actual
decl_stmt|,
name|block
decl_stmt|;
name|rtx
name|header
init|=
name|DECL_SAVED_INSNS
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|rtx
name|insns
init|=
name|FIRST_FUNCTION_INSN
argument_list|(
name|header
argument_list|)
decl_stmt|;
name|rtx
name|parm_insns
init|=
name|FIRST_PARM_INSN
argument_list|(
name|header
argument_list|)
decl_stmt|;
name|tree
modifier|*
name|arg_trees
decl_stmt|;
name|rtx
modifier|*
name|arg_vals
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|max_regno
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|min_labelno
init|=
name|FIRST_LABELNO
argument_list|(
name|header
argument_list|)
decl_stmt|;
name|int
name|max_labelno
init|=
name|LAST_LABELNO
argument_list|(
name|header
argument_list|)
decl_stmt|;
name|int
name|nargs
decl_stmt|;
name|rtx
name|local_return_label
init|=
literal|0
decl_stmt|;
name|rtx
name|loc
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
name|struct
name|inline_remap
modifier|*
name|map
decl_stmt|;
name|rtx
name|cc0_insn
init|=
literal|0
decl_stmt|;
name|rtvec
name|arg_vector
init|=
name|ORIGINAL_ARG_VECTOR
argument_list|(
name|header
argument_list|)
decl_stmt|;
comment|/* Allow for equivalences of the pseudos we make for virtual fp and ap.  */
name|max_regno
operator|=
name|MAX_REGNUM
argument_list|(
name|header
argument_list|)
operator|+
literal|3
expr_stmt|;
if|if
condition|(
name|max_regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|abort
argument_list|()
expr_stmt|;
name|nargs
operator|=
name|list_length
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We expect PARMS to have the right length; don't crash if not.  */
if|if
condition|(
name|list_length
argument_list|(
name|parms
argument_list|)
operator|!=
name|nargs
condition|)
return|return
call|(
name|rtx
call|)
argument_list|(
name|HOST_WIDE_INT
argument_list|)
operator|-
literal|1
return|;
comment|/* Also check that the parms type match.  Since the appropriate      conversions or default promotions have already been applied,      the machine modes should match exactly.  */
for|for
control|(
name|formal
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
operator|,
name|actual
operator|=
name|parms
init|;
name|formal
condition|;
name|formal
operator|=
name|TREE_CHAIN
argument_list|(
name|formal
argument_list|)
operator|,
name|actual
operator|=
name|TREE_CHAIN
argument_list|(
name|actual
argument_list|)
control|)
block|{
name|tree
name|arg
init|=
name|TREE_VALUE
argument_list|(
name|actual
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|TYPE_MODE
argument_list|(
name|DECL_ARG_TYPE
argument_list|(
name|formal
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|!=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
condition|)
return|return
call|(
name|rtx
call|)
argument_list|(
name|HOST_WIDE_INT
argument_list|)
operator|-
literal|1
return|;
comment|/* If they are block mode, the types should match exactly.          They don't match exactly if TREE_TYPE (FORMAL) == ERROR_MARK_NODE, 	 which could happen if the parameter has incomplete type.  */
if|if
condition|(
name|mode
operator|==
name|BLKmode
operator|&&
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
operator|!=
name|TREE_TYPE
argument_list|(
name|formal
argument_list|)
condition|)
return|return
call|(
name|rtx
call|)
argument_list|(
name|HOST_WIDE_INT
argument_list|)
operator|-
literal|1
return|;
block|}
comment|/* Make a binding contour to keep inline cleanups called at      outer function-scope level from looking like they are shadowing      parameter declarations.  */
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Make a fresh binding contour that we can easily remove.  */
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|expand_start_bindings
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|parm_insns
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|parm_insns
argument_list|)
operator|>
literal|0
condition|)
block|{
name|rtx
name|note
init|=
name|emit_note
argument_list|(
name|NOTE_SOURCE_FILE
argument_list|(
name|parm_insns
argument_list|)
argument_list|,
name|NOTE_LINE_NUMBER
argument_list|(
name|parm_insns
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|note
condition|)
name|RTX_INTEGRATED_P
argument_list|(
name|note
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Expand the function arguments.  Do this first so that any      new registers get created before we allocate the maps.  */
name|arg_vals
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|nargs
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|arg_trees
operator|=
operator|(
name|tree
operator|*
operator|)
name|alloca
argument_list|(
name|nargs
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|formal
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
operator|,
name|actual
operator|=
name|parms
operator|,
name|i
operator|=
literal|0
init|;
name|formal
condition|;
name|formal
operator|=
name|TREE_CHAIN
argument_list|(
name|formal
argument_list|)
operator|,
name|actual
operator|=
name|TREE_CHAIN
argument_list|(
name|actual
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
comment|/* Actual parameter, converted to the type of the argument within the 	 function.  */
name|tree
name|arg
init|=
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|formal
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|actual
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Mode of the variable used within the function.  */
name|enum
name|machine_mode
name|mode
init|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|formal
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Where parameter is located in the function.  */
name|rtx
name|copy
decl_stmt|;
comment|/* Make sure this formal has some correspondence in the users code        * before emitting any line notes for it.  */
if|if
condition|(
name|DECL_SOURCE_LINE
argument_list|(
name|formal
argument_list|)
condition|)
block|{
name|rtx
name|note
init|=
name|emit_note
argument_list|(
name|DECL_SOURCE_FILE
argument_list|(
name|formal
argument_list|)
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|formal
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|note
condition|)
name|RTX_INTEGRATED_P
argument_list|(
name|note
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|arg_trees
index|[
name|i
index|]
operator|=
name|arg
expr_stmt|;
name|loc
operator|=
name|RTVEC_ELT
argument_list|(
name|arg_vector
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* If this is an object passed by invisible reference, we copy the 	 object into a stack slot and save its address.  If this will go 	 into memory, we do nothing now.  Otherwise, we just expand the 	 argument.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|loc
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>
name|LAST_VIRTUAL_REGISTER
condition|)
block|{
name|rtx
name|stack_slot
init|=
name|assign_stack_temp
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|,
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|store_expr
argument_list|(
name|arg
argument_list|,
name|stack_slot
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arg_vals
index|[
name|i
index|]
operator|=
name|XEXP
argument_list|(
name|stack_slot
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|loc
argument_list|)
operator|!=
name|MEM
condition|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|loc
argument_list|)
operator|!=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
condition|)
comment|/* The mode if LOC and ARG can differ if LOC was a variable 	       that had its mode promoted via PROMOTED_MODE.  */
name|arg_vals
index|[
name|i
index|]
operator|=
name|convert_to_mode
argument_list|(
name|GET_MODE
argument_list|(
name|loc
argument_list|)
argument_list|,
name|expand_expr
argument_list|(
name|arg
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|EXPAND_SUM
argument_list|)
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|formal
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|arg_vals
index|[
name|i
index|]
operator|=
name|expand_expr
argument_list|(
name|arg
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
name|EXPAND_SUM
argument_list|)
expr_stmt|;
block|}
else|else
name|arg_vals
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|arg_vals
index|[
name|i
index|]
operator|!=
literal|0
operator|&&
operator|(
operator|!
name|TREE_READONLY
argument_list|(
name|formal
argument_list|)
comment|/* If the parameter is not read-only, copy our argument through 		 a register.  Also, we cannot use ARG_VALS[I] if it overlaps 		 TARGET in any way.  In the inline function, they will likely 		 be two different pseudos, and `safe_from_p' will make all 		 sorts of smart assumptions about their not conflicting. 		 But if ARG_VALS[I] overlaps TARGET, these assumptions are 		 wrong, so put ARG_VALS[I] into a fresh register.  */
operator|||
operator|(
name|target
operator|!=
literal|0
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|arg_vals
index|[
name|i
index|]
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|arg_vals
index|[
name|i
index|]
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|arg_vals
index|[
name|i
index|]
argument_list|)
operator|==
name|MEM
operator|)
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|arg_vals
index|[
name|i
index|]
argument_list|,
name|target
argument_list|)
operator|)
comment|/* ??? We must always copy a SUBREG into a REG, because it might 		 get substituted into an address, and not all ports correctly 		 handle SUBREGs in addresses.  */
operator|||
operator|(
name|GET_CODE
argument_list|(
name|arg_vals
index|[
name|i
index|]
argument_list|)
operator|==
name|SUBREG
operator|)
operator|)
condition|)
name|arg_vals
index|[
name|i
index|]
operator|=
name|copy_to_mode_reg
argument_list|(
name|GET_MODE
argument_list|(
name|loc
argument_list|)
argument_list|,
name|arg_vals
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Allocate the structures we use to remap things.  */
name|map
operator|=
operator|(
expr|struct
name|inline_remap
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|inline_remap
argument_list|)
argument_list|)
expr_stmt|;
name|map
operator|->
name|fndecl
operator|=
name|fndecl
expr_stmt|;
name|map
operator|->
name|reg_map
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|map
operator|->
name|reg_map
argument_list|,
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|map
operator|->
name|label_map
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|max_labelno
operator|-
name|min_labelno
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|map
operator|->
name|label_map
operator|-=
name|min_labelno
expr_stmt|;
name|map
operator|->
name|insn_map
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|INSN_UID
argument_list|(
name|header
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|map
operator|->
name|insn_map
argument_list|,
name|INSN_UID
argument_list|(
name|header
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|map
operator|->
name|min_insnno
operator|=
literal|0
expr_stmt|;
name|map
operator|->
name|max_insnno
operator|=
name|INSN_UID
argument_list|(
name|header
argument_list|)
expr_stmt|;
name|map
operator|->
name|integrating
operator|=
literal|1
expr_stmt|;
comment|/* const_equiv_map maps pseudos in our routine to constants, so it needs to      be large enough for all our pseudos.  This is the number we are currently      using plus the number in the called routine, plus 15 for each arg,      five to compute the virtual frame pointer, and five for the return value.      This should be enough for most cases.  We do not reference entries      outside the range of the map.       ??? These numbers are quite arbitrary and were obtained by      experimentation.  At some point, we should try to allocate the      table after all the parameters are set up so we an more accurately      estimate the number of pseudos we will need.  */
name|map
operator|->
name|const_equiv_map_size
operator|=
name|max_reg_num
argument_list|()
operator|+
operator|(
name|max_regno
operator|-
name|FIRST_PSEUDO_REGISTER
operator|)
operator|+
literal|15
operator|*
name|nargs
operator|+
literal|10
expr_stmt|;
name|map
operator|->
name|const_equiv_map
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|map
operator|->
name|const_equiv_map_size
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|map
operator|->
name|const_equiv_map
argument_list|,
name|map
operator|->
name|const_equiv_map_size
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|map
operator|->
name|const_age_map
operator|=
operator|(
name|unsigned
operator|*
operator|)
name|alloca
argument_list|(
name|map
operator|->
name|const_equiv_map_size
operator|*
sizeof|sizeof
argument_list|(
name|unsigned
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|map
operator|->
name|const_age_map
argument_list|,
name|map
operator|->
name|const_equiv_map_size
operator|*
sizeof|sizeof
argument_list|(
name|unsigned
argument_list|)
argument_list|)
expr_stmt|;
name|map
operator|->
name|const_age
operator|=
literal|0
expr_stmt|;
comment|/* Record the current insn in case we have to set up pointers to frame      and argument memory blocks.  */
name|map
operator|->
name|insns_at_start
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
comment|/* Update the outgoing argument size to allow for those in the inlined      function.  */
if|if
condition|(
name|OUTGOING_ARGS_SIZE
argument_list|(
name|header
argument_list|)
operator|>
name|current_function_outgoing_args_size
condition|)
name|current_function_outgoing_args_size
operator|=
name|OUTGOING_ARGS_SIZE
argument_list|(
name|header
argument_list|)
expr_stmt|;
comment|/* If the inline function needs to make PIC references, that means      that this function's PIC offset table must be used.  */
if|if
condition|(
name|FUNCTION_FLAGS
argument_list|(
name|header
argument_list|)
operator|&
name|FUNCTION_FLAGS_USES_PIC_OFFSET_TABLE
condition|)
name|current_function_uses_pic_offset_table
operator|=
literal|1
expr_stmt|;
comment|/* Process each argument.  For each, set up things so that the function's      reference to the argument will refer to the argument being passed.      We only replace REG with REG here.  Any simplifications are done      via const_equiv_map.       We make two passes:  In the first, we deal with parameters that will      be placed into registers, since we need to ensure that the allocated      register number fits in const_equiv_map.  Then we store all non-register      parameters into their memory location.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nargs
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|copy
init|=
name|arg_vals
index|[
name|i
index|]
decl_stmt|;
name|loc
operator|=
name|RTVEC_ELT
argument_list|(
name|arg_vector
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* There are three cases, each handled separately.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|loc
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>
name|LAST_VIRTUAL_REGISTER
condition|)
block|{
comment|/* This must be an object passed by invisible reference (it could 	     also be a variable-sized object, but we forbid inlining functions 	     with variable-sized arguments).  COPY is the address of the 	     actual value (this computation will cause it to be copied).  We 	     map that address for the register, noting the actual address as 	     an equivalent in case it can be substituted into the insns.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|copy
argument_list|)
operator|!=
name|REG
condition|)
block|{
name|temp
operator|=
name|copy_addr_to_reg
argument_list|(
name|copy
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|copy
argument_list|)
operator|||
name|FIXED_BASE_PLUS_P
argument_list|(
name|copy
argument_list|)
condition|)
block|{
name|map
operator|->
name|const_equiv_map
index|[
name|REGNO
argument_list|(
name|temp
argument_list|)
index|]
operator|=
name|copy
expr_stmt|;
name|map
operator|->
name|const_age_map
index|[
name|REGNO
argument_list|(
name|temp
argument_list|)
index|]
operator|=
name|CONST_AGE_PARM
expr_stmt|;
block|}
name|copy
operator|=
name|temp
expr_stmt|;
block|}
name|map
operator|->
name|reg_map
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
operator|=
name|copy
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|loc
argument_list|)
operator|==
name|MEM
condition|)
block|{
comment|/* This is the case of a parameter that lives in memory. 	     It will live in the block we allocate in the called routine's 	     frame that simulates the incoming argument area.  Do nothing 	     now; we will call store_expr later.  */
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|loc
argument_list|)
operator|==
name|REG
condition|)
block|{
comment|/* This is the good case where the parameter is in a register. 	     If it is read-only and our argument is a constant, set up the 	     constant equivalence.  	     If LOC is REG_USERVAR_P, the usual case, COPY must also have 	     that flag set if it is a register.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|copy
argument_list|)
operator|!=
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|copy
argument_list|)
operator|!=
name|SUBREG
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|copy
argument_list|)
operator|==
name|REG
operator|&&
name|REG_USERVAR_P
argument_list|(
name|loc
argument_list|)
operator|&&
operator|!
name|REG_USERVAR_P
argument_list|(
name|copy
argument_list|)
operator|)
condition|)
block|{
name|temp
operator|=
name|copy_to_mode_reg
argument_list|(
name|GET_MODE
argument_list|(
name|loc
argument_list|)
argument_list|,
name|copy
argument_list|)
expr_stmt|;
name|REG_USERVAR_P
argument_list|(
name|temp
argument_list|)
operator|=
name|REG_USERVAR_P
argument_list|(
name|loc
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|copy
argument_list|)
operator|||
name|FIXED_BASE_PLUS_P
argument_list|(
name|copy
argument_list|)
condition|)
block|{
name|map
operator|->
name|const_equiv_map
index|[
name|REGNO
argument_list|(
name|temp
argument_list|)
index|]
operator|=
name|copy
expr_stmt|;
name|map
operator|->
name|const_age_map
index|[
name|REGNO
argument_list|(
name|temp
argument_list|)
index|]
operator|=
name|CONST_AGE_PARM
expr_stmt|;
block|}
name|copy
operator|=
name|temp
expr_stmt|;
block|}
name|map
operator|->
name|reg_map
index|[
name|REGNO
argument_list|(
name|loc
argument_list|)
index|]
operator|=
name|copy
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* Free any temporaries we made setting up this parameter.  */
name|free_temp_slots
argument_list|()
expr_stmt|;
block|}
comment|/* Now do the parameters that will be placed in memory.  */
for|for
control|(
name|formal
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
operator|,
name|i
operator|=
literal|0
init|;
name|formal
condition|;
name|formal
operator|=
name|TREE_CHAIN
argument_list|(
name|formal
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
name|rtx
name|copy
init|=
name|arg_vals
index|[
name|i
index|]
decl_stmt|;
name|loc
operator|=
name|RTVEC_ELT
argument_list|(
name|arg_vector
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|loc
argument_list|)
operator|==
name|MEM
comment|/* Exclude case handled above.  */
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>
name|LAST_VIRTUAL_REGISTER
operator|)
condition|)
block|{
name|rtx
name|note
init|=
name|emit_note
argument_list|(
name|DECL_SOURCE_FILE
argument_list|(
name|formal
argument_list|)
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|formal
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|note
condition|)
name|RTX_INTEGRATED_P
argument_list|(
name|note
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Compute the address in the area we reserved and store the 	     value there.  */
name|temp
operator|=
name|copy_rtx_and_substitute
argument_list|(
name|loc
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|subst_constants
argument_list|(
operator|&
name|temp
argument_list|,
name|NULL_RTX
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|apply_change_group
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|memory_address_p
argument_list|(
name|GET_MODE
argument_list|(
name|temp
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|temp
operator|=
name|change_address
argument_list|(
name|temp
argument_list|,
name|VOIDmode
argument_list|,
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|store_expr
argument_list|(
name|arg_trees
index|[
name|i
index|]
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Free any temporaries we made setting up this parameter.  */
name|free_temp_slots
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Deal with the places that the function puts its result.      We are driven by what is placed into DECL_RESULT.       Initially, we assume that we don't have anything special handling for      REG_FUNCTION_RETURN_VALUE_P.  */
name|map
operator|->
name|inline_target
operator|=
literal|0
expr_stmt|;
name|loc
operator|=
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|VOIDmode
condition|)
comment|/* There is no return value to worry about.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|loc
argument_list|)
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
operator|!
name|structure_value_addr
operator|||
operator|!
name|aggregate_value_p
argument_list|(
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Pass the function the address in which to return a structure value. 	 Note that a constructor can cause someone to call us with 	 STRUCTURE_VALUE_ADDR, but the initialization takes place 	 via the first parameter, rather than the struct return address.  	 We have two cases:  If the address is a simple register indirect, 	 use the mapping mechanism to point that register to our structure 	 return address.  Otherwise, store the structure return value into 	 the place that it will be referenced from.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|temp
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|structure_value_addr
argument_list|)
expr_stmt|;
name|map
operator|->
name|reg_map
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
operator|=
name|temp
expr_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|structure_value_addr
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|structure_value_addr
argument_list|)
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|structure_value_addr
argument_list|,
literal|0
argument_list|)
operator|==
name|virtual_stack_vars_rtx
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|structure_value_addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|)
condition|)
block|{
name|map
operator|->
name|const_equiv_map
index|[
name|REGNO
argument_list|(
name|temp
argument_list|)
index|]
operator|=
name|structure_value_addr
expr_stmt|;
name|map
operator|->
name|const_age_map
index|[
name|REGNO
argument_list|(
name|temp
argument_list|)
index|]
operator|=
name|CONST_AGE_PARM
expr_stmt|;
block|}
block|}
else|else
block|{
name|temp
operator|=
name|copy_rtx_and_substitute
argument_list|(
name|loc
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|subst_constants
argument_list|(
operator|&
name|temp
argument_list|,
name|NULL_RTX
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|apply_change_group
argument_list|()
expr_stmt|;
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|structure_value_addr
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ignore
condition|)
comment|/* We will ignore the result value, so don't look at its structure.        Note that preparations for an aggregate return value        do need to be made (above) even if it will be ignored.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|loc
argument_list|)
operator|==
name|REG
condition|)
block|{
comment|/* The function returns an object in a register and we use the return 	 value.  Set up our target for remapping.  */
comment|/* Machine mode function was declared to return.   */
name|enum
name|machine_mode
name|departing_mode
init|=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/* (Possibly wider) machine mode it actually computes 	 (for the sake of callers that fail to declare it right).  */
name|enum
name|machine_mode
name|arriving_mode
init|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|reg_to_map
decl_stmt|;
comment|/* Don't use MEMs as direct targets because on some machines 	 substituting a MEM for a REG makes invalid insns. 	 Let the combiner substitute the MEM if that is valid.  */
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|!=
name|REG
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|departing_mode
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|departing_mode
argument_list|)
expr_stmt|;
comment|/* If function's value was promoted before return, 	 avoid machine mode mismatch when we substitute INLINE_TARGET. 	 But TARGET is what we will return to the caller.  */
if|if
condition|(
name|arriving_mode
operator|!=
name|departing_mode
condition|)
name|reg_to_map
operator|=
name|gen_rtx
argument_list|(
name|SUBREG
argument_list|,
name|arriving_mode
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|reg_to_map
operator|=
name|target
expr_stmt|;
comment|/* Usually, the result value is the machine's return register. 	 Sometimes it may be a pseudo. Handle both cases.  */
if|if
condition|(
name|REG_FUNCTION_VALUE_P
argument_list|(
name|loc
argument_list|)
condition|)
name|map
operator|->
name|inline_target
operator|=
name|reg_to_map
expr_stmt|;
else|else
name|map
operator|->
name|reg_map
index|[
name|REGNO
argument_list|(
name|loc
argument_list|)
index|]
operator|=
name|reg_to_map
expr_stmt|;
block|}
comment|/* Make new label equivalences for the labels in the called function.  */
for|for
control|(
name|i
operator|=
name|min_labelno
init|;
name|i
operator|<
name|max_labelno
condition|;
name|i
operator|++
control|)
name|map
operator|->
name|label_map
index|[
name|i
index|]
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
comment|/* Perform postincrements before actually calling the function.  */
name|emit_queue
argument_list|()
expr_stmt|;
comment|/* Clean up stack so that variables might have smaller offsets.  */
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
comment|/* Save a copy of the location of const_equiv_map for mark_stores, called      via note_stores.  */
name|global_const_equiv_map
operator|=
name|map
operator|->
name|const_equiv_map
expr_stmt|;
comment|/* Now copy the insns one by one.  Do this in two passes, first the insns and      then their REG_NOTES, just like save_for_inline.  */
comment|/* This loop is very similar to the loop in copy_loop_body in unroll.c.  */
for|for
control|(
name|insn
operator|=
name|insns
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|rtx
name|copy
decl_stmt|,
name|pattern
decl_stmt|;
name|map
operator|->
name|orig_asm_operands_vector
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|INSN
case|:
name|pattern
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|copy
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
operator|==
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REG_FUNCTION_VALUE_P
argument_list|(
name|XEXP
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
comment|/* The (USE (REG n)) at return from the function should 	       be ignored since we are changing (REG n) into 	       inline_target.  */
break|break;
comment|/* Ignore setting a function value that we don't want to use.  */
if|if
condition|(
name|map
operator|->
name|inline_target
operator|==
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|pattern
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REG_FUNCTION_VALUE_P
argument_list|(
name|SET_DEST
argument_list|(
name|pattern
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|volatile_refs_p
argument_list|(
name|SET_SRC
argument_list|(
name|pattern
argument_list|)
argument_list|)
condition|)
block|{
comment|/* If we must not delete the source, 		     load it into a new temporary.  */
name|copy
operator|=
name|emit_insn
argument_list|(
name|copy_rtx_and_substitute
argument_list|(
name|pattern
argument_list|,
name|map
argument_list|)
argument_list|)
expr_stmt|;
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|copy
argument_list|)
argument_list|)
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|copy
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
block|}
else|else
name|copy
operator|=
name|emit_insn
argument_list|(
name|copy_rtx_and_substitute
argument_list|(
name|pattern
argument_list|,
name|map
argument_list|)
argument_list|)
expr_stmt|;
comment|/* REG_NOTES will be copied later.  */
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* If this insn is setting CC0, it may need to look at 	     the insn that uses CC0 to see what type of insn it is. 	     In that case, the call to recog via validate_change will 	     fail.  So don't substitute constants here.  Instead, 	     do it when we emit the following insn.  	     For example, see the pyr.md file.  That machine has signed and 	     unsigned compares.  The compare patterns must check the 	     following branch insn to see which what kind of compare to 	     emit.  	     If the previous insn set CC0, substitute constants on it as 	     well.  */
if|if
condition|(
name|sets_cc0_p
argument_list|(
name|PATTERN
argument_list|(
name|copy
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|cc0_insn
operator|=
name|copy
expr_stmt|;
else|else
block|{
if|if
condition|(
name|cc0_insn
condition|)
name|try_constants
argument_list|(
name|cc0_insn
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|cc0_insn
operator|=
literal|0
expr_stmt|;
name|try_constants
argument_list|(
name|copy
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|try_constants
argument_list|(
name|copy
argument_list|,
name|map
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|JUMP_INSN
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|RETURN
condition|)
block|{
if|if
condition|(
name|local_return_label
operator|==
literal|0
condition|)
name|local_return_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|pattern
operator|=
name|gen_jump
argument_list|(
name|local_return_label
argument_list|)
expr_stmt|;
block|}
else|else
name|pattern
operator|=
name|copy_rtx_and_substitute
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|copy
operator|=
name|emit_jump_insn
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
if|if
condition|(
name|cc0_insn
condition|)
name|try_constants
argument_list|(
name|cc0_insn
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|cc0_insn
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|try_constants
argument_list|(
name|copy
argument_list|,
name|map
argument_list|)
expr_stmt|;
comment|/* If this used to be a conditional jump insn but whose branch 	     direction is now know, we must do something special.  */
if|if
condition|(
name|condjump_p
argument_list|(
name|insn
argument_list|)
operator|&&
operator|!
name|simplejump_p
argument_list|(
name|insn
argument_list|)
operator|&&
name|map
operator|->
name|last_pc_value
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* The previous insn set cc0 for us.  So delete it.  */
name|delete_insn
argument_list|(
name|PREV_INSN
argument_list|(
name|copy
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If this is now a no-op, delete it.  */
if|if
condition|(
name|map
operator|->
name|last_pc_value
operator|==
name|pc_rtx
condition|)
block|{
name|delete_insn
argument_list|(
name|copy
argument_list|)
expr_stmt|;
name|copy
operator|=
literal|0
expr_stmt|;
block|}
else|else
comment|/* Otherwise, this is unconditional jump so we must put a 		   BARRIER after it.  We could do some dead code elimination 		   here, but jump.c will do it just as well.  */
name|emit_barrier
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|CALL_INSN
case|:
name|pattern
operator|=
name|copy_rtx_and_substitute
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|copy
operator|=
name|emit_call_insn
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
if|if
condition|(
name|cc0_insn
condition|)
name|try_constants
argument_list|(
name|cc0_insn
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|cc0_insn
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|try_constants
argument_list|(
name|copy
argument_list|,
name|map
argument_list|)
expr_stmt|;
comment|/* Be lazy and assume CALL_INSNs clobber all hard registers.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
name|map
operator|->
name|const_equiv_map
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|CODE_LABEL
case|:
name|copy
operator|=
name|emit_label
argument_list|(
name|map
operator|->
name|label_map
index|[
name|CODE_LABEL_NUMBER
argument_list|(
name|insn
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|LABEL_NAME
argument_list|(
name|copy
argument_list|)
operator|=
name|LABEL_NAME
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|map
operator|->
name|const_age
operator|++
expr_stmt|;
break|break;
case|case
name|BARRIER
case|:
name|copy
operator|=
name|emit_barrier
argument_list|()
expr_stmt|;
break|break;
case|case
name|NOTE
case|:
comment|/* It is important to discard function-end and function-beg notes, 	     so we have only one of each in the current function. 	     Also, NOTE_INSN_DELETED notes aren't useful (save_for_inline 	     deleted these in the copy used for continuing compilation, 	     not the copy used for inlining).  */
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE_INSN_FUNCTION_END
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE_INSN_FUNCTION_BEG
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE_INSN_DELETED
condition|)
name|copy
operator|=
name|emit_note
argument_list|(
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
argument_list|,
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|copy
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|copy
condition|)
name|RTX_INTEGRATED_P
argument_list|(
name|copy
argument_list|)
operator|=
literal|1
expr_stmt|;
name|map
operator|->
name|insn_map
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
operator|=
name|copy
expr_stmt|;
block|}
comment|/* Now copy the REG_NOTES.  Increment const_age, so that only constants      from parameters can be substituted in.  These are the only ones that      are valid across the entire function.  */
name|map
operator|->
name|const_age
operator|++
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|insns
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
operator|&&
name|map
operator|->
name|insn_map
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
operator|&&
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|rtx
name|tem
init|=
name|copy_rtx_and_substitute
argument_list|(
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|,
name|map
argument_list|)
decl_stmt|;
comment|/* We must also do subst_constants, in case one of our parameters 	   has const type and constant value.  */
name|subst_constants
argument_list|(
operator|&
name|tem
argument_list|,
name|NULL_RTX
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|apply_change_group
argument_list|()
expr_stmt|;
name|REG_NOTES
argument_list|(
name|map
operator|->
name|insn_map
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
argument_list|)
operator|=
name|tem
expr_stmt|;
block|}
if|if
condition|(
name|local_return_label
condition|)
name|emit_label
argument_list|(
name|local_return_label
argument_list|)
expr_stmt|;
comment|/* Make copies of the decls of the symbols in the inline function, so that      the copies of the variables get declared in the current function.  Set      up things so that lookup_static_chain knows that to interpret registers      in SAVE_EXPRs for TYPE_SIZEs as local.  */
name|inline_function_decl
operator|=
name|fndecl
expr_stmt|;
name|integrate_parm_decls
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
argument_list|,
name|map
argument_list|,
name|arg_vector
argument_list|)
expr_stmt|;
name|integrate_decl_tree
argument_list|(
operator|(
name|tree
operator|)
name|ORIGINAL_DECL_INITIAL
argument_list|(
name|header
argument_list|)
argument_list|,
literal|0
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|inline_function_decl
operator|=
literal|0
expr_stmt|;
comment|/* End the scope containing the copied formal parameter variables      and copied LABEL_DECLs.  */
name|expand_end_bindings
argument_list|(
name|getdecls
argument_list|()
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|block
operator|=
name|poplevel
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|BLOCK_ABSTRACT_ORIGIN
argument_list|(
name|block
argument_list|)
operator|=
operator|(
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|fndecl
argument_list|)
operator|==
name|NULL
condition|?
name|fndecl
else|:
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|fndecl
argument_list|)
operator|)
expr_stmt|;
name|poplevel
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_line_note
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
if|if
condition|(
name|structure_value_addr
condition|)
block|{
name|target
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|memory_address
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|structure_value_addr
argument_list|)
argument_list|)
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|target
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|target
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a chain of PARM_DECLs, ARGS, copy each decl into a VAR_DECL,    push all of those decls and give each one the corresponding home.  */
end_comment

begin_function
specifier|static
name|void
name|integrate_parm_decls
parameter_list|(
name|args
parameter_list|,
name|map
parameter_list|,
name|arg_vector
parameter_list|)
name|tree
name|args
decl_stmt|;
name|struct
name|inline_remap
modifier|*
name|map
decl_stmt|;
name|rtvec
name|arg_vector
decl_stmt|;
block|{
specifier|register
name|tree
name|tail
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|tail
operator|=
name|args
operator|,
name|i
operator|=
literal|0
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
specifier|register
name|tree
name|decl
init|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|DECL_NAME
argument_list|(
name|tail
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|tail
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|new_decl_rtl
init|=
name|copy_rtx_and_substitute
argument_list|(
name|RTVEC_ELT
argument_list|(
name|arg_vector
argument_list|,
name|i
argument_list|)
argument_list|,
name|map
argument_list|)
decl_stmt|;
name|DECL_ARG_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|DECL_ARG_TYPE
argument_list|(
name|tail
argument_list|)
expr_stmt|;
comment|/* We really should be setting DECL_INCOMING_RTL to something reasonable 	 here, but that's going to require some more work.  */
comment|/* DECL_INCOMING_RTL (decl) = ?; */
comment|/* These args would always appear unused, if not for this.  */
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Prevent warning for shadowing with these.  */
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|decl
argument_list|)
operator|=
name|tail
expr_stmt|;
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Fully instantiate the address with the equivalent form so that the 	 debugging information contains the actual register, instead of the 	 virtual register.   Do this by not passing an insn to 	 subst_constants.  */
name|subst_constants
argument_list|(
operator|&
name|new_decl_rtl
argument_list|,
name|NULL_RTX
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|apply_change_group
argument_list|()
expr_stmt|;
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|=
name|new_decl_rtl
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Given a BLOCK node LET, push decls and levels so as to construct in the    current function a tree of contexts isomorphic to the one that is given.     LEVEL indicates how far down into the BLOCK tree is the node we are    currently traversing.  It is always zero except for recursive calls.     MAP, if nonzero, is a pointer to an inline_remap map which indicates how    registers used in the DECL_RTL field should be remapped.  If it is zero,    no mapping is necessary.  */
end_comment

begin_function
specifier|static
name|void
name|integrate_decl_tree
parameter_list|(
name|let
parameter_list|,
name|level
parameter_list|,
name|map
parameter_list|)
name|tree
name|let
decl_stmt|;
name|int
name|level
decl_stmt|;
name|struct
name|inline_remap
modifier|*
name|map
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|,
name|node
decl_stmt|;
if|if
condition|(
name|level
operator|>
literal|0
condition|)
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|BLOCK_VARS
argument_list|(
name|let
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|tree
name|d
init|=
name|build_decl
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|,
name|DECL_NAME
argument_list|(
name|t
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
decl_stmt|;
name|DECL_SOURCE_LINE
argument_list|(
name|d
argument_list|)
operator|=
name|DECL_SOURCE_LINE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|DECL_SOURCE_FILE
argument_list|(
name|d
argument_list|)
operator|=
name|DECL_SOURCE_FILE
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_RTL
argument_list|(
name|t
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|DECL_RTL
argument_list|(
name|d
argument_list|)
operator|=
name|copy_rtx_and_substitute
argument_list|(
name|DECL_RTL
argument_list|(
name|t
argument_list|)
argument_list|,
name|map
argument_list|)
expr_stmt|;
comment|/* Fully instantiate the address with the equivalent form so that the 	     debugging information contains the actual register, instead of the 	     virtual register.   Do this by not passing an insn to 	     subst_constants.  */
name|subst_constants
argument_list|(
operator|&
name|DECL_RTL
argument_list|(
name|d
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|apply_change_group
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_RTL
argument_list|(
name|t
argument_list|)
condition|)
name|DECL_RTL
argument_list|(
name|d
argument_list|)
operator|=
name|copy_rtx
argument_list|(
name|DECL_RTL
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|d
argument_list|)
operator|=
name|DECL_EXTERNAL
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|d
argument_list|)
operator|=
name|TREE_STATIC
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|d
argument_list|)
operator|=
name|TREE_PUBLIC
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|d
argument_list|)
operator|=
name|TREE_CONSTANT
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
name|d
argument_list|)
operator|=
name|TREE_ADDRESSABLE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|d
argument_list|)
operator|=
name|TREE_READONLY
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|d
argument_list|)
operator|=
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* These args would always appear unused, if not for this.  */
name|TREE_USED
argument_list|(
name|d
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Prevent warning for shadowing with these.  */
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|d
argument_list|)
operator|=
name|t
expr_stmt|;
name|pushdecl
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|t
operator|=
name|BLOCK_SUBBLOCKS
argument_list|(
name|let
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
name|integrate_decl_tree
argument_list|(
name|t
argument_list|,
name|level
operator|+
literal|1
argument_list|,
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|>
literal|0
condition|)
block|{
name|node
operator|=
name|poplevel
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
condition|)
block|{
name|TREE_USED
argument_list|(
name|node
argument_list|)
operator|=
name|TREE_USED
argument_list|(
name|let
argument_list|)
expr_stmt|;
name|BLOCK_ABSTRACT_ORIGIN
argument_list|(
name|node
argument_list|)
operator|=
name|let
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create a new copy of an rtx.    Recursively copies the operands of the rtx,    except for those few rtx codes that are sharable.     We always return an rtx that is similar to that incoming rtx, with the    exception of possibly changing a REG to a SUBREG or vice versa.  No    rtl is ever emitted.     Handle constants that need to be placed in the constant pool by    calling `force_const_mem'.  */
end_comment

begin_function
name|rtx
name|copy_rtx_and_substitute
parameter_list|(
name|orig
parameter_list|,
name|map
parameter_list|)
specifier|register
name|rtx
name|orig
decl_stmt|;
name|struct
name|inline_remap
modifier|*
name|map
decl_stmt|;
block|{
specifier|register
name|rtx
name|copy
decl_stmt|,
name|temp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|RTX_CODE
name|code
decl_stmt|;
specifier|register
name|enum
name|machine_mode
name|mode
decl_stmt|;
specifier|register
name|char
modifier|*
name|format_ptr
decl_stmt|;
name|int
name|regno
decl_stmt|;
if|if
condition|(
name|orig
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|orig
argument_list|)
expr_stmt|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|orig
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
comment|/* If the stack pointer register shows up, it must be part of 	 stack-adjustments (*not* because we eliminated the frame pointer!). 	 Small hard registers are returned as-is.  Pseudo-registers 	 go through their `reg_map'.  */
name|regno
operator|=
name|REGNO
argument_list|(
name|orig
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|<=
name|LAST_VIRTUAL_REGISTER
condition|)
block|{
comment|/* Some hard registers are also mapped, 	     but others are not translated.  */
if|if
condition|(
name|map
operator|->
name|reg_map
index|[
name|regno
index|]
operator|!=
literal|0
condition|)
return|return
name|map
operator|->
name|reg_map
index|[
name|regno
index|]
return|;
comment|/* If this is the virtual frame pointer, make space in current 	     function's stack frame for the stack frame of the inline function.  	     Copy the address of this area into a pseudo.  Map 	     virtual_stack_vars_rtx to this pseudo and set up a constant 	     equivalence for it to be the address.  This will substitute the 	     address into insns where it can be substituted and use the new 	     pseudo where it can't.  */
if|if
condition|(
name|regno
operator|==
name|VIRTUAL_STACK_VARS_REGNUM
condition|)
block|{
name|rtx
name|loc
decl_stmt|,
name|seq
decl_stmt|;
name|int
name|size
init|=
name|DECL_FRAME_SIZE
argument_list|(
name|map
operator|->
name|fndecl
argument_list|)
decl_stmt|;
name|int
name|rounded
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|loc
operator|=
name|assign_stack_temp
argument_list|(
name|BLKmode
argument_list|,
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|loc
operator|=
name|XEXP
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FRAME_GROWS_DOWNWARD
comment|/* In this case, virtual_stack_vars_rtx points to one byte 		 higher than the top of the frame area.  So compute the offset 		 to one byte higher than our substitute frame. 		 Keep the fake frame pointer aligned like a real one.  */
name|rounded
operator|=
name|CEIL_ROUND
argument_list|(
name|size
argument_list|,
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|loc
operator|=
name|plus_constant
argument_list|(
name|loc
argument_list|,
name|rounded
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|map
operator|->
name|reg_map
index|[
name|regno
index|]
operator|=
name|temp
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|force_operand
argument_list|(
name|loc
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|)
expr_stmt|;
name|map
operator|->
name|const_equiv_map
index|[
name|REGNO
argument_list|(
name|temp
argument_list|)
index|]
operator|=
name|loc
expr_stmt|;
name|map
operator|->
name|const_age_map
index|[
name|REGNO
argument_list|(
name|temp
argument_list|)
index|]
operator|=
name|CONST_AGE_PARM
expr_stmt|;
name|seq
operator|=
name|gen_sequence
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insn_after
argument_list|(
name|seq
argument_list|,
name|map
operator|->
name|insns_at_start
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
elseif|else
if|if
condition|(
name|regno
operator|==
name|VIRTUAL_INCOMING_ARGS_REGNUM
condition|)
block|{
comment|/* Do the same for a block to contain any arguments referenced 		 in memory. */
name|rtx
name|loc
decl_stmt|,
name|seq
decl_stmt|;
name|int
name|size
init|=
name|FUNCTION_ARGS_SIZE
argument_list|(
name|DECL_SAVED_INSNS
argument_list|(
name|map
operator|->
name|fndecl
argument_list|)
argument_list|)
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|loc
operator|=
name|assign_stack_temp
argument_list|(
name|BLKmode
argument_list|,
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|loc
operator|=
name|XEXP
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* When arguments grow downward, the virtual incoming  		 args pointer points to the top of the argument block, 		 so the remapped location better do the same. */
ifdef|#
directive|ifdef
name|ARGS_GROW_DOWNWARD
name|loc
operator|=
name|plus_constant
argument_list|(
name|loc
argument_list|,
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|map
operator|->
name|reg_map
index|[
name|regno
index|]
operator|=
name|temp
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|force_operand
argument_list|(
name|loc
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|)
expr_stmt|;
name|map
operator|->
name|const_equiv_map
index|[
name|REGNO
argument_list|(
name|temp
argument_list|)
index|]
operator|=
name|loc
expr_stmt|;
name|map
operator|->
name|const_age_map
index|[
name|REGNO
argument_list|(
name|temp
argument_list|)
index|]
operator|=
name|CONST_AGE_PARM
expr_stmt|;
name|seq
operator|=
name|gen_sequence
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insn_after
argument_list|(
name|seq
argument_list|,
name|map
operator|->
name|insns_at_start
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
elseif|else
if|if
condition|(
name|REG_FUNCTION_VALUE_P
argument_list|(
name|orig
argument_list|)
condition|)
block|{
comment|/* This is a reference to the function return value.  If 		 the function doesn't have a return value, error.  If the 		 mode doesn't agree, make a SUBREG.  */
if|if
condition|(
name|map
operator|->
name|inline_target
operator|==
literal|0
condition|)
comment|/* Must be unrolling loops or replicating code if we 		   reach here, so return the register unchanged.  */
return|return
name|orig
return|;
elseif|else
if|if
condition|(
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|map
operator|->
name|inline_target
argument_list|)
condition|)
return|return
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|map
operator|->
name|inline_target
argument_list|)
return|;
else|else
return|return
name|map
operator|->
name|inline_target
return|;
block|}
return|return
name|orig
return|;
block|}
if|if
condition|(
name|map
operator|->
name|reg_map
index|[
name|regno
index|]
operator|==
name|NULL
condition|)
block|{
name|map
operator|->
name|reg_map
index|[
name|regno
index|]
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|REG_USERVAR_P
argument_list|(
name|map
operator|->
name|reg_map
index|[
name|regno
index|]
argument_list|)
operator|=
name|REG_USERVAR_P
argument_list|(
name|orig
argument_list|)
expr_stmt|;
name|REG_LOOP_TEST_P
argument_list|(
name|map
operator|->
name|reg_map
index|[
name|regno
index|]
argument_list|)
operator|=
name|REG_LOOP_TEST_P
argument_list|(
name|orig
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|map
operator|->
name|reg_map
index|[
name|regno
index|]
argument_list|)
operator|=
name|RTX_UNCHANGING_P
argument_list|(
name|orig
argument_list|)
expr_stmt|;
comment|/* A reg with REG_FUNCTION_VALUE_P true will never reach here.  */
block|}
return|return
name|map
operator|->
name|reg_map
index|[
name|regno
index|]
return|;
case|case
name|SUBREG
case|:
name|copy
operator|=
name|copy_rtx_and_substitute
argument_list|(
name|SUBREG_REG
argument_list|(
name|orig
argument_list|)
argument_list|,
name|map
argument_list|)
expr_stmt|;
comment|/* SUBREG is ordinary, but don't make nested SUBREGs.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|copy
argument_list|)
operator|==
name|SUBREG
condition|)
return|return
name|gen_rtx
argument_list|(
name|SUBREG
argument_list|,
name|GET_MODE
argument_list|(
name|orig
argument_list|)
argument_list|,
name|SUBREG_REG
argument_list|(
name|copy
argument_list|)
argument_list|,
name|SUBREG_WORD
argument_list|(
name|orig
argument_list|)
operator|+
name|SUBREG_WORD
argument_list|(
name|copy
argument_list|)
argument_list|)
return|;
else|else
return|return
name|gen_rtx
argument_list|(
name|SUBREG
argument_list|,
name|GET_MODE
argument_list|(
name|orig
argument_list|)
argument_list|,
name|copy
argument_list|,
name|SUBREG_WORD
argument_list|(
name|orig
argument_list|)
argument_list|)
return|;
case|case
name|USE
case|:
case|case
name|CLOBBER
case|:
comment|/* USE and CLOBBER are ordinary, but we convert (use (subreg foo)) 	 to (use foo) if the original insn didn't have a subreg. 	 Removing the subreg distorts the VAX movstrhi pattern 	 by changing the mode of an operand.  */
name|copy
operator|=
name|copy_rtx_and_substitute
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|copy
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|SUBREG
condition|)
name|copy
operator|=
name|SUBREG_REG
argument_list|(
name|copy
argument_list|)
expr_stmt|;
return|return
name|gen_rtx
argument_list|(
name|code
argument_list|,
name|VOIDmode
argument_list|,
name|copy
argument_list|)
return|;
case|case
name|CODE_LABEL
case|:
name|LABEL_PRESERVE_P
argument_list|(
name|map
operator|->
name|label_map
index|[
name|CODE_LABEL_NUMBER
argument_list|(
name|orig
argument_list|)
index|]
argument_list|)
operator|=
name|LABEL_PRESERVE_P
argument_list|(
name|orig
argument_list|)
expr_stmt|;
return|return
name|map
operator|->
name|label_map
index|[
name|CODE_LABEL_NUMBER
argument_list|(
name|orig
argument_list|)
index|]
return|;
case|case
name|LABEL_REF
case|:
name|copy
operator|=
name|rtx_alloc
argument_list|(
name|LABEL_REF
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|copy
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|copy
argument_list|,
literal|0
argument_list|)
operator|=
name|map
operator|->
name|label_map
index|[
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
expr_stmt|;
name|LABEL_OUTSIDE_LOOP_P
argument_list|(
name|copy
argument_list|)
operator|=
name|LABEL_OUTSIDE_LOOP_P
argument_list|(
name|orig
argument_list|)
expr_stmt|;
return|return
name|copy
return|;
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|CONST_INT
case|:
return|return
name|orig
return|;
case|case
name|SYMBOL_REF
case|:
comment|/* Symbols which represent the address of a label stored in the constant 	 pool must be modified to point to a constant pool entry for the 	 remapped label.  Otherwise, symbols are returned unchanged.  */
if|if
condition|(
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|orig
argument_list|)
condition|)
block|{
name|rtx
name|constant
init|=
name|get_pool_constant
argument_list|(
name|orig
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|constant
argument_list|)
operator|==
name|LABEL_REF
condition|)
block|{
name|copy
operator|=
name|rtx_alloc
argument_list|(
name|LABEL_REF
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|copy
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|copy
argument_list|,
literal|0
argument_list|)
operator|=
name|map
operator|->
name|label_map
index|[
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|constant
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
expr_stmt|;
name|LABEL_OUTSIDE_LOOP_P
argument_list|(
name|copy
argument_list|)
operator|=
name|LABEL_OUTSIDE_LOOP_P
argument_list|(
name|orig
argument_list|)
expr_stmt|;
name|copy
operator|=
name|force_const_mem
argument_list|(
name|Pmode
argument_list|,
name|copy
argument_list|)
expr_stmt|;
return|return
name|XEXP
argument_list|(
name|copy
argument_list|,
literal|0
argument_list|)
return|;
block|}
block|}
return|return
name|orig
return|;
case|case
name|CONST_DOUBLE
case|:
comment|/* We have to make a new copy of this CONST_DOUBLE because don't want 	 to use the old value of CONST_DOUBLE_MEM.  Also, this may be a 	 duplicate of a CONST_DOUBLE we have already seen.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|orig
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
block|{
name|REAL_VALUE_TYPE
name|d
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|d
argument_list|,
name|orig
argument_list|)
expr_stmt|;
return|return
name|immed_real_const_1
argument_list|(
name|d
argument_list|,
name|GET_MODE
argument_list|(
name|orig
argument_list|)
argument_list|)
return|;
block|}
else|else
return|return
name|immed_double_const
argument_list|(
name|CONST_DOUBLE_LOW
argument_list|(
name|orig
argument_list|)
argument_list|,
name|CONST_DOUBLE_HIGH
argument_list|(
name|orig
argument_list|)
argument_list|,
name|VOIDmode
argument_list|)
return|;
case|case
name|CONST
case|:
comment|/* Make new constant pool entry for a constant 	 that was in the pool of the inline function.  */
if|if
condition|(
name|RTX_INTEGRATED_P
argument_list|(
name|orig
argument_list|)
condition|)
block|{
comment|/* If this was an address of a constant pool entry that itself 	     had to be placed in the constant pool, it might not be a 	     valid address.  So the recursive call below might turn it 	     into a register.  In that case, it isn't a constant any 	     more, so return it.  This has the potential of changing a 	     MEM into a REG, but we'll assume that it safe.  */
name|temp
operator|=
name|copy_rtx_and_substitute
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CONSTANT_P
argument_list|(
name|temp
argument_list|)
condition|)
return|return
name|temp
return|;
return|return
name|validize_mem
argument_list|(
name|force_const_mem
argument_list|(
name|GET_MODE
argument_list|(
name|orig
argument_list|)
argument_list|,
name|temp
argument_list|)
argument_list|)
return|;
block|}
break|break;
case|case
name|ADDRESS
case|:
comment|/* If from constant pool address, make new constant pool entry and 	 return its address.  */
if|if
condition|(
operator|!
name|RTX_INTEGRATED_P
argument_list|(
name|orig
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|temp
operator|=
name|force_const_mem
argument_list|(
name|GET_MODE
argument_list|(
name|orig
argument_list|)
argument_list|,
name|copy_rtx_and_substitute
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
name|map
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Legitimizing the address here is incorrect.  	 The only ADDRESS rtx's that can reach here are ones created by 	 save_constants.  Hence the operand of the ADDRESS is always legal 	 in this position of the instruction, since the original rtx without 	 the ADDRESS was legal.  	 The reason we don't legitimize the address here is that on the 	 Sparc, the caller may have a (high ...) surrounding this ADDRESS. 	 This code forces the operand of the address to a register, which 	 fails because we can not take the HIGH part of a register.  	 Also, change_address may create new registers.  These registers 	 will not have valid reg_map entries.  This can cause try_constants() 	 to fail because assumes that all registers in the rtx have valid 	 reg_map entries, and it may end up replacing one of these new 	 registers with junk. */
block|if (! memory_address_p (GET_MODE (temp), XEXP (temp, 0))) 	temp = change_address (temp, GET_MODE (temp), XEXP (temp, 0));
endif|#
directive|endif
return|return
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|ASM_OPERANDS
case|:
comment|/* If a single asm insn contains multiple output operands 	 then it contains multiple ASM_OPERANDS rtx's that share operand 3. 	 We must make sure that the copied insn continues to share it.  */
if|if
condition|(
name|map
operator|->
name|orig_asm_operands_vector
operator|==
name|XVEC
argument_list|(
name|orig
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|copy
operator|=
name|rtx_alloc
argument_list|(
name|ASM_OPERANDS
argument_list|)
expr_stmt|;
name|XSTR
argument_list|(
name|copy
argument_list|,
literal|0
argument_list|)
operator|=
name|XSTR
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XSTR
argument_list|(
name|copy
argument_list|,
literal|1
argument_list|)
operator|=
name|XSTR
argument_list|(
name|orig
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XINT
argument_list|(
name|copy
argument_list|,
literal|2
argument_list|)
operator|=
name|XINT
argument_list|(
name|orig
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|XVEC
argument_list|(
name|copy
argument_list|,
literal|3
argument_list|)
operator|=
name|map
operator|->
name|copy_asm_operands_vector
expr_stmt|;
name|XVEC
argument_list|(
name|copy
argument_list|,
literal|4
argument_list|)
operator|=
name|map
operator|->
name|copy_asm_constraints_vector
expr_stmt|;
name|XSTR
argument_list|(
name|copy
argument_list|,
literal|5
argument_list|)
operator|=
name|XSTR
argument_list|(
name|orig
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|XINT
argument_list|(
name|copy
argument_list|,
literal|6
argument_list|)
operator|=
name|XINT
argument_list|(
name|orig
argument_list|,
literal|6
argument_list|)
expr_stmt|;
return|return
name|copy
return|;
block|}
break|break;
case|case
name|CALL
case|:
comment|/* This is given special treatment because the first 	 operand of a CALL is a (MEM ...) which may get 	 forced into a register for cse.  This is undesirable 	 if function-address cse isn't wanted or if we won't do cse.  */
ifndef|#
directive|ifndef
name|NO_FUNCTION_CSE
if|if
condition|(
operator|!
operator|(
name|optimize
operator|&&
operator|!
name|flag_no_function_cse
operator|)
condition|)
endif|#
directive|endif
return|return
name|gen_rtx
argument_list|(
name|CALL
argument_list|,
name|GET_MODE
argument_list|(
name|orig
argument_list|)
argument_list|,
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|copy_rtx_and_substitute
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|map
argument_list|)
argument_list|)
argument_list|,
name|copy_rtx_and_substitute
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|1
argument_list|)
argument_list|,
name|map
argument_list|)
argument_list|)
return|;
break|break;
if|#
directive|if
literal|0
comment|/* Must be ifdefed out for loop unrolling to work.  */
block|case RETURN:       abort ();
endif|#
directive|endif
case|case
name|SET
case|:
comment|/* If this is setting fp or ap, it means that we have a nonlocal goto. 	 Don't alter that. 	 If the nonlocal goto is into the current function, 	 this will result in unnecessarily bad code, but should work.  */
if|if
condition|(
name|SET_DEST
argument_list|(
name|orig
argument_list|)
operator|==
name|virtual_stack_vars_rtx
operator|||
name|SET_DEST
argument_list|(
name|orig
argument_list|)
operator|==
name|virtual_incoming_args_rtx
condition|)
return|return
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|SET_DEST
argument_list|(
name|orig
argument_list|)
argument_list|,
name|copy_rtx_and_substitute
argument_list|(
name|SET_SRC
argument_list|(
name|orig
argument_list|)
argument_list|,
name|map
argument_list|)
argument_list|)
return|;
break|break;
case|case
name|MEM
case|:
name|copy
operator|=
name|rtx_alloc
argument_list|(
name|MEM
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|copy
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|copy
argument_list|,
literal|0
argument_list|)
operator|=
name|copy_rtx_and_substitute
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|copy
argument_list|)
operator|=
name|MEM_IN_STRUCT_P
argument_list|(
name|orig
argument_list|)
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|copy
argument_list|)
operator|=
name|MEM_VOLATILE_P
argument_list|(
name|orig
argument_list|)
expr_stmt|;
comment|/* If doing function inlining, this MEM might not be const in the 	 function that it is being inlined into, and thus may not be 	 unchanging after function inlining.  Constant pool references are 	 handled elsewhere, so this doesn't lose RTX_UNCHANGING_P bits 	 for them.  */
if|if
condition|(
operator|!
name|map
operator|->
name|integrating
condition|)
name|RTX_UNCHANGING_P
argument_list|(
name|copy
argument_list|)
operator|=
name|RTX_UNCHANGING_P
argument_list|(
name|orig
argument_list|)
expr_stmt|;
return|return
name|copy
return|;
block|}
name|copy
operator|=
name|rtx_alloc
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|copy
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|copy
operator|->
name|in_struct
operator|=
name|orig
operator|->
name|in_struct
expr_stmt|;
name|copy
operator|->
name|volatil
operator|=
name|orig
operator|->
name|volatil
expr_stmt|;
name|copy
operator|->
name|unchanging
operator|=
name|orig
operator|->
name|unchanging
expr_stmt|;
name|format_ptr
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|copy
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|copy
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|format_ptr
operator|++
condition|)
block|{
case|case
literal|'0'
case|:
break|break;
case|case
literal|'e'
case|:
name|XEXP
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|copy_rtx_and_substitute
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
argument_list|,
name|map
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
comment|/* Change any references to old-insns to point to the 	     corresponding copied insns.  */
name|XEXP
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|map
operator|->
name|insn_map
index|[
name|INSN_UID
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
argument_list|)
index|]
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
name|XVEC
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|XVEC
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|XVEC
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
operator|!=
name|NULL
operator|&&
name|XVECLEN
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|XVEC
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|rtvec_alloc
argument_list|(
name|XVECLEN
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|XVECEXP
argument_list|(
name|copy
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
operator|=
name|copy_rtx_and_substitute
argument_list|(
name|XVECEXP
argument_list|(
name|orig
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'w'
case|:
name|XWINT
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|XWINT
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|XINT
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|XINT
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|XSTR
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|XSTR
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|code
operator|==
name|ASM_OPERANDS
operator|&&
name|map
operator|->
name|orig_asm_operands_vector
operator|==
literal|0
condition|)
block|{
name|map
operator|->
name|orig_asm_operands_vector
operator|=
name|XVEC
argument_list|(
name|orig
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|map
operator|->
name|copy_asm_operands_vector
operator|=
name|XVEC
argument_list|(
name|copy
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|map
operator|->
name|copy_asm_constraints_vector
operator|=
name|XVEC
argument_list|(
name|copy
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
return|return
name|copy
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Substitute known constant values into INSN, if that is valid.  */
end_comment

begin_function
name|void
name|try_constants
parameter_list|(
name|insn
parameter_list|,
name|map
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|struct
name|inline_remap
modifier|*
name|map
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|map
operator|->
name|num_sets
operator|=
literal|0
expr_stmt|;
name|subst_constants
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|,
name|map
argument_list|)
expr_stmt|;
comment|/* Apply the changes if they are valid; otherwise discard them.  */
name|apply_change_group
argument_list|()
expr_stmt|;
comment|/* Show we don't know the value of anything stored or clobbered.  */
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|mark_stores
argument_list|)
expr_stmt|;
name|map
operator|->
name|last_pc_value
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
name|map
operator|->
name|last_cc0_value
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* Set up any constant equivalences made in this insn.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|map
operator|->
name|num_sets
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|map
operator|->
name|equiv_sets
index|[
name|i
index|]
operator|.
name|dest
argument_list|)
operator|==
name|REG
condition|)
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|map
operator|->
name|equiv_sets
index|[
name|i
index|]
operator|.
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
name|map
operator|->
name|const_equiv_map
index|[
name|regno
index|]
operator|==
literal|0
comment|/* Following clause is a hack to make case work where GNU C++ 		 reassigns a variable to make cse work right.  */
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|map
operator|->
name|const_equiv_map
index|[
name|regno
index|]
argument_list|,
name|map
operator|->
name|equiv_sets
index|[
name|i
index|]
operator|.
name|equiv
argument_list|)
condition|)
block|{
name|map
operator|->
name|const_equiv_map
index|[
name|regno
index|]
operator|=
name|map
operator|->
name|equiv_sets
index|[
name|i
index|]
operator|.
name|equiv
expr_stmt|;
name|map
operator|->
name|const_age_map
index|[
name|regno
index|]
operator|=
name|map
operator|->
name|const_age
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|map
operator|->
name|equiv_sets
index|[
name|i
index|]
operator|.
name|dest
operator|==
name|pc_rtx
condition|)
name|map
operator|->
name|last_pc_value
operator|=
name|map
operator|->
name|equiv_sets
index|[
name|i
index|]
operator|.
name|equiv
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
elseif|else
if|if
condition|(
name|map
operator|->
name|equiv_sets
index|[
name|i
index|]
operator|.
name|dest
operator|==
name|cc0_rtx
condition|)
name|map
operator|->
name|last_cc0_value
operator|=
name|map
operator|->
name|equiv_sets
index|[
name|i
index|]
operator|.
name|equiv
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Substitute known constants for pseudo regs in the contents of LOC,    which are part of INSN.    If INSN is zero, the substitution should always be done (this is used to    update DECL_RTL).    These changes are taken out by try_constants if the result is not valid.     Note that we are more concerned with determining when the result of a SET    is a constant, for further propagation, than actually inserting constants    into insns; cse will do the latter task better.     This function is also used to adjust address of items previously addressed    via the virtual stack variable or virtual incoming arguments registers.  */
end_comment

begin_function
specifier|static
name|void
name|subst_constants
parameter_list|(
name|loc
parameter_list|,
name|insn
parameter_list|,
name|map
parameter_list|)
name|rtx
modifier|*
name|loc
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|struct
name|inline_remap
modifier|*
name|map
decl_stmt|;
block|{
name|rtx
name|x
init|=
operator|*
name|loc
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|register
name|char
modifier|*
name|format_ptr
decl_stmt|;
name|int
name|num_changes
init|=
name|num_validated_changes
argument_list|()
decl_stmt|;
name|rtx
name|new
init|=
literal|0
decl_stmt|;
name|enum
name|machine_mode
name|op0_mode
decl_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PC
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CONST
case|:
case|case
name|LABEL_REF
case|:
case|case
name|ADDRESS
case|:
return|return;
ifdef|#
directive|ifdef
name|HAVE_cc0
case|case
name|CC0
case|:
name|validate_change
argument_list|(
name|insn
argument_list|,
name|loc
argument_list|,
name|map
operator|->
name|last_cc0_value
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
endif|#
directive|endif
case|case
name|USE
case|:
case|case
name|CLOBBER
case|:
comment|/* The only thing we can do with a USE or CLOBBER is possibly do 	 some substitutions in a MEM within it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
name|subst_constants
argument_list|(
operator|&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|,
name|map
argument_list|)
expr_stmt|;
return|return;
case|case
name|REG
case|:
comment|/* Substitute for parms and known constants.  Don't replace 	 hard regs used as user variables with constants.  */
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|REG_USERVAR_P
argument_list|(
name|x
argument_list|)
operator|)
operator|&&
name|regno
operator|<
name|map
operator|->
name|const_equiv_map_size
operator|&&
name|map
operator|->
name|const_equiv_map
index|[
name|regno
index|]
operator|!=
literal|0
operator|&&
name|map
operator|->
name|const_age_map
index|[
name|regno
index|]
operator|>=
name|map
operator|->
name|const_age
condition|)
name|validate_change
argument_list|(
name|insn
argument_list|,
name|loc
argument_list|,
name|map
operator|->
name|const_equiv_map
index|[
name|regno
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|SUBREG
case|:
comment|/* SUBREG applied to something other than a reg 	 should be treated as ordinary, since that must 	 be a special hack and we don't know how to treat it specially. 	 Consider for example mulsidi3 in m68k.md. 	 Ordinary SUBREG of a REG needs this special treatment.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|rtx
name|inner
init|=
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|rtx
name|new
init|=
literal|0
decl_stmt|;
comment|/* We can't call subst_constants on&SUBREG_REG (x) because any 	     constant or SUBREG wouldn't be valid inside our SUBEG.  Instead, 	     see what is inside, try to form the new SUBREG and see if that is 	     valid.  We handle two cases: extracting a full word in an  	     integral mode and extracting the low part.  */
name|subst_constants
argument_list|(
operator|&
name|inner
argument_list|,
name|NULL_RTX
argument_list|,
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|UNITS_PER_WORD
operator|&&
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|VOIDmode
condition|)
name|new
operator|=
name|operand_subword
argument_list|(
name|inner
argument_list|,
name|SUBREG_WORD
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|==
literal|0
operator|&&
name|subreg_lowpart_p
argument_list|(
name|x
argument_list|)
condition|)
name|new
operator|=
name|gen_lowpart_common
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|inner
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
condition|)
name|validate_change
argument_list|(
name|insn
argument_list|,
name|loc
argument_list|,
name|new
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|MEM
case|:
name|subst_constants
argument_list|(
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|,
name|map
argument_list|)
expr_stmt|;
comment|/* If a memory address got spoiled, change it back.  */
if|if
condition|(
name|insn
operator|!=
literal|0
operator|&&
name|num_validated_changes
argument_list|()
operator|!=
name|num_changes
operator|&&
operator|!
name|memory_address_p
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|cancel_changes
argument_list|(
name|num_changes
argument_list|)
expr_stmt|;
return|return;
case|case
name|SET
case|:
block|{
comment|/* Substitute constants in our source, and in any arguments to a 	   complex (e..g, ZERO_EXTRACT) destination, but not in the destination 	   itself.  */
name|rtx
modifier|*
name|dest_loc
init|=
operator|&
name|SET_DEST
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|rtx
name|dest
init|=
operator|*
name|dest_loc
decl_stmt|;
name|rtx
name|src
decl_stmt|,
name|tem
decl_stmt|;
name|subst_constants
argument_list|(
operator|&
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|insn
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|src
operator|=
name|SET_SRC
argument_list|(
name|x
argument_list|)
expr_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
operator|*
name|dest_loc
argument_list|)
operator|==
name|ZERO_EXTRACT
comment|/* By convention, we always use ZERO_EXTRACT in the dest.  */
comment|/*	       || GET_CODE (*dest_loc) == SIGN_EXTRACT */
operator|||
name|GET_CODE
argument_list|(
operator|*
name|dest_loc
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
operator|*
name|dest_loc
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
operator|*
name|dest_loc
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
block|{
name|subst_constants
argument_list|(
operator|&
name|XEXP
argument_list|(
operator|*
name|dest_loc
argument_list|,
literal|1
argument_list|)
argument_list|,
name|insn
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|subst_constants
argument_list|(
operator|&
name|XEXP
argument_list|(
operator|*
name|dest_loc
argument_list|,
literal|2
argument_list|)
argument_list|,
name|insn
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
name|dest_loc
operator|=
operator|&
name|XEXP
argument_list|(
operator|*
name|dest_loc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Do substitute in the address of a destination in memory.  */
if|if
condition|(
name|GET_CODE
argument_list|(
operator|*
name|dest_loc
argument_list|)
operator|==
name|MEM
condition|)
name|subst_constants
argument_list|(
operator|&
name|XEXP
argument_list|(
operator|*
name|dest_loc
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|,
name|map
argument_list|)
expr_stmt|;
comment|/* Check for the case of DEST a SUBREG, both it and the underlying 	   register are less than one word, and the SUBREG has the wider mode. 	   In the case, we are really setting the underlying register to the 	   source converted to the mode of DEST.  So indicate that.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|<=
name|UNITS_PER_WORD
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
argument_list|)
argument_list|)
operator|<=
name|UNITS_PER_WORD
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
argument_list|)
argument_list|)
operator|<=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|tem
operator|=
name|gen_lowpart_if_possible
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
argument_list|)
argument_list|,
name|src
argument_list|)
operator|)
condition|)
name|src
operator|=
name|tem
operator|,
name|dest
operator|=
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
expr_stmt|;
comment|/* If storing a recognizable value save it for later recording.  */
if|if
condition|(
operator|(
name|map
operator|->
name|num_sets
operator|<
name|MAX_RECOG_OPERANDS
operator|)
operator|&&
operator|(
name|CONSTANT_P
argument_list|(
name|src
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>=
name|FIRST_VIRTUAL_REGISTER
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<=
name|LAST_VIRTUAL_REGISTER
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|COMPARE
ifdef|#
directive|ifdef
name|HAVE_cc0
operator|||
name|dest
operator|==
name|cc0_rtx
endif|#
directive|endif
operator|||
operator|(
name|dest
operator|==
name|pc_rtx
operator|&&
operator|(
name|src
operator|==
name|pc_rtx
operator|||
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|RETURN
operator|||
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|LABEL_REF
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* Normally, this copy won't do anything.  But, if SRC is a COMPARE 	       it will cause us to save the COMPARE with any constants 	       substituted, which is what we want for later.  */
name|map
operator|->
name|equiv_sets
index|[
name|map
operator|->
name|num_sets
index|]
operator|.
name|equiv
operator|=
name|copy_rtx
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|map
operator|->
name|equiv_sets
index|[
name|map
operator|->
name|num_sets
operator|++
index|]
operator|.
name|dest
operator|=
name|dest
expr_stmt|;
block|}
return|return;
block|}
block|}
name|format_ptr
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
comment|/* If the first operand is an expression, save its mode for later.  */
if|if
condition|(
operator|*
name|format_ptr
operator|==
literal|'e'
condition|)
name|op0_mode
operator|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|format_ptr
operator|++
condition|)
block|{
case|case
literal|'0'
case|:
break|break;
case|case
literal|'e'
case|:
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|)
name|subst_constants
argument_list|(
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|,
name|map
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
case|case
literal|'i'
case|:
case|case
literal|'s'
case|:
case|case
literal|'w'
case|:
break|break;
case|case
literal|'E'
case|:
if|if
condition|(
name|XVEC
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|NULL
operator|&&
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|subst_constants
argument_list|(
operator|&
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|insn
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* If this is a commutative operation, move a constant to the second      operand unless the second operand is already a CONST_INT.  */
if|if
condition|(
operator|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'c'
operator|||
name|code
operator|==
name|NE
operator|||
name|code
operator|==
name|EQ
operator|)
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
block|{
name|rtx
name|tem
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|tem
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Simplify the expression in case we put in some constants.  */
switch|switch
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
literal|'1'
case|:
name|new
operator|=
name|simplify_unary_operation
argument_list|(
name|code
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op0_mode
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
block|{
name|enum
name|machine_mode
name|op_mode
init|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|op_mode
operator|==
name|VOIDmode
condition|)
name|op_mode
operator|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|=
name|simplify_relational_operation
argument_list|(
name|code
argument_list|,
name|op_mode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FLOAT_STORE_FLAG_VALUE
if|if
condition|(
name|new
operator|!=
literal|0
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
name|new
operator|=
operator|(
operator|(
name|new
operator|==
name|const0_rtx
operator|)
condition|?
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
else|:
name|immed_real_const_1
argument_list|(
name|FLOAT_STORE_FLAG_VALUE
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
case|case
literal|'2'
case|:
case|case
literal|'c'
case|:
name|new
operator|=
name|simplify_binary_operation
argument_list|(
name|code
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
case|case
literal|'3'
case|:
name|new
operator|=
name|simplify_ternary_operation
argument_list|(
name|code
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|op0_mode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|new
condition|)
name|validate_change
argument_list|(
name|insn
argument_list|,
name|loc
argument_list|,
name|new
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Show that register modified no longer contain known constants.  We are    called from note_stores with parts of the new insn.  */
end_comment

begin_function
name|void
name|mark_stores
parameter_list|(
name|dest
parameter_list|,
name|x
parameter_list|)
name|rtx
name|dest
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
name|int
name|regno
init|=
operator|-
literal|1
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
comment|/* DEST is always the innermost thing set, except in the case of      SUBREGs of hard registers.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
condition|)
name|regno
operator|=
name|REGNO
argument_list|(
name|dest
argument_list|)
operator|,
name|mode
operator|=
name|GET_MODE
argument_list|(
name|dest
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|regno
operator|=
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|+
name|SUBREG_WORD
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|regno
operator|>=
literal|0
condition|)
block|{
name|int
name|last_reg
init|=
operator|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|?
name|regno
else|:
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
operator|-
literal|1
operator|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|regno
init|;
name|i
operator|<=
name|last_reg
condition|;
name|i
operator|++
control|)
name|global_const_equiv_map
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If any CONST expressions with RTX_INTEGRATED_P are present in the rtx    pointed to by PX, they represent constants in the constant pool.    Replace these with a new memory reference obtained from force_const_mem.    Similarly, ADDRESS expressions with RTX_INTEGRATED_P represent the    address of a constant pool entry.  Replace them with the address of    a new constant pool entry obtained from force_const_mem.  */
end_comment

begin_function
specifier|static
name|void
name|restore_constants
parameter_list|(
name|px
parameter_list|)
name|rtx
modifier|*
name|px
decl_stmt|;
block|{
name|rtx
name|x
init|=
operator|*
name|px
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
comment|/* We have to make a new CONST_DOUBLE to ensure that we account for 	 it correctly.  Using the old CONST_DOUBLE_MEM data is wrong.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
block|{
name|REAL_VALUE_TYPE
name|d
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|d
argument_list|,
name|x
argument_list|)
expr_stmt|;
operator|*
name|px
operator|=
name|immed_real_const_1
argument_list|(
name|d
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|px
operator|=
name|immed_double_const
argument_list|(
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
argument_list|,
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
argument_list|,
name|VOIDmode
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|RTX_INTEGRATED_P
argument_list|(
name|x
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST
condition|)
block|{
name|restore_constants
argument_list|(
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|px
operator|=
name|validize_mem
argument_list|(
name|force_const_mem
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|RTX_INTEGRATED_P
argument_list|(
name|x
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
comment|/* This must be (subreg/i:M1 (const/i:M2 ...) 0).  */
name|rtx
name|new
init|=
name|XEXP
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|restore_constants
argument_list|(
operator|&
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|force_const_mem
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|new
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|px
operator|=
name|validize_mem
argument_list|(
name|new
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|RTX_INTEGRATED_P
argument_list|(
name|x
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|ADDRESS
condition|)
block|{
name|restore_constants
argument_list|(
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|px
operator|=
name|XEXP
argument_list|(
name|force_const_mem
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|fmt
operator|++
condition|)
block|{
case|case
literal|'E'
case|:
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|restore_constants
argument_list|(
operator|&
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|restore_constants
argument_list|(
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a pointer to some BLOCK node, if the BLOCK_ABSTRACT_ORIGIN for the    given BLOCK node is NULL, set the BLOCK_ABSTRACT_ORIGIN for the node so    that it points to the node itself, thus indicating that the node is its    own (abstract) origin.  Additionally, if the BLOCK_ABSTRACT_ORIGIN for    the given node is NULL, recursively descend the decl/block tree which    it is the root of, and for each other ..._DECL or BLOCK node contained    therein whose DECL_ABSTRACT_ORIGINs or BLOCK_ABSTRACT_ORIGINs are also    still NULL, set *their* DECL_ABSTRACT_ORIGIN or BLOCK_ABSTRACT_ORIGIN    values to point to themselves.  */
end_comment

begin_function_decl
specifier|static
name|void
name|set_decl_origin_self
parameter_list|()
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|set_block_origin_self
parameter_list|(
name|stmt
parameter_list|)
specifier|register
name|tree
name|stmt
decl_stmt|;
block|{
if|if
condition|(
name|BLOCK_ABSTRACT_ORIGIN
argument_list|(
name|stmt
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|BLOCK_ABSTRACT_ORIGIN
argument_list|(
name|stmt
argument_list|)
operator|=
name|stmt
expr_stmt|;
block|{
specifier|register
name|tree
name|local_decl
decl_stmt|;
for|for
control|(
name|local_decl
operator|=
name|BLOCK_VARS
argument_list|(
name|stmt
argument_list|)
init|;
name|local_decl
operator|!=
name|NULL_TREE
condition|;
name|local_decl
operator|=
name|TREE_CHAIN
argument_list|(
name|local_decl
argument_list|)
control|)
name|set_decl_origin_self
argument_list|(
name|local_decl
argument_list|)
expr_stmt|;
comment|/* Potential recursion.  */
block|}
block|{
specifier|register
name|tree
name|subblock
decl_stmt|;
for|for
control|(
name|subblock
operator|=
name|BLOCK_SUBBLOCKS
argument_list|(
name|stmt
argument_list|)
init|;
name|subblock
operator|!=
name|NULL_TREE
condition|;
name|subblock
operator|=
name|BLOCK_CHAIN
argument_list|(
name|subblock
argument_list|)
control|)
name|set_block_origin_self
argument_list|(
name|subblock
argument_list|)
expr_stmt|;
comment|/* Recurse.  */
block|}
block|}
block|}
end_function

begin_comment
comment|/* Given a pointer to some ..._DECL node, if the DECL_ABSTRACT_ORIGIN for    the given ..._DECL node is NULL, set the DECL_ABSTRACT_ORIGIN for the    node to so that it points to the node itself, thus indicating that the    node represents its own (abstract) origin.  Additionally, if the    DECL_ABSTRACT_ORIGIN for the given node is NULL, recursively descend    the decl/block tree of which the given node is the root of, and for    each other ..._DECL or BLOCK node contained therein whose    DECL_ABSTRACT_ORIGINs or BLOCK_ABSTRACT_ORIGINs are also still NULL,    set *their* DECL_ABSTRACT_ORIGIN or BLOCK_ABSTRACT_ORIGIN values to    point to themselves.  */
end_comment

begin_function
specifier|static
name|void
name|set_decl_origin_self
parameter_list|(
name|decl
parameter_list|)
specifier|register
name|tree
name|decl
decl_stmt|;
block|{
if|if
condition|(
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|decl
argument_list|)
operator|=
name|decl
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
specifier|register
name|tree
name|arg
decl_stmt|;
for|for
control|(
name|arg
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|decl
argument_list|)
init|;
name|arg
condition|;
name|arg
operator|=
name|TREE_CHAIN
argument_list|(
name|arg
argument_list|)
control|)
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|arg
argument_list|)
operator|=
name|arg
expr_stmt|;
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|set_block_origin_self
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a pointer to some BLOCK node, and a boolean value to set the    "abstract" flags to, set that value into the BLOCK_ABSTRACT flag for    the given block, and for all local decls and all local sub-blocks    (recursively) which are contained therein.  */
end_comment

begin_function_decl
name|void
name|set_decl_abstract_flags
parameter_list|()
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|set_block_abstract_flags
parameter_list|(
name|stmt
parameter_list|,
name|setting
parameter_list|)
specifier|register
name|tree
name|stmt
decl_stmt|;
specifier|register
name|int
name|setting
decl_stmt|;
block|{
name|BLOCK_ABSTRACT
argument_list|(
name|stmt
argument_list|)
operator|=
name|setting
expr_stmt|;
block|{
specifier|register
name|tree
name|local_decl
decl_stmt|;
for|for
control|(
name|local_decl
operator|=
name|BLOCK_VARS
argument_list|(
name|stmt
argument_list|)
init|;
name|local_decl
operator|!=
name|NULL_TREE
condition|;
name|local_decl
operator|=
name|TREE_CHAIN
argument_list|(
name|local_decl
argument_list|)
control|)
name|set_decl_abstract_flags
argument_list|(
name|local_decl
argument_list|,
name|setting
argument_list|)
expr_stmt|;
block|}
block|{
specifier|register
name|tree
name|subblock
decl_stmt|;
for|for
control|(
name|subblock
operator|=
name|BLOCK_SUBBLOCKS
argument_list|(
name|stmt
argument_list|)
init|;
name|subblock
operator|!=
name|NULL_TREE
condition|;
name|subblock
operator|=
name|BLOCK_CHAIN
argument_list|(
name|subblock
argument_list|)
control|)
name|set_block_abstract_flags
argument_list|(
name|subblock
argument_list|,
name|setting
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Given a pointer to some ..._DECL node, and a boolean value to set the    "abstract" flags to, set that value into the DECL_ABSTRACT flag for the    given decl, and (in the case where the decl is a FUNCTION_DECL) also    set the abstract flags for all of the parameters, local vars, local    blocks and sub-blocks (recursively) to the same setting.  */
end_comment

begin_function
name|void
name|set_decl_abstract_flags
parameter_list|(
name|decl
parameter_list|,
name|setting
parameter_list|)
specifier|register
name|tree
name|decl
decl_stmt|;
specifier|register
name|int
name|setting
decl_stmt|;
block|{
name|DECL_ABSTRACT
argument_list|(
name|decl
argument_list|)
operator|=
name|setting
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
specifier|register
name|tree
name|arg
decl_stmt|;
for|for
control|(
name|arg
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|decl
argument_list|)
init|;
name|arg
condition|;
name|arg
operator|=
name|TREE_CHAIN
argument_list|(
name|arg
argument_list|)
control|)
name|DECL_ABSTRACT
argument_list|(
name|arg
argument_list|)
operator|=
name|setting
expr_stmt|;
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|set_block_abstract_flags
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|,
name|setting
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output the assembly language code for the function FNDECL    from its DECL_SAVED_INSNS.  Used for inline functions that are output    at end of compilation instead of where they came in the source.  */
end_comment

begin_function
name|void
name|output_inline_function
parameter_list|(
name|fndecl
parameter_list|)
name|tree
name|fndecl
decl_stmt|;
block|{
name|rtx
name|head
init|=
name|DECL_SAVED_INSNS
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|rtx
name|last
decl_stmt|;
name|temporary_allocation
argument_list|()
expr_stmt|;
name|current_function_decl
operator|=
name|fndecl
expr_stmt|;
comment|/* This call is only used to initialize global variables.  */
name|init_function_start
argument_list|(
name|fndecl
argument_list|,
literal|"lossage"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Redo parameter determinations in case the FUNCTION_...      macros took machine-specific actions that need to be redone.  */
name|assign_parms
argument_list|(
name|fndecl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Set stack frame size.  */
name|assign_stack_local
argument_list|(
name|BLKmode
argument_list|,
name|DECL_FRAME_SIZE
argument_list|(
name|fndecl
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|restore_reg_data
argument_list|(
name|FIRST_PARM_INSN
argument_list|(
name|head
argument_list|)
argument_list|)
expr_stmt|;
name|stack_slot_list
operator|=
name|STACK_SLOT_LIST
argument_list|(
name|head
argument_list|)
expr_stmt|;
if|if
condition|(
name|FUNCTION_FLAGS
argument_list|(
name|head
argument_list|)
operator|&
name|FUNCTION_FLAGS_CALLS_ALLOCA
condition|)
name|current_function_calls_alloca
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|FUNCTION_FLAGS
argument_list|(
name|head
argument_list|)
operator|&
name|FUNCTION_FLAGS_CALLS_SETJMP
condition|)
name|current_function_calls_setjmp
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|FUNCTION_FLAGS
argument_list|(
name|head
argument_list|)
operator|&
name|FUNCTION_FLAGS_CALLS_LONGJMP
condition|)
name|current_function_calls_longjmp
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|FUNCTION_FLAGS
argument_list|(
name|head
argument_list|)
operator|&
name|FUNCTION_FLAGS_RETURNS_STRUCT
condition|)
name|current_function_returns_struct
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|FUNCTION_FLAGS
argument_list|(
name|head
argument_list|)
operator|&
name|FUNCTION_FLAGS_RETURNS_PCC_STRUCT
condition|)
name|current_function_returns_pcc_struct
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|FUNCTION_FLAGS
argument_list|(
name|head
argument_list|)
operator|&
name|FUNCTION_FLAGS_NEEDS_CONTEXT
condition|)
name|current_function_needs_context
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|FUNCTION_FLAGS
argument_list|(
name|head
argument_list|)
operator|&
name|FUNCTION_FLAGS_HAS_NONLOCAL_LABEL
condition|)
name|current_function_has_nonlocal_label
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|FUNCTION_FLAGS
argument_list|(
name|head
argument_list|)
operator|&
name|FUNCTION_FLAGS_RETURNS_POINTER
condition|)
name|current_function_returns_pointer
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|FUNCTION_FLAGS
argument_list|(
name|head
argument_list|)
operator|&
name|FUNCTION_FLAGS_USES_CONST_POOL
condition|)
name|current_function_uses_const_pool
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|FUNCTION_FLAGS
argument_list|(
name|head
argument_list|)
operator|&
name|FUNCTION_FLAGS_USES_PIC_OFFSET_TABLE
condition|)
name|current_function_uses_pic_offset_table
operator|=
literal|1
expr_stmt|;
name|current_function_outgoing_args_size
operator|=
name|OUTGOING_ARGS_SIZE
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|current_function_pops_args
operator|=
name|POPS_ARGS
argument_list|(
name|head
argument_list|)
expr_stmt|;
comment|/* There is no need to output a return label again.  */
name|return_label
operator|=
literal|0
expr_stmt|;
name|expand_function_end
argument_list|(
name|DECL_SOURCE_FILE
argument_list|(
name|fndecl
argument_list|)
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Find last insn and rebuild the constant pool.  */
for|for
control|(
name|last
operator|=
name|FIRST_PARM_INSN
argument_list|(
name|head
argument_list|)
init|;
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
condition|;
name|last
operator|=
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|last
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
block|{
name|restore_constants
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|last
argument_list|)
argument_list|)
expr_stmt|;
name|restore_constants
argument_list|(
operator|&
name|REG_NOTES
argument_list|(
name|last
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|set_new_first_and_last_insn
argument_list|(
name|FIRST_PARM_INSN
argument_list|(
name|head
argument_list|)
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|set_new_first_and_last_label_num
argument_list|(
name|FIRST_LABELNO
argument_list|(
name|head
argument_list|)
argument_list|,
name|LAST_LABELNO
argument_list|(
name|head
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We must have already output DWARF debugging information for the      original (abstract) inline function declaration/definition, so      we want to make sure that the debugging information we generate      for this special instance of the inline function refers back to      the information we already generated.  To make sure that happens,      we simply have to set the DECL_ABSTRACT_ORIGIN for the function      node (and for all of the local ..._DECL nodes which are its children)      so that they all point to themselves.  */
name|set_decl_origin_self
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
comment|/* Compile this function all the way down to assembly code.  */
name|rest_of_compilation
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|current_function_decl
operator|=
literal|0
expr_stmt|;
name|permanent_allocation
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

