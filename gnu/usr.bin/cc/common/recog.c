begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Subroutines used by or related to instruction recognition.    Copyright (C) 1987, 1988, 1991, 1992 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_include
include|#
directive|include
file|"insn-flags.h"
end_include

begin_include
include|#
directive|include
file|"insn-codes.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|STACK_PUSH_CODE
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|STACK_GROWS_DOWNWARD
end_ifdef

begin_define
define|#
directive|define
name|STACK_PUSH_CODE
value|PRE_DEC
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|STACK_PUSH_CODE
value|PRE_INC
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Import from final.c: */
end_comment

begin_function_decl
specifier|extern
name|rtx
name|alter_subreg
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|strict_memory_address_p
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|memory_address_p
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Nonzero means allow operands to be volatile.    This should be 0 if you are generating rtl, such as if you are calling    the functions in optabs.c and expmed.c (most of the time).    This should be 1 if all valid insns need to be recognized,    such as in regclass.c and final.c and reload.c.     init_recog and init_recog_no_volatile are responsible for setting this.  */
end_comment

begin_decl_stmt
name|int
name|volatile_ok
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* On return from `constrain_operands', indicate which alternative    was satisfied.  */
end_comment

begin_decl_stmt
name|int
name|which_alternative
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero after end of reload pass.    Set to 1 or 0 by toplev.c.    Controls the significance of (SUBREG (MEM)).  */
end_comment

begin_decl_stmt
name|int
name|reload_completed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize data used by the function `recog'.    This must be called once in the compilation of a function    before any insn recognition may be done in the function.  */
end_comment

begin_function
name|void
name|init_recog_no_volatile
parameter_list|()
block|{
name|volatile_ok
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|init_recog
parameter_list|()
block|{
name|volatile_ok
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Try recognizing the instruction INSN,    and return the code number that results.    Remeber the code so that repeated calls do not    need to spend the time for actual rerecognition.     This function is the normal interface to instruction recognition.    The automatically-generated function `recog' is normally called    through this one.  (The only exception is in combine.c.)  */
end_comment

begin_function
name|int
name|recog_memoized
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
if|if
condition|(
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|<
literal|0
condition|)
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
name|recog
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
return|return
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Check that X is an insn-body for an `asm' with operands    and that the operands mentioned in it are legitimate.  */
end_comment

begin_function
name|int
name|check_asm_operands
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|int
name|noperands
init|=
name|asm_noperands
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|rtx
modifier|*
name|operands
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|noperands
operator|<
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|noperands
operator|==
literal|0
condition|)
return|return
literal|1
return|;
name|operands
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|noperands
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|decode_asm_operands
argument_list|(
name|x
argument_list|,
name|operands
argument_list|,
name|NULL_PTR
argument_list|,
name|NULL_PTR
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|noperands
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|general_operand
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|,
name|VOIDmode
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Static data for the next two routines.     The maximum number of changes supported is defined as the maximum    number of operands times 5.  This allows for repeated substitutions    inside complex indexed address, or, alternatively, changes in up    to 5 insns.  */
end_comment

begin_define
define|#
directive|define
name|MAX_CHANGE_LOCS
value|(MAX_RECOG_OPERANDS * 5)
end_define

begin_decl_stmt
specifier|static
name|rtx
name|change_objects
index|[
name|MAX_CHANGE_LOCS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|change_old_codes
index|[
name|MAX_CHANGE_LOCS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|change_locs
index|[
name|MAX_CHANGE_LOCS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|change_olds
index|[
name|MAX_CHANGE_LOCS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|num_changes
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Validate a proposed change to OBJECT.  LOC is the location in the rtl for    at which NEW will be placed.  If OBJECT is zero, no validation is done,    the change is simply made.     Two types of objects are supported:  If OBJECT is a MEM, memory_address_p    will be called with the address and mode as parameters.  If OBJECT is    an INSN, CALL_INSN, or JUMP_INSN, the insn will be re-recognized with    the change in place.     IN_GROUP is non-zero if this is part of a group of changes that must be    performed as a group.  In that case, the changes will be stored.  The    function `apply_change_group' will validate and apply the changes.     If IN_GROUP is zero, this is a single change.  Try to recognize the insn    or validate the memory reference with the change applied.  If the result    is not valid for the machine, suppress the change and return zero.    Otherwise, perform the change and return 1.  */
end_comment

begin_function
name|int
name|validate_change
parameter_list|(
name|object
parameter_list|,
name|loc
parameter_list|,
name|new
parameter_list|,
name|in_group
parameter_list|)
name|rtx
name|object
decl_stmt|;
name|rtx
modifier|*
name|loc
decl_stmt|;
name|rtx
name|new
decl_stmt|;
name|int
name|in_group
decl_stmt|;
block|{
name|rtx
name|old
init|=
operator|*
name|loc
decl_stmt|;
if|if
condition|(
name|old
operator|==
name|new
operator|||
name|rtx_equal_p
argument_list|(
name|old
argument_list|,
name|new
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|num_changes
operator|>=
name|MAX_CHANGE_LOCS
operator|||
operator|(
name|in_group
operator|==
literal|0
operator|&&
name|num_changes
operator|!=
literal|0
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
operator|*
name|loc
operator|=
name|new
expr_stmt|;
comment|/* Save the information describing this change.  */
name|change_objects
index|[
name|num_changes
index|]
operator|=
name|object
expr_stmt|;
name|change_locs
index|[
name|num_changes
index|]
operator|=
name|loc
expr_stmt|;
name|change_olds
index|[
name|num_changes
index|]
operator|=
name|old
expr_stmt|;
if|if
condition|(
name|object
operator|&&
name|GET_CODE
argument_list|(
name|object
argument_list|)
operator|!=
name|MEM
condition|)
block|{
comment|/* Set INSN_CODE to force rerecognition of insn.  Save old code in 	 case invalid.  */
name|change_old_codes
index|[
name|num_changes
index|]
operator|=
name|INSN_CODE
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|INSN_CODE
argument_list|(
name|object
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|num_changes
operator|++
expr_stmt|;
comment|/* If we are making a group of changes, return 1.  Otherwise, validate the      change group we made.  */
if|if
condition|(
name|in_group
condition|)
return|return
literal|1
return|;
else|else
return|return
name|apply_change_group
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/* Apply a group of changes previously issued with `validate_change'.    Return 1 if all changes are valid, zero otherwise.  */
end_comment

begin_function
name|int
name|apply_change_group
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
comment|/* The changes have been applied and all INSN_CODEs have been reset to force      rerecognition.       The changes are valid if we aren't given an object, or if we are      given a MEM and it still is a valid address, or if this is in insn      and it is recognized.  In the latter case, if reload has completed,      we also require that the operands meet the constraints for      the insn.  We do not allow modifying an ASM_OPERANDS after reload      has completed because verifying the constraints is too difficult.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_changes
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|object
init|=
name|change_objects
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|object
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|GET_CODE
argument_list|(
name|object
argument_list|)
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
operator|!
name|memory_address_p
argument_list|(
name|GET_MODE
argument_list|(
name|object
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|object
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
operator|(
name|recog_memoized
argument_list|(
name|object
argument_list|)
operator|<
literal|0
operator|&&
operator|(
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|object
argument_list|)
argument_list|)
operator|<
literal|0
operator|||
operator|!
name|check_asm_operands
argument_list|(
name|PATTERN
argument_list|(
name|object
argument_list|)
argument_list|)
operator|||
name|reload_completed
operator|)
operator|)
operator|||
operator|(
name|reload_completed
operator|&&
operator|(
name|insn_extract
argument_list|(
name|object
argument_list|)
operator|,
operator|!
name|constrain_operands
argument_list|(
name|INSN_CODE
argument_list|(
name|object
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|)
operator|)
condition|)
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|object
argument_list|)
decl_stmt|;
comment|/* Perhaps we couldn't recognize the insn because there were 	     extra CLOBBERs at the end.  If so, try to re-recognize 	     without the last CLOBBER (later iterations will cause each of 	     them to be eliminated, in turn).  But don't do this if we 	     have an ASM_OPERAND.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|)
operator|==
name|CLOBBER
operator|&&
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|object
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|rtx
name|newpat
decl_stmt|;
if|if
condition|(
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
operator|==
literal|2
condition|)
name|newpat
operator|=
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|j
decl_stmt|;
name|newpat
operator|=
name|gen_rtx
argument_list|(
name|PARALLEL
argument_list|,
name|VOIDmode
argument_list|,
name|gen_rtvec
argument_list|(
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|)
condition|;
name|j
operator|++
control|)
name|XVECEXP
argument_list|(
name|newpat
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
operator|=
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
comment|/* Add a new change to this group to replace the pattern 		  with this new pattern.  Then consider this change 		  as having succeeded.  The change we added will 		  cause the entire call to fail if things remain invalid.  		  Note that this can lose if a later change than the one 		  we are processing specified&XVECEXP (PATTERN (object), 0, X) 		  but this shouldn't occur.  */
name|validate_change
argument_list|(
name|object
argument_list|,
operator|&
name|PATTERN
argument_list|(
name|object
argument_list|)
argument_list|,
name|newpat
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|CLOBBER
condition|)
comment|/* If this insn is a CLOBBER or USE, it is always valid, but is 	       never recognized.  */
continue|continue;
else|else
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
name|num_changes
condition|)
block|{
name|num_changes
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
name|cancel_changes
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return the number of changes so far in the current group.   */
end_comment

begin_function
name|int
name|num_validated_changes
parameter_list|()
block|{
return|return
name|num_changes
return|;
block|}
end_function

begin_comment
comment|/* Retract the changes numbered NUM and up.  */
end_comment

begin_function
name|void
name|cancel_changes
parameter_list|(
name|num
parameter_list|)
name|int
name|num
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
comment|/* Back out all the changes.  Do this in the opposite order in which      they were made.  */
for|for
control|(
name|i
operator|=
name|num_changes
operator|-
literal|1
init|;
name|i
operator|>=
name|num
condition|;
name|i
operator|--
control|)
block|{
operator|*
name|change_locs
index|[
name|i
index|]
operator|=
name|change_olds
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|change_objects
index|[
name|i
index|]
operator|&&
name|GET_CODE
argument_list|(
name|change_objects
index|[
name|i
index|]
argument_list|)
operator|!=
name|MEM
condition|)
name|INSN_CODE
argument_list|(
name|change_objects
index|[
name|i
index|]
argument_list|)
operator|=
name|change_old_codes
index|[
name|i
index|]
expr_stmt|;
block|}
name|num_changes
operator|=
name|num
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Replace every occurrence of FROM in X with TO.  Mark each change with    validate_change passing OBJECT.  */
end_comment

begin_function
specifier|static
name|void
name|validate_replace_rtx_1
parameter_list|(
name|loc
parameter_list|,
name|from
parameter_list|,
name|to
parameter_list|,
name|object
parameter_list|)
name|rtx
modifier|*
name|loc
decl_stmt|;
name|rtx
name|from
decl_stmt|,
name|to
decl_stmt|,
name|object
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
specifier|register
name|rtx
name|x
init|=
operator|*
name|loc
decl_stmt|;
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
comment|/* X matches FROM if it is the same rtx or they are both referring to the      same register in the same mode.  Avoid calling rtx_equal_p unless the      operands look similar.  */
if|if
condition|(
name|x
operator|==
name|from
operator|||
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|REG
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|from
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|==
name|REGNO
argument_list|(
name|from
argument_list|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|GET_CODE
argument_list|(
name|from
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|from
argument_list|)
operator|&&
name|rtx_equal_p
argument_list|(
name|x
argument_list|,
name|from
argument_list|)
operator|)
condition|)
block|{
name|validate_change
argument_list|(
name|object
argument_list|,
name|loc
argument_list|,
name|to
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* For commutative or comparison operations, try replacing each argument      separately and seeing if we made any changes.  If so, put a constant      argument last.*/
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'<'
operator|||
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'c'
condition|)
block|{
name|int
name|prev_changes
init|=
name|num_changes
decl_stmt|;
name|validate_replace_rtx_1
argument_list|(
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|from
argument_list|,
name|to
argument_list|,
name|object
argument_list|)
expr_stmt|;
name|validate_replace_rtx_1
argument_list|(
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|from
argument_list|,
name|to
argument_list|,
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev_changes
operator|!=
name|num_changes
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|validate_change
argument_list|(
name|object
argument_list|,
name|loc
argument_list|,
name|gen_rtx
argument_list|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'c'
condition|?
name|code
else|:
name|swap_condition
argument_list|(
name|code
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|x
operator|=
operator|*
name|loc
expr_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PLUS
case|:
comment|/* If we have have a PLUS whose second operand is now a CONST_INT, use 	 plus_constant to try to simplify it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|==
name|to
condition|)
name|validate_change
argument_list|(
name|object
argument_list|,
name|loc
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
case|case
name|ZERO_EXTEND
case|:
case|case
name|SIGN_EXTEND
case|:
comment|/* In these cases, the operation to be performed depends on the mode 	 of the operand.  If we are replacing the operand with a VOIDmode 	 constant, we lose the information.  So try to simplify the operation 	 in that case.  If it fails, substitute in something that we know 	 won't be recognized.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
operator|==
name|VOIDmode
operator|&&
operator|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|from
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|REG
operator|&&
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|from
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REGNO
argument_list|(
name|from
argument_list|)
operator|)
operator|)
condition|)
block|{
name|rtx
name|new
init|=
name|simplify_unary_operation
argument_list|(
name|code
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|to
argument_list|,
name|GET_MODE
argument_list|(
name|from
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|new
operator|==
literal|0
condition|)
name|new
operator|=
name|gen_rtx
argument_list|(
name|CLOBBER
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|validate_change
argument_list|(
name|object
argument_list|,
name|loc
argument_list|,
name|new
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|SUBREG
case|:
comment|/* If we have a SUBREG of a register that we are replacing and we are 	 replacing it with a MEM, make a new MEM and try replacing the 	 SUBREG with it.  Don't do this if the MEM has a mode-dependent address 	 or if we would be widening it.  */
if|if
condition|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
operator|==
name|from
operator|&&
name|GET_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|mode_dependent_address_p
argument_list|(
name|XEXP
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|!
name|MEM_VOLATILE_P
argument_list|(
name|to
argument_list|)
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|<=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|offset
init|=
name|SUBREG_WORD
argument_list|(
name|x
argument_list|)
operator|*
name|UNITS_PER_WORD
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|rtx
name|new
decl_stmt|;
if|#
directive|if
name|BYTES_BIG_ENDIAN
name|offset
operator|+=
operator|(
name|MIN
argument_list|(
name|UNITS_PER_WORD
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|-
name|MIN
argument_list|(
name|UNITS_PER_WORD
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|)
operator|)
expr_stmt|;
endif|#
directive|endif
name|new
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|mode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|new
argument_list|)
operator|=
name|MEM_VOLATILE_P
argument_list|(
name|to
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|new
argument_list|)
operator|=
name|RTX_UNCHANGING_P
argument_list|(
name|to
argument_list|)
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|new
argument_list|)
operator|=
name|MEM_IN_STRUCT_P
argument_list|(
name|to
argument_list|)
expr_stmt|;
name|validate_change
argument_list|(
name|object
argument_list|,
name|loc
argument_list|,
name|new
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|ZERO_EXTRACT
case|:
case|case
name|SIGN_EXTRACT
case|:
comment|/* If we are replacing a register with memory, try to change the memory 	 to be the mode required for memory in extract operations (this isn't 	 likely to be an insertion operation; if it was, nothing bad will 	 happen, we might just fail in some cases).  */
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|from
operator|&&
name|GET_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|!
name|mode_dependent_address_p
argument_list|(
name|XEXP
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|!
name|MEM_VOLATILE_P
argument_list|(
name|to
argument_list|)
condition|)
block|{
name|enum
name|machine_mode
name|wanted_mode
init|=
name|VOIDmode
decl_stmt|;
name|enum
name|machine_mode
name|is_mode
init|=
name|GET_MODE
argument_list|(
name|to
argument_list|)
decl_stmt|;
name|int
name|width
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|pos
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_extzv
if|if
condition|(
name|code
operator|==
name|ZERO_EXTRACT
condition|)
name|wanted_mode
operator|=
name|insn_operand_mode
index|[
operator|(
name|int
operator|)
name|CODE_FOR_extzv
index|]
index|[
literal|1
index|]
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_extv
if|if
condition|(
name|code
operator|==
name|SIGN_EXTRACT
condition|)
name|wanted_mode
operator|=
name|insn_operand_mode
index|[
operator|(
name|int
operator|)
name|CODE_FOR_extv
index|]
index|[
literal|1
index|]
expr_stmt|;
endif|#
directive|endif
comment|/* If we have a narrower mode, we can do something.  */
if|if
condition|(
name|wanted_mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|wanted_mode
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|is_mode
argument_list|)
condition|)
block|{
name|int
name|offset
init|=
name|pos
operator|/
name|BITS_PER_UNIT
decl_stmt|;
name|rtx
name|newmem
decl_stmt|;
comment|/* If the bytes and bits are counted differently, we 		     must adjust the offset.  */
if|#
directive|if
name|BYTES_BIG_ENDIAN
operator|!=
name|BITS_BIG_ENDIAN
name|offset
operator|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|is_mode
argument_list|)
operator|-
name|GET_MODE_SIZE
argument_list|(
name|wanted_mode
argument_list|)
operator|-
name|offset
operator|)
expr_stmt|;
endif|#
directive|endif
name|pos
operator|%=
name|GET_MODE_BITSIZE
argument_list|(
name|wanted_mode
argument_list|)
expr_stmt|;
name|newmem
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|wanted_mode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|newmem
argument_list|)
operator|=
name|RTX_UNCHANGING_P
argument_list|(
name|to
argument_list|)
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|newmem
argument_list|)
operator|=
name|MEM_VOLATILE_P
argument_list|(
name|to
argument_list|)
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|newmem
argument_list|)
operator|=
name|MEM_IN_STRUCT_P
argument_list|(
name|to
argument_list|)
expr_stmt|;
name|validate_change
argument_list|(
name|object
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|pos
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|validate_change
argument_list|(
name|object
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|newmem
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|validate_replace_rtx_1
argument_list|(
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|from
argument_list|,
name|to
argument_list|,
name|object
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|validate_replace_rtx_1
argument_list|(
operator|&
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|from
argument_list|,
name|to
argument_list|,
name|object
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Try replacing every occurrence of FROM in INSN with TO.  After all    changes have been made, validate by seeing if INSN is still valid.  */
end_comment

begin_function
name|int
name|validate_replace_rtx
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|from
decl_stmt|,
name|to
decl_stmt|,
name|insn
decl_stmt|;
block|{
name|validate_replace_rtx_1
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|from
argument_list|,
name|to
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return
name|apply_change_group
argument_list|()
return|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_cc0
end_ifdef

begin_comment
comment|/* Return 1 if the insn using CC0 set by INSN does not contain    any ordered tests applied to the condition codes.    EQ and NE tests do not count.  */
end_comment

begin_function
name|int
name|next_insn_tests_no_inequality
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
specifier|register
name|rtx
name|next
init|=
name|next_cc0_user
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* If there is no next insn, we have to take the conservative choice.  */
if|if
condition|(
name|next
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|JUMP_INSN
operator|||
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|CALL_INSN
operator|)
operator|&&
operator|!
name|inequality_comparisons_p
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* This is useless since the insn that sets the cc's 	  must be followed immediately by the use of them.  */
end_comment

begin_comment
comment|/* Return 1 if the CC value set up by INSN is not used.  */
end_comment

begin_endif
unit|int next_insns_test_no_inequality (insn)      rtx insn; {   register rtx next = NEXT_INSN (insn);    for (; next != 0; next = NEXT_INSN (next))     {       if (GET_CODE (next) == CODE_LABEL 	  || GET_CODE (next) == BARRIER) 	return 1;       if (GET_CODE (next) == NOTE) 	continue;       if (inequality_comparisons_p (PATTERN (next))) 	return 0;       if (sets_cc0_p (PATTERN (next)) == 1) 	return 1;       if (! reg_mentioned_p (cc0_rtx, PATTERN (next))) 	return 1;     }   return 1; }
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* This is used by find_single_use to locate an rtx that contains exactly one    use of DEST, which is typically either a REG or CC0.  It returns a    pointer to the innermost rtx expression containing DEST.  Appearances of    DEST that are being used to totally replace it are not counted.  */
end_comment

begin_function
specifier|static
name|rtx
modifier|*
name|find_single_use_1
parameter_list|(
name|dest
parameter_list|,
name|loc
parameter_list|)
name|rtx
name|dest
decl_stmt|;
name|rtx
modifier|*
name|loc
decl_stmt|;
block|{
name|rtx
name|x
init|=
operator|*
name|loc
decl_stmt|;
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|rtx
modifier|*
name|result
init|=
literal|0
decl_stmt|;
name|rtx
modifier|*
name|this_result
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|fmt
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONST_INT
case|:
case|case
name|CONST
case|:
case|case
name|LABEL_REF
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CLOBBER
case|:
return|return
literal|0
return|;
case|case
name|SET
case|:
comment|/* If the destination is anything other than CC0, PC, a REG or a SUBREG 	 of a REG that occupies all of the REG, the insn uses DEST if 	 it is mentioned in the destination or the source.  Otherwise, we 	 need just check the source.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|CC0
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|PC
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|REG
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|+
operator|(
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
operator|==
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|+
operator|(
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
operator|)
operator|)
condition|)
break|break;
return|return
name|find_single_use_1
argument_list|(
name|dest
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
return|;
case|case
name|MEM
case|:
case|case
name|SUBREG
case|:
return|return
name|find_single_use_1
argument_list|(
name|dest
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
comment|/* If it wasn't one of the common cases above, check each expression and      vector of this code.  Look for a unique usage of DEST.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
if|if
condition|(
name|dest
operator|==
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|dest
argument_list|)
operator|==
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
operator|)
condition|)
name|this_result
operator|=
name|loc
expr_stmt|;
else|else
name|this_result
operator|=
name|find_single_use_1
argument_list|(
name|dest
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
literal|0
condition|)
name|result
operator|=
name|this_result
expr_stmt|;
elseif|else
if|if
condition|(
name|this_result
condition|)
comment|/* Duplicate usage.  */
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
if|if
condition|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
operator|==
name|dest
operator|||
operator|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
operator|==
name|REGNO
argument_list|(
name|dest
argument_list|)
operator|)
condition|)
name|this_result
operator|=
name|loc
expr_stmt|;
else|else
name|this_result
operator|=
name|find_single_use_1
argument_list|(
name|dest
argument_list|,
operator|&
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
literal|0
condition|)
name|result
operator|=
name|this_result
expr_stmt|;
elseif|else
if|if
condition|(
name|this_result
condition|)
return|return
literal|0
return|;
block|}
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* See if DEST, produced in INSN, is used only a single time in the    sequel.  If so, return a pointer to the innermost rtx expression in which    it is used.     If PLOC is non-zero, *PLOC is set to the insn containing the single use.     This routine will return usually zero either before flow is called (because    there will be no LOG_LINKS notes) or after reload (because the REG_DEAD    note can't be trusted).     If DEST is cc0_rtx, we look only at the next insn.  In that case, we don't    care about REG_DEAD notes or LOG_LINKS.     Otherwise, we find the single use by finding an insn that has a    LOG_LINKS pointing at INSN and has a REG_DEAD note for DEST.  If DEST is    only referenced once in that insn, we know that it must be the first    and last insn referencing DEST.  */
end_comment

begin_function
name|rtx
modifier|*
name|find_single_use
parameter_list|(
name|dest
parameter_list|,
name|insn
parameter_list|,
name|ploc
parameter_list|)
name|rtx
name|dest
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|rtx
modifier|*
name|ploc
decl_stmt|;
block|{
name|rtx
name|next
decl_stmt|;
name|rtx
modifier|*
name|result
decl_stmt|;
name|rtx
name|link
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
if|if
condition|(
name|dest
operator|==
name|cc0_rtx
condition|)
block|{
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|==
literal|0
operator|||
operator|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|!=
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|!=
name|JUMP_INSN
operator|)
condition|)
return|return
literal|0
return|;
name|result
operator|=
name|find_single_use_1
argument_list|(
name|dest
argument_list|,
operator|&
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|&&
name|ploc
condition|)
operator|*
name|ploc
operator|=
name|next
expr_stmt|;
return|return
name|result
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|reload_completed
operator|||
name|reload_in_progress
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
for|for
control|(
name|next
operator|=
name|next_nonnote_insn
argument_list|(
name|insn
argument_list|)
init|;
name|next
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|!=
name|CODE_LABEL
condition|;
name|next
operator|=
name|next_nonnote_insn
argument_list|(
name|next
argument_list|)
control|)
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
literal|'i'
operator|&&
name|dead_or_set_p
argument_list|(
name|next
argument_list|,
name|dest
argument_list|)
condition|)
block|{
for|for
control|(
name|link
operator|=
name|LOG_LINKS
argument_list|(
name|next
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
operator|==
name|insn
condition|)
break|break;
if|if
condition|(
name|link
condition|)
block|{
name|result
operator|=
name|find_single_use_1
argument_list|(
name|dest
argument_list|,
operator|&
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ploc
condition|)
operator|*
name|ploc
operator|=
name|next
expr_stmt|;
return|return
name|result
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if OP is a valid general operand for machine mode MODE.    This is either a register reference, a memory reference,    or a constant.  In the case of a memory reference, the address    is checked for general validity for the target machine.     Register and memory references must have mode MODE in order to be valid,    but some constants have no machine mode and are valid for any mode.     If MODE is VOIDmode, OP is checked for validity for whatever mode    it has.     The main use of this function is as a predicate in match_operand    expressions in the machine description.     For an explanation of this function's behavior for registers of    class NO_REGS, see the comment for `register_operand'.  */
end_comment

begin_function
name|int
name|general_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
specifier|register
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
name|int
name|mode_altering_drug
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|mode
operator|=
name|GET_MODE
argument_list|(
name|op
argument_list|)
expr_stmt|;
comment|/* Don't accept CONST_INT or anything similar      if the caller wants something floating.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
operator|&&
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_INT
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_PARTIAL_INT
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
condition|)
return|return
operator|(
operator|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
operator|||
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|mode
operator|)
ifdef|#
directive|ifdef
name|LEGITIMATE_PIC_OPERAND_P
operator|&&
operator|(
operator|!
name|flag_pic
operator|||
name|LEGITIMATE_PIC_OPERAND_P
argument_list|(
name|op
argument_list|)
operator|)
endif|#
directive|endif
operator|&&
name|LEGITIMATE_CONSTANT_P
argument_list|(
name|op
argument_list|)
operator|)
return|;
comment|/* Except for certain constants with VOIDmode, already checked for,      OP's mode must match MODE if MODE specifies a mode.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|code
operator|==
name|SUBREG
condition|)
block|{
ifdef|#
directive|ifdef
name|INSN_SCHEDULING
comment|/* On machines that have insn scheduling, we want all memory 	 reference to be explicit, so outlaw paradoxical SUBREGs.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* No longer needed, since (SUBREG (MEM...)) 	 will load the MEM into a reload reg in the MEM's own mode.  */
block|mode_altering_drug = 1;
endif|#
directive|endif
block|}
if|if
condition|(
name|code
operator|==
name|REG
condition|)
comment|/* A register whose class is NO_REGS is not a general operand.  */
return|return
operator|(
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
name|REGNO_REG_CLASS
argument_list|(
name|REGNO
argument_list|(
name|op
argument_list|)
argument_list|)
operator|!=
name|NO_REGS
operator|)
return|;
if|if
condition|(
name|code
operator|==
name|MEM
condition|)
block|{
specifier|register
name|rtx
name|y
init|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|volatile_ok
operator|&&
name|MEM_VOLATILE_P
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Use the mem's mode, since it will be reloaded thus.  */
name|mode
operator|=
name|GET_MODE
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|GO_IF_LEGITIMATE_ADDRESS
argument_list|(
name|mode
argument_list|,
name|y
argument_list|,
name|win
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
name|win
label|:
if|if
condition|(
name|mode_altering_drug
condition|)
return|return
operator|!
name|mode_dependent_address_p
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if OP is a valid memory address for a memory reference    of mode MODE.     The main use of this function is as a predicate in match_operand    expressions in the machine description.  */
end_comment

begin_function
name|int
name|address_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
name|memory_address_p
argument_list|(
name|mode
argument_list|,
name|op
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a register reference of mode MODE.    If MODE is VOIDmode, accept a register in any mode.     The main use of this function is as a predicate in match_operand    expressions in the machine description.     As a special exception, registers whose class is NO_REGS are    not accepted by `register_operand'.  The reason for this change    is to allow the representation of special architecture artifacts    (such as a condition code register) without extending the rtl    definitions.  Since registers of class NO_REGS cannot be used    as registers in any case where register classes are examined,    it is most consistent to keep this function from accepting them.  */
end_comment

begin_function
name|int
name|register_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
comment|/* Before reload, we can allow (SUBREG (MEM...)) as a register operand 	 because it is guaranteed to be reloaded into one. 	 Just make sure the MEM is valid in itself. 	 (Ideally, (SUBREG (MEM)...) should not exist after reload, 	 but currently it does result from (SUBREG (REG)...) where the 	 reg went on the stack.)  */
if|if
condition|(
operator|!
name|reload_completed
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
return|return
name|general_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
comment|/* We don't consider registers whose class is NO_REGS      to be a register operand.  */
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
name|REGNO_REG_CLASS
argument_list|(
name|REGNO
argument_list|(
name|op
argument_list|)
argument_list|)
operator|!=
name|NO_REGS
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP should match a MATCH_SCRATCH, i.e., if it is a SCRATCH    or a hard register.  */
end_comment

begin_function
name|int
name|scratch_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|mode
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SCRATCH
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a valid immediate operand for mode MODE.     The main use of this function is as a predicate in match_operand    expressions in the machine description.  */
end_comment

begin_function
name|int
name|immediate_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
comment|/* Don't accept CONST_INT or anything similar      if the caller wants something floating.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
operator|&&
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_INT
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_PARTIAL_INT
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
operator|&&
operator|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|mode
operator|||
name|mode
operator|==
name|VOIDmode
operator|||
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
operator|)
ifdef|#
directive|ifdef
name|LEGITIMATE_PIC_OPERAND_P
operator|&&
operator|(
operator|!
name|flag_pic
operator|||
name|LEGITIMATE_PIC_OPERAND_P
argument_list|(
name|op
argument_list|)
operator|)
endif|#
directive|endif
operator|&&
name|LEGITIMATE_CONSTANT_P
argument_list|(
name|op
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if OP is an operand that is a CONST_INT.  */
end_comment

begin_function
name|int
name|const_int_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if OP is an operand that is a constant integer or constant    floating-point number.  */
end_comment

begin_function
name|int
name|const_double_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
comment|/* Don't accept CONST_INT or anything similar      if the caller wants something floating.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
operator|&&
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_INT
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_PARTIAL_INT
condition|)
return|return
literal|0
return|;
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|&&
operator|(
name|mode
operator|==
name|VOIDmode
operator|||
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|mode
operator|||
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a general operand that is not an immediate operand.  */
end_comment

begin_function
name|int
name|nonimmediate_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|general_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|&&
operator|!
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a register reference or immediate value of mode MODE.  */
end_comment

begin_function
name|int
name|nonmemory_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
condition|)
block|{
comment|/* Don't accept CONST_INT or anything similar 	 if the caller wants something floating.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
operator|&&
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_INT
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_PARTIAL_INT
condition|)
return|return
literal|0
return|;
return|return
operator|(
operator|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
operator|||
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|mode
operator|)
ifdef|#
directive|ifdef
name|LEGITIMATE_PIC_OPERAND_P
operator|&&
operator|(
operator|!
name|flag_pic
operator|||
name|LEGITIMATE_PIC_OPERAND_P
argument_list|(
name|op
argument_list|)
operator|)
endif|#
directive|endif
operator|&&
name|LEGITIMATE_CONSTANT_P
argument_list|(
name|op
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
comment|/* Before reload, we can allow (SUBREG (MEM...)) as a register operand 	 because it is guaranteed to be reloaded into one. 	 Just make sure the MEM is valid in itself. 	 (Ideally, (SUBREG (MEM)...) should not exist after reload, 	 but currently it does result from (SUBREG (REG)...) where the 	 reg went on the stack.)  */
if|if
condition|(
operator|!
name|reload_completed
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
return|return
name|general_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
comment|/* We don't consider registers whose class is NO_REGS      to be a register operand.  */
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
name|REGNO_REG_CLASS
argument_list|(
name|REGNO
argument_list|(
name|op
argument_list|)
argument_list|)
operator|!=
name|NO_REGS
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a valid operand that stands for pushing a    value of mode MODE onto the stack.     The main use of this function is as a predicate in match_operand    expressions in the machine description.  */
end_comment

begin_function
name|int
name|push_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
condition|)
return|return
literal|0
return|;
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|STACK_PUSH_CODE
condition|)
return|return
literal|0
return|;
return|return
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
operator|==
name|stack_pointer_rtx
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if ADDR is a valid memory address for mode MODE.  */
end_comment

begin_function
name|int
name|memory_address_p
parameter_list|(
name|mode
parameter_list|,
name|addr
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
specifier|register
name|rtx
name|addr
decl_stmt|;
block|{
name|GO_IF_LEGITIMATE_ADDRESS
argument_list|(
name|mode
argument_list|,
name|addr
argument_list|,
name|win
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|win
label|:
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a valid memory reference with mode MODE,    including a valid address.     The main use of this function is as a predicate in match_operand    expressions in the machine description.  */
end_comment

begin_function
name|int
name|memory_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|rtx
name|inner
decl_stmt|;
if|if
condition|(
operator|!
name|reload_completed
condition|)
comment|/* Note that no SUBREG is a memory operand before end of reload pass,        because (SUBREG (MEM...)) forces reloading into a register.  */
return|return
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|&&
name|general_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
condition|)
return|return
literal|0
return|;
name|inner
operator|=
name|op
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|SUBREG
condition|)
name|inner
operator|=
name|SUBREG_REG
argument_list|(
name|inner
argument_list|)
expr_stmt|;
return|return
operator|(
name|GET_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|MEM
operator|&&
name|general_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a valid indirect memory reference with mode MODE;    that is, a memory reference whose address is a general_operand.  */
end_comment

begin_function
name|int
name|indirect_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
comment|/* Before reload, a SUBREG isn't in memory (see memory_operand, above).  */
if|if
condition|(
operator|!
name|reload_completed
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
block|{
specifier|register
name|int
name|offset
init|=
name|SUBREG_WORD
argument_list|(
name|op
argument_list|)
operator|*
name|UNITS_PER_WORD
decl_stmt|;
name|rtx
name|inner
init|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|#
directive|if
name|BYTES_BIG_ENDIAN
name|offset
operator|-=
operator|(
name|MIN
argument_list|(
name|UNITS_PER_WORD
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|)
argument_list|)
operator|-
name|MIN
argument_list|(
name|UNITS_PER_WORD
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|inner
argument_list|)
argument_list|)
argument_list|)
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* The only way that we can have a general_operand as the resulting 	 address is if OFFSET is zero and the address already is an operand 	 or if the address is (plus Y (const_int -OFFSET)) and Y is an 	 operand.  */
return|return
operator|(
operator|(
name|offset
operator|==
literal|0
operator|&&
name|general_operand
argument_list|(
name|XEXP
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
operator|-
name|offset
operator|&&
name|general_operand
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|)
operator|)
operator|)
return|;
block|}
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|&&
name|memory_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|&&
name|general_operand
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if this is a comparison operator.  This allows the use of    MATCH_OPERATOR to recognize all the branch insns.  */
end_comment

begin_function
name|int
name|comparison_operator
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|mode
operator|==
name|VOIDmode
operator|||
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|mode
operator|)
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
literal|'<'
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If BODY is an insn body that uses ASM_OPERANDS,    return the number of operands (both input and output) in the insn.    Otherwise return -1.  */
end_comment

begin_function
name|int
name|asm_noperands
parameter_list|(
name|body
parameter_list|)
name|rtx
name|body
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|ASM_OPERANDS
condition|)
comment|/* No output operands: return number of input operands.  */
return|return
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|body
argument_list|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|ASM_OPERANDS
condition|)
comment|/* Single output operand: BODY is (set OUTPUT (asm_operands ...)).  */
return|return
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
operator|+
literal|1
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|ASM_OPERANDS
condition|)
block|{
comment|/* Multiple output operands, or 1 output plus some clobbers: 	 body is [(set OUTPUT (asm_operands ...))... (clobber (reg ...))...].  */
name|int
name|i
decl_stmt|;
name|int
name|n_sets
decl_stmt|;
comment|/* Count backwards through CLOBBERs to determine number of SETs.  */
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
operator|-
literal|1
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
break|break;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
operator|-
literal|1
argument_list|)
argument_list|)
operator|!=
name|CLOBBER
condition|)
return|return
operator|-
literal|1
return|;
block|}
comment|/* N_SETS is now number of output operands.  */
name|n_sets
operator|=
name|i
expr_stmt|;
comment|/* Verify that all the SETs we have 	 came from a single original asm_operands insn 	 (so that invalid combinations are blocked).  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_sets
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|elt
init|=
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|elt
argument_list|)
operator|!=
name|SET
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|ASM_OPERANDS
condition|)
return|return
operator|-
literal|1
return|;
comment|/* If these ASM_OPERANDS rtx's came from different original insns 	     then they aren't allowed together.  */
if|if
condition|(
name|ASM_OPERANDS_INPUT_VEC
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|ASM_OPERANDS_INPUT_VEC
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
return|return
operator|(
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|+
name|n_sets
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ASM_OPERANDS
condition|)
block|{
comment|/* 0 outputs, but some clobbers: 	 body is [(asm_operands ...) (clobber (reg ...))...].  */
name|int
name|i
decl_stmt|;
comment|/* Make sure all the other parallel things really are clobbers.  */
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|!=
name|CLOBBER
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
else|else
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Assuming BODY is an insn body that uses ASM_OPERANDS,    copy its operands (both input and output) into the vector OPERANDS,    the locations of the operands within the insn into the vector OPERAND_LOCS,    and the constraints for the operands into CONSTRAINTS.    Write the modes of the operands into MODES.    Return the assembler-template.     If MODES, OPERAND_LOCS, CONSTRAINTS or OPERANDS is 0,    we don't store that info.  */
end_comment

begin_function
name|char
modifier|*
name|decode_asm_operands
parameter_list|(
name|body
parameter_list|,
name|operands
parameter_list|,
name|operand_locs
parameter_list|,
name|constraints
parameter_list|,
name|modes
parameter_list|)
name|rtx
name|body
decl_stmt|;
name|rtx
modifier|*
name|operands
decl_stmt|;
name|rtx
modifier|*
modifier|*
name|operand_locs
decl_stmt|;
name|char
modifier|*
modifier|*
name|constraints
decl_stmt|;
name|enum
name|machine_mode
modifier|*
name|modes
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|noperands
decl_stmt|;
name|char
modifier|*
name|template
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|ASM_OPERANDS
condition|)
block|{
name|rtx
name|asmop
init|=
name|SET_SRC
argument_list|(
name|body
argument_list|)
decl_stmt|;
comment|/* Single output operand: BODY is (set OUTPUT (asm_operands ....)).  */
name|noperands
operator|=
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|asmop
argument_list|)
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|noperands
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|operand_locs
condition|)
name|operand_locs
index|[
name|i
index|]
operator|=
operator|&
name|ASM_OPERANDS_INPUT
argument_list|(
name|asmop
argument_list|,
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|operands
condition|)
name|operands
index|[
name|i
index|]
operator|=
name|ASM_OPERANDS_INPUT
argument_list|(
name|asmop
argument_list|,
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|constraints
condition|)
name|constraints
index|[
name|i
index|]
operator|=
name|ASM_OPERANDS_INPUT_CONSTRAINT
argument_list|(
name|asmop
argument_list|,
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|modes
condition|)
name|modes
index|[
name|i
index|]
operator|=
name|ASM_OPERANDS_INPUT_MODE
argument_list|(
name|asmop
argument_list|,
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* The output is in the SET. 	 Its constraint is in the ASM_OPERANDS itself.  */
if|if
condition|(
name|operands
condition|)
name|operands
index|[
literal|0
index|]
operator|=
name|SET_DEST
argument_list|(
name|body
argument_list|)
expr_stmt|;
if|if
condition|(
name|operand_locs
condition|)
name|operand_locs
index|[
literal|0
index|]
operator|=
operator|&
name|SET_DEST
argument_list|(
name|body
argument_list|)
expr_stmt|;
if|if
condition|(
name|constraints
condition|)
name|constraints
index|[
literal|0
index|]
operator|=
name|ASM_OPERANDS_OUTPUT_CONSTRAINT
argument_list|(
name|asmop
argument_list|)
expr_stmt|;
if|if
condition|(
name|modes
condition|)
name|modes
index|[
literal|0
index|]
operator|=
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
expr_stmt|;
name|template
operator|=
name|ASM_OPERANDS_TEMPLATE
argument_list|(
name|asmop
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|ASM_OPERANDS
condition|)
block|{
name|rtx
name|asmop
init|=
name|body
decl_stmt|;
comment|/* No output operands: BODY is (asm_operands ....).  */
name|noperands
operator|=
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|asmop
argument_list|)
expr_stmt|;
comment|/* The input operands are found in the 1st element vector.  */
comment|/* Constraints for inputs are in the 2nd element vector.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|noperands
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|operand_locs
condition|)
name|operand_locs
index|[
name|i
index|]
operator|=
operator|&
name|ASM_OPERANDS_INPUT
argument_list|(
name|asmop
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|operands
condition|)
name|operands
index|[
name|i
index|]
operator|=
name|ASM_OPERANDS_INPUT
argument_list|(
name|asmop
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|constraints
condition|)
name|constraints
index|[
name|i
index|]
operator|=
name|ASM_OPERANDS_INPUT_CONSTRAINT
argument_list|(
name|asmop
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|modes
condition|)
name|modes
index|[
name|i
index|]
operator|=
name|ASM_OPERANDS_INPUT_MODE
argument_list|(
name|asmop
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|template
operator|=
name|ASM_OPERANDS_TEMPLATE
argument_list|(
name|asmop
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
block|{
name|rtx
name|asmop
init|=
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|nparallel
init|=
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* Includes CLOBBERs.  */
name|int
name|nin
init|=
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|asmop
argument_list|)
decl_stmt|;
name|int
name|nout
init|=
literal|0
decl_stmt|;
comment|/* Does not include CLOBBERs.  */
comment|/* At least one output, plus some CLOBBERs.  */
comment|/* The outputs are in the SETs. 	 Their constraints are in the ASM_OPERANDS itself.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nparallel
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
break|break;
comment|/* Past last SET */
if|if
condition|(
name|operands
condition|)
name|operands
index|[
name|i
index|]
operator|=
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|operand_locs
condition|)
name|operand_locs
index|[
name|i
index|]
operator|=
operator|&
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|constraints
condition|)
name|constraints
index|[
name|i
index|]
operator|=
name|XSTR
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|modes
condition|)
name|modes
index|[
name|i
index|]
operator|=
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|nout
operator|++
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nin
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|operand_locs
condition|)
name|operand_locs
index|[
name|i
operator|+
name|nout
index|]
operator|=
operator|&
name|ASM_OPERANDS_INPUT
argument_list|(
name|asmop
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|operands
condition|)
name|operands
index|[
name|i
operator|+
name|nout
index|]
operator|=
name|ASM_OPERANDS_INPUT
argument_list|(
name|asmop
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|constraints
condition|)
name|constraints
index|[
name|i
operator|+
name|nout
index|]
operator|=
name|ASM_OPERANDS_INPUT_CONSTRAINT
argument_list|(
name|asmop
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|modes
condition|)
name|modes
index|[
name|i
operator|+
name|nout
index|]
operator|=
name|ASM_OPERANDS_INPUT_MODE
argument_list|(
name|asmop
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|template
operator|=
name|ASM_OPERANDS_TEMPLATE
argument_list|(
name|asmop
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ASM_OPERANDS
condition|)
block|{
comment|/* No outputs, but some CLOBBERs.  */
name|rtx
name|asmop
init|=
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|nin
init|=
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|asmop
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nin
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|operand_locs
condition|)
name|operand_locs
index|[
name|i
index|]
operator|=
operator|&
name|ASM_OPERANDS_INPUT
argument_list|(
name|asmop
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|operands
condition|)
name|operands
index|[
name|i
index|]
operator|=
name|ASM_OPERANDS_INPUT
argument_list|(
name|asmop
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|constraints
condition|)
name|constraints
index|[
name|i
index|]
operator|=
name|ASM_OPERANDS_INPUT_CONSTRAINT
argument_list|(
name|asmop
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|modes
condition|)
name|modes
index|[
name|i
index|]
operator|=
name|ASM_OPERANDS_INPUT_MODE
argument_list|(
name|asmop
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|template
operator|=
name|ASM_OPERANDS_TEMPLATE
argument_list|(
name|asmop
argument_list|)
expr_stmt|;
block|}
return|return
name|template
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given an rtx *P, if it is a sum containing an integer constant term,    return the location (type rtx *) of the pointer to that constant term.    Otherwise, return a null pointer.  */
end_comment

begin_function
specifier|static
name|rtx
modifier|*
name|find_constant_term_loc
parameter_list|(
name|p
parameter_list|)
name|rtx
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|rtx
modifier|*
name|tem
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
operator|*
name|p
argument_list|)
decl_stmt|;
comment|/* If *P IS such a constant term, P is its location.  */
if|if
condition|(
name|code
operator|==
name|CONST_INT
operator|||
name|code
operator|==
name|SYMBOL_REF
operator|||
name|code
operator|==
name|LABEL_REF
operator|||
name|code
operator|==
name|CONST
condition|)
return|return
name|p
return|;
comment|/* Otherwise, if not a sum, it has no constant term.  */
if|if
condition|(
name|GET_CODE
argument_list|(
operator|*
name|p
argument_list|)
operator|!=
name|PLUS
condition|)
return|return
literal|0
return|;
comment|/* If one of the summands is constant, return its location.  */
if|if
condition|(
name|XEXP
argument_list|(
operator|*
name|p
argument_list|,
literal|0
argument_list|)
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
operator|*
name|p
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|XEXP
argument_list|(
operator|*
name|p
argument_list|,
literal|1
argument_list|)
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
operator|*
name|p
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|p
return|;
comment|/* Otherwise, check each summand for containing a constant term.  */
if|if
condition|(
name|XEXP
argument_list|(
operator|*
name|p
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|tem
operator|=
name|find_constant_term_loc
argument_list|(
operator|&
name|XEXP
argument_list|(
operator|*
name|p
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|!=
literal|0
condition|)
return|return
name|tem
return|;
block|}
if|if
condition|(
name|XEXP
argument_list|(
operator|*
name|p
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|tem
operator|=
name|find_constant_term_loc
argument_list|(
operator|&
name|XEXP
argument_list|(
operator|*
name|p
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|!=
literal|0
condition|)
return|return
name|tem
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if OP is a memory reference    whose address contains no side effects    and remains valid after the addition    of a positive integer less than the    size of the object being referenced.     We assume that the original address is valid and do not check it.     This uses strict_memory_address_p as a subroutine, so    don't use it before reload.  */
end_comment

begin_function
name|int
name|offsettable_memref_p
parameter_list|(
name|op
parameter_list|)
name|rtx
name|op
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|)
operator|&&
name|offsettable_address_p
argument_list|(
literal|1
argument_list|,
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Similar, but don't require a strictly valid mem ref:    consider pseudo-regs valid as index or base regs.  */
end_comment

begin_function
name|int
name|offsettable_nonstrict_memref_p
parameter_list|(
name|op
parameter_list|)
name|rtx
name|op
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|)
operator|&&
name|offsettable_address_p
argument_list|(
literal|0
argument_list|,
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if Y is a memory address which contains no side effects    and would remain valid after the addition of a positive integer    less than the size of that mode.     We assume that the original address is valid and do not check it.    We do check that it is valid for narrower modes.     If STRICTP is nonzero, we require a strictly valid address,    for the sake of use in reload.c.  */
end_comment

begin_function
name|int
name|offsettable_address_p
parameter_list|(
name|strictp
parameter_list|,
name|mode
parameter_list|,
name|y
parameter_list|)
name|int
name|strictp
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
specifier|register
name|rtx
name|y
decl_stmt|;
block|{
specifier|register
name|enum
name|rtx_code
name|ycode
init|=
name|GET_CODE
argument_list|(
name|y
argument_list|)
decl_stmt|;
specifier|register
name|rtx
name|z
decl_stmt|;
name|rtx
name|y1
init|=
name|y
decl_stmt|;
name|rtx
modifier|*
name|y2
decl_stmt|;
name|int
function_decl|(
modifier|*
name|addressp
function_decl|)
parameter_list|()
init|=
operator|(
name|strictp
condition|?
name|strict_memory_address_p
operator|:
name|memory_address_p
init|)
function_decl|;
if|if
condition|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Adjusting an offsettable address involves changing to a narrower mode.      Make sure that's OK.  */
if|if
condition|(
name|mode_dependent_address_p
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* If the expression contains a constant term,      see if it remains valid when max possible offset is added.  */
if|if
condition|(
operator|(
name|ycode
operator|==
name|PLUS
operator|)
operator|&&
operator|(
name|y2
operator|=
name|find_constant_term_loc
argument_list|(
operator|&
name|y1
argument_list|)
operator|)
condition|)
block|{
name|int
name|good
decl_stmt|;
name|y1
operator|=
operator|*
name|y2
expr_stmt|;
operator|*
name|y2
operator|=
name|plus_constant
argument_list|(
operator|*
name|y2
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Use QImode because an odd displacement may be automatically invalid 	 for any wider mode.  But it should be valid for a single byte.  */
name|good
operator|=
call|(
modifier|*
name|addressp
call|)
argument_list|(
name|QImode
argument_list|,
name|y
argument_list|)
expr_stmt|;
comment|/* In any case, restore old contents of memory.  */
operator|*
name|y2
operator|=
name|y1
expr_stmt|;
return|return
name|good
return|;
block|}
if|if
condition|(
name|ycode
operator|==
name|PRE_DEC
operator|||
name|ycode
operator|==
name|PRE_INC
operator|||
name|ycode
operator|==
name|POST_DEC
operator|||
name|ycode
operator|==
name|POST_INC
condition|)
return|return
literal|0
return|;
comment|/* The offset added here is chosen as the maximum offset that      any instruction could need to add when operating on something      of the specified mode.  We assume that if Y and Y+c are      valid addresses then so is Y+d for all 0<d<c.  */
name|z
operator|=
name|plus_constant_for_output
argument_list|(
name|y
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Use QImode because an odd displacement may be automatically invalid      for any wider mode.  But it should be valid for a single byte.  */
return|return
call|(
modifier|*
name|addressp
call|)
argument_list|(
name|QImode
argument_list|,
name|z
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if ADDR is an address-expression whose effect depends    on the mode of the memory reference it is used in.     Autoincrement addressing is a typical example of mode-dependence    because the amount of the increment depends on the mode.  */
end_comment

begin_function
name|int
name|mode_dependent_address_p
parameter_list|(
name|addr
parameter_list|)
name|rtx
name|addr
decl_stmt|;
block|{
name|GO_IF_MODE_DEPENDENT_ADDRESS
argument_list|(
name|addr
argument_list|,
name|win
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|win
label|:
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a general operand    other than a memory ref with a mode dependent address.  */
end_comment

begin_function
name|int
name|mode_independent_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|op
decl_stmt|;
block|{
name|rtx
name|addr
decl_stmt|;
if|if
condition|(
operator|!
name|general_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|1
return|;
name|addr
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|GO_IF_MODE_DEPENDENT_ADDRESS
argument_list|(
name|addr
argument_list|,
name|lose
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
name|lose
label|:
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Given an operand OP that is a valid memory reference    which satisfies offsettable_memref_p,    return a new memory reference whose address has been adjusted by OFFSET.    OFFSET should be positive and less than the size of the object referenced. */
end_comment

begin_function
name|rtx
name|adj_offsettable_operand
parameter_list|(
name|op
parameter_list|,
name|offset
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|int
name|offset
decl_stmt|;
block|{
specifier|register
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|MEM
condition|)
block|{
specifier|register
name|rtx
name|y
init|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|register
name|rtx
name|new
decl_stmt|;
if|if
condition|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|y
argument_list|)
condition|)
block|{
name|new
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|,
name|plus_constant_for_output
argument_list|(
name|y
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|new
argument_list|)
operator|=
name|RTX_UNCHANGING_P
argument_list|(
name|op
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|rtx
name|z
init|=
name|y
decl_stmt|;
specifier|register
name|rtx
modifier|*
name|const_loc
decl_stmt|;
name|op
operator|=
name|copy_rtx
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|z
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|const_loc
operator|=
name|find_constant_term_loc
argument_list|(
operator|&
name|z
argument_list|)
expr_stmt|;
if|if
condition|(
name|const_loc
condition|)
block|{
operator|*
name|const_loc
operator|=
name|plus_constant_for_output
argument_list|(
operator|*
name|const_loc
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|op
return|;
block|}
block|}
name|new
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|,
name|plus_constant_for_output
argument_list|(
name|y
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|new
argument_list|)
operator|=
name|RTX_UNCHANGING_P
argument_list|(
name|op
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|REGISTER_CONSTRAINTS
end_ifdef

begin_comment
comment|/* Check the operands of an insn (found in recog_operands)    against the insn's operand constraints (found via INSN_CODE_NUM)    and return 1 if they are valid.     WHICH_ALTERNATIVE is set to a number which indicates which    alternative of constraints was matched: 0 for the first alternative,    1 for the next, etc.     In addition, when two operands are match    and it happens that the output operand is (reg) while the    input operand is --(reg) or ++(reg) (a pre-inc or pre-dec),    make the output operand look like the input.    This is because the output operand is the one the template will print.     This is used in final, just before printing the assembler code and by    the routines that determine an insn's attribute.     If STRICT is a positive non-zero value, it means that we have been    called after reload has been completed.  In that case, we must    do all checks strictly.  If it is zero, it means that we have been called    before reload has completed.  In that case, we first try to see if we can    find an alternative that matches strictly.  If not, we try again, this    time assuming that reload will fix up the insn.  This provides a "best    guess" for the alternative and is used to compute attributes of insns prior    to reload.  A negative value of STRICT is used for this internal call.  */
end_comment

begin_struct
struct|struct
name|funny_match
block|{
name|int
name|this
decl_stmt|,
name|other
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|int
name|constrain_operands
parameter_list|(
name|insn_code_num
parameter_list|,
name|strict
parameter_list|)
name|int
name|insn_code_num
decl_stmt|;
name|int
name|strict
decl_stmt|;
block|{
name|char
modifier|*
name|constraints
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|int
name|matching_operands
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
enum|enum
name|op_type
block|{
name|OP_IN
block|,
name|OP_OUT
block|,
name|OP_INOUT
block|}
name|op_types
index|[
name|MAX_RECOG_OPERANDS
index|]
enum|;
name|int
name|earlyclobber
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|int
name|noperands
init|=
name|insn_n_operands
index|[
name|insn_code_num
index|]
decl_stmt|;
name|struct
name|funny_match
name|funny_match
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|int
name|funny_match_index
decl_stmt|;
name|int
name|nalternatives
init|=
name|insn_n_alternatives
index|[
name|insn_code_num
index|]
decl_stmt|;
if|if
condition|(
name|noperands
operator|==
literal|0
operator|||
name|nalternatives
operator|==
literal|0
condition|)
return|return
literal|1
return|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|noperands
condition|;
name|c
operator|++
control|)
block|{
name|constraints
index|[
name|c
index|]
operator|=
name|insn_operand_constraint
index|[
name|insn_code_num
index|]
index|[
name|c
index|]
expr_stmt|;
name|matching_operands
index|[
name|c
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|op_types
index|[
name|c
index|]
operator|=
name|OP_IN
expr_stmt|;
block|}
name|which_alternative
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|which_alternative
operator|<
name|nalternatives
condition|)
block|{
specifier|register
name|int
name|opno
decl_stmt|;
name|int
name|lose
init|=
literal|0
decl_stmt|;
name|funny_match_index
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|opno
operator|=
literal|0
init|;
name|opno
operator|<
name|noperands
condition|;
name|opno
operator|++
control|)
block|{
specifier|register
name|rtx
name|op
init|=
name|recog_operand
index|[
name|opno
index|]
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
init|=
name|constraints
index|[
name|opno
index|]
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|int
name|win
init|=
literal|0
decl_stmt|;
name|int
name|val
decl_stmt|;
name|earlyclobber
index|[
name|opno
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|offset
operator|=
name|SUBREG_WORD
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
comment|/* An empty constraint or empty alternative 	     allows anything which matched the pattern.  */
if|if
condition|(
operator|*
name|p
operator|==
literal|0
operator|||
operator|*
name|p
operator|==
literal|','
condition|)
name|win
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|','
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'?'
case|:
case|case
literal|'#'
case|:
case|case
literal|'!'
case|:
case|case
literal|'*'
case|:
case|case
literal|'%'
case|:
break|break;
case|case
literal|'='
case|:
name|op_types
index|[
name|opno
index|]
operator|=
name|OP_OUT
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
name|op_types
index|[
name|opno
index|]
operator|=
name|OP_INOUT
expr_stmt|;
break|break;
case|case
literal|'&'
case|:
name|earlyclobber
index|[
name|opno
index|]
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
comment|/* This operand must be the same as a previous one. 		   This kind of constraint is used for instructions such 		   as add when they take only two operands.  		   Note that the lower-numbered operand is passed first.  		   If we are not testing strictly, assume that this constraint 		   will be satisfied.  */
if|if
condition|(
name|strict
operator|<
literal|0
condition|)
name|val
operator|=
literal|1
expr_stmt|;
else|else
name|val
operator|=
name|operands_match_p
argument_list|(
name|recog_operand
index|[
name|c
operator|-
literal|'0'
index|]
argument_list|,
name|recog_operand
index|[
name|opno
index|]
argument_list|)
expr_stmt|;
name|matching_operands
index|[
name|opno
index|]
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
name|matching_operands
index|[
name|c
operator|-
literal|'0'
index|]
operator|=
name|opno
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
name|win
operator|=
literal|1
expr_stmt|;
comment|/* If output is *x and input is *--x, 		   arrange later to change the output to *--x as well, 		   since the output op is the one that will be printed.  */
if|if
condition|(
name|val
operator|==
literal|2
operator|&&
name|strict
operator|>
literal|0
condition|)
block|{
name|funny_match
index|[
name|funny_match_index
index|]
operator|.
name|this
operator|=
name|opno
expr_stmt|;
name|funny_match
index|[
name|funny_match_index
operator|++
index|]
operator|.
name|other
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
block|}
break|break;
case|case
literal|'p'
case|:
comment|/* p is used for address_operands.  When we are called by 		   gen_input_reload, no one will have checked that the 		   address is strictly valid, i.e., that all pseudos 		   requiring hard regs have gotten them.  */
if|if
condition|(
name|strict
operator|<=
literal|0
operator|||
operator|(
name|strict_memory_address_p
argument_list|(
name|insn_operand_mode
index|[
name|insn_code_num
index|]
index|[
name|opno
index|]
argument_list|,
name|op
argument_list|)
operator|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* No need to check general_operand again; 		   it was done in insn-recog.c.  */
case|case
literal|'g'
case|:
comment|/* Anything goes unless it is a REG and really has a hard reg 		   but the hard reg is not in the class GENERAL_REGS.  */
if|if
condition|(
name|strict
operator|<
literal|0
operator|||
name|GENERAL_REGS
operator|==
name|ALL_REGS
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|REG
operator|||
operator|(
name|reload_in_progress
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|||
name|reg_fits_class_p
argument_list|(
name|op
argument_list|,
name|GENERAL_REGS
argument_list|,
name|offset
argument_list|,
name|mode
argument_list|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
if|if
condition|(
name|strict
operator|<
literal|0
operator|||
operator|(
name|strict
operator|==
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|||
operator|(
name|strict
operator|==
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SCRATCH
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
operator|(
operator|(
name|GENERAL_REGS
operator|==
name|ALL_REGS
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
operator|||
name|reg_fits_class_p
argument_list|(
name|op
argument_list|,
name|GENERAL_REGS
argument_list|,
name|offset
argument_list|,
name|mode
argument_list|)
operator|)
operator|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
comment|/* This is used for a MATCH_SCRATCH in the cases when we 		   don't actually need anything.  So anything goes any time. */
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
comment|/* Before reload, accept what reload can turn into mem.  */
operator|||
operator|(
name|strict
operator|<
literal|0
operator|&&
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
operator|)
comment|/* During reload, accept a pseudo  */
operator|||
operator|(
name|reload_in_progress
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_DEC
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|POST_DEC
operator|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_INC
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|POST_INC
operator|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
comment|/* Match any CONST_DOUBLE, but only if 		   we can examine the bits of it reliably.  */
if|if
condition|(
operator|(
name|HOST_FLOAT_FORMAT
operator|!=
name|TARGET_FLOAT_FORMAT
operator|||
name|HOST_BITS_PER_WIDE_INT
operator|!=
name|BITS_PER_WORD
operator|)
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|VOIDmode
operator|&&
operator|!
name|flag_pretend_float
condition|)
break|break;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
case|case
literal|'H'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|CONST_DOUBLE_OK_FOR_LETTER_P
argument_list|(
name|op
argument_list|,
name|c
argument_list|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
operator|)
condition|)
break|break;
case|case
literal|'i'
case|:
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
operator|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
case|case
literal|'J'
case|:
case|case
literal|'K'
case|:
case|case
literal|'L'
case|:
case|case
literal|'M'
case|:
case|case
literal|'N'
case|:
case|case
literal|'O'
case|:
case|case
literal|'P'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
name|c
argument_list|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|EXTRA_CONSTRAINT
case|case
literal|'Q'
case|:
case|case
literal|'R'
case|:
case|case
literal|'S'
case|:
case|case
literal|'T'
case|:
case|case
literal|'U'
case|:
if|if
condition|(
name|EXTRA_CONSTRAINT
argument_list|(
name|op
argument_list|,
name|c
argument_list|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'V'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|offsettable_memref_p
argument_list|(
name|op
argument_list|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
if|if
condition|(
operator|(
name|strict
operator|>
literal|0
operator|&&
name|offsettable_memref_p
argument_list|(
name|op
argument_list|)
operator|)
operator|||
operator|(
name|strict
operator|==
literal|0
operator|&&
name|offsettable_nonstrict_memref_p
argument_list|(
name|op
argument_list|)
operator|)
comment|/* Before reload, accept what reload can handle.  */
operator|||
operator|(
name|strict
operator|<
literal|0
operator|&&
operator|(
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|)
operator|)
comment|/* During reload, accept a pseudo  */
operator|||
operator|(
name|reload_in_progress
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|strict
operator|<
literal|0
operator|||
operator|(
name|strict
operator|==
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|||
operator|(
name|strict
operator|==
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SCRATCH
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
name|reg_fits_class_p
argument_list|(
name|op
argument_list|,
name|REG_CLASS_FROM_LETTER
argument_list|(
name|c
argument_list|)
argument_list|,
name|offset
argument_list|,
name|mode
argument_list|)
operator|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
block|}
name|constraints
index|[
name|opno
index|]
operator|=
name|p
expr_stmt|;
comment|/* If this operand did not win somehow, 	     this alternative loses.  */
if|if
condition|(
operator|!
name|win
condition|)
name|lose
operator|=
literal|1
expr_stmt|;
block|}
comment|/* This alternative won; the operands are ok. 	 Change whichever operands this alternative says to change.  */
if|if
condition|(
operator|!
name|lose
condition|)
block|{
name|int
name|opno
decl_stmt|,
name|eopno
decl_stmt|;
comment|/* See if any earlyclobber operand conflicts with some other 	     operand.  */
if|if
condition|(
name|strict
operator|>
literal|0
condition|)
for|for
control|(
name|eopno
operator|=
literal|0
init|;
name|eopno
operator|<
name|noperands
condition|;
name|eopno
operator|++
control|)
comment|/* Ignore earlyclobber operands now in memory, 		 because we would often report failure when we have 		 two memory operands, one of which was formerly a REG.  */
if|if
condition|(
name|earlyclobber
index|[
name|eopno
index|]
operator|&&
name|GET_CODE
argument_list|(
name|recog_operand
index|[
name|eopno
index|]
argument_list|)
operator|==
name|REG
condition|)
for|for
control|(
name|opno
operator|=
literal|0
init|;
name|opno
operator|<
name|noperands
condition|;
name|opno
operator|++
control|)
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|recog_operand
index|[
name|opno
index|]
argument_list|)
operator|==
name|MEM
operator|||
name|op_types
index|[
name|opno
index|]
operator|!=
name|OP_OUT
operator|)
operator|&&
name|opno
operator|!=
name|eopno
operator|&&
name|constraints
index|[
name|opno
index|]
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|matching_operands
index|[
name|opno
index|]
operator|==
name|eopno
operator|&&
name|rtx_equal_p
argument_list|(
name|recog_operand
index|[
name|opno
index|]
argument_list|,
name|recog_operand
index|[
name|eopno
index|]
argument_list|)
operator|)
operator|&&
operator|!
name|safe_from_earlyclobber
argument_list|(
name|recog_operand
index|[
name|opno
index|]
argument_list|,
name|recog_operand
index|[
name|eopno
index|]
argument_list|)
condition|)
name|lose
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|lose
condition|)
block|{
while|while
condition|(
operator|--
name|funny_match_index
operator|>=
literal|0
condition|)
block|{
name|recog_operand
index|[
name|funny_match
index|[
name|funny_match_index
index|]
operator|.
name|other
index|]
operator|=
name|recog_operand
index|[
name|funny_match
index|[
name|funny_match_index
index|]
operator|.
name|this
index|]
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
block|}
name|which_alternative
operator|++
expr_stmt|;
block|}
comment|/* If we are about to reject this, but we are not to test strictly,      try a very loose test.  Only return failure if it fails also.  */
if|if
condition|(
name|strict
operator|==
literal|0
condition|)
return|return
name|constrain_operands
argument_list|(
name|insn_code_num
argument_list|,
operator|-
literal|1
argument_list|)
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 iff OPERAND (assumed to be a REG rtx)    is a hard reg in class CLASS when its regno is offsetted by OFFSET    and changed to mode MODE.    If REG occupies multiple hard regs, all of them must be in CLASS.  */
end_comment

begin_function
name|int
name|reg_fits_class_p
parameter_list|(
name|operand
parameter_list|,
name|class
parameter_list|,
name|offset
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|operand
decl_stmt|;
specifier|register
name|enum
name|reg_class
name|class
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
specifier|register
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|operand
argument_list|)
decl_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|class
index|]
argument_list|,
name|regno
operator|+
name|offset
argument_list|)
condition|)
block|{
specifier|register
name|int
name|sr
decl_stmt|;
name|regno
operator|+=
name|offset
expr_stmt|;
for|for
control|(
name|sr
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
operator|-
literal|1
init|;
name|sr
operator|>
literal|0
condition|;
name|sr
operator|--
control|)
if|if
condition|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|class
index|]
argument_list|,
name|regno
operator|+
name|sr
argument_list|)
condition|)
break|break;
return|return
name|sr
operator|==
literal|0
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* REGISTER_CONSTRAINTS */
end_comment

end_unit

