begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Top level of GNU C compiler    Copyright (C) 1987, 1988, 1989, 1992 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* This is the top level of cc1/c++.    It parses command args, opens files, invokes the various passes    in the proper order, and counts the time used by each.    Error messages and low-level interface to malloc also handled here.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_undef
undef|#
directive|undef
name|FLOAT
end_undef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_comment
comment|/* This is for hpux.  It is a real screw.  They should change hpux.  */
end_comment

begin_undef
undef|#
directive|undef
name|FLOAT
end_undef

begin_include
include|#
directive|include
file|<sys/times.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_comment
comment|/* Correct for hpux at least.  Is it good on other USG?  */
end_comment

begin_undef
undef|#
directive|undef
name|FFS
end_undef

begin_comment
comment|/* Some systems define this in param.h.  */
end_comment

begin_else
else|#
directive|else
end_else

begin_ifndef
ifndef|#
directive|ifndef
name|VMS
end_ifndef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"input.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_comment
comment|/* #include "c-tree.h" */
end_comment

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_include
include|#
directive|include
file|"defaults.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|XCOFF_DEBUGGING_INFO
end_ifdef

begin_include
include|#
directive|include
file|"xcoffout.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_comment
comment|/* The extra parameters substantially improve the I/O performance.  */
end_comment

begin_function
specifier|static
name|FILE
modifier|*
name|VMS_fopen
parameter_list|(
name|fname
parameter_list|,
name|type
parameter_list|)
name|char
modifier|*
name|fname
decl_stmt|;
name|char
modifier|*
name|type
decl_stmt|;
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
literal|"w"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|fopen
argument_list|(
name|fname
argument_list|,
name|type
argument_list|,
literal|"mbc=16"
argument_list|,
literal|"deq=64"
argument_list|,
literal|"fop=tef"
argument_list|,
literal|"shr=nil"
argument_list|)
return|;
return|return
name|fopen
argument_list|(
name|fname
argument_list|,
name|type
argument_list|,
literal|"mbc=16"
argument_list|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|fopen
value|VMS_fopen
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DEFAULT_GDB_EXTENSIONS
end_ifndef

begin_define
define|#
directive|define
name|DEFAULT_GDB_EXTENSIONS
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|int
name|rtx_equal_function_value_matters
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|VMS
argument_list|)
operator|||
name|defined
argument_list|(
name|OS2
argument_list|)
operator|)
end_if

begin_decl_stmt
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|version_string
decl_stmt|,
modifier|*
name|language_string
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|void
name|init_lex
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|init_decl_processing
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|init_obstacks
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|init_tree_codes
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|init_rtl
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|init_optabs
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|init_stmt
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|init_reg_sets
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|dump_flow_info
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|dump_sched_info
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|dump_local_alloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|rest_of_decl_compilation
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|error
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|error_with_file_and_line
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|fancy_abort
parameter_list|()
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|abort
end_ifndef

begin_function_decl
name|void
name|abort
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|void
name|set_target_switch
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_switch_values
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|decl_name
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Name of program invoked, sans directories.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Copy of arguments to main.  */
end_comment

begin_decl_stmt
name|int
name|save_argc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|save_argv
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Name of current original source file (what was input to cpp).    This comes from each #-command in the actual input.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|input_filename
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name of top-level original source file (what was input to cpp).    This comes from the #-command at the beginning of the actual input.    If there isn't any there, then this is the cc1 input file name.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|main_input_filename
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stream for reading from the input file.  */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|finput
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current line number in real source file.  */
end_comment

begin_decl_stmt
name|int
name|lineno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stack of currently pending input files.  */
end_comment

begin_decl_stmt
name|struct
name|file_stack
modifier|*
name|input_file_stack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Incremented on each change to input_file_stack.  */
end_comment

begin_decl_stmt
name|int
name|input_file_stack_tick
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* FUNCTION_DECL for function now being parsed or compiled.  */
end_comment

begin_decl_stmt
specifier|extern
name|tree
name|current_function_decl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name to use as base of names for dump output files.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|dump_base_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Bit flags that specify the machine subtype we are compiling for.    Bits are tested using macros TARGET_... defined in the tm.h file    and set by `-m...' switches.  Must be defined in rtlanal.c.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|target_flags
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flags saying which kinds of debugging dump have been requested.  */
end_comment

begin_decl_stmt
name|int
name|rtl_dump
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rtl_dump_and_exit
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|jump_opt_dump
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cse_dump
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|loop_dump
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cse2_dump
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flow_dump
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|combine_dump
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sched_dump
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|local_reg_dump
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|global_reg_dump
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sched2_dump
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|jump2_opt_dump
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dbr_sched_dump
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag_print_asm_name
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|stack_reg_dump
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name for output file of assembly code, specified with -o.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|asm_file_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Value of the -G xx switch, and whether it was passed or not.  */
end_comment

begin_decl_stmt
name|int
name|g_switch_value
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|g_switch_set
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Type(s) of debugging information we are producing (if any).    See flags.h for the definitions of the different possible    types of debugging information.  */
end_comment

begin_decl_stmt
name|enum
name|debug_info_type
name|write_symbols
init|=
name|NO_DEBUG
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Level of debugging information we are producing.  See flags.h    for the definitions of the different possible levels.  */
end_comment

begin_decl_stmt
name|enum
name|debug_info_level
name|debug_info_level
init|=
name|DINFO_LEVEL_NONE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means use GNU-only extensions in the generated symbolic    debugging information.  */
end_comment

begin_comment
comment|/* Currently, this only has an effect when write_symbols is set to    DBX_DEBUG, XCOFF_DEBUG, or DWARF_DEBUG.  */
end_comment

begin_decl_stmt
name|int
name|use_gnu_debug_info_extensions
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means do optimizations.  -O.    Particular numeric values stand for particular amounts of optimization;    thus, -O2 stores 2 here.  However, the optimizations beyond the basic    ones are not controlled directly by this variable.  Instead, they are    controlled by individual `flag_...' variables that are defaulted    based on this variable.  */
end_comment

begin_decl_stmt
name|int
name|optimize
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of error messages and warning messages so far.  */
end_comment

begin_decl_stmt
name|int
name|errorcount
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|warningcount
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sorrycount
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to function to compute the name to use to print a declaration.  */
end_comment

begin_function_decl
name|char
modifier|*
function_decl|(
modifier|*
name|decl_printable_name
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Pointer to function to compute rtl for a language-specific tree code.  */
end_comment

begin_function_decl
name|struct
name|rtx_def
modifier|*
function_decl|(
modifier|*
name|lang_expand_expr
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Pointer to function to finish handling an incomplete decl at the    end of compilation.  */
end_comment

begin_function_decl
name|void
function_decl|(
modifier|*
name|incomplete_decl_finalize_hook
function_decl|)
parameter_list|()
init|=
literal|0
function_decl|;
end_function_decl

begin_comment
comment|/* Nonzero if generating code to do profiling.  */
end_comment

begin_decl_stmt
name|int
name|profile_flag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if generating code to do profiling on a line-by-line basis.  */
end_comment

begin_decl_stmt
name|int
name|profile_block_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for -pedantic switch: warn about anything    that standard spec forbids.  */
end_comment

begin_decl_stmt
name|int
name|pedantic
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Temporarily suppress certain warnings.    This is set while reading code from a system header file.  */
end_comment

begin_decl_stmt
name|int
name|in_system_header
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means do stupid register allocation.    Currently, this is 1 if `optimize' is 0.  */
end_comment

begin_decl_stmt
name|int
name|obey_regdecls
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Don't print functions as they are compiled and don't print    times taken by the various passes.  -quiet.  */
end_comment

begin_decl_stmt
name|int
name|quiet_flag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* -f flags.  */
end_comment

begin_comment
comment|/* Nonzero means `char' should be signed.  */
end_comment

begin_decl_stmt
name|int
name|flag_signed_char
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means give an enum type only as many bytes as it needs.  */
end_comment

begin_decl_stmt
name|int
name|flag_short_enums
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for -fcaller-saves: allocate values in regs that need to    be saved across function calls, if that produces overall better code.    Optional now, so people can test it.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEFAULT_CALLER_SAVES
end_ifdef

begin_decl_stmt
name|int
name|flag_caller_saves
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|flag_caller_saves
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Nonzero if structures and unions should be returned in memory.     This should only be defined if compatibility with another compiler or    with an ABI is needed, because it results in slower code.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DEFAULT_PCC_STRUCT_RETURN
end_ifndef

begin_define
define|#
directive|define
name|DEFAULT_PCC_STRUCT_RETURN
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Nonzero for -fpcc-struct-return: return values the same way PCC does.  */
end_comment

begin_decl_stmt
name|int
name|flag_pcc_struct_return
init|=
name|DEFAULT_PCC_STRUCT_RETURN
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for -fforce-mem: load memory value into a register    before arithmetic on it.  This makes better cse but slower compilation.  */
end_comment

begin_decl_stmt
name|int
name|flag_force_mem
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for -fforce-addr: load memory address into a register before    reference to memory.  This makes better cse but slower compilation.  */
end_comment

begin_decl_stmt
name|int
name|flag_force_addr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for -fdefer-pop: don't pop args after each function call;    instead save them up to pop many calls' args with one insns.  */
end_comment

begin_decl_stmt
name|int
name|flag_defer_pop
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for -ffloat-store: don't allocate floats and doubles    in extended-precision registers.  */
end_comment

begin_decl_stmt
name|int
name|flag_float_store
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for -fcse-follow-jumps:    have cse follow jumps to do a more extensive job.  */
end_comment

begin_decl_stmt
name|int
name|flag_cse_follow_jumps
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for -fcse-skip-blocks:    have cse follow a branch around a block.  */
end_comment

begin_decl_stmt
name|int
name|flag_cse_skip_blocks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for -fexpensive-optimizations:    perform miscellaneous relatively-expensive optimizations.  */
end_comment

begin_decl_stmt
name|int
name|flag_expensive_optimizations
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for -fthread-jumps:    have jump optimize output of loop.  */
end_comment

begin_decl_stmt
name|int
name|flag_thread_jumps
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero enables strength-reduction in loop.c.  */
end_comment

begin_decl_stmt
name|int
name|flag_strength_reduce
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero enables loop unrolling in unroll.c.  Only loops for which the    number of iterations can be calculated at compile-time (UNROLL_COMPLETELY,    UNROLL_MODULO) or at run-time (preconditioned to be UNROLL_MODULO) are    unrolled.  */
end_comment

begin_decl_stmt
name|int
name|flag_unroll_loops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero enables loop unrolling in unroll.c.  All loops are unrolled.    This is generally not a win.  */
end_comment

begin_decl_stmt
name|int
name|flag_unroll_all_loops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for -fwritable-strings:    store string constants in data segment and don't uniquize them.  */
end_comment

begin_decl_stmt
name|int
name|flag_writable_strings
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means don't put addresses of constant functions in registers.    Used for compiling the Unix kernel, where strange substitutions are    done on the assembly output.  */
end_comment

begin_decl_stmt
name|int
name|flag_no_function_cse
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for -fomit-frame-pointer:    don't make a frame pointer in simple functions that don't require one.  */
end_comment

begin_decl_stmt
name|int
name|flag_omit_frame_pointer
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero to inhibit use of define_optimization peephole opts.  */
end_comment

begin_decl_stmt
name|int
name|flag_no_peephole
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero allows GCC to violate some IEEE or ANSI rules regarding math    operations in the interest of optimization.  For example it allows    GCC to assume arguments to sqrt are nonnegative numbers, allowing    faster code for sqrt to be generated. */
end_comment

begin_decl_stmt
name|int
name|flag_fast_math
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means all references through pointers are volatile.  */
end_comment

begin_decl_stmt
name|int
name|flag_volatile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means treat all global and extern variables as global.  */
end_comment

begin_decl_stmt
name|int
name|flag_volatile_global
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means just do syntax checking; don't output anything.  */
end_comment

begin_decl_stmt
name|int
name|flag_syntax_only
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means to rerun cse after loop optimization.  This increases    compilation time about 20% and picks up a few more common expressions.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|flag_rerun_cse_after_loop
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for -finline-functions: ok to inline functions that look like    good inline candidates.  */
end_comment

begin_decl_stmt
name|int
name|flag_inline_functions
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for -fkeep-inline-functions: even if we make a function    go inline everywhere, keep its definition around for debugging    purposes.  */
end_comment

begin_decl_stmt
name|int
name|flag_keep_inline_functions
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means that functions declared `inline' will be treated    as `static'.  Prevents generation of zillions of copies of unused    static inline functions; instead, `inlines' are written out    only when actually used.  Used in conjunction with -g.  Also    does the right thing with #pragma interface.  */
end_comment

begin_decl_stmt
name|int
name|flag_no_inline
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means we should be saving declaration info into a .X file.  */
end_comment

begin_decl_stmt
name|int
name|flag_gen_aux_info
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Specified name of aux-info file.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|aux_info_file_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means make the text shared if supported.  */
end_comment

begin_decl_stmt
name|int
name|flag_shared_data
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means schedule into delayed branch slots if supported.  */
end_comment

begin_decl_stmt
name|int
name|flag_delayed_branch
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we are compiling pure (sharable) code.    Value is 1 if we are doing reasonable (i.e. simple    offset into offset table) pic.  Value is 2 if we can    only perform register offsets.  */
end_comment

begin_decl_stmt
name|int
name|flag_pic
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means place uninitialized global data in the bss section. */
end_comment

begin_decl_stmt
name|int
name|flag_no_common
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means pretend it is OK to examine bits of target floats,    even if that isn't true.  The resulting code will have incorrect constants,    but the same series of instructions that the native compiler would make.  */
end_comment

begin_decl_stmt
name|int
name|flag_pretend_float
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means change certain warnings into errors.    Usually these are warnings about failure to conform to some standard.  */
end_comment

begin_decl_stmt
name|int
name|flag_pedantic_errors
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* flag_schedule_insns means schedule insns within basic blocks (before    local_alloc).    flag_schedule_insns_after_reload means schedule insns after    global_alloc.  */
end_comment

begin_decl_stmt
name|int
name|flag_schedule_insns
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag_schedule_insns_after_reload
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -finhibit-size-directive inhibits output of .size for ELF.    This is used only for compiling crtstuff.c,     and it may be extended to other effects    needed for crtstuff.c on other systems.  */
end_comment

begin_decl_stmt
name|int
name|flag_inhibit_size_directive
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -fverbose-asm causes extra commentary information to be produced in    the generated assembly code (to make it more readable).  This option    is generally only of use to those who actually need to read the    generated assembly code (perhaps while debugging the compiler itself).  */
end_comment

begin_decl_stmt
name|int
name|flag_verbose_asm
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -fgnu-linker specifies use of the GNU linker for initializations.    (Or, more generally, a linker that handles initializations.)    -fno-gnu-linker says that collect2 will be used.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_COLLECT2
end_ifdef

begin_decl_stmt
name|int
name|flag_gnu_linker
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|flag_gnu_linker
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Table of language-independent -f options.    STRING is the option name.  VARIABLE is the address of the variable.    ON_VALUE is the value to store in VARIABLE     if `-fSTRING' is seen as an option.    (If `-fno-STRING' is seen as an option, the opposite value is stored.)  */
end_comment

begin_struct
struct|struct
block|{
name|char
modifier|*
name|string
decl_stmt|;
name|int
modifier|*
name|variable
decl_stmt|;
name|int
name|on_value
decl_stmt|;
block|}
name|f_options
index|[]
init|=
block|{
block|{
literal|"float-store"
block|,
operator|&
name|flag_float_store
block|,
literal|1
block|}
block|,
block|{
literal|"volatile"
block|,
operator|&
name|flag_volatile
block|,
literal|1
block|}
block|,
block|{
literal|"volatile-global"
block|,
operator|&
name|flag_volatile_global
block|,
literal|1
block|}
block|,
block|{
literal|"defer-pop"
block|,
operator|&
name|flag_defer_pop
block|,
literal|1
block|}
block|,
block|{
literal|"omit-frame-pointer"
block|,
operator|&
name|flag_omit_frame_pointer
block|,
literal|1
block|}
block|,
block|{
literal|"cse-follow-jumps"
block|,
operator|&
name|flag_cse_follow_jumps
block|,
literal|1
block|}
block|,
block|{
literal|"cse-skip-blocks"
block|,
operator|&
name|flag_cse_skip_blocks
block|,
literal|1
block|}
block|,
block|{
literal|"expensive-optimizations"
block|,
operator|&
name|flag_expensive_optimizations
block|,
literal|1
block|}
block|,
block|{
literal|"thread-jumps"
block|,
operator|&
name|flag_thread_jumps
block|,
literal|1
block|}
block|,
block|{
literal|"strength-reduce"
block|,
operator|&
name|flag_strength_reduce
block|,
literal|1
block|}
block|,
block|{
literal|"unroll-loops"
block|,
operator|&
name|flag_unroll_loops
block|,
literal|1
block|}
block|,
block|{
literal|"unroll-all-loops"
block|,
operator|&
name|flag_unroll_all_loops
block|,
literal|1
block|}
block|,
block|{
literal|"writable-strings"
block|,
operator|&
name|flag_writable_strings
block|,
literal|1
block|}
block|,
block|{
literal|"peephole"
block|,
operator|&
name|flag_no_peephole
block|,
literal|0
block|}
block|,
block|{
literal|"force-mem"
block|,
operator|&
name|flag_force_mem
block|,
literal|1
block|}
block|,
block|{
literal|"force-addr"
block|,
operator|&
name|flag_force_addr
block|,
literal|1
block|}
block|,
block|{
literal|"function-cse"
block|,
operator|&
name|flag_no_function_cse
block|,
literal|0
block|}
block|,
block|{
literal|"inline-functions"
block|,
operator|&
name|flag_inline_functions
block|,
literal|1
block|}
block|,
block|{
literal|"keep-inline-functions"
block|,
operator|&
name|flag_keep_inline_functions
block|,
literal|1
block|}
block|,
block|{
literal|"inline"
block|,
operator|&
name|flag_no_inline
block|,
literal|0
block|}
block|,
block|{
literal|"syntax-only"
block|,
operator|&
name|flag_syntax_only
block|,
literal|1
block|}
block|,
block|{
literal|"shared-data"
block|,
operator|&
name|flag_shared_data
block|,
literal|1
block|}
block|,
block|{
literal|"caller-saves"
block|,
operator|&
name|flag_caller_saves
block|,
literal|1
block|}
block|,
block|{
literal|"pcc-struct-return"
block|,
operator|&
name|flag_pcc_struct_return
block|,
literal|1
block|}
block|,
block|{
literal|"reg-struct-return"
block|,
operator|&
name|flag_pcc_struct_return
block|,
literal|0
block|}
block|,
block|{
literal|"delayed-branch"
block|,
operator|&
name|flag_delayed_branch
block|,
literal|1
block|}
block|,
block|{
literal|"rerun-cse-after-loop"
block|,
operator|&
name|flag_rerun_cse_after_loop
block|,
literal|1
block|}
block|,
block|{
literal|"pretend-float"
block|,
operator|&
name|flag_pretend_float
block|,
literal|1
block|}
block|,
block|{
literal|"schedule-insns"
block|,
operator|&
name|flag_schedule_insns
block|,
literal|1
block|}
block|,
block|{
literal|"schedule-insns2"
block|,
operator|&
name|flag_schedule_insns_after_reload
block|,
literal|1
block|}
block|,
block|{
literal|"pic"
block|,
operator|&
name|flag_pic
block|,
literal|1
block|}
block|,
block|{
literal|"PIC"
block|,
operator|&
name|flag_pic
block|,
literal|2
block|}
block|,
block|{
literal|"fast-math"
block|,
operator|&
name|flag_fast_math
block|,
literal|1
block|}
block|,
block|{
literal|"common"
block|,
operator|&
name|flag_no_common
block|,
literal|0
block|}
block|,
block|{
literal|"inhibit-size-directive"
block|,
operator|&
name|flag_inhibit_size_directive
block|,
literal|1
block|}
block|,
block|{
literal|"verbose-asm"
block|,
operator|&
name|flag_verbose_asm
block|,
literal|1
block|}
block|,
block|{
literal|"gnu-linker"
block|,
operator|&
name|flag_gnu_linker
block|,
literal|1
block|}
block|}
struct|;
end_struct

begin_comment
comment|/* Table of language-specific options.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|lang_options
index|[]
init|=
block|{
literal|"-ftraditional"
block|,
literal|"-traditional"
block|,
literal|"-fnotraditional"
block|,
literal|"-fno-traditional"
block|,
literal|"-fsigned-char"
block|,
literal|"-funsigned-char"
block|,
literal|"-fno-signed-char"
block|,
literal|"-fno-unsigned-char"
block|,
literal|"-fsigned-bitfields"
block|,
literal|"-funsigned-bitfields"
block|,
literal|"-fno-signed-bitfields"
block|,
literal|"-fno-unsigned-bitfields"
block|,
literal|"-fshort-enums"
block|,
literal|"-fno-short-enums"
block|,
literal|"-fcond-mismatch"
block|,
literal|"-fno-cond-mismatch"
block|,
literal|"-fshort-double"
block|,
literal|"-fno-short-double"
block|,
literal|"-fasm"
block|,
literal|"-fno-asm"
block|,
literal|"-fbuiltin"
block|,
literal|"-fno-builtin"
block|,
literal|"-fno-ident"
block|,
literal|"-fident"
block|,
literal|"-ansi"
block|,
literal|"-Wimplicit"
block|,
literal|"-Wno-implicit"
block|,
literal|"-Wwrite-strings"
block|,
literal|"-Wno-write-strings"
block|,
literal|"-Wcast-qual"
block|,
literal|"-Wno-cast-qual"
block|,
literal|"-Wpointer-arith"
block|,
literal|"-Wno-pointer-arith"
block|,
literal|"-Wstrict-prototypes"
block|,
literal|"-Wno-strict-prototypes"
block|,
literal|"-Wmissing-prototypes"
block|,
literal|"-Wno-missing-prototypes"
block|,
literal|"-Wredundant-decls"
block|,
literal|"-Wno-redundant-decls"
block|,
literal|"-Wnested-externs"
block|,
literal|"-Wno-nested-externs"
block|,
literal|"-Wtraditional"
block|,
literal|"-Wno-traditional"
block|,
literal|"-Wformat"
block|,
literal|"-Wno-format"
block|,
literal|"-Wchar-subscripts"
block|,
literal|"-Wno-char-subscripts"
block|,
literal|"-Wconversion"
block|,
literal|"-Wno-conversion"
block|,
literal|"-Wparentheses"
block|,
literal|"-Wno-parentheses"
block|,
literal|"-Wcomment"
block|,
literal|"-Wno-comment"
block|,
literal|"-Wcomments"
block|,
literal|"-Wno-comments"
block|,
literal|"-Wtrigraphs"
block|,
literal|"-Wno-trigraphs"
block|,
literal|"-Wimport"
block|,
literal|"-Wno-import"
block|,
literal|"-Wmissing-braces"
block|,
literal|"-Wno-missing-braces"
block|,
literal|"-Wall"
block|,
comment|/* These are for C++.  */
literal|"-+e0"
block|,
comment|/* gcc.c tacks the `-' on the front.  */
literal|"-+e1"
block|,
literal|"-+e2"
block|,
literal|"-fsave-memoized"
block|,
literal|"-fno-save-memoized"
block|,
literal|"-fcadillac"
block|,
literal|"-fno-cadillac"
block|,
literal|"-fgc"
block|,
literal|"-fno-gc"
block|,
literal|"-flabels-ok"
block|,
literal|"-fno-labels-ok"
block|,
literal|"-fstats"
block|,
literal|"-fno-stats"
block|,
literal|"-fthis-is-variable"
block|,
literal|"-fno-this-is-variable"
block|,
literal|"-fstrict-prototype"
block|,
literal|"-fno-strict-prototype"
block|,
literal|"-fall-virtual"
block|,
literal|"-fno-all-virtual"
block|,
literal|"-fmemoize-lookups"
block|,
literal|"-fno-memoize-lookups"
block|,
literal|"-felide-constructors"
block|,
literal|"-fno-elide-constructors"
block|,
literal|"-finline-debug"
block|,
literal|"-fno-inline-debug"
block|,
literal|"-fhandle-exceptions"
block|,
literal|"-fno-handle-exceptions"
block|,
literal|"-fansi-exceptions"
block|,
literal|"-fno-ansi-exceptions"
block|,
literal|"-fspring-exceptions"
block|,
literal|"-fno-spring-exceptions"
block|,
literal|"-fdefault-inline"
block|,
literal|"-fno-default-inline"
block|,
literal|"-fenum-int-equiv"
block|,
literal|"-fno-enum-int-equiv"
block|,
literal|"-fdossier"
block|,
literal|"-fno-dossier"
block|,
literal|"-fxref"
block|,
literal|"-fno-xref"
block|,
literal|"-fnonnull-objects"
block|,
literal|"-fno-nonnull-objects"
block|,
literal|"-fimplement-inlines"
block|,
literal|"-fno-implement-inlines"
block|,
literal|"-Wreturn-type"
block|,
literal|"-Wno-return-type"
block|,
literal|"-Woverloaded-virtual"
block|,
literal|"-Wno-overloaded-virtual"
block|,
literal|"-Wenum-clash"
block|,
literal|"-Wno-enum-clash"
block|,
literal|"-Wtemplate-debugging"
block|,
literal|"-Wno-template-debugging"
block|,
comment|/* these are for obj c */
literal|"-lang-objc"
block|,
literal|"-gen-decls"
block|,
literal|"-fgnu-runtime"
block|,
literal|"-fno-gnu-runtime"
block|,
literal|"-fnext-runtime"
block|,
literal|"-fno-next-runtime"
block|,
literal|"-Wselector"
block|,
literal|"-Wno-selector"
block|,
literal|"-Wprotocol"
block|,
literal|"-Wno-protocol"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Options controlling warnings */
end_comment

begin_comment
comment|/* Don't print warning messages.  -w.  */
end_comment

begin_decl_stmt
name|int
name|inhibit_warnings
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print various extra warnings.  -W.  */
end_comment

begin_decl_stmt
name|int
name|extra_warnings
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Treat warnings as errors.  -Werror.  */
end_comment

begin_decl_stmt
name|int
name|warnings_are_errors
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero to warn about unused local variables.  */
end_comment

begin_decl_stmt
name|int
name|warn_unused
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero to warn about variables used before they are initialized.  */
end_comment

begin_decl_stmt
name|int
name|warn_uninitialized
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn about all declarations which shadow others.   */
end_comment

begin_decl_stmt
name|int
name|warn_shadow
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Warn if a switch on an enum fails to have a case for every enum value.  */
end_comment

begin_decl_stmt
name|int
name|warn_switch
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn about function definitions that default the return type    or that use a null return and have a return-type other than void.  */
end_comment

begin_decl_stmt
name|int
name|warn_return_type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn about pointer casts that increase the required    alignment of the target type (and might therefore lead to a crash    due to a misaligned access).  */
end_comment

begin_decl_stmt
name|int
name|warn_cast_align
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn about any identifiers that match in the first N    characters.  The value N is in `id_clash_len'.  */
end_comment

begin_decl_stmt
name|int
name|warn_id_clash
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|id_clash_len
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn if inline function is too large.  */
end_comment

begin_decl_stmt
name|int
name|warn_inline
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Warn if a function returns an aggregate,    since there are often incompatible calling conventions for doing this.  */
end_comment

begin_decl_stmt
name|int
name|warn_aggregate_return
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Likewise for -W.  */
end_comment

begin_struct
struct|struct
block|{
name|char
modifier|*
name|string
decl_stmt|;
name|int
modifier|*
name|variable
decl_stmt|;
name|int
name|on_value
decl_stmt|;
block|}
name|W_options
index|[]
init|=
block|{
block|{
literal|"unused"
block|,
operator|&
name|warn_unused
block|,
literal|1
block|}
block|,
block|{
literal|"error"
block|,
operator|&
name|warnings_are_errors
block|,
literal|1
block|}
block|,
block|{
literal|"shadow"
block|,
operator|&
name|warn_shadow
block|,
literal|1
block|}
block|,
block|{
literal|"switch"
block|,
operator|&
name|warn_switch
block|,
literal|1
block|}
block|,
block|{
literal|"aggregate-return"
block|,
operator|&
name|warn_aggregate_return
block|,
literal|1
block|}
block|,
block|{
literal|"cast-align"
block|,
operator|&
name|warn_cast_align
block|,
literal|1
block|}
block|,
block|{
literal|"uninitialized"
block|,
operator|&
name|warn_uninitialized
block|,
literal|1
block|}
block|,
block|{
literal|"inline"
block|,
operator|&
name|warn_inline
block|,
literal|1
block|}
block|}
struct|;
end_struct

begin_escape
end_escape

begin_comment
comment|/* Output files for assembler code (real compiler output)    and debugging dumps.  */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|asm_out_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|aux_info_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|rtl_dump_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|jump_opt_dump_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|cse_dump_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|loop_dump_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|cse2_dump_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|flow_dump_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|combine_dump_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|sched_dump_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|local_reg_dump_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|global_reg_dump_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|sched2_dump_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|jump2_opt_dump_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|dbr_sched_dump_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|stack_reg_dump_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Time accumulators, to count the total time spent in various passes.  */
end_comment

begin_decl_stmt
name|int
name|parse_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|varconst_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|integration_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|jump_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cse_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|loop_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cse2_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flow_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|combine_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sched_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|local_alloc_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|global_alloc_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sched2_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dbr_sched_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|shorten_branch_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|stack_reg_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|final_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|symout_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dump_time
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Return time used so far, in microseconds.  */
end_comment

begin_function
name|int
name|get_run_time
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|USG
name|struct
name|tms
name|tms
decl_stmt|;
else|#
directive|else
ifndef|#
directive|ifndef
name|VMS
name|struct
name|rusage
name|rusage
decl_stmt|;
else|#
directive|else
comment|/* VMS */
struct|struct
block|{
name|int
name|proc_user_time
decl_stmt|;
name|int
name|proc_system_time
decl_stmt|;
name|int
name|child_user_time
decl_stmt|;
name|int
name|child_system_time
decl_stmt|;
block|}
name|vms_times
struct|;
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
name|quiet_flag
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|USG
name|times
argument_list|(
operator|&
name|tms
argument_list|)
expr_stmt|;
return|return
operator|(
name|tms
operator|.
name|tms_utime
operator|+
name|tms
operator|.
name|tms_stime
operator|)
operator|*
operator|(
literal|1000000
operator|/
name|HZ
operator|)
return|;
else|#
directive|else
ifndef|#
directive|ifndef
name|VMS
name|getrusage
argument_list|(
literal|0
argument_list|,
operator|&
name|rusage
argument_list|)
expr_stmt|;
return|return
operator|(
name|rusage
operator|.
name|ru_utime
operator|.
name|tv_sec
operator|*
literal|1000000
operator|+
name|rusage
operator|.
name|ru_utime
operator|.
name|tv_usec
operator|+
name|rusage
operator|.
name|ru_stime
operator|.
name|tv_sec
operator|*
literal|1000000
operator|+
name|rusage
operator|.
name|ru_stime
operator|.
name|tv_usec
operator|)
return|;
else|#
directive|else
comment|/* VMS */
name|times
argument_list|(
operator|&
name|vms_times
argument_list|)
expr_stmt|;
return|return
operator|(
name|vms_times
operator|.
name|proc_user_time
operator|+
name|vms_times
operator|.
name|proc_system_time
operator|)
operator|*
literal|10000
return|;
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function

begin_define
define|#
directive|define
name|TIMEVAR
parameter_list|(
name|VAR
parameter_list|,
name|BODY
parameter_list|)
define|\
value|do { int otime = get_run_time (); BODY; VAR += get_run_time () - otime; } while (0)
end_define

begin_function
name|void
name|print_time
parameter_list|(
name|str
parameter_list|,
name|total
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|total
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"time in %s: %d.%06d\n"
argument_list|,
name|str
argument_list|,
name|total
operator|/
literal|1000000
argument_list|,
name|total
operator|%
literal|1000000
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Count an error or warning.  Return 1 if the message should be printed.  */
end_comment

begin_function
name|int
name|count_error
parameter_list|(
name|warningp
parameter_list|)
name|int
name|warningp
decl_stmt|;
block|{
if|if
condition|(
name|warningp
operator|&&
name|inhibit_warnings
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|warningp
operator|&&
operator|!
name|warnings_are_errors
condition|)
name|warningcount
operator|++
expr_stmt|;
else|else
block|{
specifier|static
name|int
name|warning_message
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|warningp
operator|&&
operator|!
name|warning_message
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: warnings being treated as errors\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|warning_message
operator|=
literal|1
expr_stmt|;
block|}
name|errorcount
operator|++
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Print a fatal error message.  NAME is the text.    Also include a system error message based on `errno'.  */
end_comment

begin_function
name|void
name|pfatal_with_name
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|35
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fatal_io_error
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s: I/O error\n"
argument_list|,
name|progname
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|35
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fatal
parameter_list|(
name|s
parameter_list|,
name|v
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|v
decl_stmt|;
block|{
name|error
argument_list|(
name|s
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|34
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called to give a better error message when we don't have an insn to match    what we are looking for or if the insn's constraints aren't satisfied,    rather than just calling abort().  */
end_comment

begin_function
name|void
name|fatal_insn_not_found
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
if|if
condition|(
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"internal error--unrecognizable insn:"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"internal error--insn does not satisfy its constraints:"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|debug_rtx
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|asm_out_file
condition|)
name|fflush
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|aux_info_file
condition|)
name|fflush
argument_list|(
name|aux_info_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fflush
argument_list|(
name|rtl_dump_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|jump_opt_dump_file
condition|)
name|fflush
argument_list|(
name|jump_opt_dump_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|cse_dump_file
condition|)
name|fflush
argument_list|(
name|cse_dump_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop_dump_file
condition|)
name|fflush
argument_list|(
name|loop_dump_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|cse2_dump_file
condition|)
name|fflush
argument_list|(
name|cse2_dump_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|flow_dump_file
condition|)
name|fflush
argument_list|(
name|flow_dump_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|combine_dump_file
condition|)
name|fflush
argument_list|(
name|combine_dump_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|sched_dump_file
condition|)
name|fflush
argument_list|(
name|sched_dump_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_reg_dump_file
condition|)
name|fflush
argument_list|(
name|local_reg_dump_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|global_reg_dump_file
condition|)
name|fflush
argument_list|(
name|global_reg_dump_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|sched2_dump_file
condition|)
name|fflush
argument_list|(
name|sched2_dump_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|jump2_opt_dump_file
condition|)
name|fflush
argument_list|(
name|jump2_opt_dump_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbr_sched_dump_file
condition|)
name|fflush
argument_list|(
name|dbr_sched_dump_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|stack_reg_dump_file
condition|)
name|fflush
argument_list|(
name|stack_reg_dump_file
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is the default decl_printable_name function.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|decl_name
parameter_list|(
name|decl
parameter_list|,
name|kind
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|char
modifier|*
modifier|*
name|kind
decl_stmt|;
block|{
return|return
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|int
name|need_error_newline
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function of last error message;    more generally, function such that if next error message is in it    then we don't have to mention the function name.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|last_error_function
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used to detect when input_file_stack has changed since last described.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|last_error_tick
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Called when the start of a function definition is parsed,    this function prints on stderr the name of the function.  */
end_comment

begin_function
name|void
name|announce_function
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|quiet_flag
condition|)
block|{
name|char
modifier|*
name|junk
decl_stmt|;
if|if
condition|(
name|rtl_dump_and_exit
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s "
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %s"
argument_list|,
call|(
modifier|*
name|decl_printable_name
call|)
argument_list|(
name|decl
argument_list|,
operator|&
name|junk
argument_list|)
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|need_error_newline
operator|=
literal|1
expr_stmt|;
name|last_error_function
operator|=
name|current_function_decl
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Prints out, if necessary, the name of the current function    which caused an error.  Called from all error and warning functions.  */
end_comment

begin_function
name|void
name|report_error_function
parameter_list|(
name|file
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
block|{
name|struct
name|file_stack
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|need_error_newline
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|need_error_newline
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|last_error_function
operator|!=
name|current_function_decl
condition|)
block|{
name|char
modifier|*
name|kind
init|=
literal|"function"
decl_stmt|;
if|if
condition|(
name|current_function_decl
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|kind
operator|=
literal|"method"
expr_stmt|;
if|if
condition|(
name|file
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_function_decl
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"At top level:\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|name
init|=
call|(
modifier|*
name|decl_printable_name
call|)
argument_list|(
name|current_function_decl
argument_list|,
operator|&
name|kind
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"In %s `%s':\n"
argument_list|,
name|kind
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|last_error_function
operator|=
name|current_function_decl
expr_stmt|;
block|}
if|if
condition|(
name|input_file_stack
operator|&&
name|input_file_stack
operator|->
name|next
operator|!=
literal|0
operator|&&
name|input_file_stack_tick
operator|!=
name|last_error_tick
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"In file included"
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|input_file_stack
operator|->
name|next
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" from %s:%d"
argument_list|,
name|p
operator|->
name|name
argument_list|,
name|p
operator|->
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|next
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|","
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|":\n"
argument_list|)
expr_stmt|;
name|last_error_tick
operator|=
name|input_file_stack_tick
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Report an error at the current line number.    S is a string and V and V2 are args for `printf'.  We use HOST_WIDE_INT    as the type for these args assuming it is wide enough to hold a    pointer.  This isn't terribly portable, but is the best we can do    without vprintf universally available.  */
end_comment

begin_function
name|void
name|error
parameter_list|(
name|s
parameter_list|,
name|v
parameter_list|,
name|v2
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|HOST_WIDE_INT
name|v
decl_stmt|;
comment|/* Also used as pointer */
name|HOST_WIDE_INT
name|v2
decl_stmt|;
comment|/* Also used as pointer */
block|{
name|error_with_file_and_line
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|s
argument_list|,
name|v
argument_list|,
name|v2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Report an error at line LINE of file FILE.    S and V are a string and an arg for `printf'.  */
end_comment

begin_function
name|void
name|error_with_file_and_line
parameter_list|(
name|file
parameter_list|,
name|line
parameter_list|,
name|s
parameter_list|,
name|v
parameter_list|,
name|v2
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|HOST_WIDE_INT
name|v
decl_stmt|;
name|HOST_WIDE_INT
name|v2
decl_stmt|;
block|{
name|count_error
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|report_error_function
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: "
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|s
argument_list|,
name|v
argument_list|,
name|v2
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Report an error at the declaration DECL.    S and V are a string and an arg which uses %s to substitute    the declaration name.  */
end_comment

begin_function
name|void
name|error_with_decl
parameter_list|(
name|decl
parameter_list|,
name|s
parameter_list|,
name|v
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|HOST_WIDE_INT
name|v
decl_stmt|;
block|{
name|char
modifier|*
name|junk
decl_stmt|;
name|count_error
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|report_error_function
argument_list|(
name|DECL_SOURCE_FILE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: "
argument_list|,
name|DECL_SOURCE_FILE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|s
argument_list|,
call|(
modifier|*
name|decl_printable_name
call|)
argument_list|(
name|decl
argument_list|,
operator|&
name|junk
argument_list|)
argument_list|,
name|v
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|s
argument_list|,
literal|"((anonymous))"
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Report an error at the line number of the insn INSN.    S and V are a string and an arg for `printf'.    This is used only when INSN is an `asm' with operands,    and each ASM_OPERANDS records its own source file and line.  */
end_comment

begin_function
name|void
name|error_for_asm
parameter_list|(
name|insn
parameter_list|,
name|s
parameter_list|,
name|v
parameter_list|,
name|v2
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|HOST_WIDE_INT
name|v
decl_stmt|;
comment|/* Also used as pointer */
name|HOST_WIDE_INT
name|v2
decl_stmt|;
comment|/* Also used as pointer */
block|{
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|line
decl_stmt|;
name|rtx
name|body
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|asmop
decl_stmt|;
comment|/* Find the (or one of the) ASM_OPERANDS in the insn.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|ASM_OPERANDS
condition|)
name|asmop
operator|=
name|SET_SRC
argument_list|(
name|body
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|ASM_OPERANDS
condition|)
name|asmop
operator|=
name|body
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
name|asmop
operator|=
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ASM_OPERANDS
condition|)
name|asmop
operator|=
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|filename
operator|=
name|ASM_OPERANDS_SOURCE_FILE
argument_list|(
name|asmop
argument_list|)
expr_stmt|;
name|line
operator|=
name|ASM_OPERANDS_SOURCE_LINE
argument_list|(
name|asmop
argument_list|)
expr_stmt|;
name|error_with_file_and_line
argument_list|(
name|filename
argument_list|,
name|line
argument_list|,
name|s
argument_list|,
name|v
argument_list|,
name|v2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Report a warning at line LINE.    S and V are a string and an arg for `printf'.  */
end_comment

begin_function
name|void
name|warning_with_file_and_line
parameter_list|(
name|file
parameter_list|,
name|line
parameter_list|,
name|s
parameter_list|,
name|v
parameter_list|,
name|v2
parameter_list|,
name|v3
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|HOST_WIDE_INT
name|v
decl_stmt|,
name|v2
decl_stmt|,
name|v3
decl_stmt|;
block|{
if|if
condition|(
name|count_error
argument_list|(
literal|1
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|report_error_function
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: "
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"warning: "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|s
argument_list|,
name|v
argument_list|,
name|v2
argument_list|,
name|v3
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Report a warning at the current line number.    S and V are a string and an arg for `printf'.  */
end_comment

begin_function
name|void
name|warning
parameter_list|(
name|s
parameter_list|,
name|v
parameter_list|,
name|v2
parameter_list|,
name|v3
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|HOST_WIDE_INT
name|v
decl_stmt|,
name|v2
decl_stmt|,
name|v3
decl_stmt|;
comment|/* Also used as pointer */
block|{
name|warning_with_file_and_line
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|s
argument_list|,
name|v
argument_list|,
name|v2
argument_list|,
name|v3
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Report a warning at the declaration DECL.    S is string which uses %s to substitute the declaration name.    V is a second parameter that S can refer to.  */
end_comment

begin_function
name|void
name|warning_with_decl
parameter_list|(
name|decl
parameter_list|,
name|s
parameter_list|,
name|v
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|HOST_WIDE_INT
name|v
decl_stmt|;
block|{
name|char
modifier|*
name|junk
decl_stmt|;
if|if
condition|(
name|count_error
argument_list|(
literal|1
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|report_error_function
argument_list|(
name|DECL_SOURCE_FILE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: "
argument_list|,
name|DECL_SOURCE_FILE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"warning: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|s
argument_list|,
call|(
modifier|*
name|decl_printable_name
call|)
argument_list|(
name|decl
argument_list|,
operator|&
name|junk
argument_list|)
argument_list|,
name|v
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|s
argument_list|,
literal|"((anonymous))"
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Report a warning at the line number of the insn INSN.    S and V are a string and an arg for `printf'.    This is used only when INSN is an `asm' with operands,    and each ASM_OPERANDS records its own source file and line.  */
end_comment

begin_function
name|void
name|warning_for_asm
parameter_list|(
name|insn
parameter_list|,
name|s
parameter_list|,
name|v
parameter_list|,
name|v2
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|HOST_WIDE_INT
name|v
decl_stmt|;
comment|/* Also used as pointer */
name|HOST_WIDE_INT
name|v2
decl_stmt|;
comment|/* Also used as pointer */
block|{
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|line
decl_stmt|;
name|rtx
name|body
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|asmop
decl_stmt|;
comment|/* Find the (or one of the) ASM_OPERANDS in the insn.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|ASM_OPERANDS
condition|)
name|asmop
operator|=
name|SET_SRC
argument_list|(
name|body
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|ASM_OPERANDS
condition|)
name|asmop
operator|=
name|body
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
name|asmop
operator|=
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ASM_OPERANDS
condition|)
name|asmop
operator|=
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|filename
operator|=
name|ASM_OPERANDS_SOURCE_FILE
argument_list|(
name|asmop
argument_list|)
expr_stmt|;
name|line
operator|=
name|ASM_OPERANDS_SOURCE_LINE
argument_list|(
name|asmop
argument_list|)
expr_stmt|;
name|warning_with_file_and_line
argument_list|(
name|filename
argument_list|,
name|line
argument_list|,
name|s
argument_list|,
name|v
argument_list|,
name|v2
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* These functions issue either warnings or errors depending on    -pedantic-errors.  */
end_comment

begin_function
name|void
name|pedwarn
parameter_list|(
name|s
parameter_list|,
name|v
parameter_list|,
name|v2
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|HOST_WIDE_INT
name|v
decl_stmt|;
comment|/* Also used as pointer */
name|HOST_WIDE_INT
name|v2
decl_stmt|;
block|{
if|if
condition|(
name|flag_pedantic_errors
condition|)
name|error
argument_list|(
name|s
argument_list|,
name|v
argument_list|,
name|v2
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
name|s
argument_list|,
name|v
argument_list|,
name|v2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pedwarn_with_decl
parameter_list|(
name|decl
parameter_list|,
name|s
parameter_list|,
name|v
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|HOST_WIDE_INT
name|v
decl_stmt|;
block|{
if|if
condition|(
name|flag_pedantic_errors
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
name|s
argument_list|,
name|v
argument_list|)
expr_stmt|;
else|else
name|warning_with_decl
argument_list|(
name|decl
argument_list|,
name|s
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pedwarn_with_file_and_line
parameter_list|(
name|file
parameter_list|,
name|line
parameter_list|,
name|s
parameter_list|,
name|v
parameter_list|,
name|v2
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|HOST_WIDE_INT
name|v
decl_stmt|;
name|HOST_WIDE_INT
name|v2
decl_stmt|;
block|{
if|if
condition|(
name|flag_pedantic_errors
condition|)
name|error_with_file_and_line
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|s
argument_list|,
name|v
argument_list|,
name|v2
argument_list|)
expr_stmt|;
else|else
name|warning_with_file_and_line
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|s
argument_list|,
name|v
argument_list|,
name|v2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Apologize for not implementing some feature.    S, V, and V2 are a string and args for `printf'.  */
end_comment

begin_function
name|void
name|sorry
parameter_list|(
name|s
parameter_list|,
name|v
parameter_list|,
name|v2
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|HOST_WIDE_INT
name|v
decl_stmt|,
name|v2
decl_stmt|;
block|{
name|sorrycount
operator|++
expr_stmt|;
if|if
condition|(
name|input_filename
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: "
argument_list|,
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"sorry, not implemented: "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|s
argument_list|,
name|v
argument_list|,
name|v2
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Apologize for not implementing some feature, then quit.    S, V, and V2 are a string and args for `printf'.  */
end_comment

begin_function
name|void
name|really_sorry
parameter_list|(
name|s
parameter_list|,
name|v
parameter_list|,
name|v2
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|HOST_WIDE_INT
name|v
decl_stmt|,
name|v2
decl_stmt|;
block|{
if|if
condition|(
name|input_filename
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: "
argument_list|,
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"sorry, not implemented: "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|s
argument_list|,
name|v
argument_list|,
name|v2
argument_list|)
expr_stmt|;
name|fatal
argument_list|(
literal|" (fatal)\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* More 'friendly' abort that prints the line and file.    config.h can #define abort fancy_abort if you like that sort of thing.     I don't think this is actually a good idea.    Other sorts of crashes will look a certain way.    It is a good thing if crashes from calling abort look the same way.      -- RMS  */
end_comment

begin_function
name|void
name|fancy_abort
parameter_list|()
block|{
name|fatal
argument_list|(
literal|"internal gcc abort"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This calls abort and is used to avoid problems when abort if a macro.    It is used when we need to pass the address of abort.  */
end_comment

begin_function
name|void
name|do_abort
parameter_list|()
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* When `malloc.c' is compiled with `rcheck' defined,    it calls this function to report clobberage.  */
end_comment

begin_function
name|void
name|botch
parameter_list|(
name|s
parameter_list|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Same as `malloc' but report error if no memory available.  */
end_comment

begin_function
name|char
modifier|*
name|xmalloc
parameter_list|(
name|size
parameter_list|)
name|unsigned
name|size
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|value
init|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"virtual memory exhausted"
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/* Same as `realloc' but report error if no memory available.  */
end_comment

begin_function
name|char
modifier|*
name|xrealloc
parameter_list|(
name|ptr
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|char
modifier|*
name|result
init|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
name|fatal
argument_list|(
literal|"virtual memory exhausted"
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the logarithm of X, base 2, considering X unsigned,    if X is a power of 2.  Otherwise, returns -1.     This should be used via the `exact_log2' macro.  */
end_comment

begin_function
name|int
name|exact_log2_wide
parameter_list|(
name|x
parameter_list|)
specifier|register
name|unsigned
name|HOST_WIDE_INT
name|x
decl_stmt|;
block|{
specifier|register
name|int
name|log
init|=
literal|0
decl_stmt|;
comment|/* Test for 0 or a power of 2.  */
if|if
condition|(
name|x
operator|==
literal|0
operator|||
name|x
operator|!=
operator|(
name|x
operator|&
operator|-
name|x
operator|)
condition|)
return|return
operator|-
literal|1
return|;
while|while
condition|(
operator|(
name|x
operator|>>=
literal|1
operator|)
operator|!=
literal|0
condition|)
name|log
operator|++
expr_stmt|;
return|return
name|log
return|;
block|}
end_function

begin_comment
comment|/* Given X, an unsigned number, return the largest int Y such that 2**Y<= X.    If X is 0, return -1.     This should be used via the floor_log2 macro.  */
end_comment

begin_function
name|int
name|floor_log2_wide
parameter_list|(
name|x
parameter_list|)
specifier|register
name|unsigned
name|HOST_WIDE_INT
name|x
decl_stmt|;
block|{
specifier|register
name|int
name|log
init|=
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|x
operator|!=
literal|0
condition|)
name|log
operator|++
operator|,
name|x
operator|>>=
literal|1
expr_stmt|;
return|return
name|log
return|;
block|}
end_function

begin_decl_stmt
name|int
name|float_handled
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|jmp_buf
name|float_handler
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Specify where to longjmp to when a floating arithmetic error happens.    If HANDLER is 0, it means don't handle the errors any more.  */
end_comment

begin_function
name|void
name|set_float_handler
parameter_list|(
name|handler
parameter_list|)
name|jmp_buf
name|handler
decl_stmt|;
block|{
name|float_handled
operator|=
operator|(
name|handler
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|handler
condition|)
name|bcopy
argument_list|(
name|handler
argument_list|,
name|float_handler
argument_list|,
sizeof|sizeof
argument_list|(
name|float_handler
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Specify, in HANDLER, where to longjmp to when a floating arithmetic    error happens, pushing the previous specification into OLD_HANDLER.    Return an indication of whether there was a previous handler in effect.  */
end_comment

begin_function
name|int
name|push_float_handler
parameter_list|(
name|handler
parameter_list|,
name|old_handler
parameter_list|)
name|jmp_buf
name|handler
decl_stmt|,
name|old_handler
decl_stmt|;
block|{
name|int
name|was_handled
init|=
name|float_handled
decl_stmt|;
name|float_handled
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|was_handled
condition|)
name|bcopy
argument_list|(
name|float_handler
argument_list|,
name|old_handler
argument_list|,
sizeof|sizeof
argument_list|(
name|float_handler
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|handler
argument_list|,
name|float_handler
argument_list|,
sizeof|sizeof
argument_list|(
name|float_handler
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|was_handled
return|;
block|}
end_function

begin_comment
comment|/* Restore the previous specification of whether and where to longjmp to    when a floating arithmetic error happens.  */
end_comment

begin_function
name|void
name|pop_float_handler
parameter_list|(
name|handled
parameter_list|,
name|handler
parameter_list|)
name|int
name|handled
decl_stmt|;
name|jmp_buf
name|handler
decl_stmt|;
block|{
name|float_handled
operator|=
name|handled
expr_stmt|;
if|if
condition|(
name|handled
condition|)
name|bcopy
argument_list|(
name|handler
argument_list|,
name|float_handler
argument_list|,
sizeof|sizeof
argument_list|(
name|float_handler
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Signals actually come here.  */
end_comment

begin_function
specifier|static
name|void
name|float_signal
parameter_list|(
name|signo
parameter_list|)
comment|/* If this is missing, some compilers complain.  */
name|int
name|signo
decl_stmt|;
block|{
if|if
condition|(
name|float_handled
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|USG
argument_list|)
operator|||
name|defined
argument_list|(
name|hpux
argument_list|)
name|signal
argument_list|(
name|SIGFPE
argument_list|,
name|float_signal
argument_list|)
expr_stmt|;
comment|/* re-enable the signal catcher */
endif|#
directive|endif
name|float_handled
operator|=
literal|0
expr_stmt|;
name|signal
argument_list|(
name|SIGFPE
argument_list|,
name|float_signal
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|float_handler
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handler for SIGPIPE.  */
end_comment

begin_function
specifier|static
name|void
name|pipe_closed
parameter_list|(
name|signo
parameter_list|)
comment|/* If this is missing, some compilers complain.  */
name|int
name|signo
decl_stmt|;
block|{
name|fatal
argument_list|(
literal|"output pipe has been closed"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Strip off a legitimate source ending from the input string NAME of    length LEN. */
end_comment

begin_function
name|void
name|strip_off_ending
parameter_list|(
name|name
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
if|if
condition|(
name|len
operator|>
literal|2
operator|&&
operator|!
name|strcmp
argument_list|(
literal|".c"
argument_list|,
name|name
operator|+
name|len
operator|-
literal|2
argument_list|)
condition|)
name|name
index|[
name|len
operator|-
literal|2
index|]
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|len
operator|>
literal|2
operator|&&
operator|!
name|strcmp
argument_list|(
literal|".m"
argument_list|,
name|name
operator|+
name|len
operator|-
literal|2
argument_list|)
condition|)
name|name
index|[
name|len
operator|-
literal|2
index|]
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|len
operator|>
literal|2
operator|&&
operator|!
name|strcmp
argument_list|(
literal|".i"
argument_list|,
name|name
operator|+
name|len
operator|-
literal|2
argument_list|)
condition|)
name|name
index|[
name|len
operator|-
literal|2
index|]
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|len
operator|>
literal|3
operator|&&
operator|!
name|strcmp
argument_list|(
literal|".ii"
argument_list|,
name|name
operator|+
name|len
operator|-
literal|3
argument_list|)
condition|)
name|name
index|[
name|len
operator|-
literal|3
index|]
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|len
operator|>
literal|3
operator|&&
operator|!
name|strcmp
argument_list|(
literal|".co"
argument_list|,
name|name
operator|+
name|len
operator|-
literal|3
argument_list|)
condition|)
name|name
index|[
name|len
operator|-
literal|3
index|]
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|len
operator|>
literal|3
operator|&&
operator|!
name|strcmp
argument_list|(
literal|".cc"
argument_list|,
name|name
operator|+
name|len
operator|-
literal|3
argument_list|)
condition|)
name|name
index|[
name|len
operator|-
literal|3
index|]
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|len
operator|>
literal|2
operator|&&
operator|!
name|strcmp
argument_list|(
literal|".C"
argument_list|,
name|name
operator|+
name|len
operator|-
literal|2
argument_list|)
condition|)
name|name
index|[
name|len
operator|-
literal|2
index|]
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|len
operator|>
literal|4
operator|&&
operator|!
name|strcmp
argument_list|(
literal|".cxx"
argument_list|,
name|name
operator|+
name|len
operator|-
literal|4
argument_list|)
condition|)
name|name
index|[
name|len
operator|-
literal|4
index|]
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|len
operator|>
literal|2
operator|&&
operator|!
name|strcmp
argument_list|(
literal|".f"
argument_list|,
name|name
operator|+
name|len
operator|-
literal|2
argument_list|)
condition|)
name|name
index|[
name|len
operator|-
literal|2
index|]
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|len
operator|>
literal|4
operator|&&
operator|!
name|strcmp
argument_list|(
literal|".ada"
argument_list|,
name|name
operator|+
name|len
operator|-
literal|4
argument_list|)
condition|)
name|name
index|[
name|len
operator|-
literal|4
index|]
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|len
operator|>
literal|4
operator|&&
operator|!
name|strcmp
argument_list|(
literal|".atr"
argument_list|,
name|name
operator|+
name|len
operator|-
literal|4
argument_list|)
condition|)
name|name
index|[
name|len
operator|-
literal|4
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output a file name in the form wanted by System V.  */
end_comment

begin_function
name|void
name|output_file_directive
parameter_list|(
name|asm_file
parameter_list|,
name|input_name
parameter_list|)
name|FILE
modifier|*
name|asm_file
decl_stmt|;
name|char
modifier|*
name|input_name
decl_stmt|;
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|input_name
argument_list|)
decl_stmt|;
name|char
modifier|*
name|na
init|=
name|input_name
operator|+
name|len
decl_stmt|;
comment|/* NA gets INPUT_NAME sans directory names.  */
while|while
condition|(
name|na
operator|>
name|input_name
condition|)
block|{
if|if
condition|(
name|na
index|[
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
break|break;
name|na
operator|--
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ASM_OUTPUT_MAIN_SOURCE_FILENAME
name|ASM_OUTPUT_MAIN_SOURCE_FILENAME
argument_list|(
name|asm_file
argument_list|,
name|na
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|ASM_OUTPUT_SOURCE_FILENAME
name|ASM_OUTPUT_SOURCE_FILENAME
argument_list|(
name|asm_file
argument_list|,
name|na
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|asm_file
argument_list|,
literal|"\t.file\t\"%s\"\n"
argument_list|,
name|na
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Routine to build language identifier for object file. */
end_comment

begin_function
specifier|static
name|void
name|output_lang_identify
parameter_list|(
name|asm_out_file
parameter_list|)
name|FILE
modifier|*
name|asm_out_file
decl_stmt|;
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|lang_identify
argument_list|()
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
literal|"__gnu_compiled_"
argument_list|)
operator|+
literal|1
decl_stmt|;
name|char
modifier|*
name|s
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"__gnu_compiled_%s"
argument_list|,
name|lang_identify
argument_list|()
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compile an entire file of output from cpp, named NAME.    Write a file of assembly output and various debugging dumps.  */
end_comment

begin_function
specifier|static
name|void
name|compile_file
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|tree
name|globals
decl_stmt|;
name|int
name|start_time
decl_stmt|;
name|int
name|dump_base_name_length
decl_stmt|;
name|int
name|name_specified
init|=
name|name
operator|!=
literal|0
decl_stmt|;
if|if
condition|(
name|dump_base_name
operator|==
literal|0
condition|)
name|dump_base_name
operator|=
name|name
condition|?
name|name
else|:
literal|"gccdump"
expr_stmt|;
name|dump_base_name_length
operator|=
name|strlen
argument_list|(
name|dump_base_name
argument_list|)
expr_stmt|;
name|parse_time
operator|=
literal|0
expr_stmt|;
name|varconst_time
operator|=
literal|0
expr_stmt|;
name|integration_time
operator|=
literal|0
expr_stmt|;
name|jump_time
operator|=
literal|0
expr_stmt|;
name|cse_time
operator|=
literal|0
expr_stmt|;
name|loop_time
operator|=
literal|0
expr_stmt|;
name|cse2_time
operator|=
literal|0
expr_stmt|;
name|flow_time
operator|=
literal|0
expr_stmt|;
name|combine_time
operator|=
literal|0
expr_stmt|;
name|sched_time
operator|=
literal|0
expr_stmt|;
name|local_alloc_time
operator|=
literal|0
expr_stmt|;
name|global_alloc_time
operator|=
literal|0
expr_stmt|;
name|sched2_time
operator|=
literal|0
expr_stmt|;
name|dbr_sched_time
operator|=
literal|0
expr_stmt|;
name|shorten_branch_time
operator|=
literal|0
expr_stmt|;
name|stack_reg_time
operator|=
literal|0
expr_stmt|;
name|final_time
operator|=
literal|0
expr_stmt|;
name|symout_time
operator|=
literal|0
expr_stmt|;
name|dump_time
operator|=
literal|0
expr_stmt|;
comment|/* Open input file.  */
if|if
condition|(
name|name
operator|==
literal|0
operator|||
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"-"
argument_list|)
condition|)
block|{
name|finput
operator|=
name|stdin
expr_stmt|;
name|name
operator|=
literal|"stdin"
expr_stmt|;
block|}
else|else
name|finput
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|finput
operator|==
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IO_BUFFER_SIZE
name|setvbuf
argument_list|(
name|finput
argument_list|,
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|IO_BUFFER_SIZE
argument_list|)
argument_list|,
name|_IOFBF
argument_list|,
name|IO_BUFFER_SIZE
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Initialize data in various passes.  */
name|init_obstacks
argument_list|()
expr_stmt|;
name|init_tree_codes
argument_list|()
expr_stmt|;
name|init_lex
argument_list|()
expr_stmt|;
name|init_rtl
argument_list|()
expr_stmt|;
name|init_emit_once
argument_list|(
name|debug_info_level
operator|==
name|DINFO_LEVEL_NORMAL
operator|||
name|debug_info_level
operator|==
name|DINFO_LEVEL_VERBOSE
argument_list|)
expr_stmt|;
name|init_decl_processing
argument_list|()
expr_stmt|;
name|init_optabs
argument_list|()
expr_stmt|;
name|init_stmt
argument_list|()
expr_stmt|;
name|init_expmed
argument_list|()
expr_stmt|;
name|init_expr_once
argument_list|()
expr_stmt|;
name|init_loop
argument_list|()
expr_stmt|;
name|init_reload
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag_caller_saves
condition|)
name|init_caller_save
argument_list|()
expr_stmt|;
comment|/* If auxiliary info generation is desired, open the output file.      This goes in the same directory as the source file--unlike      all the other output files.  */
if|if
condition|(
name|flag_gen_aux_info
condition|)
block|{
name|aux_info_file
operator|=
name|fopen
argument_list|(
name|aux_info_file_name
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|aux_info_file
operator|==
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|aux_info_file_name
argument_list|)
expr_stmt|;
block|}
comment|/* If rtl dump desired, open the output file.  */
if|if
condition|(
name|rtl_dump
condition|)
block|{
specifier|register
name|char
modifier|*
name|dumpname
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|dump_base_name_length
operator|+
literal|6
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|dumpname
argument_list|,
name|dump_base_name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|dumpname
argument_list|,
literal|".rtl"
argument_list|)
expr_stmt|;
name|rtl_dump_file
operator|=
name|fopen
argument_list|(
name|dumpname
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
operator|==
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|dumpname
argument_list|)
expr_stmt|;
block|}
comment|/* If jump_opt dump desired, open the output file.  */
if|if
condition|(
name|jump_opt_dump
condition|)
block|{
specifier|register
name|char
modifier|*
name|dumpname
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|dump_base_name_length
operator|+
literal|6
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|dumpname
argument_list|,
name|dump_base_name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|dumpname
argument_list|,
literal|".jump"
argument_list|)
expr_stmt|;
name|jump_opt_dump_file
operator|=
name|fopen
argument_list|(
name|dumpname
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|jump_opt_dump_file
operator|==
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|dumpname
argument_list|)
expr_stmt|;
block|}
comment|/* If cse dump desired, open the output file.  */
if|if
condition|(
name|cse_dump
condition|)
block|{
specifier|register
name|char
modifier|*
name|dumpname
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|dump_base_name_length
operator|+
literal|6
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|dumpname
argument_list|,
name|dump_base_name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|dumpname
argument_list|,
literal|".cse"
argument_list|)
expr_stmt|;
name|cse_dump_file
operator|=
name|fopen
argument_list|(
name|dumpname
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cse_dump_file
operator|==
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|dumpname
argument_list|)
expr_stmt|;
block|}
comment|/* If loop dump desired, open the output file.  */
if|if
condition|(
name|loop_dump
condition|)
block|{
specifier|register
name|char
modifier|*
name|dumpname
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|dump_base_name_length
operator|+
literal|6
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|dumpname
argument_list|,
name|dump_base_name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|dumpname
argument_list|,
literal|".loop"
argument_list|)
expr_stmt|;
name|loop_dump_file
operator|=
name|fopen
argument_list|(
name|dumpname
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop_dump_file
operator|==
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|dumpname
argument_list|)
expr_stmt|;
block|}
comment|/* If cse2 dump desired, open the output file.  */
if|if
condition|(
name|cse2_dump
condition|)
block|{
specifier|register
name|char
modifier|*
name|dumpname
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|dump_base_name_length
operator|+
literal|6
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|dumpname
argument_list|,
name|dump_base_name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|dumpname
argument_list|,
literal|".cse2"
argument_list|)
expr_stmt|;
name|cse2_dump_file
operator|=
name|fopen
argument_list|(
name|dumpname
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cse2_dump_file
operator|==
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|dumpname
argument_list|)
expr_stmt|;
block|}
comment|/* If flow dump desired, open the output file.  */
if|if
condition|(
name|flow_dump
condition|)
block|{
specifier|register
name|char
modifier|*
name|dumpname
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|dump_base_name_length
operator|+
literal|6
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|dumpname
argument_list|,
name|dump_base_name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|dumpname
argument_list|,
literal|".flow"
argument_list|)
expr_stmt|;
name|flow_dump_file
operator|=
name|fopen
argument_list|(
name|dumpname
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flow_dump_file
operator|==
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|dumpname
argument_list|)
expr_stmt|;
block|}
comment|/* If combine dump desired, open the output file.  */
if|if
condition|(
name|combine_dump
condition|)
block|{
specifier|register
name|char
modifier|*
name|dumpname
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|dump_base_name_length
operator|+
literal|10
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|dumpname
argument_list|,
name|dump_base_name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|dumpname
argument_list|,
literal|".combine"
argument_list|)
expr_stmt|;
name|combine_dump_file
operator|=
name|fopen
argument_list|(
name|dumpname
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|combine_dump_file
operator|==
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|dumpname
argument_list|)
expr_stmt|;
block|}
comment|/* If scheduling dump desired, open the output file.  */
if|if
condition|(
name|sched_dump
condition|)
block|{
specifier|register
name|char
modifier|*
name|dumpname
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|dump_base_name_length
operator|+
literal|7
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|dumpname
argument_list|,
name|dump_base_name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|dumpname
argument_list|,
literal|".sched"
argument_list|)
expr_stmt|;
name|sched_dump_file
operator|=
name|fopen
argument_list|(
name|dumpname
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sched_dump_file
operator|==
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|dumpname
argument_list|)
expr_stmt|;
block|}
comment|/* If local_reg dump desired, open the output file.  */
if|if
condition|(
name|local_reg_dump
condition|)
block|{
specifier|register
name|char
modifier|*
name|dumpname
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|dump_base_name_length
operator|+
literal|6
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|dumpname
argument_list|,
name|dump_base_name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|dumpname
argument_list|,
literal|".lreg"
argument_list|)
expr_stmt|;
name|local_reg_dump_file
operator|=
name|fopen
argument_list|(
name|dumpname
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_reg_dump_file
operator|==
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|dumpname
argument_list|)
expr_stmt|;
block|}
comment|/* If global_reg dump desired, open the output file.  */
if|if
condition|(
name|global_reg_dump
condition|)
block|{
specifier|register
name|char
modifier|*
name|dumpname
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|dump_base_name_length
operator|+
literal|6
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|dumpname
argument_list|,
name|dump_base_name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|dumpname
argument_list|,
literal|".greg"
argument_list|)
expr_stmt|;
name|global_reg_dump_file
operator|=
name|fopen
argument_list|(
name|dumpname
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|global_reg_dump_file
operator|==
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|dumpname
argument_list|)
expr_stmt|;
block|}
comment|/* If 2nd scheduling dump desired, open the output file.  */
if|if
condition|(
name|sched2_dump
condition|)
block|{
specifier|register
name|char
modifier|*
name|dumpname
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|dump_base_name_length
operator|+
literal|8
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|dumpname
argument_list|,
name|dump_base_name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|dumpname
argument_list|,
literal|".sched2"
argument_list|)
expr_stmt|;
name|sched2_dump_file
operator|=
name|fopen
argument_list|(
name|dumpname
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sched2_dump_file
operator|==
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|dumpname
argument_list|)
expr_stmt|;
block|}
comment|/* If jump2_opt dump desired, open the output file.  */
if|if
condition|(
name|jump2_opt_dump
condition|)
block|{
specifier|register
name|char
modifier|*
name|dumpname
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|dump_base_name_length
operator|+
literal|7
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|dumpname
argument_list|,
name|dump_base_name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|dumpname
argument_list|,
literal|".jump2"
argument_list|)
expr_stmt|;
name|jump2_opt_dump_file
operator|=
name|fopen
argument_list|(
name|dumpname
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|jump2_opt_dump_file
operator|==
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|dumpname
argument_list|)
expr_stmt|;
block|}
comment|/* If dbr_sched dump desired, open the output file.  */
if|if
condition|(
name|dbr_sched_dump
condition|)
block|{
specifier|register
name|char
modifier|*
name|dumpname
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|dump_base_name_length
operator|+
literal|7
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|dumpname
argument_list|,
name|dump_base_name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|dumpname
argument_list|,
literal|".dbr"
argument_list|)
expr_stmt|;
name|dbr_sched_dump_file
operator|=
name|fopen
argument_list|(
name|dumpname
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbr_sched_dump_file
operator|==
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|dumpname
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|STACK_REGS
comment|/* If stack_reg dump desired, open the output file.  */
if|if
condition|(
name|stack_reg_dump
condition|)
block|{
specifier|register
name|char
modifier|*
name|dumpname
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|dump_base_name_length
operator|+
literal|10
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|dumpname
argument_list|,
name|dump_base_name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|dumpname
argument_list|,
literal|".stack"
argument_list|)
expr_stmt|;
name|stack_reg_dump_file
operator|=
name|fopen
argument_list|(
name|dumpname
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stack_reg_dump_file
operator|==
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|dumpname
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Open assembler code output file.  */
if|if
condition|(
operator|!
name|name_specified
operator|&&
name|asm_file_name
operator|==
literal|0
condition|)
name|asm_out_file
operator|=
name|stdout
expr_stmt|;
else|else
block|{
specifier|register
name|char
modifier|*
name|dumpname
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|dump_base_name_length
operator|+
literal|6
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|dump_base_name
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|dumpname
argument_list|,
name|dump_base_name
argument_list|)
expr_stmt|;
name|strip_off_ending
argument_list|(
name|dumpname
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|dumpname
argument_list|,
literal|".s"
argument_list|)
expr_stmt|;
if|if
condition|(
name|asm_file_name
operator|==
literal|0
condition|)
block|{
name|asm_file_name
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|dumpname
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|asm_file_name
argument_list|,
name|dumpname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|asm_file_name
argument_list|,
literal|"-"
argument_list|)
condition|)
name|asm_out_file
operator|=
name|stdout
expr_stmt|;
else|else
name|asm_out_file
operator|=
name|fopen
argument_list|(
name|asm_file_name
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|asm_out_file
operator|==
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|asm_file_name
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|IO_BUFFER_SIZE
name|setvbuf
argument_list|(
name|asm_out_file
argument_list|,
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|IO_BUFFER_SIZE
argument_list|)
argument_list|,
name|_IOFBF
argument_list|,
name|IO_BUFFER_SIZE
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|input_filename
operator|=
name|name
expr_stmt|;
comment|/* Perform language-specific initialization.      This may set main_input_filename.  */
name|lang_init
argument_list|()
expr_stmt|;
comment|/* If the input doesn't start with a #line, use the input name      as the official input file name.  */
if|if
condition|(
name|main_input_filename
operator|==
literal|0
condition|)
name|main_input_filename
operator|=
name|name
expr_stmt|;
comment|/* Put an entry on the input file stack for the main input file.  */
name|input_file_stack
operator|=
operator|(
expr|struct
name|file_stack
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|file_stack
argument_list|)
argument_list|)
expr_stmt|;
name|input_file_stack
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|input_file_stack
operator|->
name|name
operator|=
name|input_filename
expr_stmt|;
name|ASM_FILE_START
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
comment|/* Output something to inform GDB that this compilation was by GCC.  */
ifndef|#
directive|ifndef
name|ASM_IDENTIFY_GCC
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"gcc2_compiled.:\n"
argument_list|)
expr_stmt|;
else|#
directive|else
name|ASM_IDENTIFY_GCC
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Output something to identify which front-end produced this file. */
ifdef|#
directive|ifdef
name|ASM_IDENTIFY_LANGUAGE
name|ASM_IDENTIFY_LANGUAGE
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ??? Note: There used to be a conditional here    to call assemble_zeros without fail if DBX_DEBUGGING_INFO is defined.    This was to guarantee separation between gcc_compiled. and    the first function, for the sake of dbx on Suns.    However, having the extra zero here confused the Emacs    code for unexec, and might confuse other programs too.    Therefore, I took out that change.    In future versions we should find another way to solve    that dbx problem.  -- rms, 23 May 93.  */
comment|/* Don't let the first function fall at the same address      as gcc_compiled., if profiling.  */
if|if
condition|(
name|profile_flag
operator|||
name|profile_block_flag
condition|)
name|assemble_zeros
argument_list|(
name|UNITS_PER_WORD
argument_list|)
expr_stmt|;
comment|/* If dbx symbol table desired, initialize writing it      and output the predefined types.  */
if|#
directive|if
name|defined
argument_list|(
name|DBX_DEBUGGING_INFO
argument_list|)
operator|||
name|defined
argument_list|(
name|XCOFF_DEBUGGING_INFO
argument_list|)
if|if
condition|(
name|write_symbols
operator|==
name|DBX_DEBUG
operator|||
name|write_symbols
operator|==
name|XCOFF_DEBUG
condition|)
name|TIMEVAR
argument_list|(
name|symout_time
argument_list|,
name|dbxout_init
argument_list|(
name|asm_out_file
argument_list|,
name|main_input_filename
argument_list|,
name|getdecls
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SDB_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|SDB_DEBUG
condition|)
name|TIMEVAR
argument_list|(
name|symout_time
argument_list|,
name|sdbout_init
argument_list|(
name|asm_out_file
argument_list|,
name|main_input_filename
argument_list|,
name|getdecls
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DWARF_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|DWARF_DEBUG
condition|)
name|TIMEVAR
argument_list|(
name|symout_time
argument_list|,
name|dwarfout_init
argument_list|(
name|asm_out_file
argument_list|,
name|main_input_filename
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Initialize yet another pass.  */
name|init_final
argument_list|(
name|main_input_filename
argument_list|)
expr_stmt|;
name|start_time
operator|=
name|get_run_time
argument_list|()
expr_stmt|;
comment|/* Call the parser, which parses the entire file      (calling rest_of_compilation for each function).  */
if|if
condition|(
name|yyparse
argument_list|()
operator|!=
literal|0
condition|)
if|if
condition|(
name|errorcount
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Errors detected in input file (your bison.simple is out of date)"
argument_list|)
expr_stmt|;
comment|/* Compilation is now finished except for writing      what's left of the symbol table output.  */
name|parse_time
operator|+=
name|get_run_time
argument_list|()
operator|-
name|start_time
expr_stmt|;
name|parse_time
operator|-=
name|integration_time
expr_stmt|;
name|parse_time
operator|-=
name|varconst_time
expr_stmt|;
name|globals
operator|=
name|getdecls
argument_list|()
expr_stmt|;
comment|/* Really define vars that have had only a tentative definition.      Really output inline functions that must actually be callable      and have not been output so far.  */
block|{
name|int
name|len
init|=
name|list_length
argument_list|(
name|globals
argument_list|)
decl_stmt|;
name|tree
modifier|*
name|vec
init|=
operator|(
name|tree
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
operator|*
name|len
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|tree
name|decl
decl_stmt|;
comment|/* Process the decls in reverse order--earliest first.        Put them into VEC from back to front, then take out from front.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|decl
operator|=
name|globals
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
operator|,
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
name|vec
index|[
name|len
operator|-
name|i
operator|-
literal|1
index|]
operator|=
name|decl
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|vec
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|&&
name|incomplete_decl_finalize_hook
operator|!=
literal|0
condition|)
call|(
modifier|*
name|incomplete_decl_finalize_hook
call|)
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* Don't write out static consts, unless we used them. 	       (This used to write them out only if the address was 	       taken, but that was wrong; if the variable was simply 	       referred to, it still needs to exist or else it will 	       be undefined in the linker.)  */
if|if
condition|(
operator|!
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|||
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|||
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|||
name|TREE_ADDRESSABLE
argument_list|(
name|decl
argument_list|)
operator|||
name|TREE_ADDRESSABLE
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|rest_of_decl_compilation
argument_list|(
name|decl
argument_list|,
name|NULL_PTR
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
comment|/* Cancel the RTL for this decl so that, if debugging info 		 output for global variables is still to come, 		 this one will be omitted.  */
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|TREE_ADDRESSABLE
argument_list|(
name|decl
argument_list|)
operator|||
name|TREE_ADDRESSABLE
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
name|output_inline_function
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Warn about any function 	   declared static but not defined. 	   We don't warn about variables, 	   because many programs have static variables 	   that exist only to get some text into the object file.  */
if|if
condition|(
operator|(
name|warn_unused
operator|||
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|||
operator|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_USED
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|)
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|pedwarn_with_decl
argument_list|(
name|decl
argument_list|,
literal|"`%s' declared `static' but never defined"
argument_list|)
expr_stmt|;
comment|/* This symbol is effectively an "extern" declaration now.  */
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|assemble_external
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
comment|/* Warn about static fns or vars defined but not used, 	   but not about inline functions 	   since unused inline statics is normal practice.  */
if|if
condition|(
name|warn_unused
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|)
operator|&&
operator|!
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_INLINE
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_REGISTER
argument_list|(
name|decl
argument_list|)
comment|/* The TREE_USED bit for file-scope decls 	       is kept in the identifier, to handle multiple 	       external decls in different scopes.  */
operator|&&
operator|!
name|TREE_USED
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|warning_with_decl
argument_list|(
name|decl
argument_list|,
literal|"`%s' defined but not used"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SDB_DEBUGGING_INFO
comment|/* The COFF linker can move initialized global vars to the end. 	   And that can screw up the symbol ordering. 	   By putting the symbols in that order to begin with, 	   we avoid a problem.  mcsun!unido!fauern!tumuc!pes@uunet.uu.net.  */
if|if
condition|(
name|write_symbols
operator|==
name|SDB_DEBUG
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
condition|)
name|TIMEVAR
argument_list|(
name|symout_time
argument_list|,
name|sdbout_symbol
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Output COFF information for non-global 	   file-scope initialized variables. */
if|if
condition|(
name|write_symbols
operator|==
name|SDB_DEBUG
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
name|TIMEVAR
argument_list|(
name|symout_time
argument_list|,
name|sdbout_toplevel_data
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SDB_DEBUGGING_INFO */
ifdef|#
directive|ifdef
name|DWARF_DEBUGGING_INFO
comment|/* Output DWARF information for file-scope tentative data object 	   declarations, file-scope (extern) function declarations (which 	   had no corresponding body) and file-scope tagged type declarations 	   and definitions which have not yet been forced out.  */
if|if
condition|(
name|write_symbols
operator|==
name|DWARF_DEBUG
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|||
operator|!
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
name|TIMEVAR
argument_list|(
name|symout_time
argument_list|,
name|dwarfout_file_scope_decl
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
comment|/* Do dbx symbols */
if|#
directive|if
name|defined
argument_list|(
name|DBX_DEBUGGING_INFO
argument_list|)
operator|||
name|defined
argument_list|(
name|XCOFF_DEBUGGING_INFO
argument_list|)
if|if
condition|(
name|write_symbols
operator|==
name|DBX_DEBUG
operator|||
name|write_symbols
operator|==
name|XCOFF_DEBUG
condition|)
name|TIMEVAR
argument_list|(
argument|symout_time
argument_list|,
argument|{ 	       dbxout_finish (asm_out_file, main_input_filename); 	     }
argument_list|)
empty_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DWARF_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|DWARF_DEBUG
condition|)
name|TIMEVAR
argument_list|(
argument|symout_time
argument_list|,
argument|{ 	       dwarfout_finish (); 	     }
argument_list|)
empty_stmt|;
endif|#
directive|endif
comment|/* Output some stuff at end of file if nec.  */
name|end_final
argument_list|(
name|main_input_filename
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ASM_FILE_END
name|ASM_FILE_END
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|after_finish_compilation
label|:
comment|/* Language-specific end of compilation actions.  */
name|lang_finish
argument_list|()
expr_stmt|;
comment|/* Close the dump files.  */
if|if
condition|(
name|flag_gen_aux_info
condition|)
block|{
name|fclose
argument_list|(
name|aux_info_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|errorcount
condition|)
name|unlink
argument_list|(
name|aux_info_file_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rtl_dump
condition|)
name|fclose
argument_list|(
name|rtl_dump_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|jump_opt_dump
condition|)
name|fclose
argument_list|(
name|jump_opt_dump_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|cse_dump
condition|)
name|fclose
argument_list|(
name|cse_dump_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop_dump
condition|)
name|fclose
argument_list|(
name|loop_dump_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|cse2_dump
condition|)
name|fclose
argument_list|(
name|cse2_dump_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|flow_dump
condition|)
name|fclose
argument_list|(
name|flow_dump_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|combine_dump
condition|)
block|{
name|dump_combine_total_stats
argument_list|(
name|combine_dump_file
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|combine_dump_file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sched_dump
condition|)
name|fclose
argument_list|(
name|sched_dump_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_reg_dump
condition|)
name|fclose
argument_list|(
name|local_reg_dump_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|global_reg_dump
condition|)
name|fclose
argument_list|(
name|global_reg_dump_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|sched2_dump
condition|)
name|fclose
argument_list|(
name|sched2_dump_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|jump2_opt_dump
condition|)
name|fclose
argument_list|(
name|jump2_opt_dump_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbr_sched_dump
condition|)
name|fclose
argument_list|(
name|dbr_sched_dump_file
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|STACK_REGS
if|if
condition|(
name|stack_reg_dump
condition|)
name|fclose
argument_list|(
name|stack_reg_dump_file
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Close non-debugging input and output files.  Take special care to note      whether fclose returns an error, since the pages might still be on the      buffer chain while the file is open.  */
name|fclose
argument_list|(
name|finput
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|asm_out_file
argument_list|)
operator|!=
literal|0
operator|||
name|fclose
argument_list|(
name|asm_out_file
argument_list|)
operator|!=
literal|0
condition|)
name|fatal_io_error
argument_list|(
name|asm_file_name
argument_list|)
expr_stmt|;
comment|/* Print the times.  */
if|if
condition|(
operator|!
name|quiet_flag
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|print_time
argument_list|(
literal|"parse"
argument_list|,
name|parse_time
argument_list|)
expr_stmt|;
name|print_time
argument_list|(
literal|"integration"
argument_list|,
name|integration_time
argument_list|)
expr_stmt|;
name|print_time
argument_list|(
literal|"jump"
argument_list|,
name|jump_time
argument_list|)
expr_stmt|;
name|print_time
argument_list|(
literal|"cse"
argument_list|,
name|cse_time
argument_list|)
expr_stmt|;
name|print_time
argument_list|(
literal|"loop"
argument_list|,
name|loop_time
argument_list|)
expr_stmt|;
name|print_time
argument_list|(
literal|"cse2"
argument_list|,
name|cse2_time
argument_list|)
expr_stmt|;
name|print_time
argument_list|(
literal|"flow"
argument_list|,
name|flow_time
argument_list|)
expr_stmt|;
name|print_time
argument_list|(
literal|"combine"
argument_list|,
name|combine_time
argument_list|)
expr_stmt|;
name|print_time
argument_list|(
literal|"sched"
argument_list|,
name|sched_time
argument_list|)
expr_stmt|;
name|print_time
argument_list|(
literal|"local-alloc"
argument_list|,
name|local_alloc_time
argument_list|)
expr_stmt|;
name|print_time
argument_list|(
literal|"global-alloc"
argument_list|,
name|global_alloc_time
argument_list|)
expr_stmt|;
name|print_time
argument_list|(
literal|"sched2"
argument_list|,
name|sched2_time
argument_list|)
expr_stmt|;
name|print_time
argument_list|(
literal|"dbranch"
argument_list|,
name|dbr_sched_time
argument_list|)
expr_stmt|;
name|print_time
argument_list|(
literal|"shorten-branch"
argument_list|,
name|shorten_branch_time
argument_list|)
expr_stmt|;
name|print_time
argument_list|(
literal|"stack-reg"
argument_list|,
name|stack_reg_time
argument_list|)
expr_stmt|;
name|print_time
argument_list|(
literal|"final"
argument_list|,
name|final_time
argument_list|)
expr_stmt|;
name|print_time
argument_list|(
literal|"varconst"
argument_list|,
name|varconst_time
argument_list|)
expr_stmt|;
name|print_time
argument_list|(
literal|"symout"
argument_list|,
name|symout_time
argument_list|)
expr_stmt|;
name|print_time
argument_list|(
literal|"dump"
argument_list|,
name|dump_time
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This is called from various places for FUNCTION_DECL, VAR_DECL,    and TYPE_DECL nodes.     This does nothing for local (non-static) variables.    Otherwise, it sets up the RTL and outputs any assembler code    (label definition, storage allocation and initialization).     DECL is the declaration.  If ASMSPEC is nonzero, it specifies    the assembler symbol name to be used.  TOP_LEVEL is nonzero    if this declaration is not within a function.  */
end_comment

begin_function
name|void
name|rest_of_decl_compilation
parameter_list|(
name|decl
parameter_list|,
name|asmspec
parameter_list|,
name|top_level
parameter_list|,
name|at_end
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|char
modifier|*
name|asmspec
decl_stmt|;
name|int
name|top_level
decl_stmt|;
name|int
name|at_end
decl_stmt|;
block|{
comment|/* Declarations of variables, and of functions defined elsewhere.  */
comment|/* Forward declarations for nested functions are not "external",      but we need to treat them as if they were.  */
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|TIMEVAR
argument_list|(
argument|varconst_time
argument_list|,
argument|{ 	       make_decl_rtl (decl, asmspec, top_level);
comment|/* For a user-invisible decl that should be replaced 		  by its value when used, don't output anything.  */
argument|if (! (TREE_CODE (decl) == VAR_DECL&& DECL_IGNORED_P (decl)&& TREE_READONLY (decl)&& DECL_INITIAL (decl) !=
literal|0
argument|))
comment|/* Don't output anything 		    when a tentative file-scope definition is seen. 		    But at end of compilation, do output code for them.  */
argument|if (! (! at_end&& top_level&& (DECL_INITIAL (decl) ==
literal|0
argument||| DECL_INITIAL (decl) == error_mark_node 			    || DECL_IGNORED_P (decl)))) 		   assemble_variable (decl, top_level, at_end); 	     }
argument_list|)
empty_stmt|;
elseif|else
if|if
condition|(
name|DECL_REGISTER
argument_list|(
name|decl
argument_list|)
operator|&&
name|asmspec
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|decode_reg_name
argument_list|(
name|asmspec
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|make_decl_rtl
argument_list|(
name|decl
argument_list|,
name|asmspec
argument_list|,
name|top_level
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"invalid register name `%s' for register variable"
argument_list|,
name|asmspec
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|DBX_DEBUGGING_INFO
argument_list|)
operator|||
name|defined
argument_list|(
name|XCOFF_DEBUGGING_INFO
argument_list|)
elseif|else
if|if
condition|(
operator|(
name|write_symbols
operator|==
name|DBX_DEBUG
operator|||
name|write_symbols
operator|==
name|XCOFF_DEBUG
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|TIMEVAR
argument_list|(
name|symout_time
argument_list|,
name|dbxout_symbol
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SDB_DEBUGGING_INFO
elseif|else
if|if
condition|(
name|write_symbols
operator|==
name|SDB_DEBUG
operator|&&
name|top_level
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|TIMEVAR
argument_list|(
name|symout_time
argument_list|,
name|sdbout_symbol
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Called after finishing a record, union or enumeral type.  */
end_comment

begin_function
name|void
name|rest_of_type_compilation
parameter_list|(
name|type
parameter_list|,
name|toplev
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
name|toplev
decl_stmt|;
block|{
if|#
directive|if
name|defined
argument_list|(
name|DBX_DEBUGGING_INFO
argument_list|)
operator|||
name|defined
argument_list|(
name|XCOFF_DEBUGGING_INFO
argument_list|)
if|if
condition|(
name|write_symbols
operator|==
name|DBX_DEBUG
operator|||
name|write_symbols
operator|==
name|XCOFF_DEBUG
condition|)
name|TIMEVAR
argument_list|(
name|symout_time
argument_list|,
name|dbxout_symbol
argument_list|(
name|TYPE_STUB_DECL
argument_list|(
name|type
argument_list|)
argument_list|,
operator|!
name|toplev
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SDB_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|SDB_DEBUG
condition|)
name|TIMEVAR
argument_list|(
name|symout_time
argument_list|,
name|sdbout_symbol
argument_list|(
name|TYPE_STUB_DECL
argument_list|(
name|type
argument_list|)
argument_list|,
operator|!
name|toplev
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* This is called from finish_function (within yyparse)    after each top-level definition is parsed.    It is supposed to compile that function or variable    and output the assembler code for it.    After we return, the tree storage is freed.  */
end_comment

begin_function
name|void
name|rest_of_compilation
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
specifier|register
name|rtx
name|insns
decl_stmt|;
name|int
name|start_time
init|=
name|get_run_time
argument_list|()
decl_stmt|;
name|int
name|tem
decl_stmt|;
comment|/* Nonzero if we have saved the original DECL_INITIAL of the function,      to be restored after we finish compiling the function      (for use when compiling inline calls to this function).  */
name|tree
name|saved_block_tree
init|=
literal|0
decl_stmt|;
comment|/* Likewise, for DECL_ARGUMENTS.  */
name|tree
name|saved_arguments
init|=
literal|0
decl_stmt|;
name|int
name|failure
init|=
literal|0
decl_stmt|;
comment|/* If we are reconsidering an inline function      at the end of compilation, skip the stuff for making it inline.  */
if|if
condition|(
name|DECL_SAVED_INSNS
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|specd
init|=
name|DECL_INLINE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|char
modifier|*
name|lose
decl_stmt|;
comment|/* If requested, consider whether to make this function inline.  */
if|if
condition|(
name|specd
operator|||
name|flag_inline_functions
condition|)
name|TIMEVAR
argument_list|(
argument|integration_time
argument_list|,
argument|{ 		   lose = function_cannot_inline_p (decl); 		   if (lose) 		     { 		       if (warn_inline&& specd) 			 warning_with_decl (decl, lose); 		       DECL_INLINE (decl) =
literal|0
argument|; 		     } 		   else 		     DECL_INLINE (decl) =
literal|1
argument|; 		 }
argument_list|)
empty_stmt|;
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
comment|/* Dump the rtl code if we are dumping rtl.  */
if|if
condition|(
name|rtl_dump
condition|)
name|TIMEVAR
argument_list|(
argument|dump_time
argument_list|,
argument|{ 		   fprintf (rtl_dump_file,
literal|"\n;; Function %s\n\n"
argument|, 			    IDENTIFIER_POINTER (DECL_NAME (decl))); 		   if (DECL_SAVED_INSNS (decl)) 		     fprintf (rtl_dump_file,
literal|";; (integrable)\n\n"
argument|); 		   print_rtl (rtl_dump_file, insns); 		   fflush (rtl_dump_file); 		 }
argument_list|)
empty_stmt|;
comment|/* If function is inline, and we don't yet know whether to 	 compile it by itself, defer decision till end of compilation. 	 finish_compilation will call rest_of_compilation again 	 for those functions that need to be output.  */
if|if
condition|(
name|DECL_INLINE
argument_list|(
name|decl
argument_list|)
operator|&&
operator|(
operator|(
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_ADDRESSABLE
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|flag_keep_inline_functions
operator|)
operator|||
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DWARF_DEBUGGING_INFO
comment|/* Generate the DWARF info for the "abstract" instance 	     of a function which we may later generate inlined and/or 	     out-of-line instances of.  */
if|if
condition|(
name|write_symbols
operator|==
name|DWARF_DEBUG
condition|)
block|{
name|set_decl_abstract_flags
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|TIMEVAR
argument_list|(
name|symout_time
argument_list|,
name|dwarfout_file_scope_decl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|set_decl_abstract_flags
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|TIMEVAR
argument_list|(
name|integration_time
argument_list|,
name|save_for_inline_nocopy
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|exit_rest_of_compilation
goto|;
block|}
comment|/* If we have to compile the function now, save its rtl and subdecls 	 so that its compilation will not affect what others get.  */
if|if
condition|(
name|DECL_INLINE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DWARF_DEBUGGING_INFO
comment|/* Generate the DWARF info for the "abstract" instance of 	     a function which we will generate an out-of-line instance 	     of almost immediately (and which we may also later generate 	     various inlined instances of).  */
if|if
condition|(
name|write_symbols
operator|==
name|DWARF_DEBUG
condition|)
block|{
name|set_decl_abstract_flags
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|TIMEVAR
argument_list|(
name|symout_time
argument_list|,
name|dwarfout_file_scope_decl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|set_decl_abstract_flags
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|saved_block_tree
operator|=
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|saved_arguments
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|TIMEVAR
argument_list|(
name|integration_time
argument_list|,
name|save_for_inline_copying
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Now that integrate will no longer see our rtl, we need not distinguish      between the return value of this function and the return value of called      functions.  */
name|rtx_equal_function_value_matters
operator|=
literal|0
expr_stmt|;
comment|/* Don't return yet if -Wreturn-type; we need to do jump_optimize.  */
if|if
condition|(
operator|(
name|rtl_dump_and_exit
operator|||
name|flag_syntax_only
operator|)
operator|&&
operator|!
name|warn_return_type
condition|)
block|{
goto|goto
name|exit_rest_of_compilation
goto|;
block|}
comment|/* From now on, allocate rtl in current_obstack, not in saveable_obstack.      Note that that may have been done above, in save_for_inline_copying.      The call to resume_temporary_allocation near the end of this function      goes back to the usual state of affairs.  */
name|rtl_in_current_obstack
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|FINALIZE_PIC
comment|/* If we are doing position-independent code generation, now      is the time to output special prologues and epilogues.      We do not want to do this earlier, because it just clutters      up inline functions with meaningless insns.  */
if|if
condition|(
name|flag_pic
condition|)
name|FINALIZE_PIC
expr_stmt|;
endif|#
directive|endif
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
comment|/* Copy any shared structure that should not be shared.  */
name|unshare_all_rtl
argument_list|(
name|insns
argument_list|)
expr_stmt|;
comment|/* Instantiate all virtual registers.  */
name|instantiate_virtual_regs
argument_list|(
name|current_function_decl
argument_list|,
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
comment|/* See if we have allocated stack slots that are not directly addressable.      If so, scan all the insns and create explicit address computation      for all references to such slots.  */
comment|/*   fixup_stack_slots (); */
comment|/* Do jump optimization the first time, if -opt.      Also do it if -W, but in that case it doesn't change the rtl code,      it only computes whether control can drop off the end of the function.  */
if|if
condition|(
name|optimize
operator|>
literal|0
operator|||
name|extra_warnings
operator|||
name|warn_return_type
comment|/* If function is `volatile', we should warn if it tries to return.  */
operator|||
name|TREE_THIS_VOLATILE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|TIMEVAR
argument_list|(
name|jump_time
argument_list|,
name|reg_scan
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|TIMEVAR
argument_list|(
name|jump_time
argument_list|,
name|jump_optimize
argument_list|(
name|insns
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Now is when we stop if -fsyntax-only and -Wreturn-type.  */
if|if
condition|(
name|rtl_dump_and_exit
operator|||
name|flag_syntax_only
condition|)
goto|goto
name|exit_rest_of_compilation
goto|;
comment|/* Dump rtl code after jump, if we are doing that.  */
if|if
condition|(
name|jump_opt_dump
condition|)
name|TIMEVAR
argument_list|(
argument|dump_time
argument_list|,
argument|{ 	       fprintf (jump_opt_dump_file,
literal|"\n;; Function %s\n\n"
argument|, 			IDENTIFIER_POINTER (DECL_NAME (decl))); 	       print_rtl (jump_opt_dump_file, insns); 	       fflush (jump_opt_dump_file); 	     }
argument_list|)
empty_stmt|;
comment|/* Perform common subexpression elimination.      Nonzero value from `cse_main' means that jumps were simplified      and some code may now be unreachable, so do      jump optimization again.  */
if|if
condition|(
name|cse_dump
condition|)
name|TIMEVAR
argument_list|(
argument|dump_time
argument_list|,
argument|{ 	       fprintf (cse_dump_file,
literal|"\n;; Function %s\n\n"
argument|, 			IDENTIFIER_POINTER (DECL_NAME (decl))); 	     }
argument_list|)
empty_stmt|;
if|if
condition|(
name|optimize
operator|>
literal|0
condition|)
block|{
name|TIMEVAR
argument_list|(
name|cse_time
argument_list|,
name|reg_scan
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_thread_jumps
condition|)
comment|/* Hacks by tiemann& kenner.  */
name|TIMEVAR
argument_list|(
name|jump_time
argument_list|,
name|thread_jumps
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|TIMEVAR
argument_list|(
name|cse_time
argument_list|,
name|tem
operator|=
name|cse_main
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
literal|0
argument_list|,
name|cse_dump_file
argument_list|)
argument_list|)
expr_stmt|;
name|TIMEVAR
argument_list|(
name|cse_time
argument_list|,
name|delete_dead_from_cse
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
name|TIMEVAR
argument_list|(
name|jump_time
argument_list|,
name|jump_optimize
argument_list|(
name|insns
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Dump rtl code after cse, if we are doing that.  */
if|if
condition|(
name|cse_dump
condition|)
name|TIMEVAR
argument_list|(
argument|dump_time
argument_list|,
argument|{ 	       print_rtl (cse_dump_file, insns); 	       fflush (cse_dump_file); 	     }
argument_list|)
empty_stmt|;
if|if
condition|(
name|loop_dump
condition|)
name|TIMEVAR
argument_list|(
argument|dump_time
argument_list|,
argument|{ 	       fprintf (loop_dump_file,
literal|"\n;; Function %s\n\n"
argument|, 			IDENTIFIER_POINTER (DECL_NAME (decl))); 	     }
argument_list|)
empty_stmt|;
comment|/* Move constant computations out of loops.  */
if|if
condition|(
name|optimize
operator|>
literal|0
condition|)
block|{
name|TIMEVAR
argument_list|(
argument|loop_time
argument_list|,
argument|{ 		 loop_optimize (insns, loop_dump_file); 	       }
argument_list|)
empty_stmt|;
block|}
comment|/* Dump rtl code after loop opt, if we are doing that.  */
if|if
condition|(
name|loop_dump
condition|)
name|TIMEVAR
argument_list|(
argument|dump_time
argument_list|,
argument|{ 	       print_rtl (loop_dump_file, insns); 	       fflush (loop_dump_file); 	     }
argument_list|)
empty_stmt|;
if|if
condition|(
name|cse2_dump
condition|)
name|TIMEVAR
argument_list|(
argument|dump_time
argument_list|,
argument|{ 	       fprintf (cse2_dump_file,
literal|"\n;; Function %s\n\n"
argument|, 			IDENTIFIER_POINTER (DECL_NAME (decl))); 	     }
argument_list|)
empty_stmt|;
if|if
condition|(
name|optimize
operator|>
literal|0
operator|&&
name|flag_rerun_cse_after_loop
condition|)
block|{
name|TIMEVAR
argument_list|(
name|cse2_time
argument_list|,
name|reg_scan
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|TIMEVAR
argument_list|(
name|cse2_time
argument_list|,
name|tem
operator|=
name|cse_main
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
literal|1
argument_list|,
name|cse2_dump_file
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
name|TIMEVAR
argument_list|(
name|jump_time
argument_list|,
name|jump_optimize
argument_list|(
name|insns
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|optimize
operator|>
literal|0
operator|&&
name|flag_thread_jumps
condition|)
comment|/* This pass of jump threading straightens out code        that was kinked by loop optimization.  */
name|TIMEVAR
argument_list|(
name|jump_time
argument_list|,
name|thread_jumps
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Dump rtl code after cse, if we are doing that.  */
if|if
condition|(
name|cse2_dump
condition|)
name|TIMEVAR
argument_list|(
argument|dump_time
argument_list|,
argument|{ 	       print_rtl (cse2_dump_file, insns); 	       fflush (cse2_dump_file); 	     }
argument_list|)
empty_stmt|;
comment|/* We are no longer anticipating cse in this function, at least.  */
name|cse_not_expected
operator|=
literal|1
expr_stmt|;
comment|/* Now we choose between stupid (pcc-like) register allocation      (if we got the -noreg switch and not -opt)      and smart register allocation.  */
if|if
condition|(
name|optimize
operator|>
literal|0
condition|)
comment|/* Stupid allocation probably won't work */
name|obey_regdecls
operator|=
literal|0
expr_stmt|;
comment|/* if optimizations being done.  */
name|regclass_init
argument_list|()
expr_stmt|;
comment|/* Print function header into flow dump now      because doing the flow analysis makes some of the dump.  */
if|if
condition|(
name|flow_dump
condition|)
name|TIMEVAR
argument_list|(
argument|dump_time
argument_list|,
argument|{ 	       fprintf (flow_dump_file,
literal|"\n;; Function %s\n\n"
argument|, 			IDENTIFIER_POINTER (DECL_NAME (decl))); 	     }
argument_list|)
empty_stmt|;
if|if
condition|(
name|obey_regdecls
condition|)
block|{
name|TIMEVAR
argument_list|(
argument|flow_time
argument_list|,
argument|{ 		 regclass (insns, max_reg_num ()); 		 stupid_life_analysis (insns, max_reg_num (), 				       flow_dump_file); 	       }
argument_list|)
empty_stmt|;
block|}
else|else
block|{
comment|/* Do control and data flow analysis, 	 and write some of the results to dump file.  */
name|TIMEVAR
argument_list|(
name|flow_time
argument_list|,
name|flow_analysis
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
name|flow_dump_file
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|warn_uninitialized
condition|)
block|{
name|uninitialized_vars_warning
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|setjmp_args_warning
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Dump rtl after flow analysis.  */
if|if
condition|(
name|flow_dump
condition|)
name|TIMEVAR
argument_list|(
argument|dump_time
argument_list|,
argument|{ 	       print_rtl (flow_dump_file, insns); 	       fflush (flow_dump_file); 	     }
argument_list|)
empty_stmt|;
comment|/* If -opt, try combining insns through substitution.  */
if|if
condition|(
name|optimize
operator|>
literal|0
condition|)
name|TIMEVAR
argument_list|(
name|combine_time
argument_list|,
name|combine_instructions
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Dump rtl code after insn combination.  */
if|if
condition|(
name|combine_dump
condition|)
name|TIMEVAR
argument_list|(
argument|dump_time
argument_list|,
argument|{ 	       fprintf (combine_dump_file,
literal|"\n;; Function %s\n\n"
argument|, 			IDENTIFIER_POINTER (DECL_NAME (decl))); 	       dump_combine_stats (combine_dump_file); 	       print_rtl (combine_dump_file, insns); 	       fflush (combine_dump_file); 	     }
argument_list|)
empty_stmt|;
comment|/* Print function header into sched dump now      because doing the sched analysis makes some of the dump.  */
if|if
condition|(
name|sched_dump
condition|)
name|TIMEVAR
argument_list|(
argument|dump_time
argument_list|,
argument|{ 	       fprintf (sched_dump_file,
literal|"\n;; Function %s\n\n"
argument|, 			IDENTIFIER_POINTER (DECL_NAME (decl))); 	     }
argument_list|)
empty_stmt|;
if|if
condition|(
name|optimize
operator|>
literal|0
operator|&&
name|flag_schedule_insns
condition|)
block|{
comment|/* Do control and data sched analysis, 	 and write some of the results to dump file.  */
name|TIMEVAR
argument_list|(
name|sched_time
argument_list|,
name|schedule_insns
argument_list|(
name|sched_dump_file
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Dump rtl after instruction scheduling.  */
if|if
condition|(
name|sched_dump
condition|)
name|TIMEVAR
argument_list|(
argument|dump_time
argument_list|,
argument|{ 	       print_rtl (sched_dump_file, insns); 	       fflush (sched_dump_file); 	     }
argument_list|)
empty_stmt|;
comment|/* Unless we did stupid register allocation,      allocate pseudo-regs that are used only within 1 basic block.  */
if|if
condition|(
operator|!
name|obey_regdecls
condition|)
name|TIMEVAR
argument_list|(
argument|local_alloc_time
argument_list|,
argument|{ 	       regclass (insns, max_reg_num ()); 	       local_alloc (); 	     }
argument_list|)
empty_stmt|;
comment|/* Dump rtl code after allocating regs within basic blocks.  */
if|if
condition|(
name|local_reg_dump
condition|)
name|TIMEVAR
argument_list|(
argument|dump_time
argument_list|,
argument|{ 	       fprintf (local_reg_dump_file,
literal|"\n;; Function %s\n\n"
argument|, 			IDENTIFIER_POINTER (DECL_NAME (decl))); 	       dump_flow_info (local_reg_dump_file); 	       dump_local_alloc (local_reg_dump_file); 	       print_rtl (local_reg_dump_file, insns); 	       fflush (local_reg_dump_file); 	     }
argument_list|)
empty_stmt|;
if|if
condition|(
name|global_reg_dump
condition|)
name|TIMEVAR
argument_list|(
name|dump_time
argument_list|,
name|fprintf
argument_list|(
name|global_reg_dump_file
argument_list|,
literal|"\n;; Function %s\n\n"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Unless we did stupid register allocation,      allocate remaining pseudo-regs, then do the reload pass      fixing up any insns that are invalid.  */
name|TIMEVAR
argument_list|(
argument|global_alloc_time
argument_list|,
argument|{ 	     if (!obey_regdecls) 	       failure = global_alloc (global_reg_dump_file); 	     else 	       failure = reload (insns,
literal|0
argument|, global_reg_dump_file); 	   }
argument_list|)
empty_stmt|;
if|if
condition|(
name|global_reg_dump
condition|)
name|TIMEVAR
argument_list|(
argument|dump_time
argument_list|,
argument|{ 	       dump_global_regs (global_reg_dump_file); 	       print_rtl (global_reg_dump_file, insns); 	       fflush (global_reg_dump_file); 	     }
argument_list|)
empty_stmt|;
if|if
condition|(
name|failure
condition|)
goto|goto
name|exit_rest_of_compilation
goto|;
name|reload_completed
operator|=
literal|1
expr_stmt|;
comment|/* On some machines, the prologue and epilogue code, or parts thereof,      can be represented as RTL.  Doing so lets us schedule insns between      it and the rest of the code and also allows delayed branch      scheduling to operate in the epilogue.  */
name|thread_prologue_and_epilogue_insns
argument_list|(
name|insns
argument_list|)
expr_stmt|;
if|if
condition|(
name|optimize
operator|>
literal|0
operator|&&
name|flag_schedule_insns_after_reload
condition|)
block|{
if|if
condition|(
name|sched2_dump
condition|)
name|TIMEVAR
argument_list|(
argument|dump_time
argument_list|,
argument|{ 		   fprintf (sched2_dump_file,
literal|"\n;; Function %s\n\n"
argument|, 			    IDENTIFIER_POINTER (DECL_NAME (decl))); 		 }
argument_list|)
empty_stmt|;
comment|/* Do control and data sched analysis again, 	 and write some more of the results to dump file.  */
name|TIMEVAR
argument_list|(
name|sched2_time
argument_list|,
name|schedule_insns
argument_list|(
name|sched2_dump_file
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Dump rtl after post-reorder instruction scheduling.  */
if|if
condition|(
name|sched2_dump
condition|)
name|TIMEVAR
argument_list|(
argument|dump_time
argument_list|,
argument|{ 		   print_rtl (sched2_dump_file, insns); 		   fflush (sched2_dump_file); 		 }
argument_list|)
empty_stmt|;
block|}
ifdef|#
directive|ifdef
name|LEAF_REGISTERS
name|leaf_function
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|optimize
operator|>
literal|0
operator|&&
name|only_leaf_regs_used
argument_list|()
operator|&&
name|leaf_function_p
argument_list|()
condition|)
name|leaf_function
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* One more attempt to remove jumps to .+1      left by dead-store-elimination.      Also do cross-jumping this time      and delete no-op move insns.  */
if|if
condition|(
name|optimize
operator|>
literal|0
condition|)
block|{
name|TIMEVAR
argument_list|(
name|jump_time
argument_list|,
name|jump_optimize
argument_list|(
name|insns
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Dump rtl code after jump, if we are doing that.  */
if|if
condition|(
name|jump2_opt_dump
condition|)
name|TIMEVAR
argument_list|(
argument|dump_time
argument_list|,
argument|{ 	       fprintf (jump2_opt_dump_file,
literal|"\n;; Function %s\n\n"
argument|, 			IDENTIFIER_POINTER (DECL_NAME (decl))); 	       print_rtl (jump2_opt_dump_file, insns); 	       fflush (jump2_opt_dump_file); 	     }
argument_list|)
empty_stmt|;
comment|/* If a scheduling pass for delayed branches is to be done,      call the scheduling code. */
ifdef|#
directive|ifdef
name|DELAY_SLOTS
if|if
condition|(
name|optimize
operator|>
literal|0
operator|&&
name|flag_delayed_branch
condition|)
block|{
name|TIMEVAR
argument_list|(
name|dbr_sched_time
argument_list|,
name|dbr_schedule
argument_list|(
name|insns
argument_list|,
name|dbr_sched_dump_file
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbr_sched_dump
condition|)
block|{
name|TIMEVAR
argument_list|(
argument|dump_time
argument_list|,
argument|{ 		   fprintf (dbr_sched_dump_file,
literal|"\n;; Function %s\n\n"
argument|, 			    IDENTIFIER_POINTER (DECL_NAME (decl))); 		   print_rtl (dbr_sched_dump_file, insns); 		   fflush (dbr_sched_dump_file); 		 }
argument_list|)
empty_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|optimize
operator|>
literal|0
condition|)
comment|/* Shorten branches.  */
name|TIMEVAR
argument_list|(
argument|shorten_branch_time
argument_list|,
argument|{ 	       shorten_branches (get_insns ()); 	     }
argument_list|)
empty_stmt|;
ifdef|#
directive|ifdef
name|STACK_REGS
name|TIMEVAR
argument_list|(
name|stack_reg_time
argument_list|,
name|reg_to_stack
argument_list|(
name|insns
argument_list|,
name|stack_reg_dump_file
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|stack_reg_dump
condition|)
block|{
name|TIMEVAR
argument_list|(
argument|dump_time
argument_list|,
argument|{ 		 fprintf (stack_reg_dump_file,
literal|"\n;; Function %s\n\n"
argument|, 			  IDENTIFIER_POINTER (DECL_NAME (decl))); 		 print_rtl (stack_reg_dump_file, insns); 		 fflush (stack_reg_dump_file); 	       }
argument_list|)
empty_stmt|;
block|}
endif|#
directive|endif
comment|/* Now turn the rtl into assembler code.  */
name|TIMEVAR
argument_list|(
argument|final_time
argument_list|,
argument|{ 	     rtx x; 	     char *fnname;
comment|/* Get the function's name, as described by its RTL. 		This may be different from the DECL_NAME name used 		in the source file.  */
argument|x = DECL_RTL (decl); 	     if (GET_CODE (x) != MEM) 	       abort (); 	     x = XEXP (x,
literal|0
argument|); 	     if (GET_CODE (x) != SYMBOL_REF) 	       abort (); 	     fnname = XSTR (x,
literal|0
argument|);  	     assemble_start_function (decl, fnname); 	     final_start_function (insns, asm_out_file, optimize); 	     final (insns, asm_out_file, optimize,
literal|0
argument|); 	     final_end_function (insns, asm_out_file, optimize); 	     assemble_end_function (decl, fnname); 	     fflush (asm_out_file); 	   }
argument_list|)
empty_stmt|;
comment|/* Write DBX symbols if requested */
comment|/* Note that for those inline functions where we don't initially      know for certain that we will be generating an out-of-line copy,      the first invocation of this routine (rest_of_compilation) will      skip over this code by doing a `goto exit_rest_of_compilation;'.      Later on, finish_compilation will call rest_of_compilation again      for those inline functions that need to have out-of-line copies      generated.  During that call, we *will* be routed past here.  */
ifdef|#
directive|ifdef
name|DBX_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|DBX_DEBUG
condition|)
name|TIMEVAR
argument_list|(
name|symout_time
argument_list|,
name|dbxout_function
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DWARF_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|DWARF_DEBUG
condition|)
name|TIMEVAR
argument_list|(
name|symout_time
argument_list|,
name|dwarfout_file_scope_decl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|exit_rest_of_compilation
label|:
comment|/* In case the function was not output,      don't leave any temporary anonymous types      queued up for sdb output.  */
ifdef|#
directive|ifdef
name|SDB_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|SDB_DEBUG
condition|)
name|sdbout_types
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Put back the tree of subblocks and list of arguments      from before we copied them.      Code generation and the output of debugging info may have modified      the copy, but the original is unchanged.  */
if|if
condition|(
name|saved_block_tree
operator|!=
literal|0
condition|)
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|saved_block_tree
expr_stmt|;
if|if
condition|(
name|saved_arguments
operator|!=
literal|0
condition|)
name|DECL_ARGUMENTS
argument_list|(
name|decl
argument_list|)
operator|=
name|saved_arguments
expr_stmt|;
name|reload_completed
operator|=
literal|0
expr_stmt|;
comment|/* Clear out the real_constant_chain before some of the rtx's      it runs through become garbage.  */
name|clear_const_double_mem
argument_list|()
expr_stmt|;
comment|/* Cancel the effect of rtl_in_current_obstack.  */
name|resume_temporary_allocation
argument_list|()
expr_stmt|;
comment|/* The parsing time is all the time spent in yyparse      *except* what is spent in this function.  */
name|parse_time
operator|-=
name|get_run_time
argument_list|()
operator|-
name|start_time
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Entry point of cc1/c++.  Decode command args, then call compile_file.    Exit code is 35 if can't open files, 34 if fatal error,    33 if had nonfatal errors, else success.  */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|envp
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
modifier|*
name|envp
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|filename
init|=
literal|0
decl_stmt|;
name|int
name|flag_print_mem
init|=
literal|0
decl_stmt|;
name|int
name|version_flag
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/* save in case md file wants to emit args as a comment.  */
name|save_argc
operator|=
name|argc
expr_stmt|;
name|save_argv
operator|=
name|argv
expr_stmt|;
name|p
operator|=
name|argv
index|[
literal|0
index|]
operator|+
name|strlen
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|argv
index|[
literal|0
index|]
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
operator|--
name|p
expr_stmt|;
name|progname
operator|=
name|p
expr_stmt|;
ifdef|#
directive|ifdef
name|RLIMIT_STACK
comment|/* Get rid of any avoidable limit on stack size.  */
block|{
name|struct
name|rlimit
name|rlim
decl_stmt|;
comment|/* Set the stack limit huge so that alloca does not fail. */
name|getrlimit
argument_list|(
name|RLIMIT_STACK
argument_list|,
operator|&
name|rlim
argument_list|)
expr_stmt|;
name|rlim
operator|.
name|rlim_cur
operator|=
name|rlim
operator|.
name|rlim_max
expr_stmt|;
name|setrlimit
argument_list|(
name|RLIMIT_STACK
argument_list|,
operator|&
name|rlim
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* RLIMIT_STACK */
name|signal
argument_list|(
name|SIGFPE
argument_list|,
name|float_signal
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGPIPE
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|pipe_closed
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|decl_printable_name
operator|=
name|decl_name
expr_stmt|;
name|lang_expand_expr
operator|=
operator|(
expr|struct
name|rtx_def
operator|*
call|(
modifier|*
call|)
argument_list|()
operator|)
name|do_abort
expr_stmt|;
comment|/* Initialize whether `char' is signed.  */
name|flag_signed_char
operator|=
name|DEFAULT_SIGNED_CHAR
expr_stmt|;
ifdef|#
directive|ifdef
name|DEFAULT_SHORT_ENUMS
comment|/* Initialize how much space enums occupy, by default.  */
name|flag_short_enums
operator|=
name|DEFAULT_SHORT_ENUMS
expr_stmt|;
endif|#
directive|endif
comment|/* Scan to see what optimization level has been specified.  That will      determine the default value of many flags.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-O"
argument_list|)
condition|)
block|{
name|optimize
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'O'
condition|)
block|{
comment|/* Handle -O2, -O3, -O69, ...  */
name|char
modifier|*
name|p
init|=
operator|&
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
decl_stmt|;
name|int
name|c
decl_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|p
operator|++
condition|)
if|if
condition|(
operator|!
operator|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
operator|)
condition|)
break|break;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
name|optimize
operator|=
name|atoi
argument_list|(
operator|&
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|obey_regdecls
operator|=
operator|(
name|optimize
operator|==
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|optimize
operator|==
literal|0
condition|)
block|{
name|flag_no_inline
operator|=
literal|1
expr_stmt|;
name|warn_inline
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|optimize
operator|>=
literal|1
condition|)
block|{
name|flag_defer_pop
operator|=
literal|1
expr_stmt|;
name|flag_thread_jumps
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|DELAY_SLOTS
name|flag_delayed_branch
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|optimize
operator|>=
literal|2
condition|)
block|{
name|flag_cse_follow_jumps
operator|=
literal|1
expr_stmt|;
name|flag_cse_skip_blocks
operator|=
literal|1
expr_stmt|;
name|flag_expensive_optimizations
operator|=
literal|1
expr_stmt|;
name|flag_strength_reduce
operator|=
literal|1
expr_stmt|;
name|flag_rerun_cse_after_loop
operator|=
literal|1
expr_stmt|;
name|flag_caller_saves
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|INSN_SCHEDULING
name|flag_schedule_insns
operator|=
literal|1
expr_stmt|;
name|flag_schedule_insns_after_reload
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|OPTIMIZATION_OPTIONS
comment|/* Allow default optimizations to be specified on a per-machine basis.  */
name|OPTIMIZATION_OPTIONS
argument_list|(
name|optimize
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Initialize register usage now so switches may override.  */
name|init_reg_sets
argument_list|()
expr_stmt|;
name|target_flags
operator|=
literal|0
expr_stmt|;
name|set_target_switch
argument_list|(
literal|""
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|;
comment|/* If this is a language-specific option, 	 decode it in a language-specific way.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|lang_options
index|[
name|j
index|]
operator|!=
literal|0
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|lang_options
index|[
name|j
index|]
argument_list|,
name|strlen
argument_list|(
name|lang_options
index|[
name|j
index|]
argument_list|)
argument_list|)
condition|)
break|break;
if|if
condition|(
name|lang_options
index|[
name|j
index|]
operator|!=
literal|0
condition|)
comment|/* If the option is valid for *some* language, 	   treat it as valid even if this language doesn't understand it.  */
name|lang_decode_option
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
block|{
specifier|register
name|char
modifier|*
name|str
init|=
name|argv
index|[
name|i
index|]
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|str
index|[
literal|0
index|]
operator|==
literal|'Y'
condition|)
name|str
operator|++
expr_stmt|;
if|if
condition|(
name|str
index|[
literal|0
index|]
operator|==
literal|'m'
condition|)
name|set_target_switch
argument_list|(
operator|&
name|str
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"dumpbase"
argument_list|)
condition|)
block|{
name|dump_base_name
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|str
index|[
literal|0
index|]
operator|==
literal|'d'
condition|)
block|{
specifier|register
name|char
modifier|*
name|p
init|=
operator|&
name|str
index|[
literal|1
index|]
decl_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
switch|switch
condition|(
operator|*
name|p
operator|++
condition|)
block|{
case|case
literal|'a'
case|:
name|combine_dump
operator|=
literal|1
expr_stmt|;
name|dbr_sched_dump
operator|=
literal|1
expr_stmt|;
name|flow_dump
operator|=
literal|1
expr_stmt|;
name|global_reg_dump
operator|=
literal|1
expr_stmt|;
name|jump_opt_dump
operator|=
literal|1
expr_stmt|;
name|jump2_opt_dump
operator|=
literal|1
expr_stmt|;
name|local_reg_dump
operator|=
literal|1
expr_stmt|;
name|loop_dump
operator|=
literal|1
expr_stmt|;
name|rtl_dump
operator|=
literal|1
expr_stmt|;
name|cse_dump
operator|=
literal|1
operator|,
name|cse2_dump
operator|=
literal|1
expr_stmt|;
name|sched_dump
operator|=
literal|1
expr_stmt|;
name|sched2_dump
operator|=
literal|1
expr_stmt|;
name|stack_reg_dump
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
name|stack_reg_dump
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|combine_dump
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|dbr_sched_dump
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|flow_dump
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|global_reg_dump
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'j'
case|:
name|jump_opt_dump
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'J'
case|:
name|jump2_opt_dump
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|local_reg_dump
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|loop_dump
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|flag_print_mem
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|flag_print_asm_name
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|rtl_dump
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|cse_dump
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|cse2_dump
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|sched_dump
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|sched2_dump
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'y'
case|:
name|set_yydebug
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|rtl_dump_and_exit
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|str
index|[
literal|0
index|]
operator|==
literal|'f'
condition|)
block|{
specifier|register
name|char
modifier|*
name|p
init|=
operator|&
name|str
index|[
literal|1
index|]
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
comment|/* Some kind of -f option. 		 P's value is the option sans `-f'. 		 Search for it in the table of options.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
operator|!
name|found
operator|&&
name|j
operator|<
sizeof|sizeof
argument_list|(
name|f_options
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|f_options
index|[
literal|0
index|]
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
name|f_options
index|[
name|j
index|]
operator|.
name|string
argument_list|)
condition|)
block|{
operator|*
name|f_options
index|[
name|j
index|]
operator|.
name|variable
operator|=
name|f_options
index|[
name|j
index|]
operator|.
name|on_value
expr_stmt|;
comment|/* A goto here would be cleaner, 			 but breaks the vax pcc.  */
name|found
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'n'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'o'
operator|&&
name|p
index|[
literal|2
index|]
operator|==
literal|'-'
operator|&&
operator|!
name|strcmp
argument_list|(
name|p
operator|+
literal|3
argument_list|,
name|f_options
index|[
name|j
index|]
operator|.
name|string
argument_list|)
condition|)
block|{
operator|*
name|f_options
index|[
name|j
index|]
operator|.
name|variable
operator|=
operator|!
name|f_options
index|[
name|j
index|]
operator|.
name|on_value
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|found
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"fixed-"
argument_list|,
literal|6
argument_list|)
condition|)
name|fix_register
argument_list|(
operator|&
name|p
index|[
literal|6
index|]
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"call-used-"
argument_list|,
literal|10
argument_list|)
condition|)
name|fix_register
argument_list|(
operator|&
name|p
index|[
literal|10
index|]
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"call-saved-"
argument_list|,
literal|11
argument_list|)
condition|)
name|fix_register
argument_list|(
operator|&
name|p
index|[
literal|11
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"Invalid option `%s'"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|str
index|[
literal|0
index|]
operator|==
literal|'O'
condition|)
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|str
operator|+
literal|1
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|>=
literal|'0'
operator|&&
operator|*
name|p
operator|<=
literal|'9'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
empty_stmt|;
else|else
name|error
argument_list|(
literal|"Invalid option `%s'"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"pedantic"
argument_list|)
condition|)
name|pedantic
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"pedantic-errors"
argument_list|)
condition|)
name|flag_pedantic_errors
operator|=
name|pedantic
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"quiet"
argument_list|)
condition|)
name|quiet_flag
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"version"
argument_list|)
condition|)
name|version_flag
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"w"
argument_list|)
condition|)
name|inhibit_warnings
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"W"
argument_list|)
condition|)
block|{
name|extra_warnings
operator|=
literal|1
expr_stmt|;
name|warn_uninitialized
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|str
index|[
literal|0
index|]
operator|==
literal|'W'
condition|)
block|{
specifier|register
name|char
modifier|*
name|p
init|=
operator|&
name|str
index|[
literal|1
index|]
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
comment|/* Some kind of -W option. 		 P's value is the option sans `-W'. 		 Search for it in the table of options.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
operator|!
name|found
operator|&&
name|j
operator|<
sizeof|sizeof
argument_list|(
name|W_options
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|W_options
index|[
literal|0
index|]
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
name|W_options
index|[
name|j
index|]
operator|.
name|string
argument_list|)
condition|)
block|{
operator|*
name|W_options
index|[
name|j
index|]
operator|.
name|variable
operator|=
name|W_options
index|[
name|j
index|]
operator|.
name|on_value
expr_stmt|;
comment|/* A goto here would be cleaner, 			 but breaks the vax pcc.  */
name|found
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'n'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'o'
operator|&&
name|p
index|[
literal|2
index|]
operator|==
literal|'-'
operator|&&
operator|!
name|strcmp
argument_list|(
name|p
operator|+
literal|3
argument_list|,
name|W_options
index|[
name|j
index|]
operator|.
name|string
argument_list|)
condition|)
block|{
operator|*
name|W_options
index|[
name|j
index|]
operator|.
name|variable
operator|=
operator|!
name|W_options
index|[
name|j
index|]
operator|.
name|on_value
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|found
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"id-clash-"
argument_list|,
literal|9
argument_list|)
condition|)
block|{
name|char
modifier|*
name|endp
init|=
name|p
operator|+
literal|9
decl_stmt|;
while|while
condition|(
operator|*
name|endp
condition|)
block|{
if|if
condition|(
operator|*
name|endp
operator|>=
literal|'0'
operator|&&
operator|*
name|endp
operator|<=
literal|'9'
condition|)
name|endp
operator|++
expr_stmt|;
else|else
block|{
name|error
argument_list|(
literal|"Invalid option `%s'"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
goto|goto
name|id_clash_lose
goto|;
block|}
block|}
name|warn_id_clash
operator|=
literal|1
expr_stmt|;
name|id_clash_len
operator|=
name|atoi
argument_list|(
name|str
operator|+
literal|10
argument_list|)
expr_stmt|;
name|id_clash_lose
label|:
empty_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"Invalid option `%s'"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"p"
argument_list|)
condition|)
name|profile_flag
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"a"
argument_list|)
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|BLOCK_PROFILER
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|FUNCTION_BLOCK_PROFILER
argument_list|)
name|warning
argument_list|(
literal|"`-a' option (basic block profile) not supported"
argument_list|)
expr_stmt|;
else|#
directive|else
name|profile_block_flag
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|str
index|[
literal|0
index|]
operator|==
literal|'g'
condition|)
block|{
name|char
modifier|*
name|p
init|=
name|str
operator|+
literal|1
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
name|unsigned
name|level
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|(
operator|*
name|p
operator|<
literal|'0'
operator|||
operator|*
name|p
operator|>
literal|'9'
operator|)
condition|)
name|p
operator|++
expr_stmt|;
name|len
operator|=
name|p
operator|-
name|str
expr_stmt|;
name|q
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|q
operator|&&
operator|(
operator|*
name|q
operator|>=
literal|'0'
operator|&&
operator|*
name|q
operator|<=
literal|'9'
operator|)
condition|)
name|q
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
name|level
operator|=
name|atoi
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
name|level
operator|=
literal|2
expr_stmt|;
comment|/* default debugging info level */
if|if
condition|(
operator|*
name|q
operator|||
name|level
operator|>
literal|3
condition|)
block|{
name|warning
argument_list|(
literal|"invalid debug level specification in option: `-%s'"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"no debugging information will be generated"
argument_list|)
expr_stmt|;
name|level
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If more than one debugging type is supported, 		 you must define PREFERRED_DEBUGGING_TYPE 		 to choose a format in a system-dependent way.  */
comment|/* This is one long line cause VAXC can't handle a \-newline.  */
if|#
directive|if
literal|1
operator|<
operator|(
name|defined
argument_list|(
name|DBX_DEBUGGING_INFO
argument_list|)
operator|+
name|defined
argument_list|(
name|SDB_DEBUGGING_INFO
argument_list|)
operator|+
name|defined
argument_list|(
name|DWARF_DEBUGGING_INFO
argument_list|)
operator|+
name|defined
argument_list|(
name|XCOFF_DEBUGGING_INFO
argument_list|)
operator|)
ifdef|#
directive|ifdef
name|PREFERRED_DEBUGGING_TYPE
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|str
argument_list|,
literal|"ggdb"
argument_list|,
name|len
argument_list|)
condition|)
name|write_symbols
operator|=
name|PREFERRED_DEBUGGING_TYPE
expr_stmt|;
else|#
directive|else
comment|/* no PREFERRED_DEBUGGING_TYPE */
name|You
name|Lose
operator|!
name|You
name|must
name|define
name|PREFERRED_DEBUGGING_TYPE
operator|!
endif|#
directive|endif
comment|/* no PREFERRED_DEBUGGING_TYPE */
endif|#
directive|endif
comment|/* More than one debugger format enabled.  */
ifdef|#
directive|ifdef
name|DBX_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|!=
name|NO_DEBUG
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|str
argument_list|,
literal|"ggdb"
argument_list|,
name|len
argument_list|)
condition|)
name|write_symbols
operator|=
name|DBX_DEBUG
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|str
argument_list|,
literal|"gstabs"
argument_list|,
name|len
argument_list|)
condition|)
name|write_symbols
operator|=
name|DBX_DEBUG
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|str
argument_list|,
literal|"gstabs+"
argument_list|,
name|len
argument_list|)
condition|)
name|write_symbols
operator|=
name|DBX_DEBUG
expr_stmt|;
comment|/* Always enable extensions for -ggdb or -gstabs+,  		 always disable for -gstabs. 		 For plain -g, use system-specific default.  */
if|if
condition|(
name|write_symbols
operator|==
name|DBX_DEBUG
operator|&&
operator|!
name|strncmp
argument_list|(
name|str
argument_list|,
literal|"ggdb"
argument_list|,
name|len
argument_list|)
operator|&&
name|len
operator|>=
literal|2
condition|)
name|use_gnu_debug_info_extensions
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|write_symbols
operator|==
name|DBX_DEBUG
operator|&&
operator|!
name|strncmp
argument_list|(
name|str
argument_list|,
literal|"gstabs+"
argument_list|,
name|len
argument_list|)
operator|&&
name|len
operator|>=
literal|7
condition|)
name|use_gnu_debug_info_extensions
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|write_symbols
operator|==
name|DBX_DEBUG
operator|&&
operator|!
name|strncmp
argument_list|(
name|str
argument_list|,
literal|"gstabs"
argument_list|,
name|len
argument_list|)
operator|&&
name|len
operator|>=
literal|2
condition|)
name|use_gnu_debug_info_extensions
operator|=
literal|0
expr_stmt|;
else|else
name|use_gnu_debug_info_extensions
operator|=
name|DEFAULT_GDB_EXTENSIONS
expr_stmt|;
endif|#
directive|endif
comment|/* DBX_DEBUGGING_INFO */
ifdef|#
directive|ifdef
name|DWARF_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|!=
name|NO_DEBUG
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|str
argument_list|,
literal|"g"
argument_list|,
name|len
argument_list|)
condition|)
name|write_symbols
operator|=
name|DWARF_DEBUG
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|str
argument_list|,
literal|"ggdb"
argument_list|,
name|len
argument_list|)
condition|)
name|write_symbols
operator|=
name|DWARF_DEBUG
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|str
argument_list|,
literal|"gdwarf"
argument_list|,
name|len
argument_list|)
condition|)
name|write_symbols
operator|=
name|DWARF_DEBUG
expr_stmt|;
comment|/* Always enable extensions for -ggdb or -gdwarf+,  		 always disable for -gdwarf. 		 For plain -g, use system-specific default.  */
if|if
condition|(
name|write_symbols
operator|==
name|DWARF_DEBUG
operator|&&
operator|!
name|strncmp
argument_list|(
name|str
argument_list|,
literal|"ggdb"
argument_list|,
name|len
argument_list|)
operator|&&
name|len
operator|>=
literal|2
condition|)
name|use_gnu_debug_info_extensions
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|write_symbols
operator|==
name|DWARF_DEBUG
operator|&&
operator|!
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"gdwarf+"
argument_list|)
condition|)
name|use_gnu_debug_info_extensions
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|write_symbols
operator|==
name|DWARF_DEBUG
operator|&&
operator|!
name|strncmp
argument_list|(
name|str
argument_list|,
literal|"gdwarf"
argument_list|,
name|len
argument_list|)
operator|&&
name|len
operator|>=
literal|2
condition|)
name|use_gnu_debug_info_extensions
operator|=
literal|0
expr_stmt|;
else|else
name|use_gnu_debug_info_extensions
operator|=
name|DEFAULT_GDB_EXTENSIONS
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SDB_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|!=
name|NO_DEBUG
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|str
argument_list|,
literal|"g"
argument_list|,
name|len
argument_list|)
condition|)
name|write_symbols
operator|=
name|SDB_DEBUG
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|str
argument_list|,
literal|"gdb"
argument_list|,
name|len
argument_list|)
condition|)
name|write_symbols
operator|=
name|SDB_DEBUG
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|str
argument_list|,
literal|"gcoff"
argument_list|,
name|len
argument_list|)
condition|)
name|write_symbols
operator|=
name|SDB_DEBUG
expr_stmt|;
endif|#
directive|endif
comment|/* SDB_DEBUGGING_INFO */
ifdef|#
directive|ifdef
name|XCOFF_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|!=
name|NO_DEBUG
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|str
argument_list|,
literal|"g"
argument_list|,
name|len
argument_list|)
condition|)
name|write_symbols
operator|=
name|XCOFF_DEBUG
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|str
argument_list|,
literal|"ggdb"
argument_list|,
name|len
argument_list|)
condition|)
name|write_symbols
operator|=
name|XCOFF_DEBUG
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|str
argument_list|,
literal|"gxcoff"
argument_list|,
name|len
argument_list|)
condition|)
name|write_symbols
operator|=
name|XCOFF_DEBUG
expr_stmt|;
comment|/* Always enable extensions for -ggdb or -gxcoff+, 		 always disable for -gxcoff. 		 For plain -g, use system-specific default.  */
if|if
condition|(
name|write_symbols
operator|==
name|XCOFF_DEBUG
operator|&&
operator|!
name|strncmp
argument_list|(
name|str
argument_list|,
literal|"ggdb"
argument_list|,
name|len
argument_list|)
operator|&&
name|len
operator|>=
literal|2
condition|)
name|use_gnu_debug_info_extensions
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|write_symbols
operator|==
name|XCOFF_DEBUG
operator|&&
operator|!
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"gxcoff+"
argument_list|)
condition|)
name|use_gnu_debug_info_extensions
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|write_symbols
operator|==
name|XCOFF_DEBUG
operator|&&
operator|!
name|strncmp
argument_list|(
name|str
argument_list|,
literal|"gxcoff"
argument_list|,
name|len
argument_list|)
operator|&&
name|len
operator|>=
literal|2
condition|)
name|use_gnu_debug_info_extensions
operator|=
literal|0
expr_stmt|;
else|else
name|use_gnu_debug_info_extensions
operator|=
name|DEFAULT_GDB_EXTENSIONS
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|write_symbols
operator|==
name|NO_DEBUG
condition|)
name|warning
argument_list|(
literal|"`-%s' option not supported on this version of GCC"
argument_list|,
name|str
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|level
operator|==
literal|0
condition|)
name|write_symbols
operator|=
name|NO_DEBUG
expr_stmt|;
else|else
name|debug_info_level
operator|=
operator|(
expr|enum
name|debug_info_level
operator|)
name|level
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"o"
argument_list|)
condition|)
block|{
name|asm_file_name
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|str
index|[
literal|0
index|]
operator|==
literal|'G'
condition|)
block|{
name|g_switch_set
operator|=
name|TRUE
expr_stmt|;
name|g_switch_value
operator|=
name|atoi
argument_list|(
operator|(
name|str
index|[
literal|1
index|]
operator|!=
literal|'\0'
operator|)
condition|?
name|str
operator|+
literal|1
else|:
name|argv
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|str
argument_list|,
literal|"aux-info"
argument_list|,
literal|8
argument_list|)
condition|)
block|{
name|flag_gen_aux_info
operator|=
literal|1
expr_stmt|;
name|aux_info_file_name
operator|=
operator|(
name|str
index|[
literal|8
index|]
operator|!=
literal|'\0'
condition|?
name|str
operator|+
literal|8
else|:
name|argv
index|[
operator|++
name|i
index|]
operator|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"Invalid option `%s'"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'+'
condition|)
name|error
argument_list|(
literal|"Invalid option `%s'"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
name|filename
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|optimize
operator|==
literal|0
condition|)
block|{
comment|/* Inlining does not work if not optimizing, 	 so force it not to be done.  */
name|flag_no_inline
operator|=
literal|1
expr_stmt|;
name|warn_inline
operator|=
literal|0
expr_stmt|;
comment|/* The c_decode_option and lang_decode_option functions set 	 this to `2' if -Wall is used, so we can avoid giving out 	 lots of errors for people who don't realize what -Wall does.  */
if|if
condition|(
name|warn_uninitialized
operator|==
literal|1
condition|)
name|warning
argument_list|(
literal|"-Wuninitialized is not supported without -O"
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|DWARF_DEBUGGING_INFO
argument_list|)
if|if
condition|(
name|write_symbols
operator|==
name|DWARF_DEBUG
operator|&&
name|strcmp
argument_list|(
name|language_string
argument_list|,
literal|"GNU C++"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"-g option not supported for C++ on SVR4 systems"
argument_list|)
expr_stmt|;
name|write_symbols
operator|=
name|NO_DEBUG
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* defined(DWARF_DEBUGGING_INFO) */
ifdef|#
directive|ifdef
name|OVERRIDE_OPTIONS
comment|/* Some machines may reject certain combinations of options.  */
name|OVERRIDE_OPTIONS
expr_stmt|;
endif|#
directive|endif
comment|/* Unrolling all loops implies that standard loop unrolling must also      be done.  */
if|if
condition|(
name|flag_unroll_all_loops
condition|)
name|flag_unroll_loops
operator|=
literal|1
expr_stmt|;
comment|/* Loop unrolling requires that strength_reduction be on also.  Silently      turn on strength reduction here if it isn't already on.  Also, the loop      unrolling code assumes that cse will be run after loop, so that must      be turned on also.  */
if|if
condition|(
name|flag_unroll_loops
condition|)
block|{
name|flag_strength_reduce
operator|=
literal|1
expr_stmt|;
name|flag_rerun_cse_after_loop
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Warn about options that are not supported on this machine.  */
ifndef|#
directive|ifndef
name|INSN_SCHEDULING
if|if
condition|(
name|flag_schedule_insns
operator|||
name|flag_schedule_insns_after_reload
condition|)
name|warning
argument_list|(
literal|"instruction scheduling not supported on this target machine"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|DELAY_SLOTS
if|if
condition|(
name|flag_delayed_branch
condition|)
name|warning
argument_list|(
literal|"this target machine does not have delayed branches"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If we are in verbose mode, write out the version and maybe all the      option flags in use.  */
if|if
condition|(
name|version_flag
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s version %s"
argument_list|,
name|language_string
argument_list|,
name|version_string
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TARGET_VERSION
name|TARGET_VERSION
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__GNUC__
ifndef|#
directive|ifndef
name|__VERSION__
define|#
directive|define
name|__VERSION__
value|"[unknown]"
endif|#
directive|endif
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" compiled by GNU C version %s.\n"
argument_list|,
name|__VERSION__
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" compiled by CC.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|quiet_flag
condition|)
name|print_switch_values
argument_list|()
expr_stmt|;
block|}
comment|/* Now that register usage is specified, convert it to HARD_REG_SETs.  */
name|init_reg_sets_1
argument_list|()
expr_stmt|;
name|compile_file
argument_list|(
name|filename
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|OS2
ifndef|#
directive|ifndef
name|VMS
if|if
condition|(
name|flag_print_mem
condition|)
block|{
name|char
modifier|*
name|lim
init|=
operator|(
name|char
operator|*
operator|)
name|sbrk
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Data size %d.\n"
argument_list|,
name|lim
operator|-
operator|(
name|char
operator|*
operator|)
operator|&
name|environ
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USG
name|system
argument_list|(
literal|"ps -l 1>&2"
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* not USG */
name|system
argument_list|(
literal|"ps v"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not USG */
block|}
endif|#
directive|endif
comment|/* not VMS */
endif|#
directive|endif
comment|/* not OS2 */
if|if
condition|(
name|errorcount
condition|)
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sorrycount
condition|)
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|SUCCESS_EXIT_CODE
argument_list|)
expr_stmt|;
return|return
literal|34
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Decode -m switches.  */
end_comment

begin_comment
comment|/* Here is a table, controlled by the tm.h file, listing each -m switch    and which bits in `target_switches' it should set or clear.    If VALUE is positive, it is bits to set.    If VALUE is negative, -VALUE is bits to clear.    (The sign bit is not used so there is no confusion.)  */
end_comment

begin_struct
struct|struct
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|value
decl_stmt|;
block|}
name|target_switches
index|[]
init|=
name|TARGET_SWITCHES
struct|;
end_struct

begin_comment
comment|/* This table is similar, but allows the switch to have a value.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TARGET_OPTIONS
end_ifdef

begin_struct
struct|struct
block|{
name|char
modifier|*
name|prefix
decl_stmt|;
name|char
modifier|*
modifier|*
name|variable
decl_stmt|;
block|}
name|target_options
index|[]
init|=
name|TARGET_OPTIONS
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Decode the switch -mNAME.  */
end_comment

begin_function
name|void
name|set_target_switch
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|int
name|j
decl_stmt|;
name|int
name|valid
init|=
literal|0
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
sizeof|sizeof
name|target_switches
operator|/
sizeof|sizeof
name|target_switches
index|[
literal|0
index|]
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|target_switches
index|[
name|j
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|target_switches
index|[
name|j
index|]
operator|.
name|value
operator|<
literal|0
condition|)
name|target_flags
operator|&=
operator|~
operator|-
name|target_switches
index|[
name|j
index|]
operator|.
name|value
expr_stmt|;
else|else
name|target_flags
operator||=
name|target_switches
index|[
name|j
index|]
operator|.
name|value
expr_stmt|;
name|valid
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TARGET_OPTIONS
if|if
condition|(
operator|!
name|valid
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
sizeof|sizeof
name|target_options
operator|/
sizeof|sizeof
name|target_options
index|[
literal|0
index|]
condition|;
name|j
operator|++
control|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|target_options
index|[
name|j
index|]
operator|.
name|prefix
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|target_options
index|[
name|j
index|]
operator|.
name|prefix
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
condition|)
block|{
operator|*
name|target_options
index|[
name|j
index|]
operator|.
name|variable
operator|=
name|name
operator|+
name|len
expr_stmt|;
name|valid
operator|=
literal|1
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|valid
condition|)
name|error
argument_list|(
literal|"Invalid option `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Variable used for communication between the following two routines.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|line_position
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print an option value and adjust the position in the line.  */
end_comment

begin_function
specifier|static
name|void
name|print_single_switch
parameter_list|(
name|type
parameter_list|,
name|name
parameter_list|)
name|char
modifier|*
name|type
decl_stmt|,
decl|*
name|name
decl_stmt|;
end_function

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %s%s"
argument_list|,
name|type
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|line_position
operator|+=
name|strlen
argument_list|(
name|type
argument_list|)
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|line_position
operator|>
literal|65
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n\t"
argument_list|)
expr_stmt|;
name|line_position
operator|=
literal|8
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Print default target switches for -version.  */
end_comment

begin_function
specifier|static
name|void
name|print_switch_values
parameter_list|()
block|{
specifier|register
name|int
name|j
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"enabled:"
argument_list|)
expr_stmt|;
name|line_position
operator|=
literal|8
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
sizeof|sizeof
name|f_options
operator|/
sizeof|sizeof
name|f_options
index|[
literal|0
index|]
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|*
name|f_options
index|[
name|j
index|]
operator|.
name|variable
operator|==
name|f_options
index|[
name|j
index|]
operator|.
name|on_value
condition|)
name|print_single_switch
argument_list|(
literal|"-f"
argument_list|,
name|f_options
index|[
name|j
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
sizeof|sizeof
name|W_options
operator|/
sizeof|sizeof
name|W_options
index|[
literal|0
index|]
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|*
name|W_options
index|[
name|j
index|]
operator|.
name|variable
operator|==
name|W_options
index|[
name|j
index|]
operator|.
name|on_value
condition|)
name|print_single_switch
argument_list|(
literal|"-W"
argument_list|,
name|W_options
index|[
name|j
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
sizeof|sizeof
name|target_switches
operator|/
sizeof|sizeof
name|target_switches
index|[
literal|0
index|]
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|target_switches
index|[
name|j
index|]
operator|.
name|name
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
name|target_switches
index|[
name|j
index|]
operator|.
name|value
operator|>
literal|0
operator|&&
operator|(
operator|(
name|target_switches
index|[
name|j
index|]
operator|.
name|value
operator|&
name|target_flags
operator|)
operator|==
name|target_switches
index|[
name|j
index|]
operator|.
name|value
operator|)
condition|)
name|print_single_switch
argument_list|(
literal|"-m"
argument_list|,
name|target_switches
index|[
name|j
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

