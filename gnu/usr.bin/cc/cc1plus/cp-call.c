begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Functions related to invoking methods and overloaded functions.    Copyright (C) 1987, 1992, 1993 Free Software Foundation, Inc.    Contributed by Michael Tiemann (tiemann@cygnus.com)  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* High-level class interface. */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_function_decl
specifier|extern
name|void
name|sorry
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|int
name|inhibit_warnings
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|flag_assume_nonnull_objects
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|tree
name|ctor_label
decl_stmt|,
name|dtor_label
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* From cp-typeck.c:  */
end_comment

begin_function_decl
specifier|extern
name|tree
name|unary_complex_lvalue
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Compute the ease with which a conversion can be performed    between an expected and the given type.  */
end_comment

begin_function_decl
specifier|static
name|int
name|convert_harshness
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|EVIL_HARSHNESS
parameter_list|(
name|ARG
parameter_list|)
value|((ARG)& 1)
end_define

begin_define
define|#
directive|define
name|ELLIPSIS_HARSHNESS
parameter_list|(
name|ARG
parameter_list|)
value|((ARG)& 2)
end_define

begin_define
define|#
directive|define
name|USER_HARSHNESS
parameter_list|(
name|ARG
parameter_list|)
value|((ARG)& 4)
end_define

begin_define
define|#
directive|define
name|CONTRAVARIANT_HARSHNESS
parameter_list|(
name|ARG
parameter_list|)
value|((ARG)& 8)
end_define

begin_define
define|#
directive|define
name|BASE_DERIVED_HARSHNESS
parameter_list|(
name|ARG
parameter_list|)
value|((ARG)& 16)
end_define

begin_define
define|#
directive|define
name|INT_TO_BD_HARSHNESS
parameter_list|(
name|ARG
parameter_list|)
value|(((ARG)<< 5) | 16)
end_define

begin_define
define|#
directive|define
name|INT_FROM_BD_HARSHNESS
parameter_list|(
name|ARG
parameter_list|)
value|((ARG)>> 5)
end_define

begin_define
define|#
directive|define
name|INT_TO_EASY_HARSHNESS
parameter_list|(
name|ARG
parameter_list|)
value|((ARG)<< 5)
end_define

begin_define
define|#
directive|define
name|INT_FROM_EASY_HARSHNESS
parameter_list|(
name|ARG
parameter_list|)
value|((ARG)>> 5)
end_define

begin_define
define|#
directive|define
name|ONLY_EASY_HARSHNESS
parameter_list|(
name|ARG
parameter_list|)
value|(((ARG)& 31) == 0)
end_define

begin_define
define|#
directive|define
name|CONST_HARSHNESS
parameter_list|(
name|ARG
parameter_list|)
value|((ARG)& 2048)
end_define

begin_comment
comment|/* Ordering function for overload resolution.  */
end_comment

begin_function
name|int
name|rank_for_overload
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|struct
name|candidate
modifier|*
name|x
decl_stmt|,
decl|*
name|y
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
name|y
operator|->
name|evil
operator|-
name|x
operator|->
name|evil
condition|)
return|return
name|y
operator|->
name|evil
operator|-
name|x
operator|->
name|evil
return|;
if|if
condition|(
name|CONST_HARSHNESS
argument_list|(
name|y
operator|->
name|harshness
index|[
literal|0
index|]
argument_list|)
operator|^
name|CONST_HARSHNESS
argument_list|(
name|x
operator|->
name|harshness
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
name|y
operator|->
name|harshness
index|[
literal|0
index|]
operator|-
name|x
operator|->
name|harshness
index|[
literal|0
index|]
return|;
if|if
condition|(
name|y
operator|->
name|ellipsis
operator|-
name|x
operator|->
name|ellipsis
condition|)
return|return
name|y
operator|->
name|ellipsis
operator|-
name|x
operator|->
name|ellipsis
return|;
if|if
condition|(
name|y
operator|->
name|user
operator|-
name|x
operator|->
name|user
condition|)
return|return
name|y
operator|->
name|user
operator|-
name|x
operator|->
name|user
return|;
if|if
condition|(
name|y
operator|->
name|b_or_d
operator|-
name|x
operator|->
name|b_or_d
condition|)
return|return
name|y
operator|->
name|b_or_d
operator|-
name|x
operator|->
name|b_or_d
return|;
return|return
name|y
operator|->
name|easy
operator|-
name|x
operator|->
name|easy
return|;
block|}
end_block

begin_comment
comment|/* TYPE is the type we wish to convert to.  PARM is the parameter    we have to work with.  We use a somewhat arbitrary cost function    to measure this conversion.  */
end_comment

begin_function
specifier|static
name|int
name|convert_harshness
parameter_list|(
name|type
parameter_list|,
name|parmtype
parameter_list|,
name|parm
parameter_list|)
specifier|register
name|tree
name|type
decl_stmt|,
name|parmtype
decl_stmt|;
name|tree
name|parm
decl_stmt|;
block|{
specifier|register
name|enum
name|tree_code
name|codel
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|coder
init|=
name|TREE_CODE
argument_list|(
name|parmtype
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_convert_harshness
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|parmtype
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|coder
operator|==
name|ERROR_MARK
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|codel
operator|==
name|POINTER_TYPE
operator|&&
operator|(
name|coder
operator|==
name|METHOD_TYPE
operator|||
name|coder
operator|==
name|FUNCTION_TYPE
operator|)
condition|)
block|{
name|tree
name|p1
decl_stmt|,
name|p2
decl_stmt|;
name|int
name|harshness
decl_stmt|,
name|new_harshness
decl_stmt|;
comment|/* Get to the METHOD_TYPE or FUNCTION_TYPE that this might be.  */
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|coder
operator|!=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
return|return
literal|1
return|;
name|harshness
operator|=
literal|0
expr_stmt|;
comment|/* We allow the default conversion between function type 	 and pointer-to-function type for free.  */
if|if
condition|(
name|type
operator|==
name|parmtype
condition|)
return|return
literal|0
return|;
comment|/* Compare return types.  */
name|p1
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|p2
operator|=
name|TREE_TYPE
argument_list|(
name|parmtype
argument_list|)
expr_stmt|;
name|new_harshness
operator|=
name|convert_harshness
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_harshness
operator|&
literal|1
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|BASE_DERIVED_HARSHNESS
argument_list|(
name|new_harshness
argument_list|)
condition|)
block|{
name|tree
name|binfo
decl_stmt|;
comment|/* This only works for pointers.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|p1
argument_list|)
operator|!=
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|p1
argument_list|)
operator|!=
name|REFERENCE_TYPE
condition|)
return|return
literal|1
return|;
name|p1
operator|=
name|TREE_TYPE
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|p2
operator|=
name|TREE_TYPE
argument_list|(
name|p2
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONTRAVARIANT_HARSHNESS
argument_list|(
name|new_harshness
argument_list|)
condition|)
name|binfo
operator|=
name|get_binfo
argument_list|(
name|p2
argument_list|,
name|p1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|binfo
operator|=
name|get_binfo
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|BINFO_OFFSET_ZEROP
argument_list|(
name|binfo
argument_list|)
condition|)
block|{
specifier|static
name|int
name|explained
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|CONTRAVARIANT_HARSHNESS
argument_list|(
name|new_harshness
argument_list|)
condition|)
name|message_2_types
argument_list|(
name|sorry
argument_list|,
literal|"cannot cast `%d' to `%d' at function call site"
argument_list|,
name|p2
argument_list|,
name|p1
argument_list|)
expr_stmt|;
else|else
name|message_2_types
argument_list|(
name|sorry
argument_list|,
literal|"cannot cast `%d' to `%d' at function call site"
argument_list|,
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|explained
operator|++
condition|)
name|sorry
argument_list|(
literal|"(because pointer values change during conversion)"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
name|harshness
operator||=
name|new_harshness
expr_stmt|;
name|p1
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|p2
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|parmtype
argument_list|)
expr_stmt|;
while|while
condition|(
name|p1
operator|&&
name|TREE_VALUE
argument_list|(
name|p1
argument_list|)
operator|!=
name|void_type_node
operator|&&
name|p2
operator|&&
name|TREE_VALUE
argument_list|(
name|p2
argument_list|)
operator|!=
name|void_type_node
condition|)
block|{
name|new_harshness
operator|=
name|convert_harshness
argument_list|(
name|TREE_VALUE
argument_list|(
name|p1
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|p2
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|EVIL_HARSHNESS
argument_list|(
name|new_harshness
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|BASE_DERIVED_HARSHNESS
argument_list|(
name|new_harshness
argument_list|)
condition|)
block|{
comment|/* This only works for pointers and references. */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|p1
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|p1
argument_list|)
argument_list|)
operator|!=
name|REFERENCE_TYPE
condition|)
return|return
literal|1
return|;
name|new_harshness
operator|^=
name|CONTRAVARIANT_HARSHNESS
argument_list|(
name|new_harshness
argument_list|)
expr_stmt|;
name|harshness
operator||=
name|new_harshness
expr_stmt|;
block|}
comment|/* This trick allows use to accumulate easy type 	     conversions without messing up the bits that encode 	     info about more involved things.  */
elseif|else
if|if
condition|(
name|ONLY_EASY_HARSHNESS
argument_list|(
name|new_harshness
argument_list|)
condition|)
name|harshness
operator|+=
name|new_harshness
expr_stmt|;
else|else
name|harshness
operator||=
name|new_harshness
expr_stmt|;
name|p1
operator|=
name|TREE_CHAIN
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|p2
operator|=
name|TREE_CHAIN
argument_list|(
name|p2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p1
operator|==
name|p2
condition|)
return|return
name|harshness
return|;
if|if
condition|(
name|p2
condition|)
return|return
name|p1
condition|?
literal|1
else|:
operator|(
name|harshness
operator||
name|ELLIPSIS_HARSHNESS
argument_list|(
operator|-
literal|1
argument_list|)
operator|)
return|;
if|if
condition|(
name|p1
condition|)
return|return
name|harshness
operator||
operator|(
name|TREE_PURPOSE
argument_list|(
name|p1
argument_list|)
operator|==
name|NULL_TREE
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|codel
operator|==
name|POINTER_TYPE
operator|&&
name|coder
operator|==
name|OFFSET_TYPE
condition|)
block|{
comment|/* XXX: Note this is set a few times, but it's never actually 	 used! (bpk) */
name|int
name|harshness
decl_stmt|;
comment|/* Get to the OFFSET_TYPE that this might be.  */
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|coder
operator|!=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
return|return
literal|1
return|;
name|harshness
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|parmtype
argument_list|)
condition|)
name|harshness
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|UNIQUELY_DERIVED_FROM_P
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|parmtype
argument_list|)
argument_list|)
condition|)
name|harshness
operator|=
name|INT_TO_BD_HARSHNESS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|UNIQUELY_DERIVED_FROM_P
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|parmtype
argument_list|)
argument_list|,
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|harshness
operator|=
name|CONTRAVARIANT_HARSHNESS
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
return|return
literal|1
return|;
comment|/* Now test the OFFSET_TYPE's target compatibility.  */
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|parmtype
operator|=
name|TREE_TYPE
argument_list|(
name|parmtype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|coder
operator|==
name|UNKNOWN_TYPE
condition|)
block|{
if|if
condition|(
name|codel
operator|==
name|FUNCTION_TYPE
operator|||
name|codel
operator|==
name|METHOD_TYPE
operator|||
operator|(
name|codel
operator|==
name|POINTER_TYPE
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
operator|)
operator|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|coder
operator|==
name|VOID_TYPE
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|codel
operator|==
name|ENUMERAL_TYPE
operator|||
name|codel
operator|==
name|INTEGER_TYPE
condition|)
block|{
comment|/* Control equivalence of ints an enums.  */
if|if
condition|(
name|codel
operator|==
name|ENUMERAL_TYPE
operator|&&
name|flag_int_enum_equivalence
operator|==
literal|0
condition|)
block|{
comment|/* Enums can be converted to ints, but not vice-versa.  */
if|if
condition|(
name|coder
operator|!=
name|ENUMERAL_TYPE
operator|||
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_MAIN_VARIANT
argument_list|(
name|parmtype
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
comment|/* else enums and ints (almost) freely interconvert.  */
if|if
condition|(
name|coder
operator|==
name|INTEGER_TYPE
operator|||
name|coder
operator|==
name|ENUMERAL_TYPE
condition|)
block|{
name|int
name|easy
init|=
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|^
name|TREE_UNSIGNED
argument_list|(
name|parmtype
argument_list|)
decl_stmt|;
if|if
condition|(
name|codel
operator|!=
name|coder
condition|)
name|easy
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_MODE
argument_list|(
name|parmtype
argument_list|)
condition|)
name|easy
operator|+=
literal|2
expr_stmt|;
return|return
name|INT_TO_EASY_HARSHNESS
argument_list|(
name|easy
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|coder
operator|==
name|REAL_TYPE
condition|)
return|return
name|INT_TO_EASY_HARSHNESS
argument_list|(
literal|4
argument_list|)
return|;
block|}
if|if
condition|(
name|codel
operator|==
name|REAL_TYPE
condition|)
if|if
condition|(
name|coder
operator|==
name|REAL_TYPE
condition|)
comment|/* Shun converting between float and double if a choice exists.  */
block|{
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_MODE
argument_list|(
name|parmtype
argument_list|)
condition|)
return|return
name|INT_TO_EASY_HARSHNESS
argument_list|(
literal|2
argument_list|)
return|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|coder
operator|==
name|INTEGER_TYPE
operator|||
name|coder
operator|==
name|ENUMERAL_TYPE
condition|)
return|return
name|INT_TO_EASY_HARSHNESS
argument_list|(
literal|4
argument_list|)
return|;
comment|/* convert arrays which have not previously been converted.  */
if|if
condition|(
name|codel
operator|==
name|ARRAY_TYPE
condition|)
name|codel
operator|=
name|POINTER_TYPE
expr_stmt|;
if|if
condition|(
name|coder
operator|==
name|ARRAY_TYPE
condition|)
name|coder
operator|=
name|POINTER_TYPE
expr_stmt|;
comment|/* Conversions among pointers */
if|if
condition|(
name|codel
operator|==
name|POINTER_TYPE
operator|&&
name|coder
operator|==
name|POINTER_TYPE
condition|)
block|{
specifier|register
name|tree
name|ttl
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|ttr
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|parmtype
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|penalty
init|=
literal|4
operator|*
operator|(
name|ttl
operator|!=
name|ttr
operator|)
decl_stmt|;
comment|/* Anything converts to void *.  void * converts to anything. 	 Since these may be `const void *' (etc.) use VOID_TYPE 	 instead of void_type_node. 	 Otherwise, the targets must be the same, 	 except that we do allow (at some cost) conversion 	 between signed and unsinged pointer types.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|==
name|METHOD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|==
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
condition|)
block|{
if|if
condition|(
name|comptypes
argument_list|(
name|ttl
argument_list|,
name|ttr
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
return|return
name|INT_TO_EASY_HARSHNESS
argument_list|(
name|penalty
argument_list|)
return|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|==
name|VOID_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|==
name|VOID_TYPE
operator|||
operator|(
name|TREE_UNSIGNED
argument_list|(
name|ttl
argument_list|)
operator|^
name|TREE_UNSIGNED
argument_list|(
name|ttr
argument_list|)
operator|&&
operator|(
name|ttl
operator|=
name|unsigned_type
argument_list|(
name|ttl
argument_list|)
operator|,
name|ttr
operator|=
name|unsigned_type
argument_list|(
name|ttr
argument_list|)
operator|,
name|penalty
operator|=
literal|10
operator|,
literal|0
operator|)
operator|)
operator|||
operator|(
name|comp_target_types
argument_list|(
name|ttl
argument_list|,
name|ttr
argument_list|,
literal|0
argument_list|)
operator|)
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|penalty
operator|==
literal|10
condition|)
return|return
name|INT_TO_EASY_HARSHNESS
argument_list|(
literal|10
argument_list|)
return|;
if|if
condition|(
name|ttr
operator|==
name|ttl
condition|)
return|return
name|INT_TO_BD_HARSHNESS
argument_list|(
literal|0
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
block|{
name|int
name|b_or_d
init|=
name|get_base_distance
argument_list|(
name|ttl
argument_list|,
name|ttr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|b_or_d
operator|<
literal|0
condition|)
block|{
name|b_or_d
operator|=
name|get_base_distance
argument_list|(
name|ttr
argument_list|,
name|ttl
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|b_or_d
operator|<
literal|0
condition|)
return|return
literal|1
return|;
return|return
name|CONTRAVARIANT_HARSHNESS
argument_list|(
operator|-
literal|1
argument_list|)
return|;
block|}
return|return
name|INT_TO_BD_HARSHNESS
argument_list|(
name|b_or_d
argument_list|)
return|;
block|}
comment|/* If converting from a `class*' to a `void*', make it 	 less favorable than any inheritance relationship.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|==
name|VOID_TYPE
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|ttr
argument_list|)
condition|)
return|return
name|INT_TO_BD_HARSHNESS
argument_list|(
name|CLASSTYPE_MAX_DEPTH
argument_list|(
name|ttr
argument_list|)
operator|+
literal|1
argument_list|)
return|;
return|return
name|INT_TO_EASY_HARSHNESS
argument_list|(
name|penalty
argument_list|)
return|;
block|}
if|if
condition|(
name|codel
operator|==
name|POINTER_TYPE
operator|&&
name|coder
operator|==
name|INTEGER_TYPE
condition|)
block|{
comment|/* This is not a bad match, but don't let it beat 	 integer-enum combinations.  */
if|if
condition|(
name|parm
operator|&&
name|integer_zerop
argument_list|(
name|parm
argument_list|)
condition|)
return|return
name|INT_TO_EASY_HARSHNESS
argument_list|(
literal|4
argument_list|)
return|;
block|}
comment|/* C++: one of the types must be a reference type.  */
block|{
name|tree
name|ttl
decl_stmt|,
name|ttr
decl_stmt|;
specifier|register
name|tree
name|intype
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|parmtype
argument_list|)
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|form
init|=
name|TREE_CODE
argument_list|(
name|intype
argument_list|)
decl_stmt|;
name|int
name|penalty
decl_stmt|;
if|if
condition|(
name|codel
operator|==
name|REFERENCE_TYPE
operator|||
name|coder
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|ttl
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|codel
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|ttl
operator|=
name|TREE_TYPE
argument_list|(
name|ttl
argument_list|)
expr_stmt|;
comment|/* When passing a non-const argument into a const reference, 	       dig it a little, so a non-const reference is preferred over 	       this one. (mrs) */
if|if
condition|(
name|parm
operator|&&
name|TREE_READONLY
argument_list|(
name|ttl
argument_list|)
operator|&&
operator|!
name|TREE_READONLY
argument_list|(
name|parm
argument_list|)
condition|)
name|penalty
operator|=
literal|2
expr_stmt|;
else|else
name|penalty
operator|=
literal|0
expr_stmt|;
name|ttl
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|ttl
argument_list|)
expr_stmt|;
if|if
condition|(
name|form
operator|==
name|OFFSET_TYPE
condition|)
block|{
name|intype
operator|=
name|TREE_TYPE
argument_list|(
name|intype
argument_list|)
expr_stmt|;
name|form
operator|=
name|TREE_CODE
argument_list|(
name|intype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|form
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|intype
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|intype
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ttl
operator|==
name|intype
condition|)
return|return
literal|0
return|;
name|penalty
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
comment|/* Can reference be built up?  */
if|if
condition|(
name|ttl
operator|==
name|intype
operator|&&
name|penalty
operator|==
literal|0
condition|)
block|{
comment|/* Because the READONLY bits and VOLATILE bits are not 		     always in the type, this extra check is necessary.  The 		     problem should be fixed someplace else, and this extra 		     code removed.  		     Also, if type if a reference, the readonly bits could 		     either be in the outer type (with reference) or on the 		     inner type (the thing being referenced).  (mrs)  */
if|if
condition|(
name|parm
operator|&&
operator|(
operator|(
name|TREE_READONLY
argument_list|(
name|parm
argument_list|)
operator|&&
operator|!
operator|(
name|TYPE_READONLY
argument_list|(
name|type
argument_list|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|&&
name|TYPE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|parm
argument_list|)
operator|&&
operator|!
operator|(
name|TYPE_VOLATILE
argument_list|(
name|type
argument_list|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|&&
name|TYPE_VOLATILE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|penalty
operator|=
literal|2
expr_stmt|;
else|else
return|return
literal|0
return|;
block|}
else|else
name|penalty
operator|=
literal|2
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|form
operator|==
name|REFERENCE_TYPE
condition|)
block|{
if|if
condition|(
name|parm
condition|)
block|{
name|tree
name|tmp
init|=
name|convert_from_reference
argument_list|(
name|parm
argument_list|)
decl_stmt|;
name|intype
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|intype
operator|=
name|parmtype
expr_stmt|;
do|do
block|{
name|intype
operator|=
name|TREE_TYPE
argument_list|(
name|intype
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|TREE_CODE
argument_list|(
name|intype
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
do|;
name|intype
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|intype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ttl
operator|==
name|intype
condition|)
return|return
literal|0
return|;
else|else
name|penalty
operator|=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|ttl
argument_list|)
operator|^
name|TREE_UNSIGNED
argument_list|(
name|intype
argument_list|)
condition|)
block|{
name|ttl
operator|=
name|unsigned_type
argument_list|(
name|ttl
argument_list|)
expr_stmt|;
name|intype
operator|=
name|unsigned_type
argument_list|(
name|intype
argument_list|)
expr_stmt|;
name|penalty
operator|+=
literal|2
expr_stmt|;
block|}
name|ttr
operator|=
name|intype
expr_stmt|;
comment|/* If the initializer is not an lvalue, then it does not 	   matter if we make life easier for the programmer 	   by creating a temporary variable with which to 	   hold the result.  */
if|if
condition|(
name|parm
operator|&&
operator|(
name|coder
operator|==
name|INTEGER_TYPE
operator|||
name|coder
operator|==
name|ENUMERAL_TYPE
operator|||
name|coder
operator|==
name|REAL_TYPE
operator|)
operator|&&
operator|!
name|lvalue_p
argument_list|(
name|parm
argument_list|)
condition|)
return|return
operator|(
name|convert_harshness
argument_list|(
name|ttl
argument_list|,
name|ttr
argument_list|,
name|NULL_TREE
argument_list|)
operator||
name|INT_TO_EASY_HARSHNESS
argument_list|(
name|penalty
argument_list|)
operator|)
return|;
if|if
condition|(
name|ttl
operator|==
name|ttr
condition|)
block|{
if|if
condition|(
name|penalty
condition|)
return|return
name|INT_TO_EASY_HARSHNESS
argument_list|(
name|penalty
argument_list|)
return|;
return|return
name|INT_TO_BD_HARSHNESS
argument_list|(
literal|0
argument_list|)
return|;
block|}
comment|/* Pointers to voids always convert for pointers.  But 	   make them less natural than more specific matches.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|ttl
argument_list|)
operator|==
name|void_type_node
operator|||
name|TREE_TYPE
argument_list|(
name|ttr
argument_list|)
operator|==
name|void_type_node
condition|)
return|return
name|INT_TO_EASY_HARSHNESS
argument_list|(
name|penalty
operator|+
literal|1
argument_list|)
return|;
if|if
condition|(
name|parm
operator|&&
name|codel
operator|!=
name|REFERENCE_TYPE
condition|)
return|return
operator|(
name|convert_harshness
argument_list|(
name|ttl
argument_list|,
name|ttr
argument_list|,
name|NULL_TREE
argument_list|)
operator||
name|INT_TO_EASY_HARSHNESS
argument_list|(
name|penalty
argument_list|)
operator|)
return|;
comment|/* Here it does matter.  If this conversion is from 	   derived to base, allow it.  Otherwise, types must 	   be compatible in the strong sense.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
block|{
name|int
name|b_or_d
init|=
name|get_base_distance
argument_list|(
name|ttl
argument_list|,
name|ttr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|b_or_d
operator|<
literal|0
condition|)
block|{
name|b_or_d
operator|=
name|get_base_distance
argument_list|(
name|ttr
argument_list|,
name|ttl
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|b_or_d
operator|<
literal|0
condition|)
return|return
literal|1
return|;
return|return
name|CONTRAVARIANT_HARSHNESS
argument_list|(
operator|-
literal|1
argument_list|)
return|;
block|}
comment|/* Say that this conversion is relatively painless. 	       If it turns out that there is a user-defined X(X&) 	       constructor, then that will be invoked, but that's 	       preferable to dealing with other user-defined conversions 	       that may produce surprising results.  */
return|return
name|INT_TO_BD_HARSHNESS
argument_list|(
name|b_or_d
argument_list|)
return|;
block|}
if|if
condition|(
name|comp_target_types
argument_list|(
name|ttl
argument_list|,
name|intype
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|INT_TO_EASY_HARSHNESS
argument_list|(
name|penalty
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|codel
operator|==
name|RECORD_TYPE
operator|&&
name|coder
operator|==
name|RECORD_TYPE
condition|)
block|{
name|int
name|b_or_d
init|=
name|get_base_distance
argument_list|(
name|type
argument_list|,
name|parmtype
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|b_or_d
operator|<
literal|0
condition|)
block|{
name|b_or_d
operator|=
name|get_base_distance
argument_list|(
name|parmtype
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|b_or_d
operator|<
literal|0
condition|)
return|return
literal|1
return|;
return|return
name|CONTRAVARIANT_HARSHNESS
argument_list|(
operator|-
literal|1
argument_list|)
return|;
block|}
return|return
name|INT_TO_BD_HARSHNESS
argument_list|(
name|b_or_d
argument_list|)
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Algorithm: Start out with no strikes against.  For each argument    which requires a (subjective) hard conversion (such as between    floating point and integer), issue a strike.  If there are the same    number of formal and actual parameters in the list, there will be at    least on strike, otherwise an exact match would have been found.  If    there are not the same number of arguments in the type lists, we are    not dead yet: a `...' means that we can have more parms then were    declared, and if we wind up in the default argument section of the    list those can be used as well.  If an exact match could be found for    one of those cases, return it immediately.  Otherwise, rank the fields    so that fields with fewer strikes are tried first.     Conversions between builtin and user-defined types are allowed, but    no function involving such a conversion is preferred to one which    does not require such a conversion.  Furthermore, such conversions    must be unique.  */
end_comment

begin_function
name|void
name|compute_conversion_costs
parameter_list|(
name|function
parameter_list|,
name|tta_in
parameter_list|,
name|cp
parameter_list|,
name|arglen
parameter_list|)
name|tree
name|function
decl_stmt|;
name|tree
name|tta_in
decl_stmt|;
name|struct
name|candidate
modifier|*
name|cp
decl_stmt|;
name|int
name|arglen
decl_stmt|;
block|{
name|tree
name|ttf_in
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|ttf
init|=
name|ttf_in
decl_stmt|;
name|tree
name|tta
init|=
name|tta_in
decl_stmt|;
comment|/* Start out with no strikes against.  */
name|int
name|evil_strikes
init|=
literal|0
decl_stmt|;
name|int
name|ellipsis_strikes
init|=
literal|0
decl_stmt|;
name|int
name|user_strikes
init|=
literal|0
decl_stmt|;
name|int
name|b_or_d_strikes
init|=
literal|0
decl_stmt|;
name|int
name|easy_strikes
init|=
literal|0
decl_stmt|;
name|int
name|strike_index
init|=
literal|0
decl_stmt|,
name|win
decl_stmt|,
name|lose
decl_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_compute_conversion_costs
operator|++
expr_stmt|;
endif|#
directive|endif
name|cp
operator|->
name|function
operator|=
name|function
expr_stmt|;
name|cp
operator|->
name|arg
operator|=
name|tta
condition|?
name|TREE_VALUE
argument_list|(
name|tta
argument_list|)
else|:
name|NULL_TREE
expr_stmt|;
name|cp
operator|->
name|u
operator|.
name|bad_arg
operator|=
literal|0
expr_stmt|;
comment|/* optimistic!  */
name|bzero
argument_list|(
name|cp
operator|->
name|harshness
argument_list|,
operator|(
name|arglen
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|ttf
operator|&&
name|tta
condition|)
block|{
name|int
name|harshness
decl_stmt|;
if|if
condition|(
name|ttf
operator|==
name|void_list_node
condition|)
break|break;
if|if
condition|(
name|type_unknown_p
argument_list|(
name|TREE_VALUE
argument_list|(
name|tta
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Must perform some instantiation here.  */
name|tree
name|rhs
init|=
name|TREE_VALUE
argument_list|(
name|tta
argument_list|)
decl_stmt|;
name|tree
name|lhstype
init|=
name|TREE_VALUE
argument_list|(
name|ttf
argument_list|)
decl_stmt|;
comment|/* Keep quiet about possible contravariance violations.  */
name|int
name|old_inhibit_warnings
init|=
name|inhibit_warnings
decl_stmt|;
name|inhibit_warnings
operator|=
literal|1
expr_stmt|;
comment|/* @@ This is to undo what `grokdeclarator' does to 	     parameter types.  It really should go through 	     something more general.  */
name|TREE_TYPE
argument_list|(
name|tta
argument_list|)
operator|=
name|unknown_type_node
expr_stmt|;
name|rhs
operator|=
name|instantiate_type
argument_list|(
name|lhstype
argument_list|,
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|inhibit_warnings
operator|=
name|old_inhibit_warnings
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|ERROR_MARK
condition|)
name|harshness
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|harshness
operator|=
name|convert_harshness
argument_list|(
name|lhstype
argument_list|,
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
comment|/* harshness |= 2; */
block|}
block|}
else|else
name|harshness
operator|=
name|convert_harshness
argument_list|(
name|TREE_VALUE
argument_list|(
name|ttf
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tta
argument_list|)
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|tta
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|->
name|harshness
index|[
name|strike_index
index|]
operator|=
name|harshness
expr_stmt|;
if|if
condition|(
name|EVIL_HARSHNESS
argument_list|(
name|harshness
argument_list|)
operator|||
name|CONTRAVARIANT_HARSHNESS
argument_list|(
name|harshness
argument_list|)
condition|)
block|{
name|cp
operator|->
name|u
operator|.
name|bad_arg
operator|=
name|strike_index
expr_stmt|;
name|evil_strikes
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ELLIPSIS_HARSHNESS
argument_list|(
name|harshness
argument_list|)
condition|)
block|{
name|ellipsis_strikes
operator|+=
literal|1
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* This is never set by `convert_harshness'.  */
if|else if (USER_HARSHNESS (harshness)) 	{ 	  user_strikes += 1; 	}
endif|#
directive|endif
elseif|else
if|if
condition|(
name|BASE_DERIVED_HARSHNESS
argument_list|(
name|harshness
argument_list|)
condition|)
block|{
name|b_or_d_strikes
operator|+=
name|INT_FROM_BD_HARSHNESS
argument_list|(
name|harshness
argument_list|)
expr_stmt|;
block|}
else|else
name|easy_strikes
operator|+=
name|INT_FROM_EASY_HARSHNESS
argument_list|(
name|harshness
argument_list|)
expr_stmt|;
name|ttf
operator|=
name|TREE_CHAIN
argument_list|(
name|ttf
argument_list|)
expr_stmt|;
name|tta
operator|=
name|TREE_CHAIN
argument_list|(
name|tta
argument_list|)
expr_stmt|;
name|strike_index
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|tta
condition|)
block|{
comment|/* ran out of formals, and parmlist is fixed size.  */
if|if
condition|(
name|ttf
comment|/* == void_type_node */
condition|)
block|{
name|cp
operator|->
name|evil
operator|=
literal|1
expr_stmt|;
name|cp
operator|->
name|u
operator|.
name|bad_arg
operator|=
operator|-
literal|1
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|ttf
operator|&&
name|ttf
operator|!=
name|void_list_node
condition|)
block|{
comment|/* ran out of actuals, and no defaults.  */
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|ttf
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|cp
operator|->
name|evil
operator|=
literal|1
expr_stmt|;
name|cp
operator|->
name|u
operator|.
name|bad_arg
operator|=
operator|-
literal|2
expr_stmt|;
return|return;
block|}
comment|/* Store index of first default.  */
name|cp
operator|->
name|harshness
index|[
name|arglen
index|]
operator|=
name|strike_index
operator|+
literal|1
expr_stmt|;
block|}
else|else
name|cp
operator|->
name|harshness
index|[
name|arglen
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Argument list lengths work out, so don't need to check them again.  */
if|if
condition|(
name|evil_strikes
condition|)
block|{
comment|/* We do not check for derived->base conversions here, since in 	 no case would they give evil strike counts, unless such conversions 	 are somehow ambiguous.  */
comment|/* See if any user-defined conversions apply.          But make sure that we do not loop.  */
specifier|static
name|int
name|dont_convert_types
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|dont_convert_types
condition|)
block|{
name|cp
operator|->
name|evil
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|win
operator|=
literal|0
expr_stmt|;
comment|/* Only get one chance to win.  */
name|ttf
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
name|tta
operator|=
name|tta_in
expr_stmt|;
name|strike_index
operator|=
literal|0
expr_stmt|;
name|evil_strikes
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ttf
operator|&&
name|tta
condition|)
block|{
if|if
condition|(
name|ttf
operator|==
name|void_list_node
condition|)
break|break;
name|lose
operator|=
name|cp
operator|->
name|harshness
index|[
name|strike_index
index|]
expr_stmt|;
if|if
condition|(
name|EVIL_HARSHNESS
argument_list|(
name|lose
argument_list|)
operator|||
name|CONTRAVARIANT_HARSHNESS
argument_list|(
name|lose
argument_list|)
condition|)
block|{
name|tree
name|actual_type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tta
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|formal_type
init|=
name|TREE_VALUE
argument_list|(
name|ttf
argument_list|)
decl_stmt|;
name|dont_convert_types
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|formal_type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|formal_type
operator|=
name|TREE_TYPE
argument_list|(
name|formal_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|actual_type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|actual_type
operator|=
name|TREE_TYPE
argument_list|(
name|actual_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|formal_type
operator|!=
name|error_mark_node
operator|&&
name|actual_type
operator|!=
name|error_mark_node
condition|)
block|{
name|formal_type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|formal_type
argument_list|)
expr_stmt|;
name|actual_type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|actual_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|formal_type
argument_list|)
condition|)
block|{
comment|/* If it has a constructor for this type, try to use it.  */
if|if
condition|(
name|convert_to_aggr
argument_list|(
name|formal_type
argument_list|,
name|TREE_VALUE
argument_list|(
name|tta
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
operator|!=
name|error_mark_node
condition|)
block|{
comment|/* @@ There is no way to save this result yet. 			     @@ So success is NULL_TREE for now.  */
name|win
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|actual_type
argument_list|)
operator|&&
name|TYPE_HAS_CONVERSION
argument_list|(
name|actual_type
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|formal_type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_HAS_INT_CONVERSION
argument_list|(
name|actual_type
argument_list|)
condition|)
name|win
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|formal_type
argument_list|)
operator|==
name|REAL_TYPE
operator|&&
name|TYPE_HAS_REAL_CONVERSION
argument_list|(
name|actual_type
argument_list|)
condition|)
name|win
operator|++
expr_stmt|;
else|else
block|{
name|tree
name|conv
init|=
name|build_type_conversion
argument_list|(
name|CALL_EXPR
argument_list|,
name|TREE_VALUE
argument_list|(
name|ttf
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|tta
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|conv
condition|)
block|{
if|if
condition|(
name|conv
operator|==
name|error_mark_node
condition|)
name|win
operator|+=
literal|2
expr_stmt|;
else|else
name|win
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|ttf
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|conv
operator|=
name|build_type_conversion
argument_list|(
name|CALL_EXPR
argument_list|,
name|formal_type
argument_list|,
name|TREE_VALUE
argument_list|(
name|tta
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|conv
condition|)
block|{
if|if
condition|(
name|conv
operator|==
name|error_mark_node
condition|)
name|win
operator|+=
literal|2
expr_stmt|;
else|else
name|win
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
name|dont_convert_types
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|win
operator|==
literal|1
condition|)
block|{
name|user_strikes
operator|+=
literal|1
expr_stmt|;
name|cp
operator|->
name|harshness
index|[
name|strike_index
index|]
operator|=
name|USER_HARSHNESS
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|win
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cp
operator|->
name|u
operator|.
name|bad_arg
operator|>
name|strike_index
condition|)
name|cp
operator|->
name|u
operator|.
name|bad_arg
operator|=
name|strike_index
expr_stmt|;
name|evil_strikes
operator|=
name|win
condition|?
literal|2
else|:
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|ttf
operator|=
name|TREE_CHAIN
argument_list|(
name|ttf
argument_list|)
expr_stmt|;
name|tta
operator|=
name|TREE_CHAIN
argument_list|(
name|tta
argument_list|)
expr_stmt|;
name|strike_index
operator|+=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Const member functions get a small penalty because defaulting      to const is less useful than defaulting to non-const. */
comment|/* This is bogus, it does not correspond to anything in the ARM.      This code will be fixed when this entire section is rewritten      to conform to the ARM.  (mrs)  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
if|if
condition|(
name|TYPE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|ttf_in
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|cp
operator|->
name|harshness
index|[
literal|0
index|]
operator|+=
name|INT_TO_EASY_HARSHNESS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|++
name|easy_strikes
expr_stmt|;
block|}
else|else
block|{
comment|/* Calling a non-const member function from a const member function 	     is probably invalid, but for now we let it only draw a warning. 	     We indicate that such a mismatch has occurred by setting the 	     harshness to a maximum value.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tta_in
argument_list|)
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
operator|(
name|TYPE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tta_in
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
name|cp
operator|->
name|harshness
index|[
literal|0
index|]
operator||=
name|CONST_HARSHNESS
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|cp
operator|->
name|evil
operator|=
name|evil_strikes
expr_stmt|;
name|cp
operator|->
name|ellipsis
operator|=
name|ellipsis_strikes
expr_stmt|;
name|cp
operator|->
name|user
operator|=
name|user_strikes
expr_stmt|;
name|cp
operator|->
name|b_or_d
operator|=
name|b_or_d_strikes
expr_stmt|;
name|cp
operator|->
name|easy
operator|=
name|easy_strikes
expr_stmt|;
block|}
end_function

begin_comment
comment|/* When one of several possible overloaded functions and/or methods    can be called, choose the best candidate for overloading.     BASETYPE is the context from which we start method resolution    or NULL if we are comparing overloaded functions.    CANDIDATES is the array of candidates we have to choose from.    N_CANDIDATES is the length of CANDIDATES.    PARMS is a TREE_LIST of parameters to the function we'll ultimately    choose.  It is modified in place when resolving methods.  It is not    modified in place when resolving overloaded functions.    LEN is the length of the parameter list.  */
end_comment

begin_function
specifier|static
name|struct
name|candidate
modifier|*
name|ideal_candidate
parameter_list|(
name|basetype
parameter_list|,
name|candidates
parameter_list|,
name|n_candidates
parameter_list|,
name|parms
parameter_list|,
name|len
parameter_list|)
name|tree
name|basetype
decl_stmt|;
name|struct
name|candidate
modifier|*
name|candidates
decl_stmt|;
name|int
name|n_candidates
decl_stmt|;
name|tree
name|parms
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|struct
name|candidate
modifier|*
name|cp
init|=
name|candidates
operator|+
name|n_candidates
decl_stmt|;
name|int
name|index
decl_stmt|,
name|i
decl_stmt|;
name|tree
name|ttf
decl_stmt|;
name|qsort
argument_list|(
name|candidates
argument_list|,
comment|/* char *base */
name|n_candidates
argument_list|,
comment|/* int nel */
sizeof|sizeof
argument_list|(
expr|struct
name|candidate
argument_list|)
argument_list|,
comment|/* int width */
name|rank_for_overload
argument_list|)
expr_stmt|;
comment|/* int (*compar)() */
comment|/* If the best candidate requires user-defined conversions,      and its user-defined conversions are a strict subset      of all other candidates requiring user-defined conversions,      then it is, in fact, the best.  */
for|for
control|(
name|i
operator|=
operator|-
literal|1
init|;
name|cp
operator|+
name|i
operator|!=
name|candidates
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|cp
index|[
name|i
index|]
operator|.
name|user
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|i
operator|<
operator|-
literal|1
condition|)
block|{
name|tree
name|ttf0
decl_stmt|;
comment|/* Check that every other candidate requires those conversions 	 as a strict subset of their conversions.  */
if|if
condition|(
name|cp
index|[
name|i
index|]
operator|.
name|user
operator|==
name|cp
index|[
operator|-
literal|1
index|]
operator|.
name|user
condition|)
goto|goto
name|non_subset
goto|;
comment|/* Look at subset relationship more closely.  */
while|while
condition|(
name|i
operator|!=
operator|-
literal|1
condition|)
block|{
for|for
control|(
name|ttf
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|cp
index|[
name|i
index|]
operator|.
name|function
argument_list|)
argument_list|)
operator|,
name|ttf0
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|cp
index|[
operator|-
literal|1
index|]
operator|.
name|function
argument_list|)
argument_list|)
operator|,
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|len
condition|;
name|ttf
operator|=
name|TREE_CHAIN
argument_list|(
name|ttf
argument_list|)
operator|,
name|ttf0
operator|=
name|TREE_CHAIN
argument_list|(
name|ttf0
argument_list|)
operator|,
name|index
operator|++
control|)
if|if
condition|(
name|USER_HARSHNESS
argument_list|(
name|cp
index|[
name|i
index|]
operator|.
name|harshness
index|[
name|index
index|]
argument_list|)
condition|)
block|{
comment|/* If our "best" candidate also needs a conversion, 		   it must be the same one.  */
if|if
condition|(
name|USER_HARSHNESS
argument_list|(
name|cp
index|[
operator|-
literal|1
index|]
operator|.
name|harshness
index|[
name|index
index|]
argument_list|)
operator|&&
name|TREE_VALUE
argument_list|(
name|ttf
argument_list|)
operator|!=
name|TREE_VALUE
argument_list|(
name|ttf0
argument_list|)
condition|)
goto|goto
name|non_subset
goto|;
block|}
name|i
operator|++
expr_stmt|;
block|}
comment|/* The best was the best.  */
return|return
name|cp
operator|-
literal|1
return|;
name|non_subset
label|:
comment|/* Use other rules for determining "bestness".  */
empty_stmt|;
block|}
comment|/* If the best two candidates we find require user-defined      conversions, we may need to report and error message.  */
if|if
condition|(
name|cp
index|[
operator|-
literal|1
index|]
operator|.
name|user
operator|&&
name|cp
index|[
operator|-
literal|2
index|]
operator|.
name|user
operator|&&
operator|(
name|cp
index|[
operator|-
literal|1
index|]
operator|.
name|b_or_d
operator|||
name|cp
index|[
operator|-
literal|2
index|]
operator|.
name|b_or_d
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* If the best two methods found involved user-defined 	 type conversions, then we must see whether one 	 of them is exactly what we wanted.  If not, then 	 we have an ambiguity.  */
name|int
name|best
init|=
literal|0
decl_stmt|;
name|tree
name|tta
init|=
name|parms
decl_stmt|;
name|tree
name|f1
decl_stmt|;
if|#
directive|if
literal|0
comment|/* for LUCID */
block|tree p1;
endif|#
directive|endif
comment|/* Stash all of our parameters in safe places 	 so that we can perform type conversions in place.  */
while|while
condition|(
name|tta
condition|)
block|{
name|TREE_PURPOSE
argument_list|(
name|tta
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|tta
argument_list|)
expr_stmt|;
name|tta
operator|=
name|TREE_CHAIN
argument_list|(
name|tta
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|int
name|exact_conversions
init|=
literal|0
decl_stmt|;
name|i
operator|-=
literal|1
expr_stmt|;
name|tta
operator|=
name|parms
expr_stmt|;
if|if
condition|(
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|cp
index|[
name|i
index|]
operator|.
name|function
argument_list|)
condition|)
name|tta
operator|=
name|TREE_CHAIN
argument_list|(
name|tta
argument_list|)
expr_stmt|;
comment|/* special note, we don't go through len parameters, because we 	     may only need len-1 parameters because of a call to a static 	     member. */
for|for
control|(
name|ttf
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|cp
index|[
name|i
index|]
operator|.
name|function
argument_list|)
argument_list|)
operator|,
name|index
operator|=
literal|0
init|;
name|tta
condition|;
name|tta
operator|=
name|TREE_CHAIN
argument_list|(
name|tta
argument_list|)
operator|,
name|ttf
operator|=
name|TREE_CHAIN
argument_list|(
name|ttf
argument_list|)
operator|,
name|index
operator|++
control|)
block|{
if|if
condition|(
name|USER_HARSHNESS
argument_list|(
name|cp
index|[
name|i
index|]
operator|.
name|harshness
index|[
name|index
index|]
argument_list|)
condition|)
block|{
name|tree
name|this_parm
init|=
name|build_type_conversion
argument_list|(
name|CALL_EXPR
argument_list|,
name|TREE_VALUE
argument_list|(
name|ttf
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|tta
argument_list|)
argument_list|,
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
name|basetype
operator|!=
name|NULL_TREE
condition|)
name|TREE_VALUE
argument_list|(
name|tta
argument_list|)
operator|=
name|this_parm
expr_stmt|;
if|if
condition|(
name|this_parm
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|this_parm
argument_list|)
operator|!=
name|CONVERT_EXPR
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|this_parm
argument_list|)
operator|!=
name|NOP_EXPR
operator|||
name|comp_target_types
argument_list|(
name|TREE_TYPE
argument_list|(
name|this_parm
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|this_parm
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
name|exact_conversions
operator|+=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|PROMOTES_TO_AGGR_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|ttf
argument_list|)
argument_list|,
name|REFERENCE_TYPE
argument_list|)
condition|)
block|{
comment|/* To get here we had to have succeeded via 			 a constructor.  */
name|TREE_VALUE
argument_list|(
name|tta
argument_list|)
operator|=
name|TREE_PURPOSE
argument_list|(
name|tta
argument_list|)
expr_stmt|;
name|exact_conversions
operator|+=
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|exact_conversions
operator|==
name|cp
index|[
name|i
index|]
operator|.
name|user
condition|)
block|{
if|if
condition|(
name|best
operator|==
literal|0
condition|)
block|{
name|best
operator|=
name|i
expr_stmt|;
name|f1
operator|=
name|cp
index|[
name|best
index|]
operator|.
name|function
expr_stmt|;
if|#
directive|if
literal|0
comment|/* For LUCID */
block|p1 = TYPE_ARG_TYPES (TREE_TYPE (f1));
endif|#
directive|endif
block|}
else|else
block|{
comment|/* Don't complain if next best is from base class.  */
name|tree
name|f2
init|=
name|cp
index|[
name|i
index|]
operator|.
name|function
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|f1
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|f2
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
operator|&&
name|BASE_DERIVED_HARSHNESS
argument_list|(
name|cp
index|[
name|i
index|]
operator|.
name|harshness
index|[
literal|0
index|]
argument_list|)
operator|&&
name|cp
index|[
name|best
index|]
operator|.
name|harshness
index|[
literal|0
index|]
operator|<
name|cp
index|[
name|i
index|]
operator|.
name|harshness
index|[
literal|0
index|]
condition|)
block|{
if|#
directive|if
literal|0
block|tree p2 = TYPE_ARG_TYPES (TREE_TYPE (f2));
comment|/* For LUCID.  */
block|if (! compparms (TREE_CHAIN (p1), TREE_CHAIN (p2), 1)) 			goto ret0; 		      else
endif|#
directive|endif
continue|continue;
block|}
else|else
block|{
comment|/* Ensure that there's nothing ambiguous about these 			 two fns.  */
name|int
name|identical
init|=
literal|1
decl_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|len
condition|;
name|index
operator|++
control|)
block|{
comment|/* Type conversions must be piecewise equivalent.  */
if|if
condition|(
name|USER_HARSHNESS
argument_list|(
name|cp
index|[
name|best
index|]
operator|.
name|harshness
index|[
name|index
index|]
argument_list|)
operator|!=
name|USER_HARSHNESS
argument_list|(
name|cp
index|[
name|i
index|]
operator|.
name|harshness
index|[
name|index
index|]
argument_list|)
condition|)
goto|goto
name|ret0
goto|;
comment|/* If there's anything we like better about the 			     other function, consider it ambiguous.  */
if|if
condition|(
name|cp
index|[
name|i
index|]
operator|.
name|harshness
index|[
name|index
index|]
operator|<
name|cp
index|[
name|best
index|]
operator|.
name|harshness
index|[
name|index
index|]
condition|)
goto|goto
name|ret0
goto|;
comment|/* If any single one it diffent, then the whole is 			     not identical.  */
if|if
condition|(
name|cp
index|[
name|i
index|]
operator|.
name|harshness
index|[
name|index
index|]
operator|!=
name|cp
index|[
name|best
index|]
operator|.
name|harshness
index|[
name|index
index|]
condition|)
name|identical
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If we can't tell the difference between the two, it 			 is ambiguous.  */
if|if
condition|(
name|identical
condition|)
goto|goto
name|ret0
goto|;
comment|/* If we made it to here, it means we're satisfied that 			 BEST is still best.  */
continue|continue;
block|}
block|}
block|}
block|}
do|while
condition|(
name|cp
operator|+
name|i
operator|!=
name|candidates
condition|)
do|;
if|if
condition|(
name|best
condition|)
block|{
name|int
name|exact_conversions
init|=
name|cp
index|[
name|best
index|]
operator|.
name|user
decl_stmt|;
name|tta
operator|=
name|parms
expr_stmt|;
if|if
condition|(
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|cp
index|[
name|best
index|]
operator|.
name|function
argument_list|)
condition|)
name|tta
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
expr_stmt|;
for|for
control|(
name|ttf
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|cp
index|[
name|best
index|]
operator|.
name|function
argument_list|)
argument_list|)
operator|,
name|index
operator|=
literal|0
init|;
name|exact_conversions
operator|>
literal|0
condition|;
name|tta
operator|=
name|TREE_CHAIN
argument_list|(
name|tta
argument_list|)
operator|,
name|ttf
operator|=
name|TREE_CHAIN
argument_list|(
name|ttf
argument_list|)
operator|,
name|index
operator|++
control|)
block|{
if|if
condition|(
name|USER_HARSHNESS
argument_list|(
name|cp
index|[
name|best
index|]
operator|.
name|harshness
index|[
name|index
index|]
argument_list|)
condition|)
block|{
comment|/* We must now fill in the slot we left behind. 		     @@ This could be optimized to use the value previously 		     @@ computed by build_type_conversion in some cases.  */
if|if
condition|(
name|basetype
operator|!=
name|NULL_TREE
condition|)
name|TREE_VALUE
argument_list|(
name|tta
argument_list|)
operator|=
name|convert
argument_list|(
name|TREE_VALUE
argument_list|(
name|ttf
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|tta
argument_list|)
argument_list|)
expr_stmt|;
name|exact_conversions
operator|-=
literal|1
expr_stmt|;
block|}
else|else
name|TREE_VALUE
argument_list|(
name|tta
argument_list|)
operator|=
name|TREE_PURPOSE
argument_list|(
name|tta
argument_list|)
expr_stmt|;
block|}
return|return
name|cp
operator|+
name|best
return|;
block|}
goto|goto
name|ret0
goto|;
block|}
comment|/* If the best two candidates we find both use default parameters,      we may need to report and error.  Don't need to worry if next-best      candidate is forced to use user-defined conversion when best is not.  */
if|if
condition|(
name|cp
index|[
operator|-
literal|2
index|]
operator|.
name|user
operator|==
literal|0
operator|&&
name|cp
index|[
operator|-
literal|1
index|]
operator|.
name|harshness
index|[
name|len
index|]
operator|!=
literal|0
operator|&&
name|cp
index|[
operator|-
literal|2
index|]
operator|.
name|harshness
index|[
name|len
index|]
operator|!=
literal|0
condition|)
block|{
name|tree
name|tt1
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|cp
index|[
operator|-
literal|1
index|]
operator|.
name|function
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|tt2
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|cp
index|[
operator|-
literal|2
index|]
operator|.
name|function
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|i
init|=
name|cp
index|[
operator|-
literal|1
index|]
operator|.
name|harshness
index|[
name|len
index|]
decl_stmt|;
if|if
condition|(
name|cp
index|[
operator|-
literal|2
index|]
operator|.
name|harshness
index|[
name|len
index|]
operator|<
name|i
condition|)
name|i
operator|=
name|cp
index|[
operator|-
literal|2
index|]
operator|.
name|harshness
index|[
name|len
index|]
expr_stmt|;
while|while
condition|(
operator|--
name|i
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_VALUE
argument_list|(
name|tt1
argument_list|)
argument_list|)
operator|!=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_VALUE
argument_list|(
name|tt2
argument_list|)
argument_list|)
condition|)
comment|/* These lists are not identical, so we can choose our best candidate.  */
return|return
name|cp
operator|-
literal|1
return|;
name|tt1
operator|=
name|TREE_CHAIN
argument_list|(
name|tt1
argument_list|)
expr_stmt|;
name|tt2
operator|=
name|TREE_CHAIN
argument_list|(
name|tt2
argument_list|)
expr_stmt|;
block|}
comment|/* To get here, both lists had the same parameters up to the defaults 	 which were used.  This is an ambiguous request.  */
goto|goto
name|ret0
goto|;
block|}
comment|/* Otherwise, return our best candidate.  Note that if we get candidates      from independent base classes, we have an ambiguity, even if one      argument list look a little better than another one.  */
if|if
condition|(
name|cp
index|[
operator|-
literal|1
index|]
operator|.
name|b_or_d
operator|&&
name|basetype
operator|&&
name|TYPE_USES_MULTIPLE_INHERITANCE
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
name|int
name|i
init|=
name|n_candidates
operator|-
literal|1
decl_stmt|,
name|best
init|=
name|i
decl_stmt|;
name|tree
name|base1
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|candidates
index|[
name|i
index|]
operator|.
name|function
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
return|return
name|cp
operator|-
literal|1
return|;
for|for
control|(
init|;
name|i
operator|>=
literal|0
operator|&&
name|candidates
index|[
name|i
index|]
operator|.
name|user
operator|==
literal|0
operator|&&
name|candidates
index|[
name|i
index|]
operator|.
name|evil
operator|==
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|candidates
index|[
name|i
index|]
operator|.
name|function
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|tree
name|newbase
init|=
name|DECL_CLASS_CONTEXT
argument_list|(
name|candidates
index|[
name|i
index|]
operator|.
name|function
argument_list|)
decl_stmt|;
if|if
condition|(
name|base1
operator|!=
name|NULL_TREE
condition|)
block|{
comment|/* newbase could be a base or a parent of base1 */
if|if
condition|(
name|newbase
operator|!=
name|base1
operator|&&
operator|!
name|UNIQUELY_DERIVED_FROM_P
argument_list|(
name|newbase
argument_list|,
name|base1
argument_list|)
operator|&&
operator|!
name|UNIQUELY_DERIVED_FROM_P
argument_list|(
name|base1
argument_list|,
name|newbase
argument_list|)
condition|)
block|{
name|error_with_aggr_type
argument_list|(
name|basetype
argument_list|,
literal|"ambiguous request for function from distinct base classes of type `%s'"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"  first candidate is `%s'"
argument_list|,
name|fndecl_as_string
argument_list|(
literal|0
argument_list|,
name|candidates
index|[
name|best
index|]
operator|.
name|function
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"  second candidate is `%s'"
argument_list|,
name|fndecl_as_string
argument_list|(
literal|0
argument_list|,
name|candidates
index|[
name|i
index|]
operator|.
name|function
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|cp
index|[
operator|-
literal|1
index|]
operator|.
name|evil
operator|=
literal|1
expr_stmt|;
return|return
name|cp
operator|-
literal|1
return|;
block|}
block|}
else|else
block|{
name|best
operator|=
name|i
expr_stmt|;
name|base1
operator|=
name|newbase
expr_stmt|;
block|}
block|}
else|else
return|return
name|cp
operator|-
literal|1
return|;
block|}
block|}
comment|/* Don't accept a candidate as being ideal if it's indistinguishable      from another candidate.  */
if|if
condition|(
name|rank_for_overload
argument_list|(
name|cp
operator|-
literal|1
argument_list|,
name|cp
operator|-
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* If the types are distinguishably different (like 	 `long' vs. `unsigned long'), that's ok.  But if they are arbitrarily 	 different, such as `int (*)(void)' vs. `void (*)(int)', 	 that's not ok.  */
name|tree
name|p1
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|cp
index|[
operator|-
literal|1
index|]
operator|.
name|function
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|p2
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|cp
index|[
operator|-
literal|2
index|]
operator|.
name|function
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
name|p1
operator|&&
name|p2
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|p1
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|p1
argument_list|)
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|&&
name|TREE_VALUE
argument_list|(
name|p1
argument_list|)
operator|!=
name|TREE_VALUE
argument_list|(
name|p2
argument_list|)
condition|)
return|return
literal|0
return|;
name|p1
operator|=
name|TREE_CHAIN
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|p2
operator|=
name|TREE_CHAIN
argument_list|(
name|p2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p1
operator|||
name|p2
condition|)
return|return
literal|0
return|;
block|}
return|return
name|cp
operator|-
literal|1
return|;
name|ret0
label|:
comment|/* In the case where there is no ideal candidate, restore      TREE_VALUE slots of PARMS from TREE_PURPOSE slots.  */
while|while
condition|(
name|parms
condition|)
block|{
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
operator|=
name|TREE_PURPOSE
argument_list|(
name|parms
argument_list|)
expr_stmt|;
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Assume that if the class referred to is not in the    current class hierarchy, that it may be remote.    PARENT is assumed to be of aggregate type here.  */
end_comment

begin_function
specifier|static
name|int
name|may_be_remote
parameter_list|(
name|parent
parameter_list|)
name|tree
name|parent
decl_stmt|;
block|{
if|if
condition|(
name|TYPE_OVERLOADS_METHOD_CALL_EXPR
argument_list|(
name|parent
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|current_class_type
operator|==
name|NULL_TREE
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|parent
operator|==
name|current_class_type
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|UNIQUELY_DERIVED_FROM_P
argument_list|(
name|parent
argument_list|,
name|current_class_type
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|tree
name|build_vfield_ref
parameter_list|(
name|datum
parameter_list|,
name|type
parameter_list|)
name|tree
name|datum
decl_stmt|,
name|type
decl_stmt|;
block|{
name|tree
name|rval
decl_stmt|;
name|int
name|old_assume_nonnull_objects
init|=
name|flag_assume_nonnull_objects
decl_stmt|;
if|if
condition|(
name|datum
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* Vtable references are always made from non-null objects.  */
name|flag_assume_nonnull_objects
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|datum
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|datum
operator|=
name|convert_from_reference
argument_list|(
name|datum
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_USES_COMPLEX_INHERITANCE
argument_list|(
name|type
argument_list|)
condition|)
name|rval
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|CLASSTYPE_VFIELD
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|datum
argument_list|,
name|CLASSTYPE_VFIELD
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|rval
operator|=
name|build_component_ref
argument_list|(
name|datum
argument_list|,
name|DECL_NAME
argument_list|(
name|CLASSTYPE_VFIELD
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|flag_assume_nonnull_objects
operator|=
name|old_assume_nonnull_objects
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* Build a call to a member of an object.  I.e., one that overloads    operator ()(), or is a pointer-to-function or pointer-to-method.  */
end_comment

begin_function
specifier|static
name|tree
name|build_field_call
parameter_list|(
name|basetype_path
parameter_list|,
name|instance_ptr
parameter_list|,
name|name
parameter_list|,
name|parms
parameter_list|,
name|err_name
parameter_list|)
name|tree
name|basetype_path
decl_stmt|;
name|tree
name|instance_ptr
decl_stmt|,
name|name
decl_stmt|,
name|parms
decl_stmt|;
name|char
modifier|*
name|err_name
decl_stmt|;
block|{
name|tree
name|field
decl_stmt|,
name|instance
decl_stmt|;
if|if
condition|(
name|instance_ptr
operator|==
name|current_class_decl
condition|)
block|{
comment|/* Check to see if we really have a reference to an instance variable 	 with `operator()()' overloaded.  */
name|field
operator|=
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|field
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"`this' has no member named `%s'"
argument_list|,
name|err_name
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
comment|/* If it's a field, try overloading operator (), 	     or calling if the field is a pointer-to-function.  */
name|instance
operator|=
name|build_component_ref_1
argument_list|(
name|C_C_D
argument_list|,
name|field
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|instance
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
operator|&&
name|TYPE_OVERLOADS_CALL_EXPR
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
condition|)
return|return
name|build_opfncall
argument_list|(
name|CALL_EXPR
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|instance
argument_list|,
name|parms
argument_list|,
name|NULL_TREE
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
return|return
name|build_function_call
argument_list|(
name|instance
argument_list|,
name|parms
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
return|return
name|build_function_call
argument_list|(
name|instance
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|current_class_decl
argument_list|,
name|parms
argument_list|)
argument_list|)
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
comment|/* Check to see if this is not really a reference to an instance variable      with `operator()()' overloaded.  */
name|field
operator|=
name|lookup_field
argument_list|(
name|basetype_path
argument_list|,
name|name
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* This can happen if the reference was ambiguous      or for visibility violations.  */
if|if
condition|(
name|field
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|field
condition|)
block|{
name|tree
name|basetype
decl_stmt|;
name|tree
name|ftype
init|=
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|ftype
argument_list|)
operator|&&
name|TYPE_OVERLOADS_CALL_EXPR
argument_list|(
name|ftype
argument_list|)
condition|)
block|{
comment|/* Make the next search for this field very short.  */
name|basetype
operator|=
name|DECL_FIELD_CONTEXT
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|instance_ptr
operator|=
name|convert_pointer_to
argument_list|(
name|basetype
argument_list|,
name|instance_ptr
argument_list|)
expr_stmt|;
name|instance
operator|=
name|build_indirect_ref
argument_list|(
name|instance_ptr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|build_opfncall
argument_list|(
name|CALL_EXPR
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|build_component_ref_1
argument_list|(
name|instance
argument_list|,
name|field
argument_list|,
literal|0
argument_list|)
argument_list|,
name|parms
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ftype
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ftype
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ftype
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
comment|/* This is a member which is a pointer to function.  */
name|tree
name|ref
init|=
name|build_component_ref_1
argument_list|(
name|build_indirect_ref
argument_list|(
name|instance_ptr
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|field
argument_list|,
name|LOOKUP_COMPLAIN
argument_list|)
decl_stmt|;
if|if
condition|(
name|ref
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
return|return
name|build_function_call
argument_list|(
name|ref
argument_list|,
name|parms
argument_list|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ftype
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"invalid call via pointer-to-member function"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
else|else
return|return
name|NULL_TREE
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_function
name|tree
name|find_scoped_type
parameter_list|(
name|type
parameter_list|,
name|inner_name
parameter_list|,
name|inner_types
parameter_list|)
name|tree
name|type
decl_stmt|,
name|inner_name
decl_stmt|,
name|inner_types
decl_stmt|;
block|{
name|tree
name|tags
init|=
name|CLASSTYPE_TAGS
argument_list|(
name|type
argument_list|)
decl_stmt|;
while|while
condition|(
name|tags
condition|)
block|{
comment|/* The TREE_PURPOSE of an enum tag (which becomes a member of the 	 enclosing class) is set to the name for the enum type.  So, if 	 inner_name is `bar', and we strike `baz' for `enum bar { baz }', 	 then this test will be true.  */
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|tags
argument_list|)
operator|==
name|inner_name
condition|)
block|{
if|if
condition|(
name|inner_types
operator|==
name|NULL_TREE
condition|)
return|return
name|DECL_NESTED_TYPENAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|TREE_VALUE
argument_list|(
name|tags
argument_list|)
argument_list|)
argument_list|)
return|;
return|return
name|resolve_scope_to_name
argument_list|(
name|TREE_VALUE
argument_list|(
name|tags
argument_list|)
argument_list|,
name|inner_types
argument_list|)
return|;
block|}
name|tags
operator|=
name|TREE_CHAIN
argument_list|(
name|tags
argument_list|)
expr_stmt|;
block|}
comment|/* Look for a TYPE_DECL.  */
for|for
control|(
name|tags
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|tags
condition|;
name|tags
operator|=
name|TREE_CHAIN
argument_list|(
name|tags
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tags
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_NAME
argument_list|(
name|tags
argument_list|)
operator|==
name|inner_name
condition|)
block|{
comment|/* Code by raeburn.  */
if|if
condition|(
name|inner_types
operator|==
name|NULL_TREE
condition|)
return|return
name|DECL_NESTED_TYPENAME
argument_list|(
name|tags
argument_list|)
return|;
return|return
name|resolve_scope_to_name
argument_list|(
name|TREE_TYPE
argument_list|(
name|tags
argument_list|)
argument_list|,
name|inner_types
argument_list|)
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Resolve an expression NAME1::NAME2::...::NAMEn to    the name that names the above nested type.  INNER_TYPES    is a chain of nested type names (held together by SCOPE_REFs);    OUTER_TYPE is the type we know to enclose INNER_TYPES.    Returns NULL_TREE if there is an error.  */
end_comment

begin_function
name|tree
name|resolve_scope_to_name
parameter_list|(
name|outer_type
parameter_list|,
name|inner_types
parameter_list|)
name|tree
name|outer_type
decl_stmt|,
name|inner_types
decl_stmt|;
block|{
specifier|register
name|tree
name|tmp
decl_stmt|;
name|tree
name|inner_name
decl_stmt|;
if|if
condition|(
name|outer_type
operator|==
name|NULL_TREE
operator|&&
name|current_class_type
operator|!=
name|NULL_TREE
condition|)
block|{
comment|/* We first try to look for a nesting in our current class context,          then try any enclosing classes.  */
name|tree
name|type
init|=
name|current_class_type
decl_stmt|;
while|while
condition|(
name|type
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
operator|)
condition|)
block|{
name|tree
name|rval
init|=
name|resolve_scope_to_name
argument_list|(
name|type
argument_list|,
name|inner_types
argument_list|)
decl_stmt|;
if|if
condition|(
name|rval
operator|!=
name|NULL_TREE
condition|)
return|return
name|rval
return|;
name|type
operator|=
name|DECL_CONTEXT
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|inner_types
argument_list|)
operator|==
name|SCOPE_REF
condition|)
block|{
name|inner_name
operator|=
name|TREE_OPERAND
argument_list|(
name|inner_types
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|inner_types
operator|=
name|TREE_OPERAND
argument_list|(
name|inner_types
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|inner_name
operator|=
name|inner_types
expr_stmt|;
name|inner_types
operator|=
name|NULL_TREE
expr_stmt|;
block|}
if|if
condition|(
name|outer_type
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* If we have something that's already a type by itself, 	 use that.  */
if|if
condition|(
name|IDENTIFIER_HAS_TYPE_VALUE
argument_list|(
name|inner_name
argument_list|)
condition|)
block|{
if|if
condition|(
name|inner_types
condition|)
return|return
name|resolve_scope_to_name
argument_list|(
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|inner_name
argument_list|)
argument_list|,
name|inner_types
argument_list|)
return|;
return|return
name|inner_name
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|outer_type
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Look for member classes or enums.  */
name|tmp
operator|=
name|find_scoped_type
argument_list|(
name|outer_type
argument_list|,
name|inner_name
argument_list|,
name|inner_types
argument_list|)
expr_stmt|;
comment|/* If it's not a type in this class, then go down into the      base classes and search there.  */
if|if
condition|(
operator|!
name|tmp
operator|&&
name|TYPE_BINFO
argument_list|(
name|outer_type
argument_list|)
condition|)
block|{
name|tree
name|binfos
init|=
name|TYPE_BINFO_BASETYPES
argument_list|(
name|outer_type
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baselinks
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baselinks
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tmp
operator|=
name|find_scoped_type
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|,
name|inner_name
argument_list|,
name|inner_types
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
condition|)
return|return
name|tmp
return|;
block|}
name|tmp
operator|=
name|NULL_TREE
expr_stmt|;
block|}
return|return
name|tmp
return|;
block|}
end_function

begin_comment
comment|/* Build a method call of the form `EXP->SCOPES::NAME (PARMS)'.    This is how virtual function calls are avoided.  */
end_comment

begin_function
name|tree
name|build_scoped_method_call
parameter_list|(
name|exp
parameter_list|,
name|scopes
parameter_list|,
name|name
parameter_list|,
name|parms
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|tree
name|scopes
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|tree
name|parms
decl_stmt|;
block|{
comment|/* Because this syntactic form does not allow      a pointer to a base class to be `stolen',      we need not protect the derived->base conversion      that happens here.            @@ But we do have to check visibility privileges later.  */
name|tree
name|basename
init|=
name|resolve_scope_to_name
argument_list|(
name|NULL_TREE
argument_list|,
name|scopes
argument_list|)
decl_stmt|;
name|tree
name|basetype
decl_stmt|,
name|binfo
decl_stmt|,
name|decl
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
operator|||
name|basename
operator|==
name|NULL_TREE
operator|||
operator|!
name|is_aggr_typedef
argument_list|(
name|basename
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"base object of scoped method call is not of aggregate type"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|basetype
operator|=
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|basename
argument_list|)
expr_stmt|;
if|if
condition|(
name|binfo
operator|=
name|binfo_or_else
argument_list|(
name|basetype
argument_list|,
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|binfo
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
name|decl
operator|=
name|build_indirect_ref
argument_list|(
name|convert_pointer_to
argument_list|(
name|binfo
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|decl
operator|=
name|build_scoped_ref
argument_list|(
name|exp
argument_list|,
name|scopes
argument_list|)
expr_stmt|;
comment|/* Call to a destructor.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|BIT_NOT_EXPR
condition|)
block|{
comment|/* Explicit call to destructor.  */
name|name
operator|=
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_aggr_typedef
argument_list|(
name|name
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|!=
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|error_with_aggr_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|"qualified type `%s' does not match destructor type `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
operator|!
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|error_with_aggr_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|"type `%s' has no destructor"
argument_list|)
expr_stmt|;
return|return
name|build_delete
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|decl
argument_list|,
name|integer_two_node
argument_list|,
name|LOOKUP_NORMAL
operator||
name|LOOKUP_NONVIRTUAL
operator||
name|LOOKUP_DESTRUCTOR
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/* Call to a method.  */
return|return
name|build_method_call
argument_list|(
name|decl
argument_list|,
name|name
argument_list|,
name|parms
argument_list|,
name|NULL_TREE
argument_list|,
name|LOOKUP_NORMAL
operator||
name|LOOKUP_NONVIRTUAL
argument_list|)
return|;
block|}
return|return
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* Build something of the form ptr->method (args)    or object.method (args).  This can also build    calls to constructors, and find friends.     Member functions always take their class variable    as a pointer.     INSTANCE is a class instance.     NAME is the NAME field of the struct, union, or class    whose type is that of INSTANCE.     PARMS help to figure out what that NAME really refers to.     BASETYPE_PATH, if non-NULL, tells which basetypes of INSTANCE    we should be traversed before starting our search.  We need    this information to get protected accesses correct.     FLAGS is the logical disjunction of zero or more LOOKUP_    flags.  See cp-tree.h for more info.     If this is all OK, calls build_function_call with the resolved    member function.     This function must also handle being called to perform    initialization, promotion/coercion of arguments, and    instantiation of default parameters.     Note that NAME may refer to an instance variable name.  If    `operator()()' is defined for the type of that field, then we return    that result.  */
end_comment

begin_function
name|tree
name|build_method_call
parameter_list|(
name|instance
parameter_list|,
name|name
parameter_list|,
name|parms
parameter_list|,
name|basetype_path
parameter_list|,
name|flags
parameter_list|)
name|tree
name|instance
decl_stmt|,
name|name
decl_stmt|,
name|parms
decl_stmt|,
name|basetype_path
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
specifier|register
name|tree
name|function
decl_stmt|,
name|fntype
decl_stmt|,
name|value_type
decl_stmt|;
specifier|register
name|tree
name|basetype
decl_stmt|,
name|save_basetype
decl_stmt|;
specifier|register
name|tree
name|baselink
decl_stmt|,
name|result
decl_stmt|,
name|method_name
decl_stmt|,
name|parmtypes
decl_stmt|,
name|parm
decl_stmt|;
name|tree
name|last
decl_stmt|;
name|int
name|pass
decl_stmt|;
name|enum
name|visibility_type
name|visibility
decl_stmt|;
comment|/* Range of cases for vtable optimization.  */
enum|enum
name|vtable_needs
block|{
name|not_needed
block|,
name|maybe_needed
block|,
name|unneeded
block|,
name|needed
block|}
enum|;
name|enum
name|vtable_needs
name|need_vtbl
init|=
name|not_needed
decl_stmt|;
name|char
modifier|*
name|err_name
decl_stmt|;
name|char
modifier|*
name|name_kind
decl_stmt|;
name|int
name|ever_seen
init|=
literal|0
decl_stmt|;
name|tree
name|instance_ptr
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|all_virtual
init|=
name|flag_all_virtual
decl_stmt|;
name|int
name|static_call_context
init|=
literal|0
decl_stmt|;
name|tree
name|saw_private
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|saw_protected
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Keep track of `const' and `volatile' objects.  */
name|int
name|constp
decl_stmt|,
name|volatilep
decl_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_build_method_call
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|instance
operator|==
name|error_mark_node
operator|||
name|name
operator|==
name|error_mark_node
operator|||
name|parms
operator|==
name|error_mark_node
operator|||
operator|(
name|instance
operator|!=
name|NULL_TREE
operator|&&
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
operator|==
name|error_mark_node
operator|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* This is the logic that magically deletes the second argument to      operator delete, if it is not needed. */
if|if
condition|(
name|name
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|DELETE_EXPR
index|]
operator|&&
name|list_length
argument_list|(
name|parms
argument_list|)
operator|==
literal|2
condition|)
block|{
name|tree
name|save_last
init|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
decl_stmt|;
name|tree
name|result
decl_stmt|;
comment|/* get rid of unneeded argument */
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|result
operator|=
name|build_method_call
argument_list|(
name|instance
argument_list|,
name|name
argument_list|,
name|parms
argument_list|,
name|basetype_path
argument_list|,
operator|(
name|LOOKUP_SPECULATIVELY
operator||
name|flags
operator|)
operator|&
operator|~
name|LOOKUP_COMPLAIN
argument_list|)
expr_stmt|;
comment|/* If it works, return it. */
if|if
condition|(
name|result
operator|&&
name|result
operator|!=
name|error_mark_node
condition|)
return|return
name|build_method_call
argument_list|(
name|instance
argument_list|,
name|name
argument_list|,
name|parms
argument_list|,
name|basetype_path
argument_list|,
name|flags
argument_list|)
return|;
comment|/* If it doesn't work, two argument delete must work */
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
operator|=
name|save_last
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* C++ 2.1 does not allow this, but ANSI probably will.  */
block|if (TREE_CODE (name) == BIT_NOT_EXPR)     {       error ("invalid call to destructor, use qualified name `%s::~%s'", 	     IDENTIFIER_POINTER (name), IDENTIFIER_POINTER (name));       return error_mark_node;     }
else|#
directive|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|BIT_NOT_EXPR
condition|)
block|{
name|flags
operator||=
name|LOOKUP_DESTRUCTOR
expr_stmt|;
name|name
operator|=
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_aggr_typedef
argument_list|(
name|name
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|parms
condition|)
name|error
argument_list|(
literal|"destructors take no parameters"
argument_list|)
expr_stmt|;
name|basetype
operator|=
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
if|#
directive|if
literal|0
comment|/* ARM says tp->~T() without T::~T() is valid.  */
block|error_with_aggr_type (basetype, "type `%s' has no destructor");
endif|#
directive|endif
comment|/* A destructive destructor wouldn't be a bad idea, but let's 	     not bother for now.  */
return|return
name|build_c_cast
argument_list|(
name|void_type_node
argument_list|,
name|instance
argument_list|)
return|;
block|}
name|instance
operator|=
name|default_conversion
argument_list|(
name|instance
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
name|instance_ptr
operator|=
name|instance
expr_stmt|;
else|else
name|instance_ptr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|instance
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|build_delete
argument_list|(
name|build_pointer_type
argument_list|(
name|basetype
argument_list|)
argument_list|,
name|instance_ptr
argument_list|,
name|integer_two_node
argument_list|,
name|LOOKUP_NORMAL
operator||
name|LOOKUP_DESTRUCTOR
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
endif|#
directive|endif
comment|/* Initialize name for error reporting.  */
if|if
condition|(
name|IDENTIFIER_TYPENAME_P
argument_list|(
name|name
argument_list|)
condition|)
name|err_name
operator|=
literal|"type conversion operator"
expr_stmt|;
elseif|else
if|if
condition|(
name|IDENTIFIER_OPNAME_P
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|char
modifier|*
name|p
init|=
name|operator_name_string
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|err_name
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|err_name
argument_list|,
literal|"operator %s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|SCOPE_REF
condition|)
name|err_name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|err_name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|IDENTIFIER_OPNAME_P
argument_list|(
name|name
argument_list|)
condition|)
name|GNU_xref_call
argument_list|(
name|current_function_decl
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|GNU_xref_call
argument_list|(
name|current_function_decl
argument_list|,
name|err_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|instance
operator|==
name|NULL_TREE
condition|)
block|{
name|basetype
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Check cases where this is really a call to raise 	 an exception.  */
if|if
condition|(
name|current_class_type
operator|&&
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
name|basetype
operator|=
name|purpose_member
argument_list|(
name|name
argument_list|,
name|CLASSTYPE_TAGS
argument_list|(
name|current_class_type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|basetype
condition|)
name|basetype
operator|=
name|TREE_VALUE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|SCOPE_REF
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
if|if
condition|(
operator|!
name|is_aggr_typedef
argument_list|(
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
name|basetype
operator|=
name|purpose_member
argument_list|(
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|1
argument_list|)
argument_list|,
name|CLASSTYPE_TAGS
argument_list|(
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|basetype
condition|)
name|basetype
operator|=
name|TREE_VALUE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|basetype
operator|!=
name|NULL_TREE
condition|)
empty_stmt|;
comment|/* call to a constructor... */
elseif|else
if|if
condition|(
name|IDENTIFIER_HAS_TYPE_VALUE
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|basetype
operator|=
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|name
operator|=
name|constructor_name
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|typedef_name
init|=
name|lookup_name
argument_list|(
name|name
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|typedef_name
operator|&&
name|TREE_CODE
argument_list|(
name|typedef_name
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
comment|/* Canonicalize the typedef name.  */
name|basetype
operator|=
name|TREE_TYPE
argument_list|(
name|typedef_name
argument_list|)
expr_stmt|;
name|name
operator|=
name|TYPE_IDENTIFIER
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"no constructor named `%s' in visible scope"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
name|non_aggr_error
label|:
if|if
condition|(
operator|(
name|flags
operator|&
name|LOOKUP_COMPLAIN
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|basetype
argument_list|)
operator|!=
name|ERROR_MARK
condition|)
name|error
argument_list|(
literal|"request for member `%s' in something not a structure or union"
argument_list|,
name|err_name
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|instance
operator|==
name|C_C_D
operator|||
name|instance
operator|==
name|current_class_decl
condition|)
block|{
comment|/* When doing initialization, we side-effect the TREE_TYPE of 	 C_C_D, hence we cannot set up BASETYPE from CURRENT_CLASS_TYPE.  */
name|basetype
operator|=
name|TREE_TYPE
argument_list|(
name|C_C_D
argument_list|)
expr_stmt|;
comment|/* Anything manifestly `this' in constructors and destructors 	 has a known type, so virtual function tables are not needed.  */
if|if
condition|(
name|TYPE_VIRTUAL_P
argument_list|(
name|basetype
argument_list|)
operator|&&
operator|!
operator|(
name|flags
operator|&
name|LOOKUP_NONVIRTUAL
operator|)
condition|)
name|need_vtbl
operator|=
operator|(
name|dtor_label
operator|||
name|ctor_label
operator|)
condition|?
name|unneeded
else|:
name|maybe_needed
expr_stmt|;
name|instance
operator|=
name|C_C_D
expr_stmt|;
name|instance_ptr
operator|=
name|current_class_decl
expr_stmt|;
name|result
operator|=
name|build_field_call
argument_list|(
name|TYPE_BINFO
argument_list|(
name|current_class_type
argument_list|)
argument_list|,
name|instance_ptr
argument_list|,
name|name
argument_list|,
name|parms
argument_list|,
name|err_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
return|return
name|result
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|instance
argument_list|)
operator|==
name|RESULT_DECL
condition|)
block|{
name|basetype
operator|=
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
expr_stmt|;
comment|/* Should we ever have to make a virtual function reference 	 from a RESULT_DECL, know that it must be of fixed type 	 within the scope of this function.  */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|LOOKUP_NONVIRTUAL
operator|)
operator|&&
name|TYPE_VIRTUAL_P
argument_list|(
name|basetype
argument_list|)
condition|)
name|need_vtbl
operator|=
name|maybe_needed
expr_stmt|;
name|instance_ptr
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|basetype
argument_list|)
argument_list|,
name|instance
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|instance
operator|==
name|current_exception_object
condition|)
block|{
name|instance_ptr
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|current_exception_type
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|current_exception_object
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|mark_addressable
argument_list|(
name|TREE_OPERAND
argument_list|(
name|current_exception_object
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|build_field_call
argument_list|(
name|TYPE_BINFO
argument_list|(
name|current_exception_type
argument_list|)
argument_list|,
name|instance_ptr
argument_list|,
name|name
argument_list|,
name|parms
argument_list|,
name|err_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
return|return
name|result
return|;
name|error
argument_list|(
literal|"exception member `%s' cannot be invoked"
argument_list|,
name|err_name
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
else|else
block|{
comment|/* The MAIN_VARIANT of the type that `instance_ptr' winds up being.  */
name|tree
name|inst_ptr_basetype
decl_stmt|;
name|static_call_context
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|instance
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|)
operator|==
name|error_mark_node
operator|)
expr_stmt|;
comment|/* the base type of an instance variable is pointer to class */
name|basetype
operator|=
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|basetype
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|basetype
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|basetype
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|basetype
argument_list|)
condition|)
goto|goto
name|non_aggr_error
goto|;
comment|/* Call to convert not needed because we are remaining 	     within the same type.  */
name|instance_ptr
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|basetype
argument_list|)
argument_list|,
name|instance
argument_list|)
expr_stmt|;
name|inst_ptr_basetype
operator|=
name|basetype
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|basetype
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
name|basetype
operator|=
name|TREE_TYPE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|instance_ptr
operator|=
name|instance
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|basetype
argument_list|)
condition|)
goto|goto
name|non_aggr_error
goto|;
if|if
condition|(
operator|!
name|instance_ptr
condition|)
block|{
if|if
condition|(
operator|(
name|lvalue_p
argument_list|(
name|instance
argument_list|)
operator|&&
operator|(
name|instance_ptr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|instance
argument_list|,
literal|0
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|instance_ptr
operator|=
name|unary_complex_lvalue
argument_list|(
name|ADDR_EXPR
argument_list|,
name|instance
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|instance_ptr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|instance
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|instance
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
block|{
comment|/* A cast is not an lvalue.  Initialize a fresh temp 		     with the value we are casting from, and proceed with 		     that temporary.  We can't cast to a reference type, 		     so that simplifies the initialization to something 		     we can manage.  */
name|tree
name|temp
init|=
name|get_temp_name
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
condition|)
name|expand_aggr_init
argument_list|(
name|temp
argument_list|,
name|instance
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|store_init_value
argument_list|(
name|temp
argument_list|,
name|instance
argument_list|)
expr_stmt|;
name|expand_decl_init
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
name|instance
operator|=
name|temp
expr_stmt|;
name|instance_ptr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|instance
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|instance
argument_list|)
operator|!=
name|CALL_EXPR
condition|)
name|my_friendly_abort
argument_list|(
literal|125
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTOR
argument_list|(
name|basetype
argument_list|)
condition|)
name|instance
operator|=
name|build_cplus_new
argument_list|(
name|basetype
argument_list|,
name|instance
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|instance
operator|=
name|get_temp_name
argument_list|(
name|basetype
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
name|instance
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|instance_ptr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|instance
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* @@ Should we call comp_target_types here?  */
name|inst_ptr_basetype
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance_ptr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|basetype
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|inst_ptr_basetype
argument_list|)
condition|)
name|basetype
operator|=
name|inst_ptr_basetype
expr_stmt|;
else|else
block|{
name|instance_ptr
operator|=
name|convert
argument_list|(
name|TYPE_POINTER_TO
argument_list|(
name|basetype
argument_list|)
argument_list|,
name|instance_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|instance_ptr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
block|}
block|}
else|else
name|inst_ptr_basetype
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance_ptr
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|basetype_path
operator|==
name|NULL_TREE
condition|)
name|basetype_path
operator|=
name|TYPE_BINFO
argument_list|(
name|inst_ptr_basetype
argument_list|)
expr_stmt|;
name|result
operator|=
name|build_field_call
argument_list|(
name|basetype_path
argument_list|,
name|instance_ptr
argument_list|,
name|name
argument_list|,
name|parms
argument_list|,
name|err_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
return|return
name|result
return|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|LOOKUP_NONVIRTUAL
operator|)
operator|&&
name|TYPE_VIRTUAL_P
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|instance_ptr
argument_list|)
condition|)
block|{
comment|/* This action is needed because the instance is needed 		 for providing the base of the virtual function table. 		 Without using a SAVE_EXPR, the function we are building 		 may be called twice, or side effects on the instance 		 variable (such as a post-increment), may happen twice.  */
name|instance_ptr
operator|=
name|save_expr
argument_list|(
name|instance_ptr
argument_list|)
expr_stmt|;
name|instance
operator|=
name|build_indirect_ref
argument_list|(
name|instance_ptr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
comment|/* This happens when called for operator new ().  */
name|instance
operator|=
name|build_indirect_ref
argument_list|(
name|instance
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|need_vtbl
operator|=
name|maybe_needed
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|basetype
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* This is worth complaining about, I think.  */
name|error_with_aggr_type
argument_list|(
name|basetype
argument_list|,
literal|"cannot lookup method in incomplete type `%s'"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|save_basetype
operator|=
name|basetype
expr_stmt|;
if|#
directive|if
literal|0
block|if (all_virtual == 1&& (! strncmp (IDENTIFIER_POINTER (name), OPERATOR_METHOD_FORMAT, 		     OPERATOR_METHOD_LENGTH) 	  || instance_ptr == NULL_TREE 	  || (TYPE_OVERLOADS_METHOD_CALL_EXPR (basetype) == 0)))     all_virtual = 0;
endif|#
directive|endif
name|last
operator|=
name|NULL_TREE
expr_stmt|;
for|for
control|(
name|parmtypes
operator|=
name|NULL_TREE
operator|,
name|parm
operator|=
name|parms
init|;
name|parm
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
control|)
block|{
name|tree
name|t
init|=
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
block|{
comment|/* Convert OFFSET_TYPE entities to their normal selves.  */
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
operator|=
name|resolve_offset_ref
argument_list|(
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
comment|/* Perform the conversion from ARRAY_TYPE to POINTER_TYPE in place. 	     This eliminates needless calls to `compute_conversion_costs'.  */
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
operator|=
name|default_conversion
argument_list|(
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|last
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|parmtypes
operator|=
name|chainon
argument_list|(
name|parmtypes
argument_list|,
name|last
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|instance
condition|)
block|{
name|constp
operator|=
name|TREE_READONLY
argument_list|(
name|instance
argument_list|)
expr_stmt|;
name|volatilep
operator|=
name|TREE_THIS_VOLATILE
argument_list|(
name|instance
argument_list|)
expr_stmt|;
name|parms
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|instance_ptr
argument_list|,
name|parms
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Raw constructors are always in charge.  */
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|basetype
argument_list|)
operator|&&
operator|!
operator|(
name|flags
operator|&
name|LOOKUP_HAS_IN_CHARGE
operator|)
condition|)
block|{
name|flags
operator||=
name|LOOKUP_HAS_IN_CHARGE
expr_stmt|;
name|parms
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_one_node
argument_list|,
name|parms
argument_list|)
expr_stmt|;
name|parmtypes
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|parmtypes
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_this_is_variable
operator|>
literal|0
condition|)
block|{
name|constp
operator|=
literal|0
expr_stmt|;
name|volatilep
operator|=
literal|0
expr_stmt|;
name|parms
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|basetype
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
name|parms
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|constp
operator|=
literal|0
expr_stmt|;
name|volatilep
operator|=
literal|0
expr_stmt|;
name|instance_ptr
operator|=
name|build_new
argument_list|(
name|NULL_TREE
argument_list|,
name|basetype
argument_list|,
name|void_type_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|instance_ptr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|instance_ptr
operator|=
name|save_expr
argument_list|(
name|instance_ptr
argument_list|)
expr_stmt|;
name|TREE_CALLS_NEW
argument_list|(
name|instance_ptr
argument_list|)
operator|=
literal|1
expr_stmt|;
name|instance
operator|=
name|build_indirect_ref
argument_list|(
name|instance_ptr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* If it's a default argument initialized from a ctor, what we get 	     from instance_ptr will match the arglist for the FUNCTION_DECL 	     of the constructor.  */
if|if
condition|(
name|parms
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|==
name|CALL_EXPR
operator|&&
name|TREE_OPERAND
argument_list|(
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|&&
name|TREE_CALLS_NEW
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
condition|)
name|parms
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|instance_ptr
argument_list|)
expr_stmt|;
else|else
name|parms
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|instance_ptr
argument_list|,
name|parms
argument_list|)
expr_stmt|;
block|}
block|}
name|parmtypes
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_pointer_type
argument_list|(
name|build_type_variant
argument_list|(
name|basetype
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|)
argument_list|)
argument_list|,
name|parmtypes
argument_list|)
expr_stmt|;
if|if
condition|(
name|last
operator|==
name|NULL_TREE
condition|)
name|last
operator|=
name|parmtypes
expr_stmt|;
comment|/* Look up function name in the structure type definition.  */
if|if
condition|(
operator|(
name|IDENTIFIER_HAS_TYPE_VALUE
argument_list|(
name|name
argument_list|)
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|name
argument_list|)
argument_list|)
operator|)
operator|||
name|name
operator|==
name|constructor_name
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
name|tree
name|tmp
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|name
argument_list|)
operator|==
name|basetype
operator|||
name|name
operator|==
name|constructor_name
argument_list|(
name|basetype
argument_list|)
condition|)
name|tmp
operator|=
name|TYPE_BINFO
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
else|else
name|tmp
operator|=
name|get_binfo
argument_list|(
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|name
argument_list|)
argument_list|,
name|basetype
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
name|NULL_TREE
condition|)
block|{
name|name_kind
operator|=
literal|"constructor"
expr_stmt|;
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|basetype
argument_list|)
operator|&&
operator|!
operator|(
name|flags
operator|&
name|LOOKUP_HAS_IN_CHARGE
operator|)
condition|)
block|{
comment|/* Constructors called for initialization 		 only are never in charge.  */
name|tree
name|tmplist
decl_stmt|;
name|flags
operator||=
name|LOOKUP_HAS_IN_CHARGE
expr_stmt|;
name|tmplist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_zero_node
argument_list|,
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
operator|=
name|tmplist
expr_stmt|;
name|tmplist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
operator|=
name|tmplist
expr_stmt|;
block|}
name|basetype
operator|=
name|BINFO_TYPE
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
else|else
name|name_kind
operator|=
literal|"method"
expr_stmt|;
block|}
else|else
name|name_kind
operator|=
literal|"method"
expr_stmt|;
if|if
condition|(
name|basetype_path
operator|==
name|NULL_TREE
condition|)
name|basetype_path
operator|=
name|TYPE_BINFO
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|result
operator|=
name|lookup_fnfields
argument_list|(
name|basetype_path
argument_list|,
name|name
argument_list|,
operator|(
name|flags
operator|&
name|LOOKUP_COMPLAIN
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* Now, go look for this method name.  We do not find destructors here.       Putting `void_list_node' on the end of the parmtypes      fakes out `build_decl_overload' into doing the right thing.  */
name|TREE_CHAIN
argument_list|(
name|last
argument_list|)
operator|=
name|void_list_node
expr_stmt|;
name|method_name
operator|=
name|build_decl_overload
argument_list|(
name|name
argument_list|,
name|parmtypes
argument_list|,
literal|1
operator|+
operator|(
name|name
operator|==
name|constructor_name
argument_list|(
name|save_basetype
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|last
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
for|for
control|(
name|pass
operator|=
literal|0
init|;
name|pass
operator|<
literal|2
condition|;
name|pass
operator|++
control|)
block|{
name|struct
name|candidate
modifier|*
name|candidates
decl_stmt|;
name|struct
name|candidate
modifier|*
name|cp
decl_stmt|;
name|int
name|len
decl_stmt|;
name|unsigned
name|best
init|=
literal|1
decl_stmt|;
comment|/* This increments every time we go up the type hierarchy. 	 The idea is to prefer a function of the derived class if possible. */
name|int
name|b_or_d
init|=
literal|0
decl_stmt|;
name|baselink
operator|=
name|result
expr_stmt|;
if|if
condition|(
name|pass
operator|>
literal|0
condition|)
block|{
name|candidates
operator|=
operator|(
expr|struct
name|candidate
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|ever_seen
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|candidate
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|=
name|candidates
expr_stmt|;
name|len
operator|=
name|list_length
argument_list|(
name|parms
argument_list|)
expr_stmt|;
comment|/* First see if a global function has a shot at it.  */
if|if
condition|(
name|flags
operator|&
name|LOOKUP_GLOBAL
condition|)
block|{
name|tree
name|friend_parms
decl_stmt|;
name|tree
name|parm
init|=
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|friend_parms
operator|=
name|parms
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
name|tree
name|new_type
decl_stmt|;
name|parm
operator|=
name|build_indirect_ref
argument_list|(
name|parm
argument_list|,
literal|"friendifying parms (compiler error)"
argument_list|)
expr_stmt|;
name|new_type
operator|=
name|build_reference_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
comment|/* It is possible that this should go down a layer. */
name|new_type
operator|=
name|build_type_variant
argument_list|(
name|new_type
argument_list|,
name|TREE_READONLY
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TREE_THIS_VOLATILE
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
name|parm
operator|=
name|convert
argument_list|(
name|new_type
argument_list|,
name|parm
argument_list|)
expr_stmt|;
name|friend_parms
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|parm
argument_list|,
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|my_friendly_abort
argument_list|(
literal|167
argument_list|)
expr_stmt|;
name|cp
operator|->
name|harshness
operator|=
operator|(
name|unsigned
name|short
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|len
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|build_overload_call
argument_list|(
name|name
argument_list|,
name|friend_parms
argument_list|,
literal|0
argument_list|,
name|cp
argument_list|)
expr_stmt|;
comment|/* If it turns out to be the one we were actually looking for 		 (it was probably a friend function), the return the 		 good result.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|result
argument_list|)
operator|==
name|CALL_EXPR
condition|)
return|return
name|result
return|;
while|while
condition|(
name|cp
operator|->
name|evil
operator|==
literal|0
condition|)
block|{
comment|/* non-standard uses: set the field to 0 to indicate 		     we are using a non-member function.  */
name|cp
operator|->
name|u
operator|.
name|field
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|harshness
index|[
name|len
index|]
operator|==
literal|0
operator|&&
name|cp
operator|->
name|harshness
index|[
name|len
index|]
operator|==
literal|0
operator|&&
name|cp
operator|->
name|user
operator|==
literal|0
operator|&&
name|cp
operator|->
name|b_or_d
operator|==
literal|0
operator|&&
name|cp
operator|->
name|easy
operator|<
name|best
condition|)
name|best
operator|=
name|cp
operator|->
name|easy
expr_stmt|;
name|cp
operator|+=
literal|1
expr_stmt|;
block|}
block|}
block|}
while|while
condition|(
name|baselink
condition|)
block|{
comment|/* We have a hit (of sorts). If the parameter list is 	     "error_mark_node", or some variant thereof, it won't 	     match any methods.  Since we have verified that the is 	     some method vaguely matching this one (in name at least), 	     silently return. 	      	     Don't stop for friends, however.  */
name|tree
name|basetypes
init|=
name|TREE_PURPOSE
argument_list|(
name|baselink
argument_list|)
decl_stmt|;
name|function
operator|=
name|TREE_VALUE
argument_list|(
name|baselink
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|basetypes
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|basetypes
operator|=
name|TREE_VALUE
argument_list|(
name|basetypes
argument_list|)
expr_stmt|;
name|basetype
operator|=
name|BINFO_TYPE
argument_list|(
name|basetypes
argument_list|)
expr_stmt|;
comment|/* Cast the instance variable to the appropriate type.  */
name|TREE_VALUE
argument_list|(
name|parmtypes
argument_list|)
operator|=
name|TYPE_POINTER_TO
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
if|if
condition|(
name|DESTRUCTOR_NAME_P
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|function
argument_list|)
argument_list|)
condition|)
name|function
operator|=
name|DECL_CHAIN
argument_list|(
name|function
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|function
condition|;
name|function
operator|=
name|DECL_CHAIN
argument_list|(
name|function
argument_list|)
control|)
block|{
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_inner_fields_searched
operator|++
expr_stmt|;
endif|#
directive|endif
name|ever_seen
operator|++
expr_stmt|;
comment|/* Not looking for friends here.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|&&
operator|!
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|function
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|pass
operator|==
literal|0
operator|&&
name|DECL_ASSEMBLER_NAME
argument_list|(
name|function
argument_list|)
operator|==
name|method_name
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|LOOKUP_PROTECT
condition|)
block|{
name|visibility
operator|=
name|compute_visibility
argument_list|(
name|basetypes
argument_list|,
name|function
argument_list|)
expr_stmt|;
if|if
condition|(
name|visibility
operator|==
name|visibility_protected
operator|&&
name|flags
operator|&
name|LOOKUP_PROTECTED_OK
condition|)
name|visibility
operator|=
name|visibility_public
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|LOOKUP_PROTECT
operator|)
operator|==
literal|0
operator|||
name|visibility
operator|==
name|visibility_public
condition|)
goto|goto
name|found_and_ok
goto|;
elseif|else
if|if
condition|(
name|visibility
operator|==
name|visibility_private
condition|)
name|saw_private
operator|=
name|function
expr_stmt|;
elseif|else
if|if
condition|(
name|visibility
operator|==
name|visibility_protected
condition|)
name|saw_protected
operator|=
name|function
expr_stmt|;
comment|/* If we fail on the exact match, we have 		     an immediate failure.  */
goto|goto
name|found
goto|;
block|}
if|if
condition|(
name|pass
operator|>
literal|0
condition|)
block|{
name|tree
name|these_parms
init|=
name|parms
decl_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_inner_fields_searched
operator|++
expr_stmt|;
endif|#
directive|endif
name|cp
operator|->
name|harshness
operator|=
operator|(
name|unsigned
name|short
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|len
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|function
argument_list|)
condition|)
name|these_parms
operator|=
name|TREE_CHAIN
argument_list|(
name|these_parms
argument_list|)
expr_stmt|;
name|compute_conversion_costs
argument_list|(
name|function
argument_list|,
name|these_parms
argument_list|,
name|cp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|cp
operator|->
name|b_or_d
operator|+=
name|b_or_d
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|evil
operator|==
literal|0
condition|)
block|{
name|cp
operator|->
name|u
operator|.
name|field
operator|=
name|function
expr_stmt|;
name|cp
operator|->
name|function
operator|=
name|function
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|LOOKUP_PROTECT
condition|)
block|{
name|enum
name|visibility_type
name|this_v
decl_stmt|;
name|this_v
operator|=
name|compute_visibility
argument_list|(
name|basetypes
argument_list|,
name|function
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_v
operator|==
name|visibility_protected
operator|&&
operator|(
name|flags
operator|&
name|LOOKUP_PROTECTED_OK
operator|)
condition|)
name|this_v
operator|=
name|visibility_public
expr_stmt|;
if|if
condition|(
name|this_v
operator|!=
name|visibility_public
condition|)
block|{
if|if
condition|(
name|this_v
operator|==
name|visibility_private
condition|)
name|saw_private
operator|=
name|function
expr_stmt|;
else|else
name|saw_protected
operator|=
name|function
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* No "two-level" conversions.  */
if|if
condition|(
name|flags
operator|&
name|LOOKUP_NO_CONVERSION
operator|&&
name|cp
operator|->
name|user
operator|!=
literal|0
condition|)
continue|continue;
comment|/* If we used default parameters, we must 			 check to see whether anyone else might 			 use them also, and report a possible 			 ambiguity.  */
if|if
condition|(
operator|!
name|TYPE_USES_MULTIPLE_INHERITANCE
argument_list|(
name|save_basetype
argument_list|)
operator|&&
name|cp
operator|->
name|harshness
index|[
name|len
index|]
operator|==
literal|0
operator|&&
name|CONST_HARSHNESS
argument_list|(
name|cp
operator|->
name|harshness
index|[
literal|0
index|]
argument_list|)
operator|==
literal|0
operator|&&
name|cp
operator|->
name|user
operator|==
literal|0
operator|&&
name|cp
operator|->
name|b_or_d
operator|==
literal|0
operator|&&
name|cp
operator|->
name|easy
operator|<
name|best
condition|)
block|{
if|if
condition|(
operator|!
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|function
argument_list|)
condition|)
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
operator|=
name|cp
operator|->
name|arg
expr_stmt|;
if|if
condition|(
name|best
operator|==
literal|1
condition|)
goto|goto
name|found_and_maybe_warn
goto|;
block|}
name|cp
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/* Now we have run through one link's member functions. 	     arrange to head-insert this link's links.  */
name|baselink
operator|=
name|next_baselink
argument_list|(
name|baselink
argument_list|)
expr_stmt|;
name|b_or_d
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|pass
operator|==
literal|0
condition|)
block|{
comment|/* No exact match could be found.  Now try to find match 	     using default conversions.  */
if|if
condition|(
operator|(
name|flags
operator|&
name|LOOKUP_GLOBAL
operator|)
operator|&&
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
condition|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|ever_seen
operator|+=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|ever_seen
operator|+=
name|list_length
argument_list|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ever_seen
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|LOOKUP_SPECULATIVELY
operator||
name|LOOKUP_COMPLAIN
operator|)
operator|)
operator|==
name|LOOKUP_SPECULATIVELY
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|flags
operator|&
name|LOOKUP_GLOBAL
condition|)
name|error
argument_list|(
literal|"no global or non-hidden member function `%s' defined"
argument_list|,
name|err_name
argument_list|)
expr_stmt|;
else|else
name|error_with_aggr_type
argument_list|(
name|save_basetype
argument_list|,
literal|"no non-hidden member function `%s::%s' defined"
argument_list|,
name|err_name
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
continue|continue;
block|}
if|if
condition|(
name|cp
operator|-
name|candidates
operator|!=
literal|0
condition|)
block|{
comment|/* Rank from worst to best.  Then cp will point to best one. 	     Private fields have their bits flipped.  For unsigned 	     numbers, this should make them look very large. 	     If the best alternate has a (signed) negative value, 	     then all we ever saw were private members.  */
if|if
condition|(
name|cp
operator|-
name|candidates
operator|>
literal|1
condition|)
block|{
name|cp
operator|=
name|ideal_candidate
argument_list|(
name|save_basetype
argument_list|,
name|candidates
argument_list|,
name|cp
operator|-
name|candidates
argument_list|,
name|parms
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
operator|(
expr|struct
name|candidate
operator|*
operator|)
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"ambiguous type conversion requested for %s `%s'"
argument_list|,
name|name_kind
argument_list|,
name|err_name
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|cp
operator|->
name|evil
condition|)
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
name|cp
index|[
operator|-
literal|1
index|]
operator|.
name|evil
operator|==
literal|2
condition|)
block|{
name|error
argument_list|(
literal|"ambiguous type conversion requested for %s `%s'"
argument_list|,
name|name_kind
argument_list|,
name|err_name
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
else|else
name|cp
operator|--
expr_stmt|;
comment|/* The global function was the best, so use it.  */
if|if
condition|(
name|cp
operator|->
name|u
operator|.
name|field
operator|==
literal|0
condition|)
block|{
comment|/* We must convert the instance pointer into a reference type. 		 Global overloaded functions can only either take 		 aggregate objects (which come for free from references) 		 or reference data types anyway.  */
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
operator|=
name|copy_node
argument_list|(
name|instance_ptr
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|=
name|build_reference_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance_ptr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build_function_call
argument_list|(
name|cp
operator|->
name|function
argument_list|,
name|parms
argument_list|)
return|;
block|}
name|function
operator|=
name|cp
operator|->
name|function
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|function
argument_list|)
condition|)
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
operator|=
name|cp
operator|->
name|arg
expr_stmt|;
goto|goto
name|found_and_maybe_warn
goto|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
operator|~
name|LOOKUP_GLOBAL
operator|)
operator|&
operator|(
name|LOOKUP_COMPLAIN
operator||
name|LOOKUP_SPECULATIVELY
operator|)
condition|)
block|{
name|char
modifier|*
name|tag_name
decl_stmt|,
modifier|*
name|buf
decl_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|LOOKUP_SPECULATIVELY
operator||
name|LOOKUP_COMPLAIN
operator|)
operator|)
operator|==
name|LOOKUP_SPECULATIVELY
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|cp
operator|->
name|function
argument_list|)
condition|)
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
expr_stmt|;
if|if
condition|(
name|ever_seen
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
name|saw_protected
operator||
operator|(
name|HOST_WIDE_INT
operator|)
name|saw_private
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|LOOKUP_SPECULATIVELY
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|static_call_context
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|cp
operator|->
name|function
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|error_with_aggr_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance_ptr
argument_list|)
argument_list|)
argument_list|,
literal|"object missing in call to `%s::%s'"
argument_list|,
name|err_name
argument_list|)
expr_stmt|;
else|else
name|report_type_mismatch
argument_list|(
name|cp
argument_list|,
name|parms
argument_list|,
name|name_kind
argument_list|,
name|err_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
name|tree
name|seen
init|=
name|saw_private
decl_stmt|;
if|if
condition|(
name|saw_private
condition|)
block|{
if|if
condition|(
name|saw_protected
condition|)
name|msg
operator|=
literal|"%s `%%s' (and the like) are private or protected"
expr_stmt|;
else|else
name|msg
operator|=
literal|"the %s `%%s' is private"
expr_stmt|;
block|}
else|else
block|{
name|msg
operator|=
literal|"the %s `%%s' is protected"
expr_stmt|;
name|seen
operator|=
name|saw_protected
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
name|msg
argument_list|,
name|name_kind
argument_list|)
expr_stmt|;
name|error_with_decl
argument_list|(
name|seen
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"within this context"
argument_list|)
expr_stmt|;
block|}
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|LOOKUP_SPECULATIVELY
operator||
name|LOOKUP_COMPLAIN
operator|)
operator|)
operator|==
name|LOOKUP_COMPLAIN
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|save_basetype
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
name|tag_name
operator|=
literal|"structure"
expr_stmt|;
else|else
name|tag_name
operator|=
literal|"union"
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|30
operator|+
name|strlen
argument_list|(
name|err_name
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"%s has no method named `%s'"
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|buf
argument_list|,
name|tag_name
argument_list|,
name|err_name
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
continue|continue;
name|found_and_maybe_warn
label|:
if|if
condition|(
name|CONST_HARSHNESS
argument_list|(
name|cp
operator|->
name|harshness
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|LOOKUP_COMPLAIN
condition|)
block|{
name|error_with_decl
argument_list|(
name|cp
operator|->
name|function
argument_list|,
literal|"non-const member function `%s'"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"called for const object at this point in file"
argument_list|)
expr_stmt|;
block|}
comment|/* Not good enough for a match.  */
else|else
return|return
name|error_mark_node
return|;
block|}
goto|goto
name|found_and_ok
goto|;
block|}
comment|/* Silently return error_mark_node.  */
return|return
name|error_mark_node
return|;
name|found
label|:
if|if
condition|(
name|visibility
operator|==
name|visibility_private
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|LOOKUP_COMPLAIN
condition|)
block|{
name|error_with_file_and_line
argument_list|(
name|DECL_SOURCE_FILE
argument_list|(
name|function
argument_list|)
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|function
argument_list|)
argument_list|,
name|TREE_PRIVATE
argument_list|(
name|function
argument_list|)
condition|?
literal|"%s `%s' is private"
else|:
literal|"%s `%s' is from private base class"
argument_list|,
name|name_kind
argument_list|,
name|lang_printable_name
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"within this context"
argument_list|)
expr_stmt|;
block|}
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
name|visibility
operator|==
name|visibility_protected
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|LOOKUP_COMPLAIN
condition|)
block|{
name|error_with_file_and_line
argument_list|(
name|DECL_SOURCE_FILE
argument_list|(
name|function
argument_list|)
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|function
argument_list|)
argument_list|,
name|TREE_PROTECTED
argument_list|(
name|function
argument_list|)
condition|?
literal|"%s `%s' is protected"
else|:
literal|"%s `%s' has protected visibility from this point"
argument_list|,
name|name_kind
argument_list|,
name|lang_printable_name
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"within this context"
argument_list|)
expr_stmt|;
block|}
return|return
name|error_mark_node
return|;
block|}
name|my_friendly_abort
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|found_and_ok
label|:
comment|/* From here on down, BASETYPE is the type that INSTANCE_PTR's      type (if it exists) is a pointer to.  */
name|function
operator|=
name|DECL_MAIN_VARIANT
argument_list|(
name|function
argument_list|)
expr_stmt|;
comment|/* Declare external function if necessary. */
name|assemble_external
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|fntype
operator|=
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
name|fntype
operator|=
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
expr_stmt|;
name|basetype
operator|=
name|DECL_CLASS_CONTEXT
argument_list|(
name|function
argument_list|)
expr_stmt|;
comment|/* If we are referencing a virtual function from an object      of effectively static type, then there is no need      to go through the virtual function table.  */
if|if
condition|(
name|need_vtbl
operator|==
name|maybe_needed
condition|)
block|{
name|int
name|fixed_type
init|=
name|resolves_to_fixed_type_p
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|all_virtual
operator|==
literal|1
operator|&&
name|DECL_VINDEX
argument_list|(
name|function
argument_list|)
operator|&&
name|may_be_remote
argument_list|(
name|basetype
argument_list|)
condition|)
name|need_vtbl
operator|=
name|needed
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|function
argument_list|)
condition|)
name|need_vtbl
operator|=
name|fixed_type
condition|?
name|unneeded
else|:
name|needed
expr_stmt|;
else|else
name|need_vtbl
operator|=
name|not_needed
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
operator|==
name|METHOD_TYPE
operator|&&
name|static_call_context
operator|&&
operator|!
name|DECL_CONSTRUCTOR_P
argument_list|(
name|function
argument_list|)
condition|)
block|{
comment|/* Let's be nice to the user for now, and give reasonable 	 default behavior.  */
name|instance_ptr
operator|=
name|current_class_decl
expr_stmt|;
if|if
condition|(
name|instance_ptr
condition|)
block|{
if|if
condition|(
name|basetype
operator|!=
name|current_class_type
condition|)
block|{
name|tree
name|binfo
init|=
name|get_binfo
argument_list|(
name|basetype
argument_list|,
name|current_class_type
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|binfo
operator|==
name|NULL_TREE
condition|)
block|{
name|error_not_base_type
argument_list|(
name|function
argument_list|,
name|current_class_type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
name|basetype
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|TREE_STATIC
argument_list|(
name|function
argument_list|)
condition|)
block|{
name|error_with_aggr_type
argument_list|(
name|basetype
argument_list|,
literal|"cannot call member function `%s::%s' without object"
argument_list|,
name|err_name
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
name|value_type
operator|=
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
condition|?
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
else|:
name|void_type_node
expr_stmt|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|value_type
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|LOOKUP_COMPLAIN
condition|)
name|incomplete_type_error
argument_list|(
literal|0
argument_list|,
name|value_type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* We do not pass FUNCTION into `convert_arguments', because by      now everything should be ok.  If not, then we have a serious error.  */
if|if
condition|(
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|function
argument_list|)
condition|)
name|parms
operator|=
name|convert_arguments
argument_list|(
name|NULL_TREE
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|need_vtbl
operator|==
name|unneeded
condition|)
block|{
name|int
name|sub_flags
init|=
name|DECL_CONSTRUCTOR_P
argument_list|(
name|function
argument_list|)
condition|?
name|flags
else|:
name|LOOKUP_NORMAL
decl_stmt|;
name|basetype
operator|=
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_METHOD_BASETYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
operator|!=
name|TYPE_MAIN_VARIANT
argument_list|(
name|basetype
argument_list|)
operator|&&
name|TYPE_USES_COMPLEX_INHERITANCE
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
name|basetype
operator|=
name|DECL_CLASS_CONTEXT
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|instance_ptr
operator|=
name|convert_pointer_to
argument_list|(
name|basetype
argument_list|,
name|instance_ptr
argument_list|)
expr_stmt|;
name|instance
operator|=
name|build_indirect_ref
argument_list|(
name|instance_ptr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|parms
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|instance_ptr
argument_list|,
name|convert_arguments
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_CHAIN
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|sub_flags
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|LOOKUP_NONVIRTUAL
operator|)
operator|==
literal|0
condition|)
name|basetype
operator|=
name|DECL_CONTEXT
argument_list|(
name|function
argument_list|)
expr_stmt|;
comment|/* First parm could be integer_zerop with casts like 	 ((Object*)0)->Object::IsA()  */
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
argument_list|)
condition|)
block|{
name|instance_ptr
operator|=
name|convert_pointer_to
argument_list|(
name|build_type_variant
argument_list|(
name|basetype
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|instance_ptr
argument_list|)
operator|==
name|COND_EXPR
condition|)
block|{
name|instance_ptr
operator|=
name|save_expr
argument_list|(
name|instance_ptr
argument_list|)
expr_stmt|;
name|instance
operator|=
name|build_indirect_ref
argument_list|(
name|instance_ptr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|instance_ptr
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|instance_ptr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|instance_ptr
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|instance
condition|)
empty_stmt|;
comment|/* The call to `convert_pointer_to' may return error_mark_node.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|instance_ptr
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|instance_ptr
return|;
elseif|else
if|if
condition|(
name|instance
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|instance
argument_list|)
operator|!=
name|INDIRECT_REF
operator|||
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|)
operator|!=
name|instance_ptr
condition|)
name|instance
operator|=
name|build_indirect_ref
argument_list|(
name|instance_ptr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|parms
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|instance_ptr
argument_list|,
name|convert_arguments
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_CHAIN
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* Constructors do not overload method calls.  */
block|else if (TYPE_OVERLOADS_METHOD_CALL_EXPR (basetype)&& name != TYPE_IDENTIFIER (basetype)&& (TREE_CODE (function) != FUNCTION_DECL 	       || strncmp (IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (function)), 			   OPERATOR_METHOD_FORMAT, 			   OPERATOR_METHOD_LENGTH))
if|#
directive|if
literal|0
block|&& (may_be_remote (basetype) 	       || (C_C_D ? TREE_TYPE (instance) != current_class_type : 1))
else|#
directive|else
comment|/* This change by Larry Ketcham.  */
block|&& (may_be_remote (basetype) || instance != C_C_D)
endif|#
directive|endif
block|)     {       tree fn_as_int;        parms = TREE_CHAIN (parms);        if (!all_virtual&& TREE_CODE (function) == FUNCTION_DECL) 	fn_as_int = build_unary_op (ADDR_EXPR, function, 0);       else 	fn_as_int = convert (TREE_TYPE (default_conversion (function)), DECL_VINDEX (function));       if (all_virtual == 1) 	fn_as_int = convert (integer_type_node, fn_as_int);        result = build_opfncall (METHOD_CALL_EXPR, LOOKUP_NORMAL, instance, fn_as_int, parms);        if (result == NULL_TREE) 	{ 	  compiler_error ("could not overload `operator->()(...)'"); 	  return error_mark_node; 	}       else if (result == error_mark_node) 	return error_mark_node;
if|#
directive|if
literal|0
comment|/* Do this if we want the result of operator->() to inherit 	 the type of the function it is subbing for.  */
block|TREE_TYPE (result) = value_type;
endif|#
directive|endif
block|return result;     }
endif|#
directive|endif
if|if
condition|(
name|need_vtbl
operator|==
name|needed
condition|)
block|{
name|function
operator|=
name|build_vfn_ref
argument_list|(
operator|&
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
argument_list|,
name|instance
argument_list|,
name|DECL_VINDEX
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
operator|=
name|build_pointer_type
argument_list|(
name|fntype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|GNU_xref_call
argument_list|(
name|current_function_decl
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|function
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
if|if
condition|(
name|DECL_INLINE
argument_list|(
name|function
argument_list|)
condition|)
name|function
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|fntype
argument_list|)
argument_list|,
name|function
argument_list|)
expr_stmt|;
else|else
block|{
name|assemble_external
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|function
argument_list|)
operator|=
literal|1
expr_stmt|;
name|function
operator|=
name|default_conversion
argument_list|(
name|function
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|function
operator|=
name|default_conversion
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|result
operator|=
name|build_nt
argument_list|(
name|CALL_EXPR
argument_list|,
name|function
argument_list|,
name|parms
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
operator|=
name|value_type
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_RAISES
argument_list|(
name|result
argument_list|)
operator|=
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|fntype
argument_list|)
operator|||
operator|(
name|parms
operator|&&
name|TREE_RAISES
argument_list|(
name|parms
argument_list|)
operator|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Similar to `build_method_call', but for overloaded non-member functions.    The name of this function comes through NAME.  The name depends    on PARMS.     Note that this function must handle simple `C' promotions,    as well as variable numbers of arguments (...), and    default arguments to boot.     If the overloading is successful, we return a tree node which    contains the call to the function.     If overloading produces candidates which are probable, but not definite,    we hold these candidates.  If FINAL_CP is non-zero, then we are free    to assume that final_cp points to enough storage for all candidates that    this function might generate.  The `harshness' array is preallocated for    the first candidate, but not for subsequent ones.     Note that the DECL_RTL of FUNCTION must be made to agree with this    function's new name.  */
end_comment

begin_function
name|tree
name|build_overload_call_real
parameter_list|(
name|fnname
parameter_list|,
name|parms
parameter_list|,
name|complain
parameter_list|,
name|final_cp
parameter_list|,
name|buildxxx
parameter_list|)
name|tree
name|fnname
decl_stmt|,
name|parms
decl_stmt|;
name|int
name|complain
decl_stmt|;
name|struct
name|candidate
modifier|*
name|final_cp
decl_stmt|;
name|int
name|buildxxx
decl_stmt|;
block|{
comment|/* must check for overloading here */
name|tree
name|overload_name
decl_stmt|,
name|functions
decl_stmt|,
name|function
decl_stmt|,
name|parm
decl_stmt|;
name|tree
name|parmtypes
init|=
name|NULL_TREE
decl_stmt|,
name|last
init|=
name|NULL_TREE
decl_stmt|;
specifier|register
name|tree
name|outer
decl_stmt|;
name|int
name|length
decl_stmt|;
name|int
name|parmlength
init|=
name|list_length
argument_list|(
name|parms
argument_list|)
decl_stmt|;
name|struct
name|candidate
modifier|*
name|candidates
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|final_cp
condition|)
block|{
name|final_cp
index|[
literal|0
index|]
operator|.
name|evil
operator|=
literal|0
expr_stmt|;
name|final_cp
index|[
literal|0
index|]
operator|.
name|user
operator|=
literal|0
expr_stmt|;
name|final_cp
index|[
literal|0
index|]
operator|.
name|b_or_d
operator|=
literal|0
expr_stmt|;
name|final_cp
index|[
literal|0
index|]
operator|.
name|easy
operator|=
literal|0
expr_stmt|;
name|final_cp
index|[
literal|0
index|]
operator|.
name|function
operator|=
literal|0
expr_stmt|;
comment|/* end marker.  */
name|final_cp
index|[
literal|1
index|]
operator|.
name|evil
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|parm
operator|=
name|parms
init|;
name|parm
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
control|)
block|{
specifier|register
name|tree
name|t
init|=
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|error_mark_node
condition|)
block|{
if|if
condition|(
name|final_cp
condition|)
name|final_cp
operator|->
name|evil
operator|=
literal|1
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ARRAY_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
block|{
comment|/* Perform the conversion from ARRAY_TYPE to POINTER_TYPE in place. 	     Also convert OFFSET_TYPE entities to their normal selves. 	     This eliminates needless calls to `compute_conversion_costs'.  */
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
operator|=
name|default_conversion
argument_list|(
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|last
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|parmtypes
operator|=
name|chainon
argument_list|(
name|parmtypes
argument_list|,
name|last
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|last
condition|)
name|TREE_CHAIN
argument_list|(
name|last
argument_list|)
operator|=
name|void_list_node
expr_stmt|;
else|else
name|parmtypes
operator|=
name|void_list_node
expr_stmt|;
name|overload_name
operator|=
name|build_decl_overload
argument_list|(
name|fnname
argument_list|,
name|parmtypes
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Now check to see whether or not we can win.      Note that if we are called from `build_method_call',      then we cannot have a mis-match, because we would have      already found such a winning case.  */
if|if
condition|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|overload_name
argument_list|)
condition|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|overload_name
argument_list|)
argument_list|)
operator|!=
name|TREE_LIST
condition|)
return|return
name|build_function_call
argument_list|(
name|DECL_MAIN_VARIANT
argument_list|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|overload_name
argument_list|)
argument_list|)
argument_list|,
name|parms
argument_list|)
return|;
name|functions
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|fnname
argument_list|)
expr_stmt|;
if|if
condition|(
name|functions
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"only member functions apply"
argument_list|)
expr_stmt|;
if|if
condition|(
name|final_cp
condition|)
name|final_cp
operator|->
name|evil
operator|=
literal|1
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|functions
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|functions
operator|=
name|DECL_MAIN_VARIANT
argument_list|(
name|functions
argument_list|)
expr_stmt|;
if|if
condition|(
name|final_cp
condition|)
block|{
comment|/* We are just curious whether this is a viable alternative or not.  */
name|compute_conversion_costs
argument_list|(
name|functions
argument_list|,
name|parms
argument_list|,
name|final_cp
argument_list|,
name|parmlength
argument_list|)
expr_stmt|;
return|return
name|functions
return|;
block|}
else|else
return|return
name|build_function_call
argument_list|(
name|functions
argument_list|,
name|parms
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|functions
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"function `%s' declared overloaded, but no instances of that function declared"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|functions
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|final_cp
condition|)
name|final_cp
operator|->
name|evil
operator|=
literal|1
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|functions
argument_list|)
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
specifier|register
name|tree
name|outer
decl_stmt|;
name|length
operator|=
literal|0
expr_stmt|;
comment|/* The list-of-lists should only occur for class things.  */
name|my_friendly_assert
argument_list|(
name|functions
operator|==
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|fnname
argument_list|)
argument_list|,
literal|168
argument_list|)
expr_stmt|;
for|for
control|(
name|outer
operator|=
name|functions
init|;
name|outer
condition|;
name|outer
operator|=
name|TREE_CHAIN
argument_list|(
name|outer
argument_list|)
control|)
block|{
comment|/* member functions.  */
name|length
operator|+=
name|decl_list_length
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_VALUE
argument_list|(
name|outer
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* friend functions.  */
name|length
operator|+=
name|list_length
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|outer
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|length
operator|=
name|list_length
argument_list|(
name|functions
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|final_cp
condition|)
name|candidates
operator|=
name|final_cp
expr_stmt|;
else|else
name|candidates
operator|=
operator|(
expr|struct
name|candidate
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|length
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|candidate
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|=
name|candidates
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|functions
argument_list|)
argument_list|)
operator|!=
name|TREE_LIST
argument_list|,
literal|169
argument_list|)
expr_stmt|;
comment|/* OUTER is the list of FUNCTION_DECLS, in a TREE_LIST.  */
for|for
control|(
name|outer
operator|=
name|functions
init|;
name|outer
condition|;
name|outer
operator|=
name|TREE_CHAIN
argument_list|(
name|outer
argument_list|)
control|)
block|{
name|int
name|template_cost
init|=
literal|0
decl_stmt|;
name|function
operator|=
name|TREE_VALUE
argument_list|(
name|outer
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|TEMPLATE_DECL
operator|&&
operator|!
name|DECL_TEMPLATE_IS_CLASS
argument_list|(
name|function
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|function
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
operator|)
condition|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|function
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|TEMPLATE_DECL
condition|)
name|code
operator|=
name|TREE_CODE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|CONST_DECL
condition|)
name|error_with_decl
argument_list|(
name|function
argument_list|,
literal|"enumeral value `%s' conflicts with function of same name"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|VAR_DECL
condition|)
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|function
argument_list|)
condition|)
name|error_with_decl
argument_list|(
name|function
argument_list|,
literal|"variable `%s' conflicts with function of same name"
argument_list|)
expr_stmt|;
else|else
name|error_with_decl
argument_list|(
name|function
argument_list|,
literal|"constant field `%s' conflicts with function of same name"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|TYPE_DECL
condition|)
continue|continue;
else|else
name|my_friendly_abort
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"at this point in file"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
name|int
name|ntparms
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|DECL_TEMPLATE_PARMS
argument_list|(
name|function
argument_list|)
argument_list|)
decl_stmt|;
name|tree
modifier|*
name|targs
init|=
operator|(
name|tree
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
operator|*
name|ntparms
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|i
operator|=
name|type_unification
argument_list|(
name|DECL_TEMPLATE_PARMS
argument_list|(
name|function
argument_list|)
argument_list|,
name|targs
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
argument_list|,
name|parms
argument_list|,
operator|&
name|template_cost
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|function
operator|=
name|instantiate_template
argument_list|(
name|function
argument_list|,
name|targs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
comment|/* Unconverted template -- failed match.  */
name|cp
operator|->
name|evil
operator|=
literal|1
operator|,
name|cp
operator|->
name|function
operator|=
name|function
operator|,
name|cp
operator|->
name|u
operator|.
name|bad_arg
operator|=
operator|-
literal|4
expr_stmt|;
else|else
block|{
name|function
operator|=
name|DECL_MAIN_VARIANT
argument_list|(
name|function
argument_list|)
expr_stmt|;
comment|/* Can't use alloca here, since result might be 	     passed to calling function.  */
name|cp
operator|->
name|harshness
operator|=
operator|(
name|unsigned
name|short
operator|*
operator|)
name|oballoc
argument_list|(
operator|(
name|parmlength
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|compute_conversion_costs
argument_list|(
name|function
argument_list|,
name|parms
argument_list|,
name|cp
argument_list|,
name|parmlength
argument_list|)
expr_stmt|;
comment|/* Should really add another field...  */
name|cp
operator|->
name|easy
operator|=
name|cp
operator|->
name|easy
operator|*
literal|128
operator|+
name|template_cost
expr_stmt|;
if|if
condition|(
name|cp
index|[
literal|0
index|]
operator|.
name|evil
operator|==
literal|0
condition|)
block|{
name|cp
index|[
literal|1
index|]
operator|.
name|evil
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|final_cp
operator|&&
name|cp
index|[
literal|0
index|]
operator|.
name|user
operator|==
literal|0
operator|&&
name|cp
index|[
literal|0
index|]
operator|.
name|b_or_d
operator|==
literal|0
operator|&&
name|template_cost
operator|==
literal|0
operator|&&
name|cp
index|[
literal|0
index|]
operator|.
name|easy
operator|<=
literal|1
condition|)
block|{
name|final_cp
index|[
literal|0
index|]
operator|.
name|easy
operator|=
name|cp
index|[
literal|0
index|]
operator|.
name|easy
expr_stmt|;
return|return
name|function
return|;
block|}
name|cp
operator|++
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|cp
operator|-
name|candidates
condition|)
block|{
name|tree
name|rval
init|=
name|error_mark_node
decl_stmt|;
comment|/* Leave marker.  */
name|cp
index|[
literal|0
index|]
operator|.
name|evil
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|cp
operator|-
name|candidates
operator|>
literal|1
condition|)
block|{
name|struct
name|candidate
modifier|*
name|best_cp
init|=
name|ideal_candidate
argument_list|(
name|NULL_TREE
argument_list|,
name|candidates
argument_list|,
name|cp
operator|-
name|candidates
argument_list|,
name|parms
argument_list|,
name|parmlength
argument_list|)
decl_stmt|;
if|if
condition|(
name|best_cp
operator|==
operator|(
expr|struct
name|candidate
operator|*
operator|)
literal|0
condition|)
block|{
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"call of overloaded `%s' is ambiguous"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|fnname
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
else|else
name|rval
operator|=
name|best_cp
operator|->
name|function
expr_stmt|;
block|}
else|else
block|{
name|cp
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|evil
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"type conversion ambiguous"
argument_list|)
expr_stmt|;
block|}
else|else
name|rval
operator|=
name|cp
operator|->
name|function
expr_stmt|;
block|}
if|if
condition|(
name|final_cp
condition|)
return|return
name|rval
return|;
return|return
name|buildxxx
condition|?
name|build_function_call_maybe
argument_list|(
name|rval
argument_list|,
name|parms
argument_list|)
else|:
name|build_function_call
argument_list|(
name|rval
argument_list|,
name|parms
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|complain
condition|)
block|{
name|tree
name|name
decl_stmt|;
name|char
modifier|*
name|err_name
decl_stmt|;
comment|/* Initialize name for error reporting.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|functions
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|name
operator|=
name|TREE_PURPOSE
argument_list|(
name|functions
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|functions
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
comment|/* Since the implicit `operator new' and `operator delete' functions 	 are set up to have IDENTIFIER_GLOBAL_VALUEs that are unary ADDR_EXPRs 	 by default_conversion(), we must compensate for that here by 	 using the name of the ADDR_EXPR's operand.  */
name|name
operator|=
name|DECL_NAME
argument_list|(
name|TREE_OPERAND
argument_list|(
name|functions
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|name
operator|=
name|DECL_NAME
argument_list|(
name|functions
argument_list|)
expr_stmt|;
if|if
condition|(
name|IDENTIFIER_OPNAME_P
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|char
modifier|*
name|opname
init|=
name|operator_name_string
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|err_name
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|opname
argument_list|)
operator|+
literal|12
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|err_name
argument_list|,
literal|"operator %s"
argument_list|,
name|opname
argument_list|)
expr_stmt|;
block|}
else|else
name|err_name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|report_type_mismatch
argument_list|(
name|cp
argument_list|,
name|parms
argument_list|,
literal|"function"
argument_list|,
name|err_name
argument_list|)
expr_stmt|;
block|}
return|return
name|error_mark_node
return|;
block|}
end_function

begin_function
name|tree
name|build_overload_call
parameter_list|(
name|fnname
parameter_list|,
name|parms
parameter_list|,
name|complain
parameter_list|,
name|final_cp
parameter_list|)
name|tree
name|fnname
decl_stmt|,
name|parms
decl_stmt|;
name|int
name|complain
decl_stmt|;
name|struct
name|candidate
modifier|*
name|final_cp
decl_stmt|;
block|{
return|return
name|build_overload_call_real
argument_list|(
name|fnname
argument_list|,
name|parms
argument_list|,
name|complain
argument_list|,
name|final_cp
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|tree
name|build_overload_call_maybe
parameter_list|(
name|fnname
parameter_list|,
name|parms
parameter_list|,
name|complain
parameter_list|,
name|final_cp
parameter_list|)
name|tree
name|fnname
decl_stmt|,
name|parms
decl_stmt|;
name|int
name|complain
decl_stmt|;
name|struct
name|candidate
modifier|*
name|final_cp
decl_stmt|;
block|{
return|return
name|build_overload_call_real
argument_list|(
name|fnname
argument_list|,
name|parms
argument_list|,
name|complain
argument_list|,
name|final_cp
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

end_unit

