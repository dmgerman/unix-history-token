begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Handle parameterized types (templates) for GNU C++.    Copyright (C) 1992, 1993 Free Software Foundation, Inc.    Written by Ken Raeburn (raeburn@cygnus.com) while at Watchmaker Computing.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* Known bugs or deficiencies include:    * templates for class static data don't work (methods only)    * duplicated method templates can crash the compiler    * interface/impl data is taken from file defining the template    * all methods must be provided in header files; can't use a source      file that contains only the method templates and "just win"    * method templates must be seen before the expansion of the      class template is done  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"cp-decl.h"
end_include

begin_include
include|#
directive|include
file|"cp-parse.h"
end_include

begin_decl_stmt
specifier|extern
name|struct
name|obstack
name|permanent_obstack
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|tree
name|grokdeclarator
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|int
name|lineno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|input_filename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pending_inline
modifier|*
name|pending_template_expansions
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|processing_template_decl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|processing_template_defn
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_function_decl
specifier|static
name|int
name|unify
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_pending_template
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|void
name|overload_template_name
argument_list|()
decl_stmt|,
name|pop_template_decls
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We've got a template header coming up; set obstacks up to save the    nodes created permanently.  (There might be cases with nested templates    where we don't have to do this, but they aren't implemented, and it    probably wouldn't be worth the effort.)  */
end_comment

begin_function
name|void
name|begin_template_parm_list
parameter_list|()
block|{
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|push_obstacks
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|&
name|permanent_obstack
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Process information from new template parameter NEXT and append it to the    LIST being built.  The rules for use of a template parameter type name    by later parameters are not well-defined for us just yet.  However, the    only way to avoid having to parse expressions of unknown complexity (and    with tokens of unknown types) is to disallow it completely.	So for now,    that is what is assumed.  */
end_comment

begin_function
name|tree
name|process_template_parm
parameter_list|(
name|list
parameter_list|,
name|next
parameter_list|)
name|tree
name|list
decl_stmt|,
name|next
decl_stmt|;
block|{
name|tree
name|parm
decl_stmt|;
name|int
name|is_type
decl_stmt|;
name|parm
operator|=
name|next
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|TREE_LIST
argument_list|,
literal|259
argument_list|)
expr_stmt|;
name|is_type
operator|=
name|TREE_CODE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
expr_stmt|;
if|if
condition|(
operator|!
name|is_type
condition|)
block|{
name|parm
operator|=
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|TREE_LIST
argument_list|,
literal|260
argument_list|)
expr_stmt|;
name|parm
operator|=
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
expr_stmt|;
comment|/* is a const-param */
name|parm
operator|=
name|grokdeclarator
argument_list|(
name|TREE_VALUE
argument_list|(
name|next
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|next
argument_list|)
argument_list|,
name|NORMAL
argument_list|,
literal|0
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* A template parameter is not modifiable.  */
name|TREE_READONLY
argument_list|(
name|parm
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
name|sorry
argument_list|(
literal|"aggregate template parameter types"
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
operator|=
name|void_type_node
expr_stmt|;
block|}
block|}
return|return
name|chainon
argument_list|(
name|list
argument_list|,
name|parm
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The end of a template parameter list has been reached.  Process the    tree list into a parameter vector, converting each parameter into a more    useful form.	 Type parameters are saved as IDENTIFIER_NODEs, and others    as PARM_DECLs.  */
end_comment

begin_function
name|tree
name|end_template_parm_list
parameter_list|(
name|parms
parameter_list|)
name|tree
name|parms
decl_stmt|;
block|{
name|int
name|nparms
init|=
literal|0
decl_stmt|;
name|tree
name|saved_parmlist
decl_stmt|;
name|tree
name|parm
decl_stmt|;
for|for
control|(
name|parm
operator|=
name|parms
init|;
name|parm
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
control|)
name|nparms
operator|++
expr_stmt|;
name|saved_parmlist
operator|=
name|make_tree_vec
argument_list|(
name|nparms
argument_list|)
expr_stmt|;
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|parm
operator|=
name|parms
operator|,
name|nparms
operator|=
literal|0
init|;
name|parm
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
operator|,
name|nparms
operator|++
control|)
block|{
name|tree
name|p
init|=
name|parm
decl_stmt|,
name|decl
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
name|tree
name|t
decl_stmt|;
name|p
operator|=
name|TREE_PURPOSE
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|IDENTIFIER_NODE
argument_list|,
literal|261
argument_list|)
expr_stmt|;
name|t
operator|=
name|make_node
argument_list|(
name|TEMPLATE_TYPE_PARM
argument_list|)
expr_stmt|;
name|TEMPLATE_TYPE_SET_INFO
argument_list|(
name|t
argument_list|,
name|saved_parmlist
argument_list|,
name|nparms
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_lang_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|p
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
operator|=
name|decl
expr_stmt|;
block|}
else|else
block|{
name|tree
name|tinfo
init|=
name|make_node
argument_list|(
name|TEMPLATE_CONST_PARM
argument_list|)
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_PERMANENT
argument_list|(
name|tinfo
argument_list|)
argument_list|,
literal|262
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TREE_PERMANENT
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|tree
name|old_p
init|=
name|p
decl_stmt|;
name|TREE_PERMANENT
argument_list|(
name|old_p
argument_list|)
operator|=
literal|1
expr_stmt|;
name|p
operator|=
name|copy_node
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|TREE_PERMANENT
argument_list|(
name|old_p
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
name|TEMPLATE_CONST_SET_INFO
argument_list|(
name|tinfo
argument_list|,
name|saved_parmlist
argument_list|,
name|nparms
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|tinfo
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|CONST_DECL
argument_list|,
name|DECL_NAME
argument_list|(
name|p
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|tinfo
expr_stmt|;
block|}
name|TREE_VEC_ELT
argument_list|(
name|saved_parmlist
argument_list|,
name|nparms
argument_list|)
operator|=
name|p
expr_stmt|;
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
name|set_current_level_tags_transparency
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|processing_template_decl
operator|++
expr_stmt|;
return|return
name|saved_parmlist
return|;
block|}
end_function

begin_comment
comment|/* end_template_decl is called after a template declaration is seen.    D1 is template header; D2 is class_head_sans_basetype or a    TEMPLATE_DECL with its DECL_RESULT field set.  */
end_comment

begin_function
name|void
name|end_template_decl
parameter_list|(
name|d1
parameter_list|,
name|d2
parameter_list|,
name|is_class
parameter_list|)
name|tree
name|d1
decl_stmt|,
name|d2
decl_stmt|,
name|is_class
decl_stmt|;
block|{
name|tree
name|decl
decl_stmt|;
name|struct
name|template_info
modifier|*
name|tmpl
decl_stmt|;
name|tmpl
operator|=
operator|(
expr|struct
name|template_info
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|template_info
argument_list|)
argument_list|)
expr_stmt|;
name|tmpl
operator|->
name|text
operator|=
literal|0
expr_stmt|;
name|tmpl
operator|->
name|length
operator|=
literal|0
expr_stmt|;
name|tmpl
operator|->
name|aggr
operator|=
name|is_class
expr_stmt|;
comment|/* cloned from reinit_parse_for_template */
name|tmpl
operator|->
name|filename
operator|=
name|input_filename
expr_stmt|;
name|tmpl
operator|->
name|lineno
operator|=
name|lineno
expr_stmt|;
name|tmpl
operator|->
name|parm_vec
operator|=
name|d1
expr_stmt|;
comment|/* [eichin:19911015.2306EST] */
ifdef|#
directive|ifdef
name|DEBUG_CP_BINDING_LEVELS
name|indent_to
argument_list|(
name|stderr
argument_list|,
name|debug_bindings_indentation
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"end_template_decl"
argument_list|)
expr_stmt|;
name|debug_bindings_indentation
operator|+=
literal|4
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|d2
operator|==
name|NULL_TREE
operator|||
name|d2
operator|==
name|error_mark_node
condition|)
block|{
name|decl
operator|=
literal|0
expr_stmt|;
goto|goto
name|lose
goto|;
block|}
if|if
condition|(
name|is_class
condition|)
block|{
name|decl
operator|=
name|build_lang_decl
argument_list|(
name|TEMPLATE_DECL
argument_list|,
name|d2
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|d2
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
name|decl
operator|=
name|d2
expr_stmt|;
else|else
block|{
comment|/* Class destructor templates and operator templates are 	     slipping past as non-template nodes.  Process them here, since 	     I haven't figured out where to catch them earlier.  I could 	     go do that, but it's a choice between getting that done and 	     staying only N months behind schedule.  Sorry....  */
name|enum
name|tree_code
name|code
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|d2
argument_list|)
operator|==
name|CALL_EXPR
argument_list|,
literal|263
argument_list|)
expr_stmt|;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|d2
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|code
operator|==
name|BIT_NOT_EXPR
operator|||
name|code
operator|==
name|OP_IDENTIFIER
operator|||
name|code
operator|==
name|SCOPE_REF
argument_list|,
literal|264
argument_list|)
expr_stmt|;
name|d2
operator|=
name|grokdeclarator
argument_list|(
name|d2
argument_list|,
name|NULL_TREE
argument_list|,
name|MEMFUNCDEF
argument_list|,
literal|0
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_lang_decl
argument_list|(
name|TEMPLATE_DECL
argument_list|,
name|DECL_NAME
argument_list|(
name|d2
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|d2
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_TEMPLATE_RESULT
argument_list|(
name|decl
argument_list|)
operator|=
name|d2
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|DECL_CONTEXT
argument_list|(
name|d2
argument_list|)
expr_stmt|;
name|DECL_CLASS_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|DECL_CLASS_CONTEXT
argument_list|(
name|d2
argument_list|)
expr_stmt|;
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|=
name|DECL_NAME
argument_list|(
name|d2
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|d2
argument_list|)
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
name|TREE_PUBLIC
argument_list|(
name|d2
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
operator|(
name|DECL_EXTERNAL
argument_list|(
name|d2
argument_list|)
operator|&&
operator|!
operator|(
name|DECL_CLASS_CONTEXT
argument_list|(
name|d2
argument_list|)
operator|&&
operator|!
name|DECL_THIS_EXTERN
argument_list|(
name|d2
argument_list|)
operator|)
operator|)
expr_stmt|;
block|}
comment|/* All routines creating TEMPLATE_DECL nodes should now be using 	 build_lang_decl, which will have set this up already.	*/
name|my_friendly_assert
argument_list|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
argument_list|,
literal|265
argument_list|)
expr_stmt|;
comment|/* @@ Somewhere, permanent allocation isn't being used.  */
if|if
condition|(
operator|!
name|DECL_TEMPLATE_IS_CLASS
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|tree
name|result
init|=
name|DECL_TEMPLATE_RESULT
argument_list|(
name|decl
argument_list|)
decl_stmt|;
comment|/* Will do nothing if allocation was already permanent.  */
name|DECL_ARGUMENTS
argument_list|(
name|result
argument_list|)
operator|=
name|copy_to_permanent
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If this is for a method, there's an extra binding level here.	*/
if|if
condition|(
operator|!
name|DECL_TEMPLATE_IS_CLASS
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_CONTEXT
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
comment|/* @@ Find out where this should be getting set!  */
name|tree
name|r
init|=
name|DECL_TEMPLATE_RESULT
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|DECL_CLASS_CONTEXT
argument_list|(
name|r
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|DECL_CLASS_CONTEXT
argument_list|(
name|r
argument_list|)
operator|=
name|DECL_CONTEXT
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
block|}
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
operator|=
name|tmpl
expr_stmt|;
name|DECL_TEMPLATE_PARMS
argument_list|(
name|decl
argument_list|)
operator|=
name|d1
expr_stmt|;
name|lose
label|:
if|if
condition|(
name|decl
condition|)
block|{
comment|/* If context of decl is non-null (i.e., method template), add it 	 to the appropriate class template, and pop the binding levels.  */
if|if
condition|(
operator|!
name|DECL_TEMPLATE_IS_CLASS
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_CONTEXT
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
name|tree
name|ctx
init|=
name|DECL_CONTEXT
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|tmpl
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|ctx
argument_list|)
operator|==
name|UNINSTANTIATED_P_TYPE
argument_list|,
literal|266
argument_list|)
expr_stmt|;
name|tmpl
operator|=
name|UPT_TEMPLATE
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|DECL_TEMPLATE_MEMBERS
argument_list|(
name|tmpl
argument_list|)
operator|=
name|perm_tree_cons
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
name|decl
argument_list|,
name|DECL_TEMPLATE_MEMBERS
argument_list|(
name|tmpl
argument_list|)
argument_list|)
expr_stmt|;
name|poplevel
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|poplevel
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Otherwise, go back to top level first, and push the template decl 	 again there.  */
else|else
block|{
name|poplevel
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|poplevel
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|&&
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|push_overloaded_decl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
if|#
directive|if
literal|0
comment|/* It happens sometimes, with syntactic or semantic errors.  	 One specific case: 	 template<class A, int X, int Y> class Foo { ... }; 	 template<class A, int X, int y> Foo<X,Y>::method (Foo& x) { ... } 	 Note the missing "A" in the class containing "method".  */
block|my_friendly_assert (global_bindings_p (), 267);
else|#
directive|else
while|while
condition|(
operator|!
name|global_bindings_p
argument_list|()
condition|)
name|poplevel
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pop_obstacks
argument_list|()
expr_stmt|;
name|processing_template_decl
operator|--
expr_stmt|;
operator|(
name|void
operator|)
name|get_pending_sizes
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_CP_BINDING_LEVELS
name|debug_bindings_indentation
operator|-=
literal|4
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Convert all template arguments to their appropriate types, and return    a vector containing the resulting values.  If any error occurs, return    error_mark_node.  */
end_comment

begin_function
specifier|static
name|tree
name|coerce_template_parms
parameter_list|(
name|parms
parameter_list|,
name|arglist
parameter_list|,
name|in_decl
parameter_list|)
name|tree
name|parms
decl_stmt|,
name|arglist
decl_stmt|;
name|tree
name|in_decl
decl_stmt|;
block|{
name|int
name|nparms
decl_stmt|,
name|i
decl_stmt|,
name|lost
init|=
literal|0
decl_stmt|;
name|tree
name|vec
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arglist
argument_list|)
operator|==
name|TREE_VEC
condition|)
name|nparms
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
else|else
name|nparms
operator|=
name|list_length
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
name|nparms
operator|!=
name|TREE_VEC_LENGTH
argument_list|(
name|parms
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"incorrect number of parameters (%d, should be %d)"
argument_list|,
name|nparms
argument_list|,
name|TREE_VEC_LENGTH
argument_list|(
name|parms
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_decl
condition|)
name|error_with_decl
argument_list|(
name|in_decl
argument_list|,
literal|"in template expansion for decl `%s'"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arglist
argument_list|)
operator|==
name|TREE_VEC
condition|)
name|vec
operator|=
name|copy_node
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
else|else
block|{
name|vec
operator|=
name|make_tree_vec
argument_list|(
name|nparms
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nparms
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|arg
init|=
name|arglist
decl_stmt|;
name|arglist
operator|=
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|error_mark_node
condition|)
name|lost
operator|++
expr_stmt|;
else|else
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|vec
argument_list|,
name|i
argument_list|)
operator|=
name|arg
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nparms
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|arg
init|=
name|TREE_VEC_ELT
argument_list|(
name|vec
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|parm
init|=
name|TREE_VEC_ELT
argument_list|(
name|parms
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|val
decl_stmt|;
name|int
name|is_type
decl_stmt|,
name|requires_type
decl_stmt|;
name|is_type
operator|=
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
literal|'t'
expr_stmt|;
name|requires_type
operator|=
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|IDENTIFIER_NODE
expr_stmt|;
if|if
condition|(
name|is_type
operator|!=
name|requires_type
condition|)
block|{
if|if
condition|(
name|in_decl
condition|)
name|error_with_decl
argument_list|(
name|in_decl
argument_list|,
literal|"type/value mismatch in template parameter list for `%s'"
argument_list|)
expr_stmt|;
name|lost
operator|++
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|vec
argument_list|,
name|i
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|is_type
condition|)
name|val
operator|=
name|groktypename
argument_list|(
name|arg
argument_list|)
expr_stmt|;
else|else
name|val
operator|=
name|digest_init
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|arg
argument_list|,
operator|(
name|tree
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|error_mark_node
condition|)
name|lost
operator|++
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|vec
argument_list|,
name|i
argument_list|)
operator|=
name|val
expr_stmt|;
block|}
if|if
condition|(
name|lost
condition|)
return|return
name|error_mark_node
return|;
return|return
name|vec
return|;
block|}
end_function

begin_comment
comment|/* Given class template name and parameter list, produce a user-friendly name    for the instantiation.  Note that this name isn't necessarily valid as    input to the compiler, because ">" characters may be adjacent.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|mangle_class_name_for_template
parameter_list|(
name|name
parameter_list|,
name|parms
parameter_list|,
name|arglist
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|tree
name|parms
decl_stmt|,
name|arglist
decl_stmt|;
block|{
specifier|static
name|struct
name|obstack
name|scratch_obstack
decl_stmt|;
specifier|static
name|char
modifier|*
name|scratch_firstobj
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nparms
decl_stmt|;
name|char
name|ibuf
index|[
literal|100
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|scratch_firstobj
condition|)
block|{
name|gcc_obstack_init
argument_list|(
operator|&
name|scratch_obstack
argument_list|)
expr_stmt|;
name|scratch_firstobj
operator|=
name|obstack_alloc
argument_list|(
operator|&
name|scratch_obstack
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|obstack_free
argument_list|(
operator|&
name|scratch_obstack
argument_list|,
name|scratch_firstobj
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
define|#
directive|define
name|buflen
value|sizeof(buf)
define|#
directive|define
name|check
value|if (bufp>= buf+buflen-1) goto too_long
define|#
directive|define
name|ccat
parameter_list|(
name|c
parameter_list|)
value|*bufp++=(c); check
define|#
directive|define
name|advance
value|bufp+=strlen(bufp); check
define|#
directive|define
name|cat
parameter_list|(
name|s
parameter_list|)
value|strncpy(bufp, s, buf+buflen-bufp-1); advance
else|#
directive|else
define|#
directive|define
name|check
define|#
directive|define
name|ccat
parameter_list|(
name|c
parameter_list|)
value|obstack_1grow (&scratch_obstack, (c));
define|#
directive|define
name|advance
define|#
directive|define
name|cat
parameter_list|(
name|s
parameter_list|)
value|obstack_grow (&scratch_obstack, (s), strlen (s))
endif|#
directive|endif
define|#
directive|define
name|icat
parameter_list|(
name|n
parameter_list|)
value|sprintf(ibuf,"%d",(n)); cat(ibuf)
define|#
directive|define
name|xcat
parameter_list|(
name|n
parameter_list|)
value|sprintf(ibuf,"%ux",n); cat(ibuf)
name|cat
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|ccat
argument_list|(
literal|'<'
argument_list|)
expr_stmt|;
name|nparms
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|parms
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|nparms
operator|==
name|TREE_VEC_LENGTH
argument_list|(
name|arglist
argument_list|)
argument_list|,
literal|268
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nparms
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|parm
init|=
name|TREE_VEC_ELT
argument_list|(
name|parms
argument_list|,
name|i
argument_list|)
decl_stmt|,
name|arg
init|=
name|TREE_VEC_ELT
argument_list|(
name|arglist
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|type
decl_stmt|,
name|id
decl_stmt|;
if|if
condition|(
name|i
condition|)
name|ccat
argument_list|(
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
comment|/* parm is a type */
name|char
modifier|*
name|typename
decl_stmt|;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|arg
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|)
operator|&&
name|TYPE_IDENTIFIER
argument_list|(
name|arg
argument_list|)
operator|&&
name|IDENTIFIER_POINTER
argument_list|(
name|TYPE_IDENTIFIER
argument_list|(
name|arg
argument_list|)
argument_list|)
condition|)
name|typename
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|TYPE_IDENTIFIER
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|typename
operator|=
name|type_as_string
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|cat
argument_list|(
name|typename
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|PARM_DECL
argument_list|,
literal|269
argument_list|)
expr_stmt|;
comment|/* Should do conversions as for "const" initializers.  */
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|id
operator|=
name|DECL_NAME
argument_list|(
name|parm
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
comment|/* New list cell was built because old chain link was in 	     use.  */
name|my_friendly_assert
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|arg
argument_list|)
operator|==
name|NULL_TREE
argument_list|,
literal|270
argument_list|)
expr_stmt|;
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|INTEGER_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
if|if
condition|(
name|TREE_INT_CST_HIGH
argument_list|(
name|arg
argument_list|)
operator|!=
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|arg
argument_list|)
operator|>>
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
name|tree
name|val
init|=
name|arg
decl_stmt|;
if|if
condition|(
name|TREE_INT_CST_HIGH
argument_list|(
name|val
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ccat
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
name|val
operator|=
name|build_int_2
argument_list|(
operator|~
name|TREE_INT_CST_LOW
argument_list|(
name|val
argument_list|)
argument_list|,
operator|-
name|TREE_INT_CST_HIGH
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Would "%x%0*x" or "%x%*0x" get zero-padding on all 		     systems?  */
block|{
specifier|static
name|char
name|format
index|[
literal|10
index|]
decl_stmt|;
comment|/* "%x%09999x\0" */
if|if
condition|(
operator|!
name|format
index|[
literal|0
index|]
condition|)
name|sprintf
argument_list|(
name|format
argument_list|,
literal|"%%x%%0%dx"
argument_list|,
name|HOST_BITS_PER_INT
operator|/
literal|4
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ibuf
argument_list|,
name|format
argument_list|,
name|TREE_INT_CST_HIGH
argument_list|(
name|val
argument_list|)
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
name|cat
argument_list|(
name|ibuf
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|icat
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"invalid integer constant for template parameter"
argument_list|)
expr_stmt|;
name|cat
argument_list|(
literal|"*error*"
argument_list|)
expr_stmt|;
block|}
break|break;
ifndef|#
directive|ifndef
name|REAL_IS_NOT_DOUBLE
case|case
name|REAL_TYPE
case|:
name|sprintf
argument_list|(
name|ibuf
argument_list|,
literal|"%e"
argument_list|,
name|TREE_REAL_CST
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|cat
argument_list|(
name|ibuf
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|POINTER_TYPE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|ADDR_EXPR
condition|)
block|{
name|error
argument_list|(
literal|"invalid pointer constant for template parameter"
argument_list|)
expr_stmt|;
name|cat
argument_list|(
literal|"*error*"
argument_list|)
expr_stmt|;
break|break;
block|}
name|ccat
argument_list|(
literal|'&'
argument_list|)
expr_stmt|;
name|arg
operator|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|cat
argument_list|(
name|fndecl_as_string
argument_list|(
literal|0
argument_list|,
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|my_friendly_assert
argument_list|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
literal|'d'
argument_list|,
literal|271
argument_list|)
expr_stmt|;
name|cat
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|sorry
argument_list|(
literal|"encoding %s as template parm"
argument_list|,
name|tree_code_name
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|type
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|my_friendly_abort
argument_list|(
literal|81
argument_list|)
expr_stmt|;
block|}
block|}
block|{
name|char
modifier|*
name|bufp
init|=
name|obstack_next_free
argument_list|(
operator|&
name|scratch_obstack
argument_list|)
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|bufp
index|[
name|offset
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
name|offset
operator|--
expr_stmt|;
name|obstack_blank_fast
argument_list|(
operator|&
name|scratch_obstack
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
name|ccat
argument_list|(
literal|'>'
argument_list|)
expr_stmt|;
name|ccat
argument_list|(
literal|'\0'
argument_list|)
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
name|obstack_base
argument_list|(
operator|&
name|scratch_obstack
argument_list|)
return|;
name|too_long
label|:
name|fatal
argument_list|(
literal|"out of (preallocated) string space creating template instantiation name"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Given an IDENTIFIER_NODE (type TEMPLATE_DECL) and a chain of    parameters, find the desired type.     D1 is the PTYPENAME terminal, and ARGLIST is the list of arguments.    Since ARGLIST is build on the decl_obstack, we must copy it here    to keep it from being reclaimed when the decl storage is reclaimed.     IN_DECL, if non-NULL, is the template declaration we are trying to    instantiate.  */
end_comment

begin_function
name|tree
name|lookup_template_class
parameter_list|(
name|d1
parameter_list|,
name|arglist
parameter_list|,
name|in_decl
parameter_list|)
name|tree
name|d1
decl_stmt|,
name|arglist
decl_stmt|;
name|tree
name|in_decl
decl_stmt|;
block|{
name|tree
name|template
decl_stmt|,
name|parmlist
decl_stmt|;
name|char
modifier|*
name|mangled_name
decl_stmt|;
name|tree
name|id
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|d1
argument_list|)
operator|==
name|IDENTIFIER_NODE
argument_list|,
literal|272
argument_list|)
expr_stmt|;
name|template
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|d1
argument_list|)
expr_stmt|;
comment|/* XXX */
if|if
condition|(
operator|!
name|template
condition|)
name|template
operator|=
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|d1
argument_list|)
expr_stmt|;
comment|/* With something like `template<class T> class X class X { ... };'      we could end up with D1 having nothing but an IDENTIFIER_LOCAL_VALUE.      We don't want to do that, but we have to deal with the situation, so      let's give them some syntax errors to chew on instead of a crash.  */
if|if
condition|(
operator|!
name|template
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|template
argument_list|)
operator|!=
name|TEMPLATE_DECL
condition|)
block|{
name|error
argument_list|(
literal|"non-template type '%s' used as a template"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|d1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_decl
condition|)
name|error_with_decl
argument_list|(
name|in_decl
argument_list|,
literal|"for template declaration `%s'"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|parmlist
operator|=
name|DECL_TEMPLATE_PARMS
argument_list|(
name|template
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|coerce_template_parms
argument_list|(
name|parmlist
argument_list|,
name|arglist
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|uses_template_parms
argument_list|(
name|arglist
argument_list|)
condition|)
block|{
name|tree
name|t
init|=
name|make_lang_type
argument_list|(
name|UNINSTANTIATED_P_TYPE
argument_list|)
decl_stmt|;
name|tree
name|d
decl_stmt|;
name|id
operator|=
name|make_anon_name
argument_list|()
expr_stmt|;
name|d
operator|=
name|build_lang_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|id
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
operator|=
name|d
expr_stmt|;
name|TYPE_VALUES
argument_list|(
name|t
argument_list|)
operator|=
name|build_tree_list
argument_list|(
name|template
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|pushdecl_top_level
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mangled_name
operator|=
name|mangle_class_name_for_template
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|d1
argument_list|)
argument_list|,
name|parmlist
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|id
operator|=
name|get_identifier
argument_list|(
name|mangled_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|IDENTIFIER_TEMPLATE
argument_list|(
name|id
argument_list|)
condition|)
block|{
name|arglist
operator|=
name|copy_to_permanent
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|IDENTIFIER_TEMPLATE
argument_list|(
name|id
argument_list|)
operator|=
name|perm_tree_cons
argument_list|(
name|template
argument_list|,
name|arglist
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
return|return
name|id
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|push_template_decls
parameter_list|(
name|parmlist
parameter_list|,
name|arglist
parameter_list|,
name|class_level
parameter_list|)
name|tree
name|parmlist
decl_stmt|,
name|arglist
decl_stmt|;
name|int
name|class_level
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|nparms
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_CP_BINDING_LEVELS
name|indent_to
argument_list|(
name|stderr
argument_list|,
name|debug_bindings_indentation
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"push_template_decls"
argument_list|)
expr_stmt|;
name|debug_bindings_indentation
operator|+=
literal|4
expr_stmt|;
endif|#
directive|endif
comment|/* Don't want to push values into global context.  */
if|if
condition|(
operator|!
name|class_level
condition|)
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|nparms
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|parmlist
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nparms
condition|;
name|i
operator|++
control|)
block|{
name|int
name|requires_type
decl_stmt|,
name|is_type
decl_stmt|;
name|tree
name|parm
init|=
name|TREE_VEC_ELT
argument_list|(
name|parmlist
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|arg
init|=
name|TREE_VEC_ELT
argument_list|(
name|arglist
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|decl
init|=
literal|0
decl_stmt|;
name|requires_type
operator|=
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|IDENTIFIER_NODE
expr_stmt|;
name|is_type
operator|=
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
literal|'t'
expr_stmt|;
if|if
condition|(
name|is_type
condition|)
block|{
comment|/* add typename to namespace */
if|if
condition|(
operator|!
name|requires_type
condition|)
block|{
name|error
argument_list|(
literal|"template use error: type provided where value needed"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|decl
operator|=
name|arg
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
literal|'t'
argument_list|,
literal|273
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_lang_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|parm
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* add const decl to namespace */
name|tree
name|val
decl_stmt|;
if|if
condition|(
name|requires_type
condition|)
block|{
name|error
argument_list|(
literal|"template use error: value provided where type needed"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|val
operator|=
name|digest_init
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|arg
argument_list|,
operator|(
name|tree
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|error_mark_node
condition|)
block|{
name|decl
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|DECL_NAME
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|val
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|decl
operator|!=
literal|0
condition|)
block|{
name|layout_decl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|class_level
condition|)
name|pushdecl_class_level
argument_list|(
name|decl
argument_list|)
expr_stmt|;
else|else
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|class_level
condition|)
name|set_current_level_tags_transparency
argument_list|(
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_CP_BINDING_LEVELS
name|debug_bindings_indentation
operator|-=
literal|4
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|pop_template_decls
parameter_list|(
name|parmlist
parameter_list|,
name|arglist
parameter_list|,
name|class_level
parameter_list|)
name|tree
name|parmlist
decl_stmt|,
name|arglist
decl_stmt|;
name|int
name|class_level
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DEBUG_CP_BINDING_LEVELS
name|indent_to
argument_list|(
name|stderr
argument_list|,
name|debug_bindings_indentation
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"pop_template_decls"
argument_list|)
expr_stmt|;
name|debug_bindings_indentation
operator|+=
literal|4
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|class_level
condition|)
name|poplevel
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_CP_BINDING_LEVELS
name|debug_bindings_indentation
operator|-=
literal|4
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Should be defined in cp-parse.h.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|yychar
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|uses_template_parms
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|t
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|INDIRECT_REF
case|:
case|case
name|COMPONENT_REF
case|:
comment|/* We assume that the object must be instantiated in order to build 	 the COMPONENT_REF, so we test only whether the type of the 	 COMPONENT_REF uses template parms.  */
return|return
name|uses_template_parms
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
case|case
name|IDENTIFIER_NODE
case|:
if|if
condition|(
operator|!
name|IDENTIFIER_TEMPLATE
argument_list|(
name|t
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|uses_template_parms
argument_list|(
name|TREE_VALUE
argument_list|(
name|IDENTIFIER_TEMPLATE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* aggregates of tree nodes */
case|case
name|TREE_VEC
case|:
block|{
name|int
name|i
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|t
argument_list|)
decl_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
if|if
condition|(
name|uses_template_parms
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
case|case
name|TREE_LIST
case|:
if|if
condition|(
name|uses_template_parms
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|||
name|uses_template_parms
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
name|uses_template_parms
argument_list|(
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
comment|/* constructed type nodes */
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
return|return
name|uses_template_parms
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
if|if
condition|(
operator|!
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|TYPE_IDENTIFIER
argument_list|(
name|t
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|uses_template_parms
argument_list|(
name|TYPE_IDENTIFIER
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
case|case
name|FUNCTION_TYPE
case|:
if|if
condition|(
name|uses_template_parms
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
name|uses_template_parms
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
case|case
name|ARRAY_TYPE
case|:
if|if
condition|(
name|uses_template_parms
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
name|uses_template_parms
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
case|case
name|OFFSET_TYPE
case|:
if|if
condition|(
name|uses_template_parms
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
name|uses_template_parms
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
case|case
name|METHOD_TYPE
case|:
if|if
condition|(
name|uses_template_parms
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|uses_template_parms
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
name|uses_template_parms
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
comment|/* decl nodes */
case|case
name|TYPE_DECL
case|:
return|return
name|uses_template_parms
argument_list|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
case|case
name|FUNCTION_DECL
case|:
if|if
condition|(
name|uses_template_parms
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* fall through */
case|case
name|VAR_DECL
case|:
case|case
name|PARM_DECL
case|:
comment|/* ??? What about FIELD_DECLs?  */
comment|/* The type of a decl can't use template parms if the name of the 	 variable doesn't, because it's impossible to resolve them.  So 	 ignore the type field for now.	 */
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
operator|&&
name|uses_template_parms
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|uses_template_parms
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"template parms used where they can't be resolved"
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
case|case
name|CALL_EXPR
case|:
return|return
name|uses_template_parms
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
case|case
name|ADDR_EXPR
case|:
return|return
name|uses_template_parms
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
comment|/* template parm nodes */
case|case
name|TEMPLATE_TYPE_PARM
case|:
case|case
name|TEMPLATE_CONST_PARM
case|:
return|return
literal|1
return|;
comment|/* simple type nodes */
case|case
name|INTEGER_TYPE
case|:
if|if
condition|(
name|uses_template_parms
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
name|uses_template_parms
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
case|case
name|REAL_TYPE
case|:
case|case
name|VOID_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
return|return
literal|0
return|;
comment|/* constants */
case|case
name|INTEGER_CST
case|:
case|case
name|REAL_CST
case|:
case|case
name|STRING_CST
case|:
return|return
literal|0
return|;
case|case
name|ERROR_MARK
case|:
comment|/* Non-error_mark_node ERROR_MARKs are bad things.  */
name|my_friendly_assert
argument_list|(
name|t
operator|==
name|error_mark_node
argument_list|,
literal|274
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
return|return
literal|0
return|;
case|case
name|UNINSTANTIATED_P_TYPE
case|:
return|return
literal|1
return|;
default|default:
switch|switch
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
block|{
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'<'
case|:
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|tree_code_length
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|t
argument_list|)
index|]
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
if|if
condition|(
name|uses_template_parms
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
default|default:
break|break;
block|}
name|sorry
argument_list|(
literal|"testing %s for template parms"
argument_list|,
name|tree_code_name
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|t
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|my_friendly_abort
argument_list|(
literal|82
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
return|return
literal|0
return|;
block|}
block|}
end_function

begin_function
name|void
name|instantiate_member_templates
parameter_list|(
name|arg
parameter_list|)
name|tree
name|arg
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
name|tree
name|classname
init|=
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|tree
name|id
init|=
name|classname
decl_stmt|;
name|tree
name|members
init|=
name|DECL_TEMPLATE_MEMBERS
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|IDENTIFIER_TEMPLATE
argument_list|(
name|id
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|t
operator|=
name|members
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|tree
name|parmvec
decl_stmt|,
name|type
decl_stmt|,
name|classparms
decl_stmt|,
name|tdecl
decl_stmt|,
name|t2
decl_stmt|;
name|int
name|nparms
decl_stmt|,
name|xxx
decl_stmt|,
name|i
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
operator|!=
name|NULL_TREE
argument_list|,
literal|275
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|TEMPLATE_DECL
argument_list|,
literal|276
argument_list|)
expr_stmt|;
comment|/* @@ Should verify that class parm list is a list of 	 distinct template parameters, and covers all the template 	 parameters.  */
name|tdecl
operator|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|type
operator|=
name|DECL_CONTEXT
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|tdecl
argument_list|)
argument_list|)
expr_stmt|;
name|classparms
operator|=
name|UPT_PARMS
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|nparms
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|classparms
argument_list|)
expr_stmt|;
name|parmvec
operator|=
name|make_tree_vec
argument_list|(
name|nparms
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nparms
condition|;
name|i
operator|++
control|)
name|TREE_VEC_ELT
argument_list|(
name|parmvec
argument_list|,
name|i
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
switch|switch
condition|(
name|unify
argument_list|(
name|DECL_TEMPLATE_PARMS
argument_list|(
name|tdecl
argument_list|)
argument_list|,
operator|&
name|TREE_VEC_ELT
argument_list|(
name|parmvec
argument_list|,
literal|0
argument_list|)
argument_list|,
name|nparms
argument_list|,
name|type
argument_list|,
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|classname
argument_list|)
argument_list|,
operator|&
name|xxx
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* Success -- well, no inconsistency, at least.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nparms
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TREE_VEC_ELT
argument_list|(
name|parmvec
argument_list|,
name|i
argument_list|)
operator|==
name|NULL_TREE
condition|)
goto|goto
name|failure
goto|;
name|t2
operator|=
name|instantiate_template
argument_list|(
name|tdecl
argument_list|,
operator|&
name|TREE_VEC_ELT
argument_list|(
name|parmvec
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|type
operator|!=
literal|0
argument_list|,
literal|277
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_INTERFACE_UNKNOWN
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|DECL_EXTERNAL
argument_list|(
name|t2
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|t2
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|DECL_EXTERNAL
argument_list|(
name|t2
argument_list|)
operator|=
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|t2
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|1
case|:
comment|/* Failure.  */
name|failure
label|:
name|error
argument_list|(
literal|"type unification error instantiating %s::%s"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|classname
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|tdecl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|error_with_decl
argument_list|(
name|tdecl
argument_list|,
literal|"for template declaration `%s'"
argument_list|)
expr_stmt|;
continue|continue
comment|/* loop of members */
continue|;
default|default:
comment|/* Eek, a bug.  */
name|my_friendly_abort
argument_list|(
literal|83
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|tree
name|instantiate_class_template
parameter_list|(
name|classname
parameter_list|,
name|setup_parse
parameter_list|)
name|tree
name|classname
decl_stmt|;
name|int
name|setup_parse
decl_stmt|;
block|{
name|struct
name|template_info
modifier|*
name|template_info
decl_stmt|;
name|tree
name|template
decl_stmt|,
name|t1
decl_stmt|;
if|if
condition|(
name|classname
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|classname
argument_list|)
operator|==
name|IDENTIFIER_NODE
argument_list|,
literal|278
argument_list|)
expr_stmt|;
name|template
operator|=
name|IDENTIFIER_TEMPLATE
argument_list|(
name|classname
argument_list|)
expr_stmt|;
if|if
condition|(
name|IDENTIFIER_HAS_TYPE_VALUE
argument_list|(
name|classname
argument_list|)
condition|)
block|{
name|tree
name|type
init|=
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|classname
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNINSTANTIATED_P_TYPE
condition|)
return|return
name|type
return|;
if|if
condition|(
name|TYPE_BEING_DEFINED
argument_list|(
name|type
argument_list|)
operator|||
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|||
name|CLASSTYPE_USE_TEMPLATE
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|type
return|;
block|}
if|if
condition|(
name|uses_template_parms
argument_list|(
name|classname
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|TREE_TYPE
argument_list|(
name|classname
argument_list|)
condition|)
block|{
name|tree
name|t
init|=
name|make_lang_type
argument_list|(
name|RECORD_TYPE
argument_list|)
decl_stmt|;
name|tree
name|d
init|=
name|build_lang_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|classname
argument_list|,
name|t
argument_list|)
decl_stmt|;
name|DECL_NAME
argument_list|(
name|d
argument_list|)
operator|=
name|classname
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
operator|=
name|d
expr_stmt|;
name|pushdecl
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
name|t1
operator|=
name|TREE_PURPOSE
argument_list|(
name|template
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|TEMPLATE_DECL
argument_list|,
literal|279
argument_list|)
expr_stmt|;
comment|/* If a template is declared but not defined, accept it; don't crash.      Later uses requiring the definition will be flagged as errors by      other code.  Thanks to niklas@appli.se for this bug fix.  */
if|if
condition|(
name|DECL_TEMPLATE_INFO
argument_list|(
name|t1
argument_list|)
operator|->
name|text
operator|==
literal|0
condition|)
name|setup_parse
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_CP_BINDING_LEVELS
name|indent_to
argument_list|(
name|stderr
argument_list|,
name|debug_bindings_indentation
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"instantiate_class_template"
argument_list|)
expr_stmt|;
name|debug_bindings_indentation
operator|+=
literal|4
expr_stmt|;
endif|#
directive|endif
name|push_to_top_level
argument_list|()
expr_stmt|;
name|push_template_decls
argument_list|(
name|DECL_TEMPLATE_PARMS
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|template
argument_list|)
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|template
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_current_level_tags_transparency
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|template_info
operator|=
name|DECL_TEMPLATE_INFO
argument_list|(
name|t1
argument_list|)
expr_stmt|;
if|if
condition|(
name|setup_parse
condition|)
block|{
name|feed_input
argument_list|(
name|template_info
operator|->
name|text
argument_list|,
name|template_info
operator|->
name|length
argument_list|,
operator|(
expr|struct
name|obstack
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|lineno
operator|=
name|template_info
operator|->
name|lineno
expr_stmt|;
name|input_filename
operator|=
name|template_info
operator|->
name|filename
expr_stmt|;
comment|/* Get interface/implementation back in sync.  */
name|extract_interface_info
argument_list|()
expr_stmt|;
name|overload_template_name
argument_list|(
name|classname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|yychar
operator|=
name|PRE_PARSED_CLASS_DECL
expr_stmt|;
name|yylval
operator|.
name|ttype
operator|=
name|build_tree_list
argument_list|(
name|class_type_node
argument_list|,
name|classname
argument_list|)
expr_stmt|;
name|processing_template_defn
operator|++
expr_stmt|;
block|}
else|else
block|{
name|tree
name|t
decl_stmt|,
name|decl
decl_stmt|,
name|id
decl_stmt|,
name|tmpl
decl_stmt|;
name|id
operator|=
name|classname
expr_stmt|;
name|tmpl
operator|=
name|TREE_PURPOSE
argument_list|(
name|IDENTIFIER_TEMPLATE
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|xref_tag
argument_list|(
name|DECL_TEMPLATE_INFO
argument_list|(
name|tmpl
argument_list|)
operator|->
name|aggr
argument_list|,
name|id
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|RECORD_TYPE
argument_list|,
literal|280
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
name|lineno
operator|=
name|template_info
operator|->
name|lineno
expr_stmt|;
name|input_filename
operator|=
name|template_info
operator|->
name|filename
expr_stmt|;
comment|/* Get interface/implementation back in sync.  */
name|extract_interface_info
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* Now, put a copy of the decl in global scope, to avoid        * recursive expansion.  */
name|decl
operator|=
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|decl
condition|)
name|decl
operator|=
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
argument_list|,
literal|281
argument_list|)
expr_stmt|;
comment|/* We'd better make sure we're on the permanent obstack or else 	   * we'll get a "friendly" abort 124 in pushdecl.  Perhaps a 	   * copy_to_permanent would be sufficient here, but then a 	   * sharing problem might occur.  I don't know -- niklas@appli.se */
name|push_obstacks
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|&
name|permanent_obstack
argument_list|)
expr_stmt|;
name|pushdecl_top_level
argument_list|(
name|copy_node
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
name|pop_from_top_level
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG_CP_BINDING_LEVELS
name|debug_bindings_indentation
operator|-=
literal|4
expr_stmt|;
endif|#
directive|endif
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|list_eq
parameter_list|(
name|t1
parameter_list|,
name|t2
parameter_list|)
name|tree
name|t1
decl_stmt|,
name|t2
decl_stmt|;
block|{
if|if
condition|(
name|t1
operator|==
name|NULL_TREE
condition|)
return|return
name|t2
operator|==
name|NULL_TREE
return|;
if|if
condition|(
name|t2
operator|==
name|NULL_TREE
condition|)
return|return
literal|0
return|;
comment|/* Don't care if one declares its arg const and the other doesn't -- the      main variant of the arg type is all that matters.  */
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_VALUE
argument_list|(
name|t1
argument_list|)
argument_list|)
operator|!=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_VALUE
argument_list|(
name|t2
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|list_eq
argument_list|(
name|TREE_CHAIN
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|t2
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|tsubst
parameter_list|(
name|t
parameter_list|,
name|args
parameter_list|,
name|nargs
parameter_list|,
name|in_decl
parameter_list|)
name|tree
name|t
decl_stmt|,
decl|*
name|args
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|nargs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|in_decl
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL_TREE
operator|||
name|t
operator|==
name|error_mark_node
condition|)
return|return
name|t
return|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
comment|/* Minor optimization. 	 ?? Are these really the most frequent cases?  Is the savings 	 significant?  */
operator|&&
name|type
operator|!=
name|integer_type_node
operator|&&
name|type
operator|!=
name|void_type_node
operator|&&
name|type
operator|!=
name|char_type_node
condition|)
name|type
operator|=
name|build_type_variant
argument_list|(
name|tsubst
argument_list|(
name|type
argument_list|,
name|args
argument_list|,
name|nargs
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|TYPE_READONLY
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_VOLATILE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|ERROR_MARK
case|:
case|case
name|IDENTIFIER_NODE
case|:
case|case
name|OP_IDENTIFIER
case|:
case|case
name|VOID_TYPE
case|:
case|case
name|REAL_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|INTEGER_CST
case|:
case|case
name|REAL_CST
case|:
case|case
name|STRING_CST
case|:
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
return|return
name|t
return|;
case|case
name|INTEGER_TYPE
case|:
if|if
condition|(
name|t
operator|==
name|integer_type_node
condition|)
return|return
name|t
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
return|return
name|t
return|;
return|return
name|build_index_2_type
argument_list|(
name|tsubst
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|nargs
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|tsubst
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|nargs
argument_list|,
name|in_decl
argument_list|)
argument_list|)
return|;
case|case
name|TEMPLATE_TYPE_PARM
case|:
return|return
name|build_type_variant
argument_list|(
name|args
index|[
name|TEMPLATE_TYPE_IDX
argument_list|(
name|t
argument_list|)
index|]
argument_list|,
name|TYPE_READONLY
argument_list|(
name|t
argument_list|)
argument_list|,
name|TYPE_VOLATILE
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
case|case
name|TEMPLATE_CONST_PARM
case|:
return|return
name|args
index|[
name|TEMPLATE_CONST_IDX
argument_list|(
name|t
argument_list|)
index|]
return|;
case|case
name|FUNCTION_DECL
case|:
block|{
name|tree
name|r
decl_stmt|;
name|tree
name|fnargs
decl_stmt|,
name|result
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|&&
operator|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
operator|!=
literal|'t'
operator|)
condition|)
return|return
name|t
return|;
name|fnargs
operator|=
name|tsubst
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|nargs
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|result
operator|=
name|tsubst
argument_list|(
name|DECL_RESULT
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|nargs
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'t'
condition|)
block|{
comment|/* Look it up in that class, and return the decl node there, 	       instead of creating a new one.  */
name|tree
name|ctx
decl_stmt|,
name|methods
decl_stmt|,
name|name
decl_stmt|,
name|method
decl_stmt|;
name|int
name|n_methods
decl_stmt|;
name|int
name|i
decl_stmt|,
name|found
init|=
literal|0
decl_stmt|;
name|name
operator|=
name|DECL_NAME
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|ctx
operator|=
name|tsubst
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|nargs
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|methods
operator|=
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|methods
operator|==
name|NULL_TREE
condition|)
comment|/* No methods at all -- no way this one can match.  */
goto|goto
name|no_match
goto|;
name|n_methods
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|methods
argument_list|)
expr_stmt|;
name|r
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|OPERATOR_TYPENAME_FORMAT
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|OPERATOR_TYPENAME_FORMAT
argument_list|)
operator|-
literal|1
argument_list|)
condition|)
block|{
comment|/* Type-conversion operator.  Reconstruct the name, in 		   case it's the name of one of the template's parameters.  */
name|name
operator|=
name|build_typename_overload
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'t'
operator|&&
name|constructor_name
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|DECL_NAME
argument_list|(
name|t
argument_list|)
condition|)
name|name
operator|=
name|constructor_name
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|fprintf (stderr, "\nfor function %s in class %s:\n", 		     IDENTIFIER_POINTER (name), 		     IDENTIFIER_POINTER (TYPE_IDENTIFIER (ctx)));
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_methods
condition|;
name|i
operator|++
control|)
block|{
name|int
name|pass
decl_stmt|;
name|method
operator|=
name|TREE_VEC_ELT
argument_list|(
name|methods
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|method
operator|==
name|NULL_TREE
operator|||
name|DECL_NAME
argument_list|(
name|method
argument_list|)
operator|!=
name|name
condition|)
continue|continue;
name|pass
operator|=
literal|0
expr_stmt|;
name|maybe_error
label|:
for|for
control|(
init|;
name|method
condition|;
name|method
operator|=
name|TREE_CHAIN
argument_list|(
name|method
argument_list|)
control|)
block|{
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|method
argument_list|)
operator|==
name|FUNCTION_DECL
argument_list|,
literal|282
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|method
argument_list|)
operator|!=
name|type
condition|)
block|{
name|tree
name|mtype
init|=
name|TREE_TYPE
argument_list|(
name|method
argument_list|)
decl_stmt|;
name|tree
name|t1
decl_stmt|,
name|t2
decl_stmt|;
comment|/* Keep looking for a method that matches 			   perfectly.  This takes care of the problem 			   where destructors (which have implicit int args) 			   look like constructors which have an int arg.  */
if|if
condition|(
name|pass
operator|==
literal|0
condition|)
continue|continue;
name|t1
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|mtype
argument_list|)
expr_stmt|;
name|t2
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|mtype
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|t2
operator|=
name|TREE_CHAIN
argument_list|(
name|t2
argument_list|)
expr_stmt|;
if|if
condition|(
name|list_eq
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|mtype
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|tree
name|newtype
decl_stmt|;
name|newtype
operator|=
name|build_function_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|newtype
operator|=
name|build_type_variant
argument_list|(
name|newtype
argument_list|,
name|TYPE_READONLY
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_VOLATILE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|newtype
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
operator|!=
name|TREE_TYPE
argument_list|(
name|mtype
argument_list|)
condition|)
goto|goto
name|maybe_bad_return_type
goto|;
block|}
elseif|else
if|if
condition|(
name|TYPE_METHOD_BASETYPE
argument_list|(
name|mtype
argument_list|)
operator|==
name|TYPE_METHOD_BASETYPE
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* Types didn't match, but arg types and 				   `this' do match, so the return type is 				   all that should be messing it up.  */
name|maybe_bad_return_type
label|:
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
operator|!=
name|TREE_TYPE
argument_list|(
name|mtype
argument_list|)
condition|)
name|error
argument_list|(
literal|"inconsistent return types for method `%s' in class `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TYPE_IDENTIFIER
argument_list|(
name|ctx
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|r
operator|=
name|method
expr_stmt|;
break|break;
block|}
name|found
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|#
directive|if
literal|0
block|fprintf (stderr, "\tfound %s\n\n", 			     IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (method)));
endif|#
directive|endif
if|if
condition|(
name|DECL_ARGUMENTS
argument_list|(
name|method
argument_list|)
operator|&&
operator|!
name|TREE_PERMANENT
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|method
argument_list|)
argument_list|)
condition|)
comment|/* @@ Is this early enough?  Might we want to do 			 this instead while processing the expansion?	 */
name|DECL_ARGUMENTS
argument_list|(
name|method
argument_list|)
operator|=
name|tsubst
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|nargs
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|r
operator|=
name|method
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|r
operator|==
name|NULL_TREE
operator|&&
name|pass
operator|==
literal|0
condition|)
block|{
name|pass
operator|=
literal|1
expr_stmt|;
name|method
operator|=
name|TREE_VEC_ELT
argument_list|(
name|methods
argument_list|,
name|i
argument_list|)
expr_stmt|;
goto|goto
name|maybe_error
goto|;
block|}
block|}
if|if
condition|(
name|r
operator|==
name|NULL_TREE
condition|)
block|{
name|no_match
label|:
name|error
argument_list|(
name|found
condition|?
literal|"template for method `%s' doesn't match any in class `%s'"
else|:
literal|"method `%s' not found in class `%s'"
argument_list|,
name|IDENTIFIER_OPNAME_P
argument_list|(
name|name
argument_list|)
condition|?
name|operator_name_string
argument_list|(
name|name
argument_list|)
else|:
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TYPE_IDENTIFIER
argument_list|(
name|ctx
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_decl
condition|)
name|error_with_decl
argument_list|(
name|in_decl
argument_list|,
literal|"in attempt to instantiate `%s' declared at this point in file"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
else|else
block|{
name|r
operator|=
name|DECL_NAME
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|{
name|tree
name|decls
decl_stmt|,
name|val
decl_stmt|;
name|int
name|got_it
init|=
literal|0
decl_stmt|;
name|decls
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|decls
operator|==
name|NULL_TREE
condition|)
comment|/* no match */
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decls
argument_list|)
operator|==
name|TREE_LIST
condition|)
while|while
condition|(
name|decls
condition|)
block|{
name|val
operator|=
name|TREE_VALUE
argument_list|(
name|decls
argument_list|)
expr_stmt|;
name|decls
operator|=
name|TREE_CHAIN
argument_list|(
name|decls
argument_list|)
expr_stmt|;
name|try_one
label|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
operator|==
name|type
condition|)
block|{
name|got_it
operator|=
literal|1
expr_stmt|;
name|r
operator|=
name|val
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|val
operator|=
name|decls
expr_stmt|;
name|decls
operator|=
name|NULL_TREE
expr_stmt|;
goto|goto
name|try_one
goto|;
block|}
if|if
condition|(
operator|!
name|got_it
condition|)
block|{
name|r
operator|=
name|build_decl_overload
argument_list|(
name|r
argument_list|,
name|TYPE_VALUES
argument_list|(
name|type
argument_list|)
argument_list|,
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
operator|!=
name|NULL_TREE
argument_list|)
expr_stmt|;
name|r
operator|=
name|build_lang_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|r
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|TREE_PUBLIC
argument_list|(
name|r
argument_list|)
operator|=
name|TREE_PUBLIC
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|r
argument_list|)
operator|=
name|DECL_EXTERNAL
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|r
argument_list|)
operator|=
name|TREE_STATIC
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|DECL_INLINE
argument_list|(
name|r
argument_list|)
operator|=
name|DECL_INLINE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|DECL_SOURCE_FILE
argument_list|(
name|r
argument_list|)
operator|=
name|DECL_SOURCE_FILE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|DECL_SOURCE_LINE
argument_list|(
name|r
argument_list|)
operator|=
name|DECL_SOURCE_LINE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|DECL_CLASS_CONTEXT
argument_list|(
name|r
argument_list|)
operator|=
name|tsubst
argument_list|(
name|DECL_CLASS_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|nargs
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|make_decl_rtl
argument_list|(
name|r
argument_list|,
name|NULL_PTR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|DECL_ARGUMENTS
argument_list|(
name|r
argument_list|)
operator|=
name|fnargs
expr_stmt|;
name|DECL_RESULT
argument_list|(
name|r
argument_list|)
operator|=
name|result
expr_stmt|;
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
operator|!=
literal|'t'
condition|)
name|push_overloaded_decl_top_level
argument_list|(
name|r
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
case|case
name|PARM_DECL
case|:
block|{
name|tree
name|r
decl_stmt|;
name|r
operator|=
name|build_decl
argument_list|(
name|PARM_DECL
argument_list|,
name|DECL_NAME
argument_list|(
name|t
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|r
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
condition|)
name|TREE_CHAIN
argument_list|(
name|r
argument_list|)
operator|=
name|tsubst
argument_list|(
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|nargs
argument_list|,
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
case|case
name|TREE_LIST
case|:
block|{
name|tree
name|purpose
decl_stmt|,
name|value
decl_stmt|,
name|chain
decl_stmt|,
name|result
decl_stmt|;
name|int
name|via_public
decl_stmt|,
name|via_virtual
decl_stmt|,
name|via_protected
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|void_list_node
condition|)
return|return
name|t
return|;
name|via_public
operator|=
name|TREE_VIA_PUBLIC
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|via_protected
operator|=
name|TREE_VIA_PROTECTED
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|via_virtual
operator|=
name|TREE_VIA_VIRTUAL
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|purpose
operator|=
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|purpose
condition|)
name|purpose
operator|=
name|tsubst
argument_list|(
name|purpose
argument_list|,
name|args
argument_list|,
name|nargs
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|value
operator|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
condition|)
name|value
operator|=
name|tsubst
argument_list|(
name|value
argument_list|,
name|args
argument_list|,
name|nargs
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|chain
operator|&&
name|chain
operator|!=
name|void_type_node
condition|)
name|chain
operator|=
name|tsubst
argument_list|(
name|chain
argument_list|,
name|args
argument_list|,
name|nargs
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|purpose
operator|==
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
operator|&&
name|value
operator|==
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
operator|&&
name|chain
operator|==
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|t
return|;
name|result
operator|=
name|hash_tree_cons
argument_list|(
name|via_public
argument_list|,
name|via_virtual
argument_list|,
name|via_protected
argument_list|,
name|purpose
argument_list|,
name|value
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|TREE_PARMLIST
argument_list|(
name|result
argument_list|)
operator|=
name|TREE_PARMLIST
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
case|case
name|TREE_VEC
case|:
block|{
name|int
name|len
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|t
argument_list|)
decl_stmt|,
name|need_new
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
name|tree
modifier|*
name|elts
init|=
operator|(
name|tree
operator|*
operator|)
name|alloca
argument_list|(
name|len
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
decl_stmt|;
name|bzero
argument_list|(
name|elts
argument_list|,
name|len
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|elts
index|[
name|i
index|]
operator|=
name|tsubst
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
argument_list|,
name|args
argument_list|,
name|nargs
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|elts
index|[
name|i
index|]
operator|!=
name|TREE_VEC_ELT
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
condition|)
name|need_new
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|need_new
condition|)
return|return
name|t
return|;
name|t
operator|=
name|make_tree_vec
argument_list|(
name|len
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|TREE_VEC_ELT
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
operator|=
name|elts
index|[
name|i
index|]
expr_stmt|;
return|return
name|t
return|;
block|}
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
block|{
name|tree
name|r
decl_stmt|;
name|enum
name|tree_code
name|code
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|t
return|;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|POINTER_TYPE
condition|)
name|r
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
else|else
name|r
operator|=
name|build_reference_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|r
operator|=
name|build_type_variant
argument_list|(
name|r
argument_list|,
name|TYPE_READONLY
argument_list|(
name|t
argument_list|)
argument_list|,
name|TYPE_VOLATILE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Will this ever be needed for TYPE_..._TO values?  */
name|layout_type
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
case|case
name|FUNCTION_TYPE
case|:
case|case
name|METHOD_TYPE
case|:
block|{
name|tree
name|values
init|=
name|TYPE_VALUES
argument_list|(
name|t
argument_list|)
decl_stmt|;
comment|/* same as TYPE_ARG_TYPES */
name|tree
name|context
init|=
name|TYPE_CONTEXT
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|new_value
decl_stmt|;
comment|/* Don't bother recursing if we know it won't change anything.	*/
if|if
condition|(
operator|!
operator|(
name|values
operator|==
name|void_type_node
operator|||
name|values
operator|==
name|integer_type_node
operator|)
condition|)
name|values
operator|=
name|tsubst
argument_list|(
name|values
argument_list|,
name|args
argument_list|,
name|nargs
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
condition|)
name|context
operator|=
name|tsubst
argument_list|(
name|context
argument_list|,
name|args
argument_list|,
name|nargs
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
comment|/* Could also optimize cases where return value and 	   values have common elements (e.g., T min(const&T, const T&).  */
comment|/* If the above parameters haven't changed, just return the type.  */
if|if
condition|(
name|type
operator|==
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|&&
name|values
operator|==
name|TYPE_VALUES
argument_list|(
name|t
argument_list|)
operator|&&
name|context
operator|==
name|TYPE_CONTEXT
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|t
return|;
comment|/* Construct a new type node and return it.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|&&
name|context
operator|==
name|NULL_TREE
condition|)
block|{
name|new_value
operator|=
name|build_function_type
argument_list|(
name|type
argument_list|,
name|values
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|context
operator|==
name|NULL_TREE
condition|)
block|{
name|tree
name|base
init|=
name|tsubst
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|args
argument_list|,
name|nargs
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
name|new_value
operator|=
name|build_cplus_method_type
argument_list|(
name|base
argument_list|,
name|type
argument_list|,
name|TREE_CHAIN
argument_list|(
name|values
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|new_value
operator|=
name|make_node
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|new_value
argument_list|)
operator|=
name|type
expr_stmt|;
name|TYPE_CONTEXT
argument_list|(
name|new_value
argument_list|)
operator|=
name|context
expr_stmt|;
name|TYPE_VALUES
argument_list|(
name|new_value
argument_list|)
operator|=
name|values
expr_stmt|;
name|TYPE_SIZE
argument_list|(
name|new_value
argument_list|)
operator|=
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_ALIGN
argument_list|(
name|new_value
argument_list|)
operator|=
name|TYPE_ALIGN
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_MODE
argument_list|(
name|new_value
argument_list|)
operator|=
name|TYPE_MODE
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_METHOD_BASETYPE
argument_list|(
name|t
argument_list|)
condition|)
name|TYPE_METHOD_BASETYPE
argument_list|(
name|new_value
argument_list|)
operator|=
name|tsubst
argument_list|(
name|TYPE_METHOD_BASETYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|nargs
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
comment|/* Need to generate hash value.  */
name|my_friendly_abort
argument_list|(
literal|84
argument_list|)
expr_stmt|;
block|}
name|new_value
operator|=
name|build_type_variant
argument_list|(
name|new_value
argument_list|,
name|TYPE_READONLY
argument_list|(
name|t
argument_list|)
argument_list|,
name|TYPE_VOLATILE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|new_value
return|;
block|}
case|case
name|ARRAY_TYPE
case|:
block|{
name|tree
name|domain
init|=
name|tsubst
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|nargs
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
name|tree
name|r
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|&&
name|domain
operator|==
name|TYPE_DOMAIN
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|t
return|;
name|r
operator|=
name|build_cplus_array_type
argument_list|(
name|type
argument_list|,
name|domain
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
case|case
name|UNINSTANTIATED_P_TYPE
case|:
block|{
name|int
name|nparms
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|DECL_TEMPLATE_PARMS
argument_list|(
name|UPT_TEMPLATE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|argvec
init|=
name|make_tree_vec
argument_list|(
name|nparms
argument_list|)
decl_stmt|;
name|tree
name|parmvec
init|=
name|UPT_PARMS
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|tree
name|id
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nparms
condition|;
name|i
operator|++
control|)
name|TREE_VEC_ELT
argument_list|(
name|argvec
argument_list|,
name|i
argument_list|)
operator|=
name|tsubst
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|parmvec
argument_list|,
name|i
argument_list|)
argument_list|,
name|args
argument_list|,
name|nargs
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|id
operator|=
name|lookup_template_class
argument_list|(
name|DECL_NAME
argument_list|(
name|UPT_TEMPLATE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
name|argvec
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IDENTIFIER_HAS_TYPE_VALUE
argument_list|(
name|id
argument_list|)
condition|)
block|{
name|instantiate_class_template
argument_list|(
name|id
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* set up pending_classes */
name|add_pending_template
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|TYPE_MAIN_VARIANT
argument_list|(
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|id
argument_list|)
argument_list|)
operator|=
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
return|return
name|build_type_variant
argument_list|(
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|id
argument_list|)
argument_list|,
name|TYPE_READONLY
argument_list|(
name|t
argument_list|)
argument_list|,
name|TYPE_VOLATILE
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
block|}
case|case
name|MINUS_EXPR
case|:
case|case
name|PLUS_EXPR
case|:
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|tsubst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|nargs
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|tsubst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|args
argument_list|,
name|nargs
argument_list|,
name|in_decl
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|NEGATE_EXPR
case|:
case|case
name|NOP_EXPR
case|:
return|return
name|fold
argument_list|(
name|build1
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|tsubst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|nargs
argument_list|,
name|in_decl
argument_list|)
argument_list|)
argument_list|)
return|;
default|default:
name|sorry
argument_list|(
literal|"use of `%s' in function template"
argument_list|,
name|tree_code_name
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|t
argument_list|)
index|]
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
end_block

begin_function
name|tree
name|instantiate_template
parameter_list|(
name|tmpl
parameter_list|,
name|targ_ptr
parameter_list|)
name|tree
name|tmpl
decl_stmt|,
decl|*
name|targ_ptr
decl_stmt|;
end_function

begin_block
block|{
name|tree
name|targs
decl_stmt|,
name|fndecl
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
name|struct
name|pending_inline
modifier|*
name|p
decl_stmt|;
name|struct
name|template_info
modifier|*
name|t
decl_stmt|;
name|struct
name|obstack
modifier|*
name|old_fmp_obstack
decl_stmt|;
specifier|extern
name|struct
name|obstack
modifier|*
name|function_maybepermanent_obstack
decl_stmt|;
name|push_obstacks
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|&
name|permanent_obstack
argument_list|)
expr_stmt|;
name|old_fmp_obstack
operator|=
name|function_maybepermanent_obstack
expr_stmt|;
name|function_maybepermanent_obstack
operator|=
operator|&
name|permanent_obstack
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|tmpl
argument_list|)
operator|==
name|TEMPLATE_DECL
argument_list|,
literal|283
argument_list|)
expr_stmt|;
name|len
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|DECL_TEMPLATE_PARMS
argument_list|(
name|tmpl
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|fndecl
operator|=
name|DECL_TEMPLATE_INSTANTIATIONS
argument_list|(
name|tmpl
argument_list|)
init|;
name|fndecl
condition|;
name|fndecl
operator|=
name|TREE_CHAIN
argument_list|(
name|fndecl
argument_list|)
control|)
block|{
name|tree
modifier|*
name|t1
init|=
operator|&
name|TREE_VEC_ELT
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|fndecl
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
name|len
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|t1
index|[
name|i
index|]
operator|!=
name|targ_ptr
index|[
name|i
index|]
condition|)
goto|goto
name|no_match
goto|;
comment|/* Here, we have a match.  */
name|fndecl
operator|=
name|TREE_VALUE
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|function_maybepermanent_obstack
operator|=
name|old_fmp_obstack
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
return|return
name|fndecl
return|;
name|no_match
label|:
empty_stmt|;
block|}
name|targs
operator|=
name|make_tree_vec
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|i
operator|=
name|len
expr_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
name|TREE_VEC_ELT
argument_list|(
name|targs
argument_list|,
name|i
argument_list|)
operator|=
name|targ_ptr
index|[
name|i
index|]
expr_stmt|;
comment|/* substitute template parameters */
name|fndecl
operator|=
name|tsubst
argument_list|(
name|DECL_RESULT
argument_list|(
name|tmpl
argument_list|)
argument_list|,
name|targ_ptr
argument_list|,
name|TREE_VEC_LENGTH
argument_list|(
name|targs
argument_list|)
argument_list|,
name|tmpl
argument_list|)
expr_stmt|;
comment|/* If it's a static member fn in the template, we need to change it      into a FUNCTION_TYPE and chop off its this pointer.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|DECL_RESULT
argument_list|(
name|tmpl
argument_list|)
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
operator|&&
name|fndecl
operator|!=
name|error_mark_node
operator|&&
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
name|tree
name|olddecl
init|=
name|DECL_RESULT
argument_list|(
name|tmpl
argument_list|)
decl_stmt|;
name|revert_static_member_fn
argument_list|(
operator|&
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|,
operator|&
name|DECL_RESULT
argument_list|(
name|tmpl
argument_list|)
argument_list|,
operator|&
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Chop off the this pointer that grokclassfn so kindly added 	 for us (it didn't know yet if the fn was static or not).  */
name|DECL_ARGUMENTS
argument_list|(
name|olddecl
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|olddecl
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|DECL_TEMPLATE_INFO
argument_list|(
name|tmpl
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|text
condition|)
block|{
name|p
operator|=
operator|(
expr|struct
name|pending_inline
operator|*
operator|)
name|permalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pending_inline
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|parm_vec
operator|=
name|t
operator|->
name|parm_vec
expr_stmt|;
name|p
operator|->
name|bindings
operator|=
name|targs
expr_stmt|;
name|p
operator|->
name|can_free
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|deja_vu
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|lineno
operator|=
name|t
operator|->
name|lineno
expr_stmt|;
name|p
operator|->
name|filename
operator|=
name|t
operator|->
name|filename
expr_stmt|;
name|p
operator|->
name|buf
operator|=
name|t
operator|->
name|text
expr_stmt|;
name|p
operator|->
name|len
operator|=
name|t
operator|->
name|length
expr_stmt|;
name|p
operator|->
name|fndecl
operator|=
name|fndecl
expr_stmt|;
name|p
operator|->
name|interface
operator|=
literal|1
expr_stmt|;
comment|/* unknown */
block|}
else|else
name|p
operator|=
operator|(
expr|struct
name|pending_inline
operator|*
operator|)
literal|0
expr_stmt|;
name|DECL_TEMPLATE_INSTANTIATIONS
argument_list|(
name|tmpl
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|targs
argument_list|,
name|fndecl
argument_list|,
name|DECL_TEMPLATE_INSTANTIATIONS
argument_list|(
name|tmpl
argument_list|)
argument_list|)
expr_stmt|;
name|function_maybepermanent_obstack
operator|=
name|old_fmp_obstack
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
if|if
condition|(
name|fndecl
operator|==
name|error_mark_node
operator|||
name|p
operator|==
operator|(
expr|struct
name|pending_inline
operator|*
operator|)
literal|0
condition|)
block|{
comment|/* do nothing */
block|}
elseif|else
if|if
condition|(
name|DECL_INLINE
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
name|DECL_PENDING_INLINE_INFO
argument_list|(
name|fndecl
argument_list|)
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|pending_inlines
expr_stmt|;
name|pending_inlines
operator|=
name|p
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|next
operator|=
name|pending_template_expansions
expr_stmt|;
name|pending_template_expansions
operator|=
name|p
expr_stmt|;
block|}
return|return
name|fndecl
return|;
block|}
end_block

begin_function
name|void
name|undo_template_name_overload
parameter_list|(
name|id
parameter_list|,
name|classlevel
parameter_list|)
name|tree
name|id
decl_stmt|;
name|int
name|classlevel
decl_stmt|;
block|{
name|tree
name|template
decl_stmt|;
name|template
operator|=
name|IDENTIFIER_TEMPLATE
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|template
condition|)
return|return;
ifdef|#
directive|ifdef
name|DEBUG_CP_BINDING_LEVELS
name|indent_to
argument_list|(
name|stderr
argument_list|,
name|debug_bindings_indentation
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"undo_template_name_overload"
argument_list|)
expr_stmt|;
name|debug_bindings_indentation
operator|+=
literal|4
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/* not yet, should get fixed properly later */
block|poplevel (0, 0, 0);
endif|#
directive|endif
if|if
condition|(
operator|!
name|classlevel
condition|)
name|poplevel
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_CP_BINDING_LEVELS
name|debug_bindings_indentation
operator|-=
literal|4
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|overload_template_name
parameter_list|(
name|id
parameter_list|,
name|classlevel
parameter_list|)
name|tree
name|id
decl_stmt|;
name|int
name|classlevel
decl_stmt|;
block|{
name|tree
name|template
decl_stmt|,
name|t
decl_stmt|,
name|decl
decl_stmt|;
name|struct
name|template_info
modifier|*
name|tinfo
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|==
name|IDENTIFIER_NODE
argument_list|,
literal|284
argument_list|)
expr_stmt|;
name|template
operator|=
name|IDENTIFIER_TEMPLATE
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|template
condition|)
return|return;
ifdef|#
directive|ifdef
name|DEBUG_CP_BINDING_LEVELS
name|indent_to
argument_list|(
name|stderr
argument_list|,
name|debug_bindings_indentation
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"overload_template_name(%d)"
argument_list|,
name|classlevel
argument_list|)
expr_stmt|;
name|debug_bindings_indentation
operator|+=
literal|4
expr_stmt|;
endif|#
directive|endif
name|template
operator|=
name|TREE_PURPOSE
argument_list|(
name|template
argument_list|)
expr_stmt|;
name|tinfo
operator|=
name|DECL_TEMPLATE_INFO
argument_list|(
name|template
argument_list|)
expr_stmt|;
name|template
operator|=
name|DECL_NAME
argument_list|(
name|template
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|template
operator|!=
name|NULL_TREE
argument_list|,
literal|285
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|classlevel
condition|)
block|{
name|pushlevel
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|declare_pseudo_global_level
argument_list|()
expr_stmt|;
block|}
name|t
operator|=
name|xref_tag
argument_list|(
name|tinfo
operator|->
name|aggr
argument_list|,
name|id
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|UNINSTANTIATED_P_TYPE
argument_list|,
literal|286
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|template
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* fix this later */
comment|/* We don't want to call here if the work has already been done.  */
block|t = (classlevel        ? IDENTIFIER_CLASS_VALUE (template)        : IDENTIFIER_LOCAL_VALUE (template));   if (t&& TREE_CODE (t) == TYPE_DECL&& TREE_TYPE (t) == t)     my_friendly_abort (85);
endif|#
directive|endif
if|if
condition|(
name|classlevel
condition|)
name|pushdecl_class_level
argument_list|(
name|decl
argument_list|)
expr_stmt|;
else|else
if|#
directive|if
literal|0
comment|/* not yet, should get fixed properly later */
else|pushdecl (decl);   pushlevel (1);
else|#
directive|else
block|{
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* @@ Is this necessary now?  */
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|template
argument_list|)
operator|=
name|decl
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG_CP_BINDING_LEVELS
name|debug_bindings_indentation
operator|-=
literal|4
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* T1 is PRE_PARSED_CLASS_DECL; T3 is result of XREF_TAG lookup.  */
end_comment

begin_function
name|void
name|end_template_instantiation
parameter_list|(
name|t1
parameter_list|,
name|t3
parameter_list|)
name|tree
name|t1
decl_stmt|,
name|t3
decl_stmt|;
block|{
specifier|extern
name|struct
name|pending_input
modifier|*
name|to_be_restored
decl_stmt|;
name|tree
name|t
decl_stmt|,
name|decl
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_CP_BINDING_LEVELS
name|indent_to
argument_list|(
name|stderr
argument_list|,
name|debug_bindings_indentation
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"end_template_instantiation"
argument_list|)
expr_stmt|;
name|debug_bindings_indentation
operator|+=
literal|4
expr_stmt|;
endif|#
directive|endif
name|processing_template_defn
operator|--
expr_stmt|;
comment|/* Restore the old parser input state.  */
if|if
condition|(
name|yychar
operator|==
name|YYEMPTY
condition|)
name|yychar
operator|=
name|yylex
argument_list|()
expr_stmt|;
if|if
condition|(
name|yychar
operator|!=
name|END_OF_SAVED_INPUT
condition|)
name|error
argument_list|(
literal|"parse error at end of class template"
argument_list|)
expr_stmt|;
else|else
block|{
name|restore_pending_input
argument_list|(
name|to_be_restored
argument_list|)
expr_stmt|;
name|to_be_restored
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Our declarations didn't get stored in the global slot, since      there was a (supposedly tags-transparent) scope in between.  */
name|t
operator|=
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|TREE_VALUE
argument_list|(
name|t1
argument_list|)
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|t
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
literal|'t'
argument_list|,
literal|287
argument_list|)
expr_stmt|;
name|CLASSTYPE_USE_TEMPLATE
argument_list|(
name|t
argument_list|)
operator|=
literal|2
expr_stmt|;
comment|/* Always make methods of template classes static, until we've      got a decent scheme for handling them.  The pragmas as they      are now are inadequate.  */
name|CLASSTYPE_INTERFACE_UNKNOWN
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|decl
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|TREE_VALUE
argument_list|(
name|t1
argument_list|)
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
argument_list|,
literal|288
argument_list|)
expr_stmt|;
name|undo_template_name_overload
argument_list|(
name|TREE_VALUE
argument_list|(
name|t1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t
operator|=
name|IDENTIFIER_TEMPLATE
argument_list|(
name|TREE_VALUE
argument_list|(
name|t1
argument_list|)
argument_list|)
expr_stmt|;
name|pop_template_decls
argument_list|(
name|DECL_TEMPLATE_PARMS
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pop_from_top_level
argument_list|()
expr_stmt|;
comment|/* This will fix up the type-value field.  */
name|pushdecl_top_level
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Restore interface/implementation settings.	 */
name|extract_interface_info
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_CP_BINDING_LEVELS
name|debug_bindings_indentation
operator|-=
literal|4
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Store away the text of an inline template function.	No rtl is    generated for this function until it is actually needed.  */
end_comment

begin_function
name|void
name|reinit_parse_for_template
parameter_list|(
name|yychar
parameter_list|,
name|d1
parameter_list|,
name|d2
parameter_list|)
name|int
name|yychar
decl_stmt|;
name|tree
name|d1
decl_stmt|,
name|d2
decl_stmt|;
block|{
name|struct
name|template_info
modifier|*
name|template_info
decl_stmt|;
if|if
condition|(
name|d2
operator|==
name|NULL_TREE
operator|||
name|d2
operator|==
name|error_mark_node
condition|)
block|{
name|lose
label|:
comment|/* @@ Should use temp obstack, and discard results.  */
name|reinit_parse_for_block
argument_list|(
name|yychar
argument_list|,
operator|&
name|permanent_obstack
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|d2
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|d2
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|d2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d2
condition|)
goto|goto
name|lose
goto|;
name|template_info
operator|=
name|DECL_TEMPLATE_INFO
argument_list|(
name|d2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|template_info
condition|)
block|{
name|template_info
operator|=
operator|(
expr|struct
name|template_info
operator|*
operator|)
name|permalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|template_info
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|template_info
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|template_info
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_TEMPLATE_INFO
argument_list|(
name|d2
argument_list|)
operator|=
name|template_info
expr_stmt|;
block|}
name|template_info
operator|->
name|filename
operator|=
name|input_filename
expr_stmt|;
name|template_info
operator|->
name|lineno
operator|=
name|lineno
expr_stmt|;
name|reinit_parse_for_block
argument_list|(
name|yychar
argument_list|,
operator|&
name|permanent_obstack
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|template_info
operator|->
name|text
operator|=
name|obstack_base
argument_list|(
operator|&
name|permanent_obstack
argument_list|)
expr_stmt|;
name|template_info
operator|->
name|length
operator|=
name|obstack_object_size
argument_list|(
operator|&
name|permanent_obstack
argument_list|)
expr_stmt|;
name|obstack_finish
argument_list|(
operator|&
name|permanent_obstack
argument_list|)
expr_stmt|;
name|template_info
operator|->
name|parm_vec
operator|=
name|d1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Type unification.     We have a function template signature with one or more references to    template parameters, and a parameter list we wish to fit to this    template.  If possible, produce a list of parameters for the template    which will cause it to fit the supplied parameter list.     Return zero for success, 2 for an incomplete match that doesn't resolve    all the types, and 1 for complete failure.  An error message will be    printed only for an incomplete match.     TPARMS[NTPARMS] is an array of template parameter types;    TARGS[NTPARMS] is the array of template parameter values.  PARMS is    the function template's signature (using TEMPLATE_PARM_IDX nodes),    and ARGS is the argument list we're trying to match against it.  */
end_comment

begin_function
name|int
name|type_unification
parameter_list|(
name|tparms
parameter_list|,
name|targs
parameter_list|,
name|parms
parameter_list|,
name|args
parameter_list|,
name|nsubsts
parameter_list|)
name|tree
name|tparms
decl_stmt|,
decl|*
name|targs
decl_stmt|,
name|parms
decl_stmt|,
name|args
decl_stmt|;
end_function

begin_decl_stmt
name|int
modifier|*
name|nsubsts
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|tree
name|parm
decl_stmt|,
name|arg
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|ntparms
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|tparms
argument_list|)
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|tparms
argument_list|)
operator|==
name|TREE_VEC
argument_list|,
literal|289
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|parms
argument_list|)
operator|==
name|TREE_LIST
argument_list|,
literal|290
argument_list|)
expr_stmt|;
comment|/* ARGS could be NULL (via a call from cp-parse.y to      build_x_function_call).  */
if|if
condition|(
name|args
condition|)
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|args
argument_list|)
operator|==
name|TREE_LIST
argument_list|,
literal|291
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|ntparms
operator|>
literal|0
argument_list|,
literal|292
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|targs
argument_list|,
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
operator|*
name|ntparms
argument_list|)
expr_stmt|;
while|while
condition|(
name|parms
operator|&&
name|parms
operator|!=
name|void_list_node
operator|&&
name|args
condition|)
block|{
name|parm
operator|=
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
expr_stmt|;
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
expr_stmt|;
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|args
operator|=
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|error_mark_node
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|arg
operator|==
name|unknown_type_node
condition|)
return|return
literal|1
return|;
if|#
directive|if
literal|0
block|if (TREE_CODE (arg) == VAR_DECL) 	arg = TREE_TYPE (arg);       else if (TREE_CODE_CLASS (TREE_CODE (arg)) == 'e') 	arg = TREE_TYPE (arg);
else|#
directive|else
name|my_friendly_assert
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
operator|!=
name|NULL_TREE
argument_list|,
literal|293
argument_list|)
expr_stmt|;
name|arg
operator|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|ntparms
argument_list|,
name|parm
argument_list|,
name|arg
argument_list|,
name|nsubsts
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
literal|1
case|:
return|return
literal|1
return|;
block|}
block|}
comment|/* Fail if we've reached the end of the parm list, and more args      are present, and the parm list isn't variadic.  */
if|if
condition|(
name|args
operator|&&
name|parms
operator|==
name|void_list_node
condition|)
return|return
literal|1
return|;
comment|/* Fail if parms are left and they don't have default values.	 */
if|if
condition|(
name|parms
operator|&&
name|parms
operator|!=
name|void_list_node
operator|&&
name|TREE_PURPOSE
argument_list|(
name|parms
argument_list|)
operator|==
name|NULL_TREE
condition|)
return|return
literal|1
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntparms
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|targs
index|[
name|i
index|]
condition|)
block|{
name|error
argument_list|(
literal|"incomplete type unification"
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Tail recursion is your friend.  */
end_comment

begin_function
specifier|static
name|int
name|unify
parameter_list|(
name|tparms
parameter_list|,
name|targs
parameter_list|,
name|ntparms
parameter_list|,
name|parm
parameter_list|,
name|arg
parameter_list|,
name|nsubsts
parameter_list|)
name|tree
name|tparms
decl_stmt|,
decl|*
name|targs
decl_stmt|,
name|parm
decl_stmt|,
name|arg
decl_stmt|;
end_function

begin_decl_stmt
name|int
modifier|*
name|nsubsts
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|idx
decl_stmt|;
comment|/* I don't think this will do the right thing with respect to types.      But the only case I've seen it in so far has been array bounds, where      signedness is the only information lost, and I think that will be      okay.  */
while|while
condition|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|NOP_EXPR
condition|)
name|parm
operator|=
name|TREE_OPERAND
argument_list|(
name|parm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|error_mark_node
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|arg
operator|==
name|unknown_type_node
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|arg
operator|==
name|parm
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
condition|)
block|{
case|case
name|TEMPLATE_TYPE_PARM
case|:
operator|(
operator|*
name|nsubsts
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|TEMPLATE_TYPE_TPARMLIST
argument_list|(
name|parm
argument_list|)
operator|!=
name|tparms
condition|)
block|{
name|error
argument_list|(
literal|"mixed template headers?!"
argument_list|)
expr_stmt|;
name|my_friendly_abort
argument_list|(
literal|86
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|idx
operator|=
name|TEMPLATE_TYPE_IDX
argument_list|(
name|parm
argument_list|)
expr_stmt|;
comment|/* Simple cases: Value already set, does match or doesn't.  */
if|if
condition|(
name|targs
index|[
name|idx
index|]
operator|==
name|arg
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|targs
index|[
name|idx
index|]
condition|)
return|return
literal|1
return|;
comment|/* Check for mixed types and values.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|tparms
argument_list|,
name|idx
argument_list|)
argument_list|)
operator|!=
name|IDENTIFIER_NODE
condition|)
return|return
literal|1
return|;
name|targs
index|[
name|idx
index|]
operator|=
name|arg
expr_stmt|;
return|return
literal|0
return|;
case|case
name|TEMPLATE_CONST_PARM
case|:
operator|(
operator|*
name|nsubsts
operator|)
operator|++
expr_stmt|;
name|idx
operator|=
name|TEMPLATE_CONST_IDX
argument_list|(
name|parm
argument_list|)
expr_stmt|;
if|if
condition|(
name|targs
index|[
name|idx
index|]
operator|==
name|arg
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|targs
index|[
name|idx
index|]
condition|)
block|{
name|my_friendly_abort
argument_list|(
literal|87
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/*	else if (typeof arg != tparms[idx]) 	return 1;*/
name|targs
index|[
name|idx
index|]
operator|=
name|copy_to_permanent
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|POINTER_TYPE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
return|return
literal|1
return|;
return|return
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|ntparms
argument_list|,
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|nsubsts
argument_list|)
return|;
case|case
name|REFERENCE_TYPE
case|:
return|return
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|ntparms
argument_list|,
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|arg
argument_list|,
name|nsubsts
argument_list|)
return|;
case|case
name|ARRAY_TYPE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|ARRAY_TYPE
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|ntparms
argument_list|,
name|TYPE_DOMAIN
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TYPE_DOMAIN
argument_list|(
name|arg
argument_list|)
argument_list|,
name|nsubsts
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
return|return
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|ntparms
argument_list|,
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|nsubsts
argument_list|)
return|;
case|case
name|REAL_TYPE
case|:
case|case
name|INTEGER_TYPE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|INTEGER_TYPE
condition|)
block|{
if|if
condition|(
name|TYPE_MIN_VALUE
argument_list|(
name|parm
argument_list|)
operator|&&
name|TYPE_MIN_VALUE
argument_list|(
name|arg
argument_list|)
operator|&&
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|ntparms
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|nsubsts
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TYPE_MAX_VALUE
argument_list|(
name|parm
argument_list|)
operator|&&
name|TYPE_MAX_VALUE
argument_list|(
name|arg
argument_list|)
operator|&&
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|ntparms
argument_list|,
name|TYPE_MAX_VALUE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TYPE_MAX_VALUE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|nsubsts
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
comment|/* As far as unification is concerned, this wins.	 Later checks 	 will invalidate it if necessary.  */
return|return
literal|0
return|;
comment|/* Types INTEGER_CST and MINUS_EXPR can come from array bounds.  */
case|case
name|INTEGER_CST
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
literal|1
return|;
return|return
operator|!
name|tree_int_cst_equal
argument_list|(
name|parm
argument_list|,
name|arg
argument_list|)
return|;
case|case
name|MINUS_EXPR
case|:
block|{
name|tree
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|t1
operator|=
name|TREE_OPERAND
argument_list|(
name|parm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t2
operator|=
name|TREE_OPERAND
argument_list|(
name|parm
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|!=
name|TEMPLATE_CONST_PARM
condition|)
return|return
literal|1
return|;
return|return
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|ntparms
argument_list|,
name|t1
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|arg
argument_list|,
name|t2
argument_list|)
argument_list|)
argument_list|,
name|nsubsts
argument_list|)
return|;
block|}
case|case
name|TREE_VEC
case|:
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|TREE_VEC
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TREE_VEC_LENGTH
argument_list|(
name|parm
argument_list|)
operator|!=
name|TREE_VEC_LENGTH
argument_list|(
name|arg
argument_list|)
condition|)
return|return
literal|1
return|;
for|for
control|(
name|i
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|parm
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|ntparms
argument_list|,
name|TREE_VEC_ELT
argument_list|(
name|parm
argument_list|,
name|i
argument_list|)
argument_list|,
name|TREE_VEC_ELT
argument_list|(
name|arg
argument_list|,
name|i
argument_list|)
argument_list|,
name|nsubsts
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
case|case
name|UNINSTANTIATED_P_TYPE
case|:
block|{
name|tree
name|a
decl_stmt|;
comment|/* Unification of something that is not a template fails. (mrs) */
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|arg
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
name|a
operator|=
name|IDENTIFIER_TEMPLATE
argument_list|(
name|TYPE_IDENTIFIER
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Unification of something that is not a template fails. (mrs) */
if|if
condition|(
name|a
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|UPT_TEMPLATE
argument_list|(
name|parm
argument_list|)
operator|!=
name|TREE_PURPOSE
argument_list|(
name|a
argument_list|)
condition|)
comment|/* different templates */
return|return
literal|1
return|;
return|return
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|ntparms
argument_list|,
name|UPT_PARMS
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|a
argument_list|)
argument_list|,
name|nsubsts
argument_list|)
return|;
block|}
case|case
name|RECORD_TYPE
case|:
comment|/* Unification of something that is not a template fails. (mrs) */
return|return
literal|1
return|;
default|default:
name|sorry
argument_list|(
literal|"use of `%s' in template type unification"
argument_list|,
name|tree_code_name
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
index|]
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
end_block

begin_escape
end_escape

begin_undef
undef|#
directive|undef
name|DEBUG
end_undef

begin_function
name|int
name|do_pending_expansions
parameter_list|()
block|{
name|struct
name|pending_inline
modifier|*
name|i
decl_stmt|,
modifier|*
name|new_list
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|pending_template_expansions
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n\n\t\t IN DO_PENDING_EXPANSIONS\n\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|i
operator|=
name|pending_template_expansions
expr_stmt|;
while|while
condition|(
name|i
condition|)
block|{
name|tree
name|context
decl_stmt|;
name|struct
name|pending_inline
modifier|*
name|next
init|=
name|i
operator|->
name|next
decl_stmt|;
name|tree
name|t
init|=
name|i
operator|->
name|fndecl
decl_stmt|;
name|int
name|decision
init|=
literal|0
decl_stmt|;
define|#
directive|define
name|DECIDE
parameter_list|(
name|N
parameter_list|)
value|if(1){decision=(N); goto decided;}else
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|VAR_DECL
argument_list|,
literal|294
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_ASM_WRITTEN
argument_list|(
name|t
argument_list|)
condition|)
name|DECIDE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* If it's a method, let the class type decide it. 	 @@ What if the method template is in a separate file? 	 Maybe both file contexts should be taken into account?  */
name|context
operator|=
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|context
argument_list|)
argument_list|)
operator|==
literal|'t'
condition|)
block|{
comment|/* If `unknown', we might want a static copy. 	     If `implementation', we want a global one. 	     If `interface', ext ref.  */
if|if
condition|(
operator|!
name|CLASSTYPE_INTERFACE_UNKNOWN
argument_list|(
name|context
argument_list|)
condition|)
name|DECIDE
argument_list|(
operator|!
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|context
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* This doesn't get us stuff needed only by the file initializer.  */
block|DECIDE (TREE_USED (t));
else|#
directive|else
comment|/* This compiles too much stuff, but that's probably better in 	 most cases than never compiling the stuff we need.  */
name|DECIDE
argument_list|(
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* else maybe call extract_interface_info? */
if|if
condition|(
name|TREE_USED
argument_list|(
name|t
argument_list|)
condition|)
comment|/* is this right? */
name|DECIDE
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|decided
label|:
ifdef|#
directive|ifdef
name|DEBUG
name|print_node_brief
argument_list|(
name|stderr
argument_list|,
name|decision
condition|?
literal|"yes: "
else|:
literal|"no: "
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t%s\n"
argument_list|,
operator|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|t
argument_list|)
condition|?
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|decision
operator|==
literal|1
condition|)
block|{
name|i
operator|->
name|next
operator|=
name|pending_inlines
expr_stmt|;
name|pending_inlines
operator|=
name|i
expr_stmt|;
block|}
else|else
block|{
name|i
operator|->
name|next
operator|=
name|new_list
expr_stmt|;
name|new_list
operator|=
name|i
expr_stmt|;
block|}
name|i
operator|=
name|next
expr_stmt|;
block|}
name|pending_template_expansions
operator|=
name|new_list
expr_stmt|;
if|if
condition|(
operator|!
name|pending_inlines
condition|)
return|return
literal|0
return|;
name|do_pending_inlines
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_struct
struct|struct
name|pending_template
block|{
name|struct
name|pending_template
modifier|*
name|next
decl_stmt|;
name|tree
name|id
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|pending_template
modifier|*
name|pending_templates
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|do_pending_templates
parameter_list|()
block|{
name|struct
name|pending_template
modifier|*
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
name|pending_templates
init|;
name|t
condition|;
name|t
operator|=
name|t
operator|->
name|next
control|)
block|{
name|instantiate_class_template
argument_list|(
name|t
operator|->
name|id
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|t
operator|=
name|pending_templates
init|;
name|t
condition|;
name|t
operator|=
name|pending_templates
control|)
block|{
name|pending_templates
operator|=
name|t
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|add_pending_template
parameter_list|(
name|pt
parameter_list|)
name|tree
name|pt
decl_stmt|;
block|{
name|struct
name|pending_template
modifier|*
name|p
decl_stmt|;
name|p
operator|=
operator|(
expr|struct
name|pending_template
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pending_template
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|pending_templates
expr_stmt|;
name|pending_templates
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|id
operator|=
name|pt
expr_stmt|;
block|}
end_function

end_unit

