begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Process declarations and variables for C compiler.    Copyright (C) 1988, 1992, 1993 Free Software Foundation, Inc.    Hacked by Michael Tiemann (tiemann@cygnus.com)  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* Process declarations and symbol lookup for C front end.    Also constructs types; the standard scalar types at initialization,    and structure, union, array and enum types when they are declared.  */
end_comment

begin_comment
comment|/* ??? not all decl nodes are given the most useful possible    line numbers.  For example, the CONST_DECLs for enum values.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"cp-decl.h"
end_include

begin_include
include|#
directive|include
file|"cp-lex.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_decl_stmt
specifier|extern
name|struct
name|obstack
name|permanent_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stack of places to restore the search obstack back to.  */
end_comment

begin_comment
comment|/* Obstack used for remembering local class declarations (like    enums and static (const) members.  */
end_comment

begin_include
include|#
directive|include
file|"stack.h"
end_include

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|decl_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|stack_level
modifier|*
name|decl_stack
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|NULL
end_undef

begin_define
define|#
directive|define
name|NULL
value|(char *)0
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|CHAR_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|CHAR_TYPE_SIZE
value|BITS_PER_UNIT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SHORT_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|SHORT_TYPE_SIZE
value|(BITS_PER_UNIT * MIN ((UNITS_PER_WORD + 1) / 2, 2))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|INT_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|INT_TYPE_SIZE
value|BITS_PER_WORD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LONG_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|LONG_TYPE_SIZE
value|BITS_PER_WORD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LONG_LONG_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|LONG_LONG_TYPE_SIZE
value|(BITS_PER_WORD * 2)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WCHAR_UNSIGNED
end_ifndef

begin_define
define|#
directive|define
name|WCHAR_UNSIGNED
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|FLOAT_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|FLOAT_TYPE_SIZE
value|BITS_PER_WORD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DOUBLE_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|DOUBLE_TYPE_SIZE
value|(BITS_PER_WORD * 2)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LONG_DOUBLE_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|LONG_DOUBLE_TYPE_SIZE
value|(BITS_PER_WORD * 2)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* We let tm.h override the types used here, to handle trivial differences    such as the choice of unsigned int or long unsigned int for size_t.    When machines start needing nontrivial differences in the size type,    it would be best to do something here to figure out automatically    from other information what type to use.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SIZE_TYPE
end_ifndef

begin_define
define|#
directive|define
name|SIZE_TYPE
value|"long unsigned int"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PTRDIFF_TYPE
end_ifndef

begin_define
define|#
directive|define
name|PTRDIFF_TYPE
value|"long int"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WCHAR_TYPE
end_ifndef

begin_define
define|#
directive|define
name|WCHAR_TYPE
value|"int"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|builtin_function
parameter_list|(
name|NAME
parameter_list|,
name|TYPE
parameter_list|,
name|CODE
parameter_list|,
name|LIBNAME
parameter_list|)
define|\
value|define_function (NAME, TYPE, CODE, (void (*)())pushdecl, LIBNAME)
end_define

begin_define
define|#
directive|define
name|auto_function
parameter_list|(
name|NAME
parameter_list|,
name|TYPE
parameter_list|,
name|CODE
parameter_list|)
define|\
value|do {					\     tree __name = NAME;		\     tree __type = TYPE;			\     define_function (IDENTIFIER_POINTER (__name), __type, CODE,	\ 		     (void (*)())push_overloaded_decl_1,	\ 		     IDENTIFIER_POINTER (build_decl_overload (__name, TYPE_ARG_TYPES (__type), 0)));\   } while (0)
end_define

begin_decl_stmt
specifier|static
name|tree
name|grokparms
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|lookup_nested_type
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|redeclaration_error_message
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|parmlist_is_random
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|grok_op_properties
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|expand_static_init
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|deactivate_exception_cleanups
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|define_function
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|tree
operator|,
expr|enum
name|built_in_function
operator|,
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* a node which has tree code ERROR_MARK, and whose type is itself.    All erroneous expressions are replaced with this node.  All functions    that accept nodes as arguments should avoid generating error messages    if this node is one of the arguments, since it is undesirable to get    multiple error messages from one error in the input.  */
end_comment

begin_decl_stmt
name|tree
name|error_mark_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Erroneous argument lists can use this *IFF* they do not modify it.  */
end_comment

begin_decl_stmt
name|tree
name|error_mark_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* INTEGER_TYPE and REAL_TYPE nodes for the standard data types */
end_comment

begin_decl_stmt
name|tree
name|short_integer_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|integer_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|long_integer_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|long_long_integer_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|short_unsigned_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|unsigned_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|long_unsigned_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|long_long_unsigned_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|ptrdiff_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|unsigned_char_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|signed_char_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|char_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|wchar_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|signed_wchar_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|unsigned_wchar_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|float_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|double_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|long_double_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|intQI_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|intHI_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|intSI_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|intDI_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|unsigned_intQI_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|unsigned_intHI_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|unsigned_intSI_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|unsigned_intDI_type_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* a VOID_TYPE node, and the same, packaged in a TREE_LIST.  */
end_comment

begin_decl_stmt
name|tree
name|void_type_node
decl_stmt|,
name|void_list_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|void_zero_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nodes for types `void *' and `const void *'.  */
end_comment

begin_decl_stmt
name|tree
name|ptr_type_node
decl_stmt|,
name|const_ptr_type_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nodes for types `char *' and `const char *'.  */
end_comment

begin_decl_stmt
name|tree
name|string_type_node
decl_stmt|,
name|const_string_type_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Type `char[256]' or something like it.    Used when an array of char is needed and the size is irrelevant.  */
end_comment

begin_decl_stmt
name|tree
name|char_array_type_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Type `int[256]' or something like it.    Used when an array of int needed and the size is irrelevant.  */
end_comment

begin_decl_stmt
name|tree
name|int_array_type_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Type `wchar_t[256]' or something like it.    Used when a wide string literal is created.  */
end_comment

begin_decl_stmt
name|tree
name|wchar_array_type_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* type `int ()' -- used for implicit declaration of functions.  */
end_comment

begin_decl_stmt
name|tree
name|default_function_type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* function types `double (double)' and `double (double, double)', etc.  */
end_comment

begin_decl_stmt
name|tree
name|double_ftype_double
decl_stmt|,
name|double_ftype_double_double
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|int_ftype_int
decl_stmt|,
name|long_ftype_long
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function type `void (void *, void *, int)' and similar ones.  */
end_comment

begin_decl_stmt
name|tree
name|void_ftype_ptr_ptr_int
decl_stmt|,
name|int_ftype_ptr_ptr_int
decl_stmt|,
name|void_ftype_ptr_int_int
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function type `char *(char *, char *)' and similar ones */
end_comment

begin_decl_stmt
name|tree
name|string_ftype_ptr_ptr
decl_stmt|,
name|int_ftype_string_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function type `size_t (const char *)' */
end_comment

begin_decl_stmt
name|tree
name|sizet_ftype_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function type `int (const void *, const void *, size_t)' */
end_comment

begin_decl_stmt
name|tree
name|int_ftype_cptr_cptr_sizet
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* C++ extensions */
end_comment

begin_decl_stmt
name|tree
name|vtable_entry_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|__t_desc_type_node
decl_stmt|,
name|__i_desc_type_node
decl_stmt|,
name|__m_desc_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|__t_desc_array_type
decl_stmt|,
name|__i_desc_array_type
decl_stmt|,
name|__m_desc_array_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|class_star_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|class_type_node
decl_stmt|,
name|record_type_node
decl_stmt|,
name|union_type_node
decl_stmt|,
name|enum_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|exception_type_node
decl_stmt|,
name|unknown_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|maybe_gc_cleanup
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used for virtual function tables.  */
end_comment

begin_decl_stmt
name|tree
name|vtbl_mask
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array type `(void *)[]' */
end_comment

begin_decl_stmt
name|tree
name|vtbl_type_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Static decls which do not have static initializers have no    initializers as far as GNU C is concerned.  EMPTY_INIT_NODE    is a static initializer which makes varasm code place the decl    in data rather than in bss space.  Such gymnastics are necessary    to avoid the problem that the linker will not include a library    file if all the library appears to contribute are bss variables.  */
end_comment

begin_decl_stmt
name|tree
name|empty_init_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* In a destructor, the point at which all derived class destroying    has been done, just before any base class destroying will be done.  */
end_comment

begin_decl_stmt
name|tree
name|dtor_label
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* In a constructor, the point at which we are ready to return    the pointer to the initialized object.  */
end_comment

begin_decl_stmt
name|tree
name|ctor_label
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A FUNCTION_DECL which can call `unhandled_exception'.    Not necessarily the one that the user will declare,    but sufficient to be called by routines that want to abort the program.  */
end_comment

begin_decl_stmt
name|tree
name|unhandled_exception_fndecl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A FUNCTION_DECL which can call `abort'.  Not necessarily the    one that the user will declare, but sufficient to be called    by routines that want to abort the program.  */
end_comment

begin_decl_stmt
name|tree
name|abort_fndecl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|rtx
name|cleanup_label
decl_stmt|,
name|return_label
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If original DECL_RESULT of current function was a register,    but due to being an addressable named return value, would up    on the stack, this variable holds the named return value's    original location.  */
end_comment

begin_decl_stmt
name|rtx
name|original_result_rtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Sequence of insns which represents base initialization.  */
end_comment

begin_decl_stmt
name|rtx
name|base_init_insns
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* C++: Keep these around to reduce calls to `get_identifier'.    Identifiers for `this' in member functions and the auto-delete    parameter for destructors.  */
end_comment

begin_decl_stmt
name|tree
name|this_identifier
decl_stmt|,
name|in_charge_identifier
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A list (chain of TREE_LIST nodes) of named label uses.    The TREE_PURPOSE field is the list of variables defined    the the label's scope defined at the point of use.    The TREE_VALUE field is the LABEL_DECL used.    The TREE_TYPE field holds `current_binding_level' at the    point of the label's use.     Used only for jumps to as-yet undefined labels, since    jumps to defined labels can have their validity checked    by stmt.c.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|named_label_uses
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A list of objects which have constructors or destructors    which reside in the global scope.  The decl is stored in    the TREE_VALUE slot and the initializer is stored    in the TREE_PURPOSE slot.  */
end_comment

begin_decl_stmt
name|tree
name|static_aggregates
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A list of functions which were declared inline, but later had their    address taken.  Used only for non-virtual member functions, since we can    find other functions easily enough.  */
end_comment

begin_decl_stmt
name|tree
name|pending_addressable_inlines
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A list of overloaded functions which we should forget ever    existed, such as functions declared in a function's scope,    once we leave that function's scope.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|overloads_to_forget
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -- end of C++ */
end_comment

begin_comment
comment|/* Two expressions that are constants with value zero.    The first is of type `int', the second of type `void *'.  */
end_comment

begin_decl_stmt
name|tree
name|integer_zero_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|null_pointer_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A node for the integer constants 1, 2, and 3.  */
end_comment

begin_decl_stmt
name|tree
name|integer_one_node
decl_stmt|,
name|integer_two_node
decl_stmt|,
name|integer_three_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we have seen an invalid cross reference    to a struct, union, or enum, but not yet printed the message.  */
end_comment

begin_decl_stmt
name|tree
name|pending_invalid_xref
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* File and line to appear in the eventual error message.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|pending_invalid_xref_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pending_invalid_xref_line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* While defining an enum type, this is 1 plus the last enumerator    constant value.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|enum_next_value
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parsing a function declarator leaves a list of parameter names    or a chain or parameter decls here.  */
end_comment

begin_decl_stmt
name|tree
name|last_function_parms
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parsing a function declarator leaves here a chain of structure    and enum types declared in the parmlist.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|last_function_parm_tags
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* After parsing the declarator that starts a function definition,    `start_function' puts here the list of parameter names or chain of decls.    `store_parm_decls' finds it here.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|current_function_parms
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Similar, for last_function_parm_tags.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|current_function_parm_tags
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A list (chain of TREE_LIST nodes) of all LABEL_DECLs in the function    that have names.  Here so we can clear out their names' definitions    at the end of the function.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|named_labels
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A list of LABEL_DECLs from outer contexts that are currently shadowed.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|shadowed_labels
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Not needed by C++ */
end_comment

begin_comment
comment|/* Nonzero when store_parm_decls is called indicates a varargs function.    Value not meaningful after store_parm_decls.  */
end_comment

begin_endif
unit|static int c_function_varargs;
endif|#
directive|endif
end_endif

begin_comment
comment|/* The FUNCTION_DECL for the function currently being compiled,    or 0 if between functions.  */
end_comment

begin_decl_stmt
name|tree
name|current_function_decl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to 0 at beginning of a function definition, set to 1 if    a return statement that specifies a return value is seen.  */
end_comment

begin_decl_stmt
name|int
name|current_function_returns_value
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to 0 at beginning of a function definition, set to 1 if    a return statement with no argument is seen.  */
end_comment

begin_decl_stmt
name|int
name|current_function_returns_null
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to 0 at beginning of a function definition, and whenever    a label (case or named) is defined.  Set to value of expression    returned from function when that value can be transformed into    a named return value.  */
end_comment

begin_decl_stmt
name|tree
name|current_function_return_value
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn about multiple (redundant) decls for the same single    variable or function.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|warn_redundant_decls
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to nonzero by `grokdeclarator' for a function    whose return type is defaulted, if warnings for this are desired.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|warn_about_return_type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero when starting a function declared `extern inline'.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|current_extern_inline
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means give `double' the same size as `float'.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|flag_short_double
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means don't recognize any builtin functions.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|flag_no_builtin
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means do emit exported implementations of functions even if    they can be inlined.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|flag_implement_inlines
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means handle things in ANSI, instead of GNU fashion.  This    flag should be tested for language behavior that's different between    ANSI and GNU, but not so horrible as to merit a PEDANTIC label.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|flag_ansi
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointers to the base and current top of the language name stack.  */
end_comment

begin_decl_stmt
specifier|extern
name|tree
modifier|*
name|current_lang_base
decl_stmt|,
modifier|*
name|current_lang_stack
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* C and C++ flags are in cp-decl2.c.  */
end_comment

begin_comment
comment|/* Set to 0 at beginning of a constructor, set to 1    if that function does an allocation before referencing its    instance variable.  */
end_comment

begin_decl_stmt
name|int
name|current_function_assigns_this
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|current_function_just_assigned_this
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to 0 at beginning of a function.  Set non-zero when    store_parm_decls is called.  Don't call store_parm_decls    if this flag is non-zero!  */
end_comment

begin_decl_stmt
name|int
name|current_function_parms_stored
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current end of entries in the gc obstack for stack pointer variables.  */
end_comment

begin_decl_stmt
name|int
name|current_function_obstack_index
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag saying whether we have used the obstack in this function or not.  */
end_comment

begin_decl_stmt
name|int
name|current_function_obstack_usage
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag used when debugging cp-spew.c */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|spew_debug
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Allocate a level of searching.  */
end_comment

begin_function
name|struct
name|stack_level
modifier|*
name|push_decl_level
parameter_list|(
name|stack
parameter_list|,
name|obstack
parameter_list|)
name|struct
name|stack_level
modifier|*
name|stack
decl_stmt|;
name|struct
name|obstack
modifier|*
name|obstack
decl_stmt|;
block|{
name|struct
name|stack_level
name|tem
decl_stmt|;
name|tem
operator|.
name|prev
operator|=
name|stack
expr_stmt|;
return|return
name|push_stack_level
argument_list|(
name|obstack
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tem
argument_list|,
sizeof|sizeof
argument_list|(
name|tem
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Discard a level of decl allocation.  */
end_comment

begin_function
specifier|static
name|struct
name|stack_level
modifier|*
name|pop_decl_level
parameter_list|(
name|stack
parameter_list|)
name|struct
name|stack_level
modifier|*
name|stack
decl_stmt|;
block|{
name|tree
modifier|*
name|bp
decl_stmt|,
modifier|*
name|tp
decl_stmt|;
name|struct
name|obstack
modifier|*
name|obstack
init|=
name|stack
operator|->
name|obstack
decl_stmt|;
name|bp
operator|=
name|stack
operator|->
name|first
expr_stmt|;
name|tp
operator|=
operator|(
name|tree
operator|*
operator|)
name|obstack_next_free
argument_list|(
name|obstack
argument_list|)
expr_stmt|;
while|while
condition|(
name|tp
operator|!=
name|bp
condition|)
block|{
operator|--
name|tp
expr_stmt|;
if|if
condition|(
operator|*
name|tp
operator|!=
name|NULL_TREE
condition|)
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
return|return
name|pop_stack_level
argument_list|(
name|stack
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* For each binding contour we allocate a binding_level structure  * which records the names defined in that contour.  * Contours include:  *  0) the global one  *  1) one for each function definition,  *     where internal declarations of the parameters appear.  *  2) one for each compound statement,  *     to record its declarations.  *  * The current meaning of a name can be found by searching the levels from  * the current one out to the global one.  *  * Off to the side, may be the class_binding_level.  This exists  * only to catch class-local declarations.  It is otherwise  * nonexistent.  *   * Also there may be binding levels that catch cleanups that  * must be run when exceptions occur.  */
end_comment

begin_comment
comment|/* Note that the information in the `names' component of the global contour    is duplicated in the IDENTIFIER_GLOBAL_VALUEs of all identifiers.  */
end_comment

begin_struct
struct|struct
name|binding_level
block|{
comment|/* A chain of _DECL nodes for all variables, constants, functions,      * and typedef types.  These are in the reverse of the order supplied.      */
name|tree
name|names
decl_stmt|;
comment|/* A list of structure, union and enum definitions,      * for looking up tag names.      * It is a chain of TREE_LIST nodes, each of whose TREE_PURPOSE is a name,      * or NULL_TREE; and whose TREE_VALUE is a RECORD_TYPE, UNION_TYPE,      * or ENUMERAL_TYPE node.      *      * C++: the TREE_VALUE nodes can be simple types for component_bindings.      *      */
name|tree
name|tags
decl_stmt|;
comment|/* For each level, a list of shadowed outer-level local definitions        to be restored when this level is popped.        Each link is a TREE_LIST whose TREE_PURPOSE is an identifier and        whose TREE_VALUE is its old definition (a kind of ..._DECL node).  */
name|tree
name|shadowed
decl_stmt|;
comment|/* Same, for IDENTIFIER_CLASS_VALUE.  */
name|tree
name|class_shadowed
decl_stmt|;
comment|/* Same, for IDENTIFIER_TYPE_VALUE.  */
name|tree
name|type_shadowed
decl_stmt|;
comment|/* For each level (except not the global one),        a chain of BLOCK nodes for all the levels        that were entered and exited one level down.  */
name|tree
name|blocks
decl_stmt|;
comment|/* The BLOCK node for this level, if one has been preallocated.        If 0, the BLOCK is allocated (if needed) when the level is popped.  */
name|tree
name|this_block
decl_stmt|;
comment|/* The binding level which this one is contained in (inherits from).  */
name|struct
name|binding_level
modifier|*
name|level_chain
decl_stmt|;
comment|/* Number of decls in `names' that have incomplete         structure or union types.  */
name|unsigned
name|short
name|n_incomplete
decl_stmt|;
comment|/* 1 for the level that holds the parameters of a function.        2 for the level that holds a class declaration.        3 for levels that hold parameter declarations.  */
name|unsigned
name|parm_flag
range|:
literal|4
decl_stmt|;
comment|/* 1 means make a BLOCK for this level regardless of all else.        2 for temporary binding contours created by the compiler.  */
name|unsigned
name|keep
range|:
literal|3
decl_stmt|;
comment|/* Nonzero if this level "doesn't exist" for tags.  */
name|unsigned
name|tag_transparent
range|:
literal|1
decl_stmt|;
comment|/* Nonzero if this level can safely have additional        cleanup-needing variables added to it.  */
name|unsigned
name|more_cleanups_ok
range|:
literal|1
decl_stmt|;
name|unsigned
name|have_cleanups
range|:
literal|1
decl_stmt|;
comment|/* Nonzero if this level can safely have additional        exception-raising statements added to it.  */
name|unsigned
name|more_exceptions_ok
range|:
literal|1
decl_stmt|;
name|unsigned
name|have_exceptions
range|:
literal|1
decl_stmt|;
comment|/* Nonzero if we should accept any name as an identifier in        this scope.  This happens in some template definitions.  */
name|unsigned
name|accept_any
range|:
literal|1
decl_stmt|;
comment|/* Nonzero if this level is for completing a template class definition        inside a binding level that temporarily binds the parameters.  This        means that definitions here should not be popped off when unwinding        this binding level.  (Not actually implemented this way,        unfortunately.)  */
name|unsigned
name|pseudo_global
range|:
literal|1
decl_stmt|;
comment|/* Two bits left for this word.  */
if|#
directive|if
name|PARANOID
name|unsigned
name|char
name|depth
decl_stmt|;
endif|#
directive|endif
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|NULL_BINDING_LEVEL
value|(struct binding_level *) NULL
end_define

begin_comment
comment|/* The binding level currently in effect.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|binding_level
modifier|*
name|current_binding_level
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The binding level of the current class, if any.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|binding_level
modifier|*
name|class_binding_level
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A chain of binding_level structures awaiting reuse.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|binding_level
modifier|*
name|free_binding_level
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The outermost binding level, for names of file scope.    This is created when the compiler is started and exists    through the entire run.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|binding_level
modifier|*
name|global_binding_level
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Binding level structures are initialized by copying this one.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|binding_level
name|clear_binding_level
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means unconditionally make a BLOCK for the next level pushed.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|keep_next_level_flag
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|PARANOID
end_if

begin_comment
comment|/* Perform sanity checking on binding levels.  Normally not needed.  */
end_comment

begin_function
name|void
name|binding_levels_sane
parameter_list|()
block|{
name|struct
name|binding_level
modifier|*
name|b
init|=
name|current_binding_level
decl_stmt|;
specifier|static
name|int
name|n
decl_stmt|;
if|if
condition|(
operator|++
name|n
operator|<
literal|3
condition|)
return|return;
name|my_friendly_assert
argument_list|(
name|global_binding_level
operator|!=
literal|0
argument_list|,
literal|126
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|current_binding_level
operator|!=
literal|0
argument_list|,
literal|127
argument_list|)
expr_stmt|;
for|for
control|(
name|b
operator|=
name|current_binding_level
init|;
name|b
operator|!=
name|global_binding_level
condition|;
name|b
operator|=
name|b
operator|->
name|level_chain
control|)
block|{
name|my_friendly_assert
argument_list|(
name|b
operator|->
name|level_chain
operator|!=
literal|0
argument_list|,
literal|128
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|b
operator|->
name|depth
operator|==
literal|1
operator|+
name|b
operator|->
name|level_chain
operator|->
name|depth
argument_list|,
literal|129
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|class_binding_level
condition|)
for|for
control|(
name|b
operator|=
name|class_binding_level
init|;
name|b
operator|!=
name|global_binding_level
operator|&&
name|b
operator|!=
name|current_binding_level
condition|;
name|b
operator|=
name|b
operator|->
name|level_chain
control|)
block|{
name|my_friendly_assert
argument_list|(
name|b
operator|->
name|level_chain
operator|!=
literal|0
argument_list|,
literal|130
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|b
operator|->
name|depth
operator|==
literal|1
operator|+
name|b
operator|->
name|level_chain
operator|->
name|depth
argument_list|,
literal|131
argument_list|)
expr_stmt|;
block|}
name|my_friendly_assert
argument_list|(
name|global_binding_level
operator|->
name|depth
operator|==
literal|0
argument_list|,
literal|132
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|global_binding_level
operator|->
name|level_chain
operator|==
literal|0
argument_list|,
literal|133
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|binding_levels_sane
parameter_list|()
value|((void)(1))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG_CP_BINDING_LEVELS
end_ifdef

begin_decl_stmt
name|int
name|debug_bindings_indentation
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
if|#
directive|if
operator|!
name|PARANOID
operator|&&
name|defined
argument_list|(
name|__GNUC__
argument_list|)
name|__inline
endif|#
directive|endif
name|push_binding_level
parameter_list|(
name|newlevel
parameter_list|,
name|tag_transparent
parameter_list|,
name|keep
parameter_list|)
name|struct
name|binding_level
modifier|*
name|newlevel
decl_stmt|;
name|int
name|tag_transparent
decl_stmt|,
name|keep
decl_stmt|;
block|{
name|binding_levels_sane
argument_list|()
expr_stmt|;
comment|/* Add this level to the front of the chain (stack) of levels that      are active.  */
ifdef|#
directive|ifdef
name|DEBUG_CP_BINDING_LEVELS
name|indent_to
argument_list|(
name|stderr
argument_list|,
name|debug_bindings_indentation
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"pushing binding level "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|HOST_PTR_PRINTF
argument_list|,
name|newlevel
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|newlevel
operator|=
name|clear_binding_level
expr_stmt|;
if|if
condition|(
name|class_binding_level
condition|)
block|{
name|newlevel
operator|->
name|level_chain
operator|=
name|class_binding_level
expr_stmt|;
name|class_binding_level
operator|=
operator|(
expr|struct
name|binding_level
operator|*
operator|)
literal|0
expr_stmt|;
block|}
else|else
block|{
name|newlevel
operator|->
name|level_chain
operator|=
name|current_binding_level
expr_stmt|;
block|}
name|current_binding_level
operator|=
name|newlevel
expr_stmt|;
name|newlevel
operator|->
name|tag_transparent
operator|=
name|tag_transparent
expr_stmt|;
name|newlevel
operator|->
name|more_cleanups_ok
operator|=
literal|1
expr_stmt|;
name|newlevel
operator|->
name|more_exceptions_ok
operator|=
literal|1
expr_stmt|;
name|newlevel
operator|->
name|keep
operator|=
name|keep
expr_stmt|;
if|#
directive|if
name|PARANOID
name|newlevel
operator|->
name|depth
operator|=
operator|(
name|newlevel
operator|->
name|level_chain
condition|?
name|newlevel
operator|->
name|level_chain
operator|->
name|depth
operator|+
literal|1
else|:
literal|0
operator|)
expr_stmt|;
endif|#
directive|endif
name|binding_levels_sane
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
if|#
directive|if
operator|!
name|PARANOID
operator|&&
name|defined
argument_list|(
name|__GNUC__
argument_list|)
name|__inline
endif|#
directive|endif
name|pop_binding_level
parameter_list|()
block|{
name|binding_levels_sane
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_CP_BINDING_LEVELS
name|indent_to
argument_list|(
name|stderr
argument_list|,
name|debug_bindings_indentation
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"popping binding level "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|HOST_PTR_PRINTF
argument_list|,
name|current_binding_level
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|global_binding_level
condition|)
block|{
comment|/* cannot pop a level, if there are none left to pop. */
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
condition|)
name|my_friendly_abort
argument_list|(
literal|123
argument_list|)
expr_stmt|;
block|}
comment|/* Pop the current level, and free the structure for reuse.  */
block|{
specifier|register
name|struct
name|binding_level
modifier|*
name|level
init|=
name|current_binding_level
decl_stmt|;
name|current_binding_level
operator|=
name|current_binding_level
operator|->
name|level_chain
expr_stmt|;
name|level
operator|->
name|level_chain
operator|=
name|free_binding_level
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_CP_BINDING_LEVELS
name|memset
argument_list|(
name|level
argument_list|,
literal|0x69
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|level
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|free_binding_level
operator|=
name|level
expr_stmt|;
if|#
directive|if
name|PARANOID
name|level
operator|->
name|depth
operator|=
operator|~
literal|0
expr_stmt|;
comment|/* ~0 assumes that the depth is unsigned. */
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
name|current_binding_level
operator|->
name|parm_flag
operator|==
literal|2
condition|)
block|{
name|class_binding_level
operator|=
name|current_binding_level
expr_stmt|;
do|do
block|{
name|current_binding_level
operator|=
name|current_binding_level
operator|->
name|level_chain
expr_stmt|;
block|}
do|while
condition|(
name|current_binding_level
operator|->
name|parm_flag
operator|==
literal|2
condition|)
do|;
block|}
block|}
name|binding_levels_sane
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Nonzero if we are currently in the global binding level.  */
end_comment

begin_function
name|int
name|global_bindings_p
parameter_list|()
block|{
return|return
name|current_binding_level
operator|==
name|global_binding_level
return|;
block|}
end_function

begin_function
name|void
name|keep_next_level
parameter_list|()
block|{
name|keep_next_level_flag
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Nonzero if the current level needs to have a BLOCK made.  */
end_comment

begin_function
name|int
name|kept_level_p
parameter_list|()
block|{
return|return
operator|(
name|current_binding_level
operator|->
name|blocks
operator|!=
name|NULL_TREE
operator|||
name|current_binding_level
operator|->
name|keep
operator|||
name|current_binding_level
operator|->
name|names
operator|!=
name|NULL_TREE
operator|||
operator|(
name|current_binding_level
operator|->
name|tags
operator|!=
name|NULL_TREE
operator|&&
operator|!
name|current_binding_level
operator|->
name|tag_transparent
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Identify this binding level as a level of parameters.  */
end_comment

begin_function
name|void
name|declare_parm_level
parameter_list|()
block|{
name|current_binding_level
operator|->
name|parm_flag
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Identify this binding level as a level of a default exception handler.  */
end_comment

begin_function
name|void
name|declare_implicit_exception
parameter_list|()
block|{
name|current_binding_level
operator|->
name|parm_flag
operator|=
literal|3
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Nonzero if current binding contour contains expressions    that might raise exceptions.  */
end_comment

begin_function
name|int
name|have_exceptions_p
parameter_list|()
block|{
return|return
name|current_binding_level
operator|->
name|have_exceptions
return|;
block|}
end_function

begin_function
name|void
name|declare_uninstantiated_type_level
parameter_list|()
block|{
name|current_binding_level
operator|->
name|accept_any
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|int
name|uninstantiated_type_level_p
parameter_list|()
block|{
return|return
name|current_binding_level
operator|->
name|accept_any
return|;
block|}
end_function

begin_function
name|void
name|declare_pseudo_global_level
parameter_list|()
block|{
name|current_binding_level
operator|->
name|pseudo_global
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|int
name|pseudo_global_level_p
parameter_list|()
block|{
return|return
name|current_binding_level
operator|->
name|pseudo_global
return|;
block|}
end_function

begin_comment
comment|/* Enter a new binding level.    If TAG_TRANSPARENT is nonzero, do so only for the name space of variables,    not for that of tags.  */
end_comment

begin_function
name|void
name|pushlevel
parameter_list|(
name|tag_transparent
parameter_list|)
name|int
name|tag_transparent
decl_stmt|;
block|{
specifier|register
name|struct
name|binding_level
modifier|*
name|newlevel
init|=
name|NULL_BINDING_LEVEL
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_CP_BINDING_LEVELS
name|indent_to
argument_list|(
name|stderr
argument_list|,
name|debug_bindings_indentation
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"pushlevel"
argument_list|)
expr_stmt|;
name|debug_bindings_indentation
operator|+=
literal|4
expr_stmt|;
endif|#
directive|endif
comment|/* If this is the top level of a function,      just make sure that NAMED_LABELS is 0.      They should have been set to 0 at the end of the previous function.  */
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
condition|)
name|my_friendly_assert
argument_list|(
name|named_labels
operator|==
name|NULL_TREE
argument_list|,
literal|134
argument_list|)
expr_stmt|;
comment|/* Reuse or create a struct for this binding level.  */
if|if
condition|(
name|free_binding_level
condition|)
block|{
name|newlevel
operator|=
name|free_binding_level
expr_stmt|;
name|free_binding_level
operator|=
name|free_binding_level
operator|->
name|level_chain
expr_stmt|;
block|}
else|else
block|{
comment|/* Create a new `struct binding_level'.  */
name|newlevel
operator|=
operator|(
expr|struct
name|binding_level
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|binding_level
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|push_binding_level
argument_list|(
name|newlevel
argument_list|,
name|tag_transparent
argument_list|,
name|keep_next_level_flag
argument_list|)
expr_stmt|;
name|GNU_xref_start_scope
argument_list|(
operator|(
name|int
operator|)
name|newlevel
argument_list|)
expr_stmt|;
name|keep_next_level_flag
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_CP_BINDING_LEVELS
name|debug_bindings_indentation
operator|-=
literal|4
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|pushlevel_temporary
parameter_list|(
name|tag_transparent
parameter_list|)
name|int
name|tag_transparent
decl_stmt|;
block|{
name|pushlevel
argument_list|(
name|tag_transparent
argument_list|)
expr_stmt|;
name|current_binding_level
operator|->
name|keep
operator|=
literal|2
expr_stmt|;
name|clear_last_expr
argument_list|()
expr_stmt|;
comment|/* Note we don't call push_momentary() here.  Otherwise, it would cause      cleanups to be allocated on the momentary obstack, and they will be      overwritten by the next statement.  */
name|expand_start_bindings
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Exit a binding level.    Pop the level off, and restore the state of the identifier-decl mappings    that were in effect when this level was entered.     If KEEP == 1, this level had explicit declarations, so    and create a "block" (a BLOCK node) for the level    to record its declarations and subblocks for symbol table output.     If KEEP == 2, this level's subblocks go to the front,    not the back of the current binding level.  This happens,    for instance, when code for constructors and destructors    need to generate code at the end of a function which must    be moved up to the front of the function.     If FUNCTIONBODY is nonzero, this level is the body of a function,    so create a block as if KEEP were set and also clear out all    label names.     If REVERSE is nonzero, reverse the order of decls before putting    them into the BLOCK.  */
end_comment

begin_function
name|tree
name|poplevel
parameter_list|(
name|keep
parameter_list|,
name|reverse
parameter_list|,
name|functionbody
parameter_list|)
name|int
name|keep
decl_stmt|;
name|int
name|reverse
decl_stmt|;
name|int
name|functionbody
decl_stmt|;
block|{
specifier|register
name|tree
name|link
decl_stmt|;
comment|/* The chain of decls was accumulated in reverse order.      Put it into forward order, just for cleanliness.  */
name|tree
name|decls
decl_stmt|;
name|int
name|tmp
init|=
name|functionbody
decl_stmt|;
name|int
name|implicit_try_block
init|=
name|current_binding_level
operator|->
name|parm_flag
operator|==
literal|3
decl_stmt|;
name|int
name|real_functionbody
init|=
name|current_binding_level
operator|->
name|keep
operator|==
literal|2
condition|?
operator|(
operator|(
name|functionbody
operator|=
literal|0
operator|)
expr|,
name|tmp
operator|)
else|:
name|functionbody
decl_stmt|;
name|tree
name|tags
init|=
name|functionbody
operator|>=
literal|0
condition|?
name|current_binding_level
operator|->
name|tags
else|:
literal|0
decl_stmt|;
name|tree
name|subblocks
init|=
name|functionbody
operator|>=
literal|0
condition|?
name|current_binding_level
operator|->
name|blocks
else|:
literal|0
decl_stmt|;
name|tree
name|block
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|int
name|block_previously_created
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_CP_BINDING_LEVELS
name|indent_to
argument_list|(
name|stderr
argument_list|,
name|debug_bindings_indentation
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"poplevel"
argument_list|)
expr_stmt|;
name|debug_bindings_indentation
operator|+=
literal|4
expr_stmt|;
endif|#
directive|endif
name|binding_levels_sane
argument_list|()
expr_stmt|;
name|GNU_xref_end_scope
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|)
name|current_binding_level
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
name|current_binding_level
operator|->
name|level_chain
argument_list|,
name|current_binding_level
operator|->
name|parm_flag
argument_list|,
name|current_binding_level
operator|->
name|keep
argument_list|,
name|current_binding_level
operator|->
name|tag_transparent
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_binding_level
operator|->
name|keep
operator|==
literal|1
condition|)
name|keep
operator|=
literal|1
expr_stmt|;
comment|/* This warning is turned off because it causes warnings for      declarations like `extern struct foo *x'.  */
if|#
directive|if
literal|0
comment|/* Warn about incomplete structure types in this level.  */
block|for (link = tags; link; link = TREE_CHAIN (link))     if (TYPE_SIZE (TREE_VALUE (link)) == NULL_TREE)       { 	tree type = TREE_VALUE (link); 	char *errmsg; 	switch (TREE_CODE (type)) 	  { 	  case RECORD_TYPE: 	    errmsg = "`struct %s' incomplete in scope ending here"; 	    break; 	  case UNION_TYPE: 	    errmsg = "`union %s' incomplete in scope ending here"; 	    break; 	  case ENUMERAL_TYPE: 	    errmsg = "`enum %s' incomplete in scope ending here"; 	    break; 	  } 	if (TREE_CODE (TYPE_NAME (type)) == IDENTIFIER_NODE) 	  error (errmsg, IDENTIFIER_POINTER (TYPE_NAME (type))); 	else
comment|/* If this type has a typedef-name, the TYPE_NAME is a TYPE_DECL.  */
block|error (errmsg, TYPE_NAME_STRING (type));       }
endif|#
directive|endif
comment|/* 0 */
comment|/* Get the decls in the order they were written.      Usually current_binding_level->names is in reverse order.      But parameter decls were previously put in forward order.  */
if|if
condition|(
name|reverse
condition|)
name|current_binding_level
operator|->
name|names
operator|=
name|decls
operator|=
name|nreverse
argument_list|(
name|current_binding_level
operator|->
name|names
argument_list|)
expr_stmt|;
else|else
name|decls
operator|=
name|current_binding_level
operator|->
name|names
expr_stmt|;
comment|/* Output any nested inline functions within this block      if they weren't already output.  */
for|for
control|(
name|decl
operator|=
name|decls
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|TREE_ADDRESSABLE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* If this decl was copied from a file-scope decl 	   on account of a block-scope extern decl, 	   propagate TREE_ADDRESSABLE to the file-scope decl.  */
if|if
condition|(
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|TREE_ADDRESSABLE
argument_list|(
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
name|output_inline_function
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
comment|/* If there were any declarations or structure tags in that level,      or if this level is a function body,      create a BLOCK to record them for the life of this function.  */
name|block
operator|=
name|NULL_TREE
expr_stmt|;
name|block_previously_created
operator|=
operator|(
name|current_binding_level
operator|->
name|this_block
operator|!=
name|NULL_TREE
operator|)
expr_stmt|;
if|if
condition|(
name|block_previously_created
condition|)
name|block
operator|=
name|current_binding_level
operator|->
name|this_block
expr_stmt|;
elseif|else
if|if
condition|(
name|keep
operator|==
literal|1
operator|||
name|functionbody
condition|)
name|block
operator|=
name|make_node
argument_list|(
name|BLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|block
operator|!=
name|NULL_TREE
condition|)
block|{
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
operator|=
name|decls
expr_stmt|;
name|BLOCK_TYPE_TAGS
argument_list|(
name|block
argument_list|)
operator|=
name|tags
expr_stmt|;
name|BLOCK_SUBBLOCKS
argument_list|(
name|block
argument_list|)
operator|=
name|subblocks
expr_stmt|;
name|remember_end_note
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
comment|/* In each subblock, record that this is its superior.  */
if|if
condition|(
name|keep
operator|>=
literal|0
condition|)
for|for
control|(
name|link
operator|=
name|subblocks
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
name|BLOCK_SUPERCONTEXT
argument_list|(
name|link
argument_list|)
operator|=
name|block
expr_stmt|;
comment|/* Clear out the meanings of the local variables of this level.  */
for|for
control|(
name|link
operator|=
name|decls
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|link
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
comment|/* If the ident. was used or addressed via a local extern decl, 	     don't forget that fact.  */
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|link
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_USED
argument_list|(
name|link
argument_list|)
condition|)
name|TREE_USED
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|link
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|link
argument_list|)
condition|)
name|TREE_ADDRESSABLE
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|link
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|link
argument_list|)
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
comment|/* Restore all name-meanings of the outer levels      that were shadowed by this level.  */
for|for
control|(
name|link
operator|=
name|current_binding_level
operator|->
name|shadowed
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
expr_stmt|;
for|for
control|(
name|link
operator|=
name|current_binding_level
operator|->
name|class_shadowed
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
expr_stmt|;
for|for
control|(
name|link
operator|=
name|current_binding_level
operator|->
name|type_shadowed
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
expr_stmt|;
comment|/* If the level being exited is the top level of a function,      check over all the labels.  */
if|if
condition|(
name|functionbody
condition|)
block|{
comment|/* If this is the top level block of a function,          the vars are the function's parameters.          Don't leave them in the BLOCK because they are          found in the FUNCTION_DECL instead.  */
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Clear out the definitions of all label names, 	 since their scopes end here.  */
for|for
control|(
name|link
operator|=
name|named_labels
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
block|{
specifier|register
name|tree
name|label
init|=
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
decl_stmt|;
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|label
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|error_with_decl
argument_list|(
name|label
argument_list|,
literal|"label `%s' used but not defined"
argument_list|)
expr_stmt|;
comment|/* Avoid crashing later.  */
name|define_label
argument_list|(
name|input_filename
argument_list|,
literal|1
argument_list|,
name|DECL_NAME
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|warn_unused
operator|&&
operator|!
name|TREE_USED
argument_list|(
name|label
argument_list|)
condition|)
name|warning_with_decl
argument_list|(
name|label
argument_list|,
literal|"label `%s' defined but not used"
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_LABEL_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|label
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Put the labels into the "variables" of the              top-level block, so debugger can see them.  */
name|TREE_CHAIN
argument_list|(
name|label
argument_list|)
operator|=
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
operator|=
name|label
expr_stmt|;
block|}
name|named_labels
operator|=
name|NULL_TREE
expr_stmt|;
block|}
comment|/* Any uses of undefined labels now operate under constraints      of next binding contour.  */
block|{
name|struct
name|binding_level
modifier|*
name|level_chain
decl_stmt|;
name|level_chain
operator|=
name|current_binding_level
operator|->
name|level_chain
expr_stmt|;
if|if
condition|(
name|level_chain
condition|)
block|{
name|tree
name|labels
decl_stmt|;
for|for
control|(
name|labels
operator|=
name|named_label_uses
init|;
name|labels
condition|;
name|labels
operator|=
name|TREE_CHAIN
argument_list|(
name|labels
argument_list|)
control|)
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|labels
argument_list|)
operator|==
operator|(
name|tree
operator|)
name|current_binding_level
condition|)
block|{
name|TREE_TYPE
argument_list|(
name|labels
argument_list|)
operator|=
operator|(
name|tree
operator|)
name|level_chain
expr_stmt|;
name|TREE_PURPOSE
argument_list|(
name|labels
argument_list|)
operator|=
name|level_chain
operator|->
name|names
expr_stmt|;
block|}
block|}
block|}
name|tmp
operator|=
name|current_binding_level
operator|->
name|keep
expr_stmt|;
name|pop_binding_level
argument_list|()
expr_stmt|;
if|if
condition|(
name|functionbody
condition|)
name|DECL_INITIAL
argument_list|(
name|current_function_decl
argument_list|)
operator|=
name|block
expr_stmt|;
elseif|else
if|if
condition|(
name|block
condition|)
block|{
if|if
condition|(
operator|!
name|block_previously_created
condition|)
name|current_binding_level
operator|->
name|blocks
operator|=
name|chainon
argument_list|(
name|current_binding_level
operator|->
name|blocks
argument_list|,
name|block
argument_list|)
expr_stmt|;
block|}
comment|/* If we did not make a block for the level just exited,      any blocks made for inner levels      (since they cannot be recorded as subblocks in that level)      must be carried forward so they will later become subblocks      of something else.  */
elseif|else
if|if
condition|(
name|subblocks
condition|)
if|if
condition|(
name|keep
operator|==
literal|2
condition|)
name|current_binding_level
operator|->
name|blocks
operator|=
name|chainon
argument_list|(
name|subblocks
argument_list|,
name|current_binding_level
operator|->
name|blocks
argument_list|)
expr_stmt|;
else|else
name|current_binding_level
operator|->
name|blocks
operator|=
name|chainon
argument_list|(
name|current_binding_level
operator|->
name|blocks
argument_list|,
name|subblocks
argument_list|)
expr_stmt|;
comment|/* Take care of compiler's internal binding structures.  */
if|if
condition|(
name|tmp
operator|==
literal|2
operator|&&
operator|!
name|implicit_try_block
condition|)
block|{
if|#
directive|if
literal|0
comment|/* We did not call push_momentary for this 	 binding contour, so there is nothing to pop.  */
block|pop_momentary ();
endif|#
directive|endif
name|expand_end_bindings
argument_list|(
name|getdecls
argument_list|()
argument_list|,
name|keep
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|block
operator|=
name|poplevel
argument_list|(
name|keep
argument_list|,
name|reverse
argument_list|,
name|real_functionbody
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|block
condition|)
name|TREE_USED
argument_list|(
name|block
argument_list|)
operator|=
literal|1
expr_stmt|;
name|binding_levels_sane
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_CP_BINDING_LEVELS
name|debug_bindings_indentation
operator|-=
literal|4
expr_stmt|;
endif|#
directive|endif
return|return
name|block
return|;
block|}
end_function

begin_comment
comment|/* Delete the node BLOCK from the current binding level.    This is used for the block inside a stmt expr ({...})    so that the block can be reinserted where appropriate.  */
end_comment

begin_function
name|void
name|delete_block
parameter_list|(
name|block
parameter_list|)
name|tree
name|block
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|current_binding_level
operator|->
name|blocks
operator|==
name|block
condition|)
name|current_binding_level
operator|->
name|blocks
operator|=
name|TREE_CHAIN
argument_list|(
name|block
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|current_binding_level
operator|->
name|blocks
init|;
name|t
condition|;
control|)
block|{
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|==
name|block
condition|)
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|block
argument_list|)
expr_stmt|;
else|else
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
name|TREE_CHAIN
argument_list|(
name|block
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Clear TREE_USED which is always set by poplevel.      The flag is set again if insert_block is called.  */
name|TREE_USED
argument_list|(
name|block
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Insert BLOCK at the end of the list of subblocks of the    current binding level.  This is used when a BIND_EXPR is expanded,    to handle the BLOCK node inside the BIND_EXPR.  */
end_comment

begin_function
name|void
name|insert_block
parameter_list|(
name|block
parameter_list|)
name|tree
name|block
decl_stmt|;
block|{
name|TREE_USED
argument_list|(
name|block
argument_list|)
operator|=
literal|1
expr_stmt|;
name|current_binding_level
operator|->
name|blocks
operator|=
name|chainon
argument_list|(
name|current_binding_level
operator|->
name|blocks
argument_list|,
name|block
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add BLOCK to the current list of blocks for this binding contour.  */
end_comment

begin_function
name|void
name|add_block_current_level
parameter_list|(
name|block
parameter_list|)
name|tree
name|block
decl_stmt|;
block|{
name|current_binding_level
operator|->
name|blocks
operator|=
name|chainon
argument_list|(
name|current_binding_level
operator|->
name|blocks
argument_list|,
name|block
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the BLOCK node for the innermost scope    (the one we are currently in).  */
end_comment

begin_function
name|void
name|set_block
parameter_list|(
name|block
parameter_list|)
specifier|register
name|tree
name|block
decl_stmt|;
block|{
name|current_binding_level
operator|->
name|this_block
operator|=
name|block
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Do a pushlevel for class declarations.  */
end_comment

begin_function
name|void
name|pushlevel_class
parameter_list|()
block|{
name|binding_levels_sane
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_CP_BINDING_LEVELS
name|indent_to
argument_list|(
name|stderr
argument_list|,
name|debug_bindings_indentation
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"pushlevel_class"
argument_list|)
expr_stmt|;
name|debug_bindings_indentation
operator|+=
literal|4
expr_stmt|;
endif|#
directive|endif
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|decl_stack
operator|=
name|push_decl_level
argument_list|(
name|decl_stack
argument_list|,
operator|&
name|decl_obstack
argument_list|)
expr_stmt|;
name|class_binding_level
operator|=
name|current_binding_level
expr_stmt|;
name|class_binding_level
operator|->
name|parm_flag
operator|=
literal|2
expr_stmt|;
do|do
block|{
name|current_binding_level
operator|=
name|current_binding_level
operator|->
name|level_chain
expr_stmt|;
block|}
do|while
condition|(
name|current_binding_level
operator|->
name|parm_flag
operator|==
literal|2
condition|)
do|;
name|binding_levels_sane
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_CP_BINDING_LEVELS
name|debug_bindings_indentation
operator|-=
literal|4
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ...and a poplevel for class declarations.  */
end_comment

begin_function
name|tree
name|poplevel_class
parameter_list|()
block|{
specifier|register
name|struct
name|binding_level
modifier|*
name|level
init|=
name|class_binding_level
decl_stmt|;
name|tree
name|block
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|shadowed
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_CP_BINDING_LEVELS
name|indent_to
argument_list|(
name|stderr
argument_list|,
name|debug_bindings_indentation
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"poplevel_class"
argument_list|)
expr_stmt|;
name|debug_bindings_indentation
operator|+=
literal|4
expr_stmt|;
endif|#
directive|endif
name|binding_levels_sane
argument_list|()
expr_stmt|;
if|if
condition|(
name|level
operator|==
operator|(
expr|struct
name|binding_level
operator|*
operator|)
literal|0
condition|)
block|{
while|while
condition|(
name|current_binding_level
operator|&&
name|class_binding_level
operator|==
operator|(
expr|struct
name|binding_level
operator|*
operator|)
literal|0
condition|)
name|block
operator|=
name|poplevel
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_binding_level
operator|==
operator|(
expr|struct
name|binding_level
operator|*
operator|)
literal|0
condition|)
name|fatal
argument_list|(
literal|"syntax error too serious"
argument_list|)
expr_stmt|;
name|level
operator|=
name|class_binding_level
expr_stmt|;
block|}
name|decl_stack
operator|=
name|pop_decl_level
argument_list|(
name|decl_stack
argument_list|)
expr_stmt|;
for|for
control|(
name|shadowed
operator|=
name|level
operator|->
name|shadowed
init|;
name|shadowed
condition|;
name|shadowed
operator|=
name|TREE_CHAIN
argument_list|(
name|shadowed
argument_list|)
control|)
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|shadowed
argument_list|)
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|shadowed
argument_list|)
expr_stmt|;
for|for
control|(
name|shadowed
operator|=
name|level
operator|->
name|class_shadowed
init|;
name|shadowed
condition|;
name|shadowed
operator|=
name|TREE_CHAIN
argument_list|(
name|shadowed
argument_list|)
control|)
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|shadowed
argument_list|)
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|shadowed
argument_list|)
expr_stmt|;
for|for
control|(
name|shadowed
operator|=
name|level
operator|->
name|type_shadowed
init|;
name|shadowed
condition|;
name|shadowed
operator|=
name|TREE_CHAIN
argument_list|(
name|shadowed
argument_list|)
control|)
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|shadowed
argument_list|)
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|shadowed
argument_list|)
expr_stmt|;
name|GNU_xref_end_scope
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|)
name|class_binding_level
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
name|class_binding_level
operator|->
name|level_chain
argument_list|,
name|class_binding_level
operator|->
name|parm_flag
argument_list|,
name|class_binding_level
operator|->
name|keep
argument_list|,
name|class_binding_level
operator|->
name|tag_transparent
argument_list|)
expr_stmt|;
name|class_binding_level
operator|=
name|level
operator|->
name|level_chain
expr_stmt|;
if|if
condition|(
name|class_binding_level
operator|->
name|parm_flag
operator|!=
literal|2
condition|)
name|class_binding_level
operator|=
operator|(
expr|struct
name|binding_level
operator|*
operator|)
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_CP_BINDING_LEVELS
name|indent_to
argument_list|(
name|stderr
argument_list|,
name|debug_bindings_indentation
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"popping class binding level "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|HOST_PTR_PRINTF
argument_list|,
name|level
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|level
argument_list|,
literal|0x69
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|level
argument_list|)
argument_list|)
expr_stmt|;
name|debug_bindings_indentation
operator|-=
literal|4
expr_stmt|;
else|#
directive|else
name|level
operator|->
name|level_chain
operator|=
name|free_binding_level
expr_stmt|;
name|free_binding_level
operator|=
name|level
expr_stmt|;
endif|#
directive|endif
name|binding_levels_sane
argument_list|()
expr_stmt|;
return|return
name|block
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* For debugging.  */
end_comment

begin_decl_stmt
name|int
name|no_print_functions
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|no_print_builtins
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|print_binding_level
parameter_list|(
name|lvl
parameter_list|)
name|struct
name|binding_level
modifier|*
name|lvl
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|,
name|len
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" blocks="
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|HOST_PTR_PRINTF
argument_list|,
name|lvl
operator|->
name|blocks
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" n_incomplete=%d parm_flag=%d keep=%d"
argument_list|,
name|lvl
operator|->
name|n_incomplete
argument_list|,
name|lvl
operator|->
name|parm_flag
argument_list|,
name|lvl
operator|->
name|keep
argument_list|)
expr_stmt|;
if|if
condition|(
name|lvl
operator|->
name|tag_transparent
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" tag-transparent"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lvl
operator|->
name|more_cleanups_ok
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" more-cleanups-ok"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lvl
operator|->
name|have_cleanups
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" have-cleanups"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lvl
operator|->
name|more_exceptions_ok
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" more-exceptions-ok"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lvl
operator|->
name|have_exceptions
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" have-exceptions"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lvl
operator|->
name|names
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" names:\t"
argument_list|)
expr_stmt|;
comment|/* We can probably fit 3 names to a line?  */
for|for
control|(
name|t
operator|=
name|lvl
operator|->
name|names
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
if|if
condition|(
name|no_print_functions
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FUNCTION_DECL
operator|)
condition|)
continue|continue;
if|if
condition|(
name|no_print_builtins
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_DECL
operator|)
operator|&&
operator|(
operator|!
name|strcmp
argument_list|(
name|DECL_SOURCE_FILE
argument_list|(
name|t
argument_list|)
argument_list|,
literal|"<built-in>"
argument_list|)
operator|)
condition|)
continue|continue;
comment|/* Function decls tend to have longer names.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|len
operator|=
literal|3
expr_stmt|;
else|else
name|len
operator|=
literal|2
expr_stmt|;
name|i
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|6
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n\t"
argument_list|)
expr_stmt|;
name|i
operator|=
name|len
expr_stmt|;
block|}
name|print_node_brief
argument_list|(
name|stderr
argument_list|,
literal|""
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ERROR_MARK
condition|)
break|break;
block|}
if|if
condition|(
name|i
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lvl
operator|->
name|tags
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" tags:\t"
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|t
operator|=
name|lvl
operator|->
name|tags
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|len
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_IDENTIFIER
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
name|len
operator|=
literal|2
expr_stmt|;
else|else
name|len
operator|=
literal|4
expr_stmt|;
name|i
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|5
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n\t"
argument_list|)
expr_stmt|;
name|i
operator|=
name|len
expr_stmt|;
block|}
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|print_node_brief
argument_list|(
name|stderr
argument_list|,
literal|"<unnamed-typedef"
argument_list|,
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_IDENTIFIER
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
name|print_node_brief
argument_list|(
name|stderr
argument_list|,
literal|""
argument_list|,
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|print_node_brief
argument_list|(
name|stderr
argument_list|,
literal|"<typedef"
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|print_node_brief
argument_list|(
name|stderr
argument_list|,
literal|""
argument_list|,
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lvl
operator|->
name|shadowed
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" shadowed:"
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|lvl
operator|->
name|shadowed
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %s "
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lvl
operator|->
name|class_shadowed
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" class-shadowed:"
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|lvl
operator|->
name|class_shadowed
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %s "
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lvl
operator|->
name|type_shadowed
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" type-shadowed:"
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|lvl
operator|->
name|type_shadowed
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
if|#
directive|if
literal|0
block|fprintf (stderr, "\n\t");           print_node_brief (stderr, "<", TREE_PURPOSE (t), 0);           if (TREE_VALUE (t))             print_node_brief (stderr, " ", TREE_VALUE (t), 0);           else             fprintf (stderr, " (none)");           fprintf (stderr, ">");
else|#
directive|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %s "
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|print_other_binding_stack
parameter_list|(
name|stack
parameter_list|)
name|struct
name|binding_level
modifier|*
name|stack
decl_stmt|;
block|{
name|struct
name|binding_level
modifier|*
name|level
decl_stmt|;
for|for
control|(
name|level
operator|=
name|stack
init|;
name|level
operator|!=
name|global_binding_level
condition|;
name|level
operator|=
name|level
operator|->
name|level_chain
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"binding level "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|HOST_PTR_PRINTF
argument_list|,
name|level
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|print_binding_level
argument_list|(
name|level
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|print_binding_stack
parameter_list|()
block|{
name|struct
name|binding_level
modifier|*
name|b
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"current_binding_level="
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|HOST_PTR_PRINTF
argument_list|,
name|current_binding_level
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nclass_binding_level="
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|HOST_PTR_PRINTF
argument_list|,
name|class_binding_level
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nglobal_binding_level="
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|HOST_PTR_PRINTF
argument_list|,
name|global_binding_level
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|class_binding_level
condition|)
block|{
for|for
control|(
name|b
operator|=
name|class_binding_level
init|;
name|b
condition|;
name|b
operator|=
name|b
operator|->
name|level_chain
control|)
if|if
condition|(
name|b
operator|==
name|current_binding_level
condition|)
break|break;
if|if
condition|(
name|b
condition|)
name|b
operator|=
name|class_binding_level
expr_stmt|;
else|else
name|b
operator|=
name|current_binding_level
expr_stmt|;
block|}
else|else
name|b
operator|=
name|current_binding_level
expr_stmt|;
name|print_other_binding_stack
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"global:\n"
argument_list|)
expr_stmt|;
name|print_binding_level
argument_list|(
name|global_binding_level
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutines for reverting temporarily to top-level for instantiation    of templates and such.  We actually need to clear out the class- and    local-value slots of all identifiers, so that only the global values    are at all visible.  Simply setting current_binding_level to the global    scope isn't enough, because more binding levels may be pushed.  */
end_comment

begin_struct
struct|struct
name|saved_scope
block|{
name|struct
name|binding_level
modifier|*
name|old_binding_level
decl_stmt|;
name|tree
name|old_bindings
decl_stmt|;
name|struct
name|saved_scope
modifier|*
name|prev
decl_stmt|;
name|tree
name|class_name
decl_stmt|,
name|class_type
decl_stmt|,
name|class_decl
decl_stmt|,
name|function_decl
decl_stmt|;
name|struct
name|binding_level
modifier|*
name|class_bindings
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|saved_scope
modifier|*
name|current_saved_scope
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|tree
name|prev_class_type
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|push_to_top_level
parameter_list|()
block|{
name|struct
name|saved_scope
modifier|*
name|s
init|=
operator|(
expr|struct
name|saved_scope
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|saved_scope
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|binding_level
modifier|*
name|b
init|=
name|current_binding_level
decl_stmt|;
name|tree
name|old_bindings
init|=
name|NULL_TREE
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_CP_BINDING_LEVELS
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"PUSH_TO_TOP_LEVEL\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Have to include global_binding_level, because class-level decls      aren't listed anywhere useful.  */
for|for
control|(
init|;
name|b
condition|;
name|b
operator|=
name|b
operator|->
name|level_chain
control|)
block|{
name|tree
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
name|b
operator|->
name|names
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|b
operator|!=
name|global_binding_level
condition|)
block|{
name|tree
name|binding
decl_stmt|,
name|t1
decl_stmt|,
name|t2
init|=
name|t
decl_stmt|;
name|tree
name|id
init|=
name|DECL_ASSEMBLER_NAME
argument_list|(
name|t2
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|id
operator|||
operator|(
operator|!
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|id
argument_list|)
operator|&&
operator|!
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|id
argument_list|)
operator|)
condition|)
continue|continue;
for|for
control|(
name|t1
operator|=
name|old_bindings
init|;
name|t1
condition|;
name|t1
operator|=
name|TREE_CHAIN
argument_list|(
name|t1
argument_list|)
control|)
if|if
condition|(
name|TREE_VEC_ELT
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
operator|==
name|id
condition|)
goto|goto
name|skip_it
goto|;
name|binding
operator|=
name|make_tree_vec
argument_list|(
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|==
name|IDENTIFIER_NODE
argument_list|,
literal|135
argument_list|)
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|binding
argument_list|,
literal|0
argument_list|)
operator|=
name|id
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|binding
argument_list|,
literal|1
argument_list|)
operator|=
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|binding
argument_list|,
literal|2
argument_list|)
operator|=
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|binding
argument_list|,
literal|3
argument_list|)
operator|=
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|id
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|id
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|adjust_type_value
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
name|TREE_CHAIN
argument_list|(
name|binding
argument_list|)
operator|=
name|old_bindings
expr_stmt|;
name|old_bindings
operator|=
name|binding
expr_stmt|;
name|skip_it
label|:
empty_stmt|;
block|}
comment|/* Unwind type-value slots back to top level.  */
if|if
condition|(
name|b
operator|!=
name|global_binding_level
condition|)
for|for
control|(
name|t
operator|=
name|b
operator|->
name|type_shadowed
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
name|SET_IDENTIFIER_TYPE_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|s
operator|->
name|old_binding_level
operator|=
name|current_binding_level
expr_stmt|;
name|current_binding_level
operator|=
name|global_binding_level
expr_stmt|;
name|s
operator|->
name|class_name
operator|=
name|current_class_name
expr_stmt|;
name|s
operator|->
name|class_type
operator|=
name|current_class_type
expr_stmt|;
name|s
operator|->
name|class_decl
operator|=
name|current_class_decl
expr_stmt|;
name|s
operator|->
name|function_decl
operator|=
name|current_function_decl
expr_stmt|;
name|s
operator|->
name|class_bindings
operator|=
name|class_binding_level
expr_stmt|;
name|current_class_name
operator|=
name|current_class_type
operator|=
name|current_class_decl
operator|=
name|NULL_TREE
expr_stmt|;
name|current_function_decl
operator|=
name|NULL_TREE
expr_stmt|;
name|class_binding_level
operator|=
operator|(
expr|struct
name|binding_level
operator|*
operator|)
literal|0
expr_stmt|;
name|s
operator|->
name|prev
operator|=
name|current_saved_scope
expr_stmt|;
name|s
operator|->
name|old_bindings
operator|=
name|old_bindings
expr_stmt|;
name|current_saved_scope
operator|=
name|s
expr_stmt|;
name|binding_levels_sane
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pop_from_top_level
parameter_list|()
block|{
name|struct
name|saved_scope
modifier|*
name|s
init|=
name|current_saved_scope
decl_stmt|;
name|tree
name|t
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_CP_BINDING_LEVELS
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"POP_FROM_TOP_LEVEL\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|binding_levels_sane
argument_list|()
expr_stmt|;
name|current_binding_level
operator|=
name|s
operator|->
name|old_binding_level
expr_stmt|;
name|current_saved_scope
operator|=
name|s
operator|->
name|prev
expr_stmt|;
for|for
control|(
name|t
operator|=
name|s
operator|->
name|old_bindings
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|tree
name|id
init|=
name|TREE_VEC_ELT
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|id
condition|)
block|{
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|id
argument_list|)
operator|=
name|TREE_VEC_ELT
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|id
argument_list|)
operator|=
name|TREE_VEC_ELT
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|id
argument_list|)
operator|=
name|TREE_VEC_ELT
argument_list|(
name|t
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
block|}
name|current_class_name
operator|=
name|s
operator|->
name|class_name
expr_stmt|;
name|current_class_type
operator|=
name|s
operator|->
name|class_type
expr_stmt|;
name|current_class_decl
operator|=
name|s
operator|->
name|class_decl
expr_stmt|;
if|if
condition|(
name|current_class_type
condition|)
name|C_C_D
operator|=
name|CLASSTYPE_INST_VAR
argument_list|(
name|current_class_type
argument_list|)
expr_stmt|;
else|else
name|C_C_D
operator|=
name|NULL_TREE
expr_stmt|;
name|current_function_decl
operator|=
name|s
operator|->
name|function_decl
expr_stmt|;
name|class_binding_level
operator|=
name|s
operator|->
name|class_bindings
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|binding_levels_sane
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Push a definition of struct, union or enum tag "name".    "type" should be the type node.    We assume that the tag "name" is not already defined.     Note that the definition may really be just a forward reference.    In that case, the TYPE_SIZE will be a NULL_TREE.     C++ gratuitously puts all these tags in the name space. */
end_comment

begin_comment
comment|/* When setting the IDENTIFIER_TYPE_VALUE field of an identifier ID,    record the shadowed value for this binding contour.  TYPE is    the type that ID maps to.  */
end_comment

begin_function
name|void
name|set_identifier_type_value
parameter_list|(
name|id
parameter_list|,
name|type
parameter_list|)
name|tree
name|id
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
name|current_binding_level
operator|!=
name|global_binding_level
condition|)
block|{
name|tree
name|old_type_value
init|=
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|current_binding_level
operator|->
name|type_shadowed
operator|=
name|tree_cons
argument_list|(
name|id
argument_list|,
name|old_type_value
argument_list|,
name|current_binding_level
operator|->
name|type_shadowed
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|class_binding_level
condition|)
block|{
name|tree
name|old_type_value
init|=
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|class_binding_level
operator|->
name|type_shadowed
operator|=
name|tree_cons
argument_list|(
name|id
argument_list|,
name|old_type_value
argument_list|,
name|class_binding_level
operator|->
name|type_shadowed
argument_list|)
expr_stmt|;
block|}
name|SET_IDENTIFIER_TYPE_VALUE
argument_list|(
name|id
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * local values can need to be shadowed too, but it only happens  * explicitly from pushdecl, in support of nested enums.  */
end_comment

begin_function
name|void
name|set_identifier_local_value
parameter_list|(
name|id
parameter_list|,
name|type
parameter_list|)
name|tree
name|id
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
name|current_binding_level
operator|!=
name|global_binding_level
condition|)
block|{
name|tree
name|old_local_value
init|=
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|current_binding_level
operator|->
name|shadowed
operator|=
name|tree_cons
argument_list|(
name|id
argument_list|,
name|old_local_value
argument_list|,
name|current_binding_level
operator|->
name|shadowed
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|class_binding_level
condition|)
block|{
name|tree
name|old_local_value
init|=
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|class_binding_level
operator|->
name|shadowed
operator|=
name|tree_cons
argument_list|(
name|id
argument_list|,
name|old_local_value
argument_list|,
name|class_binding_level
operator|->
name|shadowed
argument_list|)
expr_stmt|;
block|}
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|id
argument_list|)
operator|=
name|type
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Subroutine "set_nested_typename" builds the nested-typename of    the type decl in question.  (Argument CLASSNAME can actually be    a function as well, if that's the smallest containing scope.)  */
end_comment

begin_function
specifier|static
name|void
name|set_nested_typename
parameter_list|(
name|decl
parameter_list|,
name|classname
parameter_list|,
name|name
parameter_list|,
name|type
parameter_list|)
name|tree
name|decl
decl_stmt|,
name|classname
decl_stmt|,
name|name
decl_stmt|,
name|type
decl_stmt|;
block|{
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
argument_list|,
literal|136
argument_list|)
expr_stmt|;
if|if
condition|(
name|classname
operator|!=
name|NULL_TREE
condition|)
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|classname
argument_list|)
operator|==
name|IDENTIFIER_NODE
argument_list|,
literal|137
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|IDENTIFIER_NODE
argument_list|,
literal|138
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|4
operator|+
name|IDENTIFIER_LENGTH
argument_list|(
name|classname
argument_list|)
operator|+
name|IDENTIFIER_LENGTH
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s::%s"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|classname
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_NESTED_TYPENAME
argument_list|(
name|decl
argument_list|)
operator|=
name|get_identifier
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_TYPE_VALUE
argument_list|(
name|DECL_NESTED_TYPENAME
argument_list|(
name|decl
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
else|else
name|DECL_NESTED_TYPENAME
argument_list|(
name|decl
argument_list|)
operator|=
name|name
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* not yet, should get fixed properly later */
end_comment

begin_comment
comment|/* Create a TYPE_DECL node with the correct DECL_ASSEMBLER_NAME.    Other routines shouldn't use build_decl directly; they'll produce    incorrect results with `-g' unless they duplicate this code.     This is currently needed mainly for dbxout.c, but we can make    use of it in cp-method.c later as well.  */
end_comment

begin_comment
unit|tree make_type_decl (name, type)      tree name, type; {   tree decl, id;   decl = build_decl (TYPE_DECL, name, type);   if (TYPE_NAME (type) == name)
comment|/* Class/union/enum definition, or a redundant typedef for same.  */
end_comment

begin_comment
unit|{       id = get_identifier (build_overload_name (type, 1, 1));       DECL_ASSEMBLER_NAME (decl) = id;     }   else if (TYPE_NAME (type) != NULL_TREE)
comment|/* Explicit typedef, or implicit typedef for template expansion.  */
end_comment

begin_comment
unit|DECL_ASSEMBLER_NAME (decl) = DECL_ASSEMBLER_NAME (TYPE_NAME (type));   else     {
comment|/* Typedef for unnamed struct; some other situations. 	 TYPE_NAME is null; what's right here?  */
end_comment

begin_endif
unit|}   return decl; }
endif|#
directive|endif
end_endif

begin_function
name|void
name|pushtag
parameter_list|(
name|name
parameter_list|,
name|type
parameter_list|)
name|tree
name|name
decl_stmt|,
name|type
decl_stmt|;
block|{
specifier|register
name|struct
name|binding_level
modifier|*
name|b
decl_stmt|;
if|if
condition|(
name|class_binding_level
condition|)
name|b
operator|=
name|class_binding_level
expr_stmt|;
else|else
block|{
name|b
operator|=
name|current_binding_level
expr_stmt|;
while|while
condition|(
name|b
operator|->
name|tag_transparent
condition|)
name|b
operator|=
name|b
operator|->
name|level_chain
expr_stmt|;
block|}
if|if
condition|(
name|b
operator|==
name|global_binding_level
condition|)
name|b
operator|->
name|tags
operator|=
name|perm_tree_cons
argument_list|(
name|name
argument_list|,
name|type
argument_list|,
name|b
operator|->
name|tags
argument_list|)
expr_stmt|;
else|else
name|b
operator|->
name|tags
operator|=
name|saveable_tree_cons
argument_list|(
name|name
argument_list|,
name|type
argument_list|,
name|b
operator|->
name|tags
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
block|{
comment|/* Record the identifier as the type's name if it has none.  */
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|=
name|name
expr_stmt|;
comment|/* Do C++ gratuitous typedefing.  */
if|if
condition|(
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|name
argument_list|)
operator|!=
name|type
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|RECORD_TYPE
operator|||
name|class_binding_level
operator|==
operator|(
expr|struct
name|binding_level
operator|*
operator|)
literal|0
operator|||
operator|!
name|CLASSTYPE_DECLARED_EXCEPTION
argument_list|(
name|type
argument_list|)
operator|)
condition|)
block|{
specifier|register
name|tree
name|d
decl_stmt|;
if|if
condition|(
name|current_class_type
operator|==
name|NULL_TREE
operator|||
name|TYPE_SIZE
argument_list|(
name|current_class_type
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|current_lang_name
operator|==
name|lang_name_cplusplus
condition|)
name|d
operator|=
name|lookup_nested_type
argument_list|(
name|type
argument_list|,
name|current_class_type
condition|?
name|TYPE_NAME
argument_list|(
name|current_class_type
argument_list|)
else|:
name|NULL_TREE
argument_list|)
expr_stmt|;
else|else
name|d
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|d
operator|==
name|NULL_TREE
condition|)
block|{
if|#
directive|if
literal|0
comment|/* not yet, should get fixed properly later */
block|d = make_type_decl (name, type); 		  DECL_ASSEMBLER_NAME (d) = get_identifier (build_overload_name (type, 1, 1));
else|#
directive|else
name|d
operator|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|DECL_ASSEMBLER_NAME
argument_list|(
name|d
argument_list|)
operator|=
name|get_identifier
argument_list|(
name|build_overload_name
argument_list|(
name|type
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* mark the binding layer marker as internal. (mrs) */
name|DECL_SOURCE_LINE
argument_list|(
name|d
argument_list|)
operator|=
literal|0
expr_stmt|;
name|set_identifier_type_value
argument_list|(
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
else|else
name|d
operator|=
name|TYPE_NAME
argument_list|(
name|d
argument_list|)
expr_stmt|;
comment|/* If it is anonymous, then we are called from pushdecl, 		 and we don't want to infinitely recurse.  Also, if the 		 name is already in scope, we don't want to push it 		 again--pushdecl is only for pushing new decls.  */
if|if
condition|(
operator|!
name|ANON_AGGRNAME_P
argument_list|(
name|name
argument_list|)
operator|&&
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|TYPE_DECL
operator|||
name|lookup_name
argument_list|(
name|name
argument_list|,
literal|1
argument_list|)
operator|!=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|class_binding_level
condition|)
name|d
operator|=
name|pushdecl_class_level
argument_list|(
name|d
argument_list|)
expr_stmt|;
else|else
name|d
operator|=
name|pushdecl
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Make nested declarations go into class-level scope.  */
name|d
operator|=
name|build_lang_field_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|set_identifier_type_value
argument_list|(
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|d
operator|=
name|pushdecl_class_level
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ANON_AGGRNAME_P
argument_list|(
name|name
argument_list|)
condition|)
name|DECL_IGNORED_P
argument_list|(
name|d
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|=
name|d
expr_stmt|;
if|if
condition|(
operator|(
name|current_class_type
operator|==
name|NULL_TREE
operator|&&
name|current_function_decl
operator|==
name|NULL_TREE
operator|)
operator|||
name|current_lang_name
operator|!=
name|lang_name_cplusplus
condition|)
comment|/* Non-nested class.  */
name|DECL_NESTED_TYPENAME
argument_list|(
name|d
argument_list|)
operator|=
name|name
expr_stmt|;
elseif|else
if|if
condition|(
name|current_function_decl
operator|!=
name|NULL_TREE
condition|)
block|{
comment|/* Function-nested class.  */
name|set_nested_typename
argument_list|(
name|d
argument_list|,
name|DECL_ASSEMBLER_NAME
argument_list|(
name|current_function_decl
argument_list|)
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* This builds the links for classes nested in fn scope.  */
name|DECL_CONTEXT
argument_list|(
name|d
argument_list|)
operator|=
name|current_function_decl
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|current_class_type
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* Class-nested class.  */
name|set_nested_typename
argument_list|(
name|d
argument_list|,
name|DECL_NESTED_TYPENAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|current_class_type
argument_list|)
argument_list|)
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* This builds the links for classes nested in type scope.  */
name|DECL_CONTEXT
argument_list|(
name|d
argument_list|)
operator|=
name|current_class_type
expr_stmt|;
name|DECL_CLASS_CONTEXT
argument_list|(
name|d
argument_list|)
operator|=
name|current_class_type
expr_stmt|;
block|}
block|}
if|if
condition|(
name|b
operator|->
name|parm_flag
operator|==
literal|2
condition|)
block|{
name|TREE_NONLOCAL_FLAG
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|name
argument_list|)
operator|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|current_class_type
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|CLASSTYPE_TAGS
argument_list|(
name|current_class_type
argument_list|)
operator|=
name|b
operator|->
name|tags
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
condition|)
comment|/* Use the canonical TYPE_DECL for this node.  */
name|TYPE_STUB_DECL
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Create a fake NULL-named TYPE_DECL node whose TREE_TYPE 	 will be the tagged type we just added to the current 	 binding level.  This fake NULL-named TYPE_DECL node helps 	 dwarfout.c to know when it needs to output a 	 representation of a tagged type, and it also gives us a 	 convenient place to record the "scope start" address for 	 the tagged type.  */
if|#
directive|if
literal|0
comment|/* not yet, should get fixed properly later */
block|TYPE_STUB_DECL (type) = pushdecl (make_type_decl (NULL, type));
else|#
directive|else
name|TYPE_STUB_DECL
argument_list|(
name|type
argument_list|)
operator|=
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/* Counter used to create anonymous type names.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|anon_cnt
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return an IDENTIFIER which can be used as a name for    anonymous structs and unions.  */
end_comment

begin_function
name|tree
name|make_anon_name
parameter_list|()
block|{
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
name|ANON_AGGRNAME_FORMAT
argument_list|,
name|anon_cnt
operator|++
argument_list|)
expr_stmt|;
return|return
name|get_identifier
argument_list|(
name|buf
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Clear the TREE_PURPOSE slot of tags which have anonymous typenames.    This keeps dbxout from getting confused.  */
end_comment

begin_function
name|void
name|clear_anon_tags
parameter_list|()
block|{
specifier|register
name|struct
name|binding_level
modifier|*
name|b
decl_stmt|;
specifier|register
name|tree
name|tags
decl_stmt|;
specifier|static
name|int
name|last_cnt
init|=
literal|0
decl_stmt|;
comment|/* Fast out if no new anon names were declared.  */
if|if
condition|(
name|last_cnt
operator|==
name|anon_cnt
condition|)
return|return;
name|b
operator|=
name|current_binding_level
expr_stmt|;
while|while
condition|(
name|b
operator|->
name|tag_transparent
condition|)
name|b
operator|=
name|b
operator|->
name|level_chain
expr_stmt|;
name|tags
operator|=
name|b
operator|->
name|tags
expr_stmt|;
while|while
condition|(
name|tags
condition|)
block|{
comment|/* A NULL purpose means we have already processed all tags 	 from here to the end of the list.  */
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|tags
argument_list|)
operator|==
name|NULL_TREE
condition|)
break|break;
if|if
condition|(
name|ANON_AGGRNAME_P
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tags
argument_list|)
argument_list|)
condition|)
name|TREE_PURPOSE
argument_list|(
name|tags
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|tags
operator|=
name|TREE_CHAIN
argument_list|(
name|tags
argument_list|)
expr_stmt|;
block|}
name|last_cnt
operator|=
name|anon_cnt
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutine of duplicate_decls: return truthvalue of whether    or not types of these decls match.  */
end_comment

begin_function
specifier|static
name|int
name|decls_match
parameter_list|(
name|newdecl
parameter_list|,
name|olddecl
parameter_list|)
name|tree
name|newdecl
decl_stmt|,
name|olddecl
decl_stmt|;
block|{
name|int
name|types_match
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|tree
name|f1
init|=
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
decl_stmt|;
name|tree
name|f2
init|=
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
decl_stmt|;
name|tree
name|p1
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|f1
argument_list|)
decl_stmt|;
name|tree
name|p2
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|f2
argument_list|)
decl_stmt|;
comment|/* When we parse a static member function definition, 	 we put together a FUNCTION_DECL which thinks its type 	 is METHOD_TYPE.  Change that to FUNCTION_TYPE, and 	 proceed.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|f1
argument_list|)
operator|==
name|METHOD_TYPE
operator|&&
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|olddecl
argument_list|)
condition|)
name|revert_static_member_fn
argument_list|(
operator|&
name|f1
argument_list|,
operator|&
name|newdecl
argument_list|,
operator|&
name|p1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|f2
argument_list|)
operator|==
name|METHOD_TYPE
operator|&&
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|newdecl
argument_list|)
condition|)
name|revert_static_member_fn
argument_list|(
operator|&
name|f2
argument_list|,
operator|&
name|olddecl
argument_list|,
operator|&
name|p2
argument_list|)
expr_stmt|;
comment|/* Here we must take care of the case where new default 	 parameters are specified.  Also, warn if an old 	 declaration becomes ambiguous because default 	 parameters may cause the two to be ambiguous.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|f1
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|f2
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|f1
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
name|compiler_error_with_decl
argument_list|(
name|newdecl
argument_list|,
literal|"`%s' redeclared as member function"
argument_list|)
expr_stmt|;
else|else
name|compiler_error_with_decl
argument_list|(
name|newdecl
argument_list|,
literal|"`%s' redeclared as non-member function"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|comptypes
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|f1
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|f2
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
name|types_match
operator|=
name|compparms
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|types_match
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|error_mark_node
condition|)
name|types_match
operator|=
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|error_mark_node
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|types_match
operator|=
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|NULL_TREE
expr_stmt|;
else|else
name|types_match
operator|=
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|types_match
return|;
block|}
end_function

begin_comment
comment|/* Handle when a new declaration NEWDECL has the same name as an old    one OLDDECL in the same binding contour.  Prints an error message    if appropriate.     If safely possible, alter OLDDECL to look like NEWDECL, and return 1.    Otherwise, return 0.  */
end_comment

begin_function
specifier|static
name|int
name|duplicate_decls
parameter_list|(
name|newdecl
parameter_list|,
name|olddecl
parameter_list|)
specifier|register
name|tree
name|newdecl
decl_stmt|,
name|olddecl
decl_stmt|;
block|{
specifier|extern
name|struct
name|obstack
name|permanent_obstack
decl_stmt|;
name|unsigned
name|olddecl_uid
init|=
name|DECL_UID
argument_list|(
name|olddecl
argument_list|)
decl_stmt|;
name|int
name|olddecl_friend
init|=
literal|0
decl_stmt|,
name|types_match
decl_stmt|;
name|int
name|new_defines_function
decl_stmt|;
specifier|register
name|unsigned
name|saved_old_decl_uid
decl_stmt|;
specifier|register
name|int
name|saved_old_decl_friend_p
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
comment|/* If a new decl finds a list of old decls, then 	 we assume that the new decl has C linkage, and 	 that the old decls have C++ linkage.  In this case, 	 we must look through the list to see whether 	 there is an ambiguity or not.  */
name|tree
name|olddecls
init|=
name|olddecl
decl_stmt|;
comment|/* If the overload list is empty, just install the decl.  */
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|olddecls
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|TREE_VALUE
argument_list|(
name|olddecls
argument_list|)
operator|=
name|newdecl
expr_stmt|;
return|return
literal|1
return|;
block|}
while|while
condition|(
name|olddecls
condition|)
block|{
if|if
condition|(
name|decls_match
argument_list|(
name|newdecl
argument_list|,
name|TREE_VALUE
argument_list|(
name|olddecls
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|VAR_DECL
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|DECL_LANGUAGE
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|DECL_LANGUAGE
argument_list|(
name|TREE_VALUE
argument_list|(
name|olddecls
argument_list|)
argument_list|)
condition|)
block|{
name|error_with_decl
argument_list|(
name|newdecl
argument_list|,
literal|"declaration of `%s' with different language linkage"
argument_list|)
expr_stmt|;
name|error_with_decl
argument_list|(
name|TREE_VALUE
argument_list|(
name|olddecls
argument_list|)
argument_list|,
literal|"previous declaration here"
argument_list|)
expr_stmt|;
block|}
name|types_match
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|olddecls
operator|=
name|TREE_CHAIN
argument_list|(
name|olddecls
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|olddecls
condition|)
name|olddecl
operator|=
name|TREE_VALUE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
else|else
return|return
literal|1
return|;
block|}
else|else
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|!=
name|TREE_LIST
condition|)
name|olddecl_friend
operator|=
name|DECL_LANG_SPECIFIC
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|DECL_FRIEND_P
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|types_match
operator|=
name|decls_match
argument_list|(
name|newdecl
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
operator|==
name|ERROR_MARK
operator|)
operator|||
operator|(
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
operator|==
name|ERROR_MARK
operator|)
condition|)
name|types_match
operator|=
literal|0
expr_stmt|;
comment|/* If this decl has linkage, and the old one does too, maybe no error.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
name|error_with_decl
argument_list|(
name|newdecl
argument_list|,
literal|"`%s' redeclared as different kind of symbol"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|olddecl
operator|=
name|TREE_VALUE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|error_with_decl
argument_list|(
name|olddecl
argument_list|,
literal|"previous declaration of `%s'"
argument_list|)
expr_stmt|;
comment|/* New decl is completely inconsistent with the old one => 	 tell caller to replace the old one.  */
return|return
literal|0
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
comment|/* Now that functions must hold information normally held 	 by field decls, there is extra work to do so that 	 declaration information does not get destroyed during 	 definition.  */
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|olddecl
argument_list|)
condition|)
name|DECL_VINDEX
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_VINDEX
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|olddecl
argument_list|)
condition|)
name|DECL_CONTEXT
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_CONTEXT
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_CLASS_CONTEXT
argument_list|(
name|olddecl
argument_list|)
condition|)
name|DECL_CLASS_CONTEXT
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_CLASS_CONTEXT
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_CHAIN
argument_list|(
name|newdecl
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|DECL_CHAIN
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_CHAIN
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_PENDING_INLINE_INFO
argument_list|(
name|newdecl
argument_list|)
operator|==
operator|(
expr|struct
name|pending_inline
operator|*
operator|)
literal|0
condition|)
name|DECL_PENDING_INLINE_INFO
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_PENDING_INLINE_INFO
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_traditional
operator|&&
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|newdecl
argument_list|)
argument_list|)
operator|==
name|olddecl
condition|)
comment|/* If -traditional, avoid error for redeclaring fcn        after implicit decl.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_BUILT_IN
argument_list|(
name|olddecl
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|types_match
condition|)
block|{
name|error_with_decl
argument_list|(
name|newdecl
argument_list|,
literal|"declaration of `%s'"
argument_list|)
expr_stmt|;
name|error_with_decl
argument_list|(
name|olddecl
argument_list|,
literal|"conflicts with built-in declaration `%s'"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|types_match
condition|)
block|{
name|tree
name|oldtype
init|=
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
decl_stmt|;
name|tree
name|newtype
init|=
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
decl_stmt|;
name|int
name|give_error
init|=
literal|0
decl_stmt|;
comment|/* Already complained about this, so don't do so again.  */
if|if
condition|(
name|current_class_type
operator|==
name|NULL_TREE
operator|||
name|IDENTIFIER_ERROR_LOCUS
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|newdecl
argument_list|)
argument_list|)
operator|!=
name|current_class_type
condition|)
block|{
name|give_error
operator|=
literal|1
expr_stmt|;
name|error_with_decl
argument_list|(
name|newdecl
argument_list|,
literal|"conflicting types for `%s'"
argument_list|)
expr_stmt|;
block|}
comment|/* Check for function type mismatch 	 involving an empty arglist vs a nonempty one.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|oldtype
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|newtype
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|&&
operator|(
operator|(
name|TYPE_ARG_TYPES
argument_list|(
name|oldtype
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
operator|==
name|NULL_TREE
operator|)
operator|||
operator|(
name|TYPE_ARG_TYPES
argument_list|(
name|newtype
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|==
name|NULL_TREE
operator|)
operator|)
condition|)
block|{
comment|/* Classify the problem further.  */
specifier|register
name|tree
name|t
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|oldtype
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL_TREE
condition|)
name|t
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|newtype
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
specifier|register
name|tree
name|type
init|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|type
operator|!=
name|void_type_node
condition|)
block|{
name|error
argument_list|(
literal|"A parameter list with an ellipsis can't match"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"an empty parameter name list declaration."
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|float_type_node
operator|||
name|C_PROMOTING_INTEGER_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"An argument type that has a default promotion"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"can't match an empty parameter name list declaration."
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|give_error
condition|)
name|error_with_decl
argument_list|(
name|olddecl
argument_list|,
literal|"previous declaration of `%s'"
argument_list|)
expr_stmt|;
comment|/* There is one thing GNU C++ cannot tolerate: a constructor 	 which takes the type of object being constructed. 	 Farm that case out here.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_CONSTRUCTOR_P
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
name|tree
name|tmp
init|=
name|TREE_CHAIN
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|newtype
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmp
operator|!=
name|NULL_TREE
operator|&&
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_VALUE
argument_list|(
name|tmp
argument_list|)
argument_list|)
operator|==
name|TYPE_METHOD_BASETYPE
argument_list|(
name|newtype
argument_list|)
operator|)
condition|)
block|{
name|tree
name|parm
init|=
name|TREE_CHAIN
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|newdecl
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|argtypes
init|=
name|hash_tree_chain
argument_list|(
name|build_reference_type
argument_list|(
name|TREE_VALUE
argument_list|(
name|tmp
argument_list|)
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|tmp
argument_list|)
argument_list|)
decl_stmt|;
name|DECL_ARG_TYPE
argument_list|(
name|parm
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
operator|=
name|TYPE_REFERENCE_TO
argument_list|(
name|TREE_VALUE
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|newtype
operator|=
name|build_cplus_method_type
argument_list|(
name|TYPE_METHOD_BASETYPE
argument_list|(
name|newtype
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|newtype
argument_list|)
argument_list|,
name|argtypes
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"constructor cannot take as argument the type being constructed"
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_ERROR_LOCUS
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|newdecl
argument_list|)
argument_list|,
name|current_class_type
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|char
modifier|*
name|errmsg
init|=
name|redeclaration_error_message
argument_list|(
name|newdecl
argument_list|,
name|olddecl
argument_list|)
decl_stmt|;
if|if
condition|(
name|errmsg
condition|)
block|{
name|error_with_decl
argument_list|(
name|newdecl
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|olddecl
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|error_with_decl
argument_list|(
name|olddecl
argument_list|,
operator|(
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|current_binding_level
operator|==
name|global_binding_level
operator|)
condition|?
literal|"`%s' previously defined here"
else|:
literal|"`%s' previously declared here"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
comment|/* Prototype decl follows defn w/o prototype.  */
name|warning_with_decl
argument_list|(
name|newdecl
argument_list|,
literal|"prototype for `%s'"
argument_list|)
expr_stmt|;
name|warning_with_decl
argument_list|(
name|olddecl
argument_list|,
literal|"follows non-prototype definition here"
argument_list|)
expr_stmt|;
block|}
comment|/* These bits are logically part of the type.  */
if|if
condition|(
name|pedantic
operator|&&
operator|(
name|TREE_READONLY
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|TREE_READONLY
argument_list|(
name|olddecl
argument_list|)
operator|||
name|TREE_THIS_VOLATILE
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|TREE_THIS_VOLATILE
argument_list|(
name|olddecl
argument_list|)
operator|)
condition|)
name|error_with_decl
argument_list|(
name|newdecl
argument_list|,
literal|"type qualifiers for `%s' conflict with previous decl"
argument_list|)
expr_stmt|;
block|}
comment|/* Deal with C++: must preserve virtual function table size.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
operator|&&
name|TYPE_LANG_SPECIFIC
argument_list|(
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
condition|)
block|{
name|CLASSTYPE_VSIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
operator|=
name|CLASSTYPE_VSIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
expr_stmt|;
name|CLASSTYPE_FRIEND_CLASSES
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
operator|=
name|CLASSTYPE_FRIEND_CLASSES
argument_list|(
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* why assert here?  Just because debugging information is 	 messed up? (mrs) */
comment|/* it happens on something like: 	 	typedef struct Thing {                 	Thing(); 		        int     x; 		} Thing;       */
if|#
directive|if
literal|0
block|my_friendly_assert (DECL_IGNORED_P (olddecl) == DECL_IGNORED_P (newdecl), 139);
endif|#
directive|endif
block|}
comment|/* Special handling ensues if new decl is a function definition.  */
name|new_defines_function
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|NULL_TREE
operator|)
expr_stmt|;
comment|/* Optionally warn about more than one declaration for the same name,      but don't warn about a function declaration followed by a definition.  */
if|if
condition|(
name|warn_redundant_decls
operator|&&
name|DECL_SOURCE_LINE
argument_list|(
name|olddecl
argument_list|)
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|new_defines_function
operator|&&
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
operator|==
name|NULL_TREE
operator|)
condition|)
block|{
name|warning_with_decl
argument_list|(
name|newdecl
argument_list|,
literal|"redundant redeclaration of `%s' in same scope"
argument_list|)
expr_stmt|;
name|warning_with_decl
argument_list|(
name|olddecl
argument_list|,
literal|"previous declaration of `%s'"
argument_list|)
expr_stmt|;
block|}
comment|/* Copy all the DECL_... slots specified in the new decl      except for any that we copy here from the old type.  */
if|if
condition|(
name|types_match
condition|)
block|{
comment|/* Automatically handles default parameters.  */
name|tree
name|oldtype
init|=
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
decl_stmt|;
comment|/* Merge the data types specified in the two decls.  */
name|tree
name|newtype
init|=
name|common_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|DECL_THIS_EXTERN
argument_list|(
name|newdecl
argument_list|)
operator||=
name|DECL_THIS_EXTERN
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
comment|/* Do this after calling `common_type' so that default 	 parameters don't confuse us.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|(
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
operator|!=
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|tree
name|ctype
init|=
name|NULL_TREE
decl_stmt|;
name|ctype
operator|=
name|DECL_CLASS_CONTEXT
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|build_exception_variant
argument_list|(
name|ctype
argument_list|,
name|newtype
argument_list|,
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
operator|=
name|build_exception_variant
argument_list|(
name|ctype
argument_list|,
name|newtype
argument_list|,
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|oldtype
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|compexcepttypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|error_with_decl
argument_list|(
name|newdecl
argument_list|,
literal|"declaration of `%s' raises different exceptions..."
argument_list|)
expr_stmt|;
name|error_with_decl
argument_list|(
name|olddecl
argument_list|,
literal|"...from previous declaration here"
argument_list|)
expr_stmt|;
block|}
block|}
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
operator|=
name|newtype
expr_stmt|;
comment|/* Lay the type out, unless already done.  */
if|if
condition|(
name|oldtype
operator|!=
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|error_mark_node
condition|)
name|layout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|TYPE_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|CONST_DECL
condition|)
name|layout_decl
argument_list|(
name|newdecl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Since the type is OLDDECL's, make OLDDECL's size go with.  */
name|DECL_SIZE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_SIZE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
block|}
comment|/* Merge the type qualifiers.  */
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|newdecl
argument_list|)
condition|)
name|TREE_READONLY
argument_list|(
name|olddecl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|newdecl
argument_list|)
condition|)
name|TREE_THIS_VOLATILE
argument_list|(
name|olddecl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Merge the initialization information.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
comment|/* Keep the old rtl since we can safely use it, unless it's the 	 call to abort() used for abstract virtuals.  */
if|if
condition|(
operator|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|!
name|DECL_ABSTRACT_VIRTUAL_P
argument_list|(
name|olddecl
argument_list|)
operator|)
operator|||
name|DECL_RTL
argument_list|(
name|olddecl
argument_list|)
operator|!=
name|DECL_RTL
argument_list|(
name|abort_fndecl
argument_list|)
condition|)
name|DECL_RTL
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_RTL
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
block|}
comment|/* If cannot merge, then use the new type and qualifiers,      and don't preserve the old rtl.  */
else|else
block|{
comment|/* Clean out any memory we had of the old declaration.  */
name|tree
name|oldstatic
init|=
name|value_member
argument_list|(
name|olddecl
argument_list|,
name|static_aggregates
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldstatic
condition|)
name|TREE_VALUE
argument_list|(
name|oldstatic
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|olddecl
argument_list|)
operator|=
name|TREE_READONLY
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|olddecl
argument_list|)
operator|=
name|TREE_THIS_VOLATILE
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|olddecl
argument_list|)
operator|=
name|TREE_SIDE_EFFECTS
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
block|}
comment|/* Merge the storage class information.  */
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
name|TREE_STATIC
argument_list|(
name|newdecl
argument_list|)
operator|=
name|TREE_STATIC
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_EXTERNAL
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
comment|/* For functions, static overrides non-static.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|TREE_PUBLIC
argument_list|(
name|newdecl
argument_list|)
operator|&=
name|TREE_PUBLIC
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
comment|/* This is since we don't automatically 	     copy the attributes of NEWDECL into OLDDECL.  */
name|TREE_PUBLIC
argument_list|(
name|olddecl
argument_list|)
operator|=
name|TREE_PUBLIC
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
comment|/* If this clears `static', clear it in the identifier too.  */
if|if
condition|(
operator|!
name|TREE_PUBLIC
argument_list|(
name|olddecl
argument_list|)
condition|)
name|TREE_PUBLIC
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|olddecl
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|TREE_PUBLIC
argument_list|(
name|newdecl
argument_list|)
operator|=
name|TREE_PUBLIC
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TREE_STATIC
argument_list|(
name|olddecl
argument_list|)
operator|=
name|TREE_STATIC
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
comment|/* A `const' which was not declared `extern' and is 	 in static storage is invisible.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_READONLY
argument_list|(
name|newdecl
argument_list|)
operator|&&
name|TREE_STATIC
argument_list|(
name|newdecl
argument_list|)
operator|&&
operator|!
name|DECL_THIS_EXTERN
argument_list|(
name|newdecl
argument_list|)
condition|)
name|TREE_PUBLIC
argument_list|(
name|newdecl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|olddecl
argument_list|)
operator|=
name|TREE_PUBLIC
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
block|}
comment|/* If either decl says `inline', this fn is inline,      unless its definition was passed already.  */
if|if
condition|(
name|DECL_INLINE
argument_list|(
name|newdecl
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|DECL_INLINE
argument_list|(
name|olddecl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_INLINE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_INLINE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
if|if
condition|(
name|new_defines_function
condition|)
comment|/* If defining a function declared with other language 	   linkage, use the previously declared language linkage.  */
name|DECL_LANGUAGE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_LANGUAGE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* If redeclaring a builtin function, and not a definition, 	     it stays built in.  */
if|if
condition|(
name|DECL_BUILT_IN
argument_list|(
name|olddecl
argument_list|)
condition|)
block|{
name|DECL_BUILT_IN
argument_list|(
name|newdecl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_SET_FUNCTION_CODE
argument_list|(
name|newdecl
argument_list|,
name|DECL_FUNCTION_CODE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we're keeping the built-in definition, keep the rtl, 		 regardless of declaration matches.  */
name|DECL_RTL
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_RTL
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
block|}
else|else
name|DECL_FRAME_SIZE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_FRAME_SIZE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_RESULT
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_RESULT
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_SAVED_INSNS
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_SAVED_INSNS
argument_list|(
name|olddecl
argument_list|)
condition|)
comment|/* Previously saved insns go together with 	       the function's previous definition.  */
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
comment|/* Don't clear out the arguments if we're redefining a function.  */
if|if
condition|(
name|DECL_ARGUMENTS
argument_list|(
name|olddecl
argument_list|)
condition|)
name|DECL_ARGUMENTS
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now preserve various other info from the definition.  */
name|TREE_ADDRESSABLE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|TREE_ADDRESSABLE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|TREE_ASM_WRITTEN
argument_list|(
name|newdecl
argument_list|)
operator|=
name|TREE_ASM_WRITTEN
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
comment|/* Don't really know how much of the language-specific      values we should copy from old to new.  */
if|#
directive|if
literal|1
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|olddecl
argument_list|)
condition|)
name|DECL_IN_AGGR_P
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_IN_AGGR_P
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* We are about to copy the contexts of newdecl into olddecl, so save a      few tidbits of information from olddecl that we may need to restore      after the copying takes place.  */
name|saved_old_decl_uid
operator|=
name|DECL_UID
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|saved_old_decl_friend_p
operator|=
name|DECL_LANG_SPECIFIC
argument_list|(
name|olddecl
argument_list|)
condition|?
name|DECL_FRIEND_P
argument_list|(
name|olddecl
argument_list|)
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|int
name|function_size
decl_stmt|;
name|struct
name|lang_decl
modifier|*
name|ol
init|=
name|DECL_LANG_SPECIFIC
argument_list|(
name|olddecl
argument_list|)
decl_stmt|;
name|struct
name|lang_decl
modifier|*
name|nl
init|=
name|DECL_LANG_SPECIFIC
argument_list|(
name|newdecl
argument_list|)
decl_stmt|;
name|function_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|tree_decl
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|newdecl
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tree_common
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|olddecl
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tree_common
argument_list|)
argument_list|,
name|function_size
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|tree_common
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|char
operator|*
operator|)
name|newdecl
operator|+
operator|(
operator|(
name|function_size
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|lang_decl
argument_list|)
operator|+
name|obstack_alignment_mask
argument_list|(
operator|&
name|permanent_obstack
argument_list|)
operator|)
operator|&
operator|~
name|obstack_alignment_mask
argument_list|(
operator|&
name|permanent_obstack
argument_list|)
operator|)
operator|==
name|obstack_next_free
argument_list|(
operator|&
name|permanent_obstack
argument_list|)
condition|)
block|{
name|DECL_MAIN_VARIANT
argument_list|(
name|newdecl
argument_list|)
operator|=
name|olddecl
expr_stmt|;
name|DECL_LANG_SPECIFIC
argument_list|(
name|olddecl
argument_list|)
operator|=
name|ol
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|nl
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ol
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lang_decl
argument_list|)
argument_list|)
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|LANG_DECL_PERMANENT
argument_list|(
name|ol
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_MAIN_VARIANT
argument_list|(
name|olddecl
argument_list|)
operator|==
name|olddecl
condition|)
block|{
comment|/* Save these lang_decls that would otherwise be lost.  */
specifier|extern
name|tree
name|free_lang_decl_chain
decl_stmt|;
name|tree
name|free_lang_decl
init|=
operator|(
name|tree
operator|)
name|ol
decl_stmt|;
name|TREE_CHAIN
argument_list|(
name|free_lang_decl
argument_list|)
operator|=
name|free_lang_decl_chain
expr_stmt|;
name|free_lang_decl_chain
operator|=
name|free_lang_decl
expr_stmt|;
block|}
else|else
block|{
comment|/* Storage leak.  */
block|}
block|}
block|}
else|else
block|{
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|newdecl
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tree_common
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|olddecl
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tree_common
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tree_decl
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|tree_common
argument_list|)
operator|+
name|tree_code_length
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
index|]
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|DECL_UID
argument_list|(
name|olddecl
argument_list|)
operator|=
name|olddecl_uid
expr_stmt|;
if|if
condition|(
name|olddecl_friend
condition|)
name|DECL_FRIEND_P
argument_list|(
name|olddecl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Restore some pieces of information which were originally in olddecl.  */
name|DECL_UID
argument_list|(
name|olddecl
argument_list|)
operator|=
name|saved_old_decl_uid
expr_stmt|;
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|olddecl
argument_list|)
condition|)
name|DECL_FRIEND_P
argument_list|(
name|olddecl
argument_list|)
operator||=
name|saved_old_decl_friend_p
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|adjust_type_value
parameter_list|(
name|id
parameter_list|)
name|tree
name|id
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|current_binding_level
operator|!=
name|global_binding_level
condition|)
block|{
if|if
condition|(
name|current_binding_level
operator|!=
name|class_binding_level
condition|)
block|{
name|t
operator|=
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|set_it
label|:
name|SET_IDENTIFIER_TYPE_VALUE
argument_list|(
name|id
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
name|my_friendly_abort
argument_list|(
literal|7
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_class_type
condition|)
block|{
name|t
operator|=
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_DECL
condition|)
goto|goto
name|set_it
goto|;
block|}
block|}
name|t
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_DECL
condition|)
goto|goto
name|set_it
goto|;
if|if
condition|(
name|t
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
name|SET_IDENTIFIER_TYPE_VALUE
argument_list|(
name|id
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record a decl-node X as belonging to the current lexical scope.    Check for errors (such as an incompatible declaration for the same    name already seen in the same scope).     Returns either X or an old decl for the same name.    If an old decl is returned, it may have been smashed    to agree with what X says.  */
end_comment

begin_function
name|tree
name|pushdecl
parameter_list|(
name|x
parameter_list|)
name|tree
name|x
decl_stmt|;
block|{
specifier|register
name|tree
name|t
decl_stmt|;
if|#
directive|if
literal|0
comment|/* not yet, should get fixed properly later */
block|register tree name;
else|#
directive|else
specifier|register
name|tree
name|name
init|=
name|DECL_ASSEMBLER_NAME
argument_list|(
name|x
argument_list|)
decl_stmt|;
endif|#
directive|endif
specifier|register
name|struct
name|binding_level
modifier|*
name|b
init|=
name|current_binding_level
decl_stmt|;
if|#
directive|if
literal|0
block|static int nglobals; int len;    len = list_length (global_binding_level->names);   if (len< nglobals)     my_friendly_abort (8);   else if (len> nglobals)     nglobals = len;
endif|#
directive|endif
comment|/* Don't change DECL_CONTEXT of virtual methods.  */
if|if
condition|(
name|x
operator|!=
name|current_function_decl
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|||
operator|!
name|DECL_VIRTUAL_P
argument_list|(
name|x
argument_list|)
operator|)
condition|)
name|DECL_CONTEXT
argument_list|(
name|x
argument_list|)
operator|=
name|current_function_decl
expr_stmt|;
comment|/* A local declaration for a function doesn't constitute nesting.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|==
literal|0
condition|)
name|DECL_CONTEXT
argument_list|(
name|x
argument_list|)
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
comment|/* not yet, should get fixed properly later */
comment|/* For functions and class static data, we currently look up the encoded      form of the name.  For types, we want the real name.  The former will      probably be changed soon, according to MDT.  */
block|if (TREE_CODE (x) == FUNCTION_DECL || TREE_CODE (x) == VAR_DECL)     name = DECL_ASSEMBLER_NAME (x);   else     name = DECL_NAME (x);
else|#
directive|else
comment|/* Type are looked up using the DECL_NAME, as that is what the rest of the      compiler wants to use. */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|name
operator|=
name|DECL_NAME
argument_list|(
name|x
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|name
condition|)
block|{
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
name|t
operator|=
name|lookup_name_current_level
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|error_mark_node
condition|)
block|{
comment|/* error_mark_node is 0 for a while during initialization!  */
name|t
operator|=
name|NULL_TREE
expr_stmt|;
name|error_with_decl
argument_list|(
name|x
argument_list|,
literal|"`%s' used prior to declaration"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|!=
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|PARM_DECL
condition|)
block|{
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|fatal
argument_list|(
literal|"parse errors have confused me too much"
argument_list|)
expr_stmt|;
block|}
name|file
operator|=
name|DECL_SOURCE_FILE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|line
operator|=
name|DECL_SOURCE_LINE
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_DECL
operator|||
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
comment|/* We do nothing special here, because C++ does such nasty 		 things with TYPE_DECLs.  Instead, just let the TYPE_DECL 		 get shadowed, and know that if we need to find a TYPE_DECL 		 for a given name, we can look in the IDENTIFIER_TYPE_VALUE 		 slot of the identifier.  */
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|duplicate_decls
argument_list|(
name|x
argument_list|,
name|t
argument_list|)
condition|)
return|return
name|t
return|;
block|}
elseif|else
if|if
condition|(
name|t
operator|!=
name|NULL_TREE
operator|&&
name|duplicate_decls
argument_list|(
name|x
argument_list|,
name|t
argument_list|)
condition|)
block|{
comment|/* If this decl is `static' and an `extern' was seen previously, 	     that is erroneous.  But don't complain if -traditional, 	     since traditional compilers don't complain.  	     Note that this does not apply to the C++ case of declaring 	     a variable `extern const' and then later `const'.  */
if|if
condition|(
operator|!
name|flag_traditional
operator|&&
name|TREE_PUBLIC
argument_list|(
name|name
argument_list|)
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|DECL_INLINE
argument_list|(
name|x
argument_list|)
condition|)
block|{
comment|/* Due to interference in memory reclamation (X may be 		 obstack-deallocated at this point), we must guard against 		 one really special case.  */
if|if
condition|(
name|current_function_decl
operator|==
name|x
condition|)
name|current_function_decl
operator|=
name|t
expr_stmt|;
if|if
condition|(
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|name
argument_list|)
condition|)
name|warning
argument_list|(
literal|"`%s' was declared implicitly `extern' and later `static'"
argument_list|,
name|lang_printable_name
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"`%s' was declared `extern' and later `static'"
argument_list|,
name|lang_printable_name
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|warning_with_file_and_line
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"previous declaration of `%s'"
argument_list|,
name|lang_printable_name
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
comment|/* If declaring a type as a typedef, and the type has no known 	 typedef name, install this TYPE_DECL as its typedef name.  	 C++: If it had an anonymous aggregate or enum name, 	 give it a `better' one.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|tree
name|name
init|=
name|TYPE_NAME
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
block|{
comment|/* If these are different names, and we're at the global 		 binding level, make two equivalent definitions.  */
name|name
operator|=
name|x
expr_stmt|;
if|if
condition|(
name|global_bindings_p
argument_list|()
condition|)
name|TYPE_NAME
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|=
name|x
expr_stmt|;
block|}
else|else
block|{
name|tree
name|tname
init|=
name|DECL_NAME
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|global_bindings_p
argument_list|()
operator|&&
name|ANON_AGGRNAME_P
argument_list|(
name|tname
argument_list|)
condition|)
block|{
comment|/* do gratuitous C++ typedefing, and make sure that 		     we access this type either through TREE_TYPE field 		     or via the tags list.  */
name|TYPE_NAME
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|=
name|x
expr_stmt|;
name|pushtag
argument_list|(
name|tname
argument_list|,
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TYPE_DECL
argument_list|,
literal|140
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|name
argument_list|)
operator|&&
operator|!
name|DECL_NESTED_TYPENAME
argument_list|(
name|name
argument_list|)
condition|)
name|set_nested_typename
argument_list|(
name|x
argument_list|,
name|current_class_name
argument_list|,
name|DECL_NAME
argument_list|(
name|name
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|&&
name|TYPE_IDENTIFIER
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|set_identifier_type_value
argument_list|(
name|DECL_NAME
argument_list|(
name|x
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
comment|/* was using TYPE_IDENTIFIER (TREE_TYPE (x)) */
block|}
comment|/* Multiple external decls of the same identifier ought to match.  */
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|x
argument_list|)
operator|&&
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
operator|(
name|DECL_EXTERNAL
argument_list|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
argument_list|)
operator|||
name|TREE_PUBLIC
argument_list|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
argument_list|)
operator|)
comment|/* We get warnings about inline functions where they are defined. 	     Avoid duplicate warnings where they are used.  */
operator|&&
operator|!
name|DECL_INLINE
argument_list|(
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|warning_with_decl
argument_list|(
name|x
argument_list|,
literal|"type mismatch with previous external decl"
argument_list|)
expr_stmt|;
name|warning_with_decl
argument_list|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"previous external decl of `%s'"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* In PCC-compatibility mode, extern decls of vars with no current decl 	 take effect at top level no matter where they are.  */
if|if
condition|(
name|flag_traditional
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|x
argument_list|)
operator|&&
name|lookup_name
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|b
operator|=
name|global_binding_level
expr_stmt|;
comment|/* This name is new in its binding level. 	 Install the new declaration and return it.  */
if|if
condition|(
name|b
operator|==
name|global_binding_level
condition|)
block|{
comment|/* Install a global value.  */
comment|/* Rule for VAR_DECLs, but not for other kinds of _DECLs: 	     A `const' which was not declared `extern' is invisible.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_READONLY
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|DECL_THIS_EXTERN
argument_list|(
name|x
argument_list|)
condition|)
name|TREE_PUBLIC
argument_list|(
name|x
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* If the first global decl has external linkage, 	     warn if we later see static one.  */
if|if
condition|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|TREE_PUBLIC
argument_list|(
name|x
argument_list|)
condition|)
name|TREE_PUBLIC
argument_list|(
name|name
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Don't install a TYPE_DECL if we already have another 	     sort of _DECL with that name.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|TYPE_DECL
operator|||
name|t
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_DECL
condition|)
if|#
directive|if
literal|0
comment|/* This has not be thoroughly tested yet. */
comment|/* It allows better dwarf debugging. */
then|IDENTIFIER_GLOBAL_VALUE (name) 	      = TREE_CODE_CLASS (TREE_CODE (x)) == 'd' 		? x : build_decl (TYPE_DECL, NULL, TREE_TYPE (x));
else|#
directive|else
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
operator|=
name|x
expr_stmt|;
endif|#
directive|endif
comment|/* Don't forget if the function was used via an implicit decl.  */
if|if
condition|(
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|name
argument_list|)
operator|&&
name|TREE_USED
argument_list|(
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|name
argument_list|)
argument_list|)
condition|)
name|TREE_USED
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Don't forget if its address was taken in that way.  */
if|if
condition|(
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|name
argument_list|)
operator|&&
name|TREE_ADDRESSABLE
argument_list|(
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|name
argument_list|)
argument_list|)
condition|)
name|TREE_ADDRESSABLE
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Warn about mismatches against previous implicit decl.  */
if|if
condition|(
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|name
argument_list|)
operator|!=
name|NULL_TREE
comment|/* If this real decl matches the implicit, don't complain.  */
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|integer_type_node
operator|)
condition|)
name|warning
argument_list|(
literal|"`%s' was previously implicitly declared to return `int'"
argument_list|,
name|lang_printable_name
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this decl is `static' and an `extern' was seen previously, 	     that is erroneous.  Don't do this for TYPE_DECLs.  */
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|name
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|TYPE_DECL
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|name
argument_list|)
condition|)
name|warning
argument_list|(
literal|"`%s' was declared implicitly `extern' and later `static'"
argument_list|,
name|lang_printable_name
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"`%s' was declared `extern' and later `static'"
argument_list|,
name|lang_printable_name
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Here to install a non-global value.  */
name|tree
name|oldlocal
init|=
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|tree
name|oldglobal
init|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|set_identifier_local_value
argument_list|(
name|name
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* If this is an extern function declaration, see if we 	     have a global definition or declaration for the function.  */
if|if
condition|(
name|oldlocal
operator|==
name|NULL_TREE
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|DECL_INLINE
argument_list|(
name|x
argument_list|)
operator|&&
name|oldglobal
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|oldglobal
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
comment|/* We have one.  Their types must agree.  */
if|if
condition|(
operator|!
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|oldglobal
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
name|warning_with_decl
argument_list|(
name|x
argument_list|,
literal|"extern declaration of `%s' doesn't match global one"
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Inner extern decl is inline if global one is. 		     Copy enough to really inline it.  */
if|if
condition|(
name|DECL_INLINE
argument_list|(
name|oldglobal
argument_list|)
condition|)
block|{
name|DECL_INLINE
argument_list|(
name|x
argument_list|)
operator|=
name|DECL_INLINE
argument_list|(
name|oldglobal
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|=
operator|(
name|current_function_decl
operator|==
name|oldglobal
condition|?
name|NULL_TREE
else|:
name|DECL_INITIAL
argument_list|(
name|oldglobal
argument_list|)
operator|)
expr_stmt|;
name|DECL_SAVED_INSNS
argument_list|(
name|x
argument_list|)
operator|=
name|DECL_SAVED_INSNS
argument_list|(
name|oldglobal
argument_list|)
expr_stmt|;
name|DECL_ARGUMENTS
argument_list|(
name|x
argument_list|)
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|oldglobal
argument_list|)
expr_stmt|;
name|DECL_RESULT
argument_list|(
name|x
argument_list|)
operator|=
name|DECL_RESULT
argument_list|(
name|oldglobal
argument_list|)
expr_stmt|;
name|TREE_ASM_WRITTEN
argument_list|(
name|x
argument_list|)
operator|=
name|TREE_ASM_WRITTEN
argument_list|(
name|oldglobal
argument_list|)
expr_stmt|;
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|x
argument_list|)
operator|=
name|oldglobal
expr_stmt|;
block|}
comment|/* Inner extern decl is built-in if global one is.  */
if|if
condition|(
name|DECL_BUILT_IN
argument_list|(
name|oldglobal
argument_list|)
condition|)
block|{
name|DECL_BUILT_IN
argument_list|(
name|x
argument_list|)
operator|=
name|DECL_BUILT_IN
argument_list|(
name|oldglobal
argument_list|)
expr_stmt|;
name|DECL_SET_FUNCTION_CODE
argument_list|(
name|x
argument_list|,
name|DECL_FUNCTION_CODE
argument_list|(
name|oldglobal
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Keep the arg types from a file-scope fcn defn.  */
if|if
condition|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|oldglobal
argument_list|)
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|DECL_INITIAL
argument_list|(
name|oldglobal
argument_list|)
operator|&&
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|oldglobal
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If we have a local external declaration, 	     and no file-scope declaration has yet been seen, 	     then if we later have a file-scope decl it must not be static.  */
if|if
condition|(
name|oldlocal
operator|==
name|NULL_TREE
operator|&&
name|oldglobal
operator|==
name|NULL_TREE
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|x
argument_list|)
operator|&&
name|TREE_PUBLIC
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|TREE_PUBLIC
argument_list|(
name|name
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|DECL_FROM_INLINE
argument_list|(
name|x
argument_list|)
condition|)
comment|/* Inline decls shadow nothing.  */
empty_stmt|;
comment|/* Warn if shadowing an argument at the top level of the body.  */
elseif|else
if|if
condition|(
name|oldlocal
operator|!=
name|NULL_TREE
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|x
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|oldlocal
argument_list|)
operator|==
name|PARM_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|PARM_DECL
condition|)
block|{
comment|/* Go to where the parms should be and see if we 		 find them there.  */
name|struct
name|binding_level
modifier|*
name|b
init|=
name|current_binding_level
operator|->
name|level_chain
decl_stmt|;
if|if
condition|(
name|cleanup_label
condition|)
name|b
operator|=
name|b
operator|->
name|level_chain
expr_stmt|;
comment|/* ARM $8.3 */
if|if
condition|(
name|b
operator|->
name|parm_flag
operator|==
literal|1
condition|)
name|pedwarn
argument_list|(
literal|"declaration of `%s' shadows a parameter"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Maybe warn if shadowing something else.  */
elseif|else
if|if
condition|(
name|warn_shadow
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|x
argument_list|)
comment|/* No shadow warnings for internally generated vars.  */
operator|&&
name|DECL_SOURCE_LINE
argument_list|(
name|x
argument_list|)
operator|!=
literal|0
comment|/* No shadow warnings for vars made for inlining.  */
operator|&&
operator|!
name|DECL_FROM_INLINE
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|char
modifier|*
name|warnstring
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|oldlocal
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|oldlocal
argument_list|)
operator|==
name|PARM_DECL
condition|)
name|warnstring
operator|=
literal|"declaration of `%s' shadows a parameter"
expr_stmt|;
elseif|else
if|if
condition|(
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|name
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|warnstring
operator|=
literal|"declaration of `%s' shadows a member of `this'"
expr_stmt|;
elseif|else
if|if
condition|(
name|oldlocal
operator|!=
name|NULL_TREE
condition|)
name|warnstring
operator|=
literal|"declaration of `%s' shadows previous local"
expr_stmt|;
elseif|else
if|if
condition|(
name|oldglobal
operator|!=
name|NULL_TREE
condition|)
name|warnstring
operator|=
literal|"declaration of `%s' shadows global declaration"
expr_stmt|;
if|if
condition|(
name|warnstring
condition|)
name|warning
argument_list|(
name|warnstring
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If storing a local value, there may already be one (inherited). 	     If so, record it for restoration when this binding level ends.  */
if|if
condition|(
name|oldlocal
operator|!=
name|NULL_TREE
condition|)
name|b
operator|->
name|shadowed
operator|=
name|tree_cons
argument_list|(
name|name
argument_list|,
name|oldlocal
argument_list|,
name|b
operator|->
name|shadowed
argument_list|)
expr_stmt|;
block|}
comment|/* Keep count of variables in this level with incomplete type.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|TEMPLATE_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CPLUS_CATCH_DECL
operator|&&
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|PROMOTES_TO_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|,
name|ARRAY_TYPE
argument_list|)
condition|)
block|{
if|if
condition|(
operator|++
name|b
operator|->
name|n_incomplete
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"too many incomplete variables at this point"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|name
operator|!=
name|NULL_TREE
condition|)
block|{
name|adjust_type_value
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_class_name
condition|)
block|{
if|if
condition|(
operator|!
name|DECL_NESTED_TYPENAME
argument_list|(
name|x
argument_list|)
condition|)
name|set_nested_typename
argument_list|(
name|x
argument_list|,
name|current_class_name
argument_list|,
name|DECL_NAME
argument_list|(
name|x
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|adjust_type_value
argument_list|(
name|DECL_NESTED_TYPENAME
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Put decls on list in reverse order.      We will reverse them later if necessary.  */
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
operator|=
name|b
operator|->
name|names
expr_stmt|;
name|b
operator|->
name|names
operator|=
name|x
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|b
operator|!=
name|global_binding_level
operator|||
name|TREE_PERMANENT
argument_list|(
name|x
argument_list|)
operator|)
condition|)
name|my_friendly_abort
argument_list|(
literal|124
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Like pushdecl, only it places X in GLOBAL_BINDING_LEVEL,    if appropriate.  */
end_comment

begin_function
name|tree
name|pushdecl_top_level
parameter_list|(
name|x
parameter_list|)
name|tree
name|x
decl_stmt|;
block|{
specifier|register
name|tree
name|t
decl_stmt|;
specifier|register
name|struct
name|binding_level
modifier|*
name|b
init|=
name|current_binding_level
decl_stmt|;
name|current_binding_level
operator|=
name|global_binding_level
expr_stmt|;
name|t
operator|=
name|pushdecl
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|current_binding_level
operator|=
name|b
expr_stmt|;
if|if
condition|(
name|class_binding_level
condition|)
name|b
operator|=
name|class_binding_level
expr_stmt|;
comment|/* Now, the type_shadowed stack may screw us.  Munge it so it does      what we want.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|tree
name|name
init|=
name|DECL_NAME
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|tree
name|newval
decl_stmt|;
name|tree
modifier|*
name|ptr
init|=
operator|(
name|tree
operator|*
operator|)
literal|0
decl_stmt|;
for|for
control|(
init|;
name|b
operator|!=
name|global_binding_level
condition|;
name|b
operator|=
name|b
operator|->
name|level_chain
control|)
block|{
name|tree
name|shadowed
init|=
name|b
operator|->
name|type_shadowed
decl_stmt|;
for|for
control|(
init|;
name|shadowed
condition|;
name|shadowed
operator|=
name|TREE_CHAIN
argument_list|(
name|shadowed
argument_list|)
control|)
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|shadowed
argument_list|)
operator|==
name|name
condition|)
block|{
name|ptr
operator|=
operator|&
name|TREE_VALUE
argument_list|(
name|shadowed
argument_list|)
expr_stmt|;
comment|/* Can't break out of the loop here because sometimes 		   a binding level will have duplicate bindings for 		   PT names.  It's gross, but I haven't time to fix it.  */
block|}
block|}
name|newval
operator|=
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
operator|(
name|tree
operator|*
operator|)
literal|0
condition|)
block|{
comment|/* @@ This shouldn't be needed.  My test case "zstring.cc" trips              up here if this is changed to an assertion.  --KR  */
name|SET_IDENTIFIER_TYPE_VALUE
argument_list|(
name|name
argument_list|,
name|newval
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
literal|0
comment|/* Disabled this 11/10/92, since there are many cases which 	     behave just fine when *ptr doesn't satisfy either of these. 	     For example, nested classes declared as friends of their enclosing 	     class will not meet this criteria.  (bpk) */
block|my_friendly_assert (*ptr == NULL_TREE || *ptr == newval, 141);
endif|#
directive|endif
operator|*
name|ptr
operator|=
name|newval
expr_stmt|;
block|}
block|}
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Like push_overloaded_decl, only it places X in GLOBAL_BINDING_LEVEL,    if appropriate.  */
end_comment

begin_function
name|void
name|push_overloaded_decl_top_level
parameter_list|(
name|x
parameter_list|,
name|forget
parameter_list|)
name|tree
name|x
decl_stmt|;
name|int
name|forget
decl_stmt|;
block|{
name|struct
name|binding_level
modifier|*
name|b
init|=
name|current_binding_level
decl_stmt|;
name|current_binding_level
operator|=
name|global_binding_level
expr_stmt|;
name|push_overloaded_decl
argument_list|(
name|x
argument_list|,
name|forget
argument_list|)
expr_stmt|;
name|current_binding_level
operator|=
name|b
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make the declaration of X appear in CLASS scope.  */
end_comment

begin_function
name|tree
name|pushdecl_class_level
parameter_list|(
name|x
parameter_list|)
name|tree
name|x
decl_stmt|;
block|{
comment|/* Don't use DECL_ASSEMBLER_NAME here!  Everything that looks in class      scope looks for the pre-mangled name.  */
specifier|register
name|tree
name|name
init|=
name|DECL_NAME
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|name
condition|)
block|{
name|tree
name|oldclass
init|=
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldclass
condition|)
name|class_binding_level
operator|->
name|class_shadowed
operator|=
name|tree_cons
argument_list|(
name|name
argument_list|,
name|oldclass
argument_list|,
name|class_binding_level
operator|->
name|class_shadowed
argument_list|)
expr_stmt|;
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|name
argument_list|)
operator|=
name|x
expr_stmt|;
name|obstack_ptr_grow
argument_list|(
operator|&
name|decl_obstack
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
operator|!
name|DECL_NESTED_TYPENAME
argument_list|(
name|x
argument_list|)
condition|)
name|set_nested_typename
argument_list|(
name|x
argument_list|,
name|current_class_name
argument_list|,
name|name
argument_list|,
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Tell caller how to interpret a TREE_LIST which contains    chains of FUNCTION_DECLS.  */
end_comment

begin_function
name|int
name|overloaded_globals_p
parameter_list|(
name|list
parameter_list|)
name|tree
name|list
decl_stmt|;
block|{
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|list
argument_list|)
operator|==
name|TREE_LIST
argument_list|,
literal|142
argument_list|)
expr_stmt|;
comment|/* Don't commit caller to seeing them as globals.  */
if|if
condition|(
name|TREE_NONLOCAL_FLAG
argument_list|(
name|list
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Do commit caller to seeing them as globals.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|list
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
return|return
literal|1
return|;
comment|/* Do commit caller to not seeing them as globals.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* DECL is a FUNCTION_DECL which may have other definitions already in place.    We get around this by making IDENTIFIER_GLOBAL_VALUE (DECL_NAME (DECL))    point to a list of all the things that want to be referenced by that name.    It is then up to the users of that name to decide what to do with that    list.     DECL may also be a TEMPLATE_DECL, with a FUNCTION_DECL in its DECL_RESULT    slot.  It is dealt with the same way.     The value returned may be a previous declaration if we guessed wrong    about what language DECL should belong to (C or C++).  Otherwise,    it's always DECL (and never something that's not a _DECL).  */
end_comment

begin_function
name|tree
name|push_overloaded_decl
parameter_list|(
name|decl
parameter_list|,
name|forgettable
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|int
name|forgettable
decl_stmt|;
block|{
name|tree
name|orig_name
init|=
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|tree
name|glob
init|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|orig_name
argument_list|)
decl_stmt|;
name|DECL_OVERLOADED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|glob
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|glob
argument_list|)
operator|!=
name|TREE_LIST
condition|)
block|{
if|if
condition|(
name|DECL_LANGUAGE
argument_list|(
name|decl
argument_list|)
operator|==
name|lang_c
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|glob
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
if|if
condition|(
name|DECL_LANGUAGE
argument_list|(
name|glob
argument_list|)
operator|==
name|lang_c
condition|)
block|{
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"C-language function `%s' overloaded here"
argument_list|)
expr_stmt|;
name|error_with_decl
argument_list|(
name|glob
argument_list|,
literal|"Previous C-language version of this function was `%s'"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|my_friendly_abort
argument_list|(
literal|9
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|forgettable
operator|&&
operator|!
name|flag_traditional
operator|&&
name|TREE_PERMANENT
argument_list|(
name|glob
argument_list|)
operator|==
literal|1
operator|&&
operator|!
name|global_bindings_p
argument_list|()
condition|)
name|overloads_to_forget
operator|=
name|tree_cons
argument_list|(
name|orig_name
argument_list|,
name|glob
argument_list|,
name|overloads_to_forget
argument_list|)
expr_stmt|;
comment|/* We cache the value of builtin functions as ADDR_EXPRs 	     in the name space.  Convert it to some kind of _DECL after 	     remembering what to forget.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|glob
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
name|glob
operator|=
name|TREE_OPERAND
argument_list|(
name|glob
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|glob
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_LANGUAGE
argument_list|(
name|glob
argument_list|)
operator|!=
name|DECL_LANGUAGE
argument_list|(
name|decl
argument_list|)
operator|&&
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|glob
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|current_lang_stack
operator|==
name|current_lang_base
condition|)
block|{
name|DECL_LANGUAGE
argument_list|(
name|decl
argument_list|)
operator|=
name|DECL_LANGUAGE
argument_list|(
name|glob
argument_list|)
expr_stmt|;
return|return
name|glob
return|;
block|}
else|else
block|{
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"conflicting language contexts for declaration of `%s';"
argument_list|)
expr_stmt|;
name|error_with_decl
argument_list|(
name|glob
argument_list|,
literal|"conflicts with previous declaration here"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pedantic
operator|&&
name|TREE_CODE
argument_list|(
name|glob
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|glob
argument_list|)
argument_list|)
operator|==
literal|'d'
argument_list|,
literal|143
argument_list|)
expr_stmt|;
name|error_with_decl
argument_list|(
name|glob
argument_list|,
literal|"non-function declaration `%s'"
argument_list|)
expr_stmt|;
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"conflicts with function declaration `%s'"
argument_list|)
expr_stmt|;
block|}
name|glob
operator|=
name|tree_cons
argument_list|(
name|orig_name
argument_list|,
name|glob
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|glob
operator|=
name|tree_cons
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|glob
argument_list|)
argument_list|,
name|decl
argument_list|,
name|glob
argument_list|)
expr_stmt|;
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|orig_name
argument_list|)
operator|=
name|glob
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|glob
argument_list|)
operator|=
name|unknown_type_node
expr_stmt|;
return|return
name|decl
return|;
block|}
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|glob
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|TREE_VALUE
argument_list|(
name|glob
argument_list|)
operator|=
name|decl
expr_stmt|;
return|return
name|decl
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|TEMPLATE_DECL
condition|)
block|{
name|tree
name|name
init|=
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|tree
name|tmp
decl_stmt|;
for|for
control|(
name|tmp
operator|=
name|glob
init|;
name|tmp
condition|;
name|tmp
operator|=
name|TREE_CHAIN
argument_list|(
name|tmp
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tmp
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_LANGUAGE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tmp
argument_list|)
argument_list|)
operator|!=
name|DECL_LANGUAGE
argument_list|(
name|decl
argument_list|)
operator|&&
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tmp
argument_list|)
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"conflicting language contexts for declaration of `%s';"
argument_list|)
expr_stmt|;
name|error_with_decl
argument_list|(
name|TREE_VALUE
argument_list|(
name|tmp
argument_list|)
argument_list|,
literal|"conflicts with previous declaration here"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tmp
argument_list|)
argument_list|)
operator|!=
name|TEMPLATE_DECL
operator|&&
name|DECL_ASSEMBLER_NAME
argument_list|(
name|TREE_VALUE
argument_list|(
name|tmp
argument_list|)
argument_list|)
operator|==
name|name
condition|)
return|return
name|decl
return|;
block|}
block|}
block|}
if|if
condition|(
name|DECL_LANGUAGE
argument_list|(
name|decl
argument_list|)
operator|==
name|lang_c
condition|)
block|{
name|tree
name|decls
init|=
name|glob
decl_stmt|;
while|while
condition|(
name|decls
operator|&&
name|DECL_LANGUAGE
argument_list|(
name|TREE_VALUE
argument_list|(
name|decls
argument_list|)
argument_list|)
operator|==
name|lang_cplusplus
condition|)
name|decls
operator|=
name|TREE_CHAIN
argument_list|(
name|decls
argument_list|)
expr_stmt|;
if|if
condition|(
name|decls
condition|)
block|{
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"C-language function `%s' overloaded here"
argument_list|)
expr_stmt|;
name|error_with_decl
argument_list|(
name|TREE_VALUE
argument_list|(
name|decls
argument_list|)
argument_list|,
literal|"Previous C-language version of this function was `%s'"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|forgettable
operator|&&
operator|!
name|flag_traditional
operator|&&
operator|(
name|glob
operator|==
name|NULL_TREE
operator|||
name|TREE_PERMANENT
argument_list|(
name|glob
argument_list|)
operator|==
literal|1
operator|)
operator|&&
operator|!
name|global_bindings_p
argument_list|()
operator|&&
operator|!
name|pseudo_global_level_p
argument_list|()
condition|)
name|overloads_to_forget
operator|=
name|tree_cons
argument_list|(
name|orig_name
argument_list|,
name|glob
argument_list|,
name|overloads_to_forget
argument_list|)
expr_stmt|;
name|glob
operator|=
name|tree_cons
argument_list|(
name|orig_name
argument_list|,
name|decl
argument_list|,
name|glob
argument_list|)
expr_stmt|;
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|orig_name
argument_list|)
operator|=
name|glob
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|glob
argument_list|)
operator|=
name|unknown_type_node
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate an implicit declaration for identifier FUNCTIONID    as a function of type int ().  Print a warning if appropriate.  */
end_comment

begin_function
name|tree
name|implicitly_declare
parameter_list|(
name|functionid
parameter_list|)
name|tree
name|functionid
decl_stmt|;
block|{
specifier|register
name|tree
name|decl
decl_stmt|;
name|int
name|temp
init|=
name|allocation_temporary_p
argument_list|()
decl_stmt|;
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
comment|/* Save the decl permanently so we can warn if definition follows.      In ANSI C, warn_implicit is usually false, so the saves little space.      But in C++, it's usually true, hence the extra code.  */
if|if
condition|(
name|temp
operator|&&
operator|(
name|flag_traditional
operator|||
operator|!
name|warn_implicit
operator|||
name|current_binding_level
operator|==
name|global_binding_level
operator|)
condition|)
name|end_temporary_allocation
argument_list|()
expr_stmt|;
comment|/* We used to reuse an old implicit decl here,      but this loses with inline functions because it can clobber      the saved decl chains.  */
name|decl
operator|=
name|build_lang_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|functionid
argument_list|,
name|default_function_type
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* ANSI standard says implicit declarations are in the innermost block.      So we record the decl in the standard fashion.      If flag_traditional is set, pushdecl does it top-level.  */
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|rest_of_decl_compilation
argument_list|(
name|decl
argument_list|,
name|NULL_PTR
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|warn_implicit
comment|/* Only one warning per identifier.  */
operator|&&
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|functionid
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|pedwarn
argument_list|(
literal|"implicit declaration of function `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|functionid
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SET_IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|functionid
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Return zero if the declaration NEWDECL is valid    when the declaration OLDDECL (assumed to be for the same name)    has already been seen.    Otherwise return an error message format string with a %s    where the identifier should go.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|redeclaration_error_message
parameter_list|(
name|newdecl
parameter_list|,
name|olddecl
parameter_list|)
name|tree
name|newdecl
decl_stmt|,
name|olddecl
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
comment|/* Because C++ can put things into name space for free, 	 constructs like "typedef struct foo { ... } foo" 	 would look like an erroneous redeclaration.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
return|return
literal|"redefinition of `%s'"
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
comment|/* If this is a pure function, its olddecl will actually be 	 the original initialization to `0' (which we force to call 	 abort()).  Don't complain about redefinition in this case.  */
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|DECL_ABSTRACT_VIRTUAL_P
argument_list|(
name|olddecl
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Declarations of functions can insist on internal linkage 	 but they can't be inconsistent with internal linkage, 	 so there can be no error on that account. 	 However defining the same name twice is no good.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|NULL_TREE
comment|/* However, defining once as extern inline and a second 	     time in another way is ok.  */
operator|&&
operator|!
operator|(
name|DECL_INLINE
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|!
operator|(
name|DECL_INLINE
argument_list|(
name|newdecl
argument_list|)
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|newdecl
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|olddecl
argument_list|)
operator|==
name|NULL_TREE
condition|)
return|return
literal|"`%s' not declared in class"
return|;
else|else
return|return
literal|"redefinition of `%s'"
return|;
block|}
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
condition|)
block|{
comment|/* Objects declared at top level:  */
comment|/* If at least one is a reference, it's ok.  */
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|newdecl
argument_list|)
operator|||
name|DECL_EXTERNAL
argument_list|(
name|olddecl
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Reject two definitions.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|NULL_TREE
condition|)
return|return
literal|"redefinition of `%s'"
return|;
comment|/* Now we have two tentative defs, or one tentative and one real def.  */
comment|/* Insist that the linkage match.  */
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|olddecl
argument_list|)
operator|!=
name|TREE_PUBLIC
argument_list|(
name|newdecl
argument_list|)
condition|)
return|return
literal|"conflicting declarations of `%s'"
return|;
return|return
literal|0
return|;
block|}
else|else
block|{
comment|/* Objects declared with block scope:  */
comment|/* Reject two definitions, and reject a definition 	 together with an external reference.  */
if|if
condition|(
operator|!
operator|(
name|DECL_EXTERNAL
argument_list|(
name|newdecl
argument_list|)
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|olddecl
argument_list|)
operator|)
condition|)
return|return
literal|"redeclaration of `%s'"
return|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Get the LABEL_DECL corresponding to identifier ID as a label.    Create one if none exists so far for the current function.    This function is called for both label definitions and label references.  */
end_comment

begin_function
name|tree
name|lookup_label
parameter_list|(
name|id
parameter_list|)
name|tree
name|id
decl_stmt|;
block|{
specifier|register
name|tree
name|decl
init|=
name|IDENTIFIER_LABEL_VALUE
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|decl
operator|==
name|NULL_TREE
operator|||
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|named_label_uses
operator|==
literal|0
operator|||
name|TREE_PURPOSE
argument_list|(
name|named_label_uses
argument_list|)
operator|!=
name|current_binding_level
operator|->
name|names
operator|||
name|TREE_VALUE
argument_list|(
name|named_label_uses
argument_list|)
operator|!=
name|decl
operator|)
condition|)
block|{
name|named_label_uses
operator|=
name|tree_cons
argument_list|(
name|current_binding_level
operator|->
name|names
argument_list|,
name|decl
argument_list|,
name|named_label_uses
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|named_label_uses
argument_list|)
operator|=
operator|(
name|tree
operator|)
name|current_binding_level
expr_stmt|;
block|}
comment|/* Use a label already defined or ref'd with this name.  */
if|if
condition|(
name|decl
operator|!=
name|NULL_TREE
condition|)
block|{
comment|/* But not if it is inherited and wasn't declared to be inheritable.  */
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|!=
name|current_function_decl
operator|&&
operator|!
name|C_DECLARED_LABEL_FLAG
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|shadow_label
argument_list|(
name|id
argument_list|)
return|;
return|return
name|decl
return|;
block|}
name|decl
operator|=
name|build_decl
argument_list|(
name|LABEL_DECL
argument_list|,
name|id
argument_list|,
name|void_type_node
argument_list|)
expr_stmt|;
comment|/* A label not explicitly declared must be local to where it's ref'd.  */
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|current_function_decl
expr_stmt|;
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
operator|=
name|VOIDmode
expr_stmt|;
comment|/* Say where one reference is to the label,      for the sake of the error if it is not defined.  */
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
operator|=
name|lineno
expr_stmt|;
name|DECL_SOURCE_FILE
argument_list|(
name|decl
argument_list|)
operator|=
name|input_filename
expr_stmt|;
name|SET_IDENTIFIER_LABEL_VALUE
argument_list|(
name|id
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|named_labels
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|decl
argument_list|,
name|named_labels
argument_list|)
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|named_label_uses
argument_list|)
operator|=
name|decl
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Make a label named NAME in the current function,    shadowing silently any that may be inherited from containing functions    or containing scopes.     Note that valid use, if the label being shadowed    comes from another scope in the same function,    requires calling declare_nonlocal_label right away.  */
end_comment

begin_function
name|tree
name|shadow_label
parameter_list|(
name|name
parameter_list|)
name|tree
name|name
decl_stmt|;
block|{
specifier|register
name|tree
name|decl
init|=
name|IDENTIFIER_LABEL_VALUE
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|decl
operator|!=
name|NULL_TREE
condition|)
block|{
name|shadowed_labels
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|decl
argument_list|,
name|shadowed_labels
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_LABEL_VALUE
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_LABEL_VALUE
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|lookup_label
argument_list|(
name|name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Define a label, specifying the location in the source file.    Return the LABEL_DECL node for the label, if the definition is valid.    Otherwise return 0.  */
end_comment

begin_function
name|tree
name|define_label
parameter_list|(
name|filename
parameter_list|,
name|line
parameter_list|,
name|name
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|line
decl_stmt|;
name|tree
name|name
decl_stmt|;
block|{
name|tree
name|decl
init|=
name|lookup_label
argument_list|(
name|name
argument_list|)
decl_stmt|;
comment|/* After labels, make any new cleanups go into their      own new (temporary) binding contour.  */
name|current_binding_level
operator|->
name|more_cleanups_ok
operator|=
literal|0
expr_stmt|;
comment|/* If label with this name is known from an outer context, shadow it.  */
if|if
condition|(
name|decl
operator|!=
name|NULL_TREE
operator|&&
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|!=
name|current_function_decl
condition|)
block|{
name|shadowed_labels
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|decl
argument_list|,
name|shadowed_labels
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_LABEL_VALUE
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|decl
operator|=
name|lookup_label
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"duplicate label `%s'"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|tree
name|uses
decl_stmt|,
name|prev
decl_stmt|;
comment|/* Mark label as having been defined.  */
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
comment|/* Say where in the source.  */
name|DECL_SOURCE_FILE
argument_list|(
name|decl
argument_list|)
operator|=
name|filename
expr_stmt|;
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
operator|=
name|line
expr_stmt|;
for|for
control|(
name|prev
operator|=
name|NULL_TREE
operator|,
name|uses
operator|=
name|named_label_uses
init|;
name|uses
condition|;
name|prev
operator|=
name|uses
operator|,
name|uses
operator|=
name|TREE_CHAIN
argument_list|(
name|uses
argument_list|)
control|)
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|uses
argument_list|)
operator|==
name|decl
condition|)
block|{
name|struct
name|binding_level
modifier|*
name|b
init|=
name|current_binding_level
decl_stmt|;
while|while
condition|(
name|b
condition|)
block|{
name|tree
name|new_decls
init|=
name|b
operator|->
name|names
decl_stmt|;
name|tree
name|old_decls
init|=
operator|(
operator|(
name|tree
operator|)
name|b
operator|==
name|TREE_TYPE
argument_list|(
name|uses
argument_list|)
condition|?
name|TREE_PURPOSE
argument_list|(
name|uses
argument_list|)
else|:
name|NULL_TREE
operator|)
decl_stmt|;
while|while
condition|(
name|new_decls
operator|!=
name|old_decls
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|new_decls
argument_list|)
operator|==
name|VAR_DECL
comment|/* Don't complain about crossing initialization 			   of internal entities.  They can't be accessed, 			   and they should be cleaned up 			   by the time we get to the label.  */
operator|&&
name|DECL_SOURCE_LINE
argument_list|(
name|new_decls
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|DECL_INITIAL
argument_list|(
name|new_decls
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|DECL_INITIAL
argument_list|(
name|new_decls
argument_list|)
operator|!=
name|error_mark_node
operator|)
operator|||
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|TREE_TYPE
argument_list|(
name|new_decls
argument_list|)
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|IDENTIFIER_ERROR_LOCUS
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"invalid jump to label `%s'"
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_ERROR_LOCUS
argument_list|(
name|decl
argument_list|,
name|current_function_decl
argument_list|)
expr_stmt|;
name|error_with_decl
argument_list|(
name|new_decls
argument_list|,
literal|"crosses initialization of `%s'"
argument_list|)
expr_stmt|;
block|}
name|new_decls
operator|=
name|TREE_CHAIN
argument_list|(
name|new_decls
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|tree
operator|)
name|b
operator|==
name|TREE_TYPE
argument_list|(
name|uses
argument_list|)
condition|)
break|break;
name|b
operator|=
name|b
operator|->
name|level_chain
expr_stmt|;
block|}
if|if
condition|(
name|prev
condition|)
name|TREE_CHAIN
argument_list|(
name|prev
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|uses
argument_list|)
expr_stmt|;
else|else
name|named_label_uses
operator|=
name|TREE_CHAIN
argument_list|(
name|uses
argument_list|)
expr_stmt|;
block|}
name|current_function_return_value
operator|=
name|NULL_TREE
expr_stmt|;
return|return
name|decl
return|;
block|}
block|}
end_function

begin_comment
comment|/* Same, but for CASE labels.  If DECL is NULL_TREE, it's the default.  */
end_comment

begin_comment
comment|/* XXX Note decl is never actually used. (bpk) */
end_comment

begin_function
name|void
name|define_case_label
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|tree
name|cleanup
init|=
name|last_cleanup_this_contour
argument_list|()
decl_stmt|;
if|if
condition|(
name|cleanup
condition|)
block|{
specifier|static
name|int
name|explained
init|=
literal|0
decl_stmt|;
name|error_with_decl
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|cleanup
argument_list|)
argument_list|,
literal|"destructor needed for `%s'"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"where case label appears here"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|explained
condition|)
block|{
name|error
argument_list|(
literal|"(enclose actions of previous case statements requiring"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"destructors in their own binding contours.)"
argument_list|)
expr_stmt|;
name|explained
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* After labels, make any new cleanups go into their      own new (temporary) binding contour.  */
name|current_binding_level
operator|->
name|more_cleanups_ok
operator|=
literal|0
expr_stmt|;
name|current_function_return_value
operator|=
name|NULL_TREE
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the list of declarations of the current level.    Note that this list is in reverse order unless/until    you nreverse it; and when you do nreverse it, you must    store the result back using `storedecls' or you will lose.  */
end_comment

begin_function
name|tree
name|getdecls
parameter_list|()
block|{
return|return
name|current_binding_level
operator|->
name|names
return|;
block|}
end_function

begin_comment
comment|/* Return the list of type-tags (for structs, etc) of the current level.  */
end_comment

begin_function
name|tree
name|gettags
parameter_list|()
block|{
return|return
name|current_binding_level
operator|->
name|tags
return|;
block|}
end_function

begin_comment
comment|/* Store the list of declarations of the current level.    This is done for the parameter declarations of a function being defined,    after they are modified in the light of any missing parameters.  */
end_comment

begin_function
specifier|static
name|void
name|storedecls
parameter_list|(
name|decls
parameter_list|)
name|tree
name|decls
decl_stmt|;
block|{
name|current_binding_level
operator|->
name|names
operator|=
name|decls
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Similarly, store the list of tags of the current level.  */
end_comment

begin_function
specifier|static
name|void
name|storetags
parameter_list|(
name|tags
parameter_list|)
name|tree
name|tags
decl_stmt|;
block|{
name|current_binding_level
operator|->
name|tags
operator|=
name|tags
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given NAME, an IDENTIFIER_NODE,    return the structure (or union or enum) definition for that name.    Searches binding levels from BINDING_LEVEL up to the global level.    If THISLEVEL_ONLY is nonzero, searches only the specified context    (but skips any tag-transparent contexts to find one that is    meaningful for tags).    FORM says which kind of type the caller wants;    it is RECORD_TYPE or UNION_TYPE or ENUMERAL_TYPE.    If the wrong kind of type is found, and it's not a template, an error is    reported.  */
end_comment

begin_function
specifier|static
name|tree
name|lookup_tag
parameter_list|(
name|form
parameter_list|,
name|name
parameter_list|,
name|binding_level
parameter_list|,
name|thislevel_only
parameter_list|)
name|enum
name|tree_code
name|form
decl_stmt|;
name|struct
name|binding_level
modifier|*
name|binding_level
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|int
name|thislevel_only
decl_stmt|;
block|{
specifier|register
name|struct
name|binding_level
modifier|*
name|level
decl_stmt|;
for|for
control|(
name|level
operator|=
name|binding_level
init|;
name|level
condition|;
name|level
operator|=
name|level
operator|->
name|level_chain
control|)
block|{
specifier|register
name|tree
name|tail
decl_stmt|;
if|if
condition|(
name|ANON_AGGRNAME_P
argument_list|(
name|name
argument_list|)
condition|)
for|for
control|(
name|tail
operator|=
name|level
operator|->
name|tags
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
control|)
block|{
comment|/* There's no need for error checking here, because 	       anon names are unique throughout the compilation.  */
if|if
condition|(
name|TYPE_IDENTIFIER
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
operator|==
name|name
condition|)
return|return
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
return|;
block|}
else|else
for|for
control|(
name|tail
operator|=
name|level
operator|->
name|tags
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
operator|==
name|name
condition|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Should tighten this up; it'll probably permit 		   UNION_TYPE and a struct template, for example.  */
if|if
condition|(
name|code
operator|!=
name|form
operator|&&
operator|!
operator|(
name|form
operator|!=
name|ENUMERAL_TYPE
operator|&&
operator|(
name|code
operator|==
name|TEMPLATE_DECL
operator|||
name|code
operator|==
name|UNINSTANTIATED_P_TYPE
operator|)
operator|)
condition|)
block|{
comment|/* Definition isn't the kind we were looking for.  */
name|error
argument_list|(
literal|"`%s' defined as wrong kind of tag"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|thislevel_only
operator|&&
operator|!
name|level
operator|->
name|tag_transparent
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|current_class_type
operator|&&
name|level
operator|->
name|level_chain
operator|==
name|global_binding_level
condition|)
block|{
comment|/* Try looking in this class's tags before heading into 	     global binding level.  */
name|tree
name|context
init|=
name|current_class_type
decl_stmt|;
while|while
condition|(
name|context
condition|)
block|{
switch|switch
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|context
argument_list|)
argument_list|)
condition|)
block|{
case|case
literal|'t'
case|:
block|{
name|tree
name|these_tags
init|=
name|CLASSTYPE_TAGS
argument_list|(
name|context
argument_list|)
decl_stmt|;
if|if
condition|(
name|ANON_AGGRNAME_P
argument_list|(
name|name
argument_list|)
condition|)
while|while
condition|(
name|these_tags
condition|)
block|{
if|if
condition|(
name|TYPE_IDENTIFIER
argument_list|(
name|TREE_VALUE
argument_list|(
name|these_tags
argument_list|)
argument_list|)
operator|==
name|name
condition|)
return|return
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
return|;
name|these_tags
operator|=
name|TREE_CHAIN
argument_list|(
name|these_tags
argument_list|)
expr_stmt|;
block|}
else|else
while|while
condition|(
name|these_tags
condition|)
block|{
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|these_tags
argument_list|)
operator|==
name|name
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|these_tags
argument_list|)
argument_list|)
operator|!=
name|form
condition|)
block|{
name|error
argument_list|(
literal|"`%s' defined as wrong kind of tag in class scope"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
return|;
block|}
name|these_tags
operator|=
name|TREE_CHAIN
argument_list|(
name|these_tags
argument_list|)
expr_stmt|;
block|}
comment|/* If this type is not yet complete, then don't 		       look at its context.  */
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|context
argument_list|)
operator|==
name|NULL_TREE
condition|)
goto|goto
name|no_context
goto|;
comment|/* Go to next enclosing type, if any.  */
name|context
operator|=
name|DECL_CONTEXT
argument_list|(
name|TYPE_NAME
argument_list|(
name|context
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|context
operator|=
name|DECL_CONTEXT
argument_list|(
name|context
argument_list|)
expr_stmt|;
break|break;
default|default:
name|my_friendly_abort
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
name|no_context
label|:
break|break;
block|}
block|}
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_function
name|void
name|set_current_level_tags_transparency
parameter_list|(
name|tags_transparent
parameter_list|)
name|int
name|tags_transparent
decl_stmt|;
block|{
name|current_binding_level
operator|->
name|tag_transparent
operator|=
name|tags_transparent
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a type, find the tag that was defined for it and return the tag name.    Otherwise return 0.  However, the value can never be 0    in the cases in which this is used.     C++: If NAME is non-zero, this is the new name to install.  This is    done when replacing anonymous tags with real tag names.  */
end_comment

begin_function
specifier|static
name|tree
name|lookup_tag_reverse
parameter_list|(
name|type
parameter_list|,
name|name
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|name
decl_stmt|;
block|{
specifier|register
name|struct
name|binding_level
modifier|*
name|level
decl_stmt|;
for|for
control|(
name|level
operator|=
name|current_binding_level
init|;
name|level
condition|;
name|level
operator|=
name|level
operator|->
name|level_chain
control|)
block|{
specifier|register
name|tree
name|tail
decl_stmt|;
for|for
control|(
name|tail
operator|=
name|level
operator|->
name|tags
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
operator|==
name|type
condition|)
block|{
if|if
condition|(
name|name
condition|)
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
operator|=
name|name
expr_stmt|;
return|return
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
return|;
block|}
block|}
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Given type TYPE which was not declared in C++ language context,    attempt to find a name by which it is referred.  */
end_comment

begin_function
name|tree
name|typedecl_for_tag
parameter_list|(
name|tag
parameter_list|)
name|tree
name|tag
decl_stmt|;
block|{
name|struct
name|binding_level
modifier|*
name|b
init|=
name|current_binding_level
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|tag
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
condition|)
return|return
name|TYPE_NAME
argument_list|(
name|tag
argument_list|)
return|;
while|while
condition|(
name|b
condition|)
block|{
name|tree
name|decls
init|=
name|b
operator|->
name|names
decl_stmt|;
while|while
condition|(
name|decls
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decls
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|TREE_TYPE
argument_list|(
name|decls
argument_list|)
operator|==
name|tag
condition|)
break|break;
name|decls
operator|=
name|TREE_CHAIN
argument_list|(
name|decls
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|decls
condition|)
return|return
name|decls
return|;
name|b
operator|=
name|b
operator|->
name|level_chain
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Called when we must retroactively globalize a type we previously    thought needed to be nested.  This happens, for example, when    a `friend class' declaration is seen for an undefined type.  */
end_comment

begin_function
specifier|static
name|void
name|globalize_nested_type
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|,
name|prev
init|=
name|NULL_TREE
decl_stmt|,
name|d
init|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|struct
name|binding_level
modifier|*
name|b
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|d
argument_list|)
operator|==
name|TYPE_DECL
argument_list|,
literal|144
argument_list|)
expr_stmt|;
comment|/* If the type value has already been globalized, then we're set.  */
if|if
condition|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|d
argument_list|)
argument_list|)
operator|==
name|d
condition|)
return|return;
if|if
condition|(
name|IDENTIFIER_HAS_TYPE_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|d
argument_list|)
argument_list|)
condition|)
block|{
comment|/* If this type already made it into the global tags, 	 silently return.  */
if|if
condition|(
name|value_member
argument_list|(
name|type
argument_list|,
name|global_binding_level
operator|->
name|tags
argument_list|)
condition|)
return|return;
block|}
name|set_identifier_type_value
argument_list|(
name|DECL_NESTED_TYPENAME
argument_list|(
name|d
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|DECL_NESTED_TYPENAME
argument_list|(
name|d
argument_list|)
operator|=
name|DECL_NAME
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|d
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|class_binding_level
condition|)
name|b
operator|=
name|class_binding_level
expr_stmt|;
else|else
name|b
operator|=
name|current_binding_level
expr_stmt|;
while|while
condition|(
name|b
operator|!=
name|global_binding_level
condition|)
block|{
name|prev
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|parm_flag
operator|==
literal|2
condition|)
for|for
control|(
name|t
operator|=
name|b
operator|->
name|tags
init|;
name|t
operator|!=
name|NULL_TREE
condition|;
name|prev
operator|=
name|t
operator|,
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
operator|==
name|type
condition|)
goto|goto
name|found
goto|;
name|b
operator|=
name|b
operator|->
name|level_chain
expr_stmt|;
block|}
comment|/* We failed to find this tag anywhere up the binding chains.      B is now the global binding level... check there.  */
name|prev
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|parm_flag
operator|==
literal|2
condition|)
for|for
control|(
name|t
operator|=
name|b
operator|->
name|tags
init|;
name|t
operator|!=
name|NULL_TREE
condition|;
name|prev
operator|=
name|t
operator|,
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
operator|==
name|type
condition|)
goto|goto
name|foundglobal
goto|;
comment|/* It wasn't in global scope either, so this is an anonymous forward ref      of some kind; let it happen.  */
return|return;
name|foundglobal
label|:
name|print_node_brief
argument_list|(
name|stderr
argument_list|,
literal|"Tried to globalize already-global type "
argument_list|,
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|my_friendly_abort
argument_list|(
literal|11
argument_list|)
expr_stmt|;
name|found
label|:
comment|/* Pull the tag out of the nested binding contour.  */
if|if
condition|(
name|prev
condition|)
name|TREE_CHAIN
argument_list|(
name|prev
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
else|else
name|b
operator|->
name|tags
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|set_identifier_type_value
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|global_binding_level
operator|->
name|tags
operator|=
name|perm_tree_cons
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
name|global_binding_level
operator|->
name|tags
argument_list|)
expr_stmt|;
comment|/* Pull the tag out of the class's tags (if there).      It won't show up if it appears e.g. in a parameter declaration      or definition of a member function of this type.  */
if|if
condition|(
name|current_class_type
operator|!=
name|NULL_TREE
condition|)
block|{
for|for
control|(
name|t
operator|=
name|CLASSTYPE_TAGS
argument_list|(
name|current_class_type
argument_list|)
operator|,
name|prev
operator|=
name|NULL_TREE
init|;
name|t
operator|!=
name|NULL_TREE
condition|;
name|prev
operator|=
name|t
operator|,
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
operator|==
name|type
condition|)
break|break;
if|if
condition|(
name|t
operator|!=
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|prev
condition|)
name|TREE_CHAIN
argument_list|(
name|prev
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
else|else
name|CLASSTYPE_TAGS
argument_list|(
name|current_class_type
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
name|pushdecl_top_level
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|maybe_globalize_type
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
operator|(
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
operator|)
operator|&&
operator|!
name|TYPE_BEING_DEFINED
argument_list|(
name|type
argument_list|)
operator|)
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|)
operator|&&
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|==
name|NULL_TREE
comment|/* This part is gross.  We keep calling here with types that 	 are instantiations of templates, when that type should is 	 global, or doesn't have the type decl established yet, 	 so globalizing will fail (because it won't find the type in any 	 non-global scope).  So we short-circuit that path.  */
operator|&&
operator|!
operator|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|TYPE_IDENTIFIER
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
operator|!
name|IDENTIFIER_HAS_TYPE_VALUE
argument_list|(
name|TYPE_IDENTIFIER
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
condition|)
name|globalize_nested_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Lookup TYPE in CONTEXT (a chain of nested types or a FUNCTION_DECL).    Return the type value, or NULL_TREE if not found.  */
end_comment

begin_function
specifier|static
name|tree
name|lookup_nested_type
parameter_list|(
name|type
parameter_list|,
name|context
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|context
decl_stmt|;
block|{
if|if
condition|(
name|context
operator|==
name|NULL_TREE
condition|)
return|return
name|NULL_TREE
return|;
while|while
condition|(
name|context
condition|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|context
argument_list|)
condition|)
block|{
case|case
name|TYPE_DECL
case|:
block|{
name|tree
name|ctype
init|=
name|TREE_TYPE
argument_list|(
name|context
argument_list|)
decl_stmt|;
name|tree
name|match
init|=
name|value_member
argument_list|(
name|type
argument_list|,
name|CLASSTYPE_TAGS
argument_list|(
name|ctype
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|match
condition|)
return|return
name|TREE_VALUE
argument_list|(
name|match
argument_list|)
return|;
name|context
operator|=
name|DECL_CONTEXT
argument_list|(
name|context
argument_list|)
expr_stmt|;
comment|/* When we have a nested class whose member functions have 	       local types (e.g., a set of enums), we'll arrive here 	       with the DECL_CONTEXT as the actual RECORD_TYPE node for 	       the enclosing class.  Instead, we want to make sure we 	       come back in here with the TYPE_DECL, not the RECORD_TYPE.  */
if|if
condition|(
name|context
operator|&&
name|TREE_CODE
argument_list|(
name|context
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
name|context
operator|=
name|TREE_CHAIN
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|FUNCTION_DECL
case|:
return|return
name|TYPE_IDENTIFIER
argument_list|(
name|type
argument_list|)
condition|?
name|lookup_name
argument_list|(
name|TYPE_IDENTIFIER
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
else|:
name|NULL_TREE
return|;
break|break;
default|default:
name|my_friendly_abort
argument_list|(
literal|12
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Look up NAME in the current binding level and its superiors in the    namespace of variables, functions and typedefs.  Return a ..._DECL    node of some kind representing its definition if there is only one    such declaration, or return a TREE_LIST with all the overloaded    definitions if there are many, or return 0 if it is undefined.     If PREFER_TYPE is> 0, we prefer TYPE_DECLs.    If PREFER_TYPE is = 0, we prefer non-TYPE_DECLs.    If PREFER_TYPE is< 0, we arbitrate according to lexical context.  */
end_comment

begin_function
name|tree
name|lookup_name
parameter_list|(
name|name
parameter_list|,
name|prefer_type
parameter_list|)
name|tree
name|name
decl_stmt|;
name|int
name|prefer_type
decl_stmt|;
block|{
specifier|register
name|tree
name|val
decl_stmt|;
if|if
condition|(
name|current_binding_level
operator|!=
name|global_binding_level
operator|&&
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|name
argument_list|)
condition|)
name|val
operator|=
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* In C++ class fields are between local and global scope,      just before the global scope.  */
elseif|else
if|if
condition|(
name|current_class_type
condition|)
block|{
name|val
operator|=
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|NULL_TREE
operator|&&
name|TYPE_SIZE
argument_list|(
name|current_class_type
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|CLASSTYPE_LOCAL_TYPEDECLS
argument_list|(
name|current_class_type
argument_list|)
condition|)
block|{
comment|/* Try to find values from base classes 	     if we are presently defining a type. 	     We are presently only interested in TYPE_DECLs.  */
name|val
operator|=
name|lookup_field
argument_list|(
name|current_class_type
argument_list|,
name|name
argument_list|,
literal|0
argument_list|,
name|prefer_type
operator|<
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|error_mark_node
condition|)
return|return
name|val
return|;
if|if
condition|(
name|val
operator|&&
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
name|val
operator|=
name|NULL_TREE
expr_stmt|;
block|}
comment|/* yylex() calls this with -2, since we should never start digging for 	 the nested name at the point where we haven't even, for example, 	 created the COMPONENT_REF or anything like that.  */
if|if
condition|(
name|val
operator|==
name|NULL_TREE
condition|)
name|val
operator|=
name|lookup_nested_field
argument_list|(
name|name
argument_list|,
name|prefer_type
operator|!=
operator|-
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|NULL_TREE
condition|)
name|val
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
else|else
name|val
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
block|{
specifier|extern
name|int
name|looking_for_typename
decl_stmt|;
comment|/* Arbitrate between finding a TYPE_DECL and finding 	 other kinds of _DECLs.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|TYPE_DECL
operator|||
name|looking_for_typename
operator|<
literal|0
condition|)
return|return
name|val
return|;
if|if
condition|(
name|IDENTIFIER_HAS_TYPE_VALUE
argument_list|(
name|name
argument_list|)
condition|)
block|{
specifier|register
name|tree
name|val_as_type
init|=
name|TYPE_NAME
argument_list|(
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|name
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|==
name|val_as_type
operator|||
name|prefer_type
operator|>
literal|0
operator|||
name|looking_for_typename
operator|>
literal|0
condition|)
return|return
name|val_as_type
return|;
if|if
condition|(
name|prefer_type
operator|==
literal|0
condition|)
return|return
name|val
return|;
return|return
name|arbitrate_lookup
argument_list|(
name|name
argument_list|,
name|val
argument_list|,
name|val_as_type
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
block|}
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Similar to `lookup_name' but look only at current binding level.  */
end_comment

begin_function
name|tree
name|lookup_name_current_level
parameter_list|(
name|name
parameter_list|)
name|tree
name|name
decl_stmt|;
block|{
specifier|register
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
condition|)
return|return
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
return|;
if|if
condition|(
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|name
argument_list|)
operator|==
name|NULL_TREE
condition|)
return|return
literal|0
return|;
for|for
control|(
name|t
operator|=
name|current_binding_level
operator|->
name|names
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
operator|==
name|name
condition|)
break|break;
return|return
name|t
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Arrange for the user to get a source line number, even when the    compiler is going down in flames, so that she at least has a    chance of working around problems in the compiler.  We used to    call error(), but that let the segmentation fault continue    through; now, it's much more passive by asking them to send the    maintainers mail about the problem.  */
end_comment

begin_function
specifier|static
name|void
name|sigsegv
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|signal
argument_list|(
name|SIGSEGV
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGIOT
name|signal
argument_list|(
name|SIGIOT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGILL
name|signal
argument_list|(
name|SIGILL
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGABRT
name|signal
argument_list|(
name|SIGABRT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|my_friendly_abort
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Array for holding types considered "built-in".  These types    are output in the module in which `main' is defined.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
modifier|*
name|builtin_type_tdescs_arr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|builtin_type_tdescs_len
decl_stmt|,
name|builtin_type_tdescs_max
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Push the declarations of builtin types into the namespace.    RID_INDEX, if< RID_MAX is the index of the builtin type    in the array RID_POINTERS.  NAME is the name used when looking    up the builtin type.  TYPE is the _TYPE node for the builtin type.  */
end_comment

begin_function
specifier|static
name|void
name|record_builtin_type
parameter_list|(
name|rid_index
parameter_list|,
name|name
parameter_list|,
name|type
parameter_list|)
name|enum
name|rid
name|rid_index
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|rname
init|=
name|NULL_TREE
decl_stmt|,
name|tname
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|tdecl
decl_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|rid_index
operator|<
operator|(
name|int
operator|)
name|RID_MAX
condition|)
name|rname
operator|=
name|ridpointers
index|[
operator|(
name|int
operator|)
name|rid_index
index|]
expr_stmt|;
if|if
condition|(
name|name
condition|)
name|tname
operator|=
name|get_identifier
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|tname
condition|)
block|{
if|#
directive|if
literal|0
comment|/* not yet, should get fixed properly later */
block|tdecl = pushdecl (make_type_decl (tname, type));
else|#
directive|else
name|tdecl
operator|=
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|tname
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|set_identifier_type_value
argument_list|(
name|tname
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|rid_index
operator|<
operator|(
name|int
operator|)
name|RID_MAX
condition|)
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|tname
argument_list|)
operator|=
name|tdecl
expr_stmt|;
block|}
if|if
condition|(
name|rname
operator|!=
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|tname
operator|!=
name|NULL_TREE
condition|)
block|{
name|set_identifier_type_value
argument_list|(
name|rname
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|rname
argument_list|)
operator|=
name|tdecl
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
literal|0
comment|/* not yet, should get fixed properly later */
block|tdecl = pushdecl (make_type_decl (rname, type));
else|#
directive|else
name|tdecl
operator|=
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|rname
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|set_identifier_type_value
argument_list|(
name|rname
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|flag_dossier
condition|)
block|{
if|if
condition|(
name|builtin_type_tdescs_len
operator|+
literal|5
operator|>=
name|builtin_type_tdescs_max
condition|)
block|{
name|builtin_type_tdescs_max
operator|*=
literal|2
expr_stmt|;
name|builtin_type_tdescs_arr
operator|=
operator|(
name|tree
operator|*
operator|)
name|xrealloc
argument_list|(
name|builtin_type_tdescs_arr
argument_list|,
name|builtin_type_tdescs_max
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|builtin_type_tdescs_arr
index|[
name|builtin_type_tdescs_len
operator|++
index|]
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
block|{
name|builtin_type_tdescs_arr
index|[
name|builtin_type_tdescs_len
operator|++
index|]
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|builtin_type_tdescs_arr
index|[
name|builtin_type_tdescs_len
operator|++
index|]
operator|=
name|build_type_variant
argument_list|(
name|TYPE_POINTER_TO
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|VOID_TYPE
condition|)
block|{
name|builtin_type_tdescs_arr
index|[
name|builtin_type_tdescs_len
operator|++
index|]
operator|=
name|build_reference_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|builtin_type_tdescs_arr
index|[
name|builtin_type_tdescs_len
operator|++
index|]
operator|=
name|build_type_variant
argument_list|(
name|TYPE_REFERENCE_TO
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|output_builtin_tdesc_entries
parameter_list|()
block|{
specifier|extern
name|struct
name|obstack
name|permanent_obstack
decl_stmt|;
comment|/* If there's more than one main in this file, don't crash.  */
if|if
condition|(
name|builtin_type_tdescs_arr
operator|==
literal|0
condition|)
return|return;
name|push_obstacks
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|&
name|permanent_obstack
argument_list|)
expr_stmt|;
while|while
condition|(
name|builtin_type_tdescs_len
operator|>
literal|0
condition|)
block|{
name|tree
name|type
init|=
name|builtin_type_tdescs_arr
index|[
operator|--
name|builtin_type_tdescs_len
index|]
decl_stmt|;
name|tree
name|tdesc
init|=
name|build_t_desc
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|TREE_ASM_WRITTEN
argument_list|(
name|tdesc
argument_list|)
operator|=
literal|0
expr_stmt|;
name|build_t_desc
argument_list|(
name|type
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|builtin_type_tdescs_arr
argument_list|)
expr_stmt|;
name|builtin_type_tdescs_arr
operator|=
literal|0
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Push overloaded decl, in global scope, with one argument so it    can be used as a callback from define_function.  */
end_comment

begin_function
specifier|static
name|void
name|push_overloaded_decl_1
parameter_list|(
name|x
parameter_list|)
name|tree
name|x
decl_stmt|;
block|{
name|push_overloaded_decl
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create the predefined scalar types of C,    and some nodes representing standard constants (0, 1, (void *)0).    Initialize the global binding level.    Make definitions for built-in primitive functions.  */
end_comment

begin_function
name|void
name|init_decl_processing
parameter_list|()
block|{
name|tree
name|decl
decl_stmt|;
specifier|register
name|tree
name|endlink
decl_stmt|,
name|int_endlink
decl_stmt|,
name|double_endlink
decl_stmt|,
name|ptr_endlink
decl_stmt|;
name|tree
name|fields
index|[
literal|20
index|]
decl_stmt|;
comment|/* Either char* or void*.  */
name|tree
name|traditional_ptr_type_node
decl_stmt|;
comment|/* Data type of memcpy.  */
name|tree
name|memcpy_ftype
decl_stmt|;
name|int
name|wchar_type_size
decl_stmt|;
comment|/* Have to make these distinct before we try using them.  */
name|lang_name_cplusplus
operator|=
name|get_identifier
argument_list|(
literal|"C++"
argument_list|)
expr_stmt|;
name|lang_name_c
operator|=
name|get_identifier
argument_list|(
literal|"C"
argument_list|)
expr_stmt|;
comment|/* Initially, C.  */
name|current_lang_name
operator|=
name|lang_name_c
expr_stmt|;
name|current_function_decl
operator|=
name|NULL_TREE
expr_stmt|;
name|named_labels
operator|=
name|NULL_TREE
expr_stmt|;
name|named_label_uses
operator|=
name|NULL_TREE
expr_stmt|;
name|current_binding_level
operator|=
name|NULL_BINDING_LEVEL
expr_stmt|;
name|free_binding_level
operator|=
name|NULL_BINDING_LEVEL
expr_stmt|;
comment|/* Because most segmentation signals can be traced back into user      code, catch them and at least give the user a chance of working      around compiler bugs. */
name|signal
argument_list|(
name|SIGSEGV
argument_list|,
name|sigsegv
argument_list|)
expr_stmt|;
comment|/* We will also catch aborts in the back-end through sigsegv and give the      user a chance to see where the error might be, and to defeat aborts in      the back-end when there have been errors previously in their code. */
ifdef|#
directive|ifdef
name|SIGIOT
name|signal
argument_list|(
name|SIGIOT
argument_list|,
name|sigsegv
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGILL
name|signal
argument_list|(
name|SIGILL
argument_list|,
name|sigsegv
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGABRT
name|signal
argument_list|(
name|SIGABRT
argument_list|,
name|sigsegv
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|gcc_obstack_init
argument_list|(
operator|&
name|decl_obstack
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_dossier
condition|)
block|{
name|builtin_type_tdescs_max
operator|=
literal|100
expr_stmt|;
name|builtin_type_tdescs_arr
operator|=
operator|(
name|tree
operator|*
operator|)
name|xmalloc
argument_list|(
literal|100
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Must lay these out before anything else gets laid out.  */
name|error_mark_node
operator|=
name|make_node
argument_list|(
name|ERROR_MARK
argument_list|)
expr_stmt|;
name|TREE_PERMANENT
argument_list|(
name|error_mark_node
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|error_mark_node
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|error_mark_list
operator|=
name|build_tree_list
argument_list|(
name|error_mark_node
argument_list|,
name|error_mark_node
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|error_mark_list
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* make the binding_level structure for global names.  */
name|global_binding_level
operator|=
name|current_binding_level
expr_stmt|;
name|this_identifier
operator|=
name|get_identifier
argument_list|(
name|THIS_NAME
argument_list|)
expr_stmt|;
name|in_charge_identifier
operator|=
name|get_identifier
argument_list|(
name|IN_CHARGE_NAME
argument_list|)
expr_stmt|;
comment|/* Define `int' and `char' first so that dbx will output them first.  */
name|integer_type_node
operator|=
name|make_signed_type
argument_list|(
name|INT_TYPE_SIZE
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_INT
argument_list|,
name|NULL_PTR
argument_list|,
name|integer_type_node
argument_list|)
expr_stmt|;
comment|/* Define `char', which is like either `signed char' or `unsigned char'      but not the same as either.  */
name|char_type_node
operator|=
operator|(
name|flag_signed_char
condition|?
name|make_signed_type
argument_list|(
name|CHAR_TYPE_SIZE
argument_list|)
else|:
name|make_unsigned_type
argument_list|(
name|CHAR_TYPE_SIZE
argument_list|)
operator|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_CHAR
argument_list|,
literal|"char"
argument_list|,
name|char_type_node
argument_list|)
expr_stmt|;
name|long_integer_type_node
operator|=
name|make_signed_type
argument_list|(
name|LONG_TYPE_SIZE
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_LONG
argument_list|,
literal|"long int"
argument_list|,
name|long_integer_type_node
argument_list|)
expr_stmt|;
name|unsigned_type_node
operator|=
name|make_unsigned_type
argument_list|(
name|INT_TYPE_SIZE
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_UNSIGNED
argument_list|,
literal|"unsigned int"
argument_list|,
name|unsigned_type_node
argument_list|)
expr_stmt|;
name|long_unsigned_type_node
operator|=
name|make_unsigned_type
argument_list|(
name|LONG_TYPE_SIZE
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
literal|"long unsigned int"
argument_list|,
name|long_unsigned_type_node
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
literal|"unsigned long"
argument_list|,
name|long_unsigned_type_node
argument_list|)
expr_stmt|;
comment|/* `unsigned long' is the standard type for sizeof.      Traditionally, use a signed type.      Note that stddef.h uses `unsigned long',      and this must agree, even of long and int are the same size.  */
if|if
condition|(
name|flag_traditional
condition|)
name|sizetype
operator|=
name|long_integer_type_node
expr_stmt|;
else|else
name|sizetype
operator|=
name|TREE_TYPE
argument_list|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|get_identifier
argument_list|(
name|SIZE_TYPE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ptrdiff_type_node
operator|=
name|TREE_TYPE
argument_list|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|get_identifier
argument_list|(
name|PTRDIFF_TYPE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|)
operator|=
name|sizetype
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|char_type_node
argument_list|)
argument_list|)
operator|=
name|sizetype
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|unsigned_type_node
argument_list|)
argument_list|)
operator|=
name|sizetype
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|long_unsigned_type_node
argument_list|)
argument_list|)
operator|=
name|sizetype
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|long_integer_type_node
argument_list|)
argument_list|)
operator|=
name|sizetype
expr_stmt|;
name|short_integer_type_node
operator|=
name|make_signed_type
argument_list|(
name|SHORT_TYPE_SIZE
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_SHORT
argument_list|,
literal|"short int"
argument_list|,
name|short_integer_type_node
argument_list|)
expr_stmt|;
name|long_long_integer_type_node
operator|=
name|make_signed_type
argument_list|(
name|LONG_LONG_TYPE_SIZE
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
literal|"long long int"
argument_list|,
name|long_long_integer_type_node
argument_list|)
expr_stmt|;
name|short_unsigned_type_node
operator|=
name|make_unsigned_type
argument_list|(
name|SHORT_TYPE_SIZE
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
literal|"short unsigned int"
argument_list|,
name|short_unsigned_type_node
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
literal|"unsigned short"
argument_list|,
name|short_unsigned_type_node
argument_list|)
expr_stmt|;
name|long_long_unsigned_type_node
operator|=
name|make_unsigned_type
argument_list|(
name|LONG_LONG_TYPE_SIZE
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
literal|"long long unsigned int"
argument_list|,
name|long_long_unsigned_type_node
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
literal|"long long unsigned"
argument_list|,
name|long_long_unsigned_type_node
argument_list|)
expr_stmt|;
comment|/* Define both `signed char' and `unsigned char'.  */
name|signed_char_type_node
operator|=
name|make_signed_type
argument_list|(
name|CHAR_TYPE_SIZE
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
literal|"signed char"
argument_list|,
name|signed_char_type_node
argument_list|)
expr_stmt|;
name|unsigned_char_type_node
operator|=
name|make_unsigned_type
argument_list|(
name|CHAR_TYPE_SIZE
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
literal|"unsigned char"
argument_list|,
name|unsigned_char_type_node
argument_list|)
expr_stmt|;
comment|/* These are types that type_for_size and type_for_mode use.  */
name|intQI_type_node
operator|=
name|make_signed_type
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|QImode
argument_list|)
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|intQI_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|intHI_type_node
operator|=
name|make_signed_type
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|HImode
argument_list|)
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|intHI_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|intSI_type_node
operator|=
name|make_signed_type
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|SImode
argument_list|)
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|intSI_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|intDI_type_node
operator|=
name|make_signed_type
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|DImode
argument_list|)
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|intDI_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|unsigned_intQI_type_node
operator|=
name|make_unsigned_type
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|QImode
argument_list|)
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|unsigned_intQI_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|unsigned_intHI_type_node
operator|=
name|make_unsigned_type
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|HImode
argument_list|)
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|unsigned_intHI_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|unsigned_intSI_type_node
operator|=
name|make_unsigned_type
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|SImode
argument_list|)
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|unsigned_intSI_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|unsigned_intDI_type_node
operator|=
name|make_unsigned_type
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|DImode
argument_list|)
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|unsigned_intDI_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|float_type_node
operator|=
name|make_node
argument_list|(
name|REAL_TYPE
argument_list|)
expr_stmt|;
name|TYPE_PRECISION
argument_list|(
name|float_type_node
argument_list|)
operator|=
name|FLOAT_TYPE_SIZE
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_FLOAT
argument_list|,
name|NULL
argument_list|,
name|float_type_node
argument_list|)
expr_stmt|;
name|layout_type
argument_list|(
name|float_type_node
argument_list|)
expr_stmt|;
name|double_type_node
operator|=
name|make_node
argument_list|(
name|REAL_TYPE
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_short_double
condition|)
name|TYPE_PRECISION
argument_list|(
name|double_type_node
argument_list|)
operator|=
name|FLOAT_TYPE_SIZE
expr_stmt|;
else|else
name|TYPE_PRECISION
argument_list|(
name|double_type_node
argument_list|)
operator|=
name|DOUBLE_TYPE_SIZE
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_DOUBLE
argument_list|,
name|NULL
argument_list|,
name|double_type_node
argument_list|)
expr_stmt|;
name|layout_type
argument_list|(
name|double_type_node
argument_list|)
expr_stmt|;
name|long_double_type_node
operator|=
name|make_node
argument_list|(
name|REAL_TYPE
argument_list|)
expr_stmt|;
name|TYPE_PRECISION
argument_list|(
name|long_double_type_node
argument_list|)
operator|=
name|LONG_DOUBLE_TYPE_SIZE
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
literal|"long double"
argument_list|,
name|long_double_type_node
argument_list|)
expr_stmt|;
name|layout_type
argument_list|(
name|long_double_type_node
argument_list|)
expr_stmt|;
name|integer_zero_node
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|integer_zero_node
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
name|integer_one_node
operator|=
name|build_int_2
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|integer_one_node
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
name|integer_two_node
operator|=
name|build_int_2
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|integer_two_node
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
name|integer_three_node
operator|=
name|build_int_2
argument_list|(
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|integer_three_node
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
name|empty_init_node
operator|=
name|build_nt
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* These are needed by stor-layout.c.  */
name|size_zero_node
operator|=
name|size_int
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|size_one_node
operator|=
name|size_int
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|void_type_node
operator|=
name|make_node
argument_list|(
name|VOID_TYPE
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_VOID
argument_list|,
name|NULL
argument_list|,
name|void_type_node
argument_list|)
expr_stmt|;
name|layout_type
argument_list|(
name|void_type_node
argument_list|)
expr_stmt|;
comment|/* Uses integer_zero_node.  */
name|void_list_node
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|void_type_node
argument_list|)
expr_stmt|;
name|TREE_PARMLIST
argument_list|(
name|void_list_node
argument_list|)
operator|=
literal|1
expr_stmt|;
name|null_pointer_node
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|null_pointer_node
argument_list|)
operator|=
name|build_pointer_type
argument_list|(
name|void_type_node
argument_list|)
expr_stmt|;
name|layout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|null_pointer_node
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Used for expressions that do nothing, but are not errors.  */
name|void_zero_node
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|void_zero_node
argument_list|)
operator|=
name|void_type_node
expr_stmt|;
name|string_type_node
operator|=
name|build_pointer_type
argument_list|(
name|char_type_node
argument_list|)
expr_stmt|;
name|const_string_type_node
operator|=
name|build_pointer_type
argument_list|(
name|build_type_variant
argument_list|(
name|char_type_node
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
name|NULL
argument_list|,
name|string_type_node
argument_list|)
expr_stmt|;
comment|/* make a type for arrays of 256 characters.      256 is picked randomly because we have a type for integers from 0 to 255.      With luck nothing will ever really depend on the length of this      array type.  */
name|char_array_type_node
operator|=
name|build_array_type
argument_list|(
name|char_type_node
argument_list|,
name|unsigned_char_type_node
argument_list|)
expr_stmt|;
comment|/* Likewise for arrays of ints.  */
name|int_array_type_node
operator|=
name|build_array_type
argument_list|(
name|integer_type_node
argument_list|,
name|unsigned_char_type_node
argument_list|)
expr_stmt|;
comment|/* This is just some anonymous class type.  Nobody should ever      need to look inside this envelope.  */
name|class_star_type_node
operator|=
name|build_pointer_type
argument_list|(
name|make_lang_type
argument_list|(
name|RECORD_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|default_function_type
operator|=
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|build_pointer_type
argument_list|(
name|default_function_type
argument_list|)
expr_stmt|;
name|ptr_type_node
operator|=
name|build_pointer_type
argument_list|(
name|void_type_node
argument_list|)
expr_stmt|;
name|const_ptr_type_node
operator|=
name|build_pointer_type
argument_list|(
name|build_type_variant
argument_list|(
name|void_type_node
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
name|NULL
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
name|endlink
operator|=
name|void_list_node
expr_stmt|;
name|int_endlink
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|endlink
argument_list|)
expr_stmt|;
name|double_endlink
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|double_type_node
argument_list|,
name|endlink
argument_list|)
expr_stmt|;
name|ptr_endlink
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|endlink
argument_list|)
expr_stmt|;
name|double_ftype_double
operator|=
name|build_function_type
argument_list|(
name|double_type_node
argument_list|,
name|double_endlink
argument_list|)
expr_stmt|;
name|double_ftype_double_double
operator|=
name|build_function_type
argument_list|(
name|double_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|double_type_node
argument_list|,
name|double_endlink
argument_list|)
argument_list|)
expr_stmt|;
name|int_ftype_int
operator|=
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|int_endlink
argument_list|)
expr_stmt|;
name|long_ftype_long
operator|=
name|build_function_type
argument_list|(
name|long_integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|long_integer_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
expr_stmt|;
name|void_ftype_ptr_ptr_int
operator|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|int_endlink
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|int_ftype_cptr_cptr_sizet
operator|=
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|const_ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|const_ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|sizetype
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|void_ftype_ptr_int_int
operator|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|int_endlink
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|string_ftype_ptr_ptr
comment|/* strcpy prototype */
operator|=
name|build_function_type
argument_list|(
name|string_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|string_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|const_string_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|int_ftype_string_string
comment|/* strcmp prototype */
operator|=
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|const_string_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|const_string_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|sizet_ftype_string
comment|/* strlen prototype */
operator|=
name|build_function_type
argument_list|(
name|sizetype
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|const_string_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
expr_stmt|;
name|traditional_ptr_type_node
operator|=
operator|(
name|flag_traditional
condition|?
name|string_type_node
else|:
name|ptr_type_node
operator|)
expr_stmt|;
name|memcpy_ftype
comment|/* memcpy prototype */
operator|=
name|build_function_type
argument_list|(
name|traditional_ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|const_ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|sizetype
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VTABLE_USES_MASK
comment|/* This is primarily for virtual function definition.  We      declare an array of `void *', which can later be      converted to the appropriate function pointer type.      To do pointers to members, we need a mask which can      distinguish an index value into a virtual function table      from an address.  */
name|vtbl_mask
operator|=
name|build_int_2
argument_list|(
operator|~
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
name|VINDEX_MAX
operator|-
literal|1
operator|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vtbl_type_node
operator|=
name|build_array_type
argument_list|(
name|ptr_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|layout_type
argument_list|(
name|vtbl_type_node
argument_list|)
expr_stmt|;
name|vtbl_type_node
operator|=
name|build_type_variant
argument_list|(
name|vtbl_type_node
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
name|NULL
argument_list|,
name|vtbl_type_node
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_constant_p"
argument_list|,
name|int_ftype_int
argument_list|,
name|BUILT_IN_CONSTANT_P
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_alloca"
argument_list|,
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|sizetype
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|,
name|BUILT_IN_ALLOCA
argument_list|,
literal|"alloca"
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|builtin_function ("alloca", 		    build_function_type (ptr_type_node, 					 tree_cons (NULL_TREE, 						    sizetype, 						    endlink)), 		    BUILT_IN_ALLOCA, NULL_PTR);
endif|#
directive|endif
name|builtin_function
argument_list|(
literal|"__builtin_abs"
argument_list|,
name|int_ftype_int
argument_list|,
name|BUILT_IN_ABS
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_fabs"
argument_list|,
name|double_ftype_double
argument_list|,
name|BUILT_IN_FABS
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_labs"
argument_list|,
name|long_ftype_long
argument_list|,
name|BUILT_IN_LABS
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_ffs"
argument_list|,
name|int_ftype_int
argument_list|,
name|BUILT_IN_FFS
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_fsqrt"
argument_list|,
name|double_ftype_double
argument_list|,
name|BUILT_IN_FSQRT
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_sin"
argument_list|,
name|double_ftype_double
argument_list|,
name|BUILT_IN_SIN
argument_list|,
literal|"sin"
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_cos"
argument_list|,
name|double_ftype_double
argument_list|,
name|BUILT_IN_COS
argument_list|,
literal|"cos"
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_saveregs"
argument_list|,
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|,
name|BUILT_IN_SAVEREGS
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
comment|/* EXPAND_BUILTIN_VARARGS is obsolete.  */
if|#
directive|if
literal|0
block|builtin_function ("__builtin_varargs", 		    build_function_type (ptr_type_node, 					 tree_cons (NULL_TREE, 						    integer_type_node, 						    endlink)), 		    BUILT_IN_VARARGS, NULL_PTR);
endif|#
directive|endif
name|builtin_function
argument_list|(
literal|"__builtin_classify_type"
argument_list|,
name|default_function_type
argument_list|,
name|BUILT_IN_CLASSIFY_TYPE
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_next_arg"
argument_list|,
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|,
name|BUILT_IN_NEXT_ARG
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_args_info"
argument_list|,
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|,
name|BUILT_IN_ARGS_INFO
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
comment|/* Currently under experimentation.  */
name|builtin_function
argument_list|(
literal|"__builtin_memcpy"
argument_list|,
name|memcpy_ftype
argument_list|,
name|BUILT_IN_MEMCPY
argument_list|,
literal|"memcpy"
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_memcmp"
argument_list|,
name|int_ftype_cptr_cptr_sizet
argument_list|,
name|BUILT_IN_MEMCMP
argument_list|,
literal|"memcmp"
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_strcmp"
argument_list|,
name|int_ftype_string_string
argument_list|,
name|BUILT_IN_STRCMP
argument_list|,
literal|"strcmp"
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_strcpy"
argument_list|,
name|string_ftype_ptr_ptr
argument_list|,
name|BUILT_IN_STRCPY
argument_list|,
literal|"strcpy"
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_strlen"
argument_list|,
name|sizet_ftype_string
argument_list|,
name|BUILT_IN_STRLEN
argument_list|,
literal|"strlen"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flag_no_builtin
condition|)
block|{
if|#
directive|if
literal|0
comment|/* These do not work well with libg++.  */
block|builtin_function ("abs", int_ftype_int, BUILT_IN_ABS, NULL_PTR);       builtin_function ("fabs", double_ftype_double, BUILT_IN_FABS, NULL_PTR);       builtin_function ("labs", long_ftype_long, BUILT_IN_LABS, NULL_PTR);
endif|#
directive|endif
name|builtin_function
argument_list|(
literal|"memcpy"
argument_list|,
name|memcpy_ftype
argument_list|,
name|BUILT_IN_MEMCPY
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"memcmp"
argument_list|,
name|int_ftype_cptr_cptr_sizet
argument_list|,
name|BUILT_IN_MEMCMP
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"strcmp"
argument_list|,
name|int_ftype_string_string
argument_list|,
name|BUILT_IN_STRCMP
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"strcpy"
argument_list|,
name|string_ftype_ptr_ptr
argument_list|,
name|BUILT_IN_STRCPY
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"strlen"
argument_list|,
name|sizet_ftype_string
argument_list|,
name|BUILT_IN_STRLEN
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"sin"
argument_list|,
name|double_ftype_double
argument_list|,
name|BUILT_IN_SIN
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"cos"
argument_list|,
name|double_ftype_double
argument_list|,
name|BUILT_IN_COS
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* Support for these has not been written in either expand_builtin      or build_function_call.  */
block|builtin_function ("__builtin_div", default_ftype, BUILT_IN_DIV, 0);   builtin_function ("__builtin_ldiv", default_ftype, BUILT_IN_LDIV, 0);   builtin_function ("__builtin_ffloor", double_ftype_double, BUILT_IN_FFLOOR, 0);   builtin_function ("__builtin_fceil", double_ftype_double, BUILT_IN_FCEIL, 0);   builtin_function ("__builtin_fmod", double_ftype_double_double, BUILT_IN_FMOD, 0);   builtin_function ("__builtin_frem", double_ftype_double_double, BUILT_IN_FREM, 0);   builtin_function ("__builtin_memset", ptr_ftype_ptr_int_int, BUILT_IN_MEMSET, 0);   builtin_function ("__builtin_getexp", double_ftype_double, BUILT_IN_GETEXP, 0);   builtin_function ("__builtin_getman", double_ftype_double, BUILT_IN_GETMAN, 0);
endif|#
directive|endif
comment|/* C++ extensions */
name|unknown_type_node
operator|=
name|make_node
argument_list|(
name|UNKNOWN_TYPE
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* not yet, should get fixed properly later */
block|pushdecl (make_type_decl (get_identifier ("unknown type"), 		       unknown_type_node));
else|#
directive|else
name|decl
operator|=
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"unknown type"
argument_list|)
argument_list|,
name|unknown_type_node
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make sure the "unknown type" typedecl gets ignored for debug info.  */
name|DECL_IGNORED_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|TYPE_SIZE
argument_list|(
name|unknown_type_node
argument_list|)
operator|=
name|TYPE_SIZE
argument_list|(
name|void_type_node
argument_list|)
expr_stmt|;
name|TYPE_ALIGN
argument_list|(
name|unknown_type_node
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_MODE
argument_list|(
name|unknown_type_node
argument_list|)
operator|=
name|TYPE_MODE
argument_list|(
name|void_type_node
argument_list|)
expr_stmt|;
comment|/* Indirecting an UNKNOWN_TYPE node yields an UNKNOWN_TYPE node.  */
name|TREE_TYPE
argument_list|(
name|unknown_type_node
argument_list|)
operator|=
name|unknown_type_node
expr_stmt|;
comment|/* Looking up TYPE_POINTER_TO and TYPE_REFERENCE_TO yield the same result.  */
name|TYPE_POINTER_TO
argument_list|(
name|unknown_type_node
argument_list|)
operator|=
name|unknown_type_node
expr_stmt|;
name|TYPE_REFERENCE_TO
argument_list|(
name|unknown_type_node
argument_list|)
operator|=
name|unknown_type_node
expr_stmt|;
comment|/* This is special for C++ so functions can be overloaded. */
name|wchar_type_node
operator|=
name|TREE_TYPE
argument_list|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|get_identifier
argument_list|(
name|WCHAR_TYPE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|wchar_type_size
operator|=
name|TYPE_PRECISION
argument_list|(
name|wchar_type_node
argument_list|)
expr_stmt|;
name|signed_wchar_type_node
operator|=
name|make_signed_type
argument_list|(
name|wchar_type_size
argument_list|)
expr_stmt|;
name|unsigned_wchar_type_node
operator|=
name|make_unsigned_type
argument_list|(
name|wchar_type_size
argument_list|)
expr_stmt|;
name|wchar_type_node
operator|=
name|TREE_UNSIGNED
argument_list|(
name|wchar_type_node
argument_list|)
condition|?
name|unsigned_wchar_type_node
else|:
name|signed_wchar_type_node
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_WCHAR
argument_list|,
literal|"__wchar_t"
argument_list|,
name|wchar_type_node
argument_list|)
expr_stmt|;
comment|/* This is for wide string constants.  */
name|wchar_array_type_node
operator|=
name|build_array_type
argument_list|(
name|wchar_type_node
argument_list|,
name|unsigned_char_type_node
argument_list|)
expr_stmt|;
comment|/* This is a hack that should go away when we deliver the      real gc code.  */
if|if
condition|(
name|flag_gc
condition|)
block|{
name|builtin_function
argument_list|(
literal|"__gc_main"
argument_list|,
name|default_function_type
argument_list|,
name|NOT_BUILT_IN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|lookup_name
argument_list|(
name|get_identifier
argument_list|(
literal|"__gc_main"
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Simplify life by making a "vtable_entry_type".  Give its      fields names so that the debugger can use them.  */
name|vtable_entry_type
operator|=
name|make_lang_type
argument_list|(
name|RECORD_TYPE
argument_list|)
expr_stmt|;
name|fields
index|[
literal|0
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
name|VTABLE_DELTA_NAME
argument_list|)
argument_list|,
name|short_integer_type_node
argument_list|)
expr_stmt|;
name|fields
index|[
literal|1
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
name|VTABLE_INDEX_NAME
argument_list|)
argument_list|,
name|short_integer_type_node
argument_list|)
expr_stmt|;
name|fields
index|[
literal|2
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
name|VTABLE_PFN_NAME
argument_list|)
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
name|finish_builtin_type
argument_list|(
name|vtable_entry_type
argument_list|,
name|VTBL_PTR_TYPE
argument_list|,
name|fields
argument_list|,
literal|2
argument_list|,
name|double_type_node
argument_list|)
expr_stmt|;
comment|/* Make this part of an invisible union.  */
name|fields
index|[
literal|3
index|]
operator|=
name|copy_node
argument_list|(
name|fields
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|fields
index|[
literal|3
index|]
argument_list|)
operator|=
name|short_integer_type_node
expr_stmt|;
name|DECL_NAME
argument_list|(
name|fields
index|[
literal|3
index|]
argument_list|)
operator|=
name|get_identifier
argument_list|(
name|VTABLE_DELTA2_NAME
argument_list|)
expr_stmt|;
name|DECL_MODE
argument_list|(
name|fields
index|[
literal|3
index|]
argument_list|)
operator|=
name|TYPE_MODE
argument_list|(
name|short_integer_type_node
argument_list|)
expr_stmt|;
name|DECL_SIZE
argument_list|(
name|fields
index|[
literal|3
index|]
argument_list|)
operator|=
name|TYPE_SIZE
argument_list|(
name|short_integer_type_node
argument_list|)
expr_stmt|;
name|TREE_UNSIGNED
argument_list|(
name|fields
index|[
literal|3
index|]
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|fields
index|[
literal|2
index|]
argument_list|)
operator|=
name|fields
index|[
literal|3
index|]
expr_stmt|;
name|vtable_entry_type
operator|=
name|build_type_variant
argument_list|(
name|vtable_entry_type
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
name|VTBL_PTR_TYPE
argument_list|,
name|vtable_entry_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_dossier
condition|)
block|{
comment|/* Must build __t_desc type.  Currently, type descriptors look like this:  	 struct __t_desc 	 {            const char *name; 	   int size; 	   int bits; 	   struct __t_desc *points_to; 	   int ivars_count, meths_count; 	   struct __i_desc *ivars[]; 	   struct __m_desc *meths[]; 	   struct __t_desc *parents[]; 	   struct __t_desc *vbases[]; 	   int offsets[]; 	 };  	 ...as per Linton's paper.  */
name|__t_desc_type_node
operator|=
name|make_lang_type
argument_list|(
name|RECORD_TYPE
argument_list|)
expr_stmt|;
name|__i_desc_type_node
operator|=
name|make_lang_type
argument_list|(
name|RECORD_TYPE
argument_list|)
expr_stmt|;
name|__m_desc_type_node
operator|=
name|make_lang_type
argument_list|(
name|RECORD_TYPE
argument_list|)
expr_stmt|;
name|__t_desc_array_type
operator|=
name|build_array_type
argument_list|(
name|TYPE_POINTER_TO
argument_list|(
name|__t_desc_type_node
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|__i_desc_array_type
operator|=
name|build_array_type
argument_list|(
name|TYPE_POINTER_TO
argument_list|(
name|__i_desc_type_node
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|__m_desc_array_type
operator|=
name|build_array_type
argument_list|(
name|TYPE_POINTER_TO
argument_list|(
name|__m_desc_type_node
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|fields
index|[
literal|0
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"name"
argument_list|)
argument_list|,
name|string_type_node
argument_list|)
expr_stmt|;
name|fields
index|[
literal|1
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"size"
argument_list|)
argument_list|,
name|unsigned_type_node
argument_list|)
expr_stmt|;
name|fields
index|[
literal|2
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"bits"
argument_list|)
argument_list|,
name|unsigned_type_node
argument_list|)
expr_stmt|;
name|fields
index|[
literal|3
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"points_to"
argument_list|)
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|__t_desc_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|fields
index|[
literal|4
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"ivars_count"
argument_list|)
argument_list|,
name|integer_type_node
argument_list|)
expr_stmt|;
name|fields
index|[
literal|5
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"meths_count"
argument_list|)
argument_list|,
name|integer_type_node
argument_list|)
expr_stmt|;
name|fields
index|[
literal|6
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"ivars"
argument_list|)
argument_list|,
name|build_pointer_type
argument_list|(
name|__i_desc_array_type
argument_list|)
argument_list|)
expr_stmt|;
name|fields
index|[
literal|7
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"meths"
argument_list|)
argument_list|,
name|build_pointer_type
argument_list|(
name|__m_desc_array_type
argument_list|)
argument_list|)
expr_stmt|;
name|fields
index|[
literal|8
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"parents"
argument_list|)
argument_list|,
name|build_pointer_type
argument_list|(
name|__t_desc_array_type
argument_list|)
argument_list|)
expr_stmt|;
name|fields
index|[
literal|9
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"vbases"
argument_list|)
argument_list|,
name|build_pointer_type
argument_list|(
name|__t_desc_array_type
argument_list|)
argument_list|)
expr_stmt|;
name|fields
index|[
literal|10
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"offsets"
argument_list|)
argument_list|,
name|build_pointer_type
argument_list|(
name|integer_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|finish_builtin_type
argument_list|(
name|__t_desc_type_node
argument_list|,
literal|"__t_desc"
argument_list|,
name|fields
argument_list|,
literal|10
argument_list|,
name|integer_type_node
argument_list|)
expr_stmt|;
comment|/* ivar descriptors look like this:  	 struct __i_desc 	 { 	   const char *name; 	   int offset; 	   struct __t_desc *type; 	 };       */
name|fields
index|[
literal|0
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"name"
argument_list|)
argument_list|,
name|string_type_node
argument_list|)
expr_stmt|;
name|fields
index|[
literal|1
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"offset"
argument_list|)
argument_list|,
name|integer_type_node
argument_list|)
expr_stmt|;
name|fields
index|[
literal|2
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"type"
argument_list|)
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|__t_desc_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|finish_builtin_type
argument_list|(
name|__i_desc_type_node
argument_list|,
literal|"__i_desc"
argument_list|,
name|fields
argument_list|,
literal|2
argument_list|,
name|integer_type_node
argument_list|)
expr_stmt|;
comment|/* method descriptors look like this:  	 struct __m_desc 	 { 	   const char *name; 	   int vindex; 	   struct __t_desc *vcontext; 	   struct __t_desc *return_type; 	   void (*address)(); 	   short parm_count; 	   short required_parms; 	   struct __t_desc *parm_types[]; 	 };       */
name|fields
index|[
literal|0
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"name"
argument_list|)
argument_list|,
name|string_type_node
argument_list|)
expr_stmt|;
name|fields
index|[
literal|1
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"vindex"
argument_list|)
argument_list|,
name|integer_type_node
argument_list|)
expr_stmt|;
name|fields
index|[
literal|2
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"vcontext"
argument_list|)
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|__t_desc_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|fields
index|[
literal|3
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"return_type"
argument_list|)
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|__t_desc_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|fields
index|[
literal|4
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"address"
argument_list|)
argument_list|,
name|build_pointer_type
argument_list|(
name|default_function_type
argument_list|)
argument_list|)
expr_stmt|;
name|fields
index|[
literal|5
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"parm_count"
argument_list|)
argument_list|,
name|short_integer_type_node
argument_list|)
expr_stmt|;
name|fields
index|[
literal|6
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"required_parms"
argument_list|)
argument_list|,
name|short_integer_type_node
argument_list|)
expr_stmt|;
name|fields
index|[
literal|7
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"parm_types"
argument_list|)
argument_list|,
name|build_pointer_type
argument_list|(
name|build_array_type
argument_list|(
name|TYPE_POINTER_TO
argument_list|(
name|__t_desc_type_node
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|finish_builtin_type
argument_list|(
name|__m_desc_type_node
argument_list|,
literal|"__m_desc"
argument_list|,
name|fields
argument_list|,
literal|7
argument_list|,
name|integer_type_node
argument_list|)
expr_stmt|;
block|}
comment|/* Now, C++.  */
name|current_lang_name
operator|=
name|lang_name_cplusplus
expr_stmt|;
if|if
condition|(
name|flag_dossier
condition|)
block|{
name|int
name|i
init|=
name|builtin_type_tdescs_len
decl_stmt|;
while|while
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|tree
name|tdesc
init|=
name|build_t_desc
argument_list|(
name|builtin_type_tdescs_arr
index|[
operator|--
name|i
index|]
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|TREE_ASM_WRITTEN
argument_list|(
name|tdesc
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|TREE_OPERAND
argument_list|(
name|tdesc
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|auto_function
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|NEW_EXPR
index|]
argument_list|,
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|sizetype
argument_list|,
name|void_list_node
argument_list|)
argument_list|)
argument_list|,
name|NOT_BUILT_IN
argument_list|)
expr_stmt|;
name|auto_function
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|DELETE_EXPR
index|]
argument_list|,
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|void_list_node
argument_list|)
argument_list|)
argument_list|,
name|NOT_BUILT_IN
argument_list|)
expr_stmt|;
name|abort_fndecl
operator|=
name|define_function
argument_list|(
literal|"abort"
argument_list|,
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|void_list_node
argument_list|)
argument_list|,
name|NOT_BUILT_IN
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|unhandled_exception_fndecl
operator|=
name|define_function
argument_list|(
literal|"__unhandled_exception"
argument_list|,
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|,
name|NOT_BUILT_IN
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Perform other language dependent initializations.  */
name|init_class_processing
argument_list|()
expr_stmt|;
name|init_init_processing
argument_list|()
expr_stmt|;
name|init_search_processing
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag_handle_exceptions
condition|)
block|{
if|if
condition|(
name|flag_handle_exceptions
operator|==
literal|2
condition|)
comment|/* Too much trouble to inline all the trys needed for this.  */
name|flag_this_is_variable
operator|=
literal|2
expr_stmt|;
name|init_exception_processing
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|flag_gc
condition|)
name|init_gc_processing
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag_no_inline
condition|)
name|flag_inline_functions
operator|=
literal|0
operator|,
name|flag_default_inline
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flag_cadillac
condition|)
name|init_cadillac
argument_list|()
expr_stmt|;
comment|/* Create the global bindings for __FUNCTION__ and __PRETTY_FUNCTION__.  */
name|declare_function_name
argument_list|()
expr_stmt|;
comment|/* Warnings about failure to return values are too valuable to forego.  */
name|warn_return_type
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make a definition for a builtin function named NAME and whose data type    is TYPE.  TYPE should be a function type with argument types.    FUNCTION_CODE tells later passes how to compile calls to this function.    See tree.h for its possible values.     If LIBRARY_NAME is nonzero, use that for DECL_ASSEMBLER_NAME,    the name to be called if we can't opencode the function.  */
end_comment

begin_decl_stmt
name|tree
name|define_function
argument_list|(
name|name
argument_list|,
name|type
argument_list|,
name|function_code
argument_list|,
name|pfn
argument_list|,
name|library_name
argument_list|)
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|built_in_function
name|function_code
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
function_decl|(
modifier|*
name|pfn
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|char
modifier|*
name|library_name
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|tree
name|decl
init|=
name|build_lang_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|get_identifier
argument_list|(
name|name
argument_list|)
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Since `pushdecl' relies on DECL_ASSEMBLER_NAME instead of DECL_NAME,      we cannot change DECL_ASSEMBLER_NAME until we have installed this      function in the namespace.  */
if|if
condition|(
name|pfn
condition|)
call|(
modifier|*
name|pfn
call|)
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|library_name
condition|)
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
operator|=
name|get_identifier
argument_list|(
name|library_name
argument_list|)
expr_stmt|;
name|make_function_rtl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|function_code
operator|!=
name|NOT_BUILT_IN
condition|)
block|{
name|DECL_BUILT_IN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_SET_FUNCTION_CODE
argument_list|(
name|decl
argument_list|,
name|function_code
argument_list|)
expr_stmt|;
block|}
return|return
name|decl
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Called when a declaration is seen that contains no names to declare.    If its type is a reference to a structure, union or enum inherited    from a containing scope, shadow that tag name for the current scope    with a forward reference.    If its type defines a new named structure or union    or defines an enum, it is valid but we need not do anything here.    Otherwise, it is an error.     C++: may have to grok the declspecs to learn about static,    complain for anonymous unions.  */
end_comment

begin_function
name|void
name|shadow_tag
parameter_list|(
name|declspecs
parameter_list|)
name|tree
name|declspecs
decl_stmt|;
block|{
name|int
name|found_tag
init|=
literal|0
decl_stmt|;
name|int
name|warned
init|=
literal|0
decl_stmt|;
specifier|register
name|tree
name|link
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|code
decl_stmt|,
name|ok_code
init|=
name|ERROR_MARK
decl_stmt|;
specifier|register
name|tree
name|t
init|=
name|NULL_TREE
decl_stmt|;
for|for
control|(
name|link
operator|=
name|declspecs
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
block|{
specifier|register
name|tree
name|value
init|=
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
decl_stmt|;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE_CODE
argument_list|(
name|code
argument_list|)
operator|||
name|code
operator|==
name|ENUMERAL_TYPE
condition|)
comment|/* Used to test also that TYPE_SIZE (value) != 0. 	   That caused warning for `struct foo;' at top level in the file.  */
block|{
specifier|register
name|tree
name|name
init|=
name|TYPE_NAME
argument_list|(
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL_TREE
condition|)
name|name
operator|=
name|lookup_tag_reverse
argument_list|(
name|value
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|&&
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|name
operator|=
name|DECL_NAME
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|class_binding_level
condition|)
name|t
operator|=
name|lookup_tag
argument_list|(
name|code
argument_list|,
name|name
argument_list|,
name|class_binding_level
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|t
operator|=
name|lookup_tag
argument_list|(
name|code
argument_list|,
name|name
argument_list|,
name|current_binding_level
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL_TREE
condition|)
block|{
name|push_obstacks
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|&
name|permanent_obstack
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE_CODE
argument_list|(
name|code
argument_list|)
condition|)
name|t
operator|=
name|make_lang_type
argument_list|(
name|code
argument_list|)
expr_stmt|;
else|else
name|t
operator|=
name|make_node
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|pushtag
argument_list|(
name|name
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
name|ok_code
operator|=
name|code
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|name
operator|!=
name|NULL_TREE
operator|||
name|code
operator|==
name|ENUMERAL_TYPE
condition|)
name|ok_code
operator|=
name|code
expr_stmt|;
if|if
condition|(
name|ok_code
operator|!=
name|ERROR_MARK
condition|)
name|found_tag
operator|++
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|warned
condition|)
name|pedwarn
argument_list|(
literal|"useless keyword or type name in declaration"
argument_list|)
expr_stmt|;
name|warned
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/* This is where the variables in an anonymous union are      declared.  An anonymous union declaration looks like:      union { ... } ;      because there is no declarator after the union, the parser      sends that declaration here.  */
if|if
condition|(
name|ok_code
operator|==
name|UNION_TYPE
operator|&&
name|t
operator|!=
name|NULL_TREE
operator|&&
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|&&
name|ANON_AGGRNAME_P
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|ANON_AGGRNAME_P
argument_list|(
name|TYPE_IDENTIFIER
argument_list|(
name|t
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
block|{
comment|/* ANSI C++ June 5 1992 WP 9.5.3.  Anonymous unions may not have 	 function members.  */
if|if
condition|(
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|decl
init|=
name|grokdeclarator
argument_list|(
name|NULL_TREE
argument_list|,
name|declspecs
argument_list|,
name|NORMAL
argument_list|,
literal|0
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|finish_anon_union
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"anonymous union cannot have a function member"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ok_code
operator|==
name|RECORD_TYPE
operator|&&
name|found_tag
operator|==
literal|1
operator|&&
name|TYPE_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
operator|&&
name|CLASSTYPE_DECLARED_EXCEPTION
argument_list|(
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
condition|)
name|error_with_aggr_type
argument_list|(
name|t
argument_list|,
literal|"redeclaration of exception `%s'"
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|ename
decl_stmt|,
name|decl
decl_stmt|;
name|push_obstacks
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|&
name|permanent_obstack
argument_list|)
expr_stmt|;
name|pushclass
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|finish_exception
argument_list|(
name|t
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|ename
operator|=
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ename
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|ename
operator|=
name|DECL_NAME
argument_list|(
name|ename
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_lang_field_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|ename
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|finish_exception_decl
argument_list|(
name|current_class_name
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|end_exception_decls
argument_list|()
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|warned
operator|&&
name|found_tag
operator|>
literal|1
condition|)
name|warning
argument_list|(
literal|"multiple types in one declaration"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Decode a "typename", such as "int **", returning a ..._TYPE node.  */
end_comment

begin_function
name|tree
name|groktypename
parameter_list|(
name|typename
parameter_list|)
name|tree
name|typename
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|typename
argument_list|)
operator|!=
name|TREE_LIST
condition|)
return|return
name|typename
return|;
return|return
name|grokdeclarator
argument_list|(
name|TREE_VALUE
argument_list|(
name|typename
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|typename
argument_list|)
argument_list|,
name|TYPENAME
argument_list|,
literal|0
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Decode a declarator in an ordinary declaration or data definition.    This is called as soon as the type information and variable name    have been parsed, before parsing the initializer if any.    Here we create the ..._DECL node, fill in its type,    and put it on the list of decls for the current context.    The ..._DECL node is returned as the value.     Exception: for arrays where the length is not specified,    the type is left null, to be filled in by `finish_decl'.     Function definitions do not come here; they go to start_function    instead.  However, external and forward declarations of functions    do go through here.  Structure field declarations are done by    grokfield and not through here.  */
end_comment

begin_comment
comment|/* Set this to zero to debug not using the temporary obstack    to parse initializers.  */
end_comment

begin_decl_stmt
name|int
name|debug_temp_inits
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_function
name|tree
name|start_decl
parameter_list|(
name|declarator
parameter_list|,
name|declspecs
parameter_list|,
name|initialized
parameter_list|,
name|raises
parameter_list|)
name|tree
name|declspecs
decl_stmt|,
name|declarator
decl_stmt|;
name|int
name|initialized
decl_stmt|;
name|tree
name|raises
decl_stmt|;
block|{
specifier|register
name|tree
name|decl
decl_stmt|;
specifier|register
name|tree
name|type
decl_stmt|,
name|tem
decl_stmt|;
name|tree
name|context
decl_stmt|;
specifier|extern
name|int
name|have_extern_spec
decl_stmt|;
specifier|extern
name|int
name|used_extern_spec
decl_stmt|;
name|int
name|init_written
init|=
name|initialized
decl_stmt|;
comment|/* This should only be done once on the top most decl. */
if|if
condition|(
name|have_extern_spec
operator|&&
operator|!
name|used_extern_spec
condition|)
block|{
name|declspecs
operator|=
name|decl_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"extern"
argument_list|)
argument_list|,
name|declspecs
argument_list|)
expr_stmt|;
name|used_extern_spec
operator|=
literal|1
expr_stmt|;
block|}
name|decl
operator|=
name|grokdeclarator
argument_list|(
name|declarator
argument_list|,
name|declspecs
argument_list|,
name|NORMAL
argument_list|,
name|initialized
argument_list|,
name|raises
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|==
name|NULL_TREE
operator|||
name|decl
operator|==
name|void_type_node
condition|)
return|return
name|NULL_TREE
return|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Don't lose if destructors must be executed at file-level.  */
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|TREE_PERMANENT
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|push_obstacks
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|&
name|permanent_obstack
argument_list|)
expr_stmt|;
name|decl
operator|=
name|copy_node
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|tree
name|itype
init|=
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|itype
operator|&&
operator|!
name|TREE_PERMANENT
argument_list|(
name|itype
argument_list|)
condition|)
block|{
name|itype
operator|=
name|build_index_type
argument_list|(
name|copy_to_permanent
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|itype
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_cplus_array_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|itype
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|type
expr_stmt|;
block|}
block|}
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
comment|/* Interesting work for this is done in `finish_exception_decl'.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|CLASSTYPE_DECLARED_EXCEPTION
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|decl
return|;
comment|/* Corresponding pop_obstacks is done in `finish_decl'.  */
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|context
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_VIRTUAL_P
argument_list|(
name|decl
argument_list|)
operator|)
condition|?
name|DECL_CLASS_CONTEXT
argument_list|(
name|decl
argument_list|)
else|:
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
block|{
name|tree
name|d
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
comment|/* Declarator is a call_expr; extract arguments from it, since              grokdeclarator didn't do it.  */
name|tree
name|args
decl_stmt|;
name|args
operator|=
name|copy_to_permanent
argument_list|(
name|last_function_parms
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|tree
name|t
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|t
operator|=
name|TYPE_METHOD_BASETYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* type method belongs to */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|UNINSTANTIATED_P_TYPE
condition|)
block|{
name|t
operator|=
name|build_pointer_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* base type of `this' */
if|#
directive|if
literal|1
comment|/* I suspect this is wrong. */
name|t
operator|=
name|build_type_variant
argument_list|(
name|t
argument_list|,
name|flag_this_is_variable
operator|<=
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* type of `this' */
else|#
directive|else
name|t
operator|=
name|build_type_variant
argument_list|(
name|t
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* type of `this' */
endif|#
directive|endif
name|t
operator|=
name|build
argument_list|(
name|PARM_DECL
argument_list|,
name|t
argument_list|,
name|this_identifier
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|=
name|args
expr_stmt|;
name|args
operator|=
name|t
expr_stmt|;
block|}
block|}
name|DECL_ARGUMENTS
argument_list|(
name|decl
argument_list|)
operator|=
name|args
expr_stmt|;
block|}
name|d
operator|=
name|build_lang_decl
argument_list|(
name|TEMPLATE_DECL
argument_list|,
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|d
argument_list|)
operator|=
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|d
argument_list|)
operator|=
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|d
argument_list|)
operator|=
operator|(
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
operator|(
name|context
operator|&&
operator|!
name|DECL_THIS_EXTERN
argument_list|(
name|decl
argument_list|)
operator|)
operator|)
expr_stmt|;
name|DECL_TEMPLATE_RESULT
argument_list|(
name|d
argument_list|)
operator|=
name|decl
expr_stmt|;
name|DECL_OVERLOADED
argument_list|(
name|d
argument_list|)
operator|=
literal|1
expr_stmt|;
name|decl
operator|=
name|d
expr_stmt|;
block|}
if|if
condition|(
name|context
operator|&&
name|TYPE_SIZE
argument_list|(
name|context
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
comment|/* If it was not explicitly declared `extern', 	 revoke any previous claims of DECL_EXTERNAL.  */
if|if
condition|(
name|DECL_THIS_EXTERN
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
condition|)
name|DECL_IN_AGGR_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|pushclass
argument_list|(
name|context
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/* If this type of object needs a cleanup, and control may      jump past it, make a new binding level so that it is cleaned      up only when it is initialized first.  */
if|if
condition|(
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
operator|&&
name|current_binding_level
operator|->
name|more_cleanups_ok
operator|==
literal|0
condition|)
name|pushlevel_temporary
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|initialized
condition|)
comment|/* Is it valid for this decl to have an initializer at all?        If not, set INITIALIZED to zero, which will indirectly        tell `finish_decl' to ignore the initializer once it is parsed.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
case|case
name|TYPE_DECL
case|:
comment|/* typedef foo = bar  means give foo the same type as bar. 	   We haven't parsed bar yet, so `finish_decl' will fix that up. 	   Any other case of an initialization in a TYPE_DECL is an error.  */
if|if
condition|(
name|pedantic
operator|||
name|list_length
argument_list|(
name|declspecs
argument_list|)
operator|>
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"typedef `%s' is initialized"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|FUNCTION_DECL
case|:
name|error
argument_list|(
literal|"function `%s' is initialized like a variable"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
comment|/* Don't allow initializations for incomplete types 	   except for arrays which might be completed by the initialization.  */
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL_TREE
condition|)
empty_stmt|;
comment|/* A complete type is ok.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|ARRAY_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"variable `%s' has initializer but incomplete type"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"elements of array `%s' have incomplete type"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|initialized
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|TYPE_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|TEMPLATE_DECL
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"aggregate `%s' has incomplete type and cannot be initialized"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Change the type so that assemble_variable will give 	     DECL an rtl we can live with: (mem (const_int 0)).  */
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|type
operator|=
name|error_mark_node
expr_stmt|;
block|}
else|else
block|{
comment|/* If any base type in the hierarchy of TYPE needs a constructor, 	     then we set initialized to 1.  This way any nodes which are 	     created for the purposes of initializing this aggregate 	     will live as long as it does.  This is necessary for global 	     aggregates which do not have their initializers processed until 	     the end of the file.  */
name|initialized
operator|=
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|initialized
condition|)
block|{
if|if
condition|(
name|current_binding_level
operator|!=
name|global_binding_level
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
name|warning
argument_list|(
literal|"declaration of `%s' has `extern' and is initialized"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
condition|)
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Tell `pushdecl' this is an initialized decl 	 even though we don't yet have the initializer expression. 	 Also tell `finish_decl' it may store the real initializer.  */
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
comment|/* Add this decl to the current binding level, but not if it      comes from another scope, e.g. a static member variable.      TEM may equal DECL or it may be a previous decl of the same name.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|PARM_DECL
operator|&&
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TEMPLATE_DECL
operator|&&
operator|!
name|global_bindings_p
argument_list|()
operator|)
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|LANG_TYPE
condition|)
name|tem
operator|=
name|decl
expr_stmt|;
else|else
block|{
name|tem
operator|=
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
name|tree
name|tem2
init|=
name|value_member
argument_list|(
name|decl
argument_list|,
name|tem
argument_list|)
decl_stmt|;
if|if
condition|(
name|tem2
operator|!=
name|NULL_TREE
condition|)
name|tem
operator|=
name|TREE_VALUE
argument_list|(
name|tem2
argument_list|)
expr_stmt|;
else|else
block|{
while|while
condition|(
name|tem
operator|&&
operator|!
name|decls_match
argument_list|(
name|decl
argument_list|,
name|TREE_VALUE
argument_list|(
name|tem
argument_list|)
argument_list|)
condition|)
name|tem
operator|=
name|TREE_CHAIN
argument_list|(
name|tem
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|==
name|NULL_TREE
condition|)
name|tem
operator|=
name|decl
expr_stmt|;
else|else
name|tem
operator|=
name|TREE_VALUE
argument_list|(
name|tem
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|#
directive|if
literal|0
comment|/* We don't do this yet for GNU C++.  */
comment|/* For a local variable, define the RTL now.  */
block|if (current_binding_level != global_binding_level
comment|/* But not if this is a duplicate decl 	 and we preserved the rtl from the previous one 	 (which may or may not happen).  */
block|&& DECL_RTL (tem) == NULL_RTX)     {       if (TYPE_SIZE (TREE_TYPE (tem)) != NULL_TREE) 	expand_decl (tem);       else if (TREE_CODE (TREE_TYPE (tem)) == ARRAY_TYPE&& DECL_INITIAL (tem) != NULL_TREE) 	expand_decl (tem);     }
endif|#
directive|endif
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_OVERLOADED
argument_list|(
name|decl
argument_list|)
condition|)
comment|/* @@ Also done in start_function.  */
name|tem
operator|=
name|push_overloaded_decl
argument_list|(
name|tem
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
name|tree
name|result
init|=
name|DECL_TEMPLATE_RESULT
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|result
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
name|tree
name|type
decl_stmt|;
name|type
operator|=
name|DECL_CONTEXT
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNINSTANTIATED_P_TYPE
argument_list|,
literal|145
argument_list|)
expr_stmt|;
if|if
condition|(
comment|/* TREE_CODE (result) == VAR_DECL */
literal|1
condition|)
block|{
if|#
directive|if
literal|0
block|tree tmpl = UPT_TEMPLATE (type); 	       	      fprintf (stderr, "%s:%d: adding ", __FILE__, __LINE__); 	      print_node_brief (stderr, "", DECL_NAME (tem), 0); 	      fprintf (stderr, " to class %s\n", 		       IDENTIFIER_POINTER (DECL_NAME (tmpl)));               DECL_TEMPLATE_MEMBERS (tmpl)                 = perm_tree_cons (DECL_NAME (tem), tem, 				  DECL_TEMPLATE_MEMBERS (tmpl));
endif|#
directive|endif
return|return
name|tem
return|;
block|}
name|my_friendly_abort
argument_list|(
literal|13
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|result
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|tem
operator|=
name|push_overloaded_decl
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|result
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|result
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|error
argument_list|(
literal|"invalid template `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|result
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
else|else
name|my_friendly_abort
argument_list|(
literal|14
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|init_written
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|PARM_DECL
operator|||
operator|(
name|TREE_READONLY
argument_list|(
name|tem
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|FIELD_DECL
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* When parsing and digesting the initializer, 	 use temporary storage.  Do this even if we will ignore the value.  */
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
operator|&&
name|debug_temp_inits
condition|)
block|{
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
comment|/* In this case, the initializer must lay down in permanent 	       storage, since it will be saved until `finish_file' is run.   */
empty_stmt|;
else|else
name|temporary_allocation
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|flag_cadillac
condition|)
name|cadillac_start_decl
argument_list|(
name|tem
argument_list|)
expr_stmt|;
return|return
name|tem
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|make_temporary_for_reference
parameter_list|(
name|decl
parameter_list|,
name|ctor_call
parameter_list|,
name|init
parameter_list|,
name|cleanupp
parameter_list|)
name|tree
name|decl
decl_stmt|,
name|ctor_call
decl_stmt|,
name|init
decl_stmt|;
name|tree
modifier|*
name|cleanupp
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|tree
name|target_type
init|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|tmp
decl_stmt|,
name|tmp_addr
decl_stmt|;
if|if
condition|(
name|ctor_call
condition|)
block|{
name|tmp_addr
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ctor_call
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tmp_addr
argument_list|)
operator|==
name|NOP_EXPR
condition|)
name|tmp_addr
operator|=
name|TREE_OPERAND
argument_list|(
name|tmp_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|tmp_addr
argument_list|)
operator|==
name|ADDR_EXPR
argument_list|,
literal|146
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|TREE_OPERAND
argument_list|(
name|tmp_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tmp
operator|=
name|get_temp_name
argument_list|(
name|target_type
argument_list|,
name|current_binding_level
operator|==
name|global_binding_level
argument_list|)
expr_stmt|;
name|tmp_addr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|tmp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|TREE_TYPE
argument_list|(
name|tmp_addr
argument_list|)
operator|=
name|build_pointer_type
argument_list|(
name|target_type
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|convert
argument_list|(
name|TYPE_POINTER_TO
argument_list|(
name|target_type
argument_list|)
argument_list|,
name|tmp_addr
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|target_type
argument_list|)
condition|)
block|{
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
condition|)
block|{
comment|/* lay this variable out now.  Otherwise `output_addressed_constants' 	     gets confused by its initializer.  */
name|make_decl_rtl
argument_list|(
name|tmp
argument_list|,
name|NULL_PTR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|static_aggregates
operator|=
name|perm_tree_cons
argument_list|(
name|init
argument_list|,
name|tmp
argument_list|,
name|static_aggregates
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ctor_call
operator|!=
name|NULL_TREE
condition|)
name|init
operator|=
name|ctor_call
expr_stmt|;
else|else
name|init
operator|=
name|build_method_call
argument_list|(
name|tmp
argument_list|,
name|constructor_name
argument_list|(
name|target_type
argument_list|)
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|init
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|type
argument_list|,
name|init
argument_list|,
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|cleanupp
operator|=
name|maybe_build_cleanup
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|DECL_INITIAL
argument_list|(
name|tmp
argument_list|)
operator|=
name|init
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|tmp
argument_list|)
operator|=
name|current_binding_level
operator|==
name|global_binding_level
expr_stmt|;
name|finish_decl
argument_list|(
name|tmp
argument_list|,
name|init
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|tmp
argument_list|)
condition|)
name|preserve_initializer
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle initialization of references.    These three arguments from from `finish_decl', and have the    same meaning here that they do there.  */
end_comment

begin_comment
comment|/* quotes on semantics can be found in ARM 8.4.3. */
end_comment

begin_function
specifier|static
name|void
name|grok_reference_init
parameter_list|(
name|decl
parameter_list|,
name|type
parameter_list|,
name|init
parameter_list|,
name|cleanupp
parameter_list|)
name|tree
name|decl
decl_stmt|,
name|type
decl_stmt|,
name|init
decl_stmt|;
name|tree
modifier|*
name|cleanupp
decl_stmt|;
block|{
name|char
modifier|*
name|errstr
init|=
name|NULL
decl_stmt|;
name|int
name|is_reference
decl_stmt|;
name|tree
name|tmp
decl_stmt|;
name|tree
name|this_ptr_type
decl_stmt|,
name|actual_init
decl_stmt|;
if|if
condition|(
name|init
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|||
name|DECL_IN_AGGR_P
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"variable declared as reference not initialized"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|SET_DECL_REFERENCE_SLOT
argument_list|(
name|decl
argument_list|,
name|error_mark_node
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|init
operator|=
name|build_compound_expr
argument_list|(
name|init
argument_list|)
expr_stmt|;
name|is_reference
operator|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
expr_stmt|;
name|tmp
operator|=
name|is_reference
condition|?
name|convert_from_reference
argument_list|(
name|init
argument_list|)
else|:
name|init
expr_stmt|;
if|if
condition|(
name|is_reference
condition|)
block|{
if|if
condition|(
operator|!
name|comptypes
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|tmp
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
name|errstr
operator|=
literal|"initialization of `%s' from dissimilar reference type"
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|>=
name|TYPE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|is_reference
operator|=
literal|0
expr_stmt|;
name|init
operator|=
name|tmp
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|ARRAY_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
comment|/* Note: default conversion is only called in very 	     special cases.  */
name|init
operator|=
name|default_conversion
argument_list|(
name|init
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|comptypes
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* This section implements ANSI C++ June 5 1992 WP 8.4.3.5. */
comment|/* A reference to a volatile T cannot be initialized with 		 a const T, and vice-versa.  */
if|if
condition|(
name|TYPE_VOLATILE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
name|TREE_READONLY
argument_list|(
name|init
argument_list|)
condition|)
name|errstr
operator|=
literal|"cannot initialize a reference to a volatile T with a const T"
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
name|TREE_THIS_VOLATILE
argument_list|(
name|init
argument_list|)
condition|)
name|errstr
operator|=
literal|"cannot initialize a reference to a const T with a volatile T"
expr_stmt|;
comment|/* A reference to a plain T can be initialized only with 		 a plain T.  */
elseif|else
if|if
condition|(
operator|!
name|TYPE_VOLATILE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
operator|!
name|TYPE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|init
argument_list|)
condition|)
name|errstr
operator|=
literal|"cannot initialize a reference to T with a const T"
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|init
argument_list|)
condition|)
name|errstr
operator|=
literal|"cannot initialize a reference to T with a volatile T"
expr_stmt|;
block|}
block|}
else|else
name|init
operator|=
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|init
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|init
operator|!=
name|error_mark_node
operator|&&
operator|!
name|comptypes
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
name|errstr
operator|=
literal|"invalid type conversion for reference"
expr_stmt|;
block|}
if|if
condition|(
name|errstr
condition|)
block|{
comment|/* Things did not go smoothly; look for operator& type conversion.  */
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|tmp
argument_list|)
argument_list|)
condition|)
block|{
name|tmp
operator|=
name|build_type_conversion
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|type
argument_list|,
name|init
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
name|NULL_TREE
condition|)
block|{
name|init
operator|=
name|tmp
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|error_mark_node
condition|)
name|errstr
operator|=
literal|"ambiguous pointer conversion"
expr_stmt|;
else|else
name|errstr
operator|=
name|NULL
expr_stmt|;
name|is_reference
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|tmp
operator|=
name|build_type_conversion
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|init
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
name|NULL_TREE
condition|)
block|{
name|init
operator|=
name|tmp
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|error_mark_node
condition|)
name|errstr
operator|=
literal|"ambiguous pointer conversion"
expr_stmt|;
else|else
name|errstr
operator|=
name|NULL
expr_stmt|;
name|is_reference
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
comment|/* Look for constructor.  */
elseif|else
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
name|tmp
operator|=
name|get_temp_name
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|current_binding_level
operator|==
name|global_binding_level
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|build_method_call
argument_list|(
name|tmp
argument_list|,
name|constructor_name
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|init
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL_TREE
operator|||
name|tmp
operator|==
name|error_mark_node
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|SET_DECL_REFERENCE_SLOT
argument_list|(
name|decl
argument_list|,
name|error_mark_node
argument_list|)
expr_stmt|;
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"constructor failed to build reference initializer"
argument_list|)
expr_stmt|;
return|return;
block|}
name|make_temporary_for_reference
argument_list|(
name|decl
argument_list|,
name|tmp
argument_list|,
name|init
argument_list|,
name|cleanupp
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
if|if
condition|(
name|errstr
condition|)
block|{
name|error_with_decl
argument_list|(
name|decl
argument_list|,
name|errstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|SET_DECL_REFERENCE_SLOT
argument_list|(
name|decl
argument_list|,
name|error_mark_node
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* In the case of initialization, it is permissible      to assign one reference to another.  */
name|this_ptr_type
operator|=
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_reference
condition|)
block|{
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|init
argument_list|)
condition|)
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|save_expr
argument_list|(
name|init
argument_list|)
expr_stmt|;
else|else
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|init
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lvalue_p
argument_list|(
name|init
argument_list|)
condition|)
block|{
name|tmp
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|init
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|WITH_CLEANUP_EXPR
condition|)
block|{
comment|/* Associate the cleanup with the reference so that we 	     don't get burned by "aggressive" cleanup policy.  */
operator|*
name|cleanupp
operator|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|2
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|this_ptr_type
argument_list|)
argument_list|)
condition|)
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|convert_pointer_to
argument_list|(
name|TREE_TYPE
argument_list|(
name|this_ptr_type
argument_list|)
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
else|else
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|convert
argument_list|(
name|this_ptr_type
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|save_expr
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|current_class_decl
condition|)
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|copy_node
argument_list|(
name|current_class_decl
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
name|type
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|actual_init
operator|=
name|unary_complex_lvalue
argument_list|(
name|ADDR_EXPR
argument_list|,
name|init
argument_list|)
operator|)
condition|)
block|{
comment|/* The initializer for this decl goes into its 	 DECL_REFERENCE_SLOT.  Make sure that we can handle 	 multiple evaluations without ill effect.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|actual_init
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|actual_init
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|TARGET_EXPR
condition|)
name|actual_init
operator|=
name|save_expr
argument_list|(
name|actual_init
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|convert_pointer_to
argument_list|(
name|TREE_TYPE
argument_list|(
name|this_ptr_type
argument_list|)
argument_list|,
name|actual_init
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|save_expr
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
name|type
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
comment|/* Section 8.4.3 allows us to make a temporary for        the initialization of const&.  */
name|make_temporary_for_reference
argument_list|(
name|decl
argument_list|,
name|NULL_TREE
argument_list|,
name|init
argument_list|,
name|cleanupp
argument_list|)
expr_stmt|;
else|else
block|{
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"type mismatch in initialization of `%s' (use `const')"
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
name|done
label|:
comment|/* ?? Can this be optimized in some cases to      hand back the DECL_INITIAL slot??  */
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
name|init
operator|=
name|convert_from_reference
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_PERMANENT
argument_list|(
name|decl
argument_list|)
condition|)
name|init
operator|=
name|copy_to_permanent
argument_list|(
name|init
argument_list|)
expr_stmt|;
name|SET_DECL_REFERENCE_SLOT
argument_list|(
name|decl
argument_list|,
name|init
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_CONSTANT
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
name|expand_static_init
argument_list|(
name|decl
argument_list|,
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Finish processing of a declaration;    install its line number and initial value.    If the length of an array type is not known before,    it must be determined now, from the initial value, or it is an error.     Call `pop_obstacks' iff NEED_POP is nonzero.     For C++, `finish_decl' must be fairly evasive:  it must keep initializers    for aggregates that have constructors alive on the permanent obstack,    so that the global initializing functions can be written at the end.     INIT0 holds the value of an initializer that should be allowed to escape    the normal rules.     For functions that take default parameters, DECL points to its    "maximal" instantiation.  `finish_decl' must then also declared its    subsequently lower and lower forms of instantiation, checking for    ambiguity as it goes.  This can be sped up later.  */
end_comment

begin_function
name|void
name|finish_decl
parameter_list|(
name|decl
parameter_list|,
name|init
parameter_list|,
name|asmspec_tree
parameter_list|,
name|need_pop
parameter_list|)
name|tree
name|decl
decl_stmt|,
name|init
decl_stmt|;
name|tree
name|asmspec_tree
decl_stmt|;
name|int
name|need_pop
decl_stmt|;
block|{
specifier|register
name|tree
name|type
decl_stmt|;
name|tree
name|cleanup
init|=
name|NULL_TREE
decl_stmt|,
name|ttype
decl_stmt|;
name|int
name|was_incomplete
decl_stmt|;
name|int
name|temporary
init|=
name|allocation_temporary_p
argument_list|()
decl_stmt|;
name|char
modifier|*
name|asmspec
init|=
name|NULL
decl_stmt|;
name|int
name|was_readonly
init|=
literal|0
decl_stmt|;
comment|/* If this is 0, then we did not change obstacks.  */
if|if
condition|(
operator|!
name|decl
condition|)
block|{
if|if
condition|(
name|init
condition|)
name|error
argument_list|(
literal|"assignment (not initialization) in declaration"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|asmspec_tree
condition|)
block|{
name|asmspec
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|asmspec_tree
argument_list|)
expr_stmt|;
comment|/* Zero out old RTL, since we will rewrite it.  */
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|=
name|NULL_RTX
expr_stmt|;
block|}
comment|/* If the type of the thing we are declaring either has      a constructor, or has a virtual function table pointer,      AND its initialization was accepted by `start_decl',      then we stayed on the permanent obstack through the      declaration, otherwise, changed obstacks as GCC would.  */
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|was_incomplete
operator|=
operator|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
operator|)
expr_stmt|;
comment|/* Take care of TYPE_DECLs up front.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
if|if
condition|(
name|init
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* typedef foo = bar; store the type of bar as the type of foo.  */
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|init
operator|=
name|NULL_TREE
expr_stmt|;
block|}
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
operator|&&
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|&&
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|!=
name|type
condition|)
name|warning
argument_list|(
literal|"shadowing previous type declaration of `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|set_identifier_type_value
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|CLASSTYPE_GOT_SEMICOLON
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|GNU_xref_decl
argument_list|(
name|current_function_decl
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|rest_of_decl_compilation
argument_list|(
name|decl
argument_list|,
name|NULL_PTR
argument_list|,
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|finish_end
goto|;
block|}
if|if
condition|(
name|type
operator|!=
name|error_mark_node
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
operator|&&
name|CLASSTYPE_DECLARED_EXCEPTION
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|finish_exception_decl
argument_list|(
name|NULL_TREE
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|CLASSTYPE_GOT_SEMICOLON
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
goto|goto
name|finish_end
goto|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
block|{
name|ttype
operator|=
name|target_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* WTF?  -KR 	 Leave this out until we can figure out why it was 	 needed/desirable in the first place.  Then put a comment 	 here explaining why.  Or just delete the code if no ill 	 effects arise.  */
block|if (TYPE_NAME (ttype)&& TREE_CODE (TYPE_NAME (ttype)) == TYPE_DECL&& ANON_AGGRNAME_P (TYPE_IDENTIFIER (ttype))) 	{ 	  tree old_id = TYPE_IDENTIFIER (ttype); 	  char *newname = (char *)alloca (IDENTIFIER_LENGTH (old_id) + 2);
comment|/* Need to preserve template data for UPT nodes.  */
block|tree old_template = IDENTIFIER_TEMPLATE (old_id); 	  newname[0] = '_'; 	  bcopy (IDENTIFIER_POINTER (old_id), newname + 1, 		 IDENTIFIER_LENGTH (old_id) + 1); 	  old_id = get_identifier (newname); 	  lookup_tag_reverse (ttype, old_id); 	  TYPE_IDENTIFIER (ttype) = old_id; 	  IDENTIFIER_TEMPLATE (old_id) = old_template; 	}
endif|#
directive|endif
block|}
if|if
condition|(
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|&&
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* Currently, GNU C++ puts constants in text space, making them 	 impossible to initialize.  In the future, one would hope for 	 an operating system which understood the difference between 	 initialization and the running of a program.  */
name|was_readonly
operator|=
literal|1
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
if|if
condition|(
name|init
operator|&&
name|init
operator|!=
name|error_mark_node
condition|)
name|my_friendly_assert
argument_list|(
name|TREE_PERMANENT
argument_list|(
name|init
argument_list|)
argument_list|,
literal|147
argument_list|)
expr_stmt|;
if|if
condition|(
name|asmspec
condition|)
block|{
comment|/* This must override the asm specifier which was placed 	     by grokclassfn.  Lay this out fresh. 	      	     @@ Should emit an error if this redefines an asm-specified 	     @@ name, or if we have already used the function's name.  */
name|DECL_RTL
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
name|NULL_RTX
expr_stmt|;
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
operator|=
name|get_identifier
argument_list|(
name|asmspec
argument_list|)
expr_stmt|;
name|make_decl_rtl
argument_list|(
name|decl
argument_list|,
name|asmspec
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If `start_decl' didn't like having an initialization, ignore it now.  */
elseif|else
if|if
condition|(
name|init
operator|!=
name|NULL_TREE
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|init
operator|=
name|NULL_TREE
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|grok_reference_init
argument_list|(
name|decl
argument_list|,
name|type
argument_list|,
name|init
argument_list|,
operator|&
name|cleanup
argument_list|)
expr_stmt|;
name|init
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|GNU_xref_decl
argument_list|(
name|current_function_decl
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FIELD_DECL
operator|||
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|CONST_DECL
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|REFERENCE_TYPE
argument_list|,
literal|148
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|init
expr_stmt|;
comment|/* This will keep us from needing to worry about our obstacks.  */
name|my_friendly_assert
argument_list|(
name|init
operator|!=
name|NULL_TREE
argument_list|,
literal|149
argument_list|)
expr_stmt|;
name|init
operator|=
name|NULL_TREE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|init
condition|)
block|{
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|init
operator|=
name|digest_init
argument_list|(
name|type
argument_list|,
name|init
argument_list|,
operator|(
name|tree
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|CONSTRUCTOR
operator|&&
name|CONSTRUCTOR_ELTS
argument_list|(
name|init
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"`%s' must be initialized by constructor, not by `{...}'"
argument_list|)
expr_stmt|;
name|init
operator|=
name|error_mark_node
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* fix this in `build_functional_cast' instead. 	     Here's the trigger code:  		struct ostream 		{ 		  ostream (); 		  ostream (int, char *); 		  ostream (char *); 		  operator char *(); 		  ostream (void *); 		  operator void *(); 		  operator<< (int); 		}; 		int buf_size = 1024; 		static char buf[buf_size]; 		const char *debug(int i) { 		  char *b =&buf[0]; 		  ostream o = ostream(buf_size, b); 		  o<< i; 		  return buf; 		} 		*/
block|else if (TREE_CODE (init) == TARGET_EXPR&& TREE_CODE (TREE_OPERAND (init, 1) == NEW_EXPR)) 	    {
comment|/* User wrote something like `foo x = foo (args)'  */
block|my_friendly_assert (TREE_CODE (TREE_OPERAND (init, 0)) == VAR_DECL, 150); 	      my_friendly_assert (DECL_NAME (TREE_OPERAND (init, 0)) == NULL_TREE, 151);
comment|/* User wrote exactly `foo x = foo (args)'  */
block|if (TYPE_MAIN_VARIANT (type) == TREE_TYPE (init)) 		{ 		  init = build (CALL_EXPR, TREE_TYPE (init), 				TREE_OPERAND (TREE_OPERAND (init, 1), 0), 				TREE_OPERAND (TREE_OPERAND (init, 1), 1), 0); 		  TREE_SIDE_EFFECTS (init) = 1; 		} 	    }
endif|#
directive|endif
comment|/* We must hide the initializer so that expand_decl 	     won't try to do something it does not understand.  */
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
condition|)
block|{
name|tree
name|value
init|=
name|digest_init
argument_list|(
name|type
argument_list|,
name|empty_init_node
argument_list|,
operator|(
name|tree
operator|*
operator|)
literal|0
argument_list|)
decl_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|value
expr_stmt|;
block|}
else|else
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|!=
name|TREE_VEC
condition|)
name|init
operator|=
name|store_init_value
argument_list|(
name|decl
argument_list|,
name|init
argument_list|)
expr_stmt|;
if|if
condition|(
name|init
condition|)
comment|/* Don't let anyone try to initialize this variable 	       until we are ready to do so.  */
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
literal|'t'
operator|&&
operator|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
operator|||
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
operator|)
condition|)
block|{
name|tree
name|ctype
init|=
name|type
decl_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|ctype
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|ctype
operator|=
name|TREE_TYPE
argument_list|(
name|ctype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_NEEDS_CONSTRUCTOR
argument_list|(
name|ctype
argument_list|)
condition|)
block|{
if|if
condition|(
name|CLASSTYPE_READONLY_FIELDS_NEED_INIT
argument_list|(
name|ctype
argument_list|)
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"structure `%s' with uninitialized const members"
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_REF_FIELDS_NEED_INIT
argument_list|(
name|ctype
argument_list|)
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"structure `%s' with uninitialized reference members"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
operator|!
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
name|TYPE_READONLY
argument_list|(
name|type
argument_list|)
operator|||
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"uninitialized const `%s'"
argument_list|)
expr_stmt|;
comment|/* Initialize variables in need of static initialization 	 with `empty_init_node' to keep assemble_variable from putting them 	 in the wrong program space.  (Common storage is okay for non-public 	 uninitialized data; the linker can't match it with storage from other 	 files, and we may save some disk space.)  */
if|if
condition|(
name|flag_pic
operator|==
literal|0
operator|&&
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
operator|||
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|error_mark_node
operator|)
condition|)
block|{
name|tree
name|value
init|=
name|digest_init
argument_list|(
name|type
argument_list|,
name|empty_init_node
argument_list|,
operator|(
name|tree
operator|*
operator|)
literal|0
argument_list|)
decl_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|value
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|REFERENCE_TYPE
operator|&&
operator|(
name|TYPE_READONLY
argument_list|(
name|type
argument_list|)
operator|||
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
block|{
comment|/* ``Unless explicitly declared extern, a const object does not have 	 external linkage and must be initialized. ($8.4; $12.1)'' ARM 7.1.6 	 However, if it's `const int foo = 1; const int foo;', don't complain 	 about the second decl, since it does have an initializer before.  */
if|if
condition|(
operator|!
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|&&
operator|(
operator|!
name|pedantic
operator|||
operator|!
name|current_class_type
operator|)
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"uninitialized const `%s'"
argument_list|)
expr_stmt|;
block|}
comment|/* For top-level declaration, the initial value was read in      the temporary obstack.  MAXINDEX, rtl, etc. to be made below      must go in the permanent obstack; but don't discard the      temporary data yet.  */
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
operator|&&
name|temporary
condition|)
name|end_temporary_allocation
argument_list|()
expr_stmt|;
comment|/* Deduce size of array from initialization, if not already known.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
block|{
name|int
name|do_default
init|=
operator|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
comment|/* Even if pedantic, an external linkage array 	      may have incomplete type at first.  */
condition|?
name|pedantic
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
else|:
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|)
decl_stmt|;
name|tree
name|initializer
init|=
name|init
condition|?
name|init
else|:
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|int
name|failure
init|=
name|complete_array_type
argument_list|(
name|type
argument_list|,
name|initializer
argument_list|,
name|do_default
argument_list|)
decl_stmt|;
if|if
condition|(
name|failure
operator|==
literal|1
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"initializer fails to determine size of `%s'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|failure
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|do_default
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"array size missing in `%s'"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|pedantic
operator|&&
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|)
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|pedantic
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|tree_int_cst_lt
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"zero-size array `%s'"
argument_list|)
expr_stmt|;
name|layout_decl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* A static variable with an incomplete type: 	     that is an error if it is initialized or `static'. 	     Otherwise, let it through, but if it is not `extern' 	     then it may cause an error message later.  */
if|if
condition|(
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"storage size of `%s' isn't known"
argument_list|)
expr_stmt|;
name|init
operator|=
name|NULL_TREE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* An automatic variable with an incomplete type: that is an error. 	     Don't talk about array types here, since we took care of that 	     message in grokdeclarator.  */
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"storage size of `%s' isn't known"
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|ttype
argument_list|)
condition|)
comment|/* Let debugger know it should output info for this type.  */
name|note_debug_info_needed
argument_list|(
name|ttype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|||
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|)
operator|&&
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
operator|!
name|TREE_CONSTANT
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"storage size of `%s' isn't constant"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|int
name|yes
init|=
name|suspend_momentary
argument_list|()
decl_stmt|;
comment|/* If INIT comes from a functional cast, use the cleanup 	     we built for that.  Otherwise, make our own cleanup.  */
if|if
condition|(
name|init
operator|&&
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|WITH_CLEANUP_EXPR
operator|&&
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|cleanup
operator|=
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|init
operator|=
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|current_binding_level
operator|->
name|have_cleanups
operator|=
literal|1
expr_stmt|;
name|current_binding_level
operator|->
name|more_exceptions_ok
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|cleanup
operator|=
name|maybe_build_cleanup
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|resume_momentary
argument_list|(
name|yes
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* PARM_DECLs get cleanups, too.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|PARM_DECL
operator|&&
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|temporary
condition|)
name|end_temporary_allocation
argument_list|()
expr_stmt|;
name|cleanup
operator|=
name|maybe_build_cleanup
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|temporary
condition|)
name|resume_temporary_allocation
argument_list|()
expr_stmt|;
block|}
comment|/* Output the assembler code and/or RTL code for variables and functions,      unless the type is an undefined structure or union.      If not, it will get done when the type is completed.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|RESULT_DECL
condition|)
block|{
name|int
name|toplev
init|=
name|current_binding_level
operator|==
name|global_binding_level
decl_stmt|;
name|int
name|was_temp
init|=
operator|(
operator|(
name|flag_traditional
operator|||
operator|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
operator|)
operator|)
operator|&&
name|allocation_temporary_p
argument_list|()
operator|)
decl_stmt|;
if|if
condition|(
name|was_temp
condition|)
name|end_temporary_allocation
argument_list|()
expr_stmt|;
comment|/* If we are in need of a cleanup, get out of any implicit 	 handlers that have been established so far.  */
if|if
condition|(
name|cleanup
operator|&&
name|current_binding_level
operator|->
name|parm_flag
operator|==
literal|3
condition|)
block|{
name|pop_implicit_try_blocks
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|current_binding_level
operator|->
name|more_exceptions_ok
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|current_binding_level
operator|!=
name|global_binding_level
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|type_needs_gc_entry
argument_list|(
name|type
argument_list|)
condition|)
name|DECL_GC_OFFSET
argument_list|(
name|decl
argument_list|)
operator|=
name|size_int
argument_list|(
operator|++
name|current_function_obstack_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_VIRTUAL_P
argument_list|(
name|decl
argument_list|)
condition|)
name|make_decl_rtl
argument_list|(
name|decl
argument_list|,
name|NULL_PTR
argument_list|,
name|toplev
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
name|error_mark_node
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
name|empty_init_node
condition|)
block|{
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|save_expr
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|asmspec
condition|)
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
operator|=
name|get_identifier
argument_list|(
name|asmspec
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|toplev
operator|&&
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
operator|&&
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|BLKmode
condition|)
block|{
comment|/* If this variable is really a constant, then fill its DECL_RTL 		 slot with something which won't take up storage. 		 If something later should take its address, we can always give 		 it legitimate RTL at that time.  */
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|=
name|gen_reg_rtx
argument_list|(
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|store_expr
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|,
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|toplev
condition|)
block|{
comment|/* Keep GCC from complaining that this variable 		 is defined but never used.  */
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* If this is a static const, change its apparent linkage 		 if it belongs to a #pragma interface.  */
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|interface_unknown
condition|)
block|{
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
name|interface_only
expr_stmt|;
block|}
name|make_decl_rtl
argument_list|(
name|decl
argument_list|,
name|asmspec
argument_list|,
name|toplev
argument_list|)
expr_stmt|;
block|}
else|else
name|rest_of_decl_compilation
argument_list|(
name|decl
argument_list|,
name|asmspec
argument_list|,
name|toplev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_IN_AGGR_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|)
if|if
condition|(
name|init
operator|==
name|NULL_TREE
ifdef|#
directive|ifdef
name|DEFAULT_STATIC_DEFS
comment|/* If this code is dead, then users must 		   explicitly declare static member variables 		   outside the class def'n as well.  */
operator|&&
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
endif|#
directive|endif
condition|)
block|{
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|make_decl_rtl
argument_list|(
name|decl
argument_list|,
name|asmspec
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|rest_of_decl_compilation
argument_list|(
name|decl
argument_list|,
name|asmspec
argument_list|,
name|toplev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
comment|/* Just a constant field.  Should not need any rtl.  */
goto|goto
name|finish_end0
goto|;
block|}
else|else
name|rest_of_decl_compilation
argument_list|(
name|decl
argument_list|,
name|asmspec
argument_list|,
name|toplev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|was_temp
condition|)
name|resume_temporary_allocation
argument_list|()
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|error_mark_node
operator|&&
name|TYPE_LANG_SPECIFIC
argument_list|(
name|type
argument_list|)
operator|&&
name|CLASSTYPE_ABSTRACT_VIRTUALS
argument_list|(
name|type
argument_list|)
condition|)
name|abstract_virtuals_error
argument_list|(
name|decl
argument_list|,
name|type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
operator|)
operator|&&
name|TYPE_LANG_SPECIFIC
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
name|CLASSTYPE_ABSTRACT_VIRTUALS
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|abstract_virtuals_error
argument_list|(
name|decl
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
comment|/* C++: Handle overloaded functions with default parameters.  */
if|if
condition|(
name|DECL_OVERLOADED
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|tree
name|parmtypes
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|prev
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|original_name
init|=
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|struct
name|lang_decl
modifier|*
name|tmp_lang_decl
init|=
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
decl_stmt|;
comment|/* All variants will share an uncollectible lang_decl.  */
name|copy_decl_lang_specific
argument_list|(
name|decl
argument_list|)
expr_stmt|;
while|while
condition|(
name|parmtypes
operator|&&
name|parmtypes
operator|!=
name|void_list_node
condition|)
block|{
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|parmtypes
argument_list|)
condition|)
block|{
name|tree
name|fnname
decl_stmt|,
name|fndecl
decl_stmt|;
name|tree
modifier|*
name|argp
init|=
name|prev
condition|?
operator|&
name|TREE_CHAIN
argument_list|(
name|prev
argument_list|)
else|:
operator|&
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
decl_stmt|;
operator|*
name|argp
operator|=
name|NULL_TREE
expr_stmt|;
name|fnname
operator|=
name|build_decl_overload
argument_list|(
name|original_name
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|argp
operator|=
name|parmtypes
expr_stmt|;
name|fndecl
operator|=
name|build_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|fnname
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|fndecl
argument_list|)
operator|=
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|fndecl
argument_list|)
operator|=
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_INLINE
argument_list|(
name|fndecl
argument_list|)
operator|=
name|DECL_INLINE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Keep G++ from thinking this function is unused. 			 It is only used to speed up search in name space.  */
name|TREE_USED
argument_list|(
name|fndecl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_ASM_WRITTEN
argument_list|(
name|fndecl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|fndecl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|DECL_LANG_SPECIFIC
argument_list|(
name|fndecl
argument_list|)
operator|=
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|fndecl
operator|=
name|pushdecl
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|fndecl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|DECL_RTL
argument_list|(
name|fndecl
argument_list|)
operator|=
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
name|prev
operator|=
name|parmtypes
expr_stmt|;
name|parmtypes
operator|=
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
expr_stmt|;
block|}
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
operator|=
name|tmp_lang_decl
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|type
operator|!=
name|error_mark_node
condition|)
block|{
comment|/* Cleanups for static variables are handled by `finish_file'.  */
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
operator|||
name|init
operator|!=
name|NULL_TREE
condition|)
name|expand_static_init
argument_list|(
name|decl
argument_list|,
name|init
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
name|static_aggregates
operator|=
name|perm_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|decl
argument_list|,
name|static_aggregates
argument_list|)
expr_stmt|;
comment|/* Make entry in appropriate vector.  */
if|if
condition|(
name|flag_gc
operator|&&
name|type_needs_gc_entry
argument_list|(
name|type
argument_list|)
condition|)
name|build_static_gc_entry
argument_list|(
name|decl
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|current_binding_level
operator|!=
name|global_binding_level
condition|)
block|{
comment|/* This is a declared decl which must live until the 	     end of the binding contour.  It may need a cleanup.  */
comment|/* Recompute the RTL of a local array now 	     if it used to be an incomplete type.  */
if|if
condition|(
name|was_incomplete
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* If we used it already as memory, it must stay in memory.  */
name|TREE_ADDRESSABLE
argument_list|(
name|decl
argument_list|)
operator|=
name|TREE_USED
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* If it's still incomplete now, no init will save it.  */
if|if
condition|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|expand_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|&&
operator|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|)
condition|)
block|{
comment|/* Do this here, because we did not expand this decl's 		 rtl in start_decl.  */
if|if
condition|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_RTX
condition|)
name|expand_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cleanup
condition|)
block|{
name|expand_decl_cleanup
argument_list|(
name|NULL_TREE
argument_list|,
name|cleanup
argument_list|)
expr_stmt|;
comment|/* Cleanup used up here.  */
name|cleanup
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|&&
name|type
operator|!=
name|error_mark_node
condition|)
block|{
comment|/* Compute and store the initial value.  */
name|expand_decl_init
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|init
operator|||
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|emit_line_note
argument_list|(
name|DECL_SOURCE_FILE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|expand_aggr_init
argument_list|(
name|decl
argument_list|,
name|init
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Set this to 0 so we can tell whether an aggregate 		 which was initialized was ever used.  */
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
condition|)
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Store the cleanup, if there was one.  */
if|if
condition|(
name|cleanup
condition|)
block|{
if|if
condition|(
operator|!
name|expand_decl_cleanup
argument_list|(
name|decl
argument_list|,
name|cleanup
argument_list|)
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"parser lost in parsing declaration of `%s'"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|finish_end0
label|:
comment|/* Undo call to `pushclass' that was done in `start_decl' 	 due to initialization of qualified member variable. 	 I.e., Foo::x = 10;  */
block|{
name|tree
name|context
init|=
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|context
operator|&&
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|context
argument_list|)
argument_list|)
operator|==
literal|'t'
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
comment|/* We also have a pushclass done that we need to undo here 		   if we're at top level and declare a method.  */
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
comment|/* If size hasn't been set, we're still defining it, 		       and therefore inside the class body; don't pop 		       the binding level..  */
operator|&&
name|TYPE_SIZE
argument_list|(
name|context
argument_list|)
operator|!=
name|NULL_TREE
comment|/* The binding level gets popped elsewhere for a 		       friend declaration inside another class.  */
operator|&&
name|TYPE_IDENTIFIER
argument_list|(
name|context
argument_list|)
operator|==
name|current_class_name
operator|)
operator|)
condition|)
name|popclass
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|finish_end
label|:
if|if
condition|(
name|need_pop
condition|)
block|{
comment|/* Resume permanent allocation, if not within a function.  */
comment|/* The corresponding push_obstacks_nochange is in start_decl, 	 start_method, groktypename, and in grokfield.  */
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|was_readonly
condition|)
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|flag_cadillac
condition|)
name|cadillac_finish_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|expand_static_init
parameter_list|(
name|decl
parameter_list|,
name|init
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|tree
name|init
decl_stmt|;
block|{
name|tree
name|oldstatic
init|=
name|value_member
argument_list|(
name|decl
argument_list|,
name|static_aggregates
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldstatic
condition|)
block|{
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|oldstatic
argument_list|)
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"multiple initializations given for `%s'"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|current_binding_level
operator|!=
name|global_binding_level
condition|)
block|{
comment|/* Emit code to perform this initialization but once.  */
name|tree
name|temp
decl_stmt|;
comment|/* Remember this information until end of file. */
name|push_obstacks
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|&
name|permanent_obstack
argument_list|)
expr_stmt|;
comment|/* Emit code to perform this initialization but once.  */
name|temp
operator|=
name|get_temp_name
argument_list|(
name|integer_type_node
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rest_of_decl_compilation
argument_list|(
name|temp
argument_list|,
name|NULL_PTR
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_start_cond
argument_list|(
name|build_binary_op
argument_list|(
name|EQ_EXPR
argument_list|,
name|temp
argument_list|,
name|integer_zero_node
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_assignment
argument_list|(
name|temp
argument_list|,
name|integer_one_node
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
name|expand_aggr_init
argument_list|(
name|decl
argument_list|,
name|init
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
block|}
else|else
name|expand_assignment
argument_list|(
name|decl
argument_list|,
name|init
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_end_cond
argument_list|()
expr_stmt|;
if|if
condition|(
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
name|static_aggregates
operator|=
name|perm_tree_cons
argument_list|(
name|temp
argument_list|,
name|decl
argument_list|,
name|static_aggregates
argument_list|)
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|static_aggregates
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Resume old (possibly temporary) allocation. */
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* This code takes into account memory allocation 	 policy of `start_decl'.  Namely, if TYPE_NEEDS_CONSTRUCTING 	 does not hold for this object, then we must make permanent 	 the storage currently in the temporary obstack.  */
if|if
condition|(
operator|!
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|preserve_initializer
argument_list|()
expr_stmt|;
name|static_aggregates
operator|=
name|perm_tree_cons
argument_list|(
name|init
argument_list|,
name|decl
argument_list|,
name|static_aggregates
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make TYPE a complete type based on INITIAL_VALUE.    Return 0 if successful, 1 if INITIAL_VALUE can't be deciphered,    2 if there was no information (in which case assume 1 if DO_DEFAULT).  */
end_comment

begin_function
name|int
name|complete_array_type
parameter_list|(
name|type
parameter_list|,
name|initial_value
parameter_list|,
name|do_default
parameter_list|)
name|tree
name|type
decl_stmt|,
name|initial_value
decl_stmt|;
name|int
name|do_default
decl_stmt|;
block|{
specifier|register
name|tree
name|maxindex
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|value
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|initial_value
condition|)
block|{
comment|/* Note MAXINDEX  is really the maximum index, 	 one less than the size.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|initial_value
argument_list|)
operator|==
name|STRING_CST
condition|)
name|maxindex
operator|=
name|build_int_2
argument_list|(
name|TREE_STRING_LENGTH
argument_list|(
name|initial_value
argument_list|)
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|initial_value
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
block|{
specifier|register
name|int
name|nelts
init|=
name|list_length
argument_list|(
name|CONSTRUCTOR_ELTS
argument_list|(
name|initial_value
argument_list|)
argument_list|)
decl_stmt|;
name|maxindex
operator|=
name|build_int_2
argument_list|(
name|nelts
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Make an error message unless that happened already.  */
if|if
condition|(
name|initial_value
operator|!=
name|error_mark_node
condition|)
name|value
operator|=
literal|1
expr_stmt|;
comment|/* Prevent further error messages.  */
name|maxindex
operator|=
name|build_int_2
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|maxindex
condition|)
block|{
if|if
condition|(
name|do_default
condition|)
name|maxindex
operator|=
name|build_int_2
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|value
operator|=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|maxindex
condition|)
block|{
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
operator|=
name|build_index_type
argument_list|(
name|maxindex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TREE_TYPE
argument_list|(
name|maxindex
argument_list|)
condition|)
name|TREE_TYPE
argument_list|(
name|maxindex
argument_list|)
operator|=
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
comment|/* Lay out the type now that we can get the real answer.  */
name|layout_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return zero if something is declared to be a member of type    CTYPE when in the context of CUR_TYPE.  STRING is the error    message to print in that case.  Otherwise, quietly return 1.  */
end_comment

begin_function
specifier|static
name|int
name|member_function_or_else
parameter_list|(
name|ctype
parameter_list|,
name|cur_type
parameter_list|,
name|string
parameter_list|)
name|tree
name|ctype
decl_stmt|,
name|cur_type
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
block|{
if|if
condition|(
name|ctype
operator|&&
name|ctype
operator|!=
name|cur_type
condition|)
block|{
name|error
argument_list|(
name|string
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|ctype
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutine of `grokdeclarator'.  */
end_comment

begin_comment
comment|/* CTYPE is class type, or null if non-class.    TYPE is type this FUNCTION_DECL should have, either FUNCTION_TYPE    or METHOD_TYPE.    DECLARATOR is the function's name.    VIRTUALP is truthvalue of whether the function is virtual or not.    FLAGS are to be passed through to `grokclassfn'.    QUALS are qualifiers indicating whether the function is `const'    or `volatile'.    RAISES is a list of exceptions that this function can raise.    CHECK is 1 if we must find this method in CTYPE, 0 if we should    not look, and -1 if we should not call `grokclassfn' at all.  */
end_comment

begin_function
specifier|static
name|tree
name|grokfndecl
parameter_list|(
name|ctype
parameter_list|,
name|type
parameter_list|,
name|declarator
parameter_list|,
name|virtualp
parameter_list|,
name|flags
parameter_list|,
name|quals
parameter_list|,
name|raises
parameter_list|,
name|check
parameter_list|,
name|publicp
parameter_list|)
name|tree
name|ctype
decl_stmt|,
name|type
decl_stmt|;
name|tree
name|declarator
decl_stmt|;
name|int
name|virtualp
decl_stmt|;
name|enum
name|overload_flags
name|flags
decl_stmt|;
name|tree
name|quals
decl_stmt|,
name|raises
decl_stmt|;
name|int
name|check
decl_stmt|,
name|publicp
decl_stmt|;
block|{
name|tree
name|cname
decl_stmt|,
name|decl
decl_stmt|;
name|int
name|staticp
init|=
name|ctype
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
decl_stmt|;
if|if
condition|(
name|ctype
condition|)
name|cname
operator|=
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|ctype
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
condition|?
name|TYPE_IDENTIFIER
argument_list|(
name|ctype
argument_list|)
else|:
name|TYPE_NAME
argument_list|(
name|ctype
argument_list|)
expr_stmt|;
else|else
name|cname
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|raises
condition|)
block|{
name|type
operator|=
name|build_exception_variant
argument_list|(
name|ctype
argument_list|,
name|type
argument_list|,
name|raises
argument_list|)
expr_stmt|;
name|raises
operator|=
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
name|decl
operator|=
name|build_lang_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|declarator
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* propagate volatile out from type to decl */
if|if
condition|(
name|TYPE_VOLATILE
argument_list|(
name|type
argument_list|)
condition|)
name|TREE_THIS_VOLATILE
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Should probably propagate const out from type to decl I bet (mrs).  */
if|if
condition|(
name|staticp
condition|)
block|{
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|ctype
expr_stmt|;
name|DECL_CLASS_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|ctype
expr_stmt|;
block|}
if|if
condition|(
name|publicp
condition|)
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|quals
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"functions cannot have method qualifiers"
argument_list|)
expr_stmt|;
name|quals
operator|=
name|NULL_TREE
expr_stmt|;
block|}
comment|/* Only two styles of delete's are valid. */
if|if
condition|(
name|declarator
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|DELETE_EXPR
index|]
condition|)
block|{
name|tree
name|args
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|style1
decl_stmt|,
name|style2
decl_stmt|;
if|if
condition|(
name|ctype
operator|&&
name|args
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
comment|/* remove this */
name|args
operator|=
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|style1
operator|=
name|type_list_equal
argument_list|(
name|args
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|void_list_node
argument_list|)
argument_list|)
expr_stmt|;
name|style2
operator|=
name|style1
operator|!=
literal|0
condition|?
literal|0
else|:
name|type_list_equal
argument_list|(
name|args
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|sizetype
argument_list|,
name|void_list_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctype
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
operator|!
name|style1
condition|)
comment|/* ANSI C++ June 5 1992 WP 12.5.5.2 */
name|error
argument_list|(
literal|"global operator delete must be declared as taking a single argument of type void*"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|style1
operator|&&
operator|!
name|style2
condition|)
comment|/* ANSI C++ June 5 1992 WP 12.5.4.1 */
name|error
argument_list|(
literal|"operator delete cannot be overloaded"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|POSTINCREMENT_EXPR
index|]
operator|||
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|POSTDECREMENT_EXPR
index|]
condition|)
block|{
comment|/* According to ARM $13.4.7, postfix operator++ must take an int as 	 its second argument.  */
name|tree
name|parmtypes
decl_stmt|,
name|argtypes
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|argtypes
condition|)
block|{
name|parmtypes
operator|=
name|TREE_CHAIN
argument_list|(
name|argtypes
argument_list|)
expr_stmt|;
if|if
condition|(
name|parmtypes
operator|!=
name|NULL_TREE
operator|&&
name|TREE_VALUE
argument_list|(
name|parmtypes
argument_list|)
operator|!=
name|void_type_node
operator|&&
name|TREE_VALUE
argument_list|(
name|parmtypes
argument_list|)
operator|!=
name|integer_type_node
condition|)
name|error
argument_list|(
literal|"postfix operator%s may only take `int' as its argument"
argument_list|,
name|POSTINCREMENT_EXPR
condition|?
literal|"++"
else|:
literal|"--"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Caller will do the rest of this.  */
if|if
condition|(
name|check
operator|<
literal|0
condition|)
return|return
name|decl
return|;
if|if
condition|(
name|flags
operator|==
name|NO_SPECIAL
operator|&&
name|ctype
operator|&&
name|constructor_name
argument_list|(
name|cname
argument_list|)
operator|==
name|declarator
condition|)
block|{
name|tree
name|tmp
decl_stmt|;
comment|/* Just handle constructors here.  We could do this 	 inside the following if stmt, but I think 	 that the code is more legible by breaking this 	 case out.  See comments below for what each of 	 the following calls is supposed to do.  */
name|DECL_CONSTRUCTOR_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|grokclassfn
argument_list|(
name|ctype
argument_list|,
name|declarator
argument_list|,
name|decl
argument_list|,
name|flags
argument_list|,
name|quals
argument_list|)
expr_stmt|;
if|if
condition|(
name|check
condition|)
name|check_classfn
argument_list|(
name|ctype
argument_list|,
name|declarator
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|grok_ctor_properties
argument_list|(
name|ctype
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|check
operator|==
literal|0
condition|)
block|{
comment|/* FIXME: this should only need to look at IDENTIFIER_GLOBAL_VALUE.  */
name|tmp
operator|=
name|lookup_name
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL_TREE
condition|)
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
name|decl
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tmp
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"inconsistent declarations for `%s'"
argument_list|)
expr_stmt|;
else|else
block|{
name|duplicate_decls
argument_list|(
name|decl
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|decl
operator|=
name|tmp
expr_stmt|;
comment|/* avoid creating circularities.  */
name|DECL_CHAIN
argument_list|(
name|decl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|make_decl_rtl
argument_list|(
name|decl
argument_list|,
name|NULL_PTR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|tree
name|tmp
decl_stmt|;
comment|/* Function gets the ugly name, field gets the nice one. 	 This call may change the type of the function (because 	 of default parameters)!  */
if|if
condition|(
name|ctype
operator|!=
name|NULL_TREE
condition|)
name|grokclassfn
argument_list|(
name|ctype
argument_list|,
name|cname
argument_list|,
name|decl
argument_list|,
name|flags
argument_list|,
name|quals
argument_list|)
expr_stmt|;
if|if
condition|(
name|IDENTIFIER_OPNAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|grok_op_properties
argument_list|(
name|decl
argument_list|,
name|virtualp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctype
operator|!=
name|NULL_TREE
operator|&&
name|check
condition|)
name|check_classfn
argument_list|(
name|ctype
argument_list|,
name|cname
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctype
operator|==
name|NULL_TREE
operator|||
name|check
condition|)
return|return
name|decl
return|;
comment|/* Now install the declaration of this function so that 	 others may find it (esp. its DECL_FRIENDLIST). 	 Pretend we are at top level, we will get true 	 reference later, perhaps.  	 FIXME: This should only need to look at IDENTIFIER_GLOBAL_VALUE.  */
name|tmp
operator|=
name|lookup_name
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL_TREE
condition|)
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
name|decl
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tmp
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"inconsistent declarations for `%s'"
argument_list|)
expr_stmt|;
else|else
block|{
name|duplicate_decls
argument_list|(
name|decl
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|decl
operator|=
name|tmp
expr_stmt|;
comment|/* avoid creating circularities.  */
name|DECL_CHAIN
argument_list|(
name|decl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|make_decl_rtl
argument_list|(
name|decl
argument_list|,
name|NULL_PTR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* If this declaration supersedes the declaration of 	 a method declared virtual in the base class, then 	 mark this field as being virtual as well.  */
block|{
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|TYPE_BINFO
argument_list|(
name|ctype
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baselinks
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baselinks
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_VIRTUAL_P
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
operator|||
name|flag_all_virtual
operator|==
literal|1
condition|)
block|{
name|tmp
operator|=
name|get_first_matching_virtual
argument_list|(
name|base_binfo
argument_list|,
name|decl
argument_list|,
name|flags
operator|==
name|DTOR_FLAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
condition|)
block|{
comment|/* The TMP we really want is the one from the deepest 		       baseclass on this path, taking care not to 		       duplicate if we have already found it (via another 		       path to its virtual baseclass.  */
if|if
condition|(
name|staticp
condition|)
block|{
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"method `%s' may not be declared static"
argument_list|)
expr_stmt|;
name|error_with_decl
argument_list|(
name|tmp
argument_list|,
literal|"(since `%s' declared virtual in base class.)"
argument_list|)
expr_stmt|;
break|break;
block|}
name|virtualp
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
operator|||
name|TYPE_USES_MULTIPLE_INHERITANCE
argument_list|(
name|ctype
argument_list|)
operator|)
operator|&&
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
operator|!=
name|DECL_CONTEXT
argument_list|(
name|tmp
argument_list|)
condition|)
name|tmp
operator|=
name|get_first_matching_virtual
argument_list|(
name|TYPE_BINFO
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|tmp
argument_list|)
argument_list|)
argument_list|,
name|decl
argument_list|,
name|flags
operator|==
name|DTOR_FLAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|value_member
argument_list|(
name|tmp
argument_list|,
name|DECL_VINDEX
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* The argument types may have changed... */
name|tree
name|argtypes
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|base_variant
init|=
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|argtypes
argument_list|)
argument_list|)
decl_stmt|;
name|argtypes
operator|=
name|commonparms
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|tmp
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|argtypes
argument_list|)
argument_list|)
expr_stmt|;
comment|/* But the return type has not.  */
name|type
operator|=
name|build_cplus_method_type
argument_list|(
name|base_variant
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|argtypes
argument_list|)
expr_stmt|;
if|if
condition|(
name|raises
condition|)
block|{
name|type
operator|=
name|build_exception_variant
argument_list|(
name|ctype
argument_list|,
name|type
argument_list|,
name|raises
argument_list|)
expr_stmt|;
name|raises
operator|=
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|type
expr_stmt|;
name|DECL_VINDEX
argument_list|(
name|decl
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|tmp
argument_list|,
name|DECL_VINDEX
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
if|if
condition|(
name|virtualp
condition|)
block|{
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|DECL_VINDEX
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|IDENTIFIER_VIRTUAL_P
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ctype
operator|&&
name|CLASSTYPE_VTABLE_NEEDS_WRITING
argument_list|(
name|ctype
argument_list|)
comment|/* If this function is derived from a template, don't 		 make it public.  This shouldn't be here, but there's 		 no good way to override the interface pragmas for one 		 function or class only.  Bletch.  */
operator|&&
name|IDENTIFIER_TEMPLATE
argument_list|(
name|TYPE_IDENTIFIER
argument_list|(
name|ctype
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
operator|&&
operator|(
name|write_virtuals
operator|==
literal|2
operator|||
operator|(
name|write_virtuals
operator|==
literal|3
operator|&&
operator|!
name|CLASSTYPE_INTERFACE_UNKNOWN
argument_list|(
name|ctype
argument_list|)
operator|)
operator|)
condition|)
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
name|decl
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|grokvardecl
parameter_list|(
name|type
parameter_list|,
name|declarator
parameter_list|,
name|specbits
parameter_list|,
name|initialized
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|declarator
decl_stmt|;
name|RID_BIT_TYPE
name|specbits
decl_stmt|;
name|int
name|initialized
decl_stmt|;
block|{
name|tree
name|decl
decl_stmt|;
comment|/* This implements the "one definition rule" for global variables.      Note that declarator can come in as null when we're doing work      on an anonymous union.  */
if|if
condition|(
name|declarator
operator|&&
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|declarator
argument_list|)
operator|&&
name|current_binding_level
operator|==
name|global_binding_level
operator|&&
name|TREE_STATIC
argument_list|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|declarator
argument_list|)
argument_list|)
operator|&&
operator|(
operator|!
operator|(
name|specbits
operator|&
name|RIDBIT
argument_list|(
name|RID_EXTERN
argument_list|)
operator|)
operator|||
name|initialized
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"redefinition of `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|declarator
argument_list|)
argument_list|)
expr_stmt|;
name|error_with_decl
argument_list|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|declarator
argument_list|)
argument_list|,
literal|"previously defined here"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
block|{
comment|/* If you declare a static member so that it 	 can be initialized, the code will reach here.  */
name|tree
name|field
init|=
name|lookup_field
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|declarator
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|field
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|VAR_DECL
condition|)
block|{
name|tree
name|basetype
init|=
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|error
argument_list|(
literal|"`%s' is not a static member of class `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|declarator
argument_list|)
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|basetype
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_lang_field_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|declarator
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|basetype
expr_stmt|;
name|DECL_CLASS_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|basetype
expr_stmt|;
block|}
else|else
block|{
name|tree
name|f_type
init|=
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
decl_stmt|;
name|tree
name|o_type
init|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|f_type
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|f_type
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|o_type
argument_list|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|f_type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TREE_TYPE
argument_list|(
name|f_type
argument_list|)
operator|!=
name|TREE_TYPE
argument_list|(
name|o_type
argument_list|)
operator|)
condition|)
name|error
argument_list|(
literal|"redeclaration of type for `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|declarator
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|o_type
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
operator|=
name|type
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|f_type
operator|!=
name|o_type
condition|)
name|error
argument_list|(
literal|"redeclaration of type for `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|declarator
argument_list|)
argument_list|)
expr_stmt|;
name|decl
operator|=
name|field
expr_stmt|;
if|if
condition|(
name|initialized
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
comment|/* Complain about multiply-initialized 		 member variables, but don't be faked 		 out if initializer is faked up from `empty_init_node'.  */
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|CONSTRUCTOR
operator|||
name|CONSTRUCTOR_ELTS
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|NULL_TREE
operator|)
condition|)
name|error_with_aggr_type
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|"multiple initializations of static member `%s::%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|decl
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|declarator
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|specbits
operator|&
name|RIDBIT
argument_list|(
name|RID_EXTERN
argument_list|)
condition|)
block|{
name|DECL_THIS_EXTERN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
operator|!
name|initialized
expr_stmt|;
block|}
comment|/* In class context, static means one per class,      public visibility, and static storage.  */
if|if
condition|(
name|DECL_FIELD_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|DECL_FIELD_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
operator|!
name|initialized
expr_stmt|;
block|}
comment|/* At top level, either `static' or no s.c. makes a definition      (perhaps tentative), and absence of `static' makes it public.  */
elseif|else
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
condition|)
block|{
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
operator|!
operator|(
name|specbits
operator|&
name|RIDBIT
argument_list|(
name|RID_STATIC
argument_list|)
operator|)
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
comment|/* Not at top level, only `static' makes a static definition.  */
else|else
block|{
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
operator|!
operator|!
operator|(
name|specbits
operator|&
name|RIDBIT
argument_list|(
name|RID_STATIC
argument_list|)
operator|)
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Given declspecs and a declarator,    determine the name and type of the object declared    and construct a ..._DECL node for it.    (In one case we can return a ..._TYPE node instead.     For invalid input we sometimes return 0.)     DECLSPECS is a chain of tree_list nodes whose value fields     are the storage classes and type specifiers.     DECL_CONTEXT says which syntactic context this declaration is in:      NORMAL for most contexts.  Make a VAR_DECL or FUNCTION_DECL or TYPE_DECL.      FUNCDEF for a function definition.  Like NORMAL but a few different       error messages in each case.  Return value may be zero meaning       this definition is too screwy to try to parse.      MEMFUNCDEF for a function definition.  Like FUNCDEF but prepares to       handle member functions (which have FIELD context).       Return value may be zero meaning this definition is too screwy to       try to parse.      PARM for a parameter declaration (either within a function prototype       or before a function body).  Make a PARM_DECL, or return void_type_node.      TYPENAME if for a typename (in a cast or sizeof).       Don't make a DECL node; just return the ..._TYPE node.      FIELD for a struct or union field; make a FIELD_DECL.      BITFIELD for a field with specified width.    INITIALIZED is 1 if the decl has an initializer.     In the TYPENAME case, DECLARATOR is really an absolute declarator.    It may also be so in the PARM case, for a prototype where the    argument type is specified but not the name.     This function is where the complicated C meanings of `static'    and `extern' are interpreted.     For C++, if there is any monkey business to do, the function which    calls this one must do it, i.e., prepending instance variables,    renaming overloaded function names, etc.     Note that for this C++, it is an error to define a method within a class    which does not belong to that class.     Except in the case where SCOPE_REFs are implicitly known (such as    methods within a class being redundantly qualified),    declarations which involve SCOPE_REFs are returned as SCOPE_REFs    (class_name::decl_name).  The caller must also deal with this.     If a constructor or destructor is seen, and the context is FIELD,    then the type gains the attribute TREE_HAS_x.  If such a declaration    is erroneous, NULL_TREE is returned.     QUALS is used only for FUNCDEF and MEMFUNCDEF cases.  For a member    function, these are the qualifiers to give to the `this' pointer.     May return void_type_node if the declarator turned out to be a friend.    See grokfield for details.  */
end_comment

begin_enum
enum|enum
name|return_types
block|{
name|return_normal
block|,
name|return_ctor
block|,
name|return_dtor
block|,
name|return_conversion
block|}
enum|;
end_enum

begin_function
name|tree
name|grokdeclarator
parameter_list|(
name|declarator
parameter_list|,
name|declspecs
parameter_list|,
name|decl_context
parameter_list|,
name|initialized
parameter_list|,
name|raises
parameter_list|)
name|tree
name|declspecs
decl_stmt|;
name|tree
name|declarator
decl_stmt|;
name|enum
name|decl_context
name|decl_context
decl_stmt|;
name|int
name|initialized
decl_stmt|;
name|tree
name|raises
decl_stmt|;
block|{
specifier|extern
name|int
name|current_class_depth
decl_stmt|;
name|RID_BIT_TYPE
name|specbits
init|=
literal|0
decl_stmt|;
name|int
name|nclasses
init|=
literal|0
decl_stmt|;
name|tree
name|spec
decl_stmt|;
name|tree
name|type
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|longlong
init|=
literal|0
decl_stmt|;
name|int
name|constp
decl_stmt|;
name|int
name|volatilep
decl_stmt|;
name|int
name|virtualp
decl_stmt|,
name|friendp
decl_stmt|,
name|inlinep
decl_stmt|,
name|staticp
decl_stmt|;
name|int
name|explicit_int
init|=
literal|0
decl_stmt|;
name|int
name|explicit_char
init|=
literal|0
decl_stmt|;
name|tree
name|typedef_decl
init|=
name|NULL_TREE
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|tree
name|typedef_type
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|funcdef_flag
init|=
literal|0
decl_stmt|;
name|enum
name|tree_code
name|innermost_code
init|=
name|ERROR_MARK
decl_stmt|;
name|int
name|bitfield
init|=
literal|0
decl_stmt|;
name|int
name|size_varies
init|=
literal|0
decl_stmt|;
comment|/* Set this to error_mark_node for FIELD_DECLs we could not handle properly.      All FIELD_DECLs we build here have `init' put into their DECL_INITIAL.  */
name|tree
name|init
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Keep track of what sort of function is being processed      so that we can warn about default return values, or explicit      return values which do not match prescribed defaults.  */
name|enum
name|return_types
name|return_type
init|=
name|return_normal
decl_stmt|;
name|tree
name|dname
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|ctype
init|=
name|current_class_type
decl_stmt|;
name|tree
name|ctor_return_type
init|=
name|NULL_TREE
decl_stmt|;
name|enum
name|overload_flags
name|flags
init|=
name|NO_SPECIAL
decl_stmt|;
name|int
name|seen_scope_ref
init|=
literal|0
decl_stmt|;
name|tree
name|quals
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|decl_context
operator|==
name|FUNCDEF
condition|)
name|funcdef_flag
operator|=
literal|1
operator|,
name|decl_context
operator|=
name|NORMAL
expr_stmt|;
elseif|else
if|if
condition|(
name|decl_context
operator|==
name|MEMFUNCDEF
condition|)
name|funcdef_flag
operator|=
operator|-
literal|1
operator|,
name|decl_context
operator|=
name|FIELD
expr_stmt|;
elseif|else
if|if
condition|(
name|decl_context
operator|==
name|BITFIELD
condition|)
name|bitfield
operator|=
literal|1
operator|,
name|decl_context
operator|=
name|FIELD
expr_stmt|;
if|if
condition|(
name|flag_traditional
operator|&&
name|allocation_temporary_p
argument_list|()
condition|)
name|end_temporary_allocation
argument_list|()
expr_stmt|;
comment|/* Look inside a declarator for the name being declared      and get it as a string, for an error message.  */
block|{
name|tree
name|type
decl_stmt|,
name|last
init|=
name|NULL_TREE
decl_stmt|;
specifier|register
name|tree
name|decl
init|=
name|declarator
decl_stmt|;
name|name
operator|=
name|NULL
expr_stmt|;
comment|/* If we see something of the form `aggr_type xyzzy (a, b, c)'        it is either an old-style function declaration or a call to        a constructor.  The following conditional makes recognizes this        case as being a call to a constructor.  Too bad if it is not.  */
comment|/* For Doug Lea, also grok `aggr_type xyzzy (a, b, c)[10][10][10]'.  */
while|while
condition|(
name|decl
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|ARRAY_REF
condition|)
block|{
name|last
operator|=
name|decl
expr_stmt|;
name|decl
operator|=
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|decl
operator|&&
name|declspecs
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|CALL_EXPR
operator|&&
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SCOPE_REF
operator|)
condition|)
block|{
name|type
operator|=
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|declspecs
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|?
name|lookup_name
argument_list|(
name|TREE_VALUE
argument_list|(
name|declspecs
argument_list|)
argument_list|,
literal|1
argument_list|)
else|:
operator|(
name|IS_AGGR_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|declspecs
argument_list|)
argument_list|)
condition|?
name|TYPE_NAME
argument_list|(
name|TREE_VALUE
argument_list|(
name|declspecs
argument_list|)
argument_list|)
else|:
name|NULL_TREE
operator|)
expr_stmt|;
if|if
condition|(
name|type
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
name|parmlist_is_exprlist
argument_list|(
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|decl_context
operator|==
name|FIELD
operator|&&
name|TREE_CHAIN
argument_list|(
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
comment|/* That was an initializer list.  */
name|sorry
argument_list|(
literal|"initializer lists for field declarations"
argument_list|)
expr_stmt|;
name|decl
operator|=
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|last
condition|)
block|{
name|TREE_OPERAND
argument_list|(
name|last
argument_list|,
literal|0
argument_list|)
operator|=
name|decl
expr_stmt|;
name|decl
operator|=
name|declarator
expr_stmt|;
block|}
name|declarator
operator|=
name|decl
expr_stmt|;
name|init
operator|=
name|error_mark_node
expr_stmt|;
goto|goto
name|bot
goto|;
block|}
else|else
block|{
name|init
operator|=
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|last
condition|)
block|{
name|TREE_OPERAND
argument_list|(
name|last
argument_list|,
literal|0
argument_list|)
operator|=
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pedantic
operator|&&
name|init
condition|)
block|{
name|error
argument_list|(
literal|"arrays cannot take initializers"
argument_list|)
expr_stmt|;
name|init
operator|=
name|error_mark_node
expr_stmt|;
block|}
block|}
else|else
name|declarator
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|decl
operator|=
name|start_decl
argument_list|(
name|declarator
argument_list|,
name|declspecs
argument_list|,
literal|1
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|decl
argument_list|,
name|init
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
name|parmlist_is_random
argument_list|(
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|decl
operator|=
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|SCOPE_REF
condition|)
block|{
if|if
condition|(
name|TREE_COMPLEXITY
argument_list|(
name|decl
argument_list|)
condition|)
name|my_friendly_abort
argument_list|(
literal|15
argument_list|)
expr_stmt|;
name|decl
operator|=
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
name|error
argument_list|(
literal|"bad parameter list specification for function `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"bad parameter list specification for function"
argument_list|)
expr_stmt|;
return|return
name|void_type_node
return|;
block|}
name|bot
label|:
empty_stmt|;
block|}
else|else
comment|/* It didn't look like we thought it would, leave the ARRAY_REFs on.  */
name|decl
operator|=
name|declarator
expr_stmt|;
while|while
condition|(
name|decl
condition|)
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
case|case
name|COND_EXPR
case|:
name|ctype
operator|=
name|NULL_TREE
expr_stmt|;
name|decl
operator|=
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIT_NOT_EXPR
case|:
comment|/* for C++ destructors!  */
block|{
name|tree
name|name
init|=
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|rename
init|=
name|NULL_TREE
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|flags
operator|==
name|NO_SPECIAL
argument_list|,
literal|152
argument_list|)
expr_stmt|;
name|flags
operator|=
name|DTOR_FLAG
expr_stmt|;
name|return_type
operator|=
name|return_dtor
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|IDENTIFIER_NODE
argument_list|,
literal|153
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctype
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|current_class_type
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"destructors must be member functions"
argument_list|)
expr_stmt|;
name|flags
operator|=
name|NO_SPECIAL
expr_stmt|;
block|}
else|else
block|{
name|tree
name|t
init|=
name|constructor_name
argument_list|(
name|current_class_name
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|!=
name|name
condition|)
name|rename
operator|=
name|t
expr_stmt|;
block|}
block|}
else|else
block|{
name|tree
name|t
init|=
name|constructor_name
argument_list|(
name|ctype
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|!=
name|name
condition|)
name|rename
operator|=
name|t
expr_stmt|;
block|}
if|if
condition|(
name|rename
condition|)
block|{
name|error
argument_list|(
literal|"destructor `%s' must match class name `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|rename
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
operator|=
name|rename
expr_stmt|;
block|}
name|decl
operator|=
name|name
expr_stmt|;
block|}
break|break;
case|case
name|ADDR_EXPR
case|:
comment|/* C++ reference declaration */
comment|/* fall through */
case|case
name|ARRAY_REF
case|:
case|case
name|INDIRECT_REF
case|:
name|ctype
operator|=
name|NULL_TREE
expr_stmt|;
name|innermost_code
operator|=
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|decl
operator|=
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|CALL_EXPR
case|:
name|innermost_code
operator|=
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|decl
operator|=
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl_context
operator|==
name|FIELD
operator|&&
name|ctype
operator|==
name|NULL_TREE
condition|)
name|ctype
operator|=
name|current_class_type
expr_stmt|;
if|if
condition|(
name|ctype
operator|!=
name|NULL_TREE
operator|&&
name|decl
operator|!=
name|NULL_TREE
operator|&&
name|flags
operator|!=
name|DTOR_FLAG
operator|&&
name|decl
operator|==
name|constructor_name
argument_list|(
name|ctype
argument_list|)
condition|)
block|{
name|return_type
operator|=
name|return_ctor
expr_stmt|;
name|ctor_return_type
operator|=
name|ctype
expr_stmt|;
block|}
name|ctype
operator|=
name|NULL_TREE
expr_stmt|;
break|break;
case|case
name|IDENTIFIER_NODE
case|:
name|dname
operator|=
name|decl
expr_stmt|;
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|decl
operator|=
name|NULL_TREE
expr_stmt|;
break|break;
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
comment|/* Parse error puts this typespec where 	     a declarator should go.  */
name|error
argument_list|(
literal|"declarator name missing"
argument_list|)
expr_stmt|;
name|dname
operator|=
name|TYPE_NAME
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|dname
operator|&&
name|TREE_CODE
argument_list|(
name|dname
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|dname
operator|=
name|DECL_NAME
argument_list|(
name|dname
argument_list|)
expr_stmt|;
name|name
operator|=
name|dname
condition|?
name|IDENTIFIER_POINTER
argument_list|(
name|dname
argument_list|)
else|:
literal|"<nameless>"
expr_stmt|;
name|declspecs
operator|=
name|temp_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|decl
argument_list|,
name|declspecs
argument_list|)
expr_stmt|;
name|decl
operator|=
name|NULL_TREE
expr_stmt|;
break|break;
case|case
name|TYPE_EXPR
case|:
if|if
condition|(
name|ctype
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* ANSI C++ June 5 1992 WP 12.3.2 only describes 		 conversion functions in terms of being declared 		 as a member function.  */
name|error
argument_list|(
literal|"operator `%s' must be declared as a member"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
name|ctype
operator|=
name|NULL_TREE
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|flags
operator|==
name|NO_SPECIAL
argument_list|,
literal|154
argument_list|)
expr_stmt|;
name|flags
operator|=
name|TYPENAME_FLAG
expr_stmt|;
name|name
operator|=
literal|"operator<typename>"
expr_stmt|;
comment|/* Go to the absdcl.  */
name|decl
operator|=
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|return_type
operator|=
name|return_conversion
expr_stmt|;
break|break;
comment|/* C++ extension */
case|case
name|SCOPE_REF
case|:
if|if
condition|(
name|seen_scope_ref
operator|==
literal|1
condition|)
name|error
argument_list|(
literal|"multiple `::' terms in declarator invalid"
argument_list|)
expr_stmt|;
name|seen_scope_ref
operator|+=
literal|1
expr_stmt|;
block|{
comment|/* Perform error checking, and convert class names to types. 	       We may call grokdeclarator multiple times for the same 	       tree structure, so only do the conversion once.  In this 	       case, we have exactly what we want for `ctype'.  */
name|tree
name|cname
init|=
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|cname
operator|==
name|NULL_TREE
condition|)
name|ctype
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Can't use IS_AGGR_TYPE because CNAME might not be a type.  */
elseif|else
if|if
condition|(
name|IS_AGGR_TYPE_CODE
argument_list|(
name|TREE_CODE
argument_list|(
name|cname
argument_list|)
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|cname
argument_list|)
operator|==
name|UNINSTANTIATED_P_TYPE
condition|)
name|ctype
operator|=
name|cname
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|is_aggr_typedef
argument_list|(
name|cname
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
comment|/* Must test TREE_OPERAND (decl, 1), in case user gives 	       us `typedef (class::memfunc)(int); memfunc *memfuncptr;'  */
elseif|else
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
block|{
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
operator|=
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|cname
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctype
operator|==
name|NULL_TREE
condition|)
block|{
name|ctype
operator|=
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|cname
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
operator|=
name|ctype
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_COMPLEXITY
argument_list|(
name|decl
argument_list|)
operator|==
name|current_class_depth
condition|)
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
operator|=
name|ctype
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|UNIQUELY_DERIVED_FROM_P
argument_list|(
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|cname
argument_list|)
argument_list|,
name|ctype
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"type `%s' is not derived from type `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|cname
argument_list|)
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|ctype
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
block|{
name|ctype
operator|=
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|cname
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
operator|=
name|ctype
expr_stmt|;
block|}
block|}
name|decl
operator|=
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctype
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|&&
name|constructor_name
argument_list|(
name|ctype
argument_list|)
operator|==
name|decl
condition|)
block|{
name|return_type
operator|=
name|return_ctor
expr_stmt|;
name|ctor_return_type
operator|=
name|ctype
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|BIT_NOT_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|&&
name|constructor_name
argument_list|(
name|ctype
argument_list|)
operator|==
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|return_type
operator|=
name|return_dtor
expr_stmt|;
name|ctor_return_type
operator|=
name|ctype
expr_stmt|;
name|flags
operator|=
name|DTOR_FLAG
expr_stmt|;
name|decl
operator|=
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|ERROR_MARK
case|:
name|decl
operator|=
name|NULL_TREE
expr_stmt|;
break|break;
default|default:
name|my_friendly_abort
argument_list|(
literal|155
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
name|name
operator|=
literal|"type name"
expr_stmt|;
block|}
comment|/* A function definition's declarator must have the form of      a function declarator.  */
if|if
condition|(
name|funcdef_flag
operator|&&
name|innermost_code
operator|!=
name|CALL_EXPR
condition|)
return|return
literal|0
return|;
comment|/* Anything declared one level down from the top level      must be one of the parameters of a function      (because the body is at least two levels down).  */
comment|/* This heuristic cannot be applied to C++ nodes! Fixed, however,      by not allowing C++ class definitions to specify their parameters      with xdecls (must be spec.d in the parmlist).       Since we now wait to push a class scope until we are sure that      we are in a legitimate method context, we must set oldcname      explicitly (since current_class_name is not yet alive).  */
if|if
condition|(
name|decl_context
operator|==
name|NORMAL
operator|&&
name|current_binding_level
operator|->
name|level_chain
operator|==
name|global_binding_level
condition|)
name|decl_context
operator|=
name|PARM
expr_stmt|;
comment|/* Look through the decl specs and record which ones appear.      Some typespecs are defined as built-in typenames.      Others, the ones that are modifiers of other types,      are represented by bits in SPECBITS: set the bits for      the modifiers that appear.  Storage class keywords are also in SPECBITS.       If there is a typedef name or a type, store the type in TYPE.      This includes builtin typedefs such as `int'.       Set EXPLICIT_INT if the type is `int' or `char' and did not      come from a user typedef.       Set LONGLONG if `long' is mentioned twice.       For C++, constructors and destructors have their own fast treatment.  */
for|for
control|(
name|spec
operator|=
name|declspecs
init|;
name|spec
condition|;
name|spec
operator|=
name|TREE_CHAIN
argument_list|(
name|spec
argument_list|)
control|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|tree
name|id
init|=
name|TREE_VALUE
argument_list|(
name|spec
argument_list|)
decl_stmt|;
comment|/* Certain parse errors slip through.  For example, 	 `int class;' is not caught by the parser. Try 	 weakly to recover here.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|spec
argument_list|)
operator|!=
name|TREE_LIST
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
if|if
condition|(
name|id
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_INT
index|]
condition|)
block|{
if|if
condition|(
name|type
condition|)
name|error
argument_list|(
literal|"extraneous `int' ignored"
argument_list|)
expr_stmt|;
else|else
block|{
name|explicit_int
operator|=
literal|1
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
block|}
goto|goto
name|found
goto|;
block|}
if|if
condition|(
name|id
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CHAR
index|]
condition|)
block|{
if|if
condition|(
name|type
condition|)
name|error
argument_list|(
literal|"extraneous `char' ignored"
argument_list|)
expr_stmt|;
else|else
block|{
name|explicit_char
operator|=
literal|1
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
block|}
goto|goto
name|found
goto|;
block|}
if|if
condition|(
name|id
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_WCHAR
index|]
condition|)
block|{
if|if
condition|(
name|type
condition|)
name|error
argument_list|(
literal|"extraneous `__wchar_t' ignored"
argument_list|)
expr_stmt|;
else|else
block|{
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
block|}
goto|goto
name|found
goto|;
block|}
comment|/* C++ aggregate types.  */
if|if
condition|(
name|IDENTIFIER_HAS_TYPE_VALUE
argument_list|(
name|id
argument_list|)
condition|)
block|{
if|if
condition|(
name|type
condition|)
name|error
argument_list|(
literal|"multiple declarations `%s' and `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|type
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|type
operator|=
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|id
argument_list|)
expr_stmt|;
goto|goto
name|found
goto|;
block|}
for|for
control|(
name|i
operator|=
operator|(
name|int
operator|)
name|RID_FIRST_MODIFIER
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|RID_MAX
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ridpointers
index|[
name|i
index|]
operator|==
name|id
condition|)
block|{
if|if
condition|(
name|i
operator|==
operator|(
name|int
operator|)
name|RID_LONG
operator|&&
operator|(
name|specbits
operator|&
name|RIDBIT
argument_list|(
name|i
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"duplicate `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|longlong
condition|)
name|error
argument_list|(
literal|"`long long long' is too long for GCC"
argument_list|)
expr_stmt|;
else|else
name|longlong
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|specbits
operator|&
name|RIDBIT
argument_list|(
name|i
argument_list|)
condition|)
name|warning
argument_list|(
literal|"duplicate `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
name|specbits
operator||=
name|RIDBIT
argument_list|(
name|i
argument_list|)
expr_stmt|;
goto|goto
name|found
goto|;
block|}
block|}
block|}
if|if
condition|(
name|type
condition|)
name|error
argument_list|(
literal|"two or more data types in declaration of `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
specifier|register
name|tree
name|t
init|=
name|lookup_name
argument_list|(
name|id
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|t
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
name|error
argument_list|(
literal|"`%s' fails to be a typedef or built in type"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|typedef_decl
operator|=
name|t
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|!=
name|ERROR_MARK
condition|)
comment|/* Can't change CLASS nodes into RECORD nodes here!  */
name|type
operator|=
name|id
expr_stmt|;
name|found
label|:
block|{}
block|}
name|typedef_type
operator|=
name|type
expr_stmt|;
comment|/* No type at all: default to `int', and set EXPLICIT_INT      because it was not a user-defined typedef.  */
if|if
condition|(
name|type
operator|==
name|NULL_TREE
condition|)
block|{
name|explicit_int
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|return_type
operator|==
name|return_dtor
condition|)
name|type
operator|=
name|void_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|return_type
operator|==
name|return_ctor
condition|)
name|type
operator|=
name|TYPE_POINTER_TO
argument_list|(
name|ctor_return_type
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|funcdef_flag
operator|&&
name|explicit_warn_return_type
operator|&&
name|return_type
operator|==
name|return_normal
operator|&&
operator|!
operator|(
name|specbits
operator|&
operator|(
name|RIDBIT
argument_list|(
name|RID_SIGNED
argument_list|)
operator||
name|RIDBIT
argument_list|(
name|RID_UNSIGNED
argument_list|)
operator||
name|RIDBIT
argument_list|(
name|RID_LONG
argument_list|)
operator||
name|RIDBIT
argument_list|(
name|RID_SHORT
argument_list|)
operator|)
operator|)
condition|)
name|warn_about_return_type
operator|=
literal|1
expr_stmt|;
comment|/* Save warning until we know what is really going on.  */
name|type
operator|=
name|integer_type_node
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|return_type
operator|==
name|return_dtor
condition|)
block|{
name|error
argument_list|(
literal|"return type specification for destructor invalid"
argument_list|)
expr_stmt|;
name|type
operator|=
name|void_type_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|return_type
operator|==
name|return_ctor
condition|)
block|{
name|error
argument_list|(
literal|"return type specification for constructor invalid"
argument_list|)
expr_stmt|;
name|type
operator|=
name|TYPE_POINTER_TO
argument_list|(
name|ctor_return_type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|specbits
operator|&
name|RIDBIT
argument_list|(
name|RID_FRIEND
argument_list|)
operator|)
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|TYPE_BEING_DEFINED
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|==
name|NULL_TREE
operator|&&
operator|!
name|ANON_AGGRNAME_P
argument_list|(
name|TYPE_IDENTIFIER
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
name|current_function_decl
operator|==
name|NULL_TREE
operator|&&
name|decl_context
operator|!=
name|PARM
condition|)
block|{
comment|/* xref_tag will make friend class declarations look like 	 nested class declarations.  Retroactively change that 	 if the type has not yet been defined.  	 ??? ANSI C++ doesn't say what to do in this case yet.  */
name|globalize_nested_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
name|ctype
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Now process the modifiers that were specified      and check for invalid combinations.  */
comment|/* Long double is a special combination.  */
if|if
condition|(
operator|(
name|specbits
operator|&
name|RIDBIT
argument_list|(
name|RID_LONG
argument_list|)
operator|)
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|double_type_node
condition|)
block|{
name|specbits
operator|&=
operator|~
name|RIDBIT
argument_list|(
name|RID_LONG
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_type_variant
argument_list|(
name|long_double_type_node
argument_list|,
name|TYPE_READONLY
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_VOLATILE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Check all other uses of type modifiers.  */
if|if
condition|(
name|specbits
operator|&
operator|(
name|RIDBIT
argument_list|(
name|RID_UNSIGNED
argument_list|)
operator||
name|RIDBIT
argument_list|(
name|RID_SIGNED
argument_list|)
operator||
name|RIDBIT
argument_list|(
name|RID_LONG
argument_list|)
operator||
name|RIDBIT
argument_list|(
name|RID_SHORT
argument_list|)
operator|)
condition|)
block|{
name|int
name|ok
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REAL_TYPE
condition|)
name|error
argument_list|(
literal|"short, signed or unsigned invalid for `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|INTEGER_TYPE
operator|||
name|type
operator|==
name|wchar_type_node
condition|)
name|error
argument_list|(
literal|"long, short, signed or unsigned invalid for `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|specbits
operator|&
name|RIDBIT
argument_list|(
name|RID_LONG
argument_list|)
operator|)
operator|&&
operator|(
name|specbits
operator|&
name|RIDBIT
argument_list|(
name|RID_SHORT
argument_list|)
operator|)
condition|)
name|error
argument_list|(
literal|"long and short specified together for `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|(
name|specbits
operator|&
name|RIDBIT
argument_list|(
name|RID_LONG
argument_list|)
operator|)
operator|||
operator|(
name|specbits
operator|&
name|RIDBIT
argument_list|(
name|RID_SHORT
argument_list|)
operator|)
operator|)
operator|&&
name|explicit_char
condition|)
name|error
argument_list|(
literal|"long or short specified with char for `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|(
name|specbits
operator|&
name|RIDBIT
argument_list|(
name|RID_LONG
argument_list|)
operator|)
operator|||
operator|(
name|specbits
operator|&
name|RIDBIT
argument_list|(
name|RID_SHORT
argument_list|)
operator|)
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REAL_TYPE
condition|)
name|error
argument_list|(
literal|"long or short specified with floating type for `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|specbits
operator|&
name|RIDBIT
argument_list|(
name|RID_SIGNED
argument_list|)
operator|)
operator|&&
operator|(
name|specbits
operator|&
name|RIDBIT
argument_list|(
name|RID_UNSIGNED
argument_list|)
operator|)
condition|)
name|error
argument_list|(
literal|"signed and unsigned given together for `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
block|{
name|ok
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|explicit_int
operator|&&
operator|!
name|explicit_char
operator|&&
name|pedantic
condition|)
block|{
name|pedwarn
argument_list|(
literal|"long, short, signed or unsigned used invalidly for `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_pedantic_errors
condition|)
name|ok
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Discard the type modifiers if they are invalid.  */
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|specbits
operator|&=
operator|~
operator|(
name|RIDBIT
argument_list|(
name|RID_UNSIGNED
argument_list|)
operator||
name|RIDBIT
argument_list|(
name|RID_SIGNED
argument_list|)
operator||
name|RIDBIT
argument_list|(
name|RID_LONG
argument_list|)
operator||
name|RIDBIT
argument_list|(
name|RID_SHORT
argument_list|)
operator|)
expr_stmt|;
name|longlong
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Decide whether an integer type is signed or not.      Optionally treat bitfields as signed by default.  */
if|if
condition|(
operator|(
name|specbits
operator|&
name|RIDBIT
argument_list|(
name|RID_UNSIGNED
argument_list|)
operator|)
comment|/* Traditionally, all bitfields are unsigned.  */
operator|||
operator|(
name|bitfield
operator|&&
name|flag_traditional
operator|)
operator|||
operator|(
name|bitfield
operator|&&
operator|!
name|flag_signed_bitfields
operator|&&
operator|(
name|explicit_int
operator|||
name|explicit_char
comment|/* A typedef for plain `int' without `signed' 		 can be controlled just like plain `int'.  */
operator|||
operator|!
operator|(
name|typedef_decl
operator|!=
name|NULL_TREE
operator|&&
name|C_TYPEDEF_EXPLICITLY_SIGNED
argument_list|(
name|typedef_decl
argument_list|)
operator|)
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|ENUMERAL_TYPE
operator|&&
operator|!
operator|(
name|specbits
operator|&
name|RIDBIT
argument_list|(
name|RID_SIGNED
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|longlong
condition|)
name|type
operator|=
name|long_long_unsigned_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|specbits
operator|&
name|RIDBIT
argument_list|(
name|RID_LONG
argument_list|)
condition|)
name|type
operator|=
name|long_unsigned_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|specbits
operator|&
name|RIDBIT
argument_list|(
name|RID_SHORT
argument_list|)
condition|)
name|type
operator|=
name|short_unsigned_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|char_type_node
condition|)
name|type
operator|=
name|unsigned_char_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|typedef_decl
condition|)
name|type
operator|=
name|unsigned_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
else|else
name|type
operator|=
name|unsigned_type_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|specbits
operator|&
name|RIDBIT
argument_list|(
name|RID_SIGNED
argument_list|)
operator|)
operator|&&
name|type
operator|==
name|char_type_node
condition|)
name|type
operator|=
name|signed_char_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|longlong
condition|)
name|type
operator|=
name|long_long_integer_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|specbits
operator|&
name|RIDBIT
argument_list|(
name|RID_LONG
argument_list|)
condition|)
name|type
operator|=
name|long_integer_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|specbits
operator|&
name|RIDBIT
argument_list|(
name|RID_SHORT
argument_list|)
condition|)
name|type
operator|=
name|short_integer_type_node
expr_stmt|;
comment|/* Set CONSTP if this declaration is `const', whether by      explicit specification or via a typedef.      Likewise for VOLATILEP.  */
name|constp
operator|=
operator|!
operator|!
operator|(
name|specbits
operator|&
name|RIDBIT
argument_list|(
name|RID_CONST
argument_list|)
operator|)
operator|+
name|TYPE_READONLY
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|volatilep
operator|=
operator|!
operator|!
operator|(
name|specbits
operator|&
name|RIDBIT
argument_list|(
name|RID_VOLATILE
argument_list|)
operator|)
operator|+
name|TYPE_VOLATILE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|staticp
operator|=
literal|0
expr_stmt|;
name|inlinep
operator|=
operator|!
operator|!
operator|(
name|specbits
operator|&
name|RIDBIT
argument_list|(
name|RID_INLINE
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|constp
operator|>
literal|1
condition|)
name|warning
argument_list|(
literal|"duplicate `const'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|volatilep
operator|>
literal|1
condition|)
name|warning
argument_list|(
literal|"duplicate `volatile'"
argument_list|)
expr_stmt|;
name|virtualp
operator|=
name|specbits
operator|&
name|RIDBIT
argument_list|(
name|RID_VIRTUAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|specbits
operator|&
name|RIDBIT
argument_list|(
name|RID_STATIC
argument_list|)
condition|)
name|staticp
operator|=
literal|1
operator|+
operator|(
name|decl_context
operator|==
name|FIELD
operator|)
expr_stmt|;
if|if
condition|(
name|virtualp
operator|&&
name|staticp
operator|==
literal|2
condition|)
block|{
name|error
argument_list|(
literal|"member `%s' cannot be declared both virtual and static"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|staticp
operator|=
literal|0
expr_stmt|;
block|}
name|friendp
operator|=
name|specbits
operator|&
name|RIDBIT
argument_list|(
name|RID_FRIEND
argument_list|)
expr_stmt|;
name|specbits
operator|&=
operator|~
operator|(
name|RIDBIT
argument_list|(
name|RID_VIRTUAL
argument_list|)
operator||
name|RIDBIT
argument_list|(
name|RID_FRIEND
argument_list|)
operator|)
expr_stmt|;
comment|/* Warn if two storage classes are given. Default to `auto'.  */
if|if
condition|(
name|specbits
condition|)
block|{
if|if
condition|(
name|specbits
operator|&
name|RIDBIT
argument_list|(
name|RID_STATIC
argument_list|)
condition|)
name|nclasses
operator|++
expr_stmt|;
if|if
condition|(
name|specbits
operator|&
name|RIDBIT
argument_list|(
name|RID_EXTERN
argument_list|)
condition|)
name|nclasses
operator|++
expr_stmt|;
if|if
condition|(
name|decl_context
operator|==
name|PARM
operator|&&
name|nclasses
operator|>
literal|0
condition|)
name|error
argument_list|(
literal|"storage class specifiers invalid in parameter declarations"
argument_list|)
expr_stmt|;
if|if
condition|(
name|specbits
operator|&
name|RIDBIT
argument_list|(
name|RID_TYPEDEF
argument_list|)
condition|)
block|{
if|if
condition|(
name|decl_context
operator|==
name|PARM
condition|)
name|error
argument_list|(
literal|"typedef declaration invalid in parameter declaration"
argument_list|)
expr_stmt|;
name|nclasses
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|specbits
operator|&
name|RIDBIT
argument_list|(
name|RID_AUTO
argument_list|)
condition|)
name|nclasses
operator|++
expr_stmt|;
if|if
condition|(
name|specbits
operator|&
name|RIDBIT
argument_list|(
name|RID_REGISTER
argument_list|)
condition|)
name|nclasses
operator|++
expr_stmt|;
block|}
comment|/* Give error if `virtual' is used outside of class declaration.  */
if|if
condition|(
name|virtualp
operator|&&
name|current_class_name
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"virtual outside class declaration"
argument_list|)
expr_stmt|;
name|virtualp
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Warn about storage classes that are invalid for certain      kinds of declarations (parameters, typenames, etc.).  */
if|if
condition|(
name|nclasses
operator|>
literal|1
condition|)
name|error
argument_list|(
literal|"multiple storage classes in declaration of `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|decl_context
operator|!=
name|NORMAL
operator|&&
name|nclasses
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|decl_context
operator|==
name|PARM
operator|&&
operator|(
operator|(
name|specbits
operator|&
name|RIDBIT
argument_list|(
name|RID_REGISTER
argument_list|)
operator|)
operator||
name|RIDBIT
argument_list|(
name|RID_AUTO
argument_list|)
operator|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|(
name|decl_context
operator|==
name|FIELD
operator|||
name|decl_context
operator|==
name|TYPENAME
operator|)
operator|&&
operator|(
name|specbits
operator|&
name|RIDBIT
argument_list|(
name|RID_TYPEDEF
argument_list|)
operator|)
condition|)
block|{
comment|/* A typedef which was made in a class's scope.  */
name|tree
name|loc_typedecl
decl_stmt|;
specifier|register
name|int
name|i
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|lang_decl_flags
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
decl_stmt|;
specifier|register
name|int
modifier|*
name|pi
decl_stmt|;
name|struct
name|binding_level
modifier|*
name|local_binding_level
decl_stmt|;
comment|/* keep `grokdeclarator' from thinking we are in PARM context.  */
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* poplevel_class may be called by grokdeclarator which is called in   	     start_decl which is called below. In this case, our pushed level   	     may vanish and poplevel mustn't be called. So remember what we   	     have pushed and pop only if that is matched by    	     current_binding_level later. mnl@dtro.e-technik.th-darmstadt.de */
name|local_binding_level
operator|=
name|current_binding_level
expr_stmt|;
name|loc_typedecl
operator|=
name|start_decl
argument_list|(
name|declarator
argument_list|,
name|declspecs
argument_list|,
name|initialized
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|pi
operator|=
operator|(
name|int
operator|*
operator|)
name|permalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|lang_decl_flags
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|>
literal|0
condition|)
name|pi
index|[
operator|--
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|DECL_LANG_SPECIFIC
argument_list|(
name|loc_typedecl
argument_list|)
operator|=
operator|(
expr|struct
name|lang_decl
operator|*
operator|)
name|pi
expr_stmt|;
comment|/* This poplevel conflicts with the popclass over in 	     grokdeclarator.  See ``This popclass conflicts'' */
if|if
condition|(
name|current_binding_level
operator|==
name|local_binding_level
condition|)
name|poplevel
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (TREE_CODE (TREE_TYPE (loc_typedecl)) == ENUMERAL_TYPE) 	    { 	      tree ref = lookup_tag (ENUMERAL_TYPE, DECL_NAME (loc_typedecl), current_binding_level, 0); 	      if (! ref) 		pushtag (DECL_NAME (loc_typedecl), TREE_TYPE (loc_typedecl)); 	    }
endif|#
directive|endif
comment|/* We used to check for a typedef hiding a previous decl in 	     class scope, but delete_duplicate_fields_1 will now do 	     that for us in the proper place.  */
comment|/* We reset loc_typedecl because the IDENTIFIER_CLASS_NAME is 	     set by pushdecl_class_level.  */
name|loc_typedecl
operator|=
name|pushdecl_class_level
argument_list|(
name|loc_typedecl
argument_list|)
expr_stmt|;
return|return
name|loc_typedecl
return|;
block|}
elseif|else
if|if
condition|(
name|decl_context
operator|==
name|FIELD
comment|/* C++ allows static class elements  */
operator|&&
operator|(
name|specbits
operator|&
name|RIDBIT
argument_list|(
name|RID_STATIC
argument_list|)
operator|)
condition|)
comment|/* C++ also allows inlines and signed and unsigned elements,  	   but in those cases we don't come in here.  */
empty_stmt|;
else|else
block|{
if|if
condition|(
name|decl_context
operator|==
name|FIELD
condition|)
block|{
name|tree
name|tmp
init|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|register
name|int
name|op
init|=
name|IDENTIFIER_OPNAME_P
argument_list|(
name|tmp
argument_list|)
decl_stmt|;
name|error
argument_list|(
literal|"storage class specified for %s `%s'"
argument_list|,
name|op
condition|?
literal|"member operator"
else|:
literal|"structure field"
argument_list|,
name|op
condition|?
name|operator_name_string
argument_list|(
name|tmp
argument_list|)
else|:
name|name
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
operator|(
name|decl_context
operator|==
name|PARM
condition|?
literal|"storage class specified for parameter `%s'"
else|:
literal|"storage class specified for typename"
operator|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|specbits
operator|&=
operator|~
operator|(
name|RIDBIT
argument_list|(
name|RID_REGISTER
argument_list|)
operator||
name|RIDBIT
argument_list|(
name|RID_AUTO
argument_list|)
operator||
name|RIDBIT
argument_list|(
name|RID_EXTERN
argument_list|)
operator|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|specbits
operator|&
name|RIDBIT
argument_list|(
name|RID_EXTERN
argument_list|)
operator|)
operator|&&
name|initialized
operator|&&
operator|!
name|funcdef_flag
condition|)
block|{
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
condition|)
block|{
comment|/* It's common practice (and completely legal) to have a const 	     be initialized and declared extern.  */
if|if
condition|(
operator|!
name|constp
condition|)
name|warning
argument_list|(
literal|"`%s' initialized and declared `extern'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"`%s' has both `extern' and initializer"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|specbits
operator|&
name|RIDBIT
argument_list|(
name|RID_EXTERN
argument_list|)
operator|)
operator|&&
name|funcdef_flag
operator|&&
name|current_binding_level
operator|!=
name|global_binding_level
condition|)
name|error
argument_list|(
literal|"nested function `%s' declared `extern'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
condition|)
block|{
if|if
condition|(
name|specbits
operator|&
name|RIDBIT
argument_list|(
name|RID_AUTO
argument_list|)
condition|)
name|error
argument_list|(
literal|"top-level declaration of `%s' specifies `auto'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (specbits& RIDBIT (RID_REGISTER)) 	error ("top-level declaration of `%s' specifies `register'", name);
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/* I'm not sure under what circumstances we should turn 	 on the extern bit, and under what circumstances we should 	 warn if other bits are turned on.  */
block|if (decl_context == NORMAL&& ! (specbits& RIDBIT (RID_EXTERN))&& ! root_lang_context_p ()) 	{ 	  specbits |= RIDBIT (RID_EXTERN); 	}
endif|#
directive|endif
block|}
comment|/* Now figure out the structure of the declarator proper.      Descend through it, creating more complex types, until we reach      the declared identifier (or NULL_TREE, in an absolute declarator).  */
while|while
condition|(
name|declarator
operator|&&
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|!=
name|IDENTIFIER_NODE
condition|)
block|{
comment|/* Each level of DECLARATOR is either an ARRAY_REF (for ...[..]), 	 an INDIRECT_REF (for *...), 	 a CALL_EXPR (for ...(...)), 	 an identifier (for the name being declared) 	 or a null pointer (for the place in an absolute declarator 	 where the name was omitted). 	 For the last two cases, we have just exited the loop.  	 For C++ it could also be 	 a SCOPE_REF (for class :: ...).  In this case, we have converted 	 sensible names to types, and those are the values we use to 	 qualify the member name. 	 an ADDR_EXPR (for&...), 	 a BIT_NOT_EXPR (for destructors) 	 a TYPE_EXPR (for operator typenames)  	 At this point, TYPE is the type of elements of an array, 	 or for a function to return, or for a pointer to point to. 	 After this sequence of ifs, TYPE is the type of the 	 array or function or pointer, and DECLARATOR has had its 	 outermost layer removed.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ERROR_MARK
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|SCOPE_REF
condition|)
name|declarator
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|declarator
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|quals
operator|!=
name|NULL_TREE
operator|&&
operator|(
name|declarator
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|!=
name|SCOPE_REF
operator|)
condition|)
block|{
if|if
condition|(
name|ctype
operator|==
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|ctype
operator|=
name|TYPE_METHOD_BASETYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctype
operator|!=
name|NULL_TREE
condition|)
block|{
if|#
directive|if
literal|0
comment|/* not yet, should get fixed properly later */
block|tree dummy = make_type_decl (NULL_TREE, type);
else|#
directive|else
name|tree
name|dummy
init|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|type
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|ctype
operator|=
name|grok_method_quals
argument_list|(
name|ctype
argument_list|,
name|dummy
argument_list|,
name|quals
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|dummy
argument_list|)
expr_stmt|;
name|quals
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
condition|)
block|{
case|case
name|ARRAY_REF
case|:
name|maybe_globalize_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|{
specifier|register
name|tree
name|itype
init|=
name|NULL_TREE
decl_stmt|;
specifier|register
name|tree
name|size
init|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|declarator
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Check for some types that there cannot be arrays of.  */
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|void_type_node
condition|)
block|{
name|error
argument_list|(
literal|"declaration of `%s' as array of voids"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|type
operator|=
name|error_mark_node
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"declaration of `%s' as array of functions"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|type
operator|=
name|error_mark_node
expr_stmt|;
block|}
comment|/* ARM $8.4.3: Since you can't have a pointer to a reference, 	       you can't have arrays of references.  If we allowed them, 	       then we'd be saying x[i] is legal for an array x, but 	       then you'd have to ask: what does `*(x + i)' mean?  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|error
argument_list|(
literal|"declaration of `%s' as array of references"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
name|error_mark_node
condition|)
name|type
operator|=
name|error_mark_node
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
continue|continue;
if|if
condition|(
name|size
condition|)
block|{
comment|/* Must suspend_momentary here because the index 		   type may need to live until the end of the function. 		   For example, it is used in the declaration of a 		   variable which requires destructing at the end of 		   the function; then build_vec_delete will need this 		   value.  */
name|int
name|yes
init|=
name|suspend_momentary
argument_list|()
decl_stmt|;
comment|/* might be a cast */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_TYPE
argument_list|(
name|size
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|size
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|size
operator|=
name|TREE_OPERAND
argument_list|(
name|size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If this is a template parameter, it'll be constant, but 		   we don't know what the value is yet.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|TEMPLATE_CONST_PARM
condition|)
goto|goto
name|dont_grok_size
goto|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|size
argument_list|)
argument_list|)
operator|!=
name|INTEGER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|size
argument_list|)
argument_list|)
operator|!=
name|ENUMERAL_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"size of array `%s' has non-integer type"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|size
operator|=
name|integer_one_node
expr_stmt|;
block|}
if|if
condition|(
name|TREE_READONLY_DECL_P
argument_list|(
name|size
argument_list|)
condition|)
name|size
operator|=
name|decl_constant_value
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|pedantic
operator|&&
name|integer_zerop
argument_list|(
name|size
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C++ forbids zero-size array `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|size
argument_list|)
condition|)
block|{
if|if
condition|(
name|INT_CST_LT
argument_list|(
name|size
argument_list|,
name|integer_zero_node
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"size of array `%s' is negative"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|size
operator|=
name|integer_one_node
expr_stmt|;
block|}
name|itype
operator|=
name|build_index_type
argument_list|(
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|size
argument_list|,
name|integer_one_node
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C++ forbids variable-size array `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|dont_grok_size
label|:
name|itype
operator|=
name|build_binary_op
argument_list|(
name|MINUS_EXPR
argument_list|,
name|size
argument_list|,
name|integer_one_node
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Make sure the array size remains visibly nonconstant 		       even if it is (eg) a const variable with known value.  */
name|size_varies
operator|=
literal|1
expr_stmt|;
name|itype
operator|=
name|variable_size
argument_list|(
name|itype
argument_list|)
expr_stmt|;
name|itype
operator|=
name|build_index_type
argument_list|(
name|itype
argument_list|)
expr_stmt|;
block|}
name|resume_momentary
argument_list|(
name|yes
argument_list|)
expr_stmt|;
block|}
comment|/* Build the array type itself. 	       Merge any constancy or volatility into the target type.  */
if|if
condition|(
name|constp
operator|||
name|volatilep
condition|)
name|type
operator|=
name|build_type_variant
argument_list|(
name|type
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_cplus_array_type
argument_list|(
name|type
argument_list|,
name|itype
argument_list|)
expr_stmt|;
name|ctype
operator|=
name|NULL_TREE
expr_stmt|;
block|}
break|break;
case|case
name|CALL_EXPR
case|:
name|maybe_globalize_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|{
name|tree
name|arg_types
decl_stmt|;
comment|/* Declaring a function type. 	       Make sure we have a valid type for the function to return.  */
if|#
directive|if
literal|0
comment|/* Is this an error?  Should they be merged into TYPE here?  */
block|if (pedantic&& (constp || volatilep)) 	      pedwarn ("function declared to return const or volatile result");
else|#
directive|else
comment|/* Merge any constancy or volatility into the target type 	       for the pointer.  */
if|if
condition|(
name|constp
operator|||
name|volatilep
condition|)
block|{
name|type
operator|=
name|build_type_variant
argument_list|(
name|type
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
condition|)
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|constp
operator|=
literal|0
expr_stmt|;
name|volatilep
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Warn about some types functions can't return.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"`%s' declared as function returning a function"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|type
operator|=
name|integer_type_node
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"`%s' declared as function returning an array"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|type
operator|=
name|integer_type_node
expr_stmt|;
block|}
if|if
condition|(
name|ctype
operator|==
name|NULL_TREE
operator|&&
name|decl_context
operator|==
name|FIELD
operator|&&
operator|(
name|friendp
operator|==
literal|0
operator|||
name|dname
operator|==
name|current_class_name
operator|)
condition|)
name|ctype
operator|=
name|current_class_type
expr_stmt|;
if|if
condition|(
name|ctype
operator|&&
name|flags
operator|==
name|TYPENAME_FLAG
condition|)
name|TYPE_HAS_CONVERSION
argument_list|(
name|ctype
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ctype
operator|&&
name|constructor_name
argument_list|(
name|ctype
argument_list|)
operator|==
name|dname
condition|)
block|{
comment|/* We are within a class's scope. If our declarator name 		   is the same as the class name, and we are defining 		   a function, then it is a constructor/destructor, and 		   therefore returns a void type.  */
if|if
condition|(
name|flags
operator|==
name|DTOR_FLAG
condition|)
block|{
comment|/* ANSI C++ June 5 1992 WP 12.4.1.  A destructor may 		       not be declared const or volatile.  A destructor 		       may not be static.  */
if|if
condition|(
name|staticp
operator|==
literal|2
condition|)
name|error
argument_list|(
literal|"destructor cannot be static member function"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_READONLY
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"destructors cannot be declared `const'"
argument_list|)
expr_stmt|;
return|return
name|void_type_node
return|;
block|}
if|if
condition|(
name|TYPE_VOLATILE
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"destructors cannot be declared `volatile'"
argument_list|)
expr_stmt|;
return|return
name|void_type_node
return|;
block|}
if|if
condition|(
name|decl_context
operator|==
name|FIELD
condition|)
block|{
if|if
condition|(
operator|!
name|member_function_or_else
argument_list|(
name|ctype
argument_list|,
name|current_class_type
argument_list|,
literal|"destructor for alien class `%s' cannot be a member"
argument_list|)
condition|)
return|return
name|void_type_node
return|;
block|}
block|}
else|else
comment|/* it's a constructor. */
block|{
comment|/* ANSI C++ June 5 1992 WP 12.1.2.  A constructor may 		       not be declared const or volatile.  A constructor may 		       not be virtual.  A constructor may not be static.  */
if|if
condition|(
name|staticp
operator|==
literal|2
condition|)
name|error
argument_list|(
literal|"constructor cannot be static member function"
argument_list|)
expr_stmt|;
if|if
condition|(
name|virtualp
condition|)
block|{
name|pedwarn
argument_list|(
literal|"constructors cannot be declared virtual"
argument_list|)
expr_stmt|;
name|virtualp
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_READONLY
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"constructors cannot be declared `const'"
argument_list|)
expr_stmt|;
return|return
name|void_type_node
return|;
block|}
if|if
condition|(
name|TYPE_VOLATILE
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"constructors cannot be declared `volatile'"
argument_list|)
expr_stmt|;
return|return
name|void_type_node
return|;
block|}
if|if
condition|(
name|specbits
operator|&
operator|~
operator|(
name|RIDBIT
argument_list|(
name|RID_INLINE
argument_list|)
operator||
name|RIDBIT
argument_list|(
name|RID_STATIC
argument_list|)
operator|)
condition|)
name|error
argument_list|(
literal|"return value type specifier for constructor ignored"
argument_list|)
expr_stmt|;
name|type
operator|=
name|TYPE_POINTER_TO
argument_list|(
name|ctype
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl_context
operator|==
name|FIELD
condition|)
block|{
if|if
condition|(
operator|!
name|member_function_or_else
argument_list|(
name|ctype
argument_list|,
name|current_class_type
argument_list|,
literal|"constructor for alien class `%s' cannot be member"
argument_list|)
condition|)
return|return
name|void_type_node
return|;
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|ctype
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|return_type
operator|!=
name|return_ctor
condition|)
return|return
name|NULL_TREE
return|;
block|}
block|}
if|if
condition|(
name|decl_context
operator|==
name|FIELD
condition|)
name|staticp
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|friendp
operator|&&
name|virtualp
condition|)
block|{
comment|/* Cannot be both friend and virtual.  */
name|error
argument_list|(
literal|"virtual functions cannot be friends"
argument_list|)
expr_stmt|;
name|specbits
operator|&=
operator|~
name|RIDBIT
argument_list|(
name|RID_FRIEND
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|decl_context
operator|==
name|NORMAL
operator|&&
name|friendp
condition|)
name|error
argument_list|(
literal|"friend declaration not in class definition"
argument_list|)
expr_stmt|;
comment|/* Pick up type qualifiers which should be applied to `this'.  */
name|quals
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Traditionally, declaring return type float means double.  */
if|if
condition|(
name|flag_traditional
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|float_type_node
condition|)
block|{
name|type
operator|=
name|build_type_variant
argument_list|(
name|double_type_node
argument_list|,
name|TYPE_READONLY
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_VOLATILE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Construct the function type and go to the next 	       inner layer of declarator.  */
block|{
name|int
name|funcdef_p
decl_stmt|;
name|tree
name|inner_parms
init|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|inner_decl
init|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|declarator
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|inner_decl
operator|&&
name|TREE_CODE
argument_list|(
name|inner_decl
argument_list|)
operator|==
name|SCOPE_REF
condition|)
name|inner_decl
operator|=
name|TREE_OPERAND
argument_list|(
name|inner_decl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Say it's a definition only for the CALL_EXPR 		 closest to the identifier.  */
name|funcdef_p
operator|=
operator|(
name|inner_decl
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|inner_decl
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|||
name|TREE_CODE
argument_list|(
name|inner_decl
argument_list|)
operator|==
name|TYPE_EXPR
operator|)
operator|)
condition|?
name|funcdef_flag
else|:
literal|0
expr_stmt|;
name|arg_types
operator|=
name|grokparms
argument_list|(
name|inner_parms
argument_list|,
name|funcdef_p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|declarator
condition|)
block|{
comment|/* Get past destructors, etc. 		   We know we have one because FLAGS will be non-zero.  		   Complain about improper parameter lists here.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|BIT_NOT_EXPR
condition|)
block|{
name|declarator
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strict_prototype
operator|==
literal|0
operator|&&
name|arg_types
operator|==
name|NULL_TREE
condition|)
name|arg_types
operator|=
name|void_list_node
expr_stmt|;
elseif|else
if|if
condition|(
name|arg_types
operator|==
name|NULL_TREE
operator|||
name|arg_types
operator|!=
name|void_list_node
condition|)
block|{
name|error
argument_list|(
literal|"destructors cannot be specified with parameters"
argument_list|)
expr_stmt|;
name|arg_types
operator|=
name|void_list_node
expr_stmt|;
block|}
block|}
block|}
comment|/* the top level const or volatile is attached semantically only 	       to the function not the actual type. */
if|if
condition|(
name|TYPE_READONLY
argument_list|(
name|type
argument_list|)
operator|||
name|TYPE_VOLATILE
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|int
name|constp
init|=
name|TYPE_READONLY
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|volatilep
init|=
name|TYPE_VOLATILE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|type
operator|=
name|build_function_type
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
argument_list|,
name|flag_traditional
condition|?
literal|0
else|:
name|arg_types
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_type_variant
argument_list|(
name|type
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|)
expr_stmt|;
block|}
else|else
name|type
operator|=
name|build_function_type
argument_list|(
name|type
argument_list|,
name|flag_traditional
condition|?
literal|0
else|:
name|arg_types
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ADDR_EXPR
case|:
case|case
name|INDIRECT_REF
case|:
name|maybe_globalize_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Filter out pointers-to-references and references-to-references. 	     We can get these if a TYPE_DECL is used.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"cannot declare %s to references"
argument_list|,
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|ADDR_EXPR
condition|?
literal|"references"
else|:
literal|"pointers"
argument_list|)
expr_stmt|;
name|declarator
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Merge any constancy or volatility into the target type 	     for the pointer.  */
if|if
condition|(
name|constp
operator|||
name|volatilep
condition|)
block|{
name|type
operator|=
name|build_type_variant
argument_list|(
name|type
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
condition|)
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|constp
operator|=
literal|0
expr_stmt|;
name|volatilep
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"cannot declare references to functions; use pointer to function instead"
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|void_type_node
condition|)
name|error
argument_list|(
literal|"invalid type: `void&'"
argument_list|)
expr_stmt|;
else|else
name|type
operator|=
name|build_reference_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Process a list of type modifier keywords (such as 	     const or volatile) that were given inside the `*' or `&'.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|declarator
argument_list|)
condition|)
block|{
specifier|register
name|tree
name|typemodlist
decl_stmt|;
name|int
name|erred
init|=
literal|0
decl_stmt|;
for|for
control|(
name|typemodlist
operator|=
name|TREE_TYPE
argument_list|(
name|declarator
argument_list|)
init|;
name|typemodlist
condition|;
name|typemodlist
operator|=
name|TREE_CHAIN
argument_list|(
name|typemodlist
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|typemodlist
argument_list|)
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CONST
index|]
condition|)
name|constp
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|typemodlist
argument_list|)
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_VOLATILE
index|]
condition|)
name|volatilep
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|erred
condition|)
block|{
name|erred
operator|=
literal|1
expr_stmt|;
name|error
argument_list|(
literal|"invalid type modifier within %s declarator"
argument_list|,
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|ADDR_EXPR
condition|?
literal|"reference"
else|:
literal|"pointer"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|constp
operator|>
literal|1
condition|)
name|warning
argument_list|(
literal|"duplicate `const'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|volatilep
operator|>
literal|1
condition|)
name|warning
argument_list|(
literal|"duplicate `volatile'"
argument_list|)
expr_stmt|;
block|}
name|declarator
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ctype
operator|=
name|NULL_TREE
expr_stmt|;
break|break;
case|case
name|SCOPE_REF
case|:
block|{
comment|/* We have converted type names to NULL_TREE if the 	       name was bogus, or to a _TYPE node, if not.  	       The variable CTYPE holds the type we will ultimately 	       resolve to.  The code here just needs to build 	       up appropriate member types.  */
name|tree
name|sname
init|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* Destructors can have their visibilities changed as well.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|sname
argument_list|)
operator|==
name|BIT_NOT_EXPR
condition|)
name|sname
operator|=
name|TREE_OPERAND
argument_list|(
name|sname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_COMPLEXITY
argument_list|(
name|declarator
argument_list|)
operator|==
literal|0
condition|)
comment|/* This needs to be here, in case we are called 		 multiple times.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|friendp
operator|&&
operator|(
name|TREE_COMPLEXITY
argument_list|(
name|declarator
argument_list|)
operator|<
literal|2
operator|)
condition|)
comment|/* don't fall out into global scope. Hides real bug? --eichin */
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_COMPLEXITY
argument_list|(
name|declarator
argument_list|)
operator|==
name|current_class_depth
condition|)
block|{
name|TREE_COMPLEXITY
argument_list|(
name|declarator
argument_list|)
operator|-=
literal|1
expr_stmt|;
comment|/* This popclass conflicts with the poplevel over in 		   grokdeclarator.  See ``This poplevel conflicts'' */
name|popclass
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|my_friendly_abort
argument_list|(
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* We had a reference to a global decl, or 		   perhaps we were given a non-aggregate typedef, 		   in which case we cleared this out, and should just 		   keep going as though it wasn't there.  */
name|declarator
operator|=
name|sname
expr_stmt|;
continue|continue;
block|}
name|ctype
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sname
operator|==
name|NULL_TREE
condition|)
goto|goto
name|done_scoping
goto|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|sname
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
comment|/* This is the `standard' use of the scoping operator: 		   basetype :: member .  */
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|ctype
argument_list|)
operator|==
name|current_class_type
operator|||
name|friendp
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|type
operator|=
name|build_cplus_method_type
argument_list|(
name|build_type_variant
argument_list|(
name|ctype
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|ctype
argument_list|)
operator|!=
name|current_class_type
condition|)
block|{
name|error
argument_list|(
literal|"cannot declare member `%s::%s' within this class"
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|ctype
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|void_type_node
return|;
block|}
elseif|else
if|if
condition|(
name|extra_warnings
condition|)
name|warning
argument_list|(
literal|"extra qualification `%s' on member `%s' ignored"
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|ctype
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_offset_type
argument_list|(
name|ctype
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|ctype
argument_list|)
operator|!=
name|NULL_TREE
operator|||
operator|(
name|specbits
operator|&
name|RIDBIT
argument_list|(
name|RID_TYPEDEF
argument_list|)
operator|)
condition|)
block|{
name|tree
name|t
decl_stmt|;
comment|/* have to move this code elsewhere in this function. 		       this code is used for i.e., typedef int A::M; M *pm; */
if|if
condition|(
name|explicit_int
operator|==
operator|-
literal|1
operator|&&
name|decl_context
operator|==
name|FIELD
operator|&&
name|funcdef_flag
operator|==
literal|0
condition|)
block|{
comment|/* The code in here should only be used to build 			   stuff that will be grokked as visibility decls.  */
name|t
operator|=
name|lookup_field
argument_list|(
name|ctype
argument_list|,
name|sname
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
block|{
name|t
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|build_nt
argument_list|(
name|SCOPE_REF
argument_list|,
name|ctype
argument_list|,
name|t
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
operator|=
name|init
expr_stmt|;
return|return
name|t
return|;
block|}
comment|/* No such field, try member functions.  */
name|t
operator|=
name|lookup_fnfields
argument_list|(
name|TYPE_BINFO
argument_list|(
name|ctype
argument_list|)
argument_list|,
name|sname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
block|{
if|if
condition|(
name|flags
operator|==
name|DTOR_FLAG
condition|)
name|t
operator|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|ctype
argument_list|)
operator|&&
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
operator|==
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|ctype
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* Don't include destructor with constructors.  */
name|t
operator|=
name|DECL_CHAIN
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL_TREE
condition|)
name|error
argument_list|(
literal|"class `%s' does not have any constructors"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|sname
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|build_nt
argument_list|(
name|SCOPE_REF
argument_list|,
name|ctype
argument_list|,
name|t
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
operator|=
name|init
expr_stmt|;
return|return
name|t
return|;
block|}
if|if
condition|(
name|flags
operator|==
name|TYPENAME_FLAG
condition|)
name|error_with_aggr_type
argument_list|(
name|ctype
argument_list|,
literal|"type conversion is not a member of structure `%s'"
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"field `%s' is not a member of structure `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|sname
argument_list|)
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|ctype
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|type
operator|=
name|build_cplus_method_type
argument_list|(
name|build_type_variant
argument_list|(
name|ctype
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|current_class_type
condition|)
block|{
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|ctype
argument_list|)
operator|!=
name|current_class_type
condition|)
block|{
name|error
argument_list|(
literal|"cannot declare member `%s::%s' within this class"
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|ctype
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|void_type_node
return|;
block|}
elseif|else
if|if
condition|(
name|extra_warnings
condition|)
name|warning
argument_list|(
literal|"extra qualification `%s' on member `%s' ignored"
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|ctype
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|type
operator|=
name|build_offset_type
argument_list|(
name|ctype
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|uses_template_parms
argument_list|(
name|ctype
argument_list|)
condition|)
block|{
name|enum
name|tree_code
name|c
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|type
operator|=
name|build_cplus_method_type
argument_list|(
name|build_type_variant
argument_list|(
name|ctype
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|=
name|FUNCTION_DECL
expr_stmt|;
block|}
block|}
else|else
name|sorry
argument_list|(
literal|"structure `%s' not yet defined"
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|ctype
argument_list|)
argument_list|)
expr_stmt|;
name|declarator
operator|=
name|sname
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|sname
argument_list|)
operator|==
name|TYPE_EXPR
condition|)
block|{
comment|/* A TYPE_EXPR will change types out from under us. 		   So do the TYPE_EXPR now, and make this SCOPE_REF 		   inner to the TYPE_EXPR's CALL_EXPR.  		   This does not work if we don't get a CALL_EXPR back. 		   I did not think about error recovery, hence the 		   my_friendly_abort.  */
comment|/* Get the CALL_EXPR.  */
name|sname
operator|=
name|grokoptypename
argument_list|(
name|sname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|sname
argument_list|)
operator|==
name|CALL_EXPR
argument_list|,
literal|157
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|sname
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Scope the CALL_EXPR's name.  */
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|1
argument_list|)
operator|=
name|TREE_OPERAND
argument_list|(
name|sname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Put the SCOPE_EXPR in the CALL_EXPR's innermost position.  */
name|TREE_OPERAND
argument_list|(
name|sname
argument_list|,
literal|0
argument_list|)
operator|=
name|declarator
expr_stmt|;
comment|/* Now work from the CALL_EXPR.  */
name|declarator
operator|=
name|sname
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|sname
argument_list|)
operator|==
name|SCOPE_REF
condition|)
name|my_friendly_abort
argument_list|(
literal|17
argument_list|)
expr_stmt|;
else|else
block|{
name|done_scoping
label|:
name|declarator
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|declarator
operator|&&
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|CALL_EXPR
condition|)
comment|/* In this case, we will deal with it later.  */
empty_stmt|;
else|else
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|type
operator|=
name|build_cplus_method_type
argument_list|(
name|build_type_variant
argument_list|(
name|ctype
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|type
operator|=
name|build_offset_type
argument_list|(
name|ctype
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|BIT_NOT_EXPR
case|:
name|declarator
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_EXPR
case|:
name|declarator
operator|=
name|grokoptypename
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|explicit_int
operator|!=
operator|-
literal|1
condition|)
if|if
condition|(
name|comp_target_types
argument_list|(
name|type
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"type conversion function declared to return incongruent type"
argument_list|)
expr_stmt|;
else|else
name|pedwarn
argument_list|(
literal|"return type specified for type conversion function"
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|maybe_globalize_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
name|declarator
operator|=
name|NULL_TREE
expr_stmt|;
break|break;
case|case
name|ERROR_MARK
case|:
name|declarator
operator|=
name|NULL_TREE
expr_stmt|;
break|break;
default|default:
name|my_friendly_abort
argument_list|(
literal|158
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now TYPE has the actual type.  */
comment|/* If this is declaring a typedef name, return a TYPE_DECL.  */
if|if
condition|(
name|specbits
operator|&
name|RIDBIT
argument_list|(
name|RID_TYPEDEF
argument_list|)
condition|)
block|{
name|tree
name|decl
decl_stmt|;
comment|/* Note that the grammar rejects storage classes 	 in typenames, fields or parameters.  */
if|if
condition|(
name|constp
operator|||
name|volatilep
condition|)
name|type
operator|=
name|build_type_variant
argument_list|(
name|type
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|)
expr_stmt|;
comment|/* If the user declares "struct {...} foo" then `foo' will have 	 an anonymous name.  Fill that name in now.  Nothing can 	 refer to it, so nothing needs know about the name change. 	 The TYPE_NAME field was filled in by build_struct_xref.  */
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|ANON_AGGRNAME_P
argument_list|(
name|TYPE_IDENTIFIER
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
comment|/* replace the anonymous name with the real name everywhere.  */
name|lookup_tag_reverse
argument_list|(
name|type
argument_list|,
name|declarator
argument_list|)
expr_stmt|;
name|TYPE_IDENTIFIER
argument_list|(
name|type
argument_list|)
operator|=
name|declarator
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* not yet, should get fixed properly later */
block|decl = make_type_decl (declarator, type);
else|#
directive|else
name|decl
operator|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|declarator
argument_list|,
name|type
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|quals
condition|)
block|{
if|if
condition|(
name|ctype
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|METHOD_TYPE
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"invalid type qualifier for non-method type"
argument_list|)
expr_stmt|;
else|else
name|ctype
operator|=
name|TYPE_METHOD_BASETYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ctype
operator|!=
name|NULL_TREE
condition|)
name|grok_method_quals
argument_list|(
name|ctype
argument_list|,
name|decl
argument_list|,
name|quals
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|specbits
operator|&
name|RIDBIT
argument_list|(
name|RID_SIGNED
argument_list|)
operator|)
operator|||
operator|(
name|typedef_decl
operator|&&
name|C_TYPEDEF_EXPLICITLY_SIGNED
argument_list|(
name|typedef_decl
argument_list|)
operator|)
condition|)
name|C_TYPEDEF_EXPLICITLY_SIGNED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|decl
return|;
block|}
comment|/* Detect the case of an array type of unspecified size      which came, as such, direct from a typedef name.      We must copy the type, so that each identifier gets      a distinct type, so that each identifier's size can be      controlled separately by its own initializer.  */
if|if
condition|(
name|type
operator|==
name|typedef_type
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|type
operator|=
name|build_cplus_array_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If this is a type name (such as, in a cast or sizeof),      compute the type and return it now.  */
if|if
condition|(
name|decl_context
operator|==
name|TYPENAME
condition|)
block|{
comment|/* Note that the grammar rejects storage classes 	 in typenames, fields or parameters.  */
if|if
condition|(
name|constp
operator|||
name|volatilep
condition|)
name|type
operator|=
name|build_type_variant
argument_list|(
name|type
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|)
expr_stmt|;
comment|/* Special case: "friend class foo" looks like a TYPENAME context.  */
if|if
condition|(
name|friendp
condition|)
block|{
comment|/* A friendly class?  */
if|if
condition|(
name|current_class_type
condition|)
name|make_friend_class
argument_list|(
name|current_class_type
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"trying to make class `%s' a friend of global scope"
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|void_type_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|quals
condition|)
block|{
if|#
directive|if
literal|0
comment|/* not yet, should get fixed properly later */
block|tree dummy = make_type_decl (declarator, type);
else|#
directive|else
name|tree
name|dummy
init|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|declarator
argument_list|,
name|type
argument_list|)
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ctype
operator|==
name|NULL_TREE
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
argument_list|,
literal|159
argument_list|)
expr_stmt|;
name|ctype
operator|=
name|TYPE_METHOD_BASETYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
name|grok_method_quals
argument_list|(
name|ctype
argument_list|,
name|dummy
argument_list|,
name|quals
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|dummy
argument_list|)
expr_stmt|;
block|}
return|return
name|type
return|;
block|}
comment|/* `void' at top level (not within pointer)      is allowed only in typedefs or type names.      We don't complain about parms either, but that is because      a better error message can be made later.  */
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|void_type_node
operator|&&
name|decl_context
operator|!=
name|PARM
condition|)
block|{
if|if
condition|(
name|declarator
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
if|if
condition|(
name|IDENTIFIER_OPNAME_P
argument_list|(
name|declarator
argument_list|)
condition|)
name|error
argument_list|(
literal|"operator `%s' declared void"
argument_list|,
name|operator_name_string
argument_list|(
name|declarator
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"variable or field `%s' declared void"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"variable or field declared void"
argument_list|)
expr_stmt|;
name|type
operator|=
name|integer_type_node
expr_stmt|;
block|}
comment|/* Now create the decl, which may be a VAR_DECL, a PARM_DECL      or a FUNCTION_DECL, depending on DECL_CONTEXT and TYPE.  */
block|{
specifier|register
name|tree
name|decl
decl_stmt|;
if|if
condition|(
name|decl_context
operator|==
name|PARM
condition|)
block|{
name|tree
name|parmtype
init|=
name|type
decl_stmt|;
if|if
condition|(
name|ctype
condition|)
name|error
argument_list|(
literal|"cannot use `::' in parameter declaration"
argument_list|)
expr_stmt|;
name|bad_specifiers
argument_list|(
literal|"parameter"
argument_list|,
name|virtualp
argument_list|,
name|quals
operator|!=
name|NULL_TREE
argument_list|,
name|friendp
argument_list|,
name|raises
operator|!=
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* A parameter declared as an array of T is really a pointer to T. 	   One declared as a function is really a pointer to a function. 	   One declared as a member is really a pointer to member.  	   Don't be misled by references.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
if|if
condition|(
name|parmtype
operator|==
name|type
condition|)
block|{
comment|/* Transfer const-ness of array into that of type 		   pointed to.  */
name|type
operator|=
name|build_pointer_type
argument_list|(
name|build_type_variant
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|)
argument_list|)
expr_stmt|;
name|volatilep
operator|=
name|constp
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|type
operator|=
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
name|type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parmtype
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
comment|/* Transfer const-ness of reference into that of type pointed to.  */
name|type
operator|=
name|build_type_variant
argument_list|(
name|build_reference_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|)
expr_stmt|;
name|constp
operator|=
name|volatilep
operator|=
literal|0
expr_stmt|;
block|}
name|decl
operator|=
name|build_decl
argument_list|(
name|PARM_DECL
argument_list|,
name|declarator
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* Compute the type actually passed in the parmlist, 	   for the case where there is no prototype. 	   (For example, shorts and chars are passed as ints.) 	   When there is a prototype, this is overridden later.  */
name|DECL_ARG_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|float_type_node
condition|)
name|DECL_ARG_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|build_type_variant
argument_list|(
name|double_type_node
argument_list|,
name|TYPE_READONLY
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_VOLATILE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|C_PROMOTING_INTEGER_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
name|argtype
decl_stmt|;
comment|/* Retain unsignedness if traditional or if not really 	       getting wider.  */
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
name|flag_traditional
operator|||
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|)
condition|)
name|argtype
operator|=
name|unsigned_type_node
expr_stmt|;
else|else
name|argtype
operator|=
name|integer_type_node
expr_stmt|;
name|DECL_ARG_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|build_type_variant
argument_list|(
name|argtype
argument_list|,
name|TYPE_READONLY
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_VOLATILE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|decl_context
operator|==
name|FIELD
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
block|{
comment|/* Happens when declaring arrays of sizes which 	       are error_mark_node, for example.  */
name|decl
operator|=
name|NULL_TREE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|int
name|publicp
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|friendp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ctype
operator|==
name|NULL_TREE
condition|)
name|ctype
operator|=
name|current_class_type
expr_stmt|;
if|if
condition|(
name|ctype
operator|==
name|NULL_TREE
condition|)
block|{
specifier|register
name|int
name|op
init|=
name|IDENTIFIER_OPNAME_P
argument_list|(
name|declarator
argument_list|)
decl_stmt|;
name|error
argument_list|(
literal|"can't make %s `%s' into a method -- not in a class"
argument_list|,
name|op
condition|?
literal|"operator"
else|:
literal|"function"
argument_list|,
name|op
condition|?
name|operator_name_string
argument_list|(
name|declarator
argument_list|)
else|:
name|IDENTIFIER_POINTER
argument_list|(
name|declarator
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|void_type_node
return|;
block|}
comment|/* ``A union may [ ... ] not [ have ] virtual functions.'' 		   ARM 9.5 */
if|if
condition|(
name|virtualp
operator|&&
name|TREE_CODE
argument_list|(
name|ctype
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"function `%s' declared virtual inside a union"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|declarator
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|void_type_node
return|;
block|}
comment|/* Don't convert type of operators new and delete to 		   METHOD_TYPE; they remain FUNCTION_TYPEs.  */
if|if
condition|(
name|staticp
operator|<
literal|2
operator|&&
name|declarator
operator|!=
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|NEW_EXPR
index|]
operator|&&
name|declarator
operator|!=
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|DELETE_EXPR
index|]
condition|)
name|type
operator|=
name|build_cplus_method_type
argument_list|(
name|build_type_variant
argument_list|(
name|ctype
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Tell grokfndecl if it needs to set TREE_PUBLIC on the node.  */
name|publicp
operator|=
operator|(
operator|(
name|specbits
operator|&
name|RIDBIT
argument_list|(
name|RID_EXTERN
argument_list|)
operator|)
operator|||
operator|(
name|ctype
operator|!=
name|NULL_TREE
operator|&&
name|funcdef_flag
operator|>=
literal|0
operator|)
if|#
directive|if
literal|0
comment|/* These are replicated in each object, so we shouldn't 			  set TREE_PUBLIC. */
expr||| (friendp&& !(specbits& RIDBIT (RID_STATIC))&& !(specbits& RIDBIT (RID_INLINE)))
endif|#
directive|endif
operator|)
expr_stmt|;
name|decl
operator|=
name|grokfndecl
argument_list|(
name|ctype
argument_list|,
name|type
argument_list|,
name|declarator
argument_list|,
name|virtualp
argument_list|,
name|flags
argument_list|,
name|quals
argument_list|,
name|raises
argument_list|,
name|friendp
condition|?
operator|-
literal|1
else|:
literal|0
argument_list|,
name|publicp
argument_list|)
expr_stmt|;
name|DECL_INLINE
argument_list|(
name|decl
argument_list|)
operator|=
name|inlinep
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
comment|/* All method decls are public, so tell grokfndecl to set 	       TREE_PUBLIC, also.  */
name|decl
operator|=
name|grokfndecl
argument_list|(
name|ctype
argument_list|,
name|type
argument_list|,
name|declarator
argument_list|,
name|virtualp
argument_list|,
name|flags
argument_list|,
name|quals
argument_list|,
name|raises
argument_list|,
name|friendp
condition|?
operator|-
literal|1
else|:
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|DECL_INLINE
argument_list|(
name|decl
argument_list|)
operator|=
name|inlinep
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|CLASSTYPE_DECLARED_EXCEPTION
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* Handle a class-local exception declaration.  */
name|decl
operator|=
name|build_lang_field_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|declarator
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctype
operator|==
name|NULL_TREE
condition|)
name|ctype
operator|=
name|current_class_type
expr_stmt|;
name|finish_exception_decl
argument_list|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|ctype
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
condition|?
name|TYPE_IDENTIFIER
argument_list|(
name|ctype
argument_list|)
else|:
name|TYPE_NAME
argument_list|(
name|ctype
argument_list|)
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|void_type_node
return|;
block|}
elseif|else
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|==
name|NULL_TREE
operator|&&
operator|!
name|staticp
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|ARRAY_TYPE
operator|||
name|initialized
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|declarator
condition|)
name|error
argument_list|(
literal|"field `%s' has incomplete type"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|declarator
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"field has incomplete type"
argument_list|)
expr_stmt|;
comment|/* If we're instantiating a template, tell them which 	       instantiation made the field's type be incomplete.  */
if|if
condition|(
name|current_class_type
operator|&&
name|IDENTIFIER_TEMPLATE
argument_list|(
name|current_class_type
argument_list|)
operator|&&
name|declspecs
operator|&&
name|TREE_VALUE
argument_list|(
name|declspecs
argument_list|)
operator|&&
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|declspecs
argument_list|)
argument_list|)
operator|==
name|type
condition|)
name|error
argument_list|(
literal|"  in instantiation of template `%s'"
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|current_class_type
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|error_mark_node
expr_stmt|;
name|decl
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|friendp
condition|)
block|{
if|if
condition|(
name|declarator
condition|)
name|error
argument_list|(
literal|"`%s' is neither function nor method; cannot be declared friend"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|declarator
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|error
argument_list|(
literal|"invalid friend declaration"
argument_list|)
expr_stmt|;
return|return
name|void_type_node
return|;
block|}
name|friendp
operator|=
literal|0
expr_stmt|;
block|}
name|decl
operator|=
name|NULL_TREE
expr_stmt|;
block|}
if|if
condition|(
name|friendp
condition|)
block|{
name|tree
name|t
decl_stmt|;
comment|/* Friends are treated specially.  */
if|if
condition|(
name|ctype
operator|==
name|current_class_type
condition|)
name|warning
argument_list|(
literal|"member functions are implicitly friends of their class"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|decl
operator|&&
operator|(
name|t
operator|=
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
block|{
comment|/* ARM $13.4.3 */
if|if
condition|(
name|t
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|MODIFY_EXPR
index|]
condition|)
name|pedwarn
argument_list|(
literal|"operator `=' must be a member function"
argument_list|)
expr_stmt|;
else|else
return|return
name|do_friend
argument_list|(
name|ctype
argument_list|,
name|declarator
argument_list|,
name|decl
argument_list|,
name|last_function_parms
argument_list|,
name|flags
argument_list|,
name|quals
argument_list|)
return|;
block|}
else|else
return|return
name|void_type_node
return|;
block|}
comment|/* Structure field.  It may not be a function, except for C++ */
if|if
condition|(
name|decl
operator|==
name|NULL_TREE
condition|)
block|{
name|bad_specifiers
argument_list|(
literal|"field"
argument_list|,
name|virtualp
argument_list|,
name|quals
operator|!=
name|NULL_TREE
argument_list|,
name|friendp
argument_list|,
name|raises
operator|!=
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* ANSI C++ June 5 1992 WP 9.2.2 and 9.4.2.  A member-declarator 	       cannot have an initializer, and a static member declaration must 	       be defined elsewhere.  */
if|if
condition|(
name|initialized
condition|)
block|{
if|if
condition|(
name|staticp
condition|)
name|error
argument_list|(
literal|"static member `%s' must be defined separately from its declaration"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|declarator
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Note that initialization of const members is not 		   mentioned in the ARM or draft ANSI standard explicitly, 		   and it appears to be in common practice.  However, 		   reading the draft section 9.2.2, it does say that a 		   member declarator can't have an initializer--it does 		   not except constant members, which also qualify as 		   member-declarators.  */
elseif|else
if|if
condition|(
operator|!
name|pedantic
operator|&&
operator|(
operator|!
name|constp
operator|||
name|flag_ansi
operator|)
condition|)
name|warning
argument_list|(
literal|"ANSI C++ forbids initialization of %s `%s'"
argument_list|,
name|constp
condition|?
literal|"const member"
else|:
literal|"member"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|declarator
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|staticp
operator|||
operator|(
name|constp
operator|&&
name|initialized
operator|)
condition|)
block|{
comment|/* C++ allows static class members. 		   All other work for this is done by grokfield. 		   This VAR_DECL is built by build_lang_field_decl. 		   All other VAR_DECLs are built by build_decl.  */
name|decl
operator|=
name|build_lang_field_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|declarator
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|staticp
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* In class context, static means public visibility.  */
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
operator|!
name|initialized
expr_stmt|;
block|}
else|else
name|decl
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|declarator
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|int
name|was_overloaded
init|=
literal|0
decl_stmt|;
name|tree
name|original_name
init|=
name|declarator
decl_stmt|;
name|int
name|publicp
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|declarator
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|specbits
operator|&
operator|(
name|RIDBIT
argument_list|(
name|RID_AUTO
argument_list|)
operator||
name|RIDBIT
argument_list|(
name|RID_REGISTER
argument_list|)
operator|)
condition|)
name|error
argument_list|(
literal|"invalid storage class for function `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Function declaration not at top level. 	   Storage classes other than `extern' are not allowed 	   and `extern' makes no difference.  */
if|if
condition|(
name|current_binding_level
operator|!=
name|global_binding_level
operator|&&
operator|(
name|specbits
operator|&
operator|(
name|RIDBIT
argument_list|(
name|RID_STATIC
argument_list|)
operator||
name|RIDBIT
argument_list|(
name|RID_INLINE
argument_list|)
operator|)
operator|)
operator|&&
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"invalid storage class for function `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctype
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|virtualp
condition|)
block|{
name|error
argument_list|(
literal|"virtual non-class function `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|virtualp
operator|=
literal|0
expr_stmt|;
block|}
comment|/* ARM $13.4.3 */
comment|/* XXX: It's likely others should also be forbidden.  (bpk) */
if|if
condition|(
name|declarator
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|MODIFY_EXPR
index|]
condition|)
name|warning
argument_list|(
literal|"operator `=' must be a member function"
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_lang_name
operator|==
name|lang_name_cplusplus
operator|&&
operator|!
operator|(
name|IDENTIFIER_LENGTH
argument_list|(
name|original_name
argument_list|)
operator|==
literal|4
operator|&&
name|IDENTIFIER_POINTER
argument_list|(
name|original_name
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'m'
operator|&&
name|strcmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|original_name
argument_list|)
argument_list|,
literal|"main"
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|!
operator|(
name|IDENTIFIER_LENGTH
argument_list|(
name|original_name
argument_list|)
operator|>
literal|10
operator|&&
name|IDENTIFIER_POINTER
argument_list|(
name|original_name
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|IDENTIFIER_POINTER
argument_list|(
name|original_name
argument_list|)
index|[
literal|1
index|]
operator|==
literal|'_'
operator|&&
name|strncmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|original_name
argument_list|)
operator|+
literal|2
argument_list|,
literal|"builtin_"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* Plain overloading: will not be grok'd by grokclassfn.  */
name|declarator
operator|=
name|build_decl_overload
argument_list|(
name|dname
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|was_overloaded
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|&&
name|staticp
operator|<
literal|2
condition|)
name|type
operator|=
name|build_cplus_method_type
argument_list|(
name|build_type_variant
argument_list|(
name|ctype
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Record presence of `static'.  In C++, `inline' is like `static'. 	   Methods of classes should be public, unless we're dropping them 	   into some other file, so we don't clear TREE_PUBLIC for them.  */
name|publicp
operator|=
operator|(
operator|(
name|ctype
operator|&&
operator|!
name|CLASSTYPE_INTERFACE_UNKNOWN
argument_list|(
name|ctype
argument_list|)
operator|&&
operator|!
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|ctype
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|specbits
operator|&
operator|(
name|RIDBIT
argument_list|(
name|RID_STATIC
argument_list|)
operator||
name|RIDBIT
argument_list|(
name|RID_INLINE
argument_list|)
operator|)
operator|)
operator|)
expr_stmt|;
name|decl
operator|=
name|grokfndecl
argument_list|(
name|ctype
argument_list|,
name|type
argument_list|,
name|original_name
argument_list|,
name|virtualp
argument_list|,
name|flags
argument_list|,
name|quals
argument_list|,
name|raises
argument_list|,
name|processing_template_decl
condition|?
literal|0
else|:
name|friendp
condition|?
literal|2
else|:
literal|1
argument_list|,
name|publicp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctype
operator|==
name|NULL_TREE
condition|)
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
operator|=
name|declarator
expr_stmt|;
if|if
condition|(
name|staticp
operator|==
literal|1
condition|)
block|{
name|int
name|illegal_static
init|=
literal|0
decl_stmt|;
comment|/* Don't allow a static member function in a class, and forbid 	       declaring main to be static.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"cannot declare member function `%s' to have static linkage"
argument_list|)
expr_stmt|;
name|illegal_static
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|was_overloaded
operator|&&
operator|!
name|ctype
operator|&&
name|IDENTIFIER_LENGTH
argument_list|(
name|original_name
argument_list|)
operator|==
literal|4
operator|&&
name|IDENTIFIER_POINTER
argument_list|(
name|original_name
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'m'
operator|&&
operator|!
name|strcmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|original_name
argument_list|)
argument_list|,
literal|"main"
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"cannot declare function `main' to have static linkage"
argument_list|)
expr_stmt|;
name|illegal_static
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|illegal_static
condition|)
block|{
name|staticp
operator|=
literal|0
expr_stmt|;
name|specbits
operator|&=
operator|~
name|RIDBIT
argument_list|(
name|RID_STATIC
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Record presence of `inline', if it is reasonable.  */
if|if
condition|(
name|inlinep
condition|)
block|{
name|tree
name|last
init|=
name|tree_last
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|was_overloaded
operator|&&
operator|!
name|ctype
operator|&&
operator|!
name|strcmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|original_name
argument_list|)
argument_list|,
literal|"main"
argument_list|)
condition|)
name|warning
argument_list|(
literal|"cannot inline function `main'"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|last
operator|&&
name|last
operator|!=
name|void_list_node
condition|)
name|warning
argument_list|(
literal|"inline declaration ignored for function with `...'"
argument_list|)
expr_stmt|;
else|else
comment|/* Assume that otherwise the function can be inlined.  */
name|DECL_INLINE
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|specbits
operator|&
name|RIDBIT
argument_list|(
name|RID_EXTERN
argument_list|)
condition|)
block|{
name|current_extern_inline
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|pedantic
condition|)
name|error
argument_list|(
literal|"ANSI C++ does not permit `extern inline'"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|flag_ansi
condition|)
name|warning
argument_list|(
literal|"ANSI C++ does not permit `extern inline'"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|was_overloaded
condition|)
name|DECL_OVERLOADED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* It's a variable.  */
name|bad_specifiers
argument_list|(
literal|"variable"
argument_list|,
name|virtualp
argument_list|,
name|quals
operator|!=
name|NULL_TREE
argument_list|,
name|friendp
argument_list|,
name|raises
operator|!=
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|inlinep
condition|)
name|warning
argument_list|(
literal|"variable declared `inline'"
argument_list|)
expr_stmt|;
comment|/* An uninitialized decl with `extern' is a reference.  */
name|decl
operator|=
name|grokvardecl
argument_list|(
name|type
argument_list|,
name|declarator
argument_list|,
name|specbits
argument_list|,
name|initialized
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctype
condition|)
block|{
if|if
condition|(
name|staticp
operator|==
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"cannot declare member `%s' to have static linkage"
argument_list|,
name|lang_printable_name
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|staticp
operator|=
literal|0
expr_stmt|;
name|specbits
operator|&=
operator|~
name|RIDBIT
argument_list|(
name|RID_STATIC
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|specbits
operator|&
name|RIDBIT
argument_list|(
name|RID_EXTERN
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"cannot explicitly declare member `%s' to have extern linkage"
argument_list|,
name|lang_printable_name
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|specbits
operator|&=
operator|~
name|RIDBIT
argument_list|(
name|RID_EXTERN
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Record `register' declaration for warnings on&        and in case doing stupid register allocation.  */
if|if
condition|(
name|specbits
operator|&
name|RIDBIT
argument_list|(
name|RID_REGISTER
argument_list|)
condition|)
name|DECL_REGISTER
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Record constancy and volatility.  */
if|if
condition|(
name|constp
condition|)
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|REFERENCE_TYPE
expr_stmt|;
if|if
condition|(
name|volatilep
condition|)
block|{
name|TREE_SIDE_EFFECTS
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|decl
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Tell if a parmlist/exprlist looks like an exprlist or a parmlist.    An empty exprlist is a parmlist.  An exprlist which    contains only identifiers at the global level    is a parmlist.  Otherwise, it is an exprlist.  */
end_comment

begin_function
name|int
name|parmlist_is_exprlist
parameter_list|(
name|exprs
parameter_list|)
name|tree
name|exprs
decl_stmt|;
block|{
if|if
condition|(
name|exprs
operator|==
name|NULL_TREE
operator|||
name|TREE_PARMLIST
argument_list|(
name|exprs
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
condition|)
block|{
comment|/* At the global level, if these are all identifiers, 	 then it is a parmlist.  */
while|while
condition|(
name|exprs
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|exprs
argument_list|)
argument_list|)
operator|!=
name|IDENTIFIER_NODE
condition|)
return|return
literal|1
return|;
name|exprs
operator|=
name|TREE_CHAIN
argument_list|(
name|exprs
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Make sure that the this list of PARMS has a chance of being    grokked by `grokparms'.     @@ This is really weak, but the grammar does not allow us    @@ to easily reject things that this has to catch as syntax errors.  */
end_comment

begin_function
specifier|static
name|int
name|parmlist_is_random
parameter_list|(
name|parms
parameter_list|)
name|tree
name|parms
decl_stmt|;
block|{
if|if
condition|(
name|parms
operator|==
name|NULL_TREE
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parms
argument_list|)
operator|!=
name|TREE_LIST
condition|)
return|return
literal|1
return|;
while|while
condition|(
name|parms
condition|)
block|{
if|if
condition|(
name|parms
operator|==
name|void_list_node
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|!=
name|TREE_LIST
condition|)
return|return
literal|1
return|;
comment|/* Don't get faked out by overloaded functions, which 	 masquerade as TREE_LISTs!  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|==
name|unknown_type_node
condition|)
return|return
literal|1
return|;
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of `grokparms'.  In a fcn definition, arg types must    be complete.     C++: also subroutine of `start_function'.  */
end_comment

begin_function
specifier|static
name|void
name|require_complete_types_for_parms
parameter_list|(
name|parms
parameter_list|)
name|tree
name|parms
decl_stmt|;
block|{
while|while
condition|(
name|parms
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|parms
argument_list|)
condition|)
name|error
argument_list|(
literal|"parameter `%s' has incomplete type"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|parms
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"parameter has incomplete type"
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* If the arg types are incomplete in a declaration, 	 they must include undefined tags. 	 These tags can never be defined in the scope of the declaration, 	 so the types can never be completed, 	 and no call can be compiled successfully.  */
comment|/* This is not the right behavior for C++, but not having 	 it is also probably wrong.  */
block|else 	{
comment|/* Now warn if is a pointer to an incomplete type.  */
block|while (TREE_CODE (type) == POINTER_TYPE 		 || TREE_CODE (type) == REFERENCE_TYPE) 	    type = TREE_TYPE (type); 	  type = TYPE_MAIN_VARIANT (type); 	  if (TYPE_SIZE (type) == NULL_TREE) 	    { 	      if (DECL_NAME (parm) != NULL_TREE) 		warning ("parameter `%s' points to incomplete type", 			 IDENTIFIER_POINTER (DECL_NAME (parm))); 	      else 		warning ("parameter points to incomplete type"); 	    } 	}
endif|#
directive|endif
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Decode the list of parameter types for a function type.    Given the list of things declared inside the parens,    return a list of types.     The list we receive can have three kinds of elements:    an IDENTIFIER_NODE for names given without types,    a TREE_LIST node for arguments given as typespecs or names with typespecs,    or void_type_node, to mark the end of an argument list    when additional arguments are not permitted (... was not used).     FUNCDEF_FLAG is nonzero for a function definition, 0 for    a mere declaration.  A nonempty identifier-list gets an error message    when FUNCDEF_FLAG is zero.    If FUNCDEF_FLAG is 1, then parameter types must be complete.    If FUNCDEF_FLAG is -1, then parameter types may be incomplete.     If all elements of the input list contain types,    we return a list of the types.    If all elements contain no type (except perhaps a void_type_node    at the end), we return a null list.    If some have types and some do not, it is an error, and we    return a null list.     Also set last_function_parms to either    a list of names (IDENTIFIER_NODEs) or a chain of PARM_DECLs.    A list of names is converted to a chain of PARM_DECLs    by store_parm_decls so that ultimately it is always a chain of decls.     Note that in C++, parameters can take default values.  These default    values are in the TREE_PURPOSE field of the TREE_LIST.  It is    an error to specify default values which are followed by parameters    that have no default values, or an ELLIPSES.  For simplicities sake,    only parameters which are specified with their types can take on    default values.  */
end_comment

begin_function
specifier|static
name|tree
name|grokparms
parameter_list|(
name|first_parm
parameter_list|,
name|funcdef_flag
parameter_list|)
name|tree
name|first_parm
decl_stmt|;
name|int
name|funcdef_flag
decl_stmt|;
block|{
name|tree
name|result
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|decls
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|first_parm
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|first_parm
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
if|if
condition|(
operator|!
name|funcdef_flag
condition|)
name|warning
argument_list|(
literal|"parameter names (without types) in function declaration"
argument_list|)
expr_stmt|;
name|last_function_parms
operator|=
name|first_parm
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
else|else
block|{
comment|/* Types were specified.  This is a list of declarators 	 each represented as a TREE_LIST node.  */
specifier|register
name|tree
name|parm
decl_stmt|,
name|chain
decl_stmt|;
name|int
name|any_init
init|=
literal|0
decl_stmt|,
name|any_error
init|=
literal|0
decl_stmt|,
name|saw_void
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|first_parm
operator|!=
name|NULL_TREE
condition|)
block|{
name|tree
name|last_result
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|last_decl
init|=
name|NULL_TREE
decl_stmt|;
for|for
control|(
name|parm
operator|=
name|first_parm
init|;
name|parm
operator|!=
name|NULL_TREE
condition|;
name|parm
operator|=
name|chain
control|)
block|{
name|tree
name|type
decl_stmt|,
name|list_node
init|=
name|parm
decl_stmt|;
specifier|register
name|tree
name|decl
init|=
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
decl_stmt|;
name|tree
name|init
init|=
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
decl_stmt|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
expr_stmt|;
comment|/* @@ weak defense against parse errors.  */
if|if
condition|(
name|decl
operator|!=
name|void_type_node
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|TREE_LIST
condition|)
block|{
comment|/* Give various messages as the need arises.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|STRING_CST
condition|)
name|error
argument_list|(
literal|"invalid string constant `%s'"
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|error
argument_list|(
literal|"invalid integer constant in parameter list, did you forget to give parameter name?"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|decl
operator|!=
name|void_type_node
condition|)
block|{
comment|/* @@ May need to fetch out a `raises' here.  */
name|decl
operator|=
name|grokdeclarator
argument_list|(
name|TREE_VALUE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|PARM
argument_list|,
name|init
operator|!=
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|decl
condition|)
continue|continue;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|void_type_node
condition|)
name|decl
operator|=
name|void_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
condition|)
comment|/* Cannot use `error_with_decl' here because 			   we don't have DECL_CONTEXT set up yet.  */
name|error
argument_list|(
literal|"parameter `%s' invalidly declared method type"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"parameter invalidly declared method type"
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|type
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
condition|)
name|error
argument_list|(
literal|"parameter `%s' invalidly declared offset type"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"parameter invalidly declared offset type"
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|type
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|TYPE_LANG_SPECIFIC
argument_list|(
name|type
argument_list|)
operator|&&
name|CLASSTYPE_ABSTRACT_VIRTUALS
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|abstract_virtuals_error
argument_list|(
name|decl
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|any_error
operator|=
literal|1
expr_stmt|;
comment|/* seems like a good idea */
block|}
block|}
if|if
condition|(
name|decl
operator|==
name|void_type_node
condition|)
block|{
if|if
condition|(
name|result
operator|==
name|NULL_TREE
condition|)
block|{
name|result
operator|=
name|void_list_node
expr_stmt|;
name|last_result
operator|=
name|result
expr_stmt|;
block|}
else|else
block|{
name|TREE_CHAIN
argument_list|(
name|last_result
argument_list|)
operator|=
name|void_list_node
expr_stmt|;
name|last_result
operator|=
name|void_list_node
expr_stmt|;
block|}
name|saw_void
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|chain
operator|&&
operator|(
name|chain
operator|!=
name|void_list_node
operator|||
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
operator|)
condition|)
name|error
argument_list|(
literal|"`void' in parameter list must be entire list"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Since there is a prototype, args are passed in their own types.  */
name|DECL_ARG_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PROMOTE_PROTOTYPES
if|if
condition|(
name|C_PROMOTING_INTEGER_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
name|DECL_ARG_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|any_error
condition|)
block|{
if|if
condition|(
name|init
condition|)
block|{
name|any_init
operator|++
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|SAVE_EXPR
condition|)
name|PARM_DECL_EXPR
argument_list|(
name|init
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
if|if
condition|(
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|init
argument_list|)
argument_list|)
condition|)
block|{
comment|/* ``Local variables may not be used in default 				 argument expressions.'' dpANSI C++ 8.2.6 */
comment|/* If extern int i; within a function is not 				 considered a local variable, then this code is 				 wrong. */
name|error_with_decl
argument_list|(
name|init
argument_list|,
literal|"local variable `%s' may not be used as a default argument"
argument_list|)
expr_stmt|;
name|any_error
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_READONLY_DECL_P
argument_list|(
name|init
argument_list|)
condition|)
name|init
operator|=
name|decl_constant_value
argument_list|(
name|init
argument_list|)
expr_stmt|;
block|}
else|else
name|init
operator|=
name|require_instantiated_type
argument_list|(
name|type
argument_list|,
name|init
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|any_init
condition|)
block|{
name|error
argument_list|(
literal|"all trailing parameters must have default arguments"
argument_list|)
expr_stmt|;
name|any_error
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
name|init
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|decls
operator|==
name|NULL_TREE
condition|)
block|{
name|decls
operator|=
name|decl
expr_stmt|;
name|last_decl
operator|=
name|decls
expr_stmt|;
block|}
else|else
block|{
name|TREE_CHAIN
argument_list|(
name|last_decl
argument_list|)
operator|=
name|decl
expr_stmt|;
name|last_decl
operator|=
name|decl
expr_stmt|;
block|}
if|if
condition|(
name|TREE_PERMANENT
argument_list|(
name|list_node
argument_list|)
condition|)
block|{
name|TREE_PURPOSE
argument_list|(
name|list_node
argument_list|)
operator|=
name|init
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|list_node
argument_list|)
operator|=
name|type
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|list_node
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
name|list_node
operator|=
name|saveable_tree_cons
argument_list|(
name|init
argument_list|,
name|type
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL_TREE
condition|)
block|{
name|result
operator|=
name|list_node
expr_stmt|;
name|last_result
operator|=
name|result
expr_stmt|;
block|}
else|else
block|{
name|TREE_CHAIN
argument_list|(
name|last_result
argument_list|)
operator|=
name|list_node
expr_stmt|;
name|last_result
operator|=
name|list_node
expr_stmt|;
block|}
block|}
if|if
condition|(
name|last_result
condition|)
name|TREE_CHAIN
argument_list|(
name|last_result
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* If there are no parameters, and the function does not end 	     with `...', then last_decl will be NULL_TREE.  */
if|if
condition|(
name|last_decl
operator|!=
name|NULL_TREE
condition|)
name|TREE_CHAIN
argument_list|(
name|last_decl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
name|last_function_parms
operator|=
name|decls
expr_stmt|;
comment|/* In a fcn definition, arg types must be complete.  */
if|if
condition|(
name|funcdef_flag
operator|>
literal|0
condition|)
name|require_complete_types_for_parms
argument_list|(
name|last_function_parms
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* These memoizing functions keep track of special properties which    a class may have.  `grok_ctor_properties' notices whether a class    has a constructor of the for X(X&), and also complains    if the class has a constructor of the form X(X).    `grok_op_properties' takes notice of the various forms of    operator= which are defined, as well as what sorts of type conversion    may apply.  Both functions take a FUNCTION_DECL as an argument.  */
end_comment

begin_function
name|void
name|grok_ctor_properties
parameter_list|(
name|ctype
parameter_list|,
name|decl
parameter_list|)
name|tree
name|ctype
decl_stmt|,
name|decl
decl_stmt|;
block|{
name|tree
name|parmtypes
init|=
name|FUNCTION_ARG_CHAIN
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|tree
name|parmtype
init|=
name|parmtypes
condition|?
name|TREE_VALUE
argument_list|(
name|parmtypes
argument_list|)
else|:
name|void_type_node
decl_stmt|;
if|if
condition|(
name|parmtypes
operator|&&
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|&&
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|parmtypes
operator|=
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
expr_stmt|;
name|parmtype
operator|=
name|TREE_VALUE
argument_list|(
name|parmtypes
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parmtype
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|parmtype
argument_list|)
argument_list|)
operator|==
name|ctype
condition|)
block|{
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
operator|==
name|NULL_TREE
operator|||
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
operator|==
name|void_list_node
operator|||
name|TREE_PURPOSE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
argument_list|)
condition|)
block|{
name|TYPE_HAS_INIT_REF
argument_list|(
name|ctype
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_GETS_INIT_REF
argument_list|(
name|ctype
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TYPE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|parmtype
argument_list|)
argument_list|)
condition|)
name|TYPE_GETS_CONST_INIT_REF
argument_list|(
name|ctype
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|TYPE_GETS_INIT_AGGR
argument_list|(
name|ctype
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|parmtype
argument_list|)
operator|==
name|ctype
condition|)
block|{
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
operator|==
name|void_list_node
condition|)
name|error
argument_list|(
literal|"invalid constructor; you probably meant `%s (%s&)'"
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|ctype
argument_list|)
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|ctype
argument_list|)
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_ERROR_LOCUS
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
name|ctype
argument_list|)
expr_stmt|;
name|TYPE_GETS_INIT_AGGR
argument_list|(
name|ctype
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parmtype
argument_list|)
operator|==
name|VOID_TYPE
operator|||
name|TREE_PURPOSE
argument_list|(
name|parmtypes
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|TYPE_HAS_DEFAULT_CONSTRUCTOR
argument_list|(
name|ctype
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Do a little sanity-checking on how they declared their operator.  */
end_comment

begin_function
specifier|static
name|void
name|grok_op_properties
parameter_list|(
name|decl
parameter_list|,
name|virtualp
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|int
name|virtualp
decl_stmt|;
block|{
name|tree
name|argtypes
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|NEW_EXPR
index|]
condition|)
block|{
if|if
condition|(
name|virtualp
condition|)
name|error
argument_list|(
literal|"`operator new' cannot be declared virtual"
argument_list|)
expr_stmt|;
comment|/* Take care of function decl if we had syntax errors.  */
if|if
condition|(
name|argtypes
operator|==
name|NULL_TREE
condition|)
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|hash_tree_chain
argument_list|(
name|integer_type_node
argument_list|,
name|void_list_node
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|decl
operator|=
name|coerce_new_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|DELETE_EXPR
index|]
condition|)
block|{
if|if
condition|(
name|virtualp
condition|)
name|error
argument_list|(
literal|"`operator delete' cannot be declared virtual"
argument_list|)
expr_stmt|;
if|if
condition|(
name|argtypes
operator|==
name|NULL_TREE
condition|)
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|hash_tree_chain
argument_list|(
name|ptr_type_node
argument_list|,
name|void_list_node
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|decl
operator|=
name|coerce_delete_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"`%s' cannot be a static member function"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|MODIFY_EXPR
index|]
condition|)
block|{
name|tree
name|parmtypes
decl_stmt|;
name|tree
name|parmtype
decl_stmt|;
if|if
condition|(
name|argtypes
operator|==
name|NULL_TREE
condition|)
block|{
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"too few arguments to `%s'"
argument_list|)
expr_stmt|;
return|return;
block|}
name|parmtypes
operator|=
name|TREE_CHAIN
argument_list|(
name|argtypes
argument_list|)
expr_stmt|;
name|parmtype
operator|=
name|parmtypes
condition|?
name|TREE_VALUE
argument_list|(
name|parmtypes
argument_list|)
else|:
name|void_type_node
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parmtype
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|&&
name|TREE_TYPE
argument_list|(
name|parmtype
argument_list|)
operator|==
name|current_class_type
condition|)
block|{
name|TYPE_HAS_ASSIGN_REF
argument_list|(
name|current_class_type
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_GETS_ASSIGN_REF
argument_list|(
name|current_class_type
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TYPE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|parmtype
argument_list|)
argument_list|)
condition|)
name|TYPE_GETS_CONST_INIT_REF
argument_list|(
name|current_class_type
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Get the struct, enum or union (CODE says which) with tag NAME.    Define the tag as a forward-reference if it is not defined.     C++: If a class derivation is given, process it here, and report    an error if multiple derivation declarations are not identical.     If this is a definition, come in through xref_tag and only look in    the current frame for the name (since C++ allows new names in any    scope.)  */
end_comment

begin_comment
comment|/* avoid rewriting all callers of xref_tag */
end_comment

begin_decl_stmt
specifier|static
name|int
name|xref_next_defn
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|tree
name|xref_defn_tag
parameter_list|(
name|code_type_node
parameter_list|,
name|name
parameter_list|,
name|binfo
parameter_list|)
name|tree
name|code_type_node
decl_stmt|;
name|tree
name|name
decl_stmt|,
name|binfo
decl_stmt|;
block|{
name|tree
name|rv
decl_stmt|,
name|ncp
decl_stmt|;
name|xref_next_defn
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|class_binding_level
condition|)
block|{
name|tree
name|n1
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
comment|/* we need to build a new IDENTIFIER_NODE for name which nukes        * the pieces... */
name|n1
operator|=
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|current_class_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|n1
condition|)
name|n1
operator|=
name|DECL_NAME
argument_list|(
name|n1
argument_list|)
expr_stmt|;
else|else
name|n1
operator|=
name|current_class_name
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|4
operator|+
name|IDENTIFIER_LENGTH
argument_list|(
name|n1
argument_list|)
operator|+
name|IDENTIFIER_LENGTH
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s::%s"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|n1
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|ncp
operator|=
name|get_identifier
argument_list|(
name|buf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SPEW_DEBUG
if|if
condition|(
name|spew_debug
condition|)
name|printf
argument_list|(
literal|"*** %s ***\n"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|ncp
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
literal|0
block|IDENTIFIER_LOCAL_VALUE (name) = 	build_lang_decl (TYPE_DECL, ncp, NULL_TREE);
endif|#
directive|endif
name|rv
operator|=
name|xref_tag
argument_list|(
name|code_type_node
argument_list|,
name|name
argument_list|,
name|binfo
argument_list|)
expr_stmt|;
name|pushdecl_top_level
argument_list|(
name|build_lang_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|ncp
argument_list|,
name|rv
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rv
operator|=
name|xref_tag
argument_list|(
name|code_type_node
argument_list|,
name|name
argument_list|,
name|binfo
argument_list|)
expr_stmt|;
block|}
name|xref_next_defn
operator|=
literal|0
expr_stmt|;
return|return
name|rv
return|;
block|}
end_function

begin_function
name|tree
name|xref_tag
parameter_list|(
name|code_type_node
parameter_list|,
name|name
parameter_list|,
name|binfo
parameter_list|)
name|tree
name|code_type_node
decl_stmt|;
name|tree
name|name
decl_stmt|,
name|binfo
decl_stmt|;
block|{
name|enum
name|tag_types
name|tag_code
decl_stmt|;
name|enum
name|tree_code
name|code
decl_stmt|;
name|int
name|temp
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
specifier|register
name|tree
name|ref
decl_stmt|;
name|struct
name|binding_level
modifier|*
name|b
init|=
operator|(
name|class_binding_level
condition|?
name|class_binding_level
else|:
name|current_binding_level
operator|)
decl_stmt|;
name|tag_code
operator|=
operator|(
expr|enum
name|tag_types
operator|)
name|TREE_INT_CST_LOW
argument_list|(
name|code_type_node
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tag_code
condition|)
block|{
case|case
name|record_type
case|:
case|case
name|class_type
case|:
case|case
name|exception_type
case|:
name|code
operator|=
name|RECORD_TYPE
expr_stmt|;
name|len
operator|=
name|list_length
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
break|break;
case|case
name|union_type
case|:
name|code
operator|=
name|UNION_TYPE
expr_stmt|;
if|if
condition|(
name|binfo
condition|)
block|{
name|error
argument_list|(
literal|"derived union `%s' invalid"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|binfo
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|len
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|enum_type
case|:
name|code
operator|=
name|ENUMERAL_TYPE
expr_stmt|;
break|break;
default|default:
name|my_friendly_abort
argument_list|(
literal|18
argument_list|)
expr_stmt|;
block|}
comment|/* If a cross reference is requested, look up the type      already defined for this tag and return it.  */
if|if
condition|(
name|xref_next_defn
condition|)
block|{
comment|/* If we know we are defining this tag, only look it up in this scope        * and don't try to find it as a type. */
name|xref_next_defn
operator|=
literal|0
expr_stmt|;
name|ref
operator|=
name|lookup_tag
argument_list|(
name|code
argument_list|,
name|name
argument_list|,
name|b
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ref
operator|=
name|lookup_tag
argument_list|(
name|code
argument_list|,
name|name
argument_list|,
name|b
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ref
condition|)
block|{
comment|/* Try finding it as a type declaration.  If that wins, use it.  */
name|ref
operator|=
name|lookup_name
argument_list|(
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ref
operator|&&
name|TREE_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ref
argument_list|)
argument_list|)
operator|==
name|code
condition|)
name|ref
operator|=
name|TREE_TYPE
argument_list|(
name|ref
argument_list|)
expr_stmt|;
else|else
name|ref
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ref
condition|)
block|{
comment|/* If no such tag is yet defined, create a forward-reference node 	 and record it as the "definition". 	 When a real declaration of this type is found, 	 the forward-reference will be altered into a real type.  */
comment|/* In C++, since these migrate into the global scope, we must 	 build them on the permanent obstack.  */
name|temp
operator|=
name|allocation_temporary_p
argument_list|()
expr_stmt|;
if|if
condition|(
name|temp
condition|)
name|end_temporary_allocation
argument_list|()
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|ENUMERAL_TYPE
condition|)
block|{
name|ref
operator|=
name|make_node
argument_list|(
name|ENUMERAL_TYPE
argument_list|)
expr_stmt|;
comment|/* Give the type a default layout like unsigned int 	     to avoid crashing if it does not get defined.  */
name|TYPE_MODE
argument_list|(
name|ref
argument_list|)
operator|=
name|TYPE_MODE
argument_list|(
name|unsigned_type_node
argument_list|)
expr_stmt|;
name|TYPE_ALIGN
argument_list|(
name|ref
argument_list|)
operator|=
name|TYPE_ALIGN
argument_list|(
name|unsigned_type_node
argument_list|)
expr_stmt|;
name|TREE_UNSIGNED
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_PRECISION
argument_list|(
name|ref
argument_list|)
operator|=
name|TYPE_PRECISION
argument_list|(
name|unsigned_type_node
argument_list|)
expr_stmt|;
name|TYPE_MIN_VALUE
argument_list|(
name|ref
argument_list|)
operator|=
name|TYPE_MIN_VALUE
argument_list|(
name|unsigned_type_node
argument_list|)
expr_stmt|;
name|TYPE_MAX_VALUE
argument_list|(
name|ref
argument_list|)
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|unsigned_type_node
argument_list|)
expr_stmt|;
comment|/* Enable us to recognize when a type is created in class context. 	     To do nested classes correctly, this should probably be cleared 	     out when we leave this classes scope.  Currently this in only 	     done in `start_enum'.  */
name|pushtag
argument_list|(
name|name
argument_list|,
name|ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_cadillac
condition|)
name|cadillac_start_enum
argument_list|(
name|ref
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tag_code
operator|==
name|exception_type
condition|)
block|{
name|ref
operator|=
name|make_lang_type
argument_list|(
name|code
argument_list|)
expr_stmt|;
comment|/* Enable us to recognize when an exception type is created in 	     class context.  To do nested classes correctly, this should 	     probably be cleared out when we leave this class's scope.  */
name|CLASSTYPE_DECLARED_EXCEPTION
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
name|pushtag
argument_list|(
name|name
argument_list|,
name|ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_cadillac
condition|)
name|cadillac_start_struct
argument_list|(
name|ref
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|extern
name|tree
name|pending_vtables
decl_stmt|;
name|struct
name|binding_level
modifier|*
name|old_b
init|=
name|class_binding_level
decl_stmt|;
name|int
name|needs_writing
decl_stmt|;
name|ref
operator|=
name|make_lang_type
argument_list|(
name|code
argument_list|)
expr_stmt|;
comment|/* Record how to set the visibility of this class's 	     virtual functions.  If write_virtuals == 2 or 3, then 	     inline virtuals are ``extern inline''.  */
switch|switch
condition|(
name|write_virtuals
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|1
case|:
name|needs_writing
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|needs_writing
operator|=
operator|!
operator|!
name|value_member
argument_list|(
name|name
argument_list|,
name|pending_vtables
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|needs_writing
operator|=
operator|!
operator|(
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|ref
argument_list|)
operator|||
name|CLASSTYPE_INTERFACE_UNKNOWN
argument_list|(
name|ref
argument_list|)
operator|)
expr_stmt|;
break|break;
default|default:
name|needs_writing
operator|=
literal|0
expr_stmt|;
block|}
name|CLASSTYPE_VTABLE_NEEDS_WRITING
argument_list|(
name|ref
argument_list|)
operator|=
name|needs_writing
expr_stmt|;
ifdef|#
directive|ifdef
name|NONNESTED_CLASSES
comment|/* Class types don't nest the way enums do.  */
name|class_binding_level
operator|=
operator|(
expr|struct
name|binding_level
operator|*
operator|)
literal|0
expr_stmt|;
endif|#
directive|endif
name|pushtag
argument_list|(
name|name
argument_list|,
name|ref
argument_list|)
expr_stmt|;
name|class_binding_level
operator|=
name|old_b
expr_stmt|;
if|if
condition|(
name|flag_cadillac
condition|)
name|cadillac_start_struct
argument_list|(
name|ref
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|IS_AGGR_TYPE_CODE
argument_list|(
name|code
argument_list|)
condition|)
block|{
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|ref
argument_list|)
operator|&&
operator|(
operator|(
name|tag_code
operator|==
name|exception_type
operator|)
operator|!=
operator|(
name|CLASSTYPE_DECLARED_EXCEPTION
argument_list|(
name|ref
argument_list|)
operator|==
literal|1
operator|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"type `%s' is both exception and aggregate type"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|CLASSTYPE_DECLARED_EXCEPTION
argument_list|(
name|ref
argument_list|)
operator|=
operator|(
name|tag_code
operator|==
name|exception_type
operator|)
expr_stmt|;
block|}
block|}
comment|/* If it no longer looks like a nested type, make sure it's 	 in global scope.  */
if|if
condition|(
name|b
operator|==
name|global_binding_level
operator|&&
operator|!
name|class_binding_level
operator|&&
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
operator|=
name|TYPE_NAME
argument_list|(
name|ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|binfo
condition|)
block|{
name|tree
name|tt1
init|=
name|binfo
decl_stmt|;
name|tree
name|tt2
init|=
name|TYPE_BINFO_BASETYPES
argument_list|(
name|ref
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_BINFO_BASETYPES
argument_list|(
name|ref
argument_list|)
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|tt1
condition|;
name|i
operator|++
operator|,
name|tt1
operator|=
name|TREE_CHAIN
argument_list|(
name|tt1
argument_list|)
control|)
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|tt1
argument_list|)
operator|!=
name|TYPE_IDENTIFIER
argument_list|(
name|BINFO_TYPE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|tt2
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"redeclaration of derivation chain of type `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|tt1
operator|==
name|NULL_TREE
condition|)
comment|/* The user told us something we already knew.  */
goto|goto
name|just_return
goto|;
comment|/* In C++, since these migrate into the global scope, we must 	     build them on the permanent obstack.  */
name|end_temporary_allocation
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|binfo
condition|)
block|{
comment|/* In the declaration `A : X, Y, ... Z' we mark all the types 	 (A, X, Y, ..., Z) so we can check for duplicates.  */
name|tree
name|binfos
decl_stmt|;
name|SET_CLASSTYPE_MARKED
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|BINFO_BASETYPES
argument_list|(
name|TYPE_BINFO
argument_list|(
name|ref
argument_list|)
argument_list|)
operator|=
name|binfos
operator|=
name|make_tree_vec
argument_list|(
name|len
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|binfo
condition|;
name|binfo
operator|=
name|TREE_CHAIN
argument_list|(
name|binfo
argument_list|)
control|)
block|{
comment|/* The base of a derived struct is public.  */
name|int
name|via_public
init|=
operator|(
name|tag_code
operator|!=
name|class_type
operator|||
name|TREE_PURPOSE
argument_list|(
name|binfo
argument_list|)
operator|==
operator|(
name|tree
operator|)
name|visibility_public
operator|||
name|TREE_PURPOSE
argument_list|(
name|binfo
argument_list|)
operator|==
operator|(
name|tree
operator|)
name|visibility_public_virtual
operator|)
decl_stmt|;
name|int
name|via_protected
init|=
name|TREE_PURPOSE
argument_list|(
name|binfo
argument_list|)
operator|==
operator|(
name|tree
operator|)
name|visibility_protected
decl_stmt|;
name|int
name|via_virtual
init|=
operator|(
name|TREE_PURPOSE
argument_list|(
name|binfo
argument_list|)
operator|==
operator|(
name|tree
operator|)
name|visibility_private_virtual
operator|||
name|TREE_PURPOSE
argument_list|(
name|binfo
argument_list|)
operator|==
operator|(
name|tree
operator|)
name|visibility_public_virtual
operator|||
name|TREE_PURPOSE
argument_list|(
name|binfo
argument_list|)
operator|==
operator|(
name|tree
operator|)
name|visibility_default_virtual
operator|)
decl_stmt|;
name|tree
name|basetype
init|=
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|binfo
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|base_binfo
decl_stmt|;
name|GNU_xref_hier
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|binfo
argument_list|)
argument_list|)
argument_list|,
name|via_public
argument_list|,
name|via_virtual
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|basetype
operator|&&
name|TREE_CODE
argument_list|(
name|basetype
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|basetype
operator|=
name|TREE_TYPE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|basetype
operator|||
name|TREE_CODE
argument_list|(
name|basetype
argument_list|)
operator|!=
name|RECORD_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"base type `%s' fails to be a struct or class type"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|binfo
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|#
directive|if
literal|1
comment|/* This code replaces similar code in layout_basetypes.  */
elseif|else
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|basetype
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|error_with_aggr_type
argument_list|(
name|basetype
argument_list|,
literal|"base class `%s' has incomplete type"
argument_list|)
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
else|else
block|{
if|if
condition|(
name|CLASSTYPE_MARKED
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
if|if
condition|(
name|basetype
operator|==
name|ref
condition|)
name|error_with_aggr_type
argument_list|(
name|basetype
argument_list|,
literal|"recursive type `%s' undefined"
argument_list|)
expr_stmt|;
else|else
name|error_with_aggr_type
argument_list|(
name|basetype
argument_list|,
literal|"duplicate base type `%s' invalid"
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Note that the BINFO records which describe individual  		 inheritances are *not* shared in the lattice!  They  		 cannot be shared because a given baseclass may be  		 inherited with different `accessibility' by different  		 derived classes.  (Each BINFO record describing an  		 individual inheritance contains flags which say what  		 the `accessibility' of that particular inheritance is.)  */
name|base_binfo
operator|=
name|make_binfo
argument_list|(
name|integer_zero_node
argument_list|,
name|basetype
argument_list|,
name|TYPE_BINFO_VTABLE
argument_list|(
name|basetype
argument_list|)
argument_list|,
name|TYPE_BINFO_VIRTUALS
argument_list|(
name|basetype
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
operator|=
name|base_binfo
expr_stmt|;
name|TREE_VIA_PUBLIC
argument_list|(
name|base_binfo
argument_list|)
operator|=
name|via_public
expr_stmt|;
name|TREE_VIA_PROTECTED
argument_list|(
name|base_binfo
argument_list|)
operator|=
name|via_protected
expr_stmt|;
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
operator|=
name|via_virtual
expr_stmt|;
name|SET_CLASSTYPE_MARKED
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* XYZZY TEST VIRTUAL BASECLASSES */
block|if (CLASSTYPE_N_BASECLASSES (basetype) == NULL_TREE&& TYPE_HAS_DEFAULT_CONSTRUCTOR (basetype)&& via_virtual == 0)   {     warning ("making type `%s' a virtual baseclass", 	     TYPE_NAME_STRING (basetype));     via_virtual = 1;   }
endif|#
directive|endif
comment|/* We are free to modify these bits because they are meaningless 		 at top level, and BASETYPE is a top-level type.  */
if|if
condition|(
name|via_virtual
operator|||
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_USES_COMPLEX_INHERITANCE
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|TYPE_GETS_ASSIGNMENT
argument_list|(
name|ref
argument_list|)
operator||=
name|TYPE_GETS_ASSIGNMENT
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TYPE_OVERLOADS_METHOD_CALL_EXPR
argument_list|(
name|ref
argument_list|)
operator||=
name|TYPE_OVERLOADS_METHOD_CALL_EXPR
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TREE_GETS_NEW
argument_list|(
name|ref
argument_list|)
operator||=
name|TREE_GETS_NEW
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TREE_GETS_DELETE
argument_list|(
name|ref
argument_list|)
operator||=
name|TREE_GETS_DELETE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|CLASSTYPE_LOCAL_TYPEDECLS
argument_list|(
name|ref
argument_list|)
operator||=
name|CLASSTYPE_LOCAL_TYPEDECLS
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
condition|)
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
operator|=
name|i
expr_stmt|;
else|else
name|BINFO_BASETYPES
argument_list|(
name|TYPE_BINFO
argument_list|(
name|ref
argument_list|)
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|1
condition|)
name|TYPE_USES_MULTIPLE_INHERITANCE
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
literal|1
condition|)
name|TYPE_USES_MULTIPLE_INHERITANCE
argument_list|(
name|ref
argument_list|)
operator|=
name|TYPE_USES_MULTIPLE_INHERITANCE
argument_list|(
name|BINFO_TYPE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_USES_MULTIPLE_INHERITANCE
argument_list|(
name|ref
argument_list|)
condition|)
name|TYPE_USES_COMPLEX_INHERITANCE
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Unmark all the types.  */
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
name|CLEAR_CLASSTYPE_MARKED
argument_list|(
name|BINFO_TYPE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|CLEAR_CLASSTYPE_MARKED
argument_list|(
name|ref
argument_list|)
expr_stmt|;
block|}
name|just_return
label|:
comment|/* Until the type is defined, tentatively accept whatever      structure tag the user hands us.  */
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|ref
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|ref
operator|!=
name|current_class_type
comment|/* Have to check this, in case we have contradictory tag info.  */
operator|&&
name|IS_AGGR_TYPE_CODE
argument_list|(
name|TREE_CODE
argument_list|(
name|ref
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|tag_code
operator|==
name|class_type
condition|)
name|CLASSTYPE_DECLARED_CLASS
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|tag_code
operator|==
name|record_type
condition|)
name|CLASSTYPE_DECLARED_CLASS
argument_list|(
name|ref
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
name|pop_obstacks
argument_list|()
expr_stmt|;
return|return
name|ref
return|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|tree
name|current_local_enum
init|=
name|NULL_TREE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Begin compiling the definition of an enumeration type.    NAME is its name (or null if anonymous).    Returns the type object, as yet incomplete.    Also records info about it so that build_enumerator    may be used to declare the individual values as they are read.  */
end_comment

begin_function
name|tree
name|start_enum
parameter_list|(
name|name
parameter_list|)
name|tree
name|name
decl_stmt|;
block|{
specifier|register
name|tree
name|enumtype
init|=
name|NULL_TREE
decl_stmt|;
name|struct
name|binding_level
modifier|*
name|b
init|=
operator|(
name|class_binding_level
condition|?
name|class_binding_level
else|:
name|current_binding_level
operator|)
decl_stmt|;
comment|/* If this is the real definition for a previous forward reference,      fill in the contents in the same object that used to be the      forward reference.  */
if|if
condition|(
name|name
operator|!=
name|NULL_TREE
condition|)
name|enumtype
operator|=
name|lookup_tag
argument_list|(
name|ENUMERAL_TYPE
argument_list|,
name|name
argument_list|,
name|b
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|enumtype
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|enumtype
argument_list|)
operator|!=
name|ENUMERAL_TYPE
condition|)
block|{
name|enumtype
operator|=
name|make_node
argument_list|(
name|ENUMERAL_TYPE
argument_list|)
expr_stmt|;
name|pushtag
argument_list|(
name|name
argument_list|,
name|enumtype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|current_class_type
condition|)
name|TREE_ADDRESSABLE
argument_list|(
name|b
operator|->
name|tags
argument_list|)
operator|=
literal|1
expr_stmt|;
name|current_local_enum
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|TYPE_VALUES
argument_list|(
name|enumtype
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
comment|/* This enum is a named one that has been declared already.  */
name|error
argument_list|(
literal|"redeclaration of `enum %s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Completely replace its old definition. 	 The old enumerators remain defined, however.  */
name|TYPE_VALUES
argument_list|(
name|enumtype
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
comment|/* Initially, set up this enum as like `int'      so that we can create the enumerators' declarations and values.      Later on, the precision of the type may be changed and      it may be laid out again.  */
name|TYPE_PRECISION
argument_list|(
name|enumtype
argument_list|)
operator|=
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
expr_stmt|;
name|TYPE_SIZE
argument_list|(
name|enumtype
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|fixup_unsigned_type
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
comment|/* We copy this value because enumerated type constants      are really of the type of the enumerator, not integer_type_node.  */
name|enum_next_value
operator|=
name|copy_node
argument_list|(
name|integer_zero_node
argument_list|)
expr_stmt|;
name|GNU_xref_decl
argument_list|(
name|current_function_decl
argument_list|,
name|enumtype
argument_list|)
expr_stmt|;
return|return
name|enumtype
return|;
block|}
end_function

begin_comment
comment|/* After processing and defining all the values of an enumeration type,    install their decls in the enumeration type and finish it off.    ENUMTYPE is the type object and VALUES a list of name-value pairs.    Returns ENUMTYPE.  */
end_comment

begin_function
name|tree
name|finish_enum
parameter_list|(
name|enumtype
parameter_list|,
name|values
parameter_list|)
specifier|register
name|tree
name|enumtype
decl_stmt|,
name|values
decl_stmt|;
block|{
specifier|register
name|tree
name|pair
decl_stmt|;
specifier|register
name|HOST_WIDE_INT
name|maxvalue
init|=
literal|0
decl_stmt|;
specifier|register
name|HOST_WIDE_INT
name|minvalue
init|=
literal|0
decl_stmt|;
specifier|register
name|HOST_WIDE_INT
name|i
decl_stmt|;
name|TYPE_VALUES
argument_list|(
name|enumtype
argument_list|)
operator|=
name|values
expr_stmt|;
comment|/* Calculate the maximum value of any enumerator in this type.  */
if|if
condition|(
name|values
condition|)
block|{
comment|/* Speed up the main loop by performing some precalculations */
name|HOST_WIDE_INT
name|value
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_VALUE
argument_list|(
name|values
argument_list|)
argument_list|)
decl_stmt|;
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|values
argument_list|)
argument_list|)
operator|=
name|enumtype
expr_stmt|;
name|minvalue
operator|=
name|maxvalue
operator|=
name|value
expr_stmt|;
for|for
control|(
name|pair
operator|=
name|TREE_CHAIN
argument_list|(
name|values
argument_list|)
init|;
name|pair
condition|;
name|pair
operator|=
name|TREE_CHAIN
argument_list|(
name|pair
argument_list|)
control|)
block|{
name|value
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_VALUE
argument_list|(
name|pair
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|>
name|maxvalue
condition|)
name|maxvalue
operator|=
name|value
expr_stmt|;
elseif|else
if|if
condition|(
name|value
operator|<
name|minvalue
condition|)
name|minvalue
operator|=
name|value
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|pair
argument_list|)
argument_list|)
operator|=
name|enumtype
expr_stmt|;
block|}
block|}
if|if
condition|(
name|flag_short_enums
condition|)
block|{
comment|/* Determine the precision this type needs, lay it out, and define it.  */
for|for
control|(
name|i
operator|=
name|maxvalue
init|;
name|i
condition|;
name|i
operator|>>=
literal|1
control|)
name|TYPE_PRECISION
argument_list|(
name|enumtype
argument_list|)
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_PRECISION
argument_list|(
name|enumtype
argument_list|)
condition|)
name|TYPE_PRECISION
argument_list|(
name|enumtype
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Cancel the laying out previously done for the enum type, 	 so that fixup_unsigned_type will do it over.  */
name|TYPE_SIZE
argument_list|(
name|enumtype
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|fixup_unsigned_type
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
block|}
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|enumtype
argument_list|)
argument_list|)
operator|=
name|maxvalue
expr_stmt|;
comment|/* An enum can have some negative values; then it is signed.  */
if|if
condition|(
name|minvalue
operator|<
literal|0
condition|)
block|{
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|enumtype
argument_list|)
argument_list|)
operator|=
name|minvalue
expr_stmt|;
name|TREE_INT_CST_HIGH
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|enumtype
argument_list|)
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
name|TREE_UNSIGNED
argument_list|(
name|enumtype
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|flag_cadillac
condition|)
name|cadillac_finish_enum
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
comment|/* Finish debugging output for this type.  */
if|#
directive|if
literal|0
comment|/* @@ Do we ever generate generate ENUMERAL_TYPE nodes for which debugging      information should *not* be generated?  I think not.  */
block|if (! DECL_IGNORED_P (TYPE_NAME (enumtype)))
endif|#
directive|endif
name|rest_of_type_compilation
argument_list|(
name|enumtype
argument_list|,
name|global_bindings_p
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|enumtype
return|;
block|}
end_function

begin_comment
comment|/* Build and install a CONST_DECL for one value of the    current enumeration type (one that was begun with start_enum).    Return a tree-list containing the name and its value.    Assignment of sequential values by default is handled here.  */
end_comment

begin_function
name|tree
name|build_enumerator
parameter_list|(
name|name
parameter_list|,
name|value
parameter_list|)
name|tree
name|name
decl_stmt|,
name|value
decl_stmt|;
block|{
name|tree
name|decl
decl_stmt|,
name|result
decl_stmt|;
comment|/* Change this to zero if we find VALUE is not shareable.  */
name|int
name|shareable
init|=
literal|1
decl_stmt|;
comment|/* Remove no-op casts from the value.  */
if|if
condition|(
name|value
condition|)
name|STRIP_TYPE_NOPS
argument_list|(
name|value
argument_list|)
expr_stmt|;
comment|/* Validate and default VALUE.  */
if|if
condition|(
name|value
operator|!=
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|TREE_READONLY_DECL_P
argument_list|(
name|value
argument_list|)
condition|)
block|{
name|value
operator|=
name|decl_constant_value
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|shareable
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|error
argument_list|(
literal|"enumerator value for `%s' not integer constant"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|value
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
comment|/* The order of things is reversed here so that we      can check for possible sharing of enum values,      to keep that from happening.  */
comment|/* Default based on previous value.  */
if|if
condition|(
name|value
operator|==
name|NULL_TREE
condition|)
name|value
operator|=
name|enum_next_value
expr_stmt|;
comment|/* Remove no-op casts from the value.  */
if|if
condition|(
name|value
condition|)
name|STRIP_TYPE_NOPS
argument_list|(
name|value
argument_list|)
expr_stmt|;
comment|/* Make up for hacks in cp-lex.c.  */
if|if
condition|(
name|value
operator|==
name|integer_zero_node
condition|)
name|value
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|value
operator|==
name|integer_one_node
condition|)
name|value
operator|=
name|build_int_2
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|(
name|shareable
operator|==
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|)
condition|)
block|{
name|value
operator|=
name|copy_node
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
block|}
name|result
operator|=
name|saveable_tree_cons
argument_list|(
name|name
argument_list|,
name|value
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* C++ associates enums with global, function, or class declarations.  */
if|if
condition|(
name|current_class_type
operator|==
name|NULL_TREE
operator|||
name|current_function_decl
operator|!=
name|NULL_TREE
condition|)
block|{
comment|/* Create a declaration for the enum value name.  */
name|decl
operator|=
name|build_decl
argument_list|(
name|CONST_DECL
argument_list|,
name|name
argument_list|,
name|integer_type_node
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|value
expr_stmt|;
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|GNU_xref_decl
argument_list|(
name|current_function_decl
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|current_class_type
condition|)
block|{
comment|/* class-local enum declaration */
name|decl
operator|=
name|build_lang_field_decl
argument_list|(
name|CONST_DECL
argument_list|,
name|name
argument_list|,
name|integer_type_node
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|value
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|pushdecl_class_level
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
operator|=
name|current_local_enum
expr_stmt|;
name|current_local_enum
operator|=
name|decl
expr_stmt|;
block|}
comment|/* Set basis for default for next value.  */
name|enum_next_value
operator|=
name|build_binary_op_nodefault
argument_list|(
name|PLUS_EXPR
argument_list|,
name|value
argument_list|,
name|integer_one_node
argument_list|,
name|PLUS_EXPR
argument_list|)
expr_stmt|;
if|if
condition|(
name|enum_next_value
operator|==
name|integer_one_node
condition|)
name|enum_next_value
operator|=
name|copy_node
argument_list|(
name|enum_next_value
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|tree
name|grok_enum_decls
parameter_list|(
name|type
parameter_list|,
name|decl
parameter_list|)
name|tree
name|type
decl_stmt|,
name|decl
decl_stmt|;
block|{
name|tree
name|d
init|=
name|current_local_enum
decl_stmt|;
if|if
condition|(
name|d
operator|==
name|NULL_TREE
condition|)
return|return
name|decl
return|;
while|while
condition|(
literal|1
condition|)
block|{
name|TREE_TYPE
argument_list|(
name|d
argument_list|)
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|d
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|TREE_CHAIN
argument_list|(
name|d
argument_list|)
operator|=
name|decl
expr_stmt|;
break|break;
block|}
name|d
operator|=
name|TREE_CHAIN
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
name|decl
operator|=
name|current_local_enum
expr_stmt|;
name|current_local_enum
operator|=
name|NULL_TREE
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create the FUNCTION_DECL for a function definition.    DECLSPECS and DECLARATOR are the parts of the declaration;    they describe the function's name and the type it returns,    but twisted together in a fashion that parallels the syntax of C.     This function creates a binding context for the function body    as well as setting up the FUNCTION_DECL in current_function_decl.     Returns 1 on success.  If the DECLARATOR is not suitable for a function    (it defines a datum instead), we return 0, which tells    yyparse to report a parse error.     For C++, we must first check whether that datum makes any sense.    For example, "class A local_a(1,2);" means that variable local_a    is an aggregate of type A, which should have a constructor    applied to it with the argument list [1, 2].     @@ There is currently no way to retrieve the storage    @@ allocated to FUNCTION (or all of its parms) if we return    @@ something we had previously.  */
end_comment

begin_function
name|int
name|start_function
parameter_list|(
name|declspecs
parameter_list|,
name|declarator
parameter_list|,
name|raises
parameter_list|,
name|pre_parsed_p
parameter_list|)
name|tree
name|declarator
decl_stmt|,
name|declspecs
decl_stmt|,
name|raises
decl_stmt|;
name|int
name|pre_parsed_p
decl_stmt|;
block|{
specifier|extern
name|tree
name|EHS_decl
decl_stmt|;
name|tree
name|decl1
decl_stmt|,
name|olddecl
decl_stmt|;
name|tree
name|ctype
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|fntype
decl_stmt|;
name|tree
name|restype
decl_stmt|;
specifier|extern
name|int
name|have_extern_spec
decl_stmt|;
specifier|extern
name|int
name|used_extern_spec
decl_stmt|;
name|int
name|doing_friend
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|flag_handle_exceptions
operator|&&
name|EHS_decl
operator|==
name|NULL_TREE
condition|)
name|init_exception_processing_1
argument_list|()
expr_stmt|;
comment|/* Sanity check.  */
name|my_friendly_assert
argument_list|(
name|TREE_VALUE
argument_list|(
name|void_list_node
argument_list|)
operator|==
name|void_type_node
argument_list|,
literal|160
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CHAIN
argument_list|(
name|void_list_node
argument_list|)
operator|==
name|NULL_TREE
argument_list|,
literal|161
argument_list|)
expr_stmt|;
comment|/* Assume, until we see it does. */
name|current_function_returns_value
operator|=
literal|0
expr_stmt|;
name|current_function_returns_null
operator|=
literal|0
expr_stmt|;
name|warn_about_return_type
operator|=
literal|0
expr_stmt|;
name|current_extern_inline
operator|=
literal|0
expr_stmt|;
name|current_function_assigns_this
operator|=
literal|0
expr_stmt|;
name|current_function_just_assigned_this
operator|=
literal|0
expr_stmt|;
name|current_function_parms_stored
operator|=
literal|0
expr_stmt|;
name|original_result_rtx
operator|=
name|NULL_RTX
expr_stmt|;
name|current_function_obstack_index
operator|=
literal|0
expr_stmt|;
name|current_function_obstack_usage
operator|=
literal|0
expr_stmt|;
name|clear_temp_name
argument_list|()
expr_stmt|;
comment|/* This should only be done once on the top most decl. */
if|if
condition|(
name|have_extern_spec
operator|&&
operator|!
name|used_extern_spec
condition|)
block|{
name|declspecs
operator|=
name|decl_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"extern"
argument_list|)
argument_list|,
name|declspecs
argument_list|)
expr_stmt|;
name|used_extern_spec
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|pre_parsed_p
condition|)
block|{
name|decl1
operator|=
name|declarator
expr_stmt|;
name|last_function_parms
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
name|last_function_parm_tags
operator|=
name|NULL_TREE
expr_stmt|;
name|fntype
operator|=
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|ctype
operator|=
name|TYPE_METHOD_BASETYPE
argument_list|(
name|fntype
argument_list|)
expr_stmt|;
comment|/* ANSI C++ June 5 1992 WP 11.4.5.  A friend function defined in a 	 class is in the (lexical) scope of the class in which it is 	 defined.  */
if|if
condition|(
operator|!
name|ctype
operator|&&
name|DECL_FRIEND_P
argument_list|(
name|decl1
argument_list|)
condition|)
block|{
name|ctype
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|decl1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ctype
argument_list|)
operator|!=
name|RECORD_TYPE
condition|)
name|ctype
operator|=
name|NULL_TREE
expr_stmt|;
else|else
name|doing_friend
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|DECL_VINDEX
argument_list|(
name|decl1
argument_list|)
operator|&&
name|write_virtuals
operator|>=
literal|2
operator|&&
name|CLASSTYPE_VTABLE_NEEDS_WRITING
argument_list|(
name|ctype
argument_list|)
operator|)
condition|)
name|current_extern_inline
operator|=
name|TREE_PUBLIC
argument_list|(
name|decl1
argument_list|)
operator|&&
name|DECL_INLINE
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
name|raises
operator|=
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|fntype
argument_list|)
expr_stmt|;
comment|/* In a fcn definition, arg types must be complete.  */
name|require_complete_types_for_parms
argument_list|(
name|last_function_parms
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|decl1
operator|=
name|grokdeclarator
argument_list|(
name|declarator
argument_list|,
name|declspecs
argument_list|,
name|FUNCDEF
argument_list|,
literal|1
argument_list|,
name|raises
argument_list|)
expr_stmt|;
comment|/* If the declarator is not suitable for a function definition, 	 cause a syntax error.  */
if|if
condition|(
name|decl1
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|decl1
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
return|return
literal|0
return|;
name|fntype
operator|=
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
name|restype
operator|=
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|restype
argument_list|)
operator|&&
operator|!
name|CLASSTYPE_GOT_SEMICOLON
argument_list|(
name|restype
argument_list|)
condition|)
block|{
name|error_with_aggr_type
argument_list|(
name|restype
argument_list|,
literal|"semicolon missing after declaration of `%s'"
argument_list|)
expr_stmt|;
name|shadow_tag
argument_list|(
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|restype
argument_list|)
argument_list|)
expr_stmt|;
name|CLASSTYPE_GOT_SEMICOLON
argument_list|(
name|restype
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|fntype
operator|=
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fntype
operator|=
name|build_cplus_method_type
argument_list|(
name|build_type_variant
argument_list|(
name|TYPE_METHOD_BASETYPE
argument_list|(
name|fntype
argument_list|)
argument_list|,
name|TREE_READONLY
argument_list|(
name|decl1
argument_list|)
argument_list|,
name|TREE_SIDE_EFFECTS
argument_list|(
name|decl1
argument_list|)
argument_list|)
argument_list|,
name|integer_type_node
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
operator|=
name|fntype
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|ctype
operator|=
name|TYPE_METHOD_BASETYPE
argument_list|(
name|fntype
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IDENTIFIER_LENGTH
argument_list|(
name|DECL_NAME
argument_list|(
name|decl1
argument_list|)
argument_list|)
operator|==
literal|4
operator|&&
operator|!
name|strcmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl1
argument_list|)
argument_list|)
argument_list|,
literal|"main"
argument_list|)
operator|&&
name|DECL_CONTEXT
argument_list|(
name|decl1
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* If this doesn't return integer_type, complain.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
argument_list|)
operator|!=
name|integer_type_node
condition|)
block|{
name|warning
argument_list|(
literal|"return type for `main' changed to integer type"
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
operator|=
name|fntype
operator|=
name|default_function_type
expr_stmt|;
block|}
name|warn_about_return_type
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Warn if function was previously implicitly declared      (but not if we warned then).  */
if|if
condition|(
operator|!
name|warn_implicit
operator|&&
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|DECL_NAME
argument_list|(
name|decl1
argument_list|)
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|warning_with_decl
argument_list|(
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|DECL_NAME
argument_list|(
name|decl1
argument_list|)
argument_list|)
argument_list|,
literal|"`%s' implicitly declared before its definition"
argument_list|)
expr_stmt|;
name|current_function_decl
operator|=
name|decl1
expr_stmt|;
if|if
condition|(
name|flag_cadillac
condition|)
name|cadillac_start_function
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
else|else
name|announce_function
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|)
condition|)
name|error_with_aggr_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|,
literal|"return-type `%s' is an incomplete type"
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"return-type is an incomplete type"
argument_list|)
expr_stmt|;
comment|/* Make it return void instead, but don't change the 	 type of the DECL_RESULT, in case we have a named return value.  */
if|if
condition|(
name|ctype
condition|)
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
operator|=
name|build_cplus_method_type
argument_list|(
name|build_type_variant
argument_list|(
name|ctype
argument_list|,
name|TREE_READONLY
argument_list|(
name|decl1
argument_list|)
argument_list|,
name|TREE_SIDE_EFFECTS
argument_list|(
name|decl1
argument_list|)
argument_list|)
argument_list|,
name|void_type_node
argument_list|,
name|FUNCTION_ARG_CHAIN
argument_list|(
name|decl1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
operator|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_RESULT
argument_list|(
name|decl1
argument_list|)
operator|=
name|build_decl
argument_list|(
name|RESULT_DECL
argument_list|,
literal|0
argument_list|,
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|warn_about_return_type
condition|)
name|warning
argument_list|(
literal|"return-type defaults to `int'"
argument_list|)
expr_stmt|;
comment|/* Make the init_value nonzero so pushdecl knows this is not tentative.      error_mark_node is replaced below (in poplevel) with the BLOCK.  */
name|DECL_INITIAL
argument_list|(
name|decl1
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
comment|/* Didn't get anything from C.  */
name|olddecl
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* This function exists in static storage.      (This does not mean `static' in the C sense!)  */
name|TREE_STATIC
argument_list|(
name|decl1
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* If this function belongs to an interface, it is public.      If it belongs to someone else's interface, it is also external.      It doesn't matter whether it's inline or not.  */
if|if
condition|(
name|interface_unknown
operator|==
literal|0
condition|)
block|{
name|TREE_PUBLIC
argument_list|(
name|decl1
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl1
argument_list|)
operator|=
operator|(
name|interface_only
operator|||
operator|(
name|DECL_INLINE
argument_list|(
name|decl1
argument_list|)
operator|&&
operator|!
name|flag_implement_inlines
operator|)
operator|)
expr_stmt|;
block|}
else|else
comment|/* This is a definition, not a reference.        So normally clear DECL_EXTERNAL.        However, `extern inline' acts like a declaration except for        defining how to inline.  So set DECL_EXTERNAL in that case.  */
name|DECL_EXTERNAL
argument_list|(
name|decl1
argument_list|)
operator|=
name|current_extern_inline
expr_stmt|;
comment|/* Now see if this is the implementation of a function      declared with "C" linkage.  */
if|if
condition|(
name|ctype
operator|==
name|NULL_TREE
operator|&&
name|current_lang_name
operator|==
name|lang_name_cplusplus
operator|&&
operator|!
name|DECL_CONTEXT
argument_list|(
name|decl1
argument_list|)
condition|)
block|{
name|olddecl
operator|=
name|lookup_name_current_level
argument_list|(
name|DECL_NAME
argument_list|(
name|decl1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|olddecl
operator|&&
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
name|olddecl
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|olddecl
operator|&&
name|DECL_NAME
argument_list|(
name|decl1
argument_list|)
operator|!=
name|DECL_NAME
argument_list|(
name|olddecl
argument_list|)
condition|)
block|{
comment|/* Collision between user and internal naming scheme.  */
name|olddecl
operator|=
name|lookup_name_current_level
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|olddecl
operator|==
name|NULL_TREE
condition|)
name|olddecl
operator|=
name|decl1
expr_stmt|;
block|}
if|if
condition|(
name|olddecl
operator|&&
name|olddecl
operator|!=
name|decl1
operator|&&
name|DECL_NAME
argument_list|(
name|decl1
argument_list|)
operator|==
name|DECL_NAME
argument_list|(
name|olddecl
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|decls_match
argument_list|(
name|decl1
argument_list|,
name|olddecl
argument_list|)
condition|)
block|{
name|olddecl
operator|=
name|DECL_MAIN_VARIANT
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
comment|/* The following copy is needed to handle forcing a function's 		 linkage to obey the linkage of the original decl.  */
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl1
argument_list|)
operator|=
name|DECL_ASSEMBLER_NAME
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_OVERLOADED
argument_list|(
name|decl1
argument_list|)
operator|=
name|DECL_OVERLOADED
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
condition|)
name|redeclaration_error_message
argument_list|(
name|decl1
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|duplicate_decls
argument_list|(
name|decl1
argument_list|,
name|olddecl
argument_list|)
condition|)
name|my_friendly_abort
argument_list|(
literal|19
argument_list|)
expr_stmt|;
name|decl1
operator|=
name|olddecl
expr_stmt|;
block|}
else|else
name|olddecl
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
comment|/* Record the decl so that the function name is defined.      If we already have a decl for this name, and it is a FUNCTION_DECL,      use the old decl.  */
if|if
condition|(
name|olddecl
condition|)
name|current_function_decl
operator|=
name|olddecl
expr_stmt|;
elseif|else
if|if
condition|(
name|pre_parsed_p
operator|==
literal|0
condition|)
block|{
name|current_function_decl
operator|=
name|pushdecl
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|current_function_decl
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
comment|/* @@ revert to modified original declaration.  */
name|decl1
operator|=
name|DECL_MAIN_VARIANT
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
name|current_function_decl
operator|=
name|decl1
expr_stmt|;
block|}
else|else
block|{
name|decl1
operator|=
name|current_function_decl
expr_stmt|;
name|DECL_MAIN_VARIANT
argument_list|(
name|decl1
argument_list|)
operator|=
name|decl1
expr_stmt|;
block|}
name|fntype
operator|=
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
block|}
else|else
name|current_function_decl
operator|=
name|decl1
expr_stmt|;
if|if
condition|(
name|DECL_OVERLOADED
argument_list|(
name|decl1
argument_list|)
condition|)
name|decl1
operator|=
name|push_overloaded_decl
argument_list|(
name|decl1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctype
operator|!=
name|NULL_TREE
operator|&&
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|decl1
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
operator|=
name|fntype
operator|=
name|build_function_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|last_function_parms
operator|=
name|TREE_CHAIN
argument_list|(
name|last_function_parms
argument_list|)
expr_stmt|;
name|DECL_ARGUMENTS
argument_list|(
name|decl1
argument_list|)
operator|=
name|last_function_parms
expr_stmt|;
name|ctype
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|restype
operator|=
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
expr_stmt|;
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|current_binding_level
operator|->
name|parm_flag
operator|=
literal|1
expr_stmt|;
comment|/* Save the parm names or decls from this function's declarator      where store_parm_decls will find them.  */
name|current_function_parms
operator|=
name|last_function_parms
expr_stmt|;
name|current_function_parm_tags
operator|=
name|last_function_parm_tags
expr_stmt|;
name|GNU_xref_function
argument_list|(
name|decl1
argument_list|,
name|current_function_parms
argument_list|)
expr_stmt|;
name|make_function_rtl
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctype
condition|)
block|{
name|pushclass
argument_list|(
name|ctype
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* If we're compiling a friend function, neither of the variables 	 current_class_decl nor current_class_type will have values.  */
if|if
condition|(
operator|!
name|doing_friend
condition|)
block|{
comment|/* We know that this was set up by `grokclassfn'. 	     We do not wait until `store_parm_decls', since evil 	     parse errors may never get us to that point.  Here 	     we keep the consistency between `current_class_type' 	     and `current_class_decl'.  */
name|current_class_decl
operator|=
name|last_function_parms
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|current_class_decl
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|current_class_decl
argument_list|)
operator|==
name|PARM_DECL
argument_list|,
literal|162
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_class_decl
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
name|tree
name|variant
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_class_decl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|CLASSTYPE_INST_VAR
argument_list|(
name|ctype
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* Can't call build_indirect_ref here, because it has special 		     logic to return C_C_D given this argument.  */
name|C_C_D
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|current_class_type
argument_list|,
name|current_class_decl
argument_list|)
expr_stmt|;
name|CLASSTYPE_INST_VAR
argument_list|(
name|ctype
argument_list|)
operator|=
name|C_C_D
expr_stmt|;
block|}
else|else
block|{
name|C_C_D
operator|=
name|CLASSTYPE_INST_VAR
argument_list|(
name|ctype
argument_list|)
expr_stmt|;
comment|/* `current_class_decl' is different for every 		     function we compile.  */
name|TREE_OPERAND
argument_list|(
name|C_C_D
argument_list|,
literal|0
argument_list|)
operator|=
name|current_class_decl
expr_stmt|;
block|}
name|TREE_READONLY
argument_list|(
name|C_C_D
argument_list|)
operator|=
name|TYPE_READONLY
argument_list|(
name|variant
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|C_C_D
argument_list|)
operator|=
name|TYPE_VOLATILE
argument_list|(
name|variant
argument_list|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|C_C_D
argument_list|)
operator|=
name|TYPE_VOLATILE
argument_list|(
name|variant
argument_list|)
expr_stmt|;
block|}
else|else
name|C_C_D
operator|=
name|current_class_decl
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|decl1
argument_list|)
condition|)
name|pushclass
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl1
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
else|else
name|push_memoized_context
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Allocate further tree nodes temporarily during compilation      of this function only.  Tiemann moved up here from bottom of fn.  */
name|temporary_allocation
argument_list|()
expr_stmt|;
comment|/* Promote the value to int before returning it.  */
if|if
condition|(
name|C_PROMOTING_INTEGER_TYPE_P
argument_list|(
name|restype
argument_list|)
condition|)
block|{
comment|/* It retains unsignedness if traditional or if it isn't 	 really getting wider.  */
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|restype
argument_list|)
operator|&&
operator|(
name|flag_traditional
operator|||
name|TYPE_PRECISION
argument_list|(
name|restype
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|)
condition|)
name|restype
operator|=
name|unsigned_type_node
expr_stmt|;
else|else
name|restype
operator|=
name|integer_type_node
expr_stmt|;
block|}
if|if
condition|(
name|DECL_RESULT
argument_list|(
name|decl1
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|DECL_RESULT
argument_list|(
name|decl1
argument_list|)
operator|=
name|build_decl
argument_list|(
name|RESULT_DECL
argument_list|,
literal|0
argument_list|,
name|restype
argument_list|)
expr_stmt|;
if|if
condition|(
name|DESTRUCTOR_NAME_P
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl1
argument_list|)
argument_list|)
condition|)
block|{
name|dtor_label
operator|=
name|build_decl
argument_list|(
name|LABEL_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|ctor_label
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
block|{
name|dtor_label
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|decl1
argument_list|)
condition|)
name|ctor_label
operator|=
name|build_decl
argument_list|(
name|LABEL_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
comment|/* If this fcn was already referenced via a block-scope `extern' decl      (or an implicit decl), propagate certain information about the usage.  */
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl1
argument_list|)
argument_list|)
condition|)
name|TREE_ADDRESSABLE
argument_list|(
name|decl1
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Store the parameter declarations into the current function declaration.    This is called after parsing the parameter declarations, before    digesting the body of the function.     Also install to binding contour return value identifier, if any.  */
end_comment

begin_function
name|void
name|store_parm_decls
parameter_list|()
block|{
specifier|register
name|tree
name|fndecl
init|=
name|current_function_decl
decl_stmt|;
specifier|register
name|tree
name|parm
decl_stmt|;
name|int
name|parms_have_cleanups
init|=
literal|0
decl_stmt|;
name|tree
name|eh_decl
decl_stmt|;
comment|/* This is either a chain of PARM_DECLs (when a prototype is used).  */
name|tree
name|specparms
init|=
name|current_function_parms
decl_stmt|;
comment|/* This is a list of types declared among parms in a prototype.  */
name|tree
name|parmtags
init|=
name|current_function_parm_tags
decl_stmt|;
comment|/* This is a chain of any other decls that came in among the parm      declarations.  If a parm is declared with  enum {foo, bar} x;      then CONST_DECLs for foo and bar are put here.  */
name|tree
name|nonparms
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
condition|)
name|fatal
argument_list|(
literal|"parse errors have confused me too much"
argument_list|)
expr_stmt|;
comment|/* Initialize RTL machinery.  */
name|init_function_start
argument_list|(
name|fndecl
argument_list|,
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
comment|/* Declare __FUNCTION__ and __PRETTY_FUNCTION__ for this function.  */
name|declare_function_name
argument_list|()
expr_stmt|;
comment|/* Create a binding level for the parms.  */
name|expand_start_bindings
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Prepare to catch raises, if appropriate.  */
if|if
condition|(
name|flag_handle_exceptions
condition|)
block|{
comment|/* Get this cleanup to be run last, since it 	 is a call to `longjmp'.  */
name|setup_exception_throw_decl
argument_list|()
expr_stmt|;
name|eh_decl
operator|=
name|current_binding_level
operator|->
name|names
expr_stmt|;
name|current_binding_level
operator|->
name|names
operator|=
name|TREE_CHAIN
argument_list|(
name|current_binding_level
operator|->
name|names
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_handle_exceptions
condition|)
name|expand_start_try
argument_list|(
name|integer_one_node
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|specparms
operator|!=
name|NULL_TREE
condition|)
block|{
comment|/* This case is when the function was defined with an ANSI prototype. 	 The parms already have decls, so we need not do anything here 	 except record them as in effect 	 and complain if any redundant old-style parm decls were written.  */
specifier|register
name|tree
name|next
decl_stmt|;
comment|/* Must clear this because it might contain TYPE_DECLs declared 	 at class level.  */
name|storedecls
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
for|for
control|(
name|parm
operator|=
name|nreverse
argument_list|(
name|specparms
argument_list|)
init|;
name|parm
condition|;
name|parm
operator|=
name|next
control|)
block|{
name|next
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|PARM_DECL
condition|)
block|{
name|tree
name|cleanup
init|=
name|maybe_build_cleanup
argument_list|(
name|parm
argument_list|)
decl_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|parm
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
if|#
directive|if
literal|0
block|error_with_decl (parm, "parameter name omitted");
else|#
directive|else
comment|/* for C++, this is not an error.  */
name|pushdecl
argument_list|(
name|parm
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|void_type_node
condition|)
name|error_with_decl
argument_list|(
name|parm
argument_list|,
literal|"parameter `%s' declared void"
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Now fill in DECL_REFERENCE_SLOT for any of the parm decls. 		     A parameter is assumed not to have any side effects. 		     If this should change for any reason, then this 		     will have to wrap the bashed reference type in a save_expr. 		      		     Also, if the parameter type is declared to be an X 		     and there is an X(X&) constructor, we cannot lay it 		     into the stack (any more), so we make this parameter 		     look like it is really of reference type.  Functions 		     which pass parameters to this function will know to 		     create a temporary in their frame, and pass a reference 		     to that.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|&&
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
argument_list|)
condition|)
name|SET_DECL_REFERENCE_SLOT
argument_list|(
name|parm
argument_list|,
name|convert_from_reference
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|parm
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cleanup
condition|)
block|{
name|expand_decl
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|expand_decl_cleanup
argument_list|(
name|parm
argument_list|,
name|cleanup
argument_list|)
expr_stmt|;
name|parms_have_cleanups
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* If we find an enum constant or a type tag, 		 put it aside for the moment.  */
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|nonparms
operator|=
name|chainon
argument_list|(
name|nonparms
argument_list|,
name|parm
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Get the decls in their original chain order 	 and record in the function.  This is all and only the 	 PARM_DECLs that were pushed into scope by the loop above.  */
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
operator|=
name|getdecls
argument_list|()
expr_stmt|;
name|storetags
argument_list|(
name|chainon
argument_list|(
name|parmtags
argument_list|,
name|gettags
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Now store the final chain of decls for the arguments      as the decl-chain of the current lexical scope.      Put the enumerators in as well, at the front so that      DECL_ARGUMENTS is not modified.  */
name|storedecls
argument_list|(
name|chainon
argument_list|(
name|nonparms
argument_list|,
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize the RTL code for the function.  */
name|DECL_SAVED_INSNS
argument_list|(
name|fndecl
argument_list|)
operator|=
name|NULL_RTX
expr_stmt|;
name|expand_function_start
argument_list|(
name|fndecl
argument_list|,
name|parms_have_cleanups
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_handle_exceptions
condition|)
block|{
comment|/* Make the throw decl visible at this level, just 	 not in the way of the parameters.  */
name|pushdecl
argument_list|(
name|eh_decl
argument_list|)
expr_stmt|;
name|expand_decl_init
argument_list|(
name|eh_decl
argument_list|)
expr_stmt|;
block|}
comment|/* Create a binding contour which can be used to catch      cleanup-generated temporaries.  Also, if the return value needs or      has initialization, deal with that now.  */
if|if
condition|(
name|parms_have_cleanups
condition|)
block|{
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|expand_start_bindings
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|current_function_parms_stored
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|flag_gc
condition|)
block|{
name|maybe_gc_cleanup
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|error_mark_node
argument_list|)
expr_stmt|;
name|expand_decl_cleanup
argument_list|(
name|NULL_TREE
argument_list|,
name|maybe_gc_cleanup
argument_list|)
expr_stmt|;
block|}
comment|/* If this function is `main', emit a call to `__main'      to run global initializers, etc.  */
if|if
condition|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
operator|&&
name|IDENTIFIER_LENGTH
argument_list|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|==
literal|4
operator|&&
name|strcmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|,
literal|"main"
argument_list|)
operator|==
literal|0
operator|&&
name|DECL_CONTEXT
argument_list|(
name|fndecl
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|expand_main_function
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag_gc
condition|)
name|expand_expr
argument_list|(
name|build_function_call
argument_list|(
name|lookup_name
argument_list|(
name|get_identifier
argument_list|(
literal|"__gc_main"
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_dossier
condition|)
name|output_builtin_tdesc_entries
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Bind a name and initialization to the return value of    the current function.  */
end_comment

begin_function
name|void
name|store_return_init
parameter_list|(
name|return_id
parameter_list|,
name|init
parameter_list|)
name|tree
name|return_id
decl_stmt|,
name|init
decl_stmt|;
block|{
name|tree
name|decl
init|=
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|pedantic
condition|)
comment|/* Give this error as many times as there are occurrences,        so that users can use Emacs compilation buffers to find        and fix all such places.  */
name|error
argument_list|(
literal|"ANSI C++ does not permit named return values"
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_id
operator|!=
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|=
name|return_id
expr_stmt|;
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
operator|=
name|return_id
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"return identifier `%s' already in place"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Can't let this happen for constructors.  */
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|current_function_decl
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"can't redefine default return value for constructors"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If we have a named return value, put that in our scope as well.  */
if|if
condition|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
comment|/* If this named return value comes in a register, 	 put it in a pseudo-register.  */
if|if
condition|(
name|DECL_REGISTER
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|original_result_rtx
operator|=
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|=
name|gen_reg_rtx
argument_list|(
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Let `finish_decl' know that this initializer is ok.  */
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|init
expr_stmt|;
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|decl
argument_list|,
name|init
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Generate code for default X(X&) constructor.  */
end_comment

begin_function
specifier|static
name|void
name|build_default_constructor
parameter_list|(
name|fndecl
parameter_list|)
name|tree
name|fndecl
decl_stmt|;
block|{
name|int
name|i
init|=
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|current_class_type
argument_list|)
decl_stmt|;
name|tree
name|parm
init|=
name|TREE_CHAIN
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|fields
init|=
name|TYPE_FIELDS
argument_list|(
name|current_class_type
argument_list|)
decl_stmt|;
name|tree
name|binfos
init|=
name|TYPE_BINFO_BASETYPES
argument_list|(
name|current_class_type
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|current_class_type
argument_list|)
condition|)
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|parm
operator|=
name|DECL_REFERENCE_SLOT
argument_list|(
name|parm
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
block|{
name|tree
name|basetype
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_GETS_INIT_REF
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
name|tree
name|name
init|=
name|TYPE_NAME
argument_list|(
name|basetype
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|name
operator|=
name|DECL_NAME
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|current_base_init_list
operator|=
name|tree_cons
argument_list|(
name|name
argument_list|,
name|parm
argument_list|,
name|current_base_init_list
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
init|;
name|fields
condition|;
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
control|)
block|{
name|tree
name|name
decl_stmt|,
name|init
decl_stmt|;
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|fields
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fields
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
continue|continue;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
condition|)
block|{
if|if
condition|(
name|VFIELD_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|VBASE_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
argument_list|)
condition|)
continue|continue;
comment|/* True for duplicate members.  */
if|if
condition|(
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
argument_list|)
operator|!=
name|fields
condition|)
continue|continue;
block|}
name|init
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|fields
argument_list|)
argument_list|,
name|parm
argument_list|,
name|fields
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_ANON_UNION_ELEM
argument_list|(
name|fields
argument_list|)
condition|)
name|name
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|fields
argument_list|)
argument_list|,
name|C_C_D
argument_list|,
name|fields
argument_list|)
expr_stmt|;
else|else
block|{
name|name
operator|=
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
expr_stmt|;
name|init
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|init
argument_list|)
expr_stmt|;
block|}
name|current_member_init_list
operator|=
name|tree_cons
argument_list|(
name|name
argument_list|,
name|init
argument_list|,
name|current_member_init_list
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Finish up a function declaration and compile that function    all the way to assembler language output.  The free the storage    for the function definition.     This is called after parsing the body of the function definition.    LINENO is the current line number.     C++: CALL_POPLEVEL is non-zero if an extra call to poplevel    (and expand_end_bindings) must be made to take care of the binding    contour for the base initializers.  This is only relevant for    constructors.  */
end_comment

begin_function
name|void
name|finish_function
parameter_list|(
name|lineno
parameter_list|,
name|call_poplevel
parameter_list|)
name|int
name|lineno
decl_stmt|;
name|int
name|call_poplevel
decl_stmt|;
block|{
specifier|register
name|tree
name|fndecl
init|=
name|current_function_decl
decl_stmt|;
name|tree
name|fntype
decl_stmt|,
name|ctype
init|=
name|NULL_TREE
decl_stmt|;
name|rtx
name|head
decl_stmt|,
name|last_parm_insn
decl_stmt|,
name|mark
decl_stmt|;
specifier|extern
name|int
name|sets_exception_throw_decl
decl_stmt|;
comment|/* Label to use if this function is supposed to return a value.  */
name|tree
name|no_return_label
init|=
name|NULL_TREE
decl_stmt|;
comment|/* When we get some parse errors, we can end up without a      current_function_decl, so cope.  */
if|if
condition|(
name|fndecl
operator|==
name|NULL_TREE
condition|)
return|return;
name|fntype
operator|=
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
comment|/*  TREE_READONLY (fndecl) = 1;     This caused&foo to be of type ptr-to-const-function     which then got a warning when stored in a ptr-to-function variable.  */
comment|/* This happens on strange parse errors.  */
if|if
condition|(
operator|!
name|current_function_parms_stored
condition|)
block|{
name|call_poplevel
operator|=
literal|0
expr_stmt|;
name|store_parm_decls
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|write_symbols
operator|!=
name|NO_DEBUG
operator|&&
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
operator|!=
name|METHOD_TYPE
condition|)
block|{
name|tree
name|ttype
init|=
name|target_type
argument_list|(
name|fntype
argument_list|)
decl_stmt|;
name|tree
name|parmdecl
decl_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|ttype
argument_list|)
condition|)
comment|/* Let debugger know it should output info for this type.  */
name|note_debug_info_needed
argument_list|(
name|ttype
argument_list|)
expr_stmt|;
for|for
control|(
name|parmdecl
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
init|;
name|parmdecl
condition|;
name|parmdecl
operator|=
name|TREE_CHAIN
argument_list|(
name|parmdecl
argument_list|)
control|)
block|{
name|ttype
operator|=
name|target_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|parmdecl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|ttype
argument_list|)
condition|)
comment|/* Let debugger know it should output info for this type.  */
name|note_debug_info_needed
argument_list|(
name|ttype
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Clean house because we will need to reorder insns here.  */
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
if|if
condition|(
name|dtor_label
condition|)
block|{
name|tree
name|binfo
init|=
name|TYPE_BINFO
argument_list|(
name|current_class_type
argument_list|)
decl_stmt|;
name|tree
name|cond
init|=
name|integer_one_node
decl_stmt|;
name|tree
name|exprstmt
decl_stmt|,
name|vfields
decl_stmt|;
name|tree
name|in_charge_node
init|=
name|lookup_name
argument_list|(
name|in_charge_identifier
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|virtual_size
decl_stmt|;
name|int
name|ok_to_optimize_dtor
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|current_function_assigns_this
condition|)
name|cond
operator|=
name|build
argument_list|(
name|NE_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|current_class_decl
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|n_baseclasses
init|=
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|current_class_type
argument_list|)
decl_stmt|;
comment|/* If this destructor is empty, then we don't need to check 	     whether `this' is NULL in some cases.  */
name|mark
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|last_parm_insn
operator|=
name|get_first_nonparm_insn
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|flag_this_is_variable
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
name|ok_to_optimize_dtor
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|mark
operator|==
name|last_parm_insn
condition|)
name|ok_to_optimize_dtor
operator|=
operator|(
name|n_baseclasses
operator|==
literal|0
operator|||
operator|(
name|n_baseclasses
operator|==
literal|1
operator|&&
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|TYPE_BINFO_BASETYPE
argument_list|(
name|current_class_type
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|)
expr_stmt|;
block|}
comment|/* These initializations might go inline.  Protect 	 the binding level of the parms.  */
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_function_assigns_this
condition|)
block|{
name|current_function_assigns_this
operator|=
literal|0
expr_stmt|;
name|current_function_just_assigned_this
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Generate the code to call destructor on base class. 	 If this destructor belongs to a class with virtual 	 functions, then set the virtual function table 	 pointer to represent the type of our base class.  */
comment|/* This side-effect makes call to `build_delete' generate the 	 code we have to have at the end of this destructor.  */
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|current_class_type
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* These are two cases where we cannot delegate deletion.  */
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|current_class_type
argument_list|)
operator|||
name|TREE_GETS_DELETE
argument_list|(
name|current_class_type
argument_list|)
condition|)
name|exprstmt
operator|=
name|build_delete
argument_list|(
name|current_class_type
argument_list|,
name|C_C_D
argument_list|,
name|integer_zero_node
argument_list|,
name|LOOKUP_NONVIRTUAL
operator||
name|LOOKUP_DESTRUCTOR
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|exprstmt
operator|=
name|build_delete
argument_list|(
name|current_class_type
argument_list|,
name|C_C_D
argument_list|,
name|in_charge_node
argument_list|,
name|LOOKUP_NONVIRTUAL
operator||
name|LOOKUP_DESTRUCTOR
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If we did not assign to this, then `this' is non-zero at 	 the end of a destructor.  As a special optimization, don't 	 emit test if this is an empty destructor.  If it does nothing, 	 it does nothing.  If it calls a base destructor, the base 	 destructor will perform the test.  */
if|if
condition|(
name|exprstmt
operator|!=
name|error_mark_node
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|exprstmt
argument_list|)
operator|!=
name|NOP_EXPR
operator|||
name|TREE_OPERAND
argument_list|(
name|exprstmt
argument_list|,
literal|0
argument_list|)
operator|!=
name|integer_zero_node
operator|||
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|current_class_type
argument_list|)
operator|)
condition|)
block|{
name|expand_label
argument_list|(
name|dtor_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|cond
operator|!=
name|integer_one_node
condition|)
name|expand_start_cond
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|exprstmt
operator|!=
name|void_zero_node
condition|)
comment|/* Don't call `expand_expr_stmt' if we're not going to do 	       anything, since -Wall will give a diagnostic.  */
name|expand_expr_stmt
argument_list|(
name|exprstmt
argument_list|)
expr_stmt|;
comment|/* Run destructor on all virtual baseclasses.  */
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|current_class_type
argument_list|)
condition|)
block|{
name|tree
name|vbases
init|=
name|nreverse
argument_list|(
name|copy_list
argument_list|(
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|current_class_type
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|expand_start_cond
argument_list|(
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|in_charge_node
argument_list|,
name|integer_two_node
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|vbases
condition|)
block|{
if|if
condition|(
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|BINFO_TYPE
argument_list|(
name|vbases
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|ptr
init|=
name|convert_pointer_to_vbase
argument_list|(
name|vbases
argument_list|,
name|current_class_decl
argument_list|)
decl_stmt|;
name|expand_expr_stmt
argument_list|(
name|build_delete
argument_list|(
name|TYPE_POINTER_TO
argument_list|(
name|BINFO_TYPE
argument_list|(
name|vbases
argument_list|)
argument_list|)
argument_list|,
name|ptr
argument_list|,
name|integer_zero_node
argument_list|,
name|LOOKUP_NONVIRTUAL
operator||
name|LOOKUP_DESTRUCTOR
operator||
name|LOOKUP_HAS_IN_CHARGE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|vbases
operator|=
name|TREE_CHAIN
argument_list|(
name|vbases
argument_list|)
expr_stmt|;
block|}
name|expand_end_cond
argument_list|()
expr_stmt|;
block|}
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
if|if
condition|(
name|cond
operator|!=
name|integer_one_node
condition|)
name|expand_end_cond
argument_list|()
expr_stmt|;
block|}
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|current_class_type
argument_list|)
operator|=
literal|1
expr_stmt|;
name|virtual_size
operator|=
name|c_sizeof
argument_list|(
name|current_class_type
argument_list|)
expr_stmt|;
comment|/* At the end, call delete if that's what's requested.  */
if|if
condition|(
name|TREE_GETS_DELETE
argument_list|(
name|current_class_type
argument_list|)
condition|)
comment|/* This NOP_EXPR means we are in a static call context.  */
name|exprstmt
operator|=
name|build_method_call
argument_list|(
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|current_class_type
argument_list|)
argument_list|,
name|error_mark_node
argument_list|)
argument_list|,
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|DELETE_EXPR
index|]
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|current_class_decl
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|virtual_size
argument_list|)
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|current_class_type
argument_list|)
condition|)
name|exprstmt
operator|=
name|build_x_delete
argument_list|(
name|ptr_type_node
argument_list|,
name|current_class_decl
argument_list|,
literal|0
argument_list|,
name|virtual_size
argument_list|)
expr_stmt|;
else|else
name|exprstmt
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|exprstmt
condition|)
block|{
name|cond
operator|=
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|in_charge_node
argument_list|,
name|integer_one_node
argument_list|)
expr_stmt|;
name|expand_start_cond
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|exprstmt
argument_list|)
expr_stmt|;
name|expand_end_cond
argument_list|()
expr_stmt|;
block|}
comment|/* End of destructor.  */
name|poplevel
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Back to the top of destructor.  */
comment|/* Dont execute destructor code if `this' is NULL.  */
name|mark
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|last_parm_insn
operator|=
name|get_first_nonparm_insn
argument_list|()
expr_stmt|;
if|if
condition|(
name|last_parm_insn
operator|==
name|NULL_RTX
condition|)
name|last_parm_insn
operator|=
name|mark
expr_stmt|;
else|else
name|last_parm_insn
operator|=
name|previous_insn
argument_list|(
name|last_parm_insn
argument_list|)
expr_stmt|;
comment|/* Make all virtual function table pointers point to CURRENT_CLASS_TYPE's 	 virtual function tables.  */
if|if
condition|(
name|CLASSTYPE_VFIELDS
argument_list|(
name|current_class_type
argument_list|)
condition|)
block|{
for|for
control|(
name|vfields
operator|=
name|CLASSTYPE_VFIELDS
argument_list|(
name|current_class_type
argument_list|)
init|;
name|TREE_CHAIN
argument_list|(
name|vfields
argument_list|)
condition|;
name|vfields
operator|=
name|TREE_CHAIN
argument_list|(
name|vfields
argument_list|)
control|)
block|{
name|tree
name|vf_decl
init|=
name|current_class_decl
decl_stmt|;
comment|/* ??? This may need to be a loop if there are multiple 		 levels of replication.  */
if|if
condition|(
name|VF_BINFO_VALUE
argument_list|(
name|vfields
argument_list|)
condition|)
name|vf_decl
operator|=
name|convert_pointer_to
argument_list|(
name|VF_BINFO_VALUE
argument_list|(
name|vfields
argument_list|)
argument_list|,
name|vf_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|vf_decl
operator|!=
name|error_mark_node
condition|)
block|{
comment|/* It is one of these two, or a combination...  */
comment|/* basically speaking, I want to get down to the right 		     VF_BASETYPE_VALUE (vfields) */
if|#
directive|if
literal|0
block|if (VF_NORMAL_VALUE (vfields) != VF_DERIVED_VALUE (vfields)) 		    warning ("hum, wonder if I am doing the right thing");
endif|#
directive|endif
name|expand_expr_stmt
argument_list|(
name|build_virtual_init
argument_list|(
name|binfo
argument_list|,
name|get_binfo
argument_list|(
name|VF_BASETYPE_VALUE
argument_list|(
name|vfields
argument_list|)
argument_list|,
name|get_binfo
argument_list|(
name|VF_DERIVED_VALUE
argument_list|(
name|vfields
argument_list|)
argument_list|,
name|binfo
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|vf_decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|expand_expr_stmt
argument_list|(
name|build_virtual_init
argument_list|(
name|binfo
argument_list|,
name|binfo
argument_list|,
name|current_class_decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|current_class_type
argument_list|)
condition|)
name|expand_expr_stmt
argument_list|(
name|build_vbase_vtables_init
argument_list|(
name|binfo
argument_list|,
name|binfo
argument_list|,
name|C_C_D
argument_list|,
name|current_class_decl
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok_to_optimize_dtor
condition|)
block|{
name|cond
operator|=
name|build_binary_op
argument_list|(
name|NE_EXPR
argument_list|,
name|current_class_decl
argument_list|,
name|integer_zero_node
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|expand_start_cond
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mark
operator|!=
name|get_last_insn
argument_list|()
condition|)
name|reorder_insns
argument_list|(
name|next_insn
argument_list|(
name|mark
argument_list|)
argument_list|,
name|get_last_insn
argument_list|()
argument_list|,
name|last_parm_insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok_to_optimize_dtor
condition|)
name|expand_end_cond
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|current_function_assigns_this
condition|)
block|{
comment|/* Does not need to call emit_base_init, because 	 that is done (if needed) just after assignment to this 	 is seen.  */
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|current_function_decl
argument_list|)
condition|)
block|{
name|expand_label
argument_list|(
name|ctor_label
argument_list|)
expr_stmt|;
name|ctor_label
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|call_poplevel
condition|)
block|{
name|tree
name|decls
init|=
name|getdecls
argument_list|()
decl_stmt|;
if|if
condition|(
name|flag_handle_exceptions
operator|==
literal|2
condition|)
name|deactivate_exception_cleanups
argument_list|()
expr_stmt|;
name|expand_end_bindings
argument_list|(
name|decls
argument_list|,
name|decls
operator|!=
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|poplevel
argument_list|(
name|decls
operator|!=
name|NULL_TREE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|c_expand_return
argument_list|(
name|current_class_decl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|void_type_node
operator|&&
name|return_label
operator|!=
name|NULL_RTX
condition|)
name|no_return_label
operator|=
name|build_decl
argument_list|(
name|LABEL_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|current_function_assigns_this
operator|=
literal|0
expr_stmt|;
name|current_function_just_assigned_this
operator|=
literal|0
expr_stmt|;
name|base_init_insns
operator|=
name|NULL_RTX
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
name|tree
name|allocated_this
decl_stmt|;
name|tree
name|cond
decl_stmt|,
name|thenclause
decl_stmt|;
comment|/* Allow constructor for a type to get a new instance of the object 	 using `build_new'.  */
name|tree
name|abstract_virtuals
init|=
name|CLASSTYPE_ABSTRACT_VIRTUALS
argument_list|(
name|current_class_type
argument_list|)
decl_stmt|;
name|CLASSTYPE_ABSTRACT_VIRTUALS
argument_list|(
name|current_class_type
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|DECL_RETURNS_FIRST_ARG
argument_list|(
name|fndecl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|flag_this_is_variable
operator|>
literal|0
condition|)
block|{
name|cond
operator|=
name|build_binary_op
argument_list|(
name|EQ_EXPR
argument_list|,
name|current_class_decl
argument_list|,
name|integer_zero_node
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|thenclause
operator|=
name|build_modify_expr
argument_list|(
name|current_class_decl
argument_list|,
name|NOP_EXPR
argument_list|,
name|build_new
argument_list|(
name|NULL_TREE
argument_list|,
name|current_class_type
argument_list|,
name|void_type_node
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_handle_exceptions
operator|==
literal|2
condition|)
block|{
name|tree
name|cleanup
decl_stmt|,
name|cleanup_deallocate
decl_stmt|;
name|tree
name|virtual_size
decl_stmt|;
comment|/* This is the size of the virtual object pointed to by 		 allocated_this.  In this case, it is simple.  */
name|virtual_size
operator|=
name|c_sizeof
argument_list|(
name|current_class_type
argument_list|)
expr_stmt|;
name|allocated_this
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
name|DECL_REGISTER
argument_list|(
name|allocated_this
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|allocated_this
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|expand_decl
argument_list|(
name|allocated_this
argument_list|)
expr_stmt|;
name|expand_decl_init
argument_list|(
name|allocated_this
argument_list|)
expr_stmt|;
comment|/* How we cleanup `this' if an exception was raised before 		 we are ready to bail out.  */
name|cleanup
operator|=
name|TREE_GETS_DELETE
argument_list|(
name|current_class_type
argument_list|)
condition|?
name|build_opfncall
argument_list|(
name|DELETE_EXPR
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|allocated_this
argument_list|,
name|virtual_size
argument_list|,
name|NULL_TREE
argument_list|)
comment|/* The size of allocated_this is wrong, and hence the 		     second argument to operator delete will be wrong. */
else|:
name|build_delete
argument_list|(
name|TREE_TYPE
argument_list|(
name|allocated_this
argument_list|)
argument_list|,
name|allocated_this
argument_list|,
name|integer_three_node
argument_list|,
name|LOOKUP_NORMAL
operator||
name|LOOKUP_HAS_IN_CHARGE
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cleanup_deallocate
operator|=
name|build_modify_expr
argument_list|(
name|current_class_decl
argument_list|,
name|NOP_EXPR
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
name|cleanup
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|cleanup
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|cleanup_deallocate
argument_list|)
argument_list|)
expr_stmt|;
name|expand_decl_cleanup
argument_list|(
name|allocated_this
argument_list|,
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|build
argument_list|(
name|NE_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|allocated_this
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
name|build_compound_expr
argument_list|(
name|cleanup
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_GETS_NEW
argument_list|(
name|current_class_type
argument_list|)
condition|)
comment|/* Just check visibility here.  */
name|build_method_call
argument_list|(
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|current_class_type
argument_list|)
argument_list|,
name|error_mark_node
argument_list|)
argument_list|,
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|NEW_EXPR
index|]
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
expr_stmt|;
name|CLASSTYPE_ABSTRACT_VIRTUALS
argument_list|(
name|current_class_type
argument_list|)
operator|=
name|abstract_virtuals
expr_stmt|;
comment|/* must keep the first insn safe.  */
name|head
operator|=
name|get_insns
argument_list|()
expr_stmt|;
comment|/* this note will come up to the top with us.  */
name|mark
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag_this_is_variable
operator|>
literal|0
condition|)
block|{
name|expand_start_cond
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|thenclause
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_handle_exceptions
operator|==
literal|2
condition|)
name|expand_assignment
argument_list|(
name|allocated_this
argument_list|,
name|current_class_decl
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_end_cond
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|TREE_CHAIN
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|build_default_constructor
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
comment|/* Emit insns from `emit_base_init' which sets up virtual 	 function table pointer(s).  */
name|emit_insns
argument_list|(
name|base_init_insns
argument_list|)
expr_stmt|;
name|base_init_insns
operator|=
name|NULL_RTX
expr_stmt|;
comment|/* This is where the body of the constructor begins. 	 If there were no insns in this function body, then the 	 last_parm_insn is also the last insn.  	 If optimization is enabled, last_parm_insn may move, so 	 we don't hold on to it (across emit_base_init).  */
name|last_parm_insn
operator|=
name|get_first_nonparm_insn
argument_list|()
expr_stmt|;
if|if
condition|(
name|last_parm_insn
operator|==
name|NULL_RTX
condition|)
name|last_parm_insn
operator|=
name|mark
expr_stmt|;
else|else
name|last_parm_insn
operator|=
name|previous_insn
argument_list|(
name|last_parm_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|mark
operator|!=
name|get_last_insn
argument_list|()
condition|)
name|reorder_insns
argument_list|(
name|next_insn
argument_list|(
name|mark
argument_list|)
argument_list|,
name|get_last_insn
argument_list|()
argument_list|,
name|last_parm_insn
argument_list|)
expr_stmt|;
comment|/* This is where the body of the constructor ends.  */
name|expand_label
argument_list|(
name|ctor_label
argument_list|)
expr_stmt|;
name|ctor_label
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|flag_handle_exceptions
operator|==
literal|2
condition|)
block|{
name|expand_assignment
argument_list|(
name|allocated_this
argument_list|,
name|integer_zero_node
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|call_poplevel
condition|)
name|deactivate_exception_cleanups
argument_list|()
expr_stmt|;
block|}
name|pop_implicit_try_blocks
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|call_poplevel
condition|)
block|{
name|expand_end_bindings
argument_list|(
name|getdecls
argument_list|()
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|poplevel
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|c_expand_return
argument_list|(
name|current_class_decl
argument_list|)
expr_stmt|;
name|current_function_assigns_this
operator|=
literal|0
expr_stmt|;
name|current_function_just_assigned_this
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IDENTIFIER_LENGTH
argument_list|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|==
literal|4
operator|&&
operator|!
name|strcmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|,
literal|"main"
argument_list|)
operator|&&
name|DECL_CONTEXT
argument_list|(
name|fndecl
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* Make it so that `main' always returns 0 by default.  */
ifdef|#
directive|ifdef
name|VMS
name|c_expand_return
argument_list|(
name|integer_one_node
argument_list|)
expr_stmt|;
else|#
directive|else
name|c_expand_return
argument_list|(
name|integer_zero_node
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|return_label
operator|!=
name|NULL_RTX
operator|&&
name|current_function_return_value
operator|==
name|NULL_TREE
operator|&&
operator|!
name|DECL_NAME
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
condition|)
name|no_return_label
operator|=
name|build_decl
argument_list|(
name|LABEL_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_gc
condition|)
name|expand_gc_prologue_and_epilogue
argument_list|()
expr_stmt|;
comment|/* That's the end of the vtable decl's life.  Need to mark it such      if doing stupid register allocation.       Note that current_vtable_decl is really an INDIRECT_REF      on top of a VAR_DECL here.  */
if|if
condition|(
name|obey_regdecls
operator|&&
name|current_vtable_decl
condition|)
name|use_variable
argument_list|(
name|DECL_RTL
argument_list|(
name|TREE_OPERAND
argument_list|(
name|current_vtable_decl
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this function is supposed to return a value, ensure that      we do not fall into the cleanups by mistake.  The end of our      function will look like this:  	user code (may have return stmt somewhere) 	goto no_return_label 	cleanup_label: 	cleanups 	goto return_label 	no_return_label: 	NOTE_INSN_FUNCTION_END 	return_label: 	things for return       If the user omits a return stmt in the USER CODE section, we      will have a control path which reaches NOTE_INSN_FUNCTION_END.      Otherwise, we won't.  */
if|if
condition|(
name|no_return_label
condition|)
block|{
name|DECL_CONTEXT
argument_list|(
name|no_return_label
argument_list|)
operator|=
name|fndecl
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|no_return_label
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|DECL_SOURCE_FILE
argument_list|(
name|no_return_label
argument_list|)
operator|=
name|input_filename
expr_stmt|;
name|DECL_SOURCE_LINE
argument_list|(
name|no_return_label
argument_list|)
operator|=
name|lineno
expr_stmt|;
name|expand_goto
argument_list|(
name|no_return_label
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cleanup_label
condition|)
block|{
comment|/* remove the binding contour which is used 	 to catch cleanup-generated temporaries.  */
name|expand_end_bindings
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|poplevel
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Must mark the RESULT_DECL as being in this function.  */
name|DECL_CONTEXT
argument_list|(
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|=
name|DECL_INITIAL
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
comment|/* Obey `register' declarations if `setjmp' is called in this fn.  */
if|if
condition|(
name|flag_traditional
operator|&&
name|current_function_calls_setjmp
condition|)
name|setjmp_protect
argument_list|(
name|DECL_INITIAL
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cleanup_label
condition|)
comment|/* Emit label at beginning of cleanup code for parameters.  */
name|emit_label
argument_list|(
name|cleanup_label
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
comment|/* Cheap hack to get better code from GNU C++.  Remove when cse is fixed.  */
if|if
condition|(
name|exception_throw_decl
operator|&&
name|sets_exception_throw_decl
operator|==
literal|0
condition|)
name|expand_assignment
argument_list|(
name|exception_throw_decl
argument_list|,
name|integer_zero_node
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|flag_handle_exceptions
condition|)
block|{
name|expand_end_try
argument_list|()
expr_stmt|;
name|expand_start_except
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_end_except
argument_list|()
expr_stmt|;
block|}
name|expand_end_bindings
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Get return value into register if that's where it's supposed to be.  */
if|if
condition|(
name|original_result_rtx
condition|)
name|fixup_result_decl
argument_list|(
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
argument_list|,
name|original_result_rtx
argument_list|)
expr_stmt|;
comment|/* Finish building code that will trigger warnings if users forget      to make their functions return values.  */
if|if
condition|(
name|no_return_label
operator|||
name|cleanup_label
condition|)
name|emit_jump
argument_list|(
name|return_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|no_return_label
condition|)
block|{
comment|/* We don't need to call `expand_*_return' here because we 	 don't need any cleanups here--this path of code is only 	 for error checking purposes.  */
name|expand_label
argument_list|(
name|no_return_label
argument_list|)
expr_stmt|;
block|}
comment|/* reset scope for C++: if we were in the scope of a class,      then when we finish this function, we are not longer so.      This cannot be done until we know for sure that no more      class members will ever be referenced in this function      (i.e., calls to destructors).  */
if|if
condition|(
name|current_class_name
condition|)
block|{
name|ctype
operator|=
name|current_class_type
expr_stmt|;
name|popclass
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|pop_memoized_context
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Forget about all overloaded functions defined in      this scope which go away.  */
while|while
condition|(
name|overloads_to_forget
condition|)
block|{
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|overloads_to_forget
argument_list|)
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|overloads_to_forget
argument_list|)
expr_stmt|;
name|overloads_to_forget
operator|=
name|TREE_CHAIN
argument_list|(
name|overloads_to_forget
argument_list|)
expr_stmt|;
block|}
comment|/* Generate rtl for function exit.  */
name|expand_function_end
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
comment|/* This must come after expand_function_end because cleanups might      have declarations (from inline functions) that need to go into      this function's blocks.  */
if|if
condition|(
name|current_binding_level
operator|->
name|parm_flag
operator|!=
literal|1
condition|)
name|my_friendly_abort
argument_list|(
literal|122
argument_list|)
expr_stmt|;
name|poplevel
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Set the BLOCK_SUPERCONTEXT of the outermost function scope to point      to the FUNCTION_DECL node itself.  */
name|BLOCK_SUPERCONTEXT
argument_list|(
name|DECL_INITIAL
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|=
name|fndecl
expr_stmt|;
comment|/* So we can tell if jump_optimize sets it to 1.  */
name|can_reach_end
operator|=
literal|0
expr_stmt|;
comment|/* ??? Compensate for Sun brain damage in dealing with data segments      of PIC code.  */
if|if
condition|(
name|flag_pic
operator|&&
operator|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|fndecl
argument_list|)
operator|||
name|DESTRUCTOR_NAME_P
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|)
operator|&&
name|CLASSTYPE_NEEDS_VIRTUAL_REINIT
argument_list|(
name|TYPE_METHOD_BASETYPE
argument_list|(
name|fntype
argument_list|)
argument_list|)
condition|)
name|DECL_INLINE
argument_list|(
name|fndecl
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|fndecl
argument_list|)
comment|/* This function is just along for the ride.  If we can make 	 it inline, that's great.  Otherwise, just punt it.  */
operator|&&
operator|(
name|DECL_INLINE
argument_list|(
name|fndecl
argument_list|)
operator|==
literal|0
operator|||
name|flag_no_inline
operator|||
name|function_cannot_inline_p
argument_list|(
name|fndecl
argument_list|)
operator|)
condition|)
block|{
specifier|extern
name|int
name|rtl_dump_and_exit
decl_stmt|;
name|int
name|old_rtl_dump_and_exit
init|=
name|rtl_dump_and_exit
decl_stmt|;
name|int
name|inline_spec
init|=
name|DECL_INLINE
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
comment|/* This throws away the code for FNDECL.  */
name|rtl_dump_and_exit
operator|=
literal|1
expr_stmt|;
comment|/* This throws away the memory of the code for FNDECL.  */
if|if
condition|(
name|flag_no_inline
condition|)
name|DECL_INLINE
argument_list|(
name|fndecl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|rest_of_compilation
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|rtl_dump_and_exit
operator|=
name|old_rtl_dump_and_exit
expr_stmt|;
name|DECL_INLINE
argument_list|(
name|fndecl
argument_list|)
operator|=
name|inline_spec
expr_stmt|;
block|}
else|else
block|{
comment|/* Run the optimizers and output the assembler code for this function.  */
name|rest_of_compilation
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ctype
operator|&&
name|TREE_ASM_WRITTEN
argument_list|(
name|fndecl
argument_list|)
condition|)
name|note_debug_info_needed
argument_list|(
name|ctype
argument_list|)
expr_stmt|;
name|current_function_returns_null
operator||=
name|can_reach_end
expr_stmt|;
comment|/* Since we don't normally go through c_expand_return for constructors,      this normally gets the wrong value.      Also, named return values have their return codes emitted after      NOTE_INSN_FUNCTION_END, confusing jump.c.  */
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|fndecl
argument_list|)
operator|||
name|DECL_NAME
argument_list|(
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|current_function_returns_null
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|fndecl
argument_list|)
operator|&&
name|current_function_returns_null
condition|)
name|warning
argument_list|(
literal|"`volatile' function does return"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|warn_return_type
operator|&&
name|current_function_returns_null
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|)
operator|!=
name|void_type_node
condition|)
block|{
comment|/* If this function returns non-void and control can drop through, 	 complain.  */
name|pedwarn
argument_list|(
literal|"control reaches end of non-void function"
argument_list|)
expr_stmt|;
block|}
comment|/* With just -W, complain only if function returns both with      and without a value.  */
elseif|else
if|if
condition|(
name|extra_warnings
operator|&&
name|current_function_returns_value
operator|&&
name|current_function_returns_null
condition|)
name|warning
argument_list|(
literal|"this function may return with or without a value"
argument_list|)
expr_stmt|;
comment|/* Free all the tree nodes making up this function.  */
comment|/* Switch back to allocating nodes permanently      until we start another function.  */
name|permanent_allocation
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag_cadillac
condition|)
name|cadillac_finish_function
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_SAVED_INSNS
argument_list|(
name|fndecl
argument_list|)
operator|==
name|NULL_RTX
condition|)
block|{
comment|/* Stop pointing to the local nodes about to be freed.  */
comment|/* But DECL_INITIAL must remain nonzero so we know this 	 was an actual function definition.  */
name|DECL_INITIAL
argument_list|(
name|fndecl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_CONSTRUCTOR_P
argument_list|(
name|fndecl
argument_list|)
operator|||
operator|!
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|TYPE_METHOD_BASETYPE
argument_list|(
name|fntype
argument_list|)
argument_list|)
condition|)
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
comment|/* Let the error reporting routines know that we're outside a function.  */
name|current_function_decl
operator|=
name|NULL_TREE
expr_stmt|;
name|named_label_uses
operator|=
name|NULL_TREE
expr_stmt|;
name|clear_anon_parm_name
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create the FUNCTION_DECL for a function definition.    LINE1 is the line number that the definition absolutely begins on.    LINE2 is the line number that the name of the function appears on.    DECLSPECS and DECLARATOR are the parts of the declaration;    they describe the function's name and the type it returns,    but twisted together in a fashion that parallels the syntax of C.     This function creates a binding context for the function body    as well as setting up the FUNCTION_DECL in current_function_decl.     Returns a FUNCTION_DECL on success.     If the DECLARATOR is not suitable for a function (it defines a datum    instead), we return 0, which tells yyparse to report a parse error.     May return void_type_node indicating that this method is actually    a friend.  See grokfield for more details.     Came here with a `.pushlevel' .     DO NOT MAKE ANY CHANGES TO THIS CODE WITHOUT MAKING CORRESPONDING    CHANGES TO CODE IN `grokfield'.  */
end_comment

begin_function
name|tree
name|start_method
parameter_list|(
name|declspecs
parameter_list|,
name|declarator
parameter_list|,
name|raises
parameter_list|)
name|tree
name|declarator
decl_stmt|,
name|declspecs
decl_stmt|,
name|raises
decl_stmt|;
block|{
name|tree
name|fndecl
init|=
name|grokdeclarator
argument_list|(
name|declarator
argument_list|,
name|declspecs
argument_list|,
name|MEMFUNCDEF
argument_list|,
literal|0
argument_list|,
name|raises
argument_list|)
decl_stmt|;
comment|/* Something too ugly to handle.  */
if|if
condition|(
name|fndecl
operator|==
name|NULL_TREE
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Pass friends other than inline friend functions back.  */
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|fndecl
argument_list|)
operator|==
name|void_type_node
condition|)
return|return
name|fndecl
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fndecl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
comment|/* Not a function, tell parser to report parse error.  */
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|DECL_IN_AGGR_P
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
if|if
condition|(
name|IDENTIFIER_ERROR_LOCUS
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|!=
name|current_class_type
condition|)
block|{
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|fndecl
argument_list|)
condition|)
name|error_with_decl
argument_list|(
name|fndecl
argument_list|,
literal|"`%s' is already defined in class %s"
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|void_type_node
return|;
block|}
comment|/* If we're expanding a template, a function must be explicitly declared      inline if we're to compile it now.  If it isn't, we have to wait to see      whether it's needed, and whether an override exists.  */
if|if
condition|(
name|flag_default_inline
operator|&&
operator|!
name|processing_template_defn
condition|)
name|DECL_INLINE
argument_list|(
name|fndecl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* We read in the parameters on the maybepermanent_obstack,      but we won't be getting back to them until after we      may have clobbered them.  So the call to preserve_data      will keep them safe.  */
name|preserve_data
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_FRIEND_P
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_CHAIN
argument_list|(
name|fndecl
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
comment|/* Need a fresh node here so that we don't get circularity 	     when we link these together.  If FNDECL was a friend, then 	     `pushdecl' does the right thing, which is nothing wrt its 	     current value of DECL_CHAIN.  */
name|fndecl
operator|=
name|copy_node
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
name|fndecl
operator|=
name|copy_node
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|fndecl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|fndecl
argument_list|)
condition|)
name|grok_ctor_properties
argument_list|(
name|current_class_type
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IDENTIFIER_OPNAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
condition|)
name|grok_op_properties
argument_list|(
name|fndecl
argument_list|,
name|DECL_VIRTUAL_P
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|finish_decl
argument_list|(
name|fndecl
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Make a place for the parms */
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|current_binding_level
operator|->
name|parm_flag
operator|=
literal|1
expr_stmt|;
name|DECL_IN_AGGR_P
argument_list|(
name|fndecl
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|fndecl
return|;
block|}
end_function

begin_comment
comment|/* Go through the motions of finishing a function definition.    We don't compile this method until after the whole class has    been processed.     FINISH_METHOD must return something that looks as though it    came from GROKFIELD (since we are defining a method, after all).     This is called after parsing the body of the function definition.    STMTS is the chain of statements that makes up the function body.     DECL is the ..._DECL that `start_method' provided.  */
end_comment

begin_function
name|tree
name|finish_method
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
specifier|register
name|tree
name|fndecl
init|=
name|decl
decl_stmt|;
name|tree
name|old_initial
decl_stmt|;
name|tree
name|context
init|=
name|DECL_CONTEXT
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|link
decl_stmt|;
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|decl
argument_list|)
operator|==
name|void_type_node
condition|)
return|return
name|decl
return|;
ifdef|#
directive|ifdef
name|DEBUG_CP_BINDING_LEVELS
name|indent_to
argument_list|(
name|stderr
argument_list|,
name|debug_bindings_indentation
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"finish_method"
argument_list|)
expr_stmt|;
name|debug_bindings_indentation
operator|+=
literal|4
expr_stmt|;
endif|#
directive|endif
name|old_initial
operator|=
name|DECL_INITIAL
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
comment|/* Undo the level for the parms (from start_method).      This is like poplevel, but it causes nothing to be      saved.  Saving information here confuses symbol-table      output routines.  Besides, this information will      be correctly output when this method is actually      compiled.  */
comment|/* Clear out the meanings of the local variables of this level;      also record in each decl which block it belongs to.  */
for|for
control|(
name|link
operator|=
name|current_binding_level
operator|->
name|names
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|link
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|link
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|link
argument_list|)
operator|!=
name|FUNCTION_DECL
argument_list|,
literal|163
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|link
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
comment|/* Restore all name-meanings of the outer levels      that were shadowed by this level.  */
for|for
control|(
name|link
operator|=
name|current_binding_level
operator|->
name|shadowed
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
expr_stmt|;
for|for
control|(
name|link
operator|=
name|current_binding_level
operator|->
name|class_shadowed
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
expr_stmt|;
for|for
control|(
name|link
operator|=
name|current_binding_level
operator|->
name|type_shadowed
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
expr_stmt|;
name|GNU_xref_end_scope
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|)
name|current_binding_level
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
name|current_binding_level
operator|->
name|level_chain
argument_list|,
name|current_binding_level
operator|->
name|parm_flag
argument_list|,
name|current_binding_level
operator|->
name|keep
argument_list|,
name|current_binding_level
operator|->
name|tag_transparent
argument_list|)
expr_stmt|;
name|pop_binding_level
argument_list|()
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|fndecl
argument_list|)
operator|=
name|old_initial
expr_stmt|;
if|#
directive|if
literal|0
comment|/* tiemann would like this, but is causes String.cc to not compile. */
block|if (DECL_FRIEND_P (fndecl) || DECL_CONTEXT (fndecl) != current_class_type)
else|#
directive|else
if|if
condition|(
name|DECL_FRIEND_P
argument_list|(
name|fndecl
argument_list|)
condition|)
endif|#
directive|endif
block|{
name|CLASSTYPE_INLINE_FRIENDS
argument_list|(
name|current_class_type
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|fndecl
argument_list|,
name|CLASSTYPE_INLINE_FRIENDS
argument_list|(
name|current_class_type
argument_list|)
argument_list|)
expr_stmt|;
name|decl
operator|=
name|void_type_node
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* Work in progress, 9/17/92. */
block|else if (context != current_class_type&& TREE_CHAIN (context) != NULL_TREE&& !DESTRUCTOR_NAME_P (DECL_ASSEMBLER_NAME (decl)))     {
comment|/* Don't allow them to declare a function like this:        class A {        public:          class B {          public:            int f();          };          int B::f() {}        };         Note we can get in here if it's a friend (in which case we'll        avoid lots of nasty cruft), or it's a destructor.  Compensate.       */
block|tree tmp = DECL_ARGUMENTS (TREE_CHAIN (context));       if (tmp&& TREE_CODE (tmp) == IDENTIFIER_NODE&& TREE_CHAIN (IDENTIFIER_GLOBAL_VALUE (tmp))&& TREE_CODE (TREE_CHAIN (IDENTIFIER_GLOBAL_VALUE (tmp))) == TYPE_DECL) 	{ 	  error_with_decl (decl, 			   "qualified name used in declaration of `%s'");
comment|/* Make this node virtually unusable in the end.  */
block|TREE_CHAIN (decl) = NULL_TREE; 	}     }
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG_CP_BINDING_LEVELS
name|debug_bindings_indentation
operator|-=
literal|4
expr_stmt|;
endif|#
directive|endif
return|return
name|decl
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Called when a new struct TYPE is defined.    If this structure or union completes the type of any previous    variable declaration, lay it out and output its rtl.  */
end_comment

begin_function
name|void
name|hack_incomplete_structures
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|decl
decl_stmt|;
if|if
condition|(
name|current_binding_level
operator|->
name|n_incomplete
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
operator|!
name|type
condition|)
comment|/* Don't do this for class templates.  */
return|return;
for|for
control|(
name|decl
operator|=
name|current_binding_level
operator|->
name|names
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|==
name|type
operator|||
operator|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|type
operator|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|layout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|toplevel
init|=
name|global_binding_level
operator|==
name|current_binding_level
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|type
condition|)
name|layout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|layout_decl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rest_of_decl_compilation
argument_list|(
name|decl
argument_list|,
name|NULL_PTR
argument_list|,
name|toplevel
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|toplevel
condition|)
block|{
name|expand_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|expand_decl_cleanup
argument_list|(
name|decl
argument_list|,
name|maybe_build_cleanup
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|expand_decl_init
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
name|my_friendly_assert
argument_list|(
name|current_binding_level
operator|->
name|n_incomplete
operator|>
literal|0
argument_list|,
literal|164
argument_list|)
expr_stmt|;
operator|--
name|current_binding_level
operator|->
name|n_incomplete
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Nonzero if presently building a cleanup.  Needed because    SAVE_EXPRs are not the right things to use inside of cleanups.    They are only ever evaluated once, where the cleanup    might be evaluated several times.  In this case, a later evaluation    of the cleanup might fill in the SAVE_EXPR_RTL, and it will    not be valid for an earlier cleanup.  */
end_comment

begin_decl_stmt
name|int
name|building_cleanup
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If DECL is of a type which needs a cleanup, build that cleanup here.    We don't build cleanups if just going for syntax checking, since    fixup_cleanups does not know how to not handle them.     Don't build these on the momentary obstack; they must live    the life of the binding contour.  */
end_comment

begin_function
name|tree
name|maybe_build_cleanup
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|int
name|temp
init|=
literal|0
decl_stmt|,
name|flags
init|=
name|LOOKUP_NORMAL
operator||
name|LOOKUP_DESTRUCTOR
decl_stmt|;
name|tree
name|rval
decl_stmt|;
name|int
name|old_building_cleanup
init|=
name|building_cleanup
decl_stmt|;
name|building_cleanup
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|PARM_DECL
condition|)
name|temp
operator|=
name|suspend_momentary
argument_list|()
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|rval
operator|=
name|decl
expr_stmt|;
else|else
block|{
name|mark_addressable
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|rval
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Optimize for space over speed here.  */
if|if
condition|(
operator|!
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|type
argument_list|)
operator|||
name|flag_expensive_optimizations
condition|)
name|flags
operator||=
name|LOOKUP_NONVIRTUAL
expr_stmt|;
comment|/* Use TYPE_MAIN_VARIANT so we don't get a warning about 	 calling delete on a `const' variable.  */
if|if
condition|(
name|TYPE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|rval
argument_list|)
argument_list|)
argument_list|)
condition|)
name|rval
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|rval
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|rval
argument_list|)
expr_stmt|;
name|rval
operator|=
name|build_delete
argument_list|(
name|TREE_TYPE
argument_list|(
name|rval
argument_list|)
argument_list|,
name|rval
argument_list|,
name|integer_two_node
argument_list|,
name|flags
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
name|rval
operator|=
name|build_compound_expr
argument_list|(
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|rval
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|build_vbase_delete
argument_list|(
name|type
argument_list|,
name|decl
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|current_binding_level
operator|->
name|have_cleanups
operator|=
literal|1
expr_stmt|;
name|current_binding_level
operator|->
name|more_exceptions_ok
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|PARM_DECL
condition|)
name|resume_momentary
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|building_cleanup
operator|=
name|old_building_cleanup
expr_stmt|;
return|return
name|rval
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Expand a C++ expression at the statement level.    This is needed to ferret out nodes which have UNKNOWN_TYPE.    The C++ type checker should get all of these out when    expressions are combined with other, type-providing, expressions,    leaving only orphan expressions, such as:&class::bar;		/ / takes its address, but does nothing with it.     */
end_comment

begin_function
name|void
name|cplus_expand_expr_stmt
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
operator|==
name|unknown_type_node
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|ADDR_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|error
argument_list|(
literal|"address of overloaded function with no contextual type information"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
name|warning
argument_list|(
literal|"useless reference to a member function name, did you forget the ()?"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|remove_implicit_immediately
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|warning_with_decl
argument_list|(
name|exp
argument_list|,
literal|"reference, not call, to function `%s'"
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"at this point in file"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_RAISES
argument_list|(
name|exp
argument_list|)
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|flag_handle_exceptions
argument_list|,
literal|165
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_handle_exceptions
operator|==
literal|2
condition|)
block|{
if|if
condition|(
operator|!
name|current_binding_level
operator|->
name|more_exceptions_ok
condition|)
block|{
specifier|extern
name|struct
name|nesting
modifier|*
name|nesting_stack
decl_stmt|,
modifier|*
name|block_stack
decl_stmt|;
name|remove_implicit_immediately
operator|=
operator|(
name|nesting_stack
operator|!=
name|block_stack
operator|)
expr_stmt|;
name|cplus_expand_start_try
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|current_binding_level
operator|->
name|have_exceptions
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|expand_expr_stmt
argument_list|(
name|break_out_cleanups
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|remove_implicit_immediately
condition|)
name|pop_implicit_try_blocks
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
comment|/* Clean up any pending cleanups.  This happens when a function call      returns a cleanup-needing value that nobody uses.  */
name|expand_cleanups_to
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* When a stmt has been parsed, this function is called.     Currently, this function only does something within a    constructor's scope: if a stmt has just assigned to this,    and we are in a derived class, we call `emit_base_init'.  */
end_comment

begin_function
name|void
name|finish_stmt
parameter_list|()
block|{
specifier|extern
name|struct
name|nesting
modifier|*
name|cond_stack
decl_stmt|,
modifier|*
name|loop_stack
decl_stmt|,
modifier|*
name|case_stack
decl_stmt|;
if|if
condition|(
name|current_function_assigns_this
operator|||
operator|!
name|current_function_just_assigned_this
condition|)
return|return;
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|current_function_decl
argument_list|)
condition|)
block|{
comment|/* Constructors must wait until we are out of control 	 zones before calling base constructors.  */
if|if
condition|(
name|cond_stack
operator|||
name|loop_stack
operator|||
name|case_stack
condition|)
return|return;
name|emit_insns
argument_list|(
name|base_init_insns
argument_list|)
expr_stmt|;
name|check_base_init
argument_list|(
name|current_class_type
argument_list|)
expr_stmt|;
block|}
name|current_function_assigns_this
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|flag_cadillac
condition|)
name|cadillac_finish_stmt
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pop_implicit_try_blocks
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
if|if
condition|(
name|decl
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|current_binding_level
operator|->
name|parm_flag
operator|==
literal|3
argument_list|,
literal|166
argument_list|)
expr_stmt|;
name|current_binding_level
operator|->
name|names
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|current_binding_level
operator|->
name|parm_flag
operator|==
literal|3
condition|)
block|{
name|tree
name|name
init|=
name|get_identifier
argument_list|(
literal|"(compiler error)"
argument_list|)
decl_stmt|;
name|tree
name|orig_ex_type
init|=
name|current_exception_type
decl_stmt|;
name|tree
name|orig_ex_decl
init|=
name|current_exception_decl
decl_stmt|;
name|tree
name|orig_ex_obj
init|=
name|current_exception_object
decl_stmt|;
name|tree
name|decl
init|=
name|cplus_expand_end_try
argument_list|(
literal|2
argument_list|)
decl_stmt|;
comment|/* @@ It would be nice to make all these point 	 to exactly the same handler.  */
comment|/* Start hidden EXCEPT.  */
name|cplus_expand_start_except
argument_list|(
name|name
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* reraise ALL.  */
name|cplus_expand_reraise
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
name|current_exception_type
operator|=
name|orig_ex_type
expr_stmt|;
name|current_exception_decl
operator|=
name|orig_ex_decl
expr_stmt|;
name|current_exception_object
operator|=
name|orig_ex_obj
expr_stmt|;
comment|/* This will reraise for us.  */
name|cplus_expand_end_except
argument_list|(
name|error_mark_node
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|decl
condition|)
block|{
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
operator|=
name|current_binding_level
operator|->
name|names
expr_stmt|;
name|current_binding_level
operator|->
name|names
operator|=
name|decl
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Push a cleanup onto the current binding contour that will cause    ADDR to be cleaned up, in the case that an exception propagates    through its binding contour.  */
end_comment

begin_function
name|void
name|push_exception_cleanup
parameter_list|(
name|addr
parameter_list|)
name|tree
name|addr
decl_stmt|;
block|{
name|tree
name|decl
init|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|get_identifier
argument_list|(
name|EXCEPTION_CLEANUP_NAME
argument_list|)
argument_list|,
name|ptr_type_node
argument_list|)
decl_stmt|;
name|tree
name|cleanup
decl_stmt|;
name|decl
operator|=
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_REGISTER
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|store_init_value
argument_list|(
name|decl
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|expand_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|expand_decl_init
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|cleanup
operator|=
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|build
argument_list|(
name|NE_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|decl
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
name|build_delete
argument_list|(
name|TREE_TYPE
argument_list|(
name|addr
argument_list|)
argument_list|,
name|decl
argument_list|,
name|lookup_name
argument_list|(
name|in_charge_identifier
argument_list|,
literal|0
argument_list|)
argument_list|,
name|LOOKUP_NORMAL
operator||
name|LOOKUP_DESTRUCTOR
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
name|expand_decl_cleanup
argument_list|(
name|decl
argument_list|,
name|cleanup
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* For each binding contour, emit code that deactivates the    exception cleanups.  All other cleanups are left as they were.  */
end_comment

begin_function
specifier|static
name|void
name|deactivate_exception_cleanups
parameter_list|()
block|{
name|struct
name|binding_level
modifier|*
name|b
init|=
name|current_binding_level
decl_stmt|;
name|tree
name|xyzzy
init|=
name|get_identifier
argument_list|(
name|EXCEPTION_CLEANUP_NAME
argument_list|)
decl_stmt|;
while|while
condition|(
name|b
operator|!=
name|class_binding_level
condition|)
block|{
if|if
condition|(
name|b
operator|->
name|parm_flag
operator|==
literal|3
condition|)
block|{
name|tree
name|decls
init|=
name|b
operator|->
name|names
decl_stmt|;
while|while
condition|(
name|decls
condition|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|decls
argument_list|)
operator|==
name|xyzzy
condition|)
name|expand_assignment
argument_list|(
name|decls
argument_list|,
name|integer_zero_node
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|decls
operator|=
name|TREE_CHAIN
argument_list|(
name|decls
argument_list|)
expr_stmt|;
block|}
block|}
name|b
operator|=
name|b
operator|->
name|level_chain
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Change a static member function definition into a FUNCTION_TYPE, instead    of the METHOD_TYPE that we create when it's originally parsed.  */
end_comment

begin_function
name|void
name|revert_static_member_fn
parameter_list|(
name|fn
parameter_list|,
name|decl
parameter_list|,
name|argtypes
parameter_list|)
name|tree
modifier|*
name|fn
decl_stmt|,
decl|*
name|decl
decl_stmt|,
modifier|*
name|argtypes
decl_stmt|;
end_function

begin_block
block|{
name|tree
name|tmp
decl_stmt|,
name|function
init|=
operator|*
name|fn
decl_stmt|;
operator|*
name|argtypes
operator|=
name|TREE_CHAIN
argument_list|(
operator|*
name|argtypes
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|build_function_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|,
operator|*
name|argtypes
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|build_type_variant
argument_list|(
name|tmp
argument_list|,
name|TYPE_READONLY
argument_list|(
name|function
argument_list|)
argument_list|,
name|TYPE_VOLATILE
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|build_exception_variant
argument_list|(
name|TYPE_METHOD_BASETYPE
argument_list|(
name|function
argument_list|)
argument_list|,
name|tmp
argument_list|,
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
operator|*
name|decl
argument_list|)
operator|=
name|tmp
expr_stmt|;
operator|*
name|fn
operator|=
name|tmp
expr_stmt|;
name|DECL_STATIC_FUNCTION_P
argument_list|(
operator|*
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_block

end_unit

