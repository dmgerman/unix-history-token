begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Process declarations and variables for C compiler.    Copyright (C) 1988, 1992, 1993, 1994 Free Software Foundation, Inc.    Hacked by Michael Tiemann (tiemann@cygnus.com)  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* Process declarations and symbol lookup for C front end.    Also constructs types; the standard scalar types at initialization,    and structure, union, array and enum types when they are declared.  */
end_comment

begin_comment
comment|/* ??? not all decl nodes are given the most useful possible    line numbers.  For example, the CONST_DECLs for enum values.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"decl.h"
end_include

begin_include
include|#
directive|include
file|"lex.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_decl_stmt
specifier|extern
name|tree
name|builtin_return_address_fndecl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|obstack
name|permanent_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|current_class_depth
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|tree
name|cleanups_this_call
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stack of places to restore the search obstack back to.  */
end_comment

begin_comment
comment|/* Obstack used for remembering local class declarations (like    enums and static (const) members.  */
end_comment

begin_include
include|#
directive|include
file|"stack.h"
end_include

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|decl_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|stack_level
modifier|*
name|decl_stack
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|CHAR_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|CHAR_TYPE_SIZE
value|BITS_PER_UNIT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SHORT_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|SHORT_TYPE_SIZE
value|(BITS_PER_UNIT * MIN ((UNITS_PER_WORD + 1) / 2, 2))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|INT_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|INT_TYPE_SIZE
value|BITS_PER_WORD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LONG_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|LONG_TYPE_SIZE
value|BITS_PER_WORD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LONG_LONG_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|LONG_LONG_TYPE_SIZE
value|(BITS_PER_WORD * 2)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WCHAR_UNSIGNED
end_ifndef

begin_define
define|#
directive|define
name|WCHAR_UNSIGNED
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|FLOAT_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|FLOAT_TYPE_SIZE
value|BITS_PER_WORD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DOUBLE_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|DOUBLE_TYPE_SIZE
value|(BITS_PER_WORD * 2)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LONG_DOUBLE_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|LONG_DOUBLE_TYPE_SIZE
value|(BITS_PER_WORD * 2)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* We let tm.h override the types used here, to handle trivial differences    such as the choice of unsigned int or long unsigned int for size_t.    When machines start needing nontrivial differences in the size type,    it would be best to do something here to figure out automatically    from other information what type to use.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SIZE_TYPE
end_ifndef

begin_define
define|#
directive|define
name|SIZE_TYPE
value|"long unsigned int"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PTRDIFF_TYPE
end_ifndef

begin_define
define|#
directive|define
name|PTRDIFF_TYPE
value|"long int"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WCHAR_TYPE
end_ifndef

begin_define
define|#
directive|define
name|WCHAR_TYPE
value|"int"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|builtin_function
parameter_list|(
name|NAME
parameter_list|,
name|TYPE
parameter_list|,
name|CODE
parameter_list|,
name|LIBNAME
parameter_list|)
define|\
value|define_function (NAME, TYPE, CODE, (void (*)())pushdecl, LIBNAME)
end_define

begin_define
define|#
directive|define
name|auto_function
parameter_list|(
name|NAME
parameter_list|,
name|TYPE
parameter_list|,
name|CODE
parameter_list|)
define|\
value|do {					\     tree __name = NAME;		\     tree __type = TYPE;			\     define_function (IDENTIFIER_POINTER (__name), __type, CODE,	\ 		     (void (*)())push_overloaded_decl_1,	\ 		     IDENTIFIER_POINTER (build_decl_overload (__name, TYPE_ARG_TYPES (__type), 0)));\   } while (0)
end_define

begin_decl_stmt
specifier|static
name|tree
name|grokparms
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|lookup_nested_type
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|redeclaration_error_message
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|grok_op_properties
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|define_function
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|tree
operator|,
expr|enum
name|built_in_function
operator|,
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* a node which has tree code ERROR_MARK, and whose type is itself.    All erroneous expressions are replaced with this node.  All functions    that accept nodes as arguments should avoid generating error messages    if this node is one of the arguments, since it is undesirable to get    multiple error messages from one error in the input.  */
end_comment

begin_decl_stmt
name|tree
name|error_mark_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Erroneous argument lists can use this *IFF* they do not modify it.  */
end_comment

begin_decl_stmt
name|tree
name|error_mark_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* INTEGER_TYPE and REAL_TYPE nodes for the standard data types */
end_comment

begin_decl_stmt
name|tree
name|short_integer_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|integer_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|long_integer_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|long_long_integer_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|short_unsigned_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|unsigned_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|long_unsigned_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|long_long_unsigned_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|ptrdiff_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|unsigned_char_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|signed_char_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|char_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|wchar_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|signed_wchar_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|unsigned_wchar_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|wchar_decl_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|float_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|double_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|long_double_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|intQI_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|intHI_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|intSI_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|intDI_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|unsigned_intQI_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|unsigned_intHI_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|unsigned_intSI_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|unsigned_intDI_type_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* a VOID_TYPE node, and the same, packaged in a TREE_LIST.  */
end_comment

begin_decl_stmt
name|tree
name|void_type_node
decl_stmt|,
name|void_list_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|void_zero_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nodes for types `void *' and `const void *'.  */
end_comment

begin_decl_stmt
name|tree
name|ptr_type_node
decl_stmt|,
name|const_ptr_type_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nodes for types `char *' and `const char *'.  */
end_comment

begin_decl_stmt
name|tree
name|string_type_node
decl_stmt|,
name|const_string_type_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Type `char[256]' or something like it.    Used when an array of char is needed and the size is irrelevant.  */
end_comment

begin_decl_stmt
name|tree
name|char_array_type_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Type `int[256]' or something like it.    Used when an array of int needed and the size is irrelevant.  */
end_comment

begin_decl_stmt
name|tree
name|int_array_type_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Type `wchar_t[256]' or something like it.    Used when a wide string literal is created.  */
end_comment

begin_decl_stmt
name|tree
name|wchar_array_type_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The bool data type, and constants */
end_comment

begin_decl_stmt
name|tree
name|bool_type_node
decl_stmt|,
name|true_node
decl_stmt|,
name|false_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* type `int ()' -- used for implicit declaration of functions.  */
end_comment

begin_decl_stmt
name|tree
name|default_function_type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* function types `double (double)' and `double (double, double)', etc.  */
end_comment

begin_decl_stmt
name|tree
name|double_ftype_double
decl_stmt|,
name|double_ftype_double_double
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|int_ftype_int
decl_stmt|,
name|long_ftype_long
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function type `void (void *, void *, int)' and similar ones.  */
end_comment

begin_decl_stmt
name|tree
name|void_ftype_ptr_ptr_int
decl_stmt|,
name|int_ftype_ptr_ptr_int
decl_stmt|,
name|void_ftype_ptr_int_int
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function type `char *(char *, char *)' and similar ones */
end_comment

begin_decl_stmt
name|tree
name|string_ftype_ptr_ptr
decl_stmt|,
name|int_ftype_string_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function type `size_t (const char *)' */
end_comment

begin_decl_stmt
name|tree
name|sizet_ftype_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function type `int (const void *, const void *, size_t)' */
end_comment

begin_decl_stmt
name|tree
name|int_ftype_cptr_cptr_sizet
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* C++ extensions */
end_comment

begin_decl_stmt
name|tree
name|vtable_entry_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|delta_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|__t_desc_type_node
decl_stmt|,
name|__i_desc_type_node
decl_stmt|,
name|__m_desc_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|__t_desc_array_type
decl_stmt|,
name|__i_desc_array_type
decl_stmt|,
name|__m_desc_array_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|class_star_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|class_type_node
decl_stmt|,
name|record_type_node
decl_stmt|,
name|union_type_node
decl_stmt|,
name|enum_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|exception_type_node
decl_stmt|,
name|unknown_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|opaque_type_node
decl_stmt|,
name|signature_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|sigtable_entry_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|maybe_gc_cleanup
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array type `vtable_entry_type[]' */
end_comment

begin_decl_stmt
name|tree
name|vtbl_type_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* In a destructor, the point at which all derived class destroying    has been done, just before any base class destroying will be done.  */
end_comment

begin_decl_stmt
name|tree
name|dtor_label
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* In a constructor, the point at which we are ready to return    the pointer to the initialized object.  */
end_comment

begin_decl_stmt
name|tree
name|ctor_label
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A FUNCTION_DECL which can call `abort'.  Not necessarily the    one that the user will declare, but sufficient to be called    by routines that want to abort the program.  */
end_comment

begin_decl_stmt
name|tree
name|abort_fndecl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|rtx
name|cleanup_label
decl_stmt|,
name|return_label
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If original DECL_RESULT of current function was a register,    but due to being an addressable named return value, would up    on the stack, this variable holds the named return value's    original location.  */
end_comment

begin_decl_stmt
name|rtx
name|original_result_rtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Sequence of insns which represents base initialization.  */
end_comment

begin_decl_stmt
name|rtx
name|base_init_insns
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* C++: Keep these around to reduce calls to `get_identifier'.    Identifiers for `this' in member functions and the auto-delete    parameter for destructors.  */
end_comment

begin_decl_stmt
name|tree
name|this_identifier
decl_stmt|,
name|in_charge_identifier
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used in pointer to member functions, and in vtables. */
end_comment

begin_decl_stmt
name|tree
name|pfn_identifier
decl_stmt|,
name|index_identifier
decl_stmt|,
name|delta_identifier
decl_stmt|,
name|delta2_identifier
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|pfn_or_delta2_identifier
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A list (chain of TREE_LIST nodes) of named label uses.    The TREE_PURPOSE field is the list of variables defined    the the label's scope defined at the point of use.    The TREE_VALUE field is the LABEL_DECL used.    The TREE_TYPE field holds `current_binding_level' at the    point of the label's use.     Used only for jumps to as-yet undefined labels, since    jumps to defined labels can have their validity checked    by stmt.c.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|named_label_uses
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A list of objects which have constructors or destructors    which reside in the global scope.  The decl is stored in    the TREE_VALUE slot and the initializer is stored    in the TREE_PURPOSE slot.  */
end_comment

begin_decl_stmt
name|tree
name|static_aggregates
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -- end of C++ */
end_comment

begin_comment
comment|/* Two expressions that are constants with value zero.    The first is of type `int', the second of type `void *'.  */
end_comment

begin_decl_stmt
name|tree
name|integer_zero_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|null_pointer_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A node for the integer constants 1, 2, and 3.  */
end_comment

begin_decl_stmt
name|tree
name|integer_one_node
decl_stmt|,
name|integer_two_node
decl_stmt|,
name|integer_three_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we have seen an invalid cross reference    to a struct, union, or enum, but not yet printed the message.  */
end_comment

begin_decl_stmt
name|tree
name|pending_invalid_xref
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* File and line to appear in the eventual error message.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|pending_invalid_xref_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pending_invalid_xref_line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* While defining an enum type, this is 1 plus the last enumerator    constant value.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|enum_next_value
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means that there was overflow computing enum_next_value.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|enum_overflow
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parsing a function declarator leaves a list of parameter names    or a chain or parameter decls here.  */
end_comment

begin_decl_stmt
name|tree
name|last_function_parms
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parsing a function declarator leaves here a chain of structure    and enum types declared in the parmlist.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|last_function_parm_tags
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* After parsing the declarator that starts a function definition,    `start_function' puts here the list of parameter names or chain of decls.    `store_parm_decls' finds it here.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|current_function_parms
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Similar, for last_function_parm_tags.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|current_function_parm_tags
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A list (chain of TREE_LIST nodes) of all LABEL_DECLs in the function    that have names.  Here so we can clear out their names' definitions    at the end of the function.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|named_labels
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A list of LABEL_DECLs from outer contexts that are currently shadowed.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|shadowed_labels
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Not needed by C++ */
end_comment

begin_comment
comment|/* Nonzero when store_parm_decls is called indicates a varargs function.    Value not meaningful after store_parm_decls.  */
end_comment

begin_endif
unit|static int c_function_varargs;
endif|#
directive|endif
end_endif

begin_comment
comment|/* The FUNCTION_DECL for the function currently being compiled,    or 0 if between functions.  */
end_comment

begin_decl_stmt
name|tree
name|current_function_decl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to 0 at beginning of a function definition, set to 1 if    a return statement that specifies a return value is seen.  */
end_comment

begin_decl_stmt
name|int
name|current_function_returns_value
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to 0 at beginning of a function definition, set to 1 if    a return statement with no argument is seen.  */
end_comment

begin_decl_stmt
name|int
name|current_function_returns_null
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to 0 at beginning of a function definition, and whenever    a label (case or named) is defined.  Set to value of expression    returned from function when that value can be transformed into    a named return value.  */
end_comment

begin_decl_stmt
name|tree
name|current_function_return_value
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to nonzero by `grokdeclarator' for a function    whose return type is defaulted, if warnings for this are desired.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|warn_about_return_type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero when starting a function declared `extern inline'.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|current_extern_inline
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means give `double' the same size as `float'.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|flag_short_double
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means don't recognize any builtin functions.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|flag_no_builtin
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means don't recognize the non-ANSI builtin functions.    -ansi sets this.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|flag_no_nonansi_builtin
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means disable GNU extensions.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|flag_ansi
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we want to support huge (> 2^(sizeof(short)*8-1) bytes)    objects. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|flag_huge_objects
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we want to conserve space in the .o files.  We do this    by putting uninitialized data and runtime initialized data into    .common instead of .data at the expense of not flaging multiple    definitions.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|flag_conserve_space
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointers to the base and current top of the language name stack.  */
end_comment

begin_decl_stmt
specifier|extern
name|tree
modifier|*
name|current_lang_base
decl_stmt|,
modifier|*
name|current_lang_stack
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* C and C++ flags are in decl2.c.  */
end_comment

begin_comment
comment|/* Set to 0 at beginning of a constructor, set to 1    if that function does an allocation before referencing its    instance variable.  */
end_comment

begin_decl_stmt
name|int
name|current_function_assigns_this
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|current_function_just_assigned_this
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to 0 at beginning of a function.  Set non-zero when    store_parm_decls is called.  Don't call store_parm_decls    if this flag is non-zero!  */
end_comment

begin_decl_stmt
name|int
name|current_function_parms_stored
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current end of entries in the gc obstack for stack pointer variables.  */
end_comment

begin_decl_stmt
name|int
name|current_function_obstack_index
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag saying whether we have used the obstack in this function or not.  */
end_comment

begin_decl_stmt
name|int
name|current_function_obstack_usage
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag used when debugging spew.c */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|spew_debug
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is a copy of the class_shadowed list of the previous class binding    contour when at global scope.  It's used to reset IDENTIFIER_CLASS_VALUEs    when entering another class scope (i.e. a cache miss).  */
end_comment

begin_decl_stmt
specifier|extern
name|tree
name|previous_class_values
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Allocate a level of searching.  */
end_comment

begin_function
name|struct
name|stack_level
modifier|*
name|push_decl_level
parameter_list|(
name|stack
parameter_list|,
name|obstack
parameter_list|)
name|struct
name|stack_level
modifier|*
name|stack
decl_stmt|;
name|struct
name|obstack
modifier|*
name|obstack
decl_stmt|;
block|{
name|struct
name|stack_level
name|tem
decl_stmt|;
name|tem
operator|.
name|prev
operator|=
name|stack
expr_stmt|;
return|return
name|push_stack_level
argument_list|(
name|obstack
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tem
argument_list|,
sizeof|sizeof
argument_list|(
name|tem
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* For each binding contour we allocate a binding_level structure  * which records the names defined in that contour.  * Contours include:  *  0) the global one  *  1) one for each function definition,  *     where internal declarations of the parameters appear.  *  2) one for each compound statement,  *     to record its declarations.  *  * The current meaning of a name can be found by searching the levels from  * the current one out to the global one.  *  * Off to the side, may be the class_binding_level.  This exists  * only to catch class-local declarations.  It is otherwise  * nonexistent.  *   * Also there may be binding levels that catch cleanups that  * must be run when exceptions occur.  */
end_comment

begin_comment
comment|/* Note that the information in the `names' component of the global contour    is duplicated in the IDENTIFIER_GLOBAL_VALUEs of all identifiers.  */
end_comment

begin_struct
struct|struct
name|binding_level
block|{
comment|/* A chain of _DECL nodes for all variables, constants, functions,      * and typedef types.  These are in the reverse of the order supplied.      */
name|tree
name|names
decl_stmt|;
comment|/* A list of structure, union and enum definitions,      * for looking up tag names.      * It is a chain of TREE_LIST nodes, each of whose TREE_PURPOSE is a name,      * or NULL_TREE; and whose TREE_VALUE is a RECORD_TYPE, UNION_TYPE,      * or ENUMERAL_TYPE node.      *      * C++: the TREE_VALUE nodes can be simple types for component_bindings.      *      */
name|tree
name|tags
decl_stmt|;
comment|/* For each level, a list of shadowed outer-level local definitions        to be restored when this level is popped.        Each link is a TREE_LIST whose TREE_PURPOSE is an identifier and        whose TREE_VALUE is its old definition (a kind of ..._DECL node).  */
name|tree
name|shadowed
decl_stmt|;
comment|/* Same, for IDENTIFIER_CLASS_VALUE.  */
name|tree
name|class_shadowed
decl_stmt|;
comment|/* Same, for IDENTIFIER_TYPE_VALUE.  */
name|tree
name|type_shadowed
decl_stmt|;
comment|/* For each level (except not the global one),        a chain of BLOCK nodes for all the levels        that were entered and exited one level down.  */
name|tree
name|blocks
decl_stmt|;
comment|/* The BLOCK node for this level, if one has been preallocated.        If 0, the BLOCK is allocated (if needed) when the level is popped.  */
name|tree
name|this_block
decl_stmt|;
comment|/* The binding level which this one is contained in (inherits from).  */
name|struct
name|binding_level
modifier|*
name|level_chain
decl_stmt|;
comment|/* Number of decls in `names' that have incomplete         structure or union types.  */
name|unsigned
name|short
name|n_incomplete
decl_stmt|;
comment|/* 1 for the level that holds the parameters of a function.        2 for the level that holds a class declaration.        3 for levels that hold parameter declarations.  */
name|unsigned
name|parm_flag
range|:
literal|4
decl_stmt|;
comment|/* 1 means make a BLOCK for this level regardless of all else.        2 for temporary binding contours created by the compiler.  */
name|unsigned
name|keep
range|:
literal|3
decl_stmt|;
comment|/* Nonzero if this level "doesn't exist" for tags.  */
name|unsigned
name|tag_transparent
range|:
literal|1
decl_stmt|;
comment|/* Nonzero if this level can safely have additional        cleanup-needing variables added to it.  */
name|unsigned
name|more_cleanups_ok
range|:
literal|1
decl_stmt|;
name|unsigned
name|have_cleanups
range|:
literal|1
decl_stmt|;
comment|/* Nonzero if we should accept any name as an identifier in        this scope.  This happens in some template definitions.  */
name|unsigned
name|accept_any
range|:
literal|1
decl_stmt|;
comment|/* Nonzero if this level is for completing a template class definition        inside a binding level that temporarily binds the parameters.  This        means that definitions here should not be popped off when unwinding        this binding level.  (Not actually implemented this way,        unfortunately.)  */
name|unsigned
name|pseudo_global
range|:
literal|1
decl_stmt|;
comment|/* Two bits left for this word.  */
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_CP_BINDING_LEVELS
argument_list|)
comment|/* Binding depth at which this level began.  */
name|unsigned
name|binding_depth
decl_stmt|;
endif|#
directive|endif
comment|/* defined(DEBUG_CP_BINDING_LEVELS) */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|NULL_BINDING_LEVEL
value|((struct binding_level *) NULL)
end_define

begin_comment
comment|/* The (non-class) binding level currently in effect.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|binding_level
modifier|*
name|current_binding_level
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The binding level of the current class, if any.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|binding_level
modifier|*
name|class_binding_level
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The current (class or non-class) binding level currently in effect.  */
end_comment

begin_define
define|#
directive|define
name|inner_binding_level
define|\
value|(class_binding_level ? class_binding_level : current_binding_level)
end_define

begin_comment
comment|/* A chain of binding_level structures awaiting reuse.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|binding_level
modifier|*
name|free_binding_level
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The outermost binding level, for names of file scope.    This is created when the compiler is started and exists    through the entire run.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|binding_level
modifier|*
name|global_binding_level
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Binding level structures are initialized by copying this one.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|binding_level
name|clear_binding_level
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means unconditionally make a BLOCK for the next level pushed.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|keep_next_level_flag
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_CP_BINDING_LEVELS
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|int
name|binding_depth
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_class_level
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|indent
parameter_list|()
block|{
specifier|register
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|binding_depth
operator|*
literal|2
condition|;
name|i
operator|++
control|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(DEBUG_CP_BINDING_LEVELS) */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|pushdecl_with_scope
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
expr|struct
name|binding_level
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|push_binding_level
parameter_list|(
name|newlevel
parameter_list|,
name|tag_transparent
parameter_list|,
name|keep
parameter_list|)
name|struct
name|binding_level
modifier|*
name|newlevel
decl_stmt|;
name|int
name|tag_transparent
decl_stmt|,
name|keep
decl_stmt|;
block|{
comment|/* Add this level to the front of the chain (stack) of levels that      are active.  */
operator|*
name|newlevel
operator|=
name|clear_binding_level
expr_stmt|;
if|if
condition|(
name|class_binding_level
condition|)
block|{
name|newlevel
operator|->
name|level_chain
operator|=
name|class_binding_level
expr_stmt|;
name|class_binding_level
operator|=
operator|(
expr|struct
name|binding_level
operator|*
operator|)
literal|0
expr_stmt|;
block|}
else|else
block|{
name|newlevel
operator|->
name|level_chain
operator|=
name|current_binding_level
expr_stmt|;
block|}
name|current_binding_level
operator|=
name|newlevel
expr_stmt|;
name|newlevel
operator|->
name|tag_transparent
operator|=
name|tag_transparent
expr_stmt|;
name|newlevel
operator|->
name|more_cleanups_ok
operator|=
literal|1
expr_stmt|;
name|newlevel
operator|->
name|keep
operator|=
name|keep
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_CP_BINDING_LEVELS
argument_list|)
name|newlevel
operator|->
name|binding_depth
operator|=
name|binding_depth
expr_stmt|;
name|indent
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"push %s level 0x%08x line %d\n"
argument_list|,
operator|(
name|is_class_level
operator|)
condition|?
literal|"class"
else|:
literal|"block"
argument_list|,
name|newlevel
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|is_class_level
operator|=
literal|0
expr_stmt|;
name|binding_depth
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* defined(DEBUG_CP_BINDING_LEVELS) */
block|}
end_function

begin_function
specifier|static
name|void
name|pop_binding_level
parameter_list|()
block|{
if|if
condition|(
name|class_binding_level
condition|)
name|current_binding_level
operator|=
name|class_binding_level
expr_stmt|;
if|if
condition|(
name|global_binding_level
condition|)
block|{
comment|/* cannot pop a level, if there are none left to pop. */
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
condition|)
name|my_friendly_abort
argument_list|(
literal|123
argument_list|)
expr_stmt|;
block|}
comment|/* Pop the current level, and free the structure for reuse.  */
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_CP_BINDING_LEVELS
argument_list|)
name|binding_depth
operator|--
expr_stmt|;
name|indent
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"pop  %s level 0x%08x line %d\n"
argument_list|,
operator|(
name|is_class_level
operator|)
condition|?
literal|"class"
else|:
literal|"block"
argument_list|,
name|current_binding_level
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_class_level
operator|!=
operator|(
name|current_binding_level
operator|==
name|class_binding_level
operator|)
condition|)
if|#
directive|if
literal|0
comment|/* XXX Don't abort when we're watching how things are being managed.  */
then|abort ();
else|#
directive|else
block|{
name|indent
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XXX is_class_level != (current_binding_level == class_binding_level)\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|is_class_level
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* defined(DEBUG_CP_BINDING_LEVELS) */
block|{
specifier|register
name|struct
name|binding_level
modifier|*
name|level
init|=
name|current_binding_level
decl_stmt|;
name|current_binding_level
operator|=
name|current_binding_level
operator|->
name|level_chain
expr_stmt|;
name|level
operator|->
name|level_chain
operator|=
name|free_binding_level
expr_stmt|;
if|#
directive|if
literal|0
comment|/* defined(DEBUG_CP_BINDING_LEVELS) */
block|if (level->binding_depth != binding_depth)       abort ();
endif|#
directive|endif
comment|/* defined(DEBUG_CP_BINDING_LEVELS) */
name|free_binding_level
operator|=
name|level
expr_stmt|;
name|class_binding_level
operator|=
name|current_binding_level
expr_stmt|;
if|if
condition|(
name|class_binding_level
operator|->
name|parm_flag
operator|!=
literal|2
condition|)
name|class_binding_level
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|current_binding_level
operator|->
name|parm_flag
operator|==
literal|2
condition|)
name|current_binding_level
operator|=
name|current_binding_level
operator|->
name|level_chain
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Nonzero if we are currently in the global binding level.  */
end_comment

begin_function
name|int
name|global_bindings_p
parameter_list|()
block|{
return|return
name|current_binding_level
operator|==
name|global_binding_level
return|;
block|}
end_function

begin_function
name|void
name|keep_next_level
parameter_list|()
block|{
name|keep_next_level_flag
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Nonzero if the current level needs to have a BLOCK made.  */
end_comment

begin_function
name|int
name|kept_level_p
parameter_list|()
block|{
return|return
operator|(
name|current_binding_level
operator|->
name|blocks
operator|!=
name|NULL_TREE
operator|||
name|current_binding_level
operator|->
name|keep
operator|||
name|current_binding_level
operator|->
name|names
operator|!=
name|NULL_TREE
operator|||
operator|(
name|current_binding_level
operator|->
name|tags
operator|!=
name|NULL_TREE
operator|&&
operator|!
name|current_binding_level
operator|->
name|tag_transparent
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Identify this binding level as a level of parameters.  */
end_comment

begin_function
name|void
name|declare_parm_level
parameter_list|()
block|{
name|current_binding_level
operator|->
name|parm_flag
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|declare_uninstantiated_type_level
parameter_list|()
block|{
name|current_binding_level
operator|->
name|accept_any
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|int
name|uninstantiated_type_level_p
parameter_list|()
block|{
return|return
name|current_binding_level
operator|->
name|accept_any
return|;
block|}
end_function

begin_function
name|void
name|declare_pseudo_global_level
parameter_list|()
block|{
name|current_binding_level
operator|->
name|pseudo_global
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|int
name|pseudo_global_level_p
parameter_list|()
block|{
return|return
name|current_binding_level
operator|->
name|pseudo_global
return|;
block|}
end_function

begin_function
name|void
name|set_class_shadows
parameter_list|(
name|shadows
parameter_list|)
name|tree
name|shadows
decl_stmt|;
block|{
name|class_binding_level
operator|->
name|class_shadowed
operator|=
name|shadows
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Enter a new binding level.    If TAG_TRANSPARENT is nonzero, do so only for the name space of variables,    not for that of tags.  */
end_comment

begin_function
name|void
name|pushlevel
parameter_list|(
name|tag_transparent
parameter_list|)
name|int
name|tag_transparent
decl_stmt|;
block|{
specifier|register
name|struct
name|binding_level
modifier|*
name|newlevel
init|=
name|NULL_BINDING_LEVEL
decl_stmt|;
comment|/* If this is the top level of a function,      just make sure that NAMED_LABELS is 0.      They should have been set to 0 at the end of the previous function.  */
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
condition|)
name|my_friendly_assert
argument_list|(
name|named_labels
operator|==
name|NULL_TREE
argument_list|,
literal|134
argument_list|)
expr_stmt|;
comment|/* Reuse or create a struct for this binding level.  */
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_CP_BINDING_LEVELS
argument_list|)
if|if
condition|(
literal|0
condition|)
else|#
directive|else
comment|/* !defined(DEBUG_CP_BINDING_LEVELS) */
if|if
condition|(
name|free_binding_level
condition|)
endif|#
directive|endif
comment|/* !defined(DEBUG_CP_BINDING_LEVELS) */
block|{
name|newlevel
operator|=
name|free_binding_level
expr_stmt|;
name|free_binding_level
operator|=
name|free_binding_level
operator|->
name|level_chain
expr_stmt|;
block|}
else|else
block|{
comment|/* Create a new `struct binding_level'.  */
name|newlevel
operator|=
operator|(
expr|struct
name|binding_level
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|binding_level
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|push_binding_level
argument_list|(
name|newlevel
argument_list|,
name|tag_transparent
argument_list|,
name|keep_next_level_flag
argument_list|)
expr_stmt|;
name|GNU_xref_start_scope
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|)
name|newlevel
argument_list|)
expr_stmt|;
name|keep_next_level_flag
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pushlevel_temporary
parameter_list|(
name|tag_transparent
parameter_list|)
name|int
name|tag_transparent
decl_stmt|;
block|{
name|pushlevel
argument_list|(
name|tag_transparent
argument_list|)
expr_stmt|;
name|current_binding_level
operator|->
name|keep
operator|=
literal|2
expr_stmt|;
name|clear_last_expr
argument_list|()
expr_stmt|;
comment|/* Note we don't call push_momentary() here.  Otherwise, it would cause      cleanups to be allocated on the momentary obstack, and they will be      overwritten by the next statement.  */
name|expand_start_bindings
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Exit a binding level.    Pop the level off, and restore the state of the identifier-decl mappings    that were in effect when this level was entered.     If KEEP == 1, this level had explicit declarations, so    and create a "block" (a BLOCK node) for the level    to record its declarations and subblocks for symbol table output.     If KEEP == 2, this level's subblocks go to the front,    not the back of the current binding level.  This happens,    for instance, when code for constructors and destructors    need to generate code at the end of a function which must    be moved up to the front of the function.     If FUNCTIONBODY is nonzero, this level is the body of a function,    so create a block as if KEEP were set and also clear out all    label names.     If REVERSE is nonzero, reverse the order of decls before putting    them into the BLOCK.  */
end_comment

begin_function
name|tree
name|poplevel
parameter_list|(
name|keep
parameter_list|,
name|reverse
parameter_list|,
name|functionbody
parameter_list|)
name|int
name|keep
decl_stmt|;
name|int
name|reverse
decl_stmt|;
name|int
name|functionbody
decl_stmt|;
block|{
specifier|register
name|tree
name|link
decl_stmt|;
comment|/* The chain of decls was accumulated in reverse order.      Put it into forward order, just for cleanliness.  */
name|tree
name|decls
decl_stmt|;
name|int
name|tmp
init|=
name|functionbody
decl_stmt|;
name|int
name|implicit_try_block
init|=
name|current_binding_level
operator|->
name|parm_flag
operator|==
literal|3
decl_stmt|;
name|int
name|real_functionbody
init|=
name|current_binding_level
operator|->
name|keep
operator|==
literal|2
condition|?
operator|(
operator|(
name|functionbody
operator|=
literal|0
operator|)
expr|,
name|tmp
operator|)
else|:
name|functionbody
decl_stmt|;
name|tree
name|tags
init|=
name|functionbody
operator|>=
literal|0
condition|?
name|current_binding_level
operator|->
name|tags
else|:
literal|0
decl_stmt|;
name|tree
name|subblocks
init|=
name|functionbody
operator|>=
literal|0
condition|?
name|current_binding_level
operator|->
name|blocks
else|:
literal|0
decl_stmt|;
name|tree
name|block
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|int
name|block_previously_created
decl_stmt|;
name|GNU_xref_end_scope
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|)
name|current_binding_level
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
name|current_binding_level
operator|->
name|level_chain
argument_list|,
name|current_binding_level
operator|->
name|parm_flag
argument_list|,
name|current_binding_level
operator|->
name|keep
argument_list|,
name|current_binding_level
operator|->
name|tag_transparent
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_binding_level
operator|->
name|keep
operator|==
literal|1
condition|)
name|keep
operator|=
literal|1
expr_stmt|;
comment|/* This warning is turned off because it causes warnings for      declarations like `extern struct foo *x'.  */
if|#
directive|if
literal|0
comment|/* Warn about incomplete structure types in this level.  */
block|for (link = tags; link; link = TREE_CHAIN (link))     if (TYPE_SIZE (TREE_VALUE (link)) == NULL_TREE)       { 	tree type = TREE_VALUE (link); 	char *errmsg; 	switch (TREE_CODE (type)) 	  { 	  case RECORD_TYPE: 	    errmsg = "`struct %s' incomplete in scope ending here"; 	    break; 	  case UNION_TYPE: 	    errmsg = "`union %s' incomplete in scope ending here"; 	    break; 	  case ENUMERAL_TYPE: 	    errmsg = "`enum %s' incomplete in scope ending here"; 	    break; 	  } 	if (TREE_CODE (TYPE_NAME (type)) == IDENTIFIER_NODE) 	  error (errmsg, IDENTIFIER_POINTER (TYPE_NAME (type))); 	else
comment|/* If this type has a typedef-name, the TYPE_NAME is a TYPE_DECL.  */
block|error (errmsg, TYPE_NAME_STRING (type));       }
endif|#
directive|endif
comment|/* 0 */
comment|/* Get the decls in the order they were written.      Usually current_binding_level->names is in reverse order.      But parameter decls were previously put in forward order.  */
if|if
condition|(
name|reverse
condition|)
name|current_binding_level
operator|->
name|names
operator|=
name|decls
operator|=
name|nreverse
argument_list|(
name|current_binding_level
operator|->
name|names
argument_list|)
expr_stmt|;
else|else
name|decls
operator|=
name|current_binding_level
operator|->
name|names
expr_stmt|;
comment|/* Output any nested inline functions within this block      if they weren't already output.  */
for|for
control|(
name|decl
operator|=
name|decls
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|TREE_ADDRESSABLE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* If this decl was copied from a file-scope decl 	   on account of a block-scope extern decl, 	   propagate TREE_ADDRESSABLE to the file-scope decl.  */
if|if
condition|(
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|TREE_ADDRESSABLE
argument_list|(
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|push_function_context
argument_list|()
expr_stmt|;
name|output_inline_function
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|pop_function_context
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* If there were any declarations or structure tags in that level,      or if this level is a function body,      create a BLOCK to record them for the life of this function.  */
name|block
operator|=
name|NULL_TREE
expr_stmt|;
name|block_previously_created
operator|=
operator|(
name|current_binding_level
operator|->
name|this_block
operator|!=
name|NULL_TREE
operator|)
expr_stmt|;
if|if
condition|(
name|block_previously_created
condition|)
name|block
operator|=
name|current_binding_level
operator|->
name|this_block
expr_stmt|;
elseif|else
if|if
condition|(
name|keep
operator|==
literal|1
operator|||
name|functionbody
condition|)
name|block
operator|=
name|make_node
argument_list|(
name|BLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|block
operator|!=
name|NULL_TREE
condition|)
block|{
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
operator|=
name|decls
expr_stmt|;
name|BLOCK_TYPE_TAGS
argument_list|(
name|block
argument_list|)
operator|=
name|tags
expr_stmt|;
name|BLOCK_SUBBLOCKS
argument_list|(
name|block
argument_list|)
operator|=
name|subblocks
expr_stmt|;
comment|/* If we created the block earlier on, and we are just diddling it now, 	 then it already should have a proper BLOCK_END_NOTE value associated 	 with it, so avoid trashing that.  Otherwise, for a new block, install 	 a new BLOCK_END_NOTE value.  */
if|if
condition|(
operator|!
name|block_previously_created
condition|)
name|remember_end_note
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
comment|/* In each subblock, record that this is its superior.  */
if|if
condition|(
name|keep
operator|>=
literal|0
condition|)
for|for
control|(
name|link
operator|=
name|subblocks
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
name|BLOCK_SUPERCONTEXT
argument_list|(
name|link
argument_list|)
operator|=
name|block
expr_stmt|;
comment|/* Clear out the meanings of the local variables of this level.  */
for|for
control|(
name|link
operator|=
name|decls
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|link
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
comment|/* If the ident. was used or addressed via a local extern decl, 	     don't forget that fact.  */
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|link
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_USED
argument_list|(
name|link
argument_list|)
condition|)
name|TREE_USED
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|link
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|link
argument_list|)
condition|)
name|TREE_ADDRESSABLE
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|link
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|link
argument_list|)
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
comment|/* Restore all name-meanings of the outer levels      that were shadowed by this level.  */
for|for
control|(
name|link
operator|=
name|current_binding_level
operator|->
name|shadowed
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
expr_stmt|;
for|for
control|(
name|link
operator|=
name|current_binding_level
operator|->
name|class_shadowed
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
expr_stmt|;
for|for
control|(
name|link
operator|=
name|current_binding_level
operator|->
name|type_shadowed
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
expr_stmt|;
comment|/* If the level being exited is the top level of a function,      check over all the labels.  */
if|if
condition|(
name|functionbody
condition|)
block|{
comment|/* If this is the top level block of a function,          the vars are the function's parameters.          Don't leave them in the BLOCK because they are          found in the FUNCTION_DECL instead.  */
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Clear out the definitions of all label names, 	 since their scopes end here.  */
for|for
control|(
name|link
operator|=
name|named_labels
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
block|{
specifier|register
name|tree
name|label
init|=
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
decl_stmt|;
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|label
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"label `%D' used but not defined"
argument_list|,
name|label
argument_list|)
expr_stmt|;
comment|/* Avoid crashing later.  */
name|define_label
argument_list|(
name|input_filename
argument_list|,
literal|1
argument_list|,
name|DECL_NAME
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|warn_unused
operator|&&
operator|!
name|TREE_USED
argument_list|(
name|label
argument_list|)
condition|)
name|cp_warning_at
argument_list|(
literal|"label `%D' defined but not used"
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_LABEL_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|label
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* Put the labels into the "variables" of the              top-level block, so debugger can see them.  */
name|TREE_CHAIN
argument_list|(
name|label
argument_list|)
operator|=
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
operator|=
name|label
expr_stmt|;
block|}
name|named_labels
operator|=
name|NULL_TREE
expr_stmt|;
block|}
comment|/* Any uses of undefined labels now operate under constraints      of next binding contour.  */
block|{
name|struct
name|binding_level
modifier|*
name|level_chain
decl_stmt|;
name|level_chain
operator|=
name|current_binding_level
operator|->
name|level_chain
expr_stmt|;
if|if
condition|(
name|level_chain
condition|)
block|{
name|tree
name|labels
decl_stmt|;
for|for
control|(
name|labels
operator|=
name|named_label_uses
init|;
name|labels
condition|;
name|labels
operator|=
name|TREE_CHAIN
argument_list|(
name|labels
argument_list|)
control|)
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|labels
argument_list|)
operator|==
operator|(
name|tree
operator|)
name|current_binding_level
condition|)
block|{
name|TREE_TYPE
argument_list|(
name|labels
argument_list|)
operator|=
operator|(
name|tree
operator|)
name|level_chain
expr_stmt|;
name|TREE_PURPOSE
argument_list|(
name|labels
argument_list|)
operator|=
name|level_chain
operator|->
name|names
expr_stmt|;
block|}
block|}
block|}
name|tmp
operator|=
name|current_binding_level
operator|->
name|keep
expr_stmt|;
name|pop_binding_level
argument_list|()
expr_stmt|;
if|if
condition|(
name|functionbody
condition|)
name|DECL_INITIAL
argument_list|(
name|current_function_decl
argument_list|)
operator|=
name|block
expr_stmt|;
elseif|else
if|if
condition|(
name|block
condition|)
block|{
if|if
condition|(
operator|!
name|block_previously_created
condition|)
name|current_binding_level
operator|->
name|blocks
operator|=
name|chainon
argument_list|(
name|current_binding_level
operator|->
name|blocks
argument_list|,
name|block
argument_list|)
expr_stmt|;
block|}
comment|/* If we did not make a block for the level just exited,      any blocks made for inner levels      (since they cannot be recorded as subblocks in that level)      must be carried forward so they will later become subblocks      of something else.  */
elseif|else
if|if
condition|(
name|subblocks
condition|)
block|{
if|if
condition|(
name|keep
operator|==
literal|2
condition|)
name|current_binding_level
operator|->
name|blocks
operator|=
name|chainon
argument_list|(
name|subblocks
argument_list|,
name|current_binding_level
operator|->
name|blocks
argument_list|)
expr_stmt|;
else|else
name|current_binding_level
operator|->
name|blocks
operator|=
name|chainon
argument_list|(
name|current_binding_level
operator|->
name|blocks
argument_list|,
name|subblocks
argument_list|)
expr_stmt|;
block|}
comment|/* Take care of compiler's internal binding structures.  */
if|if
condition|(
name|tmp
operator|==
literal|2
condition|)
block|{
if|#
directive|if
literal|0
comment|/* We did not call push_momentary for this 	 binding contour, so there is nothing to pop.  */
block|pop_momentary ();
endif|#
directive|endif
name|expand_end_bindings
argument_list|(
name|getdecls
argument_list|()
argument_list|,
name|keep
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Each and every BLOCK node created here in `poplevel' is important 	 (e.g. for proper debugging information) so if we created one 	 earlier, mark it as "used".  */
if|if
condition|(
name|block
condition|)
name|TREE_USED
argument_list|(
name|block
argument_list|)
operator|=
literal|1
expr_stmt|;
name|block
operator|=
name|poplevel
argument_list|(
name|keep
argument_list|,
name|reverse
argument_list|,
name|real_functionbody
argument_list|)
expr_stmt|;
block|}
comment|/* Each and every BLOCK node created here in `poplevel' is important      (e.g. for proper debugging information) so if we created one      earlier, mark it as "used".  */
if|if
condition|(
name|block
condition|)
name|TREE_USED
argument_list|(
name|block
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|block
return|;
block|}
end_function

begin_comment
comment|/* Delete the node BLOCK from the current binding level.    This is used for the block inside a stmt expr ({...})    so that the block can be reinserted where appropriate.  */
end_comment

begin_function
name|void
name|delete_block
parameter_list|(
name|block
parameter_list|)
name|tree
name|block
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|current_binding_level
operator|->
name|blocks
operator|==
name|block
condition|)
name|current_binding_level
operator|->
name|blocks
operator|=
name|TREE_CHAIN
argument_list|(
name|block
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|current_binding_level
operator|->
name|blocks
init|;
name|t
condition|;
control|)
block|{
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|==
name|block
condition|)
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|block
argument_list|)
expr_stmt|;
else|else
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
name|TREE_CHAIN
argument_list|(
name|block
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Clear TREE_USED which is always set by poplevel.      The flag is set again if insert_block is called.  */
name|TREE_USED
argument_list|(
name|block
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Insert BLOCK at the end of the list of subblocks of the    current binding level.  This is used when a BIND_EXPR is expanded,    to handle the BLOCK node inside the BIND_EXPR.  */
end_comment

begin_function
name|void
name|insert_block
parameter_list|(
name|block
parameter_list|)
name|tree
name|block
decl_stmt|;
block|{
name|TREE_USED
argument_list|(
name|block
argument_list|)
operator|=
literal|1
expr_stmt|;
name|current_binding_level
operator|->
name|blocks
operator|=
name|chainon
argument_list|(
name|current_binding_level
operator|->
name|blocks
argument_list|,
name|block
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add BLOCK to the current list of blocks for this binding contour.  */
end_comment

begin_function
name|void
name|add_block_current_level
parameter_list|(
name|block
parameter_list|)
name|tree
name|block
decl_stmt|;
block|{
name|current_binding_level
operator|->
name|blocks
operator|=
name|chainon
argument_list|(
name|current_binding_level
operator|->
name|blocks
argument_list|,
name|block
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the BLOCK node for the innermost scope    (the one we are currently in).  */
end_comment

begin_function
name|void
name|set_block
parameter_list|(
name|block
parameter_list|)
specifier|register
name|tree
name|block
decl_stmt|;
block|{
name|current_binding_level
operator|->
name|this_block
operator|=
name|block
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Do a pushlevel for class declarations.  */
end_comment

begin_function
name|void
name|pushlevel_class
parameter_list|()
block|{
specifier|register
name|struct
name|binding_level
modifier|*
name|newlevel
decl_stmt|;
comment|/* Reuse or create a struct for this binding level.  */
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_CP_BINDING_LEVELS
argument_list|)
if|if
condition|(
literal|0
condition|)
else|#
directive|else
comment|/* !defined(DEBUG_CP_BINDING_LEVELS) */
if|if
condition|(
name|free_binding_level
condition|)
endif|#
directive|endif
comment|/* !defined(DEBUG_CP_BINDING_LEVELS) */
block|{
name|newlevel
operator|=
name|free_binding_level
expr_stmt|;
name|free_binding_level
operator|=
name|free_binding_level
operator|->
name|level_chain
expr_stmt|;
block|}
else|else
block|{
comment|/* Create a new `struct binding_level'.  */
name|newlevel
operator|=
operator|(
expr|struct
name|binding_level
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|binding_level
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_CP_BINDING_LEVELS
argument_list|)
name|is_class_level
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* defined(DEBUG_CP_BINDING_LEVELS) */
name|push_binding_level
argument_list|(
name|newlevel
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|decl_stack
operator|=
name|push_decl_level
argument_list|(
name|decl_stack
argument_list|,
operator|&
name|decl_obstack
argument_list|)
expr_stmt|;
name|class_binding_level
operator|=
name|current_binding_level
expr_stmt|;
name|class_binding_level
operator|->
name|parm_flag
operator|=
literal|2
expr_stmt|;
comment|/* We have just pushed into a new binding level.  Now, fake out the rest      of the compiler.  Set the `current_binding_level' back to point to      the most closely containing non-class binding level.  */
do|do
block|{
name|current_binding_level
operator|=
name|current_binding_level
operator|->
name|level_chain
expr_stmt|;
block|}
do|while
condition|(
name|current_binding_level
operator|->
name|parm_flag
operator|==
literal|2
condition|)
do|;
block|}
end_function

begin_comment
comment|/* ...and a poplevel for class declarations.  FORCE is used to force    clearing out of CLASS_VALUEs after a class definition.  */
end_comment

begin_function
name|tree
name|poplevel_class
parameter_list|(
name|force
parameter_list|)
name|int
name|force
decl_stmt|;
block|{
specifier|register
name|struct
name|binding_level
modifier|*
name|level
init|=
name|class_binding_level
decl_stmt|;
name|tree
name|block
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|shadowed
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|level
operator|!=
literal|0
argument_list|,
literal|354
argument_list|)
expr_stmt|;
name|decl_stack
operator|=
name|pop_stack_level
argument_list|(
name|decl_stack
argument_list|)
expr_stmt|;
for|for
control|(
name|shadowed
operator|=
name|level
operator|->
name|shadowed
init|;
name|shadowed
condition|;
name|shadowed
operator|=
name|TREE_CHAIN
argument_list|(
name|shadowed
argument_list|)
control|)
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|shadowed
argument_list|)
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|shadowed
argument_list|)
expr_stmt|;
comment|/* If we're leaving a toplevel class, don't bother to do the setting      of IDENTIFER_CLASS_VALUE to NULL_TREE, since first of all this slot      shouldn't even be used when current_class_type isn't set, and second,      if we don't touch it here, we're able to use the caching effect if the      next time we're entering a class scope, it is the same class.  */
if|if
condition|(
name|current_class_depth
operator|!=
literal|1
operator|||
name|force
condition|)
for|for
control|(
name|shadowed
operator|=
name|level
operator|->
name|class_shadowed
init|;
name|shadowed
condition|;
name|shadowed
operator|=
name|TREE_CHAIN
argument_list|(
name|shadowed
argument_list|)
control|)
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|shadowed
argument_list|)
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|shadowed
argument_list|)
expr_stmt|;
else|else
comment|/* Remember to save what IDENTIFIER's were bound in this scope so we        can recover from cache misses.  */
name|previous_class_values
operator|=
name|class_binding_level
operator|->
name|class_shadowed
expr_stmt|;
for|for
control|(
name|shadowed
operator|=
name|level
operator|->
name|type_shadowed
init|;
name|shadowed
condition|;
name|shadowed
operator|=
name|TREE_CHAIN
argument_list|(
name|shadowed
argument_list|)
control|)
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|shadowed
argument_list|)
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|shadowed
argument_list|)
expr_stmt|;
name|GNU_xref_end_scope
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|)
name|class_binding_level
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
name|class_binding_level
operator|->
name|level_chain
argument_list|,
name|class_binding_level
operator|->
name|parm_flag
argument_list|,
name|class_binding_level
operator|->
name|keep
argument_list|,
name|class_binding_level
operator|->
name|tag_transparent
argument_list|)
expr_stmt|;
if|if
condition|(
name|class_binding_level
operator|->
name|parm_flag
operator|!=
literal|2
condition|)
name|class_binding_level
operator|=
operator|(
expr|struct
name|binding_level
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* Now, pop out of the the binding level which we created up in the      `pushlevel_class' routine.  */
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_CP_BINDING_LEVELS
argument_list|)
name|is_class_level
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* defined(DEBUG_CP_BINDING_LEVELS) */
name|pop_binding_level
argument_list|()
expr_stmt|;
return|return
name|block
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* For debugging.  */
end_comment

begin_decl_stmt
name|int
name|no_print_functions
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|no_print_builtins
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|print_binding_level
parameter_list|(
name|lvl
parameter_list|)
name|struct
name|binding_level
modifier|*
name|lvl
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|,
name|len
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" blocks="
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|HOST_PTR_PRINTF
argument_list|,
name|lvl
operator|->
name|blocks
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" n_incomplete=%d parm_flag=%d keep=%d"
argument_list|,
name|lvl
operator|->
name|n_incomplete
argument_list|,
name|lvl
operator|->
name|parm_flag
argument_list|,
name|lvl
operator|->
name|keep
argument_list|)
expr_stmt|;
if|if
condition|(
name|lvl
operator|->
name|tag_transparent
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" tag-transparent"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lvl
operator|->
name|more_cleanups_ok
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" more-cleanups-ok"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lvl
operator|->
name|have_cleanups
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" have-cleanups"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lvl
operator|->
name|names
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" names:\t"
argument_list|)
expr_stmt|;
comment|/* We can probably fit 3 names to a line?  */
for|for
control|(
name|t
operator|=
name|lvl
operator|->
name|names
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
if|if
condition|(
name|no_print_functions
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FUNCTION_DECL
operator|)
condition|)
continue|continue;
if|if
condition|(
name|no_print_builtins
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_DECL
operator|)
operator|&&
operator|(
operator|!
name|strcmp
argument_list|(
name|DECL_SOURCE_FILE
argument_list|(
name|t
argument_list|)
argument_list|,
literal|"<built-in>"
argument_list|)
operator|)
condition|)
continue|continue;
comment|/* Function decls tend to have longer names.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|len
operator|=
literal|3
expr_stmt|;
else|else
name|len
operator|=
literal|2
expr_stmt|;
name|i
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|6
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n\t"
argument_list|)
expr_stmt|;
name|i
operator|=
name|len
expr_stmt|;
block|}
name|print_node_brief
argument_list|(
name|stderr
argument_list|,
literal|""
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ERROR_MARK
condition|)
break|break;
block|}
if|if
condition|(
name|i
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lvl
operator|->
name|tags
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" tags:\t"
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|t
operator|=
name|lvl
operator|->
name|tags
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|len
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_IDENTIFIER
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
name|len
operator|=
literal|2
expr_stmt|;
else|else
name|len
operator|=
literal|4
expr_stmt|;
name|i
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|5
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n\t"
argument_list|)
expr_stmt|;
name|i
operator|=
name|len
expr_stmt|;
block|}
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|print_node_brief
argument_list|(
name|stderr
argument_list|,
literal|"<unnamed-typedef"
argument_list|,
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_IDENTIFIER
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
name|print_node_brief
argument_list|(
name|stderr
argument_list|,
literal|""
argument_list|,
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|print_node_brief
argument_list|(
name|stderr
argument_list|,
literal|"<typedef"
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|print_node_brief
argument_list|(
name|stderr
argument_list|,
literal|""
argument_list|,
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lvl
operator|->
name|shadowed
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" shadowed:"
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|lvl
operator|->
name|shadowed
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %s "
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lvl
operator|->
name|class_shadowed
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" class-shadowed:"
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|lvl
operator|->
name|class_shadowed
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %s "
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lvl
operator|->
name|type_shadowed
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" type-shadowed:"
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|lvl
operator|->
name|type_shadowed
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
if|#
directive|if
literal|0
block|fprintf (stderr, "\n\t");           print_node_brief (stderr, "<", TREE_PURPOSE (t), 0);           if (TREE_VALUE (t))             print_node_brief (stderr, " ", TREE_VALUE (t), 0);           else             fprintf (stderr, " (none)");           fprintf (stderr, ">");
else|#
directive|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %s "
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|print_other_binding_stack
parameter_list|(
name|stack
parameter_list|)
name|struct
name|binding_level
modifier|*
name|stack
decl_stmt|;
block|{
name|struct
name|binding_level
modifier|*
name|level
decl_stmt|;
for|for
control|(
name|level
operator|=
name|stack
init|;
name|level
operator|!=
name|global_binding_level
condition|;
name|level
operator|=
name|level
operator|->
name|level_chain
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"binding level "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|HOST_PTR_PRINTF
argument_list|,
name|level
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|print_binding_level
argument_list|(
name|level
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|print_binding_stack
parameter_list|()
block|{
name|struct
name|binding_level
modifier|*
name|b
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"current_binding_level="
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|HOST_PTR_PRINTF
argument_list|,
name|current_binding_level
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nclass_binding_level="
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|HOST_PTR_PRINTF
argument_list|,
name|class_binding_level
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nglobal_binding_level="
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|HOST_PTR_PRINTF
argument_list|,
name|global_binding_level
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|class_binding_level
condition|)
block|{
for|for
control|(
name|b
operator|=
name|class_binding_level
init|;
name|b
condition|;
name|b
operator|=
name|b
operator|->
name|level_chain
control|)
if|if
condition|(
name|b
operator|==
name|current_binding_level
condition|)
break|break;
if|if
condition|(
name|b
condition|)
name|b
operator|=
name|class_binding_level
expr_stmt|;
else|else
name|b
operator|=
name|current_binding_level
expr_stmt|;
block|}
else|else
name|b
operator|=
name|current_binding_level
expr_stmt|;
name|print_other_binding_stack
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"global:\n"
argument_list|)
expr_stmt|;
name|print_binding_level
argument_list|(
name|global_binding_level
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutines for reverting temporarily to top-level for instantiation    of templates and such.  We actually need to clear out the class- and    local-value slots of all identifiers, so that only the global values    are at all visible.  Simply setting current_binding_level to the global    scope isn't enough, because more binding levels may be pushed.  */
end_comment

begin_struct
struct|struct
name|saved_scope
block|{
name|struct
name|binding_level
modifier|*
name|old_binding_level
decl_stmt|;
name|tree
name|old_bindings
decl_stmt|;
name|struct
name|saved_scope
modifier|*
name|prev
decl_stmt|;
name|tree
name|class_name
decl_stmt|,
name|class_type
decl_stmt|,
name|class_decl
decl_stmt|,
name|function_decl
decl_stmt|;
name|struct
name|binding_level
modifier|*
name|class_bindings
decl_stmt|;
name|tree
name|previous_class_type
decl_stmt|;
name|tree
modifier|*
name|lang_base
decl_stmt|,
modifier|*
name|lang_stack
decl_stmt|,
name|lang_name
decl_stmt|;
name|int
name|lang_stacksize
decl_stmt|;
name|tree
name|named_labels
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|saved_scope
modifier|*
name|current_saved_scope
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|tree
name|prev_class_type
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|push_to_top_level
parameter_list|()
block|{
specifier|extern
name|int
name|current_lang_stacksize
decl_stmt|;
name|struct
name|saved_scope
modifier|*
name|s
init|=
operator|(
expr|struct
name|saved_scope
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|saved_scope
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|binding_level
modifier|*
name|b
init|=
name|current_binding_level
decl_stmt|;
name|tree
name|old_bindings
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Have to include global_binding_level, because class-level decls      aren't listed anywhere useful.  */
for|for
control|(
init|;
name|b
condition|;
name|b
operator|=
name|b
operator|->
name|level_chain
control|)
block|{
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|b
operator|==
name|global_binding_level
condition|)
continue|continue;
for|for
control|(
name|t
operator|=
name|b
operator|->
name|names
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|tree
name|binding
decl_stmt|,
name|t1
decl_stmt|,
name|t2
init|=
name|t
decl_stmt|;
name|tree
name|id
init|=
name|DECL_ASSEMBLER_NAME
argument_list|(
name|t2
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|id
operator|||
operator|(
operator|!
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|id
argument_list|)
operator|&&
operator|!
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|id
argument_list|)
operator|)
condition|)
continue|continue;
for|for
control|(
name|t1
operator|=
name|old_bindings
init|;
name|t1
condition|;
name|t1
operator|=
name|TREE_CHAIN
argument_list|(
name|t1
argument_list|)
control|)
if|if
condition|(
name|TREE_VEC_ELT
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
operator|==
name|id
condition|)
goto|goto
name|skip_it
goto|;
name|binding
operator|=
name|make_tree_vec
argument_list|(
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|==
name|IDENTIFIER_NODE
argument_list|,
literal|135
argument_list|)
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|binding
argument_list|,
literal|0
argument_list|)
operator|=
name|id
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|binding
argument_list|,
literal|1
argument_list|)
operator|=
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|binding
argument_list|,
literal|2
argument_list|)
operator|=
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|binding
argument_list|,
literal|3
argument_list|)
operator|=
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|id
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|id
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|TREE_CHAIN
argument_list|(
name|binding
argument_list|)
operator|=
name|old_bindings
expr_stmt|;
name|old_bindings
operator|=
name|binding
expr_stmt|;
name|skip_it
label|:
empty_stmt|;
block|}
comment|/* Unwind type-value slots back to top level.  */
for|for
control|(
name|t
operator|=
name|b
operator|->
name|type_shadowed
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
name|SET_IDENTIFIER_TYPE_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Clear out class-level bindings cache.  */
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
operator|&&
name|previous_class_type
operator|!=
name|NULL_TREE
condition|)
block|{
name|popclass
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|previous_class_type
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|s
operator|->
name|old_binding_level
operator|=
name|current_binding_level
expr_stmt|;
name|current_binding_level
operator|=
name|global_binding_level
expr_stmt|;
name|s
operator|->
name|class_name
operator|=
name|current_class_name
expr_stmt|;
name|s
operator|->
name|class_type
operator|=
name|current_class_type
expr_stmt|;
name|s
operator|->
name|class_decl
operator|=
name|current_class_decl
expr_stmt|;
name|s
operator|->
name|function_decl
operator|=
name|current_function_decl
expr_stmt|;
name|s
operator|->
name|class_bindings
operator|=
name|class_binding_level
expr_stmt|;
name|s
operator|->
name|previous_class_type
operator|=
name|previous_class_type
expr_stmt|;
name|s
operator|->
name|lang_stack
operator|=
name|current_lang_stack
expr_stmt|;
name|s
operator|->
name|lang_base
operator|=
name|current_lang_base
expr_stmt|;
name|s
operator|->
name|lang_stacksize
operator|=
name|current_lang_stacksize
expr_stmt|;
name|s
operator|->
name|lang_name
operator|=
name|current_lang_name
expr_stmt|;
name|s
operator|->
name|named_labels
operator|=
name|named_labels
expr_stmt|;
name|current_class_name
operator|=
name|current_class_type
operator|=
name|current_class_decl
operator|=
name|NULL_TREE
expr_stmt|;
name|current_function_decl
operator|=
name|NULL_TREE
expr_stmt|;
name|class_binding_level
operator|=
operator|(
expr|struct
name|binding_level
operator|*
operator|)
literal|0
expr_stmt|;
name|previous_class_type
operator|=
name|NULL_TREE
expr_stmt|;
name|current_lang_stacksize
operator|=
literal|10
expr_stmt|;
name|current_lang_stack
operator|=
name|current_lang_base
operator|=
operator|(
name|tree
operator|*
operator|)
name|xmalloc
argument_list|(
name|current_lang_stacksize
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
name|current_lang_name
operator|=
name|lang_name_cplusplus
expr_stmt|;
name|strict_prototype
operator|=
name|strict_prototypes_lang_cplusplus
expr_stmt|;
name|named_labels
operator|=
name|NULL_TREE
expr_stmt|;
name|s
operator|->
name|prev
operator|=
name|current_saved_scope
expr_stmt|;
name|s
operator|->
name|old_bindings
operator|=
name|old_bindings
expr_stmt|;
name|current_saved_scope
operator|=
name|s
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pop_from_top_level
parameter_list|()
block|{
specifier|extern
name|int
name|current_lang_stacksize
decl_stmt|;
name|struct
name|saved_scope
modifier|*
name|s
init|=
name|current_saved_scope
decl_stmt|;
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|previous_class_type
condition|)
name|previous_class_type
operator|=
name|NULL_TREE
expr_stmt|;
name|current_binding_level
operator|=
name|s
operator|->
name|old_binding_level
expr_stmt|;
name|current_saved_scope
operator|=
name|s
operator|->
name|prev
expr_stmt|;
for|for
control|(
name|t
operator|=
name|s
operator|->
name|old_bindings
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|tree
name|id
init|=
name|TREE_VEC_ELT
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|id
condition|)
block|{
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|id
argument_list|)
operator|=
name|TREE_VEC_ELT
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|id
argument_list|)
operator|=
name|TREE_VEC_ELT
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|id
argument_list|)
operator|=
name|TREE_VEC_ELT
argument_list|(
name|t
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
block|}
name|current_class_name
operator|=
name|s
operator|->
name|class_name
expr_stmt|;
name|current_class_type
operator|=
name|s
operator|->
name|class_type
expr_stmt|;
name|current_class_decl
operator|=
name|s
operator|->
name|class_decl
expr_stmt|;
if|if
condition|(
name|current_class_type
condition|)
name|C_C_D
operator|=
name|CLASSTYPE_INST_VAR
argument_list|(
name|current_class_type
argument_list|)
expr_stmt|;
else|else
name|C_C_D
operator|=
name|NULL_TREE
expr_stmt|;
name|current_function_decl
operator|=
name|s
operator|->
name|function_decl
expr_stmt|;
name|class_binding_level
operator|=
name|s
operator|->
name|class_bindings
expr_stmt|;
name|previous_class_type
operator|=
name|s
operator|->
name|previous_class_type
expr_stmt|;
name|free
argument_list|(
name|current_lang_base
argument_list|)
expr_stmt|;
name|current_lang_base
operator|=
name|s
operator|->
name|lang_base
expr_stmt|;
name|current_lang_stack
operator|=
name|s
operator|->
name|lang_stack
expr_stmt|;
name|current_lang_name
operator|=
name|s
operator|->
name|lang_name
expr_stmt|;
name|current_lang_stacksize
operator|=
name|s
operator|->
name|lang_stacksize
expr_stmt|;
if|if
condition|(
name|current_lang_name
operator|==
name|lang_name_cplusplus
condition|)
name|strict_prototype
operator|=
name|strict_prototypes_lang_cplusplus
expr_stmt|;
elseif|else
if|if
condition|(
name|current_lang_name
operator|==
name|lang_name_c
condition|)
name|strict_prototype
operator|=
name|strict_prototypes_lang_c
expr_stmt|;
name|named_labels
operator|=
name|s
operator|->
name|named_labels
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Push a definition of struct, union or enum tag "name".    into binding_level "b".   "type" should be the type node,     We assume that the tag "name" is not already defined.     Note that the definition may really be just a forward reference.    In that case, the TYPE_SIZE will be a NULL_TREE.     C++ gratuitously puts all these tags in the name space. */
end_comment

begin_comment
comment|/* When setting the IDENTIFIER_TYPE_VALUE field of an identifier ID,    record the shadowed value for this binding contour.  TYPE is    the type that ID maps to.  */
end_comment

begin_function
specifier|static
name|void
name|set_identifier_type_value_with_scope
parameter_list|(
name|id
parameter_list|,
name|type
parameter_list|,
name|b
parameter_list|)
name|tree
name|id
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|struct
name|binding_level
modifier|*
name|b
decl_stmt|;
block|{
if|if
condition|(
name|b
operator|!=
name|global_binding_level
condition|)
block|{
name|tree
name|old_type_value
init|=
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|b
operator|->
name|type_shadowed
operator|=
name|tree_cons
argument_list|(
name|id
argument_list|,
name|old_type_value
argument_list|,
name|b
operator|->
name|type_shadowed
argument_list|)
expr_stmt|;
block|}
name|SET_IDENTIFIER_TYPE_VALUE
argument_list|(
name|id
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* As set_identifier_type_value_with_scope, but using inner_binding_level. */
end_comment

begin_function
name|void
name|set_identifier_type_value
parameter_list|(
name|id
parameter_list|,
name|type
parameter_list|)
name|tree
name|id
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
name|set_identifier_type_value_with_scope
argument_list|(
name|id
argument_list|,
name|type
argument_list|,
name|inner_binding_level
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Subroutine "set_nested_typename" builds the nested-typename of    the type decl in question.  (Argument CLASSNAME can actually be    a function as well, if that's the smallest containing scope.)  */
end_comment

begin_function
specifier|static
name|void
name|set_nested_typename
parameter_list|(
name|decl
parameter_list|,
name|classname
parameter_list|,
name|name
parameter_list|,
name|type
parameter_list|)
name|tree
name|decl
decl_stmt|,
name|classname
decl_stmt|,
name|name
decl_stmt|,
name|type
decl_stmt|;
block|{
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
argument_list|,
literal|136
argument_list|)
expr_stmt|;
if|if
condition|(
name|classname
operator|!=
name|NULL_TREE
condition|)
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|classname
argument_list|)
operator|==
name|IDENTIFIER_NODE
argument_list|,
literal|137
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|IDENTIFIER_NODE
argument_list|,
literal|138
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|4
operator|+
name|IDENTIFIER_LENGTH
argument_list|(
name|classname
argument_list|)
operator|+
name|IDENTIFIER_LENGTH
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s::%s"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|classname
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_NESTED_TYPENAME
argument_list|(
name|decl
argument_list|)
operator|=
name|get_identifier
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|TREE_MANGLED
argument_list|(
name|DECL_NESTED_TYPENAME
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* This is a special usage of IDENTIFIER_TYPE_VALUE which have no 	 correspondence in any binding_level.  This is ok since the 	 DECL_NESTED_TYPENAME is just a convenience identifier whose 	 IDENTIFIER_TYPE_VALUE will remain constant from now on.  */
name|SET_IDENTIFIER_TYPE_VALUE
argument_list|(
name|DECL_NESTED_TYPENAME
argument_list|(
name|decl
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
else|else
name|DECL_NESTED_TYPENAME
argument_list|(
name|decl
argument_list|)
operator|=
name|name
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pop off extraneous binding levels left over due to syntax errors.  */
end_comment

begin_function
name|void
name|pop_everything
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|DEBUG_CP_BINDING_LEVELS
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XXX entering pop_everything ()\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|current_binding_level
operator|!=
name|global_binding_level
operator|&&
operator|!
name|current_binding_level
operator|->
name|pseudo_global
condition|)
block|{
if|if
condition|(
name|class_binding_level
condition|)
name|pop_nested_class
argument_list|(
literal|1
argument_list|)
expr_stmt|;
else|else
name|poplevel
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG_CP_BINDING_LEVELS
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XXX leaving pop_everything ()\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* not yet, should get fixed properly later */
end_comment

begin_comment
comment|/* Create a TYPE_DECL node with the correct DECL_ASSEMBLER_NAME.    Other routines shouldn't use build_decl directly; they'll produce    incorrect results with `-g' unless they duplicate this code.     This is currently needed mainly for dbxout.c, but we can make    use of it in method.c later as well.  */
end_comment

begin_comment
unit|tree make_type_decl (name, type)      tree name, type; {   tree decl, id;   decl = build_decl (TYPE_DECL, name, type);   if (TYPE_NAME (type) == name)
comment|/* Class/union/enum definition, or a redundant typedef for same.  */
end_comment

begin_comment
unit|{       id = get_identifier (build_overload_name (type, 1, 1));       DECL_ASSEMBLER_NAME (decl) = id;     }   else if (TYPE_NAME (type) != NULL_TREE)
comment|/* Explicit typedef, or implicit typedef for template expansion.  */
end_comment

begin_comment
unit|DECL_ASSEMBLER_NAME (decl) = DECL_ASSEMBLER_NAME (TYPE_NAME (type));   else     {
comment|/* XXX: Typedef for unnamed struct; some other situations. 	 TYPE_NAME is null; what's right here?  */
end_comment

begin_endif
unit|}   return decl; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Push a tag name NAME for struct/class/union/enum type TYPE.    Normally put into into the inner-most non-tag-tranparent scope,    but if GLOBALIZE is true, put it in the inner-most non-class scope.    The latter is needed for implicit declarations. */
end_comment

begin_function
name|void
name|pushtag
parameter_list|(
name|name
parameter_list|,
name|type
parameter_list|,
name|globalize
parameter_list|)
name|tree
name|name
decl_stmt|,
name|type
decl_stmt|;
name|int
name|globalize
decl_stmt|;
block|{
specifier|register
name|struct
name|binding_level
modifier|*
name|b
decl_stmt|;
name|tree
name|context
init|=
literal|0
decl_stmt|;
name|tree
name|c_decl
init|=
literal|0
decl_stmt|;
name|b
operator|=
name|inner_binding_level
expr_stmt|;
while|while
condition|(
name|b
operator|->
name|tag_transparent
operator|||
operator|(
name|globalize
operator|&&
name|b
operator|->
name|parm_flag
operator|==
literal|2
operator|)
condition|)
name|b
operator|=
name|b
operator|->
name|level_chain
expr_stmt|;
if|if
condition|(
name|b
operator|==
name|global_binding_level
condition|)
name|b
operator|->
name|tags
operator|=
name|perm_tree_cons
argument_list|(
name|name
argument_list|,
name|type
argument_list|,
name|b
operator|->
name|tags
argument_list|)
expr_stmt|;
else|else
name|b
operator|->
name|tags
operator|=
name|saveable_tree_cons
argument_list|(
name|name
argument_list|,
name|type
argument_list|,
name|b
operator|->
name|tags
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
block|{
name|context
operator|=
name|type
condition|?
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
else|:
name|NULL_TREE
expr_stmt|;
if|if
condition|(
operator|!
name|context
operator|&&
operator|!
name|globalize
condition|)
name|context
operator|=
name|current_scope
argument_list|()
expr_stmt|;
if|if
condition|(
name|context
condition|)
name|c_decl
operator|=
name|TREE_CODE
argument_list|(
name|context
argument_list|)
operator|==
name|FUNCTION_DECL
condition|?
name|context
else|:
name|TYPE_NAME
argument_list|(
name|context
argument_list|)
expr_stmt|;
comment|/* Record the identifier as the type's name if it has none.  */
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|=
name|name
expr_stmt|;
comment|/* Do C++ gratuitous typedefing.  */
if|if
condition|(
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|name
argument_list|)
operator|!=
name|type
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|RECORD_TYPE
operator|||
name|b
operator|->
name|parm_flag
operator|!=
literal|2
operator|||
operator|!
name|CLASSTYPE_DECLARED_EXCEPTION
argument_list|(
name|type
argument_list|)
operator|)
condition|)
block|{
specifier|register
name|tree
name|d
decl_stmt|;
name|int
name|newdecl
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|b
operator|->
name|parm_flag
operator|!=
literal|2
operator|||
name|TYPE_SIZE
argument_list|(
name|current_class_type
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
name|d
operator|=
name|lookup_nested_type
argument_list|(
name|type
argument_list|,
name|c_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|==
name|NULL_TREE
condition|)
block|{
name|newdecl
operator|=
literal|1
expr_stmt|;
if|#
directive|if
literal|0
comment|/* not yet, should get fixed properly later */
block|d = make_type_decl (name, type);
else|#
directive|else
name|d
operator|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SET_DECL_ARTIFICIAL
argument_list|(
name|d
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DWARF_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|DWARF_DEBUG
condition|)
block|{
comment|/* Mark the TYPE_DECL node we created just above as an 			 gratuitous one.  We need to do this so that dwarfout.c 			 will understand that it is not supposed to output a 			 TAG_typedef DIE  for it. */
name|DECL_IGNORED_P
argument_list|(
name|d
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DWARF_DEBUGGING_INFO */
name|set_identifier_type_value_with_scope
argument_list|(
name|name
argument_list|,
name|type
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
else|else
name|d
operator|=
name|TYPE_NAME
argument_list|(
name|d
argument_list|)
expr_stmt|;
comment|/* If it is anonymous, then we are called from pushdecl, 		 and we don't want to infinitely recurse.  Also, if the 		 name is already in scope, we don't want to push it 		 again--pushdecl is only for pushing new decls.  */
if|if
condition|(
operator|!
name|ANON_AGGRNAME_P
argument_list|(
name|name
argument_list|)
operator|&&
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|TYPE_DECL
operator|||
name|lookup_name
argument_list|(
name|name
argument_list|,
literal|1
argument_list|)
operator|!=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|b
operator|->
name|parm_flag
operator|==
literal|2
condition|)
name|d
operator|=
name|pushdecl_class_level
argument_list|(
name|d
argument_list|)
expr_stmt|;
else|else
name|d
operator|=
name|pushdecl_with_scope
argument_list|(
name|d
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Make nested declarations go into class-level scope.  */
name|newdecl
operator|=
literal|1
expr_stmt|;
name|d
operator|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|SET_DECL_ARTIFICIAL
argument_list|(
name|d
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DWARF_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|DWARF_DEBUG
condition|)
block|{
comment|/* Mark the TYPE_DECL node we created just above as an 		     gratuitous one.  We need to do this so that dwarfout.c 		     will understand that it is not supposed to output a 		     TAG_typedef DIE  for it. */
name|DECL_IGNORED_P
argument_list|(
name|d
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DWARF_DEBUGGING_INFO */
comment|/* Make sure we're in this type's scope when we push the 		 decl for a template, otherwise class_binding_level will 		 be NULL and we'll end up dying inside of 		 push_class_level_binding.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNINSTANTIATED_P_TYPE
condition|)
name|pushclass
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|d
operator|=
name|pushdecl_class_level
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNINSTANTIATED_P_TYPE
condition|)
name|popclass
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|write_symbols
operator|!=
name|DWARF_DEBUG
condition|)
block|{
if|if
condition|(
name|ANON_AGGRNAME_P
argument_list|(
name|name
argument_list|)
condition|)
name|DECL_IGNORED_P
argument_list|(
name|d
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|=
name|d
expr_stmt|;
if|if
condition|(
name|context
operator|==
name|NULL_TREE
condition|)
comment|/* Non-nested class.  */
name|DECL_NESTED_TYPENAME
argument_list|(
name|d
argument_list|)
operator|=
name|name
expr_stmt|;
elseif|else
if|if
condition|(
name|context
operator|&&
name|TREE_CODE
argument_list|(
name|context
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
comment|/* Function-nested class.  */
name|set_nested_typename
argument_list|(
name|d
argument_list|,
name|DECL_ASSEMBLER_NAME
argument_list|(
name|c_decl
argument_list|)
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* This builds the links for classes nested in fn scope.  */
name|DECL_CONTEXT
argument_list|(
name|d
argument_list|)
operator|=
name|context
expr_stmt|;
block|}
comment|/*        else if (TYPE_SIZE (current_class_type) == NULL_TREE) */
elseif|else
if|if
condition|(
name|context
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|context
argument_list|)
condition|)
block|{
comment|/* Class-nested class.  */
name|set_nested_typename
argument_list|(
name|d
argument_list|,
name|DECL_NESTED_TYPENAME
argument_list|(
name|c_decl
argument_list|)
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* This builds the links for classes nested in type scope.  */
name|DECL_CONTEXT
argument_list|(
name|d
argument_list|)
operator|=
name|context
expr_stmt|;
block|}
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
operator|=
name|DECL_CONTEXT
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|newdecl
condition|)
name|DECL_ASSEMBLER_NAME
argument_list|(
name|d
argument_list|)
operator|=
name|get_identifier
argument_list|(
name|build_overload_name
argument_list|(
name|type
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|b
operator|->
name|parm_flag
operator|==
literal|2
condition|)
block|{
name|TREE_NONLOCAL_FLAG
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|current_class_type
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|CLASSTYPE_TAGS
argument_list|(
name|current_class_type
argument_list|)
operator|=
name|b
operator|->
name|tags
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
condition|)
comment|/* Use the canonical TYPE_DECL for this node.  */
name|TYPE_STUB_DECL
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Create a fake NULL-named TYPE_DECL node whose TREE_TYPE 	 will be the tagged type we just added to the current 	 binding level.  This fake NULL-named TYPE_DECL node helps 	 dwarfout.c to know when it needs to output a 	 representation of a tagged type, and it also gives us a 	 convenient place to record the "scope start" address for 	 the tagged type.  */
if|#
directive|if
literal|0
comment|/* not yet, should get fixed properly later */
block|tree d = make_type_decl (NULL_TREE, type);
else|#
directive|else
name|tree
name|d
init|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|type
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|TYPE_STUB_DECL
argument_list|(
name|type
argument_list|)
operator|=
name|pushdecl_with_scope
argument_list|(
name|d
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Counter used to create anonymous type names.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|anon_cnt
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return an IDENTIFIER which can be used as a name for    anonymous structs and unions.  */
end_comment

begin_function
name|tree
name|make_anon_name
parameter_list|()
block|{
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
name|ANON_AGGRNAME_FORMAT
argument_list|,
name|anon_cnt
operator|++
argument_list|)
expr_stmt|;
return|return
name|get_identifier
argument_list|(
name|buf
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Clear the TREE_PURPOSE slot of tags which have anonymous typenames.    This keeps dbxout from getting confused.  */
end_comment

begin_function
name|void
name|clear_anon_tags
parameter_list|()
block|{
specifier|register
name|struct
name|binding_level
modifier|*
name|b
decl_stmt|;
specifier|register
name|tree
name|tags
decl_stmt|;
specifier|static
name|int
name|last_cnt
init|=
literal|0
decl_stmt|;
comment|/* Fast out if no new anon names were declared.  */
if|if
condition|(
name|last_cnt
operator|==
name|anon_cnt
condition|)
return|return;
name|b
operator|=
name|current_binding_level
expr_stmt|;
while|while
condition|(
name|b
operator|->
name|tag_transparent
condition|)
name|b
operator|=
name|b
operator|->
name|level_chain
expr_stmt|;
name|tags
operator|=
name|b
operator|->
name|tags
expr_stmt|;
while|while
condition|(
name|tags
condition|)
block|{
comment|/* A NULL purpose means we have already processed all tags 	 from here to the end of the list.  */
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|tags
argument_list|)
operator|==
name|NULL_TREE
condition|)
break|break;
if|if
condition|(
name|ANON_AGGRNAME_P
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tags
argument_list|)
argument_list|)
condition|)
name|TREE_PURPOSE
argument_list|(
name|tags
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|tags
operator|=
name|TREE_CHAIN
argument_list|(
name|tags
argument_list|)
expr_stmt|;
block|}
name|last_cnt
operator|=
name|anon_cnt
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutine of duplicate_decls: return truthvalue of whether    or not types of these decls match.     For C++, we must compare the parameter list so that `int' can match    `int&' in a parameter position, but `int&' is not confused with    `const int&'.  */
end_comment

begin_function
specifier|static
name|int
name|decls_match
parameter_list|(
name|newdecl
parameter_list|,
name|olddecl
parameter_list|)
name|tree
name|newdecl
decl_stmt|,
name|olddecl
decl_stmt|;
block|{
name|int
name|types_match
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|tree
name|f1
init|=
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
decl_stmt|;
name|tree
name|f2
init|=
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
decl_stmt|;
name|tree
name|p1
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|f1
argument_list|)
decl_stmt|;
name|tree
name|p2
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|f2
argument_list|)
decl_stmt|;
comment|/* When we parse a static member function definition, 	 we put together a FUNCTION_DECL which thinks its type 	 is METHOD_TYPE.  Change that to FUNCTION_TYPE, and 	 proceed.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|f1
argument_list|)
operator|==
name|METHOD_TYPE
operator|&&
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|olddecl
argument_list|)
condition|)
name|revert_static_member_fn
argument_list|(
operator|&
name|newdecl
argument_list|,
operator|&
name|f1
argument_list|,
operator|&
name|p1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|f2
argument_list|)
operator|==
name|METHOD_TYPE
operator|&&
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|newdecl
argument_list|)
condition|)
name|revert_static_member_fn
argument_list|(
operator|&
name|olddecl
argument_list|,
operator|&
name|f2
argument_list|,
operator|&
name|p2
argument_list|)
expr_stmt|;
comment|/* Here we must take care of the case where new default 	 parameters are specified.  Also, warn if an old 	 declaration becomes ambiguous because default 	 parameters may cause the two to be ambiguous.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|f1
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|f2
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|f1
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
name|cp_compiler_error
argument_list|(
literal|"`%D' redeclared as member function"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
else|else
name|cp_compiler_error
argument_list|(
literal|"`%D' redeclared as non-member function"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|f1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|f2
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|strict_prototypes_lang_c
operator|&&
name|DECL_LANGUAGE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|lang_c
operator|&&
name|p2
operator|==
name|NULL_TREE
condition|)
block|{
name|types_match
operator|=
name|self_promoting_args_p
argument_list|(
name|p1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
operator|==
name|void_list_node
condition|)
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strict_prototypes_lang_c
operator|&&
name|DECL_LANGUAGE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|lang_c
operator|&&
name|DECL_LANGUAGE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|lang_c
operator|&&
name|p1
operator|==
name|NULL_TREE
condition|)
block|{
name|types_match
operator|=
name|self_promoting_args_p
argument_list|(
name|p2
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
block|}
else|else
name|types_match
operator|=
name|compparms
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
else|else
name|types_match
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|TEMPLATE_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
name|tree
name|newargs
init|=
name|DECL_TEMPLATE_PARMS
argument_list|(
name|newdecl
argument_list|)
decl_stmt|;
name|tree
name|oldargs
init|=
name|DECL_TEMPLATE_PARMS
argument_list|(
name|olddecl
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|newargs
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_VEC_LENGTH
argument_list|(
name|oldargs
argument_list|)
operator|!=
name|len
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|newarg
init|=
name|TREE_VALUE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|newargs
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|oldarg
init|=
name|TREE_VALUE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|oldargs
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newarg
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|oldarg
argument_list|)
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newarg
argument_list|)
operator|==
name|TYPE_DECL
condition|)
comment|/* continue */
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|newarg
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|oldarg
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|DECL_TEMPLATE_IS_CLASS
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|DECL_TEMPLATE_IS_CLASS
argument_list|(
name|olddecl
argument_list|)
condition|)
name|types_match
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_TEMPLATE_IS_CLASS
argument_list|(
name|newdecl
argument_list|)
condition|)
name|types_match
operator|=
literal|1
expr_stmt|;
else|else
name|types_match
operator|=
name|decls_match
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|olddecl
argument_list|)
argument_list|,
name|DECL_TEMPLATE_RESULT
argument_list|(
name|newdecl
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|error_mark_node
condition|)
name|types_match
operator|=
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|error_mark_node
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|types_match
operator|=
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|NULL_TREE
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|types_match
operator|=
literal|0
expr_stmt|;
else|else
name|types_match
operator|=
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|types_match
return|;
block|}
end_function

begin_comment
comment|/* If NEWDECL is `static' and an `extern' was seen previously,    warn about it.  (OLDDECL may be NULL_TREE; NAME contains    information about previous usage as an `extern'.)     Note that this does not apply to the C++ case of declaring    a variable `extern const' and then later `const'.     Don't complain if -traditional, since traditional compilers    don't complain.     Don't complain about built-in functions, since they are beyond    the user's control.  */
end_comment

begin_function
specifier|static
name|void
name|warn_extern_redeclared_static
parameter_list|(
name|newdecl
parameter_list|,
name|olddecl
parameter_list|)
name|tree
name|newdecl
decl_stmt|,
name|olddecl
decl_stmt|;
block|{
name|tree
name|name
decl_stmt|;
specifier|static
name|char
modifier|*
name|explicit_extern_static_warning
init|=
literal|"`%D' was declared `extern' and later `static'"
decl_stmt|;
specifier|static
name|char
modifier|*
name|implicit_extern_static_warning
init|=
literal|"`%D' was declared implicitly `extern' and later `static'"
decl_stmt|;
if|if
condition|(
name|flag_traditional
operator|||
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|TYPE_DECL
operator|||
operator|(
operator|!
name|warn_extern_inline
operator|&&
name|DECL_INLINE
argument_list|(
name|newdecl
argument_list|)
operator|)
condition|)
return|return;
name|name
operator|=
name|DECL_ASSEMBLER_NAME
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|name
argument_list|)
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
comment|/* It's okay to redeclare an ANSI built-in function as static, 	 or to declare a non-ANSI built-in function as anything.  */
if|if
condition|(
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|olddecl
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|(
name|DECL_BUILT_IN
argument_list|(
name|olddecl
argument_list|)
operator|||
name|DECL_BUILT_IN_NONANSI
argument_list|(
name|olddecl
argument_list|)
operator|)
operator|)
condition|)
block|{
name|cp_warning
argument_list|(
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|name
argument_list|)
condition|?
name|implicit_extern_static_warning
else|:
name|explicit_extern_static_warning
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|olddecl
operator|!=
name|NULL_TREE
condition|)
name|cp_warning_at
argument_list|(
literal|"previous declaration of `%D'"
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Handle when a new declaration NEWDECL has the same name as an old    one OLDDECL in the same binding contour.  Prints an error message    if appropriate.     If safely possible, alter OLDDECL to look like NEWDECL, and return 1.    Otherwise, return 0.  */
end_comment

begin_function
name|int
name|duplicate_decls
parameter_list|(
name|newdecl
parameter_list|,
name|olddecl
parameter_list|)
specifier|register
name|tree
name|newdecl
decl_stmt|,
name|olddecl
decl_stmt|;
block|{
specifier|extern
name|struct
name|obstack
name|permanent_obstack
decl_stmt|;
name|unsigned
name|olddecl_uid
init|=
name|DECL_UID
argument_list|(
name|olddecl
argument_list|)
decl_stmt|;
name|int
name|olddecl_friend
init|=
literal|0
decl_stmt|,
name|types_match
init|=
literal|0
decl_stmt|;
name|int
name|new_defines_function
decl_stmt|;
name|tree
name|previous_c_decl
init|=
name|NULL_TREE
decl_stmt|;
name|types_match
operator|=
name|decls_match
argument_list|(
name|newdecl
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|!=
name|TREE_LIST
condition|)
name|olddecl_friend
operator|=
name|DECL_LANG_SPECIFIC
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|DECL_FRIEND_P
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
comment|/* If either the type of the new decl or the type of the old decl is an      error_mark_node, then that implies that we have already issued an      error (earlier) for some bogus type specification, and in that case,      it is rather pointless to harass the user with yet more error message      about the same declaration, so well just pretent the types match here.  */
if|if
condition|(
operator|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
operator|==
name|ERROR_MARK
operator|)
operator|||
operator|(
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
operator|==
name|ERROR_MARK
operator|)
condition|)
name|types_match
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|flag_traditional
operator|&&
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|newdecl
argument_list|)
argument_list|)
operator|==
name|olddecl
condition|)
comment|/* If -traditional, avoid error for redeclaring fcn        after implicit decl.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|(
name|DECL_BUILT_IN
argument_list|(
name|olddecl
argument_list|)
operator|||
name|DECL_BUILT_IN_NONANSI
argument_list|(
name|olddecl
argument_list|)
operator|)
condition|)
block|{
comment|/* If you declare a built-in or predefined function name as static, 	 the old definition is overridden, but optionally warn this was a 	 bad choice of name.  Ditto for overloads.  */
if|if
condition|(
operator|!
name|TREE_PUBLIC
argument_list|(
name|newdecl
argument_list|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_LANGUAGE
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|DECL_LANGUAGE
argument_list|(
name|olddecl
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|warn_shadow
condition|)
name|cp_warning
argument_list|(
literal|"shadowing %s function `%#D'"
argument_list|,
name|DECL_BUILT_IN
argument_list|(
name|olddecl
argument_list|)
condition|?
literal|"built-in"
else|:
literal|"library"
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
comment|/* Discard the old built-in function.  */
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|types_match
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
block|{
comment|/* If the built-in is not ansi, then programs can override 		 it even globally without an error.  */
if|if
condition|(
operator|!
name|DECL_BUILT_IN
argument_list|(
name|olddecl
argument_list|)
condition|)
name|cp_warning
argument_list|(
literal|"library function `%#D' redeclared as non-function `%#D'"
argument_list|,
name|olddecl
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
else|else
block|{
name|cp_error
argument_list|(
literal|"declaration of `%#D'"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|cp_error
argument_list|(
literal|"conflicts with built-in declaration `%#D'"
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
name|cp_warning
argument_list|(
literal|"declaration of `%#D'"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|cp_warning
argument_list|(
literal|"conflicts with built-in declaration `%#D'"
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|TEMPLATE_DECL
operator|&&
operator|!
name|DECL_TEMPLATE_IS_CLASS
argument_list|(
name|olddecl
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|TEMPLATE_DECL
operator|&&
operator|!
name|DECL_TEMPLATE_IS_CLASS
argument_list|(
name|newdecl
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
name|cp_error
argument_list|(
literal|"`%#D' redeclared as different kind of symbol"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|olddecl
operator|=
name|TREE_VALUE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"previous declaration of `%#D'"
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
comment|/* New decl is completely inconsistent with the old one => 	 tell caller to replace the old one.  */
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|types_match
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
comment|/* The name of a class template may not be declared to refer to 	     any other template, class, function, object, namespace, value, 	     or type in the same scope. */
if|if
condition|(
name|DECL_TEMPLATE_IS_CLASS
argument_list|(
name|olddecl
argument_list|)
operator|||
name|DECL_TEMPLATE_IS_CLASS
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"declaration of template `%#D'"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"conflicts with previous declaration `%#D'"
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
if|if
condition|(
name|DECL_LANGUAGE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|lang_c
operator|&&
name|DECL_LANGUAGE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|lang_c
condition|)
block|{
name|cp_error
argument_list|(
literal|"declaration of C function `%#D' conflicts with"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"previous declaration `%#D' here"
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|compparms
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"new declaration `%#D'"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"ambiguates old declaration `%#D'"
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
block|}
if|if
condition|(
name|olddecl
operator|==
name|wchar_decl_node
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|newdecl
argument_list|)
condition|)
name|cp_pedwarn
argument_list|(
literal|"redeclaration of wchar_t as `%T'"
argument_list|,
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Throw away the redeclaration.  */
return|return
literal|1
return|;
block|}
comment|/* Already complained about this, so don't do so again.  */
elseif|else
if|if
condition|(
name|current_class_type
operator|==
name|NULL_TREE
operator|||
name|IDENTIFIER_ERROR_LOCUS
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|newdecl
argument_list|)
argument_list|)
operator|!=
name|current_class_type
condition|)
block|{
name|cp_error
argument_list|(
literal|"conflicting types for `%#D'"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"previous declaration as `%#D'"
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|char
modifier|*
name|errmsg
init|=
name|redeclaration_error_message
argument_list|(
name|newdecl
argument_list|,
name|olddecl
argument_list|)
decl_stmt|;
if|if
condition|(
name|errmsg
condition|)
block|{
name|cp_error
argument_list|(
name|errmsg
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|olddecl
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|cp_error_at
argument_list|(
operator|(
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|current_binding_level
operator|==
name|global_binding_level
operator|)
condition|?
literal|"`%#D' previously defined here"
else|:
literal|"`%#D' previously declared here"
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
comment|/* Prototype decl follows defn w/o prototype.  */
name|cp_warning_at
argument_list|(
literal|"prototype for `%#D'"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|cp_warning_at
argument_list|(
literal|"follows non-prototype definition here"
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_LANGUAGE
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|DECL_LANGUAGE
argument_list|(
name|olddecl
argument_list|)
condition|)
block|{
comment|/* extern "C" int foo (); 	     int foo () { bar (); } 	     is OK.  */
if|if
condition|(
name|current_lang_stack
operator|==
name|current_lang_base
condition|)
name|DECL_LANGUAGE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_LANGUAGE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
else|else
block|{
name|cp_error_at
argument_list|(
literal|"previous declaration of `%#D' with %L linkage"
argument_list|,
name|olddecl
argument_list|,
name|DECL_LANGUAGE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
expr_stmt|;
name|cp_error
argument_list|(
literal|"conflicts with new declaration with %L linkage"
argument_list|,
name|DECL_LANGUAGE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* These bits are logically part of the type.  */
if|if
condition|(
name|pedantic
operator|&&
operator|(
name|TREE_READONLY
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|TREE_READONLY
argument_list|(
name|olddecl
argument_list|)
operator|||
name|TREE_THIS_VOLATILE
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|TREE_THIS_VOLATILE
argument_list|(
name|olddecl
argument_list|)
operator|)
condition|)
name|cp_error_at
argument_list|(
literal|"type qualifiers for `%D' conflict with previous decl"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
block|}
comment|/* If new decl is `static' and an `extern' was seen previously,      warn about it.  */
name|warn_extern_redeclared_static
argument_list|(
name|newdecl
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
comment|/* We have committed to returning 1 at this point. */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
comment|/* Now that functions must hold information normally held 	 by field decls, there is extra work to do so that 	 declaration information does not get destroyed during 	 definition.  */
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|olddecl
argument_list|)
condition|)
name|DECL_VINDEX
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_VINDEX
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|olddecl
argument_list|)
condition|)
name|DECL_CONTEXT
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_CONTEXT
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_CLASS_CONTEXT
argument_list|(
name|olddecl
argument_list|)
condition|)
name|DECL_CLASS_CONTEXT
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_CLASS_CONTEXT
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_CHAIN
argument_list|(
name|newdecl
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|DECL_CHAIN
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_CHAIN
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NEXT_METHOD
argument_list|(
name|newdecl
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|DECL_NEXT_METHOD
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_NEXT_METHOD
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_PENDING_INLINE_INFO
argument_list|(
name|newdecl
argument_list|)
operator|==
operator|(
expr|struct
name|pending_inline
operator|*
operator|)
literal|0
condition|)
name|DECL_PENDING_INLINE_INFO
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_PENDING_INLINE_INFO
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
block|}
comment|/* Deal with C++: must preserve virtual function table size.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
specifier|register
name|tree
name|newtype
init|=
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|oldtype
init|=
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
decl_stmt|;
if|if
condition|(
name|newtype
operator|!=
name|error_mark_node
operator|&&
name|oldtype
operator|!=
name|error_mark_node
operator|&&
name|TYPE_LANG_SPECIFIC
argument_list|(
name|newtype
argument_list|)
operator|&&
name|TYPE_LANG_SPECIFIC
argument_list|(
name|oldtype
argument_list|)
condition|)
block|{
name|CLASSTYPE_VSIZE
argument_list|(
name|newtype
argument_list|)
operator|=
name|CLASSTYPE_VSIZE
argument_list|(
name|oldtype
argument_list|)
expr_stmt|;
name|CLASSTYPE_FRIEND_CLASSES
argument_list|(
name|newtype
argument_list|)
operator|=
name|CLASSTYPE_FRIEND_CLASSES
argument_list|(
name|oldtype
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* why assert here?  Just because debugging information is 	 messed up? (mrs) */
comment|/* it happens on something like: 	 	typedef struct Thing {                 	Thing(); 		        int     x; 		} Thing;       */
block|my_friendly_assert (DECL_IGNORED_P (olddecl) == DECL_IGNORED_P (newdecl), 			  139);
endif|#
directive|endif
block|}
comment|/* Special handling ensues if new decl is a function definition.  */
name|new_defines_function
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|NULL_TREE
operator|)
expr_stmt|;
comment|/* Optionally warn about more than one declaration for the same name,      but don't warn about a function declaration followed by a definition.  */
if|if
condition|(
name|warn_redundant_decls
operator|&&
operator|!
name|DECL_ARTIFICIAL
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|!
operator|(
name|new_defines_function
operator|&&
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
operator|==
name|NULL_TREE
operator|)
comment|/* Don't warn about extern decl followed by (tentative) definition.  */
operator|&&
operator|!
operator|(
name|DECL_EXTERNAL
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|newdecl
argument_list|)
operator|)
condition|)
block|{
name|cp_warning
argument_list|(
literal|"redundant redeclaration of `%D' in same scope"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|cp_warning
argument_list|(
literal|"previous declaration of `%D'"
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
block|}
comment|/* Copy all the DECL_... slots specified in the new decl      except for any that we copy here from the old type.  */
if|if
condition|(
name|types_match
condition|)
block|{
comment|/* Automatically handles default parameters.  */
name|tree
name|oldtype
init|=
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
decl_stmt|;
comment|/* Merge the data types specified in the two decls.  */
name|tree
name|newtype
init|=
name|common_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Make sure we put the new type in the same obstack as the old ones. 	 If the old types are not both in the same obstack, use the permanent 	 one.  */
if|if
condition|(
name|oldtype
operator|&&
name|TYPE_OBSTACK
argument_list|(
name|oldtype
argument_list|)
operator|==
name|TYPE_OBSTACK
argument_list|(
name|newtype
argument_list|)
condition|)
name|push_obstacks
argument_list|(
name|TYPE_OBSTACK
argument_list|(
name|oldtype
argument_list|)
argument_list|,
name|TYPE_OBSTACK
argument_list|(
name|oldtype
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|end_temporary_allocation
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|DECL_THIS_EXTERN
argument_list|(
name|newdecl
argument_list|)
operator||=
name|DECL_THIS_EXTERN
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
comment|/* Do this after calling `common_type' so that default 	 parameters don't confuse us.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|(
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
operator|!=
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|tree
name|ctype
init|=
name|NULL_TREE
decl_stmt|;
name|ctype
operator|=
name|DECL_CLASS_CONTEXT
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|build_exception_variant
argument_list|(
name|ctype
argument_list|,
name|newtype
argument_list|,
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
operator|=
name|build_exception_variant
argument_list|(
name|ctype
argument_list|,
name|newtype
argument_list|,
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|oldtype
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|compexcepttypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"declaration of `%D' raises different exceptions..."
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"...from previous declaration here"
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
block|}
block|}
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
operator|=
name|newtype
expr_stmt|;
comment|/* Lay the type out, unless already done.  */
if|if
condition|(
name|oldtype
operator|!=
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|error_mark_node
condition|)
name|layout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|TYPE_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|CONST_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|TEMPLATE_DECL
condition|)
name|layout_decl
argument_list|(
name|newdecl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Since the type is OLDDECL's, make OLDDECL's size go with.  */
name|DECL_SIZE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_SIZE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
block|}
comment|/* Merge the type qualifiers.  */
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|newdecl
argument_list|)
condition|)
name|TREE_READONLY
argument_list|(
name|olddecl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|newdecl
argument_list|)
condition|)
name|TREE_THIS_VOLATILE
argument_list|(
name|olddecl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Merge the initialization information.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_SOURCE_FILE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_SOURCE_FILE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_SOURCE_LINE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_SOURCE_LINE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
block|}
comment|/* Merge the section attribute.          We want to issue an error if the sections conflict but that must be 	 done later in decl_attributes since we are called before attributes 	 are assigned.  */
if|if
condition|(
name|DECL_SECTION_NAME
argument_list|(
name|newdecl
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|DECL_SECTION_NAME
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_SECTION_NAME
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
comment|/* Keep the old rtl since we can safely use it, unless it's the 	 call to abort() used for abstract virtuals.  */
if|if
condition|(
operator|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|!
name|DECL_ABSTRACT_VIRTUAL_P
argument_list|(
name|olddecl
argument_list|)
operator|)
operator|||
name|DECL_RTL
argument_list|(
name|olddecl
argument_list|)
operator|!=
name|DECL_RTL
argument_list|(
name|abort_fndecl
argument_list|)
condition|)
name|DECL_RTL
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_RTL
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
comment|/* If cannot merge, then use the new type and qualifiers,      and don't preserve the old rtl.  */
else|else
block|{
comment|/* Clean out any memory we had of the old declaration.  */
name|tree
name|oldstatic
init|=
name|value_member
argument_list|(
name|olddecl
argument_list|,
name|static_aggregates
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldstatic
condition|)
name|TREE_VALUE
argument_list|(
name|oldstatic
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|olddecl
argument_list|)
operator|=
name|TREE_READONLY
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|olddecl
argument_list|)
operator|=
name|TREE_THIS_VOLATILE
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|olddecl
argument_list|)
operator|=
name|TREE_SIDE_EFFECTS
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
block|}
comment|/* Merge the storage class information.  */
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
name|TREE_STATIC
argument_list|(
name|newdecl
argument_list|)
operator|=
name|TREE_STATIC
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_EXTERNAL
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
name|TREE_PUBLIC
argument_list|(
name|newdecl
argument_list|)
operator|=
name|TREE_PUBLIC
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TREE_STATIC
argument_list|(
name|olddecl
argument_list|)
operator|=
name|TREE_STATIC
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
comment|/* A `const' which was not declared `extern' and is 	 in static storage is invisible.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_READONLY
argument_list|(
name|newdecl
argument_list|)
operator|&&
name|TREE_STATIC
argument_list|(
name|newdecl
argument_list|)
operator|&&
operator|!
name|DECL_THIS_EXTERN
argument_list|(
name|newdecl
argument_list|)
condition|)
name|TREE_PUBLIC
argument_list|(
name|newdecl
argument_list|)
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
name|TREE_PUBLIC
argument_list|(
name|olddecl
argument_list|)
operator|=
name|TREE_PUBLIC
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
block|}
comment|/* For functions, static overrides non-static.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|TREE_PUBLIC
argument_list|(
name|newdecl
argument_list|)
operator|&=
name|TREE_PUBLIC
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
comment|/* This is since we don't automatically 	 copy the attributes of NEWDECL into OLDDECL.  */
name|TREE_PUBLIC
argument_list|(
name|olddecl
argument_list|)
operator|=
name|TREE_PUBLIC
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
comment|/* If this clears `static', clear it in the identifier too.  */
if|if
condition|(
operator|!
name|TREE_PUBLIC
argument_list|(
name|olddecl
argument_list|)
condition|)
name|TREE_PUBLIC
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|olddecl
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If either decl says `inline', this fn is inline,      unless its definition was passed already.  */
if|if
condition|(
name|DECL_INLINE
argument_list|(
name|newdecl
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|DECL_INLINE
argument_list|(
name|olddecl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_INLINE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_INLINE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
if|if
condition|(
operator|!
name|types_match
condition|)
block|{
name|DECL_LANGUAGE
argument_list|(
name|olddecl
argument_list|)
operator|=
name|DECL_LANGUAGE
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
name|DECL_ASSEMBLER_NAME
argument_list|(
name|olddecl
argument_list|)
operator|=
name|DECL_ASSEMBLER_NAME
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
name|DECL_ARGUMENTS
argument_list|(
name|olddecl
argument_list|)
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
name|DECL_RESULT
argument_list|(
name|olddecl
argument_list|)
operator|=
name|DECL_RESULT
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
name|DECL_RTL
argument_list|(
name|olddecl
argument_list|)
operator|=
name|DECL_RTL
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|new_defines_function
condition|)
comment|/* If defining a function declared with other language 	   linkage, use the previously declared language linkage.  */
name|DECL_LANGUAGE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_LANGUAGE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* If redeclaring a builtin function, and not a definition, 	     it stays built in.  */
if|if
condition|(
name|DECL_BUILT_IN
argument_list|(
name|olddecl
argument_list|)
condition|)
block|{
name|DECL_BUILT_IN
argument_list|(
name|newdecl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_FUNCTION_CODE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_FUNCTION_CODE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
comment|/* If we're keeping the built-in definition, keep the rtl, 		 regardless of declaration matches.  */
name|DECL_RTL
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_RTL
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
block|}
else|else
name|DECL_FRAME_SIZE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_FRAME_SIZE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_RESULT
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_RESULT
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|DECL_SAVED_INSNS
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_SAVED_INSNS
argument_list|(
name|olddecl
argument_list|)
operator|)
condition|)
comment|/* Previously saved insns go together with 	       the function's previous definition.  */
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
comment|/* Don't clear out the arguments if we're redefining a function.  */
if|if
condition|(
name|DECL_ARGUMENTS
argument_list|(
name|olddecl
argument_list|)
condition|)
name|DECL_ARGUMENTS
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
if|if
condition|(
name|DECL_TEMPLATE_INFO
argument_list|(
name|olddecl
argument_list|)
operator|->
name|length
condition|)
name|DECL_TEMPLATE_INFO
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_TEMPLATE_INFO
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_TEMPLATE_MEMBERS
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_TEMPLATE_MEMBERS
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_TEMPLATE_INSTANTIATIONS
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_TEMPLATE_INSTANTIATIONS
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_CHAIN
argument_list|(
name|newdecl
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|DECL_CHAIN
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_CHAIN
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
block|}
comment|/* Now preserve various other info from the definition.  */
name|TREE_ADDRESSABLE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|TREE_ADDRESSABLE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|TREE_ASM_WRITTEN
argument_list|(
name|newdecl
argument_list|)
operator|=
name|TREE_ASM_WRITTEN
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_COMMON
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_COMMON
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_ASSEMBLER_NAME
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_ASSEMBLER_NAME
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
comment|/* Don't really know how much of the language-specific      values we should copy from old to new.  */
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|olddecl
argument_list|)
condition|)
block|{
name|DECL_IN_AGGR_P
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_IN_AGGR_P
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_ACCESS
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_ACCESS
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|int
name|function_size
decl_stmt|;
name|struct
name|lang_decl
modifier|*
name|ol
init|=
name|DECL_LANG_SPECIFIC
argument_list|(
name|olddecl
argument_list|)
decl_stmt|;
name|struct
name|lang_decl
modifier|*
name|nl
init|=
name|DECL_LANG_SPECIFIC
argument_list|(
name|newdecl
argument_list|)
decl_stmt|;
name|function_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|tree_decl
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|newdecl
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tree_common
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|olddecl
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tree_common
argument_list|)
argument_list|,
name|function_size
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|tree_common
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Can we safely free the storage used by newdecl?  */
define|#
directive|define
name|ROUND
parameter_list|(
name|x
parameter_list|)
value|((x + obstack_alignment_mask (&permanent_obstack)) \& ~ obstack_alignment_mask (&permanent_obstack))
if|if
condition|(
operator|(
name|char
operator|*
operator|)
name|newdecl
operator|+
name|ROUND
argument_list|(
name|function_size
argument_list|)
operator|+
name|ROUND
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|lang_decl
argument_list|)
argument_list|)
operator|==
name|obstack_next_free
argument_list|(
operator|&
name|permanent_obstack
argument_list|)
condition|)
block|{
name|DECL_MAIN_VARIANT
argument_list|(
name|newdecl
argument_list|)
operator|=
name|olddecl
expr_stmt|;
name|DECL_LANG_SPECIFIC
argument_list|(
name|olddecl
argument_list|)
operator|=
name|ol
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|nl
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ol
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lang_decl
argument_list|)
argument_list|)
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|LANG_DECL_PERMANENT
argument_list|(
name|ol
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_MAIN_VARIANT
argument_list|(
name|olddecl
argument_list|)
operator|==
name|olddecl
condition|)
block|{
comment|/* Save these lang_decls that would otherwise be lost.  */
specifier|extern
name|tree
name|free_lang_decl_chain
decl_stmt|;
name|tree
name|free_lang_decl
init|=
operator|(
name|tree
operator|)
name|ol
decl_stmt|;
name|TREE_CHAIN
argument_list|(
name|free_lang_decl
argument_list|)
operator|=
name|free_lang_decl_chain
expr_stmt|;
name|free_lang_decl_chain
operator|=
name|free_lang_decl
expr_stmt|;
block|}
else|else
block|{
comment|/* Storage leak.  */
block|}
block|}
block|}
else|else
block|{
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|newdecl
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tree_common
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|olddecl
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tree_common
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tree_decl
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|tree_common
argument_list|)
operator|+
name|tree_code_length
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
index|]
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|DECL_UID
argument_list|(
name|olddecl
argument_list|)
operator|=
name|olddecl_uid
expr_stmt|;
if|if
condition|(
name|olddecl_friend
condition|)
name|DECL_FRIEND_P
argument_list|(
name|olddecl
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Record a decl-node X as belonging to the current lexical scope.    Check for errors (such as an incompatible declaration for the same    name already seen in the same scope).     Returns either X or an old decl for the same name.    If an old decl is returned, it may have been smashed    to agree with what X says.  */
end_comment

begin_function
name|tree
name|pushdecl
parameter_list|(
name|x
parameter_list|)
name|tree
name|x
decl_stmt|;
block|{
specifier|register
name|tree
name|t
decl_stmt|;
if|#
directive|if
literal|0
comment|/* not yet, should get fixed properly later */
block|register tree name;
else|#
directive|else
specifier|register
name|tree
name|name
init|=
name|DECL_ASSEMBLER_NAME
argument_list|(
name|x
argument_list|)
decl_stmt|;
endif|#
directive|endif
specifier|register
name|struct
name|binding_level
modifier|*
name|b
init|=
name|current_binding_level
decl_stmt|;
if|#
directive|if
literal|0
block|static int nglobals; int len;    len = list_length (global_binding_level->names);   if (len< nglobals)     my_friendly_abort (8);   else if (len> nglobals)     nglobals = len;
endif|#
directive|endif
if|if
condition|(
name|x
operator|!=
name|current_function_decl
comment|/* Don't change DECL_CONTEXT of virtual methods.  */
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|||
operator|!
name|DECL_VIRTUAL_P
argument_list|(
name|x
argument_list|)
operator|)
operator|&&
operator|!
name|DECL_CONTEXT
argument_list|(
name|x
argument_list|)
condition|)
name|DECL_CONTEXT
argument_list|(
name|x
argument_list|)
operator|=
name|current_function_decl
expr_stmt|;
comment|/* A local declaration for a function doesn't constitute nesting.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|==
literal|0
condition|)
name|DECL_CONTEXT
argument_list|(
name|x
argument_list|)
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
comment|/* not yet, should get fixed properly later */
comment|/* For functions and class static data, we currently look up the encoded      form of the name.  For types, we want the real name.  The former will      probably be changed soon, according to MDT.  */
block|if (TREE_CODE (x) == FUNCTION_DECL || TREE_CODE (x) == VAR_DECL)     name = DECL_ASSEMBLER_NAME (x);   else     name = DECL_NAME (x);
else|#
directive|else
comment|/* Type are looked up using the DECL_NAME, as that is what the rest of the      compiler wants to use. */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|name
operator|=
name|DECL_NAME
argument_list|(
name|x
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|name
condition|)
block|{
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
name|t
operator|=
name|lookup_name_current_level
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|error_mark_node
condition|)
block|{
comment|/* error_mark_node is 0 for a while during initialization!  */
name|t
operator|=
name|NULL_TREE
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"`%#D' used prior to declaration"
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|!=
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|PARM_DECL
condition|)
block|{
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|fatal
argument_list|(
literal|"parse errors have confused me too much"
argument_list|)
expr_stmt|;
block|}
name|file
operator|=
name|DECL_SOURCE_FILE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|line
operator|=
name|DECL_SOURCE_LINE
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_LANGUAGE
argument_list|(
name|x
argument_list|)
operator|==
name|lang_c
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TEMPLATE_DECL
operator|&&
operator|!
name|DECL_TEMPLATE_IS_CLASS
argument_list|(
name|x
argument_list|)
operator|)
operator|)
operator|&&
name|is_overloaded_fn
argument_list|(
name|t
argument_list|)
condition|)
comment|/* don't do anything just yet */
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|t
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|x
argument_list|)
operator|)
condition|)
block|{
comment|/* We do nothing special here, because C++ does such nasty 		     things with TYPE_DECLs.  Instead, just let the TYPE_DECL 		     get shadowed, and know that if we need to find a TYPE_DECL 		     for a given name, we can look in the IDENTIFIER_TYPE_VALUE 		     slot of the identifier.  */
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|duplicate_decls
argument_list|(
name|x
argument_list|,
name|t
argument_list|)
condition|)
return|return
name|t
return|;
block|}
elseif|else
if|if
condition|(
name|duplicate_decls
argument_list|(
name|x
argument_list|,
name|t
argument_list|)
condition|)
block|{
if|#
directive|if
literal|0
comment|/* This is turned off until I have time to do it right (bpk).  */
comment|/* Also warn if they did a prototype with `static' on it, but 		 then later left the `static' off.  */
block|if (! TREE_PUBLIC (name)&& TREE_PUBLIC (x)) 		{ 		  if (DECL_LANG_SPECIFIC (t)&& DECL_FRIEND_P (t)) 		    return t;  		  if (extra_warnings) 		    { 		      cp_warning ("`static' missing from declaration of `%D'", 				  t); 		      warning_with_file_and_line (file, line, 						  "previous declaration of `%s'", 						  decl_as_string (t, 0)); 		    }
comment|/* Now fix things so it'll do what they expect.  */
block|if (current_function_decl) 		    TREE_PUBLIC (current_function_decl) = 0; 		}
comment|/* Due to interference in memory reclamation (X may be 		 obstack-deallocated at this point), we must guard against 		 one really special case.  [jason: This should be handled 		 by start_function]  */
block|if (current_function_decl == x) 		current_function_decl = t;
endif|#
directive|endif
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|SET_IDENTIFIER_TYPE_VALUE
argument_list|(
name|name
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|!
name|DECL_FUNCTION_MEMBER_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|t
operator|=
name|push_overloaded_decl
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|x
operator|||
name|DECL_LANGUAGE
argument_list|(
name|x
argument_list|)
operator|==
name|lang_c
condition|)
return|return
name|t
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TEMPLATE_DECL
operator|&&
operator|!
name|DECL_TEMPLATE_IS_CLASS
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|push_overloaded_decl
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
return|;
comment|/* If declaring a type as a typedef, and the type has no known 	 typedef name, install this TYPE_DECL as its typedef name.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|tree
name|name
init|=
operator|(
name|type
operator|!=
name|error_mark_node
operator|)
condition|?
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
else|:
name|x
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
block|{
comment|/* If these are different names, and we're at the global 		 binding level, make two equivalent definitions.  */
name|name
operator|=
name|x
expr_stmt|;
if|if
condition|(
name|global_bindings_p
argument_list|()
condition|)
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|=
name|x
expr_stmt|;
block|}
else|else
block|{
name|tree
name|tname
init|=
name|DECL_NAME
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|global_bindings_p
argument_list|()
operator|&&
name|ANON_AGGRNAME_P
argument_list|(
name|tname
argument_list|)
condition|)
block|{
comment|/* do gratuitous C++ typedefing, and make sure that   		     we access this type either through TREE_TYPE field   		     or via the tags list.  */
name|TYPE_NAME
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|=
name|x
expr_stmt|;
name|pushtag
argument_list|(
name|tname
argument_list|,
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TYPE_DECL
argument_list|,
literal|140
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|name
argument_list|)
operator|&&
operator|!
name|DECL_NESTED_TYPENAME
argument_list|(
name|name
argument_list|)
condition|)
name|set_nested_typename
argument_list|(
name|x
argument_list|,
name|current_class_name
argument_list|,
name|DECL_NAME
argument_list|(
name|name
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|error_mark_node
operator|&&
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_IDENTIFIER
argument_list|(
name|type
argument_list|)
condition|)
name|set_identifier_type_value_with_scope
argument_list|(
name|DECL_NAME
argument_list|(
name|x
argument_list|)
argument_list|,
name|type
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
comment|/* Multiple external decls of the same identifier ought to match.  	 We get warnings about inline functions where they are defined. 	 We get warnings about other functions from push_overloaded_decl. 	  	 Avoid duplicate warnings where they are used.  */
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|x
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
block|{
name|tree
name|decl
decl_stmt|;
if|if
condition|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
operator|(
name|DECL_EXTERNAL
argument_list|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
argument_list|)
operator|||
name|TREE_PUBLIC
argument_list|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
argument_list|)
operator|)
condition|)
name|decl
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
else|else
name|decl
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|decl
comment|/* If different sort of thing, we already gave an error.  */
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|cp_pedwarn
argument_list|(
literal|"type mismatch with previous external decl"
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|cp_pedwarn_at
argument_list|(
literal|"previous external decl of `%#D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* In PCC-compatibility mode, extern decls of vars with no current decl 	 take effect at top level no matter where they are.  */
if|if
condition|(
name|flag_traditional
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|x
argument_list|)
operator|&&
name|lookup_name
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|b
operator|=
name|global_binding_level
expr_stmt|;
comment|/* This name is new in its binding level. 	 Install the new declaration and return it.  */
if|if
condition|(
name|b
operator|==
name|global_binding_level
condition|)
block|{
comment|/* Install a global value.  */
comment|/* Rule for VAR_DECLs, but not for other kinds of _DECLs: 	     A `const' which was not declared `extern' is invisible.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_READONLY
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|DECL_THIS_EXTERN
argument_list|(
name|x
argument_list|)
condition|)
name|TREE_PUBLIC
argument_list|(
name|x
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* If the first global decl has external linkage, 	     warn if we later see static one.  */
if|if
condition|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|TREE_PUBLIC
argument_list|(
name|x
argument_list|)
condition|)
name|TREE_PUBLIC
argument_list|(
name|name
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Don't install a TYPE_DECL if we already have another 	     sort of _DECL with that name.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|TYPE_DECL
operator|||
name|t
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
operator|=
name|x
expr_stmt|;
comment|/* Don't forget if the function was used via an implicit decl.  */
if|if
condition|(
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|name
argument_list|)
operator|&&
name|TREE_USED
argument_list|(
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|name
argument_list|)
argument_list|)
condition|)
name|TREE_USED
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Don't forget if its address was taken in that way.  */
if|if
condition|(
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|name
argument_list|)
operator|&&
name|TREE_ADDRESSABLE
argument_list|(
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|name
argument_list|)
argument_list|)
condition|)
name|TREE_ADDRESSABLE
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Warn about mismatches against previous implicit decl.  */
if|if
condition|(
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|name
argument_list|)
operator|!=
name|NULL_TREE
comment|/* If this real decl matches the implicit, don't complain.  */
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|integer_type_node
operator|)
condition|)
name|cp_warning
argument_list|(
literal|"`%D' was previously implicitly declared to return `int'"
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* If new decl is `static' and an `extern' was seen previously, 	     warn about it.  */
if|if
condition|(
name|x
operator|!=
name|NULL_TREE
operator|&&
name|t
operator|!=
name|NULL_TREE
operator|&&
name|decls_match
argument_list|(
name|x
argument_list|,
name|t
argument_list|)
condition|)
name|warn_extern_redeclared_static
argument_list|(
name|x
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Here to install a non-global value.  */
name|tree
name|oldlocal
init|=
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|tree
name|oldglobal
init|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|b
operator|->
name|shadowed
operator|=
name|tree_cons
argument_list|(
name|name
argument_list|,
name|oldlocal
argument_list|,
name|b
operator|->
name|shadowed
argument_list|)
expr_stmt|;
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|name
argument_list|)
operator|=
name|x
expr_stmt|;
comment|/* If this is a TYPE_DECL, push it into the type value slot.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|set_identifier_type_value_with_scope
argument_list|(
name|name
argument_list|,
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|,
name|b
argument_list|)
expr_stmt|;
comment|/* If this is an extern function declaration, see if we 	     have a global definition or declaration for the function.  */
if|if
condition|(
name|oldlocal
operator|==
name|NULL_TREE
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|DECL_INLINE
argument_list|(
name|x
argument_list|)
operator|&&
name|oldglobal
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|oldglobal
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
comment|/* We have one.  Their types must agree.  */
if|if
condition|(
operator|!
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|oldglobal
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|cp_warning
argument_list|(
literal|"extern declaration of `%#D' doesn't match"
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|cp_warning_at
argument_list|(
literal|"global declaration `%#D'"
argument_list|,
name|oldglobal
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Inner extern decl is inline if global one is. 		     Copy enough to really inline it.  */
if|if
condition|(
name|DECL_INLINE
argument_list|(
name|oldglobal
argument_list|)
condition|)
block|{
name|DECL_INLINE
argument_list|(
name|x
argument_list|)
operator|=
name|DECL_INLINE
argument_list|(
name|oldglobal
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|=
operator|(
name|current_function_decl
operator|==
name|oldglobal
condition|?
name|NULL_TREE
else|:
name|DECL_INITIAL
argument_list|(
name|oldglobal
argument_list|)
operator|)
expr_stmt|;
name|DECL_SAVED_INSNS
argument_list|(
name|x
argument_list|)
operator|=
name|DECL_SAVED_INSNS
argument_list|(
name|oldglobal
argument_list|)
expr_stmt|;
name|DECL_FRAME_SIZE
argument_list|(
name|x
argument_list|)
operator|=
name|DECL_FRAME_SIZE
argument_list|(
name|oldglobal
argument_list|)
expr_stmt|;
name|DECL_ARGUMENTS
argument_list|(
name|x
argument_list|)
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|oldglobal
argument_list|)
expr_stmt|;
name|DECL_RESULT
argument_list|(
name|x
argument_list|)
operator|=
name|DECL_RESULT
argument_list|(
name|oldglobal
argument_list|)
expr_stmt|;
name|TREE_ASM_WRITTEN
argument_list|(
name|x
argument_list|)
operator|=
name|TREE_ASM_WRITTEN
argument_list|(
name|oldglobal
argument_list|)
expr_stmt|;
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|x
argument_list|)
operator|=
name|oldglobal
expr_stmt|;
block|}
comment|/* Inner extern decl is built-in if global one is.  */
if|if
condition|(
name|DECL_BUILT_IN
argument_list|(
name|oldglobal
argument_list|)
condition|)
block|{
name|DECL_BUILT_IN
argument_list|(
name|x
argument_list|)
operator|=
name|DECL_BUILT_IN
argument_list|(
name|oldglobal
argument_list|)
expr_stmt|;
name|DECL_FUNCTION_CODE
argument_list|(
name|x
argument_list|)
operator|=
name|DECL_FUNCTION_CODE
argument_list|(
name|oldglobal
argument_list|)
expr_stmt|;
block|}
comment|/* Keep the arg types from a file-scope fcn defn.  */
if|if
condition|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|oldglobal
argument_list|)
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|DECL_INITIAL
argument_list|(
name|oldglobal
argument_list|)
operator|&&
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|oldglobal
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If we have a local external declaration, 	     and no file-scope declaration has yet been seen, 	     then if we later have a file-scope decl it must not be static.  */
if|if
condition|(
name|oldlocal
operator|==
name|NULL_TREE
operator|&&
name|oldglobal
operator|==
name|NULL_TREE
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|x
argument_list|)
operator|&&
name|TREE_PUBLIC
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|TREE_PUBLIC
argument_list|(
name|name
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|DECL_FROM_INLINE
argument_list|(
name|x
argument_list|)
condition|)
comment|/* Inline decls shadow nothing.  */
empty_stmt|;
comment|/* Warn if shadowing an argument at the top level of the body.  */
elseif|else
if|if
condition|(
name|oldlocal
operator|!=
name|NULL_TREE
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|x
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|oldlocal
argument_list|)
operator|==
name|PARM_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|PARM_DECL
condition|)
block|{
comment|/* Go to where the parms should be and see if we 		 find them there.  */
name|struct
name|binding_level
modifier|*
name|b
init|=
name|current_binding_level
operator|->
name|level_chain
decl_stmt|;
if|if
condition|(
name|cleanup_label
condition|)
name|b
operator|=
name|b
operator|->
name|level_chain
expr_stmt|;
comment|/* ARM $8.3 */
if|if
condition|(
name|b
operator|->
name|parm_flag
operator|==
literal|1
condition|)
name|cp_error
argument_list|(
literal|"declaration of `%#D' shadows a parameter"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* Maybe warn if shadowing something else.  */
elseif|else
if|if
condition|(
name|warn_shadow
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|x
argument_list|)
comment|/* No shadow warnings for internally generated vars.  */
operator|&&
operator|!
name|DECL_ARTIFICIAL
argument_list|(
name|x
argument_list|)
comment|/* No shadow warnings for vars made for inlining.  */
operator|&&
operator|!
name|DECL_FROM_INLINE
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|char
modifier|*
name|warnstring
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|oldlocal
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|oldlocal
argument_list|)
operator|==
name|PARM_DECL
condition|)
name|warnstring
operator|=
literal|"declaration of `%s' shadows a parameter"
expr_stmt|;
elseif|else
if|if
condition|(
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|name
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|name
argument_list|)
condition|)
name|warnstring
operator|=
literal|"declaration of `%s' shadows a member of `this'"
expr_stmt|;
elseif|else
if|if
condition|(
name|oldlocal
operator|!=
name|NULL_TREE
condition|)
name|warnstring
operator|=
literal|"declaration of `%s' shadows previous local"
expr_stmt|;
elseif|else
if|if
condition|(
name|oldglobal
operator|!=
name|NULL_TREE
condition|)
name|warnstring
operator|=
literal|"declaration of `%s' shadows global declaration"
expr_stmt|;
if|if
condition|(
name|warnstring
condition|)
name|warning
argument_list|(
name|warnstring
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If storing a local value, there may already be one (inherited). 	     If so, record it for restoration when this binding level ends.  */
if|if
condition|(
name|oldlocal
operator|!=
name|NULL_TREE
condition|)
name|b
operator|->
name|shadowed
operator|=
name|tree_cons
argument_list|(
name|name
argument_list|,
name|oldlocal
argument_list|,
name|b
operator|->
name|shadowed
argument_list|)
expr_stmt|;
block|}
comment|/* Keep count of variables in this level with incomplete type.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|TEMPLATE_DECL
operator|&&
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|PROMOTES_TO_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|,
name|ARRAY_TYPE
argument_list|)
condition|)
block|{
if|if
condition|(
operator|++
name|b
operator|->
name|n_incomplete
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"too many incomplete variables at this point"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|name
operator|!=
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|current_class_name
condition|)
block|{
if|if
condition|(
operator|!
name|TREE_MANGLED
argument_list|(
name|name
argument_list|)
condition|)
name|set_nested_typename
argument_list|(
name|x
argument_list|,
name|current_class_name
argument_list|,
name|DECL_NAME
argument_list|(
name|x
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Put decls on list in reverse order.      We will reverse them later if necessary.  */
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
operator|=
name|b
operator|->
name|names
expr_stmt|;
name|b
operator|->
name|names
operator|=
name|x
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|b
operator|!=
name|global_binding_level
operator|||
name|TREE_PERMANENT
argument_list|(
name|x
argument_list|)
operator|)
condition|)
name|my_friendly_abort
argument_list|(
literal|124
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Same as pushdecl, but define X in binding-level LEVEL. */
end_comment

begin_function
specifier|static
name|tree
name|pushdecl_with_scope
parameter_list|(
name|x
parameter_list|,
name|level
parameter_list|)
name|tree
name|x
decl_stmt|;
name|struct
name|binding_level
modifier|*
name|level
decl_stmt|;
block|{
specifier|register
name|struct
name|binding_level
modifier|*
name|b
init|=
name|current_binding_level
decl_stmt|;
name|current_binding_level
operator|=
name|level
expr_stmt|;
name|x
operator|=
name|pushdecl
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|current_binding_level
operator|=
name|b
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Like pushdecl, only it places X in GLOBAL_BINDING_LEVEL,    if appropriate.  */
end_comment

begin_function
name|tree
name|pushdecl_top_level
parameter_list|(
name|x
parameter_list|)
name|tree
name|x
decl_stmt|;
block|{
specifier|register
name|struct
name|binding_level
modifier|*
name|b
init|=
name|inner_binding_level
decl_stmt|;
specifier|register
name|tree
name|t
init|=
name|pushdecl_with_scope
argument_list|(
name|x
argument_list|,
name|global_binding_level
argument_list|)
decl_stmt|;
comment|/* Now, the type_shadowed stack may screw us.  Munge it so it does      what we want.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|tree
name|name
init|=
name|DECL_NAME
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|tree
name|newval
decl_stmt|;
name|tree
modifier|*
name|ptr
init|=
operator|(
name|tree
operator|*
operator|)
literal|0
decl_stmt|;
for|for
control|(
init|;
name|b
operator|!=
name|global_binding_level
condition|;
name|b
operator|=
name|b
operator|->
name|level_chain
control|)
block|{
name|tree
name|shadowed
init|=
name|b
operator|->
name|type_shadowed
decl_stmt|;
for|for
control|(
init|;
name|shadowed
condition|;
name|shadowed
operator|=
name|TREE_CHAIN
argument_list|(
name|shadowed
argument_list|)
control|)
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|shadowed
argument_list|)
operator|==
name|name
condition|)
block|{
name|ptr
operator|=
operator|&
name|TREE_VALUE
argument_list|(
name|shadowed
argument_list|)
expr_stmt|;
comment|/* Can't break out of the loop here because sometimes 		   a binding level will have duplicate bindings for 		   PT names.  It's gross, but I haven't time to fix it.  */
block|}
block|}
name|newval
operator|=
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
operator|(
name|tree
operator|*
operator|)
literal|0
condition|)
block|{
comment|/* @@ This shouldn't be needed.  My test case "zstring.cc" trips              up here if this is changed to an assertion.  --KR  */
name|SET_IDENTIFIER_TYPE_VALUE
argument_list|(
name|name
argument_list|,
name|newval
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
literal|0
comment|/* Disabled this 11/10/92, since there are many cases which 	     behave just fine when *ptr doesn't satisfy either of these. 	     For example, nested classes declared as friends of their enclosing 	     class will not meet this criteria.  (bpk) */
block|my_friendly_assert (*ptr == NULL_TREE || *ptr == newval, 141);
endif|#
directive|endif
operator|*
name|ptr
operator|=
name|newval
expr_stmt|;
block|}
block|}
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Like push_overloaded_decl, only it places X in GLOBAL_BINDING_LEVEL,    if appropriate.  */
end_comment

begin_function
name|void
name|push_overloaded_decl_top_level
parameter_list|(
name|x
parameter_list|,
name|forget
parameter_list|)
name|tree
name|x
decl_stmt|;
name|int
name|forget
decl_stmt|;
block|{
name|struct
name|binding_level
modifier|*
name|b
init|=
name|current_binding_level
decl_stmt|;
name|current_binding_level
operator|=
name|global_binding_level
expr_stmt|;
name|push_overloaded_decl
argument_list|(
name|x
argument_list|,
name|forget
argument_list|)
expr_stmt|;
name|current_binding_level
operator|=
name|b
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make the declaration of X appear in CLASS scope.  */
end_comment

begin_function
name|tree
name|pushdecl_class_level
parameter_list|(
name|x
parameter_list|)
name|tree
name|x
decl_stmt|;
block|{
comment|/* Don't use DECL_ASSEMBLER_NAME here!  Everything that looks in class      scope looks for the pre-mangled name.  */
specifier|register
name|tree
name|name
init|=
name|DECL_NAME
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|name
condition|)
block|{
if|if
condition|(
name|TYPE_BEING_DEFINED
argument_list|(
name|current_class_type
argument_list|)
condition|)
block|{
comment|/* Check for inconsistent use of this name in the class body. 	     Types, enums, and static vars are checked here; other 	     members are checked in finish_struct.  */
name|tree
name|icv
init|=
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|icv
comment|/* Don't complain about inherited names.  */
operator|&&
name|id_in_current_class
argument_list|(
name|name
argument_list|)
comment|/* Or shadowed tags.  */
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|icv
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_CONTEXT
argument_list|(
name|icv
argument_list|)
operator|==
name|current_class_type
operator|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"declaration of identifier `%D' as `%#D'"
argument_list|,
name|name
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"conflicts with previous use in class as `%#D'"
argument_list|,
name|icv
argument_list|)
expr_stmt|;
block|}
block|}
name|push_class_level_binding
argument_list|(
name|name
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|set_identifier_type_value
argument_list|(
name|name
argument_list|,
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_NESTED_TYPENAME
argument_list|(
name|x
argument_list|)
condition|)
name|set_nested_typename
argument_list|(
name|x
argument_list|,
name|current_class_name
argument_list|,
name|name
argument_list|,
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* This function is used to push the mangled decls for nested types into    the appropriate scope.  Previously pushdecl_top_level was used, but that    is incorrect for members of local classes.  */
end_comment

begin_function
name|tree
name|pushdecl_nonclass_level
parameter_list|(
name|x
parameter_list|)
name|tree
name|x
decl_stmt|;
block|{
name|struct
name|binding_level
modifier|*
name|b
init|=
name|current_binding_level
decl_stmt|;
if|#
directive|if
literal|0
comment|/* Get out of class scope -- this isn't necessary, because class scope      doesn't make it into current_binding_level.  */
block|while (b->parm_flag == 2)     b = b->level_chain;
else|#
directive|else
name|my_friendly_assert
argument_list|(
name|b
operator|->
name|parm_flag
operator|!=
literal|2
argument_list|,
literal|180
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Get out of template binding levels */
while|while
condition|(
name|b
operator|->
name|pseudo_global
condition|)
name|b
operator|=
name|b
operator|->
name|level_chain
expr_stmt|;
name|pushdecl_with_scope
argument_list|(
name|x
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make the declaration(s) of X appear in CLASS scope    under the name NAME.  */
end_comment

begin_function
name|void
name|push_class_level_binding
parameter_list|(
name|name
parameter_list|,
name|x
parameter_list|)
name|tree
name|name
decl_stmt|;
name|tree
name|x
decl_stmt|;
block|{
name|maybe_push_cache_obstack
argument_list|()
expr_stmt|;
name|class_binding_level
operator|->
name|class_shadowed
operator|=
name|tree_cons
argument_list|(
name|name
argument_list|,
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|name
argument_list|)
argument_list|,
name|class_binding_level
operator|->
name|class_shadowed
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|name
argument_list|)
operator|=
name|x
expr_stmt|;
name|obstack_ptr_grow
argument_list|(
operator|&
name|decl_obstack
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Tell caller how to interpret a TREE_LIST which contains    chains of FUNCTION_DECLS.  */
end_comment

begin_function
name|int
name|overloaded_globals_p
parameter_list|(
name|list
parameter_list|)
name|tree
name|list
decl_stmt|;
block|{
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|list
argument_list|)
operator|==
name|TREE_LIST
argument_list|,
literal|142
argument_list|)
expr_stmt|;
comment|/* Don't commit caller to seeing them as globals.  */
if|if
condition|(
name|TREE_NONLOCAL_FLAG
argument_list|(
name|list
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Do commit caller to seeing them as globals.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|list
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
return|return
literal|1
return|;
comment|/* Do commit caller to not seeing them as globals.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* DECL is a FUNCTION_DECL which may have other definitions already in    place.  We get around this by making the value of the identifier point    to a list of all the things that want to be referenced by that name.  It    is then up to the users of that name to decide what to do with that    list.     DECL may also be a TEMPLATE_DECL, with a FUNCTION_DECL in its DECL_RESULT    slot.  It is dealt with the same way.     The value returned may be a previous declaration if we guessed wrong    about what language DECL should belong to (C or C++).  Otherwise,    it's always DECL (and never something that's not a _DECL).  */
end_comment

begin_function
name|tree
name|push_overloaded_decl
parameter_list|(
name|decl
parameter_list|,
name|forgettable
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|int
name|forgettable
decl_stmt|;
block|{
name|tree
name|orig_name
init|=
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|tree
name|old
decl_stmt|;
name|int
name|doing_global
init|=
operator|(
name|global_bindings_p
argument_list|()
operator|||
operator|!
name|forgettable
operator|||
name|flag_traditional
operator|||
name|pseudo_global_level_p
argument_list|()
operator|)
decl_stmt|;
if|if
condition|(
name|doing_global
condition|)
block|{
name|old
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|orig_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|&&
name|TREE_CODE
argument_list|(
name|old
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|old
argument_list|)
operator|&&
operator|(
name|DECL_BUILT_IN
argument_list|(
name|old
argument_list|)
operator|||
name|DECL_BUILT_IN_NONANSI
argument_list|(
name|old
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|duplicate_decls
argument_list|(
name|decl
argument_list|,
name|old
argument_list|)
condition|)
return|return
name|old
return|;
name|old
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
else|else
block|{
name|old
operator|=
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|orig_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|purpose_member
argument_list|(
name|orig_name
argument_list|,
name|current_binding_level
operator|->
name|shadowed
argument_list|)
condition|)
block|{
name|current_binding_level
operator|->
name|shadowed
operator|=
name|tree_cons
argument_list|(
name|orig_name
argument_list|,
name|old
argument_list|,
name|current_binding_level
operator|->
name|shadowed
argument_list|)
expr_stmt|;
name|old
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|old
condition|)
block|{
if|#
directive|if
literal|0
comment|/* We cache the value of builtin functions as ADDR_EXPRs 	 in the name space.  Convert it to some kind of _DECL after 	 remembering what to forget.  */
block|if (TREE_CODE (old) == ADDR_EXPR) 	old = TREE_OPERAND (old, 0);       else
endif|#
directive|endif
if|if
condition|(
name|TREE_CODE
argument_list|(
name|old
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"previous non-function declaration `%#D'"
argument_list|,
name|old
argument_list|)
expr_stmt|;
name|cp_error
argument_list|(
literal|"conflicts with function declaration `%#D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|old
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|tree
name|t
init|=
name|TREE_TYPE
argument_list|(
name|old
argument_list|)
decl_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|t
argument_list|)
operator|&&
name|warn_shadow
condition|)
name|cp_warning
argument_list|(
literal|"`%#D' hides constructor for `%#T'"
argument_list|,
name|decl
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|old
operator|=
name|NULL_TREE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_overloaded_fn
argument_list|(
name|old
argument_list|)
condition|)
block|{
name|tree
name|tmp
decl_stmt|;
for|for
control|(
name|tmp
operator|=
name|get_first_fn
argument_list|(
name|old
argument_list|)
init|;
name|tmp
condition|;
name|tmp
operator|=
name|DECL_CHAIN
argument_list|(
name|tmp
argument_list|)
control|)
if|if
condition|(
name|decl
operator|==
name|tmp
operator|||
name|duplicate_decls
argument_list|(
name|decl
argument_list|,
name|tmp
argument_list|)
condition|)
return|return
name|tmp
return|;
block|}
block|}
if|if
condition|(
name|old
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
if|if
condition|(
name|old
operator|&&
name|is_overloaded_fn
argument_list|(
name|old
argument_list|)
condition|)
name|DECL_CHAIN
argument_list|(
name|decl
argument_list|)
operator|=
name|get_first_fn
argument_list|(
name|old
argument_list|)
expr_stmt|;
else|else
name|DECL_CHAIN
argument_list|(
name|decl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|old
operator|=
name|tree_cons
argument_list|(
name|orig_name
argument_list|,
name|decl
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|old
argument_list|)
operator|=
name|unknown_type_node
expr_stmt|;
block|}
else|else
comment|/* orig_name is not ambiguous.  */
name|old
operator|=
name|decl
expr_stmt|;
if|if
condition|(
name|doing_global
condition|)
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|orig_name
argument_list|)
operator|=
name|old
expr_stmt|;
else|else
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|orig_name
argument_list|)
operator|=
name|old
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate an implicit declaration for identifier FUNCTIONID    as a function of type int ().  Print a warning if appropriate.  */
end_comment

begin_function
name|tree
name|implicitly_declare
parameter_list|(
name|functionid
parameter_list|)
name|tree
name|functionid
decl_stmt|;
block|{
specifier|register
name|tree
name|decl
decl_stmt|;
name|int
name|temp
init|=
name|allocation_temporary_p
argument_list|()
decl_stmt|;
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
comment|/* Save the decl permanently so we can warn if definition follows.      In ANSI C, warn_implicit is usually false, so the saves little space.      But in C++, it's usually true, hence the extra code.  */
if|if
condition|(
name|temp
operator|&&
operator|(
name|flag_traditional
operator|||
operator|!
name|warn_implicit
operator|||
name|current_binding_level
operator|==
name|global_binding_level
operator|)
condition|)
name|end_temporary_allocation
argument_list|()
expr_stmt|;
comment|/* We used to reuse an old implicit decl here,      but this loses with inline functions because it can clobber      the saved decl chains.  */
name|decl
operator|=
name|build_lang_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|functionid
argument_list|,
name|default_function_type
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* ANSI standard says implicit declarations are in the innermost block.      So we record the decl in the standard fashion.      If flag_traditional is set, pushdecl does it top-level.  */
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|rest_of_decl_compilation
argument_list|(
name|decl
argument_list|,
name|NULL_PTR
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|warn_implicit
comment|/* Only one warning per identifier.  */
operator|&&
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|functionid
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|cp_pedwarn
argument_list|(
literal|"implicit declaration of function `%#D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
name|SET_IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|functionid
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Return zero if the declaration NEWDECL is valid    when the declaration OLDDECL (assumed to be for the same name)    has already been seen.    Otherwise return an error message format string with a %s    where the identifier should go.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|redeclaration_error_message
parameter_list|(
name|newdecl
parameter_list|,
name|olddecl
parameter_list|)
name|tree
name|newdecl
decl_stmt|,
name|olddecl
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
comment|/* Because C++ can put things into name space for free, 	 constructs like "typedef struct foo { ... } foo" 	 would look like an erroneous redeclaration.  */
if|if
condition|(
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
return|return
literal|"redefinition of `%#D'"
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
comment|/* If this is a pure function, its olddecl will actually be 	 the original initialization to `0' (which we force to call 	 abort()).  Don't complain about redefinition in this case.  */
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|DECL_ABSTRACT_VIRTUAL_P
argument_list|(
name|olddecl
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Declarations of functions can insist on internal linkage 	 but they can't be inconsistent with internal linkage, 	 so there can be no error on that account. 	 However defining the same name twice is no good.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|NULL_TREE
comment|/* However, defining once as extern inline and a second 	     time in another way is ok.  */
operator|&&
operator|!
operator|(
name|DECL_INLINE
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|!
operator|(
name|DECL_INLINE
argument_list|(
name|newdecl
argument_list|)
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|newdecl
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|olddecl
argument_list|)
operator|==
name|NULL_TREE
condition|)
return|return
literal|"`%#D' not declared in class"
return|;
else|else
return|return
literal|"redefinition of `%#D'"
return|;
block|}
block|{
name|tree
name|t1
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|t2
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|t1
operator|=
name|TREE_CHAIN
argument_list|(
name|t1
argument_list|)
operator|,
name|t2
operator|=
name|TREE_CHAIN
argument_list|(
name|t2
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|t1
condition|;
name|t1
operator|=
name|TREE_CHAIN
argument_list|(
name|t1
argument_list|)
operator|,
name|t2
operator|=
name|TREE_CHAIN
argument_list|(
name|t2
argument_list|)
control|)
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|t1
argument_list|)
operator|&&
name|TREE_PURPOSE
argument_list|(
name|t2
argument_list|)
condition|)
return|return
literal|"duplicate default arguments given for `%#D'"
return|;
block|}
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
condition|)
return|return
literal|"redefinition of `%#D'"
return|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
condition|)
block|{
comment|/* Objects declared at top level:  */
comment|/* If at least one is a reference, it's ok.  */
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|newdecl
argument_list|)
operator|||
name|DECL_EXTERNAL
argument_list|(
name|olddecl
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Now we have two tentative defs, or one tentative and one real def.  */
comment|/* Insist that the linkage match.  */
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|olddecl
argument_list|)
operator|!=
name|TREE_PUBLIC
argument_list|(
name|newdecl
argument_list|)
condition|)
return|return
literal|"conflicting declarations of `%#D'"
return|;
comment|/* Reject two definitions.  */
return|return
literal|"redefinition of `%#D'"
return|;
block|}
else|else
block|{
comment|/* Objects declared with block scope:  */
comment|/* Reject two definitions, and reject a definition 	 together with an external reference.  */
if|if
condition|(
operator|!
operator|(
name|DECL_EXTERNAL
argument_list|(
name|newdecl
argument_list|)
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|olddecl
argument_list|)
operator|)
condition|)
return|return
literal|"redeclaration of `%#D'"
return|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Get the LABEL_DECL corresponding to identifier ID as a label.    Create one if none exists so far for the current function.    This function is called for both label definitions and label references.  */
end_comment

begin_function
name|tree
name|lookup_label
parameter_list|(
name|id
parameter_list|)
name|tree
name|id
decl_stmt|;
block|{
specifier|register
name|tree
name|decl
init|=
name|IDENTIFIER_LABEL_VALUE
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|current_function_decl
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"label `%s' referenced outside of any function"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
operator|(
name|decl
operator|==
name|NULL_TREE
operator|||
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|named_label_uses
operator|==
name|NULL_TREE
operator|||
name|TREE_PURPOSE
argument_list|(
name|named_label_uses
argument_list|)
operator|!=
name|current_binding_level
operator|->
name|names
operator|||
name|TREE_VALUE
argument_list|(
name|named_label_uses
argument_list|)
operator|!=
name|decl
operator|)
condition|)
block|{
name|named_label_uses
operator|=
name|tree_cons
argument_list|(
name|current_binding_level
operator|->
name|names
argument_list|,
name|decl
argument_list|,
name|named_label_uses
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|named_label_uses
argument_list|)
operator|=
operator|(
name|tree
operator|)
name|current_binding_level
expr_stmt|;
block|}
comment|/* Use a label already defined or ref'd with this name.  */
if|if
condition|(
name|decl
operator|!=
name|NULL_TREE
condition|)
block|{
comment|/* But not if it is inherited and wasn't declared to be inheritable.  */
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|!=
name|current_function_decl
operator|&&
operator|!
name|C_DECLARED_LABEL_FLAG
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|shadow_label
argument_list|(
name|id
argument_list|)
return|;
return|return
name|decl
return|;
block|}
name|decl
operator|=
name|build_decl
argument_list|(
name|LABEL_DECL
argument_list|,
name|id
argument_list|,
name|void_type_node
argument_list|)
expr_stmt|;
comment|/* A label not explicitly declared must be local to where it's ref'd.  */
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|current_function_decl
expr_stmt|;
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
operator|=
name|VOIDmode
expr_stmt|;
comment|/* Say where one reference is to the label,      for the sake of the error if it is not defined.  */
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
operator|=
name|lineno
expr_stmt|;
name|DECL_SOURCE_FILE
argument_list|(
name|decl
argument_list|)
operator|=
name|input_filename
expr_stmt|;
name|SET_IDENTIFIER_LABEL_VALUE
argument_list|(
name|id
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|named_labels
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|decl
argument_list|,
name|named_labels
argument_list|)
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|named_label_uses
argument_list|)
operator|=
name|decl
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Make a label named NAME in the current function,    shadowing silently any that may be inherited from containing functions    or containing scopes.     Note that valid use, if the label being shadowed    comes from another scope in the same function,    requires calling declare_nonlocal_label right away.  */
end_comment

begin_function
name|tree
name|shadow_label
parameter_list|(
name|name
parameter_list|)
name|tree
name|name
decl_stmt|;
block|{
specifier|register
name|tree
name|decl
init|=
name|IDENTIFIER_LABEL_VALUE
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|decl
operator|!=
name|NULL_TREE
condition|)
block|{
name|shadowed_labels
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|decl
argument_list|,
name|shadowed_labels
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_LABEL_VALUE
argument_list|(
name|name
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_LABEL_VALUE
argument_list|(
name|decl
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
return|return
name|lookup_label
argument_list|(
name|name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Define a label, specifying the location in the source file.    Return the LABEL_DECL node for the label, if the definition is valid.    Otherwise return 0.  */
end_comment

begin_function
name|tree
name|define_label
parameter_list|(
name|filename
parameter_list|,
name|line
parameter_list|,
name|name
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|line
decl_stmt|;
name|tree
name|name
decl_stmt|;
block|{
name|tree
name|decl
init|=
name|lookup_label
argument_list|(
name|name
argument_list|)
decl_stmt|;
comment|/* After labels, make any new cleanups go into their      own new (temporary) binding contour.  */
name|current_binding_level
operator|->
name|more_cleanups_ok
operator|=
literal|0
expr_stmt|;
comment|/* If label with this name is known from an outer context, shadow it.  */
if|if
condition|(
name|decl
operator|!=
name|NULL_TREE
operator|&&
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|!=
name|current_function_decl
condition|)
block|{
name|shadowed_labels
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|decl
argument_list|,
name|shadowed_labels
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_LABEL_VALUE
argument_list|(
name|name
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|decl
operator|=
name|lookup_label
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
name|cp_error
argument_list|(
literal|"duplicate label `%D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|tree
name|uses
decl_stmt|,
name|prev
decl_stmt|;
comment|/* Mark label as having been defined.  */
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
comment|/* Say where in the source.  */
name|DECL_SOURCE_FILE
argument_list|(
name|decl
argument_list|)
operator|=
name|filename
expr_stmt|;
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
operator|=
name|line
expr_stmt|;
for|for
control|(
name|prev
operator|=
name|NULL_TREE
operator|,
name|uses
operator|=
name|named_label_uses
init|;
name|uses
condition|;
name|prev
operator|=
name|uses
operator|,
name|uses
operator|=
name|TREE_CHAIN
argument_list|(
name|uses
argument_list|)
control|)
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|uses
argument_list|)
operator|==
name|decl
condition|)
block|{
name|struct
name|binding_level
modifier|*
name|b
init|=
name|current_binding_level
decl_stmt|;
while|while
condition|(
name|b
condition|)
block|{
name|tree
name|new_decls
init|=
name|b
operator|->
name|names
decl_stmt|;
name|tree
name|old_decls
init|=
operator|(
operator|(
name|tree
operator|)
name|b
operator|==
name|TREE_TYPE
argument_list|(
name|uses
argument_list|)
condition|?
name|TREE_PURPOSE
argument_list|(
name|uses
argument_list|)
else|:
name|NULL_TREE
operator|)
decl_stmt|;
while|while
condition|(
name|new_decls
operator|!=
name|old_decls
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|new_decls
argument_list|)
operator|==
name|VAR_DECL
comment|/* Don't complain about crossing initialization 			   of internal entities.  They can't be accessed, 			   and they should be cleaned up 			   by the time we get to the label.  */
operator|&&
operator|!
name|DECL_ARTIFICIAL
argument_list|(
name|new_decls
argument_list|)
operator|&&
operator|(
operator|(
name|DECL_INITIAL
argument_list|(
name|new_decls
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|DECL_INITIAL
argument_list|(
name|new_decls
argument_list|)
operator|!=
name|error_mark_node
operator|)
operator|||
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|TREE_TYPE
argument_list|(
name|new_decls
argument_list|)
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|IDENTIFIER_ERROR_LOCUS
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|cp_error
argument_list|(
literal|"invalid jump to label `%D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_ERROR_LOCUS
argument_list|(
name|decl
argument_list|,
name|current_function_decl
argument_list|)
expr_stmt|;
name|cp_error
argument_list|(
literal|"crosses initialization of `%D'"
argument_list|,
name|new_decls
argument_list|)
expr_stmt|;
block|}
name|new_decls
operator|=
name|TREE_CHAIN
argument_list|(
name|new_decls
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|tree
operator|)
name|b
operator|==
name|TREE_TYPE
argument_list|(
name|uses
argument_list|)
condition|)
break|break;
name|b
operator|=
name|b
operator|->
name|level_chain
expr_stmt|;
block|}
if|if
condition|(
name|prev
condition|)
name|TREE_CHAIN
argument_list|(
name|prev
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|uses
argument_list|)
expr_stmt|;
else|else
name|named_label_uses
operator|=
name|TREE_CHAIN
argument_list|(
name|uses
argument_list|)
expr_stmt|;
block|}
name|current_function_return_value
operator|=
name|NULL_TREE
expr_stmt|;
return|return
name|decl
return|;
block|}
block|}
end_function

begin_comment
comment|/* Same, but for CASE labels.  If DECL is NULL_TREE, it's the default.  */
end_comment

begin_comment
comment|/* XXX Note decl is never actually used. (bpk) */
end_comment

begin_function
name|void
name|define_case_label
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|tree
name|cleanup
init|=
name|last_cleanup_this_contour
argument_list|()
decl_stmt|;
if|if
condition|(
name|cleanup
condition|)
block|{
specifier|static
name|int
name|explained
init|=
literal|0
decl_stmt|;
name|cp_error_at
argument_list|(
literal|"destructor needed for `%#D'"
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|cleanup
argument_list|)
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"where case label appears here"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|explained
condition|)
block|{
name|error
argument_list|(
literal|"(enclose actions of previous case statements requiring"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"destructors in their own binding contours.)"
argument_list|)
expr_stmt|;
name|explained
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* After labels, make any new cleanups go into their      own new (temporary) binding contour.  */
name|current_binding_level
operator|->
name|more_cleanups_ok
operator|=
literal|0
expr_stmt|;
name|current_function_return_value
operator|=
name|NULL_TREE
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the list of declarations of the current level.    Note that this list is in reverse order unless/until    you nreverse it; and when you do nreverse it, you must    store the result back using `storedecls' or you will lose.  */
end_comment

begin_function
name|tree
name|getdecls
parameter_list|()
block|{
return|return
name|current_binding_level
operator|->
name|names
return|;
block|}
end_function

begin_comment
comment|/* Return the list of type-tags (for structs, etc) of the current level.  */
end_comment

begin_function
name|tree
name|gettags
parameter_list|()
block|{
return|return
name|current_binding_level
operator|->
name|tags
return|;
block|}
end_function

begin_comment
comment|/* Store the list of declarations of the current level.    This is done for the parameter declarations of a function being defined,    after they are modified in the light of any missing parameters.  */
end_comment

begin_function
specifier|static
name|void
name|storedecls
parameter_list|(
name|decls
parameter_list|)
name|tree
name|decls
decl_stmt|;
block|{
name|current_binding_level
operator|->
name|names
operator|=
name|decls
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Similarly, store the list of tags of the current level.  */
end_comment

begin_function
specifier|static
name|void
name|storetags
parameter_list|(
name|tags
parameter_list|)
name|tree
name|tags
decl_stmt|;
block|{
name|current_binding_level
operator|->
name|tags
operator|=
name|tags
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given NAME, an IDENTIFIER_NODE,    return the structure (or union or enum) definition for that name.    Searches binding levels from BINDING_LEVEL up to the global level.    If THISLEVEL_ONLY is nonzero, searches only the specified context    (but skips any tag-transparent contexts to find one that is    meaningful for tags).    FORM says which kind of type the caller wants;    it is RECORD_TYPE or UNION_TYPE or ENUMERAL_TYPE.    If the wrong kind of type is found, and it's not a template, an error is    reported.  */
end_comment

begin_function
specifier|static
name|tree
name|lookup_tag
parameter_list|(
name|form
parameter_list|,
name|name
parameter_list|,
name|binding_level
parameter_list|,
name|thislevel_only
parameter_list|)
name|enum
name|tree_code
name|form
decl_stmt|;
name|struct
name|binding_level
modifier|*
name|binding_level
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|int
name|thislevel_only
decl_stmt|;
block|{
specifier|register
name|struct
name|binding_level
modifier|*
name|level
decl_stmt|;
for|for
control|(
name|level
operator|=
name|binding_level
init|;
name|level
condition|;
name|level
operator|=
name|level
operator|->
name|level_chain
control|)
block|{
specifier|register
name|tree
name|tail
decl_stmt|;
if|if
condition|(
name|ANON_AGGRNAME_P
argument_list|(
name|name
argument_list|)
condition|)
for|for
control|(
name|tail
operator|=
name|level
operator|->
name|tags
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
control|)
block|{
comment|/* There's no need for error checking here, because 	       anon names are unique throughout the compilation.  */
if|if
condition|(
name|TYPE_IDENTIFIER
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
operator|==
name|name
condition|)
return|return
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
return|;
block|}
else|else
for|for
control|(
name|tail
operator|=
name|level
operator|->
name|tags
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
operator|==
name|name
condition|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Should tighten this up; it'll probably permit 		   UNION_TYPE and a struct template, for example.  */
if|if
condition|(
name|code
operator|!=
name|form
operator|&&
operator|!
operator|(
name|form
operator|!=
name|ENUMERAL_TYPE
operator|&&
operator|(
name|code
operator|==
name|TEMPLATE_DECL
operator|||
name|code
operator|==
name|UNINSTANTIATED_P_TYPE
operator|)
operator|)
condition|)
block|{
comment|/* Definition isn't the kind we were looking for.  */
name|cp_error
argument_list|(
literal|"`%#D' redeclared as %C"
argument_list|,
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|,
name|form
argument_list|)
expr_stmt|;
block|}
return|return
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|thislevel_only
operator|&&
operator|!
name|level
operator|->
name|tag_transparent
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|current_class_type
operator|&&
name|level
operator|->
name|level_chain
operator|==
name|global_binding_level
condition|)
block|{
comment|/* Try looking in this class's tags before heading into 	     global binding level.  */
name|tree
name|context
init|=
name|current_class_type
decl_stmt|;
while|while
condition|(
name|context
condition|)
block|{
switch|switch
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|context
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|these_tags
decl_stmt|;
case|case
literal|'t'
case|:
name|these_tags
operator|=
name|CLASSTYPE_TAGS
argument_list|(
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|ANON_AGGRNAME_P
argument_list|(
name|name
argument_list|)
condition|)
while|while
condition|(
name|these_tags
condition|)
block|{
if|if
condition|(
name|TYPE_IDENTIFIER
argument_list|(
name|TREE_VALUE
argument_list|(
name|these_tags
argument_list|)
argument_list|)
operator|==
name|name
condition|)
return|return
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
return|;
name|these_tags
operator|=
name|TREE_CHAIN
argument_list|(
name|these_tags
argument_list|)
expr_stmt|;
block|}
else|else
while|while
condition|(
name|these_tags
condition|)
block|{
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|these_tags
argument_list|)
operator|==
name|name
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|these_tags
argument_list|)
argument_list|)
operator|!=
name|form
condition|)
block|{
name|cp_error
argument_list|(
literal|"`%#D' redeclared as %C in class scope"
argument_list|,
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|,
name|form
argument_list|)
expr_stmt|;
block|}
return|return
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
return|;
block|}
name|these_tags
operator|=
name|TREE_CHAIN
argument_list|(
name|these_tags
argument_list|)
expr_stmt|;
block|}
comment|/* If this type is not yet complete, then don't 		       look at its context.  */
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|context
argument_list|)
operator|==
name|NULL_TREE
condition|)
goto|goto
name|no_context
goto|;
comment|/* Go to next enclosing type, if any.  */
name|context
operator|=
name|DECL_CONTEXT
argument_list|(
name|TYPE_NAME
argument_list|(
name|context
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|context
operator|=
name|DECL_CONTEXT
argument_list|(
name|context
argument_list|)
expr_stmt|;
break|break;
default|default:
name|my_friendly_abort
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
continue|continue;
name|no_context
label|:
break|break;
block|}
block|}
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_function
name|void
name|set_current_level_tags_transparency
parameter_list|(
name|tags_transparent
parameter_list|)
name|int
name|tags_transparent
decl_stmt|;
block|{
name|current_binding_level
operator|->
name|tag_transparent
operator|=
name|tags_transparent
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a type, find the tag that was defined for it and return the tag name.    Otherwise return 0.  However, the value can never be 0    in the cases in which this is used.     C++: If NAME is non-zero, this is the new name to install.  This is    done when replacing anonymous tags with real tag names.  */
end_comment

begin_function
specifier|static
name|tree
name|lookup_tag_reverse
parameter_list|(
name|type
parameter_list|,
name|name
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|name
decl_stmt|;
block|{
specifier|register
name|struct
name|binding_level
modifier|*
name|level
decl_stmt|;
for|for
control|(
name|level
operator|=
name|current_binding_level
init|;
name|level
condition|;
name|level
operator|=
name|level
operator|->
name|level_chain
control|)
block|{
specifier|register
name|tree
name|tail
decl_stmt|;
for|for
control|(
name|tail
operator|=
name|level
operator|->
name|tags
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
operator|==
name|type
condition|)
block|{
if|if
condition|(
name|name
condition|)
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
operator|=
name|name
expr_stmt|;
return|return
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
return|;
block|}
block|}
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Given type TYPE which was not declared in C++ language context,    attempt to find a name by which it is referred.  */
end_comment

begin_function
name|tree
name|typedecl_for_tag
parameter_list|(
name|tag
parameter_list|)
name|tree
name|tag
decl_stmt|;
block|{
name|struct
name|binding_level
modifier|*
name|b
init|=
name|current_binding_level
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|tag
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
condition|)
return|return
name|TYPE_NAME
argument_list|(
name|tag
argument_list|)
return|;
while|while
condition|(
name|b
condition|)
block|{
name|tree
name|decls
init|=
name|b
operator|->
name|names
decl_stmt|;
while|while
condition|(
name|decls
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decls
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|TREE_TYPE
argument_list|(
name|decls
argument_list|)
operator|==
name|tag
condition|)
break|break;
name|decls
operator|=
name|TREE_CHAIN
argument_list|(
name|decls
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|decls
condition|)
return|return
name|decls
return|;
name|b
operator|=
name|b
operator|->
name|level_chain
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Lookup TYPE in CONTEXT (a chain of nested types or a FUNCTION_DECL).    Return the type value, or NULL_TREE if not found.  */
end_comment

begin_function
specifier|static
name|tree
name|lookup_nested_type
parameter_list|(
name|type
parameter_list|,
name|context
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|context
decl_stmt|;
block|{
if|if
condition|(
name|context
operator|==
name|NULL_TREE
condition|)
return|return
name|NULL_TREE
return|;
while|while
condition|(
name|context
condition|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|context
argument_list|)
condition|)
block|{
case|case
name|TYPE_DECL
case|:
block|{
name|tree
name|ctype
init|=
name|TREE_TYPE
argument_list|(
name|context
argument_list|)
decl_stmt|;
name|tree
name|match
init|=
name|value_member
argument_list|(
name|type
argument_list|,
name|CLASSTYPE_TAGS
argument_list|(
name|ctype
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|match
condition|)
return|return
name|TREE_VALUE
argument_list|(
name|match
argument_list|)
return|;
name|context
operator|=
name|DECL_CONTEXT
argument_list|(
name|context
argument_list|)
expr_stmt|;
comment|/* When we have a nested class whose member functions have 	       local types (e.g., a set of enums), we'll arrive here 	       with the DECL_CONTEXT as the actual RECORD_TYPE node for 	       the enclosing class.  Instead, we want to make sure we 	       come back in here with the TYPE_DECL, not the RECORD_TYPE.  */
if|if
condition|(
name|context
operator|&&
name|TREE_CODE
argument_list|(
name|context
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
name|context
operator|=
name|TREE_CHAIN
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|FUNCTION_DECL
case|:
return|return
name|TYPE_IDENTIFIER
argument_list|(
name|type
argument_list|)
condition|?
name|lookup_name
argument_list|(
name|TYPE_IDENTIFIER
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
else|:
name|NULL_TREE
return|;
break|break;
default|default:
name|my_friendly_abort
argument_list|(
literal|12
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Look up NAME in the current binding level and its superiors in the    namespace of variables, functions and typedefs.  Return a ..._DECL    node of some kind representing its definition if there is only one    such declaration, or return a TREE_LIST with all the overloaded    definitions if there are many, or return 0 if it is undefined.     If PREFER_TYPE is> 0, we prefer TYPE_DECLs.    If PREFER_TYPE is -2, we're being called from yylex(). (UGLY)    Otherwise we prefer non-TYPE_DECLs.  */
end_comment

begin_function
name|tree
name|lookup_name_real
parameter_list|(
name|name
parameter_list|,
name|prefer_type
parameter_list|,
name|nonclass
parameter_list|)
name|tree
name|name
decl_stmt|;
name|int
name|prefer_type
decl_stmt|,
name|nonclass
decl_stmt|;
block|{
specifier|register
name|tree
name|val
decl_stmt|;
name|int
name|yylex
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|prefer_type
operator|==
operator|-
literal|2
condition|)
block|{
specifier|extern
name|int
name|looking_for_typename
decl_stmt|;
name|yylex
operator|=
literal|1
expr_stmt|;
name|prefer_type
operator|=
name|looking_for_typename
expr_stmt|;
if|if
condition|(
name|got_scope
operator|!=
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|got_scope
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
elseif|else
if|if
condition|(
name|got_scope
operator|==
name|void_type_node
condition|)
name|val
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|got_scope
argument_list|)
operator|==
name|TEMPLATE_TYPE_PARM
comment|/* TFIXME -- don't do this for UPTs in new model.  */
operator|||
name|TREE_CODE
argument_list|(
name|got_scope
argument_list|)
operator|==
name|UNINSTANTIATED_P_TYPE
condition|)
block|{
if|if
condition|(
name|prefer_type
operator|>
literal|0
condition|)
name|val
operator|=
name|create_nested_upt
argument_list|(
name|got_scope
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|val
operator|=
name|NULL_TREE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|got_scope
argument_list|)
condition|)
comment|/* Someone else will give an error about this if needed. */
name|val
operator|=
name|NULL_TREE
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_BEING_DEFINED
argument_list|(
name|got_scope
argument_list|)
condition|)
block|{
name|val
operator|=
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&&
name|DECL_CONTEXT
argument_list|(
name|val
argument_list|)
operator|!=
name|got_scope
condition|)
block|{
name|struct
name|binding_level
modifier|*
name|b
init|=
name|class_binding_level
decl_stmt|;
for|for
control|(
name|val
operator|=
name|NULL_TREE
init|;
name|b
condition|;
name|b
operator|=
name|b
operator|->
name|level_chain
control|)
block|{
name|tree
name|t
init|=
name|purpose_member
argument_list|(
name|name
argument_list|,
name|b
operator|->
name|class_shadowed
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|&&
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
operator|&&
name|DECL_CONTEXT
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|got_scope
condition|)
block|{
name|val
operator|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|val
operator|==
name|NULL_TREE
operator|&&
name|CLASSTYPE_LOCAL_TYPEDECLS
argument_list|(
name|got_scope
argument_list|)
condition|)
name|val
operator|=
name|lookup_field
argument_list|(
name|got_scope
argument_list|,
name|name
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|got_scope
operator|==
name|current_class_type
condition|)
name|val
operator|=
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
else|else
name|val
operator|=
name|lookup_field
argument_list|(
name|got_scope
argument_list|,
name|name
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
if|if
condition|(
name|current_binding_level
operator|!=
name|global_binding_level
operator|&&
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|name
argument_list|)
condition|)
name|val
operator|=
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* In C++ class fields are between local and global scope,      just before the global scope.  */
elseif|else
if|if
condition|(
name|current_class_type
operator|&&
operator|!
name|nonclass
condition|)
block|{
name|val
operator|=
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|NULL_TREE
operator|&&
name|TYPE_BEING_DEFINED
argument_list|(
name|current_class_type
argument_list|)
operator|&&
name|CLASSTYPE_LOCAL_TYPEDECLS
argument_list|(
name|current_class_type
argument_list|)
condition|)
comment|/* Try to find values from base classes if we are presently 	   defining a type.  We are presently only interested in 	   TYPE_DECLs.  */
name|val
operator|=
name|lookup_field
argument_list|(
name|current_class_type
argument_list|,
name|name
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* yylex() calls this with -2, since we should never start digging for 	 the nested name at the point where we haven't even, for example, 	 created the COMPONENT_REF or anything like that.  */
if|if
condition|(
name|val
operator|==
name|NULL_TREE
condition|)
name|val
operator|=
name|lookup_nested_field
argument_list|(
name|name
argument_list|,
operator|!
name|yylex
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|NULL_TREE
condition|)
name|val
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
else|else
name|val
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|done
label|:
if|if
condition|(
name|val
condition|)
block|{
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|TEMPLATE_DECL
operator|&&
name|looking_for_template
operator|)
operator|||
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|TYPE_DECL
operator|||
name|prefer_type
operator|<=
literal|0
condition|)
return|return
name|val
return|;
if|if
condition|(
name|IDENTIFIER_HAS_TYPE_VALUE
argument_list|(
name|name
argument_list|)
condition|)
return|return
name|TYPE_NAME
argument_list|(
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|name
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
block|}
return|return
name|val
return|;
block|}
end_function

begin_function
name|tree
name|lookup_name_nonclass
parameter_list|(
name|name
parameter_list|)
name|tree
name|name
decl_stmt|;
block|{
return|return
name|lookup_name_real
argument_list|(
name|name
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
name|tree
name|lookup_name
parameter_list|(
name|name
parameter_list|,
name|prefer_type
parameter_list|)
name|tree
name|name
decl_stmt|;
name|int
name|prefer_type
decl_stmt|;
block|{
return|return
name|lookup_name_real
argument_list|(
name|name
argument_list|,
name|prefer_type
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Similar to `lookup_name' but look only at current binding level.  */
end_comment

begin_function
name|tree
name|lookup_name_current_level
parameter_list|(
name|name
parameter_list|)
name|tree
name|name
decl_stmt|;
block|{
specifier|register
name|tree
name|t
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
condition|)
block|{
name|t
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* extern "C" function() */
if|if
condition|(
name|t
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|t
operator|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|name
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
name|struct
name|binding_level
modifier|*
name|b
init|=
name|current_binding_level
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
for|for
control|(
name|t
operator|=
name|b
operator|->
name|names
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
operator|==
name|name
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|b
operator|->
name|keep
operator|==
literal|2
condition|)
name|b
operator|=
name|b
operator|->
name|level_chain
expr_stmt|;
else|else
break|break;
block|}
name|out
label|:
empty_stmt|;
block|}
return|return
name|t
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Arrange for the user to get a source line number, even when the    compiler is going down in flames, so that she at least has a    chance of working around problems in the compiler.  We used to    call error(), but that let the segmentation fault continue    through; now, it's much more passive by asking them to send the    maintainers mail about the problem.  */
end_comment

begin_function
specifier|static
name|void
name|signal_catch
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|signal
argument_list|(
name|SIGSEGV
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGIOT
name|signal
argument_list|(
name|SIGIOT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGILL
name|signal
argument_list|(
name|SIGILL
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGABRT
name|signal
argument_list|(
name|SIGABRT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGBUS
name|signal
argument_list|(
name|SIGBUS
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|my_friendly_abort
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Array for holding types considered "built-in".  These types    are output in the module in which `main' is defined.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
modifier|*
name|builtin_type_tdescs_arr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|builtin_type_tdescs_len
decl_stmt|,
name|builtin_type_tdescs_max
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Push the declarations of builtin types into the namespace.    RID_INDEX, if< RID_MAX is the index of the builtin type    in the array RID_POINTERS.  NAME is the name used when looking    up the builtin type.  TYPE is the _TYPE node for the builtin type.  */
end_comment

begin_function
specifier|static
name|void
name|record_builtin_type
parameter_list|(
name|rid_index
parameter_list|,
name|name
parameter_list|,
name|type
parameter_list|)
name|enum
name|rid
name|rid_index
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|rname
init|=
name|NULL_TREE
decl_stmt|,
name|tname
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|tdecl
decl_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|rid_index
operator|<
operator|(
name|int
operator|)
name|RID_MAX
condition|)
name|rname
operator|=
name|ridpointers
index|[
operator|(
name|int
operator|)
name|rid_index
index|]
expr_stmt|;
if|if
condition|(
name|name
condition|)
name|tname
operator|=
name|get_identifier
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|TYPE_BUILT_IN
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|tname
condition|)
block|{
if|#
directive|if
literal|0
comment|/* not yet, should get fixed properly later */
block|tdecl = pushdecl (make_type_decl (tname, type));
else|#
directive|else
name|tdecl
operator|=
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|tname
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|set_identifier_type_value
argument_list|(
name|tname
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|rid_index
operator|<
operator|(
name|int
operator|)
name|RID_MAX
condition|)
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|tname
argument_list|)
operator|=
name|tdecl
expr_stmt|;
block|}
if|if
condition|(
name|rname
operator|!=
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|tname
operator|!=
name|NULL_TREE
condition|)
block|{
name|set_identifier_type_value
argument_list|(
name|rname
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|rname
argument_list|)
operator|=
name|tdecl
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
literal|0
comment|/* not yet, should get fixed properly later */
block|tdecl = pushdecl (make_type_decl (rname, type));
else|#
directive|else
name|tdecl
operator|=
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|rname
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|set_identifier_type_value
argument_list|(
name|rname
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|flag_dossier
condition|)
block|{
if|if
condition|(
name|builtin_type_tdescs_len
operator|+
literal|5
operator|>=
name|builtin_type_tdescs_max
condition|)
block|{
name|builtin_type_tdescs_max
operator|*=
literal|2
expr_stmt|;
name|builtin_type_tdescs_arr
operator|=
operator|(
name|tree
operator|*
operator|)
name|xrealloc
argument_list|(
name|builtin_type_tdescs_arr
argument_list|,
name|builtin_type_tdescs_max
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|builtin_type_tdescs_arr
index|[
name|builtin_type_tdescs_len
operator|++
index|]
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
block|{
name|builtin_type_tdescs_arr
index|[
name|builtin_type_tdescs_len
operator|++
index|]
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|builtin_type_tdescs_arr
index|[
name|builtin_type_tdescs_len
operator|++
index|]
operator|=
name|build_pointer_type
argument_list|(
name|build_type_variant
argument_list|(
name|type
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|VOID_TYPE
condition|)
block|{
name|builtin_type_tdescs_arr
index|[
name|builtin_type_tdescs_len
operator|++
index|]
operator|=
name|build_reference_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|builtin_type_tdescs_arr
index|[
name|builtin_type_tdescs_len
operator|++
index|]
operator|=
name|build_reference_type
argument_list|(
name|build_type_variant
argument_list|(
name|type
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|output_builtin_tdesc_entries
parameter_list|()
block|{
specifier|extern
name|struct
name|obstack
name|permanent_obstack
decl_stmt|;
comment|/* If there's more than one main in this file, don't crash.  */
if|if
condition|(
name|builtin_type_tdescs_arr
operator|==
literal|0
condition|)
return|return;
name|push_obstacks
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|&
name|permanent_obstack
argument_list|)
expr_stmt|;
while|while
condition|(
name|builtin_type_tdescs_len
operator|>
literal|0
condition|)
block|{
name|tree
name|type
init|=
name|builtin_type_tdescs_arr
index|[
operator|--
name|builtin_type_tdescs_len
index|]
decl_stmt|;
name|tree
name|tdesc
init|=
name|build_t_desc
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|TREE_ASM_WRITTEN
argument_list|(
name|tdesc
argument_list|)
operator|=
literal|0
expr_stmt|;
name|build_t_desc
argument_list|(
name|type
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|builtin_type_tdescs_arr
argument_list|)
expr_stmt|;
name|builtin_type_tdescs_arr
operator|=
literal|0
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Push overloaded decl, in global scope, with one argument so it    can be used as a callback from define_function.  */
end_comment

begin_function
specifier|static
name|void
name|push_overloaded_decl_1
parameter_list|(
name|x
parameter_list|)
name|tree
name|x
decl_stmt|;
block|{
name|push_overloaded_decl
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create the predefined scalar types of C,    and some nodes representing standard constants (0, 1, (void *)0).    Initialize the global binding level.    Make definitions for built-in primitive functions.  */
end_comment

begin_function
name|void
name|init_decl_processing
parameter_list|()
block|{
name|tree
name|decl
decl_stmt|;
specifier|register
name|tree
name|endlink
decl_stmt|,
name|int_endlink
decl_stmt|,
name|double_endlink
decl_stmt|,
name|ptr_endlink
decl_stmt|;
name|tree
name|fields
index|[
literal|20
index|]
decl_stmt|;
comment|/* Either char* or void*.  */
name|tree
name|traditional_ptr_type_node
decl_stmt|;
comment|/* Data type of memcpy.  */
name|tree
name|memcpy_ftype
decl_stmt|;
if|#
directive|if
literal|0
comment|/* Not yet.  */
comment|/* Data type of strncpy.  */
block|tree strncpy_ftype;
endif|#
directive|endif
name|int
name|wchar_type_size
decl_stmt|;
name|tree
name|temp
decl_stmt|;
name|tree
name|array_domain_type
decl_stmt|;
comment|/* Have to make these distinct before we try using them.  */
name|lang_name_cplusplus
operator|=
name|get_identifier
argument_list|(
literal|"C++"
argument_list|)
expr_stmt|;
name|lang_name_c
operator|=
name|get_identifier
argument_list|(
literal|"C"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_ansi
operator|||
name|pedantic
condition|)
name|strict_prototypes_lang_c
operator|=
name|strict_prototypes_lang_cplusplus
expr_stmt|;
comment|/* Initially, C.  */
name|current_lang_name
operator|=
name|lang_name_c
expr_stmt|;
name|current_function_decl
operator|=
name|NULL_TREE
expr_stmt|;
name|named_labels
operator|=
name|NULL_TREE
expr_stmt|;
name|named_label_uses
operator|=
name|NULL_TREE
expr_stmt|;
name|current_binding_level
operator|=
name|NULL_BINDING_LEVEL
expr_stmt|;
name|free_binding_level
operator|=
name|NULL_BINDING_LEVEL
expr_stmt|;
comment|/* Because most segmentation signals can be traced back into user      code, catch them and at least give the user a chance of working      around compiler bugs. */
name|signal
argument_list|(
name|SIGSEGV
argument_list|,
name|signal_catch
argument_list|)
expr_stmt|;
comment|/* We will also catch aborts in the back-end through signal_catch and      give the user a chance to see where the error might be, and to defeat      aborts in the back-end when there have been errors previously in their      code. */
ifdef|#
directive|ifdef
name|SIGIOT
name|signal
argument_list|(
name|SIGIOT
argument_list|,
name|signal_catch
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGILL
name|signal
argument_list|(
name|SIGILL
argument_list|,
name|signal_catch
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGABRT
name|signal
argument_list|(
name|SIGABRT
argument_list|,
name|signal_catch
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGBUS
name|signal
argument_list|(
name|SIGBUS
argument_list|,
name|signal_catch
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|gcc_obstack_init
argument_list|(
operator|&
name|decl_obstack
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_dossier
condition|)
block|{
name|builtin_type_tdescs_max
operator|=
literal|100
expr_stmt|;
name|builtin_type_tdescs_arr
operator|=
operator|(
name|tree
operator|*
operator|)
name|xmalloc
argument_list|(
literal|100
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Must lay these out before anything else gets laid out.  */
name|error_mark_node
operator|=
name|make_node
argument_list|(
name|ERROR_MARK
argument_list|)
expr_stmt|;
name|TREE_PERMANENT
argument_list|(
name|error_mark_node
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|error_mark_node
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|error_mark_list
operator|=
name|build_tree_list
argument_list|(
name|error_mark_node
argument_list|,
name|error_mark_node
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|error_mark_list
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
comment|/* Make the binding_level structure for global names.  */
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|global_binding_level
operator|=
name|current_binding_level
expr_stmt|;
name|this_identifier
operator|=
name|get_identifier
argument_list|(
name|THIS_NAME
argument_list|)
expr_stmt|;
name|in_charge_identifier
operator|=
name|get_identifier
argument_list|(
name|IN_CHARGE_NAME
argument_list|)
expr_stmt|;
name|pfn_identifier
operator|=
name|get_identifier
argument_list|(
name|VTABLE_PFN_NAME
argument_list|)
expr_stmt|;
name|index_identifier
operator|=
name|get_identifier
argument_list|(
name|VTABLE_INDEX_NAME
argument_list|)
expr_stmt|;
name|delta_identifier
operator|=
name|get_identifier
argument_list|(
name|VTABLE_DELTA_NAME
argument_list|)
expr_stmt|;
name|delta2_identifier
operator|=
name|get_identifier
argument_list|(
name|VTABLE_DELTA2_NAME
argument_list|)
expr_stmt|;
name|pfn_or_delta2_identifier
operator|=
name|get_identifier
argument_list|(
literal|"__pfn_or_delta2"
argument_list|)
expr_stmt|;
comment|/* Define `int' and `char' first so that dbx will output them first.  */
name|integer_type_node
operator|=
name|make_signed_type
argument_list|(
name|INT_TYPE_SIZE
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_INT
argument_list|,
name|NULL_PTR
argument_list|,
name|integer_type_node
argument_list|)
expr_stmt|;
comment|/* Define `char', which is like either `signed char' or `unsigned char'      but not the same as either.  */
name|char_type_node
operator|=
operator|(
name|flag_signed_char
condition|?
name|make_signed_type
argument_list|(
name|CHAR_TYPE_SIZE
argument_list|)
else|:
name|make_unsigned_type
argument_list|(
name|CHAR_TYPE_SIZE
argument_list|)
operator|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_CHAR
argument_list|,
literal|"char"
argument_list|,
name|char_type_node
argument_list|)
expr_stmt|;
name|long_integer_type_node
operator|=
name|make_signed_type
argument_list|(
name|LONG_TYPE_SIZE
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_LONG
argument_list|,
literal|"long int"
argument_list|,
name|long_integer_type_node
argument_list|)
expr_stmt|;
name|unsigned_type_node
operator|=
name|make_unsigned_type
argument_list|(
name|INT_TYPE_SIZE
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_UNSIGNED
argument_list|,
literal|"unsigned int"
argument_list|,
name|unsigned_type_node
argument_list|)
expr_stmt|;
name|long_unsigned_type_node
operator|=
name|make_unsigned_type
argument_list|(
name|LONG_TYPE_SIZE
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
literal|"long unsigned int"
argument_list|,
name|long_unsigned_type_node
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
literal|"unsigned long"
argument_list|,
name|long_unsigned_type_node
argument_list|)
expr_stmt|;
name|long_long_integer_type_node
operator|=
name|make_signed_type
argument_list|(
name|LONG_LONG_TYPE_SIZE
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
literal|"long long int"
argument_list|,
name|long_long_integer_type_node
argument_list|)
expr_stmt|;
name|long_long_unsigned_type_node
operator|=
name|make_unsigned_type
argument_list|(
name|LONG_LONG_TYPE_SIZE
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
literal|"long long unsigned int"
argument_list|,
name|long_long_unsigned_type_node
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
literal|"long long unsigned"
argument_list|,
name|long_long_unsigned_type_node
argument_list|)
expr_stmt|;
comment|/* `unsigned long' is the standard type for sizeof.      Traditionally, use a signed type.      Note that stddef.h uses `unsigned long',      and this must agree, even of long and int are the same size.  */
name|sizetype
operator|=
name|TREE_TYPE
argument_list|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|get_identifier
argument_list|(
name|SIZE_TYPE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_traditional
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|sizetype
argument_list|)
condition|)
name|sizetype
operator|=
name|signed_type
argument_list|(
name|sizetype
argument_list|)
expr_stmt|;
name|ptrdiff_type_node
operator|=
name|TREE_TYPE
argument_list|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|get_identifier
argument_list|(
name|PTRDIFF_TYPE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|)
operator|=
name|sizetype
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|char_type_node
argument_list|)
argument_list|)
operator|=
name|sizetype
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|unsigned_type_node
argument_list|)
argument_list|)
operator|=
name|sizetype
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|long_unsigned_type_node
argument_list|)
argument_list|)
operator|=
name|sizetype
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|long_integer_type_node
argument_list|)
argument_list|)
operator|=
name|sizetype
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|long_long_integer_type_node
argument_list|)
argument_list|)
operator|=
name|sizetype
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|long_long_unsigned_type_node
argument_list|)
argument_list|)
operator|=
name|sizetype
expr_stmt|;
name|short_integer_type_node
operator|=
name|make_signed_type
argument_list|(
name|SHORT_TYPE_SIZE
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_SHORT
argument_list|,
literal|"short int"
argument_list|,
name|short_integer_type_node
argument_list|)
expr_stmt|;
name|short_unsigned_type_node
operator|=
name|make_unsigned_type
argument_list|(
name|SHORT_TYPE_SIZE
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
literal|"short unsigned int"
argument_list|,
name|short_unsigned_type_node
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
literal|"unsigned short"
argument_list|,
name|short_unsigned_type_node
argument_list|)
expr_stmt|;
comment|/* Define both `signed char' and `unsigned char'.  */
name|signed_char_type_node
operator|=
name|make_signed_type
argument_list|(
name|CHAR_TYPE_SIZE
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
literal|"signed char"
argument_list|,
name|signed_char_type_node
argument_list|)
expr_stmt|;
name|unsigned_char_type_node
operator|=
name|make_unsigned_type
argument_list|(
name|CHAR_TYPE_SIZE
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
literal|"unsigned char"
argument_list|,
name|unsigned_char_type_node
argument_list|)
expr_stmt|;
comment|/* These are types that type_for_size and type_for_mode use.  */
name|intQI_type_node
operator|=
name|make_signed_type
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|QImode
argument_list|)
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|intQI_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|intHI_type_node
operator|=
name|make_signed_type
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|HImode
argument_list|)
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|intHI_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|intSI_type_node
operator|=
name|make_signed_type
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|SImode
argument_list|)
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|intSI_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|intDI_type_node
operator|=
name|make_signed_type
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|DImode
argument_list|)
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|intDI_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|unsigned_intQI_type_node
operator|=
name|make_unsigned_type
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|QImode
argument_list|)
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|unsigned_intQI_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|unsigned_intHI_type_node
operator|=
name|make_unsigned_type
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|HImode
argument_list|)
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|unsigned_intHI_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|unsigned_intSI_type_node
operator|=
name|make_unsigned_type
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|SImode
argument_list|)
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|unsigned_intSI_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|unsigned_intDI_type_node
operator|=
name|make_unsigned_type
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|DImode
argument_list|)
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|unsigned_intDI_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|float_type_node
operator|=
name|make_node
argument_list|(
name|REAL_TYPE
argument_list|)
expr_stmt|;
name|TYPE_PRECISION
argument_list|(
name|float_type_node
argument_list|)
operator|=
name|FLOAT_TYPE_SIZE
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_FLOAT
argument_list|,
name|NULL_PTR
argument_list|,
name|float_type_node
argument_list|)
expr_stmt|;
name|layout_type
argument_list|(
name|float_type_node
argument_list|)
expr_stmt|;
name|double_type_node
operator|=
name|make_node
argument_list|(
name|REAL_TYPE
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_short_double
condition|)
name|TYPE_PRECISION
argument_list|(
name|double_type_node
argument_list|)
operator|=
name|FLOAT_TYPE_SIZE
expr_stmt|;
else|else
name|TYPE_PRECISION
argument_list|(
name|double_type_node
argument_list|)
operator|=
name|DOUBLE_TYPE_SIZE
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_DOUBLE
argument_list|,
name|NULL_PTR
argument_list|,
name|double_type_node
argument_list|)
expr_stmt|;
name|layout_type
argument_list|(
name|double_type_node
argument_list|)
expr_stmt|;
name|long_double_type_node
operator|=
name|make_node
argument_list|(
name|REAL_TYPE
argument_list|)
expr_stmt|;
name|TYPE_PRECISION
argument_list|(
name|long_double_type_node
argument_list|)
operator|=
name|LONG_DOUBLE_TYPE_SIZE
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
literal|"long double"
argument_list|,
name|long_double_type_node
argument_list|)
expr_stmt|;
name|layout_type
argument_list|(
name|long_double_type_node
argument_list|)
expr_stmt|;
name|integer_zero_node
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|integer_zero_node
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
name|integer_one_node
operator|=
name|build_int_2
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|integer_one_node
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
name|integer_two_node
operator|=
name|build_int_2
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|integer_two_node
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
name|integer_three_node
operator|=
name|build_int_2
argument_list|(
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|integer_three_node
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
name|bool_type_node
operator|=
name|make_unsigned_type
argument_list|(
name|CHAR_TYPE_SIZE
argument_list|)
expr_stmt|;
name|TREE_SET_CODE
argument_list|(
name|bool_type_node
argument_list|,
name|BOOLEAN_TYPE
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_BOOL
argument_list|,
literal|"bool"
argument_list|,
name|bool_type_node
argument_list|)
expr_stmt|;
name|false_node
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|false_node
argument_list|)
operator|=
name|bool_type_node
expr_stmt|;
name|true_node
operator|=
name|build_int_2
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|true_node
argument_list|)
operator|=
name|bool_type_node
expr_stmt|;
comment|/* These are needed by stor-layout.c.  */
name|size_zero_node
operator|=
name|size_int
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|size_one_node
operator|=
name|size_int
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|void_type_node
operator|=
name|make_node
argument_list|(
name|VOID_TYPE
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_VOID
argument_list|,
name|NULL_PTR
argument_list|,
name|void_type_node
argument_list|)
expr_stmt|;
name|layout_type
argument_list|(
name|void_type_node
argument_list|)
expr_stmt|;
comment|/* Uses integer_zero_node.  */
name|void_list_node
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|void_type_node
argument_list|)
expr_stmt|;
name|TREE_PARMLIST
argument_list|(
name|void_list_node
argument_list|)
operator|=
literal|1
expr_stmt|;
name|null_pointer_node
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|null_pointer_node
argument_list|)
operator|=
name|build_pointer_type
argument_list|(
name|void_type_node
argument_list|)
expr_stmt|;
name|layout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|null_pointer_node
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Used for expressions that do nothing, but are not errors.  */
name|void_zero_node
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|void_zero_node
argument_list|)
operator|=
name|void_type_node
expr_stmt|;
name|string_type_node
operator|=
name|build_pointer_type
argument_list|(
name|char_type_node
argument_list|)
expr_stmt|;
name|const_string_type_node
operator|=
name|build_pointer_type
argument_list|(
name|build_type_variant
argument_list|(
name|char_type_node
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
name|NULL_PTR
argument_list|,
name|string_type_node
argument_list|)
expr_stmt|;
comment|/* Make a type to be the domain of a few array types      whose domains don't really matter.      200 is small enough that it always fits in size_t      and large enough that it can hold most function names for the      initializations of __FUNCTION__ and __PRETTY_FUNCTION__.  */
name|array_domain_type
operator|=
name|build_index_type
argument_list|(
name|build_int_2
argument_list|(
literal|200
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* make a type for arrays of characters.      With luck nothing will ever really depend on the length of this      array type.  */
name|char_array_type_node
operator|=
name|build_array_type
argument_list|(
name|char_type_node
argument_list|,
name|array_domain_type
argument_list|)
expr_stmt|;
comment|/* Likewise for arrays of ints.  */
name|int_array_type_node
operator|=
name|build_array_type
argument_list|(
name|integer_type_node
argument_list|,
name|array_domain_type
argument_list|)
expr_stmt|;
comment|/* This is just some anonymous class type.  Nobody should ever      need to look inside this envelope.  */
name|class_star_type_node
operator|=
name|build_pointer_type
argument_list|(
name|make_lang_type
argument_list|(
name|RECORD_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|default_function_type
operator|=
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|build_pointer_type
argument_list|(
name|default_function_type
argument_list|)
expr_stmt|;
name|ptr_type_node
operator|=
name|build_pointer_type
argument_list|(
name|void_type_node
argument_list|)
expr_stmt|;
name|const_ptr_type_node
operator|=
name|build_pointer_type
argument_list|(
name|build_type_variant
argument_list|(
name|void_type_node
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
name|NULL_PTR
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
name|endlink
operator|=
name|void_list_node
expr_stmt|;
name|int_endlink
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|endlink
argument_list|)
expr_stmt|;
name|double_endlink
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|double_type_node
argument_list|,
name|endlink
argument_list|)
expr_stmt|;
name|ptr_endlink
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|endlink
argument_list|)
expr_stmt|;
name|double_ftype_double
operator|=
name|build_function_type
argument_list|(
name|double_type_node
argument_list|,
name|double_endlink
argument_list|)
expr_stmt|;
name|double_ftype_double_double
operator|=
name|build_function_type
argument_list|(
name|double_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|double_type_node
argument_list|,
name|double_endlink
argument_list|)
argument_list|)
expr_stmt|;
name|int_ftype_int
operator|=
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|int_endlink
argument_list|)
expr_stmt|;
name|long_ftype_long
operator|=
name|build_function_type
argument_list|(
name|long_integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|long_integer_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
expr_stmt|;
name|void_ftype_ptr_ptr_int
operator|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|int_endlink
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|int_ftype_cptr_cptr_sizet
operator|=
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|const_ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|const_ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|sizetype
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|void_ftype_ptr_int_int
operator|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|int_endlink
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|string_ftype_ptr_ptr
comment|/* strcpy prototype */
operator|=
name|build_function_type
argument_list|(
name|string_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|string_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|const_string_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Not yet.  */
block|strncpy_ftype
comment|/* strncpy prototype */
block|= build_function_type (string_type_node, 			   tree_cons (NULL_TREE, string_type_node, 				      tree_cons (NULL_TREE, const_string_type_node, 						 tree_cons (NULL_TREE, 							    sizetype, 							    endlink))));
endif|#
directive|endif
name|int_ftype_string_string
comment|/* strcmp prototype */
operator|=
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|const_string_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|const_string_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|sizet_ftype_string
comment|/* strlen prototype */
operator|=
name|build_function_type
argument_list|(
name|sizetype
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|const_string_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
expr_stmt|;
name|traditional_ptr_type_node
operator|=
operator|(
name|flag_traditional
condition|?
name|string_type_node
else|:
name|ptr_type_node
operator|)
expr_stmt|;
name|memcpy_ftype
comment|/* memcpy prototype */
operator|=
name|build_function_type
argument_list|(
name|traditional_ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|const_ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|sizetype
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_huge_objects
condition|)
name|delta_type_node
operator|=
name|long_integer_type_node
expr_stmt|;
else|else
name|delta_type_node
operator|=
name|short_integer_type_node
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_constant_p"
argument_list|,
name|int_ftype_int
argument_list|,
name|BUILT_IN_CONSTANT_P
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_return_address_fndecl
operator|=
name|builtin_function
argument_list|(
literal|"__builtin_return_address"
argument_list|,
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|unsigned_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|,
name|BUILT_IN_RETURN_ADDRESS
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_frame_address"
argument_list|,
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|unsigned_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|,
name|BUILT_IN_FRAME_ADDRESS
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_alloca"
argument_list|,
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|sizetype
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|,
name|BUILT_IN_ALLOCA
argument_list|,
literal|"alloca"
argument_list|)
expr_stmt|;
comment|/* Define alloca, ffs as builtins.      Declare _exit just to mark it as volatile.  */
if|if
condition|(
operator|!
name|flag_no_builtin
operator|&&
operator|!
name|flag_no_nonansi_builtin
condition|)
block|{
name|temp
operator|=
name|builtin_function
argument_list|(
literal|"alloca"
argument_list|,
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|sizetype
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|,
name|BUILT_IN_ALLOCA
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
comment|/* Suppress error if redefined as a non-function.  */
name|DECL_BUILT_IN_NONANSI
argument_list|(
name|temp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|temp
operator|=
name|builtin_function
argument_list|(
literal|"ffs"
argument_list|,
name|int_ftype_int
argument_list|,
name|BUILT_IN_FFS
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
comment|/* Suppress error if redefined as a non-function.  */
name|DECL_BUILT_IN_NONANSI
argument_list|(
name|temp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|temp
operator|=
name|builtin_function
argument_list|(
literal|"_exit"
argument_list|,
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|int_endlink
argument_list|)
argument_list|,
name|NOT_BUILT_IN
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|temp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|temp
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Suppress error if redefined as a non-function.  */
name|DECL_BUILT_IN_NONANSI
argument_list|(
name|temp
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|builtin_function
argument_list|(
literal|"__builtin_abs"
argument_list|,
name|int_ftype_int
argument_list|,
name|BUILT_IN_ABS
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_fabs"
argument_list|,
name|double_ftype_double
argument_list|,
name|BUILT_IN_FABS
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_labs"
argument_list|,
name|long_ftype_long
argument_list|,
name|BUILT_IN_LABS
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_ffs"
argument_list|,
name|int_ftype_int
argument_list|,
name|BUILT_IN_FFS
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_fsqrt"
argument_list|,
name|double_ftype_double
argument_list|,
name|BUILT_IN_FSQRT
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_sin"
argument_list|,
name|double_ftype_double
argument_list|,
name|BUILT_IN_SIN
argument_list|,
literal|"sin"
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_cos"
argument_list|,
name|double_ftype_double
argument_list|,
name|BUILT_IN_COS
argument_list|,
literal|"cos"
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_saveregs"
argument_list|,
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|,
name|BUILT_IN_SAVEREGS
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
comment|/* EXPAND_BUILTIN_VARARGS is obsolete.  */
if|#
directive|if
literal|0
block|builtin_function ("__builtin_varargs", 		    build_function_type (ptr_type_node, 					 tree_cons (NULL_TREE, 						    integer_type_node, 						    endlink)), 		    BUILT_IN_VARARGS, NULL_PTR);
endif|#
directive|endif
name|builtin_function
argument_list|(
literal|"__builtin_classify_type"
argument_list|,
name|default_function_type
argument_list|,
name|BUILT_IN_CLASSIFY_TYPE
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_next_arg"
argument_list|,
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|,
name|BUILT_IN_NEXT_ARG
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_args_info"
argument_list|,
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|,
name|BUILT_IN_ARGS_INFO
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
comment|/* Untyped call and return.  */
name|builtin_function
argument_list|(
literal|"__builtin_apply_args"
argument_list|,
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|,
name|BUILT_IN_APPLY_ARGS
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|temp
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_pointer_type
argument_list|(
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|sizetype
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_apply"
argument_list|,
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|temp
argument_list|)
argument_list|,
name|BUILT_IN_APPLY
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_return"
argument_list|,
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|,
name|BUILT_IN_RETURN
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
comment|/* Currently under experimentation.  */
name|builtin_function
argument_list|(
literal|"__builtin_memcpy"
argument_list|,
name|memcpy_ftype
argument_list|,
name|BUILT_IN_MEMCPY
argument_list|,
literal|"memcpy"
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_memcmp"
argument_list|,
name|int_ftype_cptr_cptr_sizet
argument_list|,
name|BUILT_IN_MEMCMP
argument_list|,
literal|"memcmp"
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_strcmp"
argument_list|,
name|int_ftype_string_string
argument_list|,
name|BUILT_IN_STRCMP
argument_list|,
literal|"strcmp"
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_strcpy"
argument_list|,
name|string_ftype_ptr_ptr
argument_list|,
name|BUILT_IN_STRCPY
argument_list|,
literal|"strcpy"
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Not yet.  */
block|builtin_function ("__builtin_strncpy", strncpy_ftype, 		    BUILT_IN_STRNCPY, "strncpy");
endif|#
directive|endif
name|builtin_function
argument_list|(
literal|"__builtin_strlen"
argument_list|,
name|sizet_ftype_string
argument_list|,
name|BUILT_IN_STRLEN
argument_list|,
literal|"strlen"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flag_no_builtin
condition|)
block|{
if|#
directive|if
literal|0
comment|/* These do not work well with libg++.  */
block|builtin_function ("abs", int_ftype_int, BUILT_IN_ABS, NULL_PTR);       builtin_function ("fabs", double_ftype_double, BUILT_IN_FABS, NULL_PTR);       builtin_function ("labs", long_ftype_long, BUILT_IN_LABS, NULL_PTR);
endif|#
directive|endif
name|builtin_function
argument_list|(
literal|"memcpy"
argument_list|,
name|memcpy_ftype
argument_list|,
name|BUILT_IN_MEMCPY
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"memcmp"
argument_list|,
name|int_ftype_cptr_cptr_sizet
argument_list|,
name|BUILT_IN_MEMCMP
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"strcmp"
argument_list|,
name|int_ftype_string_string
argument_list|,
name|BUILT_IN_STRCMP
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"strcpy"
argument_list|,
name|string_ftype_ptr_ptr
argument_list|,
name|BUILT_IN_STRCPY
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Not yet.  */
block|builtin_function ("strncpy", strncpy_ftype, BUILT_IN_STRNCPY, NULL_PTR);
endif|#
directive|endif
name|builtin_function
argument_list|(
literal|"strlen"
argument_list|,
name|sizet_ftype_string
argument_list|,
name|BUILT_IN_STRLEN
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"sin"
argument_list|,
name|double_ftype_double
argument_list|,
name|BUILT_IN_SIN
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"cos"
argument_list|,
name|double_ftype_double
argument_list|,
name|BUILT_IN_COS
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
comment|/* Declare these functions volatile 	 to avoid spurious "control drops through" warnings.  */
name|temp
operator|=
name|builtin_function
argument_list|(
literal|"abort"
argument_list|,
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|,
name|NOT_BUILT_IN
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|temp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|temp
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Well, these are actually ANSI, but we can't set DECL_BUILT_IN on          them...  */
name|DECL_BUILT_IN_NONANSI
argument_list|(
name|temp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|temp
operator|=
name|builtin_function
argument_list|(
literal|"exit"
argument_list|,
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|int_endlink
argument_list|)
argument_list|,
name|NOT_BUILT_IN
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|temp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|temp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_BUILT_IN_NONANSI
argument_list|(
name|temp
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* Support for these has not been written in either expand_builtin      or build_function_call.  */
block|builtin_function ("__builtin_div", default_ftype, BUILT_IN_DIV, 0);   builtin_function ("__builtin_ldiv", default_ftype, BUILT_IN_LDIV, 0);   builtin_function ("__builtin_ffloor", double_ftype_double, BUILT_IN_FFLOOR, 		    0);   builtin_function ("__builtin_fceil", double_ftype_double, BUILT_IN_FCEIL, 0);   builtin_function ("__builtin_fmod", double_ftype_double_double, 		    BUILT_IN_FMOD, 0);   builtin_function ("__builtin_frem", double_ftype_double_double, 		    BUILT_IN_FREM, 0);   builtin_function ("__builtin_memset", ptr_ftype_ptr_int_int, BUILT_IN_MEMSET, 		    0);   builtin_function ("__builtin_getexp", double_ftype_double, BUILT_IN_GETEXP, 		    0);   builtin_function ("__builtin_getman", double_ftype_double, BUILT_IN_GETMAN, 		    0);
endif|#
directive|endif
comment|/* C++ extensions */
name|unknown_type_node
operator|=
name|make_node
argument_list|(
name|UNKNOWN_TYPE
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* not yet, should get fixed properly later */
block|pushdecl (make_type_decl (get_identifier ("unknown type"), 		       unknown_type_node));
else|#
directive|else
name|decl
operator|=
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"unknown type"
argument_list|)
argument_list|,
name|unknown_type_node
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make sure the "unknown type" typedecl gets ignored for debug info.  */
name|DECL_IGNORED_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_DECL_SUPPRESS_DEBUG
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|TYPE_SIZE
argument_list|(
name|unknown_type_node
argument_list|)
operator|=
name|TYPE_SIZE
argument_list|(
name|void_type_node
argument_list|)
expr_stmt|;
name|TYPE_ALIGN
argument_list|(
name|unknown_type_node
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_MODE
argument_list|(
name|unknown_type_node
argument_list|)
operator|=
name|TYPE_MODE
argument_list|(
name|void_type_node
argument_list|)
expr_stmt|;
comment|/* Indirecting an UNKNOWN_TYPE node yields an UNKNOWN_TYPE node.  */
name|TREE_TYPE
argument_list|(
name|unknown_type_node
argument_list|)
operator|=
name|unknown_type_node
expr_stmt|;
comment|/* Looking up TYPE_POINTER_TO and TYPE_REFERENCE_TO yield the same result. */
name|TYPE_POINTER_TO
argument_list|(
name|unknown_type_node
argument_list|)
operator|=
name|unknown_type_node
expr_stmt|;
name|TYPE_REFERENCE_TO
argument_list|(
name|unknown_type_node
argument_list|)
operator|=
name|unknown_type_node
expr_stmt|;
comment|/* This is for handling opaque types in signatures.  */
name|opaque_type_node
operator|=
name|copy_node
argument_list|(
name|ptr_type_node
argument_list|)
expr_stmt|;
name|TYPE_MAIN_VARIANT
argument_list|(
name|opaque_type_node
argument_list|)
operator|=
name|opaque_type_node
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
literal|0
argument_list|,
name|opaque_type_node
argument_list|)
expr_stmt|;
comment|/* This is special for C++ so functions can be overloaded. */
name|wchar_type_node
operator|=
name|TREE_TYPE
argument_list|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|get_identifier
argument_list|(
name|WCHAR_TYPE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|wchar_type_size
operator|=
name|TYPE_PRECISION
argument_list|(
name|wchar_type_node
argument_list|)
expr_stmt|;
name|signed_wchar_type_node
operator|=
name|make_signed_type
argument_list|(
name|wchar_type_size
argument_list|)
expr_stmt|;
name|unsigned_wchar_type_node
operator|=
name|make_unsigned_type
argument_list|(
name|wchar_type_size
argument_list|)
expr_stmt|;
name|wchar_type_node
operator|=
name|TREE_UNSIGNED
argument_list|(
name|wchar_type_node
argument_list|)
condition|?
name|unsigned_wchar_type_node
else|:
name|signed_wchar_type_node
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_WCHAR
argument_list|,
literal|"__wchar_t"
argument_list|,
name|wchar_type_node
argument_list|)
expr_stmt|;
comment|/* Artificial declaration of wchar_t -- can be bashed */
name|wchar_decl_node
operator|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"wchar_t"
argument_list|)
argument_list|,
name|wchar_type_node
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|wchar_decl_node
argument_list|)
expr_stmt|;
comment|/* This is for wide string constants.  */
name|wchar_array_type_node
operator|=
name|build_array_type
argument_list|(
name|wchar_type_node
argument_list|,
name|array_domain_type
argument_list|)
expr_stmt|;
comment|/* This is a hack that should go away when we deliver the      real gc code.  */
if|if
condition|(
name|flag_gc
condition|)
block|{
name|builtin_function
argument_list|(
literal|"__gc_main"
argument_list|,
name|default_function_type
argument_list|,
name|NOT_BUILT_IN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|lookup_name
argument_list|(
name|get_identifier
argument_list|(
literal|"__gc_main"
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_vtable_thunks
condition|)
block|{
comment|/* Make sure we get a unique function type, so we can give 	 its pointer type a name.  (This wins for gdb.) */
name|tree
name|vfunc_type
init|=
name|make_node
argument_list|(
name|FUNCTION_TYPE
argument_list|)
decl_stmt|;
name|TREE_TYPE
argument_list|(
name|vfunc_type
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
name|TYPE_ARG_TYPES
argument_list|(
name|vfunc_type
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|layout_type
argument_list|(
name|vfunc_type
argument_list|)
expr_stmt|;
name|vtable_entry_type
operator|=
name|build_pointer_type
argument_list|(
name|vfunc_type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vtable_entry_type
operator|=
name|make_lang_type
argument_list|(
name|RECORD_TYPE
argument_list|)
expr_stmt|;
name|fields
index|[
literal|0
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|delta_identifier
argument_list|,
name|delta_type_node
argument_list|)
expr_stmt|;
name|fields
index|[
literal|1
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|index_identifier
argument_list|,
name|delta_type_node
argument_list|)
expr_stmt|;
name|fields
index|[
literal|2
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|pfn_identifier
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
name|finish_builtin_type
argument_list|(
name|vtable_entry_type
argument_list|,
name|VTBL_PTR_TYPE
argument_list|,
name|fields
argument_list|,
literal|2
argument_list|,
name|double_type_node
argument_list|)
expr_stmt|;
comment|/* Make this part of an invisible union.  */
name|fields
index|[
literal|3
index|]
operator|=
name|copy_node
argument_list|(
name|fields
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|fields
index|[
literal|3
index|]
argument_list|)
operator|=
name|delta_type_node
expr_stmt|;
name|DECL_NAME
argument_list|(
name|fields
index|[
literal|3
index|]
argument_list|)
operator|=
name|delta2_identifier
expr_stmt|;
name|DECL_MODE
argument_list|(
name|fields
index|[
literal|3
index|]
argument_list|)
operator|=
name|TYPE_MODE
argument_list|(
name|delta_type_node
argument_list|)
expr_stmt|;
name|DECL_SIZE
argument_list|(
name|fields
index|[
literal|3
index|]
argument_list|)
operator|=
name|TYPE_SIZE
argument_list|(
name|delta_type_node
argument_list|)
expr_stmt|;
name|TREE_UNSIGNED
argument_list|(
name|fields
index|[
literal|3
index|]
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|fields
index|[
literal|2
index|]
argument_list|)
operator|=
name|fields
index|[
literal|3
index|]
expr_stmt|;
name|vtable_entry_type
operator|=
name|build_type_variant
argument_list|(
name|vtable_entry_type
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
name|VTBL_PTR_TYPE
argument_list|,
name|vtable_entry_type
argument_list|)
expr_stmt|;
name|vtbl_type_node
operator|=
name|build_array_type
argument_list|(
name|vtable_entry_type
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|layout_type
argument_list|(
name|vtbl_type_node
argument_list|)
expr_stmt|;
name|vtbl_type_node
operator|=
name|cp_build_type_variant
argument_list|(
name|vtbl_type_node
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
name|NULL_PTR
argument_list|,
name|vtbl_type_node
argument_list|)
expr_stmt|;
comment|/* Simplify life by making a "sigtable_entry_type".  Give its      fields names so that the debugger can use them.  */
if|if
condition|(
name|flag_handle_signatures
condition|)
block|{
name|sigtable_entry_type
operator|=
name|make_lang_type
argument_list|(
name|RECORD_TYPE
argument_list|)
expr_stmt|;
name|fields
index|[
literal|0
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
name|SIGTABLE_CODE_NAME
argument_list|)
argument_list|,
name|short_integer_type_node
argument_list|)
expr_stmt|;
name|fields
index|[
literal|1
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
name|SIGTABLE_OFFSET_NAME
argument_list|)
argument_list|,
name|short_integer_type_node
argument_list|)
expr_stmt|;
name|fields
index|[
literal|2
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
name|SIGTABLE_PFN_NAME
argument_list|)
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
name|finish_builtin_type
argument_list|(
name|sigtable_entry_type
argument_list|,
name|SIGTABLE_PTR_TYPE
argument_list|,
name|fields
argument_list|,
literal|2
argument_list|,
name|double_type_node
argument_list|)
expr_stmt|;
name|sigtable_entry_type
operator|=
name|build_type_variant
argument_list|(
name|sigtable_entry_type
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
name|SIGTABLE_PTR_TYPE
argument_list|,
name|sigtable_entry_type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_dossier
condition|)
block|{
comment|/* Must build __t_desc type.  Currently, type descriptors look like this:  	 struct __t_desc 	 {            const char *name; 	   int size; 	   int bits; 	   struct __t_desc *points_to; 	   int ivars_count, meths_count; 	   struct __i_desc *ivars[]; 	   struct __m_desc *meths[]; 	   struct __t_desc *parents[]; 	   struct __t_desc *vbases[]; 	   int offsets[]; 	 };  	 ...as per Linton's paper.  */
name|__t_desc_type_node
operator|=
name|make_lang_type
argument_list|(
name|RECORD_TYPE
argument_list|)
expr_stmt|;
name|__i_desc_type_node
operator|=
name|make_lang_type
argument_list|(
name|RECORD_TYPE
argument_list|)
expr_stmt|;
name|__m_desc_type_node
operator|=
name|make_lang_type
argument_list|(
name|RECORD_TYPE
argument_list|)
expr_stmt|;
name|__t_desc_array_type
operator|=
name|build_array_type
argument_list|(
name|TYPE_POINTER_TO
argument_list|(
name|__t_desc_type_node
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|__i_desc_array_type
operator|=
name|build_array_type
argument_list|(
name|TYPE_POINTER_TO
argument_list|(
name|__i_desc_type_node
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|__m_desc_array_type
operator|=
name|build_array_type
argument_list|(
name|TYPE_POINTER_TO
argument_list|(
name|__m_desc_type_node
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|fields
index|[
literal|0
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"name"
argument_list|)
argument_list|,
name|string_type_node
argument_list|)
expr_stmt|;
name|fields
index|[
literal|1
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"size"
argument_list|)
argument_list|,
name|unsigned_type_node
argument_list|)
expr_stmt|;
name|fields
index|[
literal|2
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"bits"
argument_list|)
argument_list|,
name|unsigned_type_node
argument_list|)
expr_stmt|;
name|fields
index|[
literal|3
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"points_to"
argument_list|)
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|__t_desc_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|fields
index|[
literal|4
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"ivars_count"
argument_list|)
argument_list|,
name|integer_type_node
argument_list|)
expr_stmt|;
name|fields
index|[
literal|5
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"meths_count"
argument_list|)
argument_list|,
name|integer_type_node
argument_list|)
expr_stmt|;
name|fields
index|[
literal|6
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"ivars"
argument_list|)
argument_list|,
name|build_pointer_type
argument_list|(
name|__i_desc_array_type
argument_list|)
argument_list|)
expr_stmt|;
name|fields
index|[
literal|7
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"meths"
argument_list|)
argument_list|,
name|build_pointer_type
argument_list|(
name|__m_desc_array_type
argument_list|)
argument_list|)
expr_stmt|;
name|fields
index|[
literal|8
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"parents"
argument_list|)
argument_list|,
name|build_pointer_type
argument_list|(
name|__t_desc_array_type
argument_list|)
argument_list|)
expr_stmt|;
name|fields
index|[
literal|9
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"vbases"
argument_list|)
argument_list|,
name|build_pointer_type
argument_list|(
name|__t_desc_array_type
argument_list|)
argument_list|)
expr_stmt|;
name|fields
index|[
literal|10
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"offsets"
argument_list|)
argument_list|,
name|build_pointer_type
argument_list|(
name|integer_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|finish_builtin_type
argument_list|(
name|__t_desc_type_node
argument_list|,
literal|"__t_desc"
argument_list|,
name|fields
argument_list|,
literal|10
argument_list|,
name|integer_type_node
argument_list|)
expr_stmt|;
comment|/* ivar descriptors look like this:  	 struct __i_desc 	 { 	   const char *name; 	   int offset; 	   struct __t_desc *type; 	 };       */
name|fields
index|[
literal|0
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"name"
argument_list|)
argument_list|,
name|string_type_node
argument_list|)
expr_stmt|;
name|fields
index|[
literal|1
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"offset"
argument_list|)
argument_list|,
name|integer_type_node
argument_list|)
expr_stmt|;
name|fields
index|[
literal|2
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"type"
argument_list|)
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|__t_desc_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|finish_builtin_type
argument_list|(
name|__i_desc_type_node
argument_list|,
literal|"__i_desc"
argument_list|,
name|fields
argument_list|,
literal|2
argument_list|,
name|integer_type_node
argument_list|)
expr_stmt|;
comment|/* method descriptors look like this:  	 struct __m_desc 	 { 	   const char *name; 	   int vindex; 	   struct __t_desc *vcontext; 	   struct __t_desc *return_type; 	   void (*address)(); 	   short parm_count; 	   short required_parms; 	   struct __t_desc *parm_types[]; 	 };       */
name|fields
index|[
literal|0
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"name"
argument_list|)
argument_list|,
name|string_type_node
argument_list|)
expr_stmt|;
name|fields
index|[
literal|1
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"vindex"
argument_list|)
argument_list|,
name|integer_type_node
argument_list|)
expr_stmt|;
name|fields
index|[
literal|2
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"vcontext"
argument_list|)
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|__t_desc_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|fields
index|[
literal|3
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"return_type"
argument_list|)
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|__t_desc_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|fields
index|[
literal|4
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"address"
argument_list|)
argument_list|,
name|build_pointer_type
argument_list|(
name|default_function_type
argument_list|)
argument_list|)
expr_stmt|;
name|fields
index|[
literal|5
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"parm_count"
argument_list|)
argument_list|,
name|short_integer_type_node
argument_list|)
expr_stmt|;
name|fields
index|[
literal|6
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"required_parms"
argument_list|)
argument_list|,
name|short_integer_type_node
argument_list|)
expr_stmt|;
name|fields
index|[
literal|7
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"parm_types"
argument_list|)
argument_list|,
name|build_pointer_type
argument_list|(
name|build_array_type
argument_list|(
name|TYPE_POINTER_TO
argument_list|(
name|__t_desc_type_node
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|finish_builtin_type
argument_list|(
name|__m_desc_type_node
argument_list|,
literal|"__m_desc"
argument_list|,
name|fields
argument_list|,
literal|7
argument_list|,
name|integer_type_node
argument_list|)
expr_stmt|;
block|}
comment|/* Now, C++.  */
name|current_lang_name
operator|=
name|lang_name_cplusplus
expr_stmt|;
if|if
condition|(
name|flag_dossier
condition|)
block|{
name|int
name|i
init|=
name|builtin_type_tdescs_len
decl_stmt|;
while|while
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|tree
name|tdesc
init|=
name|build_t_desc
argument_list|(
name|builtin_type_tdescs_arr
index|[
operator|--
name|i
index|]
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|TREE_ASM_WRITTEN
argument_list|(
name|tdesc
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|TREE_OPERAND
argument_list|(
name|tdesc
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|auto_function
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|NEW_EXPR
index|]
argument_list|,
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|sizetype
argument_list|,
name|void_list_node
argument_list|)
argument_list|)
argument_list|,
name|NOT_BUILT_IN
argument_list|)
expr_stmt|;
name|auto_function
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|VEC_NEW_EXPR
index|]
argument_list|,
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|sizetype
argument_list|,
name|void_list_node
argument_list|)
argument_list|)
argument_list|,
name|NOT_BUILT_IN
argument_list|)
expr_stmt|;
name|auto_function
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|DELETE_EXPR
index|]
argument_list|,
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|void_list_node
argument_list|)
argument_list|)
argument_list|,
name|NOT_BUILT_IN
argument_list|)
expr_stmt|;
name|auto_function
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|VEC_DELETE_EXPR
index|]
argument_list|,
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|void_list_node
argument_list|)
argument_list|)
argument_list|,
name|NOT_BUILT_IN
argument_list|)
expr_stmt|;
name|abort_fndecl
operator|=
name|define_function
argument_list|(
literal|"__pure_virtual"
argument_list|,
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|void_list_node
argument_list|)
argument_list|,
name|NOT_BUILT_IN
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Perform other language dependent initializations.  */
name|init_class_processing
argument_list|()
expr_stmt|;
name|init_init_processing
argument_list|()
expr_stmt|;
name|init_search_processing
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag_handle_exceptions
condition|)
name|init_exception_processing
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag_gc
condition|)
name|init_gc_processing
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag_no_inline
condition|)
block|{
name|flag_inline_functions
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
comment|/* This causes uneccessary emission of inline functions.  */
block|flag_default_inline = 0;
endif|#
directive|endif
block|}
if|if
condition|(
name|flag_cadillac
condition|)
name|init_cadillac
argument_list|()
expr_stmt|;
comment|/* Create the global bindings for __FUNCTION__ and __PRETTY_FUNCTION__.  */
name|declare_function_name
argument_list|()
expr_stmt|;
comment|/* Prepare to check format strings against argument lists.  */
name|init_function_format_info
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make a definition for a builtin function named NAME and whose data type    is TYPE.  TYPE should be a function type with argument types.    FUNCTION_CODE tells later passes how to compile calls to this function.    See tree.h for its possible values.     If LIBRARY_NAME is nonzero, use that for DECL_ASSEMBLER_NAME,    the name to be called if we can't opencode the function.  */
end_comment

begin_decl_stmt
name|tree
name|define_function
argument_list|(
name|name
argument_list|,
name|type
argument_list|,
name|function_code
argument_list|,
name|pfn
argument_list|,
name|library_name
argument_list|)
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|built_in_function
name|function_code
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
function_decl|(
modifier|*
name|pfn
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|char
modifier|*
name|library_name
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|tree
name|decl
init|=
name|build_lang_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|get_identifier
argument_list|(
name|name
argument_list|)
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Since `pushdecl' relies on DECL_ASSEMBLER_NAME instead of DECL_NAME,      we cannot change DECL_ASSEMBLER_NAME until we have installed this      function in the namespace.  */
if|if
condition|(
name|pfn
condition|)
call|(
modifier|*
name|pfn
call|)
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|library_name
condition|)
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
operator|=
name|get_identifier
argument_list|(
name|library_name
argument_list|)
expr_stmt|;
name|make_function_rtl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|function_code
operator|!=
name|NOT_BUILT_IN
condition|)
block|{
name|DECL_BUILT_IN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_FUNCTION_CODE
argument_list|(
name|decl
argument_list|)
operator|=
name|function_code
expr_stmt|;
block|}
return|return
name|decl
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Called when a declaration is seen that contains no names to declare.    If its type is a reference to a structure, union or enum inherited    from a containing scope, shadow that tag name for the current scope    with a forward reference.    If its type defines a new named structure or union    or defines an enum, it is valid but we need not do anything here.    Otherwise, it is an error.     C++: may have to grok the declspecs to learn about static,    complain for anonymous unions.  */
end_comment

begin_function
name|void
name|shadow_tag
parameter_list|(
name|declspecs
parameter_list|)
name|tree
name|declspecs
decl_stmt|;
block|{
name|int
name|found_tag
init|=
literal|0
decl_stmt|;
name|tree
name|ob_modifier
init|=
name|NULL_TREE
decl_stmt|;
specifier|register
name|tree
name|link
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|code
decl_stmt|,
name|ok_code
init|=
name|ERROR_MARK
decl_stmt|;
specifier|register
name|tree
name|t
init|=
name|NULL_TREE
decl_stmt|;
for|for
control|(
name|link
operator|=
name|declspecs
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
block|{
specifier|register
name|tree
name|value
init|=
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
decl_stmt|;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE_CODE
argument_list|(
name|code
argument_list|)
operator|||
name|code
operator|==
name|ENUMERAL_TYPE
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|TYPE_NAME
argument_list|(
name|value
argument_list|)
operator|!=
name|NULL_TREE
argument_list|,
literal|261
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|ENUMERAL_TYPE
operator|&&
name|TYPE_SIZE
argument_list|(
name|value
argument_list|)
operator|==
literal|0
condition|)
name|cp_error
argument_list|(
literal|"forward declaration of `%#T'"
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|t
operator|=
name|value
expr_stmt|;
name|ok_code
operator|=
name|code
expr_stmt|;
name|found_tag
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_STATIC
index|]
operator|||
name|value
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_EXTERN
index|]
operator|||
name|value
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_AUTO
index|]
operator|||
name|value
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_REGISTER
index|]
condition|)
name|ob_modifier
operator|=
name|value
expr_stmt|;
block|}
comment|/* This is where the variables in an anonymous union are      declared.  An anonymous union declaration looks like:      union { ... } ;      because there is no declarator after the union, the parser      sends that declaration here.  */
if|if
condition|(
name|ok_code
operator|==
name|UNION_TYPE
operator|&&
name|t
operator|!=
name|NULL_TREE
operator|&&
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|&&
name|ANON_AGGRNAME_P
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|ANON_AGGRNAME_P
argument_list|(
name|TYPE_IDENTIFIER
argument_list|(
name|t
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
block|{
comment|/* ANSI C++ June 5 1992 WP 9.5.3.  Anonymous unions may not have 	 function members.  */
if|if
condition|(
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|decl
init|=
name|grokdeclarator
argument_list|(
name|NULL_TREE
argument_list|,
name|declspecs
argument_list|,
name|NORMAL
argument_list|,
literal|0
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|finish_anon_union
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"anonymous union cannot have a function member"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Anonymous unions are objects, that's why we only check for 	 inappropriate specifiers in this branch.  */
if|if
condition|(
name|ob_modifier
condition|)
name|cp_error
argument_list|(
literal|"`%D' can only be specified for objects and functions"
argument_list|,
name|ob_modifier
argument_list|)
expr_stmt|;
if|if
condition|(
name|found_tag
operator|==
literal|0
condition|)
name|pedwarn
argument_list|(
literal|"abstract declarator used as declaration"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|found_tag
operator|>
literal|1
condition|)
name|pedwarn
argument_list|(
literal|"multiple types in one declaration"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Decode a "typename", such as "int **", returning a ..._TYPE node.  */
end_comment

begin_function
name|tree
name|groktypename
parameter_list|(
name|typename
parameter_list|)
name|tree
name|typename
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|typename
argument_list|)
operator|!=
name|TREE_LIST
condition|)
return|return
name|typename
return|;
return|return
name|grokdeclarator
argument_list|(
name|TREE_VALUE
argument_list|(
name|typename
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|typename
argument_list|)
argument_list|,
name|TYPENAME
argument_list|,
literal|0
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Decode a declarator in an ordinary declaration or data definition.    This is called as soon as the type information and variable name    have been parsed, before parsing the initializer if any.    Here we create the ..._DECL node, fill in its type,    and put it on the list of decls for the current context.    The ..._DECL node is returned as the value.     Exception: for arrays where the length is not specified,    the type is left null, to be filled in by `finish_decl'.     Function definitions do not come here; they go to start_function    instead.  However, external and forward declarations of functions    do go through here.  Structure field declarations are done by    grokfield and not through here.  */
end_comment

begin_comment
comment|/* Set this to zero to debug not using the temporary obstack    to parse initializers.  */
end_comment

begin_decl_stmt
name|int
name|debug_temp_inits
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_function
name|tree
name|start_decl
parameter_list|(
name|declarator
parameter_list|,
name|declspecs
parameter_list|,
name|initialized
parameter_list|,
name|raises
parameter_list|)
name|tree
name|declarator
decl_stmt|,
name|declspecs
decl_stmt|;
name|int
name|initialized
decl_stmt|;
name|tree
name|raises
decl_stmt|;
block|{
specifier|register
name|tree
name|decl
decl_stmt|;
specifier|register
name|tree
name|type
decl_stmt|,
name|tem
decl_stmt|;
name|tree
name|context
decl_stmt|;
specifier|extern
name|int
name|have_extern_spec
decl_stmt|;
specifier|extern
name|int
name|used_extern_spec
decl_stmt|;
name|int
name|init_written
init|=
name|initialized
decl_stmt|;
comment|/* This should only be done once on the top most decl. */
if|if
condition|(
name|have_extern_spec
operator|&&
operator|!
name|used_extern_spec
condition|)
block|{
name|declspecs
operator|=
name|decl_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"extern"
argument_list|)
argument_list|,
name|declspecs
argument_list|)
expr_stmt|;
name|used_extern_spec
operator|=
literal|1
expr_stmt|;
block|}
name|decl
operator|=
name|grokdeclarator
argument_list|(
name|declarator
argument_list|,
name|declspecs
argument_list|,
name|NORMAL
argument_list|,
name|initialized
argument_list|,
name|raises
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|==
name|NULL_TREE
operator|||
name|decl
operator|==
name|void_type_node
condition|)
return|return
name|NULL_TREE
return|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Don't lose if destructors must be executed at file-level.  */
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|TREE_PERMANENT
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|push_obstacks
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|&
name|permanent_obstack
argument_list|)
expr_stmt|;
name|decl
operator|=
name|copy_node
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|tree
name|itype
init|=
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|itype
operator|&&
operator|!
name|TREE_PERMANENT
argument_list|(
name|itype
argument_list|)
condition|)
block|{
name|itype
operator|=
name|build_index_type
argument_list|(
name|copy_to_permanent
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|itype
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_cplus_array_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|itype
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|type
expr_stmt|;
block|}
block|}
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
comment|/* Interesting work for this is done in `finish_exception_decl'.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|CLASSTYPE_DECLARED_EXCEPTION
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|decl
return|;
comment|/* Corresponding pop_obstacks is done in `finish_decl'.  */
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|context
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_VIRTUAL_P
argument_list|(
name|decl
argument_list|)
operator|)
condition|?
name|DECL_CLASS_CONTEXT
argument_list|(
name|decl
argument_list|)
else|:
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
block|{
name|tree
name|d
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
comment|/* Declarator is a call_expr; extract arguments from it, since              grokdeclarator didn't do it.  */
name|tree
name|args
decl_stmt|;
name|args
operator|=
name|copy_to_permanent
argument_list|(
name|last_function_parms
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|tree
name|t
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|t
operator|=
name|TYPE_METHOD_BASETYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* type method belongs to */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|UNINSTANTIATED_P_TYPE
condition|)
block|{
name|t
operator|=
name|build_pointer_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* base type of `this' */
if|#
directive|if
literal|1
comment|/* I suspect this is wrong. */
name|t
operator|=
name|build_type_variant
argument_list|(
name|t
argument_list|,
name|flag_this_is_variable
operator|<=
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* type of `this' */
else|#
directive|else
name|t
operator|=
name|build_type_variant
argument_list|(
name|t
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* type of `this' */
endif|#
directive|endif
name|t
operator|=
name|build
argument_list|(
name|PARM_DECL
argument_list|,
name|t
argument_list|,
name|this_identifier
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|=
name|args
expr_stmt|;
name|args
operator|=
name|t
expr_stmt|;
block|}
block|}
name|DECL_ARGUMENTS
argument_list|(
name|decl
argument_list|)
operator|=
name|args
expr_stmt|;
block|}
name|d
operator|=
name|build_lang_decl
argument_list|(
name|TEMPLATE_DECL
argument_list|,
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|interface_unknown
operator|&&
name|flag_external_templates
operator|&&
operator|!
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|decl
argument_list|)
condition|)
name|warn_if_unknown_interface
argument_list|()
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|d
argument_list|)
operator|=
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|d
argument_list|)
operator|=
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|d
argument_list|)
operator|=
operator|(
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
operator|(
name|context
operator|&&
operator|!
name|DECL_THIS_EXTERN
argument_list|(
name|decl
argument_list|)
operator|)
operator|)
expr_stmt|;
name|DECL_TEMPLATE_RESULT
argument_list|(
name|d
argument_list|)
operator|=
name|decl
expr_stmt|;
name|decl
operator|=
name|d
expr_stmt|;
block|}
comment|/* If this type of object needs a cleanup, and control may      jump past it, make a new binding level so that it is cleaned      up only when it is initialized first.  */
if|if
condition|(
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
operator|&&
name|current_binding_level
operator|->
name|more_cleanups_ok
operator|==
literal|0
condition|)
name|pushlevel_temporary
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|initialized
condition|)
comment|/* Is it valid for this decl to have an initializer at all?        If not, set INITIALIZED to zero, which will indirectly        tell `finish_decl' to ignore the initializer once it is parsed.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
case|case
name|TYPE_DECL
case|:
comment|/* typedef foo = bar  means give foo the same type as bar. 	   We haven't parsed bar yet, so `finish_decl' will fix that up. 	   Any other case of an initialization in a TYPE_DECL is an error.  */
if|if
condition|(
name|pedantic
operator|||
name|list_length
argument_list|(
name|declspecs
argument_list|)
operator|>
literal|1
condition|)
block|{
name|cp_error
argument_list|(
literal|"typedef `%D' is initialized"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|FUNCTION_DECL
case|:
name|cp_error
argument_list|(
literal|"function `%#D' is initialized like a variable"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
comment|/* Don't allow initializations for incomplete types except for 	   arrays which might be completed by the initialization.  */
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
empty_stmt|;
comment|/* Don't complain again.  */
elseif|else
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL_TREE
condition|)
empty_stmt|;
comment|/* A complete type is ok.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|ARRAY_TYPE
condition|)
block|{
name|cp_error
argument_list|(
literal|"variable `%#D' has initializer but incomplete type"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|cp_error
argument_list|(
literal|"elements of array `%#D' have incomplete type"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|initialized
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|TYPE_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|TEMPLATE_DECL
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|cp_error
argument_list|(
literal|"aggregate `%#D' has incomplete type and cannot be initialized"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* Change the type so that assemble_variable will give 	     DECL an rtl we can live with: (mem (const_int 0)).  */
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|type
operator|=
name|error_mark_node
expr_stmt|;
block|}
else|else
block|{
comment|/* If any base type in the hierarchy of TYPE needs a constructor, 	     then we set initialized to 1.  This way any nodes which are 	     created for the purposes of initializing this aggregate 	     will live as long as it does.  This is necessary for global 	     aggregates which do not have their initializers processed until 	     the end of the file.  */
name|initialized
operator|=
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|initialized
condition|)
block|{
if|if
condition|(
name|current_binding_level
operator|!=
name|global_binding_level
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
name|cp_warning
argument_list|(
literal|"declaration of `%#D' has `extern' and is initialized"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
condition|)
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Tell `pushdecl' this is an initialized decl 	 even though we don't yet have the initializer expression. 	 Also tell `finish_decl' it may store the real initializer.  */
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
if|if
condition|(
name|context
operator|&&
name|TYPE_SIZE
argument_list|(
name|context
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
name|tree
name|field
init|=
name|lookup_field
argument_list|(
name|context
argument_list|,
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|field
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|VAR_DECL
condition|)
name|cp_error
argument_list|(
literal|"`%#D' is not a static member of `%#T'"
argument_list|,
name|decl
argument_list|,
name|context
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|duplicate_decls
argument_list|(
name|decl
argument_list|,
name|field
argument_list|)
condition|)
name|decl
operator|=
name|field
expr_stmt|;
block|}
comment|/* If it was not explicitly declared `extern', 	 revoke any previous claims of DECL_EXTERNAL.  */
if|if
condition|(
name|DECL_THIS_EXTERN
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
condition|)
name|DECL_IN_AGGR_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|pushclass
argument_list|(
name|context
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/* Add this decl to the current binding level, but not if it      comes from another scope, e.g. a static member variable.      TEM may equal DECL or it may be a previous decl of the same name.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|PARM_DECL
operator|&&
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TEMPLATE_DECL
operator|&&
operator|!
name|global_bindings_p
argument_list|()
operator|)
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|LANG_TYPE
condition|)
name|tem
operator|=
name|decl
expr_stmt|;
else|else
name|tem
operator|=
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Tell the back-end to use or not use .common as appropriate.  If we say      -fconserve-space, we want this to save space, at the expense of wrong      semantics.  If we say -fno-conserve-space, we want this to produce      errors about redefs; to do this we force variables into the data      segment.  Common storage is okay for non-public uninitialized data;      the linker can't match it with storage from other files, and we may      save some disk space.  */
name|DECL_COMMON
argument_list|(
name|tem
argument_list|)
operator|=
name|flag_conserve_space
operator|||
operator|!
name|TREE_PUBLIC
argument_list|(
name|tem
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* We don't do this yet for GNU C++.  */
comment|/* For a local variable, define the RTL now.  */
block|if (current_binding_level != global_binding_level
comment|/* But not if this is a duplicate decl 	 and we preserved the rtl from the previous one 	 (which may or may not happen).  */
block|&& DECL_RTL (tem) == NULL_RTX)     {       if (TYPE_SIZE (TREE_TYPE (tem)) != NULL_TREE) 	expand_decl (tem);       else if (TREE_CODE (TREE_TYPE (tem)) == ARRAY_TYPE&& DECL_INITIAL (tem) != NULL_TREE) 	expand_decl (tem);     }
endif|#
directive|endif
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
name|tree
name|result
init|=
name|DECL_TEMPLATE_RESULT
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|result
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
name|tree
name|type
decl_stmt|;
name|type
operator|=
name|DECL_CONTEXT
argument_list|(
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|UNINSTANTIATED_P_TYPE
condition|)
block|{
name|cp_error
argument_list|(
literal|"declaration of `%D' in non-template type `%T'"
argument_list|,
name|decl
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|result
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
return|return
name|tem
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|result
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
if|#
directive|if
literal|0
block|tree tmpl = UPT_TEMPLATE (type); 	       	      fprintf (stderr, "%s:%d: adding ", __FILE__, __LINE__); 	      print_node_brief (stderr, "", DECL_NAME (tem), 0); 	      fprintf (stderr, " to class %s\n", 		       IDENTIFIER_POINTER (DECL_NAME (tmpl)));               DECL_TEMPLATE_MEMBERS (tmpl)                 = perm_tree_cons (DECL_NAME (tem), tem, 				  DECL_TEMPLATE_MEMBERS (tmpl)); 	      return tem;
else|#
directive|else
name|sorry
argument_list|(
literal|"static data member templates"
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
endif|#
directive|endif
block|}
else|else
name|my_friendly_abort
argument_list|(
literal|13
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|result
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
comment|/*tem = push_overloaded_decl (tem, 0)*/
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|result
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
name|cp_error
argument_list|(
literal|"data template `%#D' must be member of a class template"
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|result
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|cp_error
argument_list|(
literal|"invalid template `%#D'"
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
else|else
name|my_friendly_abort
argument_list|(
literal|14
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|init_written
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|PARM_DECL
operator|||
operator|(
name|TREE_READONLY
argument_list|(
name|tem
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|FIELD_DECL
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* When parsing and digesting the initializer, 	 use temporary storage.  Do this even if we will ignore the value.  */
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
operator|&&
name|debug_temp_inits
condition|)
block|{
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
comment|/* In this case, the initializer must lay down in permanent 	       storage, since it will be saved until `finish_file' is run.   */
empty_stmt|;
else|else
name|temporary_allocation
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|flag_cadillac
condition|)
name|cadillac_start_decl
argument_list|(
name|tem
argument_list|)
expr_stmt|;
return|return
name|tem
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* unused */
end_comment

begin_comment
unit|static void make_temporary_for_reference (decl, ctor_call, init, cleanupp)      tree decl, ctor_call, init;      tree *cleanupp; {   tree type = TREE_TYPE (decl);   tree target_type = TREE_TYPE (type);   tree tmp, tmp_addr;    if (ctor_call)     {       tmp_addr = TREE_VALUE (TREE_OPERAND (ctor_call, 1));       if (TREE_CODE (tmp_addr) == NOP_EXPR) 	tmp_addr = TREE_OPERAND (tmp_addr, 0);       my_friendly_assert (TREE_CODE (tmp_addr) == ADDR_EXPR, 146);       tmp = TREE_OPERAND (tmp_addr, 0);     }   else     {       tmp = get_temp_name (target_type, 			   current_binding_level == global_binding_level);       tmp_addr = build_unary_op (ADDR_EXPR, tmp, 0);     }    TREE_TYPE (tmp_addr) = build_pointer_type (target_type);   DECL_INITIAL (decl) = convert (TYPE_POINTER_TO (target_type), tmp_addr);   TREE_TYPE (DECL_INITIAL (decl)) = type;   if (TYPE_NEEDS_CONSTRUCTING (target_type))     {       if (current_binding_level == global_binding_level) 	{
comment|/* lay this variable out now.  Otherwise `output_addressed_constants' 	     gets confused by its initializer.  */
end_comment

begin_endif
unit|make_decl_rtl (tmp, NULL_PTR, 1); 	  static_aggregates = perm_tree_cons (init, tmp, static_aggregates); 	}       else 	{ 	  if (ctor_call != NULL_TREE) 	    init = ctor_call; 	  else 	    init = build_method_call (tmp, constructor_name_full (target_type), 				      build_tree_list (NULL_TREE, init), 				      NULL_TREE, LOOKUP_NORMAL); 	  DECL_INITIAL (decl) = build (COMPOUND_EXPR, type, init, 				       DECL_INITIAL (decl)); 	  *cleanupp = maybe_build_cleanup (tmp); 	}     }   else     {       DECL_INITIAL (tmp) = init;       TREE_STATIC (tmp) = current_binding_level == global_binding_level;       finish_decl (tmp, init, 0, 0);     }   if (TREE_STATIC (tmp))     preserve_initializer (); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Handle initialization of references.    These three arguments from from `finish_decl', and have the    same meaning here that they do there.  */
end_comment

begin_comment
comment|/* quotes on semantics can be found in ARM 8.4.3. */
end_comment

begin_function
specifier|static
name|void
name|grok_reference_init
parameter_list|(
name|decl
parameter_list|,
name|type
parameter_list|,
name|init
parameter_list|,
name|cleanupp
parameter_list|)
name|tree
name|decl
decl_stmt|,
name|type
decl_stmt|,
name|init
decl_stmt|;
name|tree
modifier|*
name|cleanupp
decl_stmt|;
block|{
name|tree
name|tmp
decl_stmt|;
if|if
condition|(
name|init
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|||
name|DECL_IN_AGGR_P
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cp_error
argument_list|(
literal|"`%D' declared as reference but not initialized"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|SET_DECL_REFERENCE_SLOT
argument_list|(
name|decl
argument_list|,
name|error_mark_node
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|init
operator|==
name|error_mark_node
condition|)
return|return;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
block|{
name|cp_error
argument_list|(
literal|"ANSI C++ forbids use of initializer list to initialize reference `%D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|init
operator|=
name|build_compound_expr
argument_list|(
name|init
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|ARRAY_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
comment|/* Note: default conversion is only called in very special cases.  */
name|init
operator|=
name|default_conversion
argument_list|(
name|init
argument_list|)
expr_stmt|;
block|}
name|tmp
operator|=
name|convert_to_reference
argument_list|(
name|type
argument_list|,
name|init
argument_list|,
name|CONV_IMPLICIT
argument_list|,
name|LOOKUP_SPECULATIVELY
operator||
name|LOOKUP_NORMAL
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|error_mark_node
condition|)
goto|goto
name|fail
goto|;
elseif|else
if|if
condition|(
name|tmp
operator|!=
name|NULL_TREE
condition|)
block|{
name|tree
name|subtype
init|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|init
operator|=
name|tmp
expr_stmt|;
comment|/* Associate the cleanup with the reference so that we 	 don't get burned by "aggressive" cleanup policy.  */
if|if
condition|(
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|subtype
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|WITH_CLEANUP_EXPR
condition|)
block|{
operator|*
name|cleanupp
operator|=
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|2
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
name|tmp
operator|=
name|TREE_OPERAND
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|TARGET_EXPR
condition|)
block|{
operator|*
name|cleanupp
operator|=
name|build_delete
argument_list|(
name|TYPE_POINTER_TO
argument_list|(
name|subtype
argument_list|)
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|TREE_OPERAND
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|integer_two_node
argument_list|,
name|LOOKUP_NORMAL
operator||
name|LOOKUP_DESTRUCTOR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|tmp
argument_list|,
literal|2
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
block|}
block|}
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|save_expr
argument_list|(
name|init
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cp_error
argument_list|(
literal|"cannot initialize `%T' from `%T'"
argument_list|,
name|type
argument_list|,
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* ?? Can this be optimized in some cases to      hand back the DECL_INITIAL slot??  */
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
name|init
operator|=
name|convert_from_reference
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_PERMANENT
argument_list|(
name|decl
argument_list|)
condition|)
name|init
operator|=
name|copy_to_permanent
argument_list|(
name|init
argument_list|)
expr_stmt|;
name|SET_DECL_REFERENCE_SLOT
argument_list|(
name|decl
argument_list|,
name|init
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_CONSTANT
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
name|expand_static_init
argument_list|(
name|decl
argument_list|,
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
return|return;
name|fail
label|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|SET_DECL_REFERENCE_SLOT
argument_list|(
name|decl
argument_list|,
name|error_mark_node
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Finish processing of a declaration;    install its line number and initial value.    If the length of an array type is not known before,    it must be determined now, from the initial value, or it is an error.     Call `pop_obstacks' iff NEED_POP is nonzero.     For C++, `finish_decl' must be fairly evasive:  it must keep initializers    for aggregates that have constructors alive on the permanent obstack,    so that the global initializing functions can be written at the end.     INIT0 holds the value of an initializer that should be allowed to escape    the normal rules.     For functions that take default parameters, DECL points to its    "maximal" instantiation.  `finish_decl' must then also declared its    subsequently lower and lower forms of instantiation, checking for    ambiguity as it goes.  This can be sped up later.  */
end_comment

begin_function
name|void
name|finish_decl
parameter_list|(
name|decl
parameter_list|,
name|init
parameter_list|,
name|asmspec_tree
parameter_list|,
name|need_pop
parameter_list|)
name|tree
name|decl
decl_stmt|,
name|init
decl_stmt|;
name|tree
name|asmspec_tree
decl_stmt|;
name|int
name|need_pop
decl_stmt|;
block|{
specifier|register
name|tree
name|type
decl_stmt|;
name|tree
name|cleanup
init|=
name|NULL_TREE
decl_stmt|,
name|ttype
decl_stmt|;
name|int
name|was_incomplete
decl_stmt|;
name|int
name|temporary
init|=
name|allocation_temporary_p
argument_list|()
decl_stmt|;
name|char
modifier|*
name|asmspec
init|=
name|NULL
decl_stmt|;
name|int
name|was_readonly
init|=
literal|0
decl_stmt|;
comment|/* If this is 0, then we did not change obstacks.  */
if|if
condition|(
operator|!
name|decl
condition|)
block|{
if|if
condition|(
name|init
condition|)
name|error
argument_list|(
literal|"assignment (not initialization) in declaration"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If a name was specified, get the string.  */
if|if
condition|(
name|asmspec_tree
condition|)
name|asmspec
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|asmspec_tree
argument_list|)
expr_stmt|;
comment|/* If the type of the thing we are declaring either has      a constructor, or has a virtual function table pointer,      AND its initialization was accepted by `start_decl',      then we stayed on the permanent obstack through the      declaration, otherwise, changed obstacks as GCC would.  */
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
block|{
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
operator|&&
name|temporary
condition|)
name|end_temporary_allocation
argument_list|()
expr_stmt|;
return|return;
block|}
name|was_incomplete
operator|=
operator|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
operator|)
expr_stmt|;
comment|/* Take care of TYPE_DECLs up front.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
if|if
condition|(
name|init
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* typedef foo = bar; store the type of bar as the type of foo.  */
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|init
operator|=
name|NULL_TREE
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|!=
name|error_mark_node
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
operator|&&
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|&&
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|!=
name|type
condition|)
name|cp_warning
argument_list|(
literal|"shadowing previous type declaration of `%#D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|set_identifier_type_value
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|CLASSTYPE_GOT_SEMICOLON
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|GNU_xref_decl
argument_list|(
name|current_function_decl
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|rest_of_decl_compilation
argument_list|(
name|decl
argument_list|,
name|NULL_PTR
argument_list|,
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|finish_end
goto|;
block|}
if|if
condition|(
name|type
operator|!=
name|error_mark_node
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
operator|&&
name|CLASSTYPE_DECLARED_EXCEPTION
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|CLASSTYPE_GOT_SEMICOLON
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
goto|goto
name|finish_end
goto|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
block|{
name|ttype
operator|=
name|target_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* WTF?  -KR 	 Leave this out until we can figure out why it was 	 needed/desirable in the first place.  Then put a comment 	 here explaining why.  Or just delete the code if no ill 	 effects arise.  */
block|if (TYPE_NAME (ttype)&& TREE_CODE (TYPE_NAME (ttype)) == TYPE_DECL&& ANON_AGGRNAME_P (TYPE_IDENTIFIER (ttype))) 	{ 	  tree old_id = TYPE_IDENTIFIER (ttype); 	  char *newname = (char *)alloca (IDENTIFIER_LENGTH (old_id) + 2);
comment|/* Need to preserve template data for UPT nodes.  */
block|tree old_template = IDENTIFIER_TEMPLATE (old_id); 	  newname[0] = '_'; 	  bcopy (IDENTIFIER_POINTER (old_id), newname + 1, 		 IDENTIFIER_LENGTH (old_id) + 1); 	  old_id = get_identifier (newname); 	  lookup_tag_reverse (ttype, old_id); 	  TYPE_IDENTIFIER (ttype) = old_id; 	  IDENTIFIER_TEMPLATE (old_id) = old_template; 	}
endif|#
directive|endif
block|}
if|if
condition|(
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|&&
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* Currently, GNU C++ puts constants in text space, making them 	 impossible to initialize.  In the future, one would hope for 	 an operating system which understood the difference between 	 initialization and the running of a program.  */
name|was_readonly
operator|=
literal|1
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
if|if
condition|(
name|init
operator|&&
name|init
operator|!=
name|error_mark_node
condition|)
name|my_friendly_assert
argument_list|(
name|TREE_PERMANENT
argument_list|(
name|init
argument_list|)
argument_list|,
literal|147
argument_list|)
expr_stmt|;
if|if
condition|(
name|asmspec
condition|)
block|{
comment|/* This must override the asm specifier which was placed 	     by grokclassfn.  Lay this out fresh. 	      	     @@ Should emit an error if this redefines an asm-specified 	     @@ name, or if we have already used the function's name.  */
name|DECL_RTL
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
name|NULL_RTX
expr_stmt|;
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
operator|=
name|get_identifier
argument_list|(
name|asmspec
argument_list|)
expr_stmt|;
name|make_decl_rtl
argument_list|(
name|decl
argument_list|,
name|asmspec
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If `start_decl' didn't like having an initialization, ignore it now.  */
elseif|else
if|if
condition|(
name|init
operator|!=
name|NULL_TREE
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|init
operator|=
name|NULL_TREE
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|||
operator|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|type
argument_list|)
operator|&&
name|IS_SIGNATURE_REFERENCE
argument_list|(
name|type
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|)
name|make_decl_rtl
argument_list|(
name|decl
argument_list|,
name|NULL_PTR
argument_list|,
name|current_binding_level
operator|==
name|global_binding_level
operator|||
name|pseudo_global_level_p
argument_list|()
argument_list|)
expr_stmt|;
name|grok_reference_init
argument_list|(
name|decl
argument_list|,
name|type
argument_list|,
name|init
argument_list|,
operator|&
name|cleanup
argument_list|)
expr_stmt|;
name|init
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|GNU_xref_decl
argument_list|(
name|current_function_decl
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FIELD_DECL
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|CONST_DECL
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|REFERENCE_TYPE
argument_list|,
literal|148
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|init
expr_stmt|;
comment|/* This will keep us from needing to worry about our obstacks.  */
name|my_friendly_assert
argument_list|(
name|init
operator|!=
name|NULL_TREE
argument_list|,
literal|149
argument_list|)
expr_stmt|;
name|init
operator|=
name|NULL_TREE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|init
condition|)
block|{
if|if
condition|(
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|type
argument_list|)
operator|||
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|init
operator|=
name|digest_init
argument_list|(
name|type
argument_list|,
name|init
argument_list|,
operator|(
name|tree
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
block|{
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"`%D' must be initialized by constructor, not by `{...}'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|init
operator|=
name|error_mark_node
expr_stmt|;
block|}
else|else
goto|goto
name|dont_use_constructor
goto|;
block|}
if|#
directive|if
literal|0
comment|/* fix this in `build_functional_cast' instead. 	     Here's the trigger code:  		struct ostream 		{ 		  ostream (); 		  ostream (int, char *); 		  ostream (char *); 		  operator char *(); 		  ostream (void *); 		  operator void *(); 		  operator<< (int); 		}; 		int buf_size = 1024; 		static char buf[buf_size]; 		const char *debug(int i) { 		  char *b =&buf[0]; 		  ostream o = ostream(buf_size, b); 		  o<< i; 		  return buf; 		} 		*/
block|else if (TREE_CODE (init) == TARGET_EXPR&& TREE_CODE (TREE_OPERAND (init, 1) == NEW_EXPR)) 	    {
comment|/* User wrote something like `foo x = foo (args)'  */
block|my_friendly_assert (TREE_CODE (TREE_OPERAND (init, 0)) == VAR_DECL, 150); 	      my_friendly_assert (DECL_NAME (TREE_OPERAND (init, 0)) == NULL_TREE, 151);
comment|/* User wrote exactly `foo x = foo (args)'  */
block|if (TYPE_MAIN_VARIANT (type) == TREE_TYPE (init)) 		{ 		  init = build (CALL_EXPR, TREE_TYPE (init), 				TREE_OPERAND (TREE_OPERAND (init, 1), 0), 				TREE_OPERAND (TREE_OPERAND (init, 1), 1), 0); 		  TREE_SIDE_EFFECTS (init) = 1; 		} 	    }
endif|#
directive|endif
comment|/* We must hide the initializer so that expand_decl 	     won't try to do something it does not understand.  */
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
condition|)
block|{
name|tree
name|value
decl_stmt|;
if|if
condition|(
name|DECL_COMMON
argument_list|(
name|decl
argument_list|)
condition|)
comment|/* Should this be a NULL_TREE? */
name|value
operator|=
name|error_mark_node
expr_stmt|;
else|else
name|value
operator|=
name|build
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|type
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|value
expr_stmt|;
block|}
else|else
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
else|else
block|{
name|dont_use_constructor
label|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|!=
name|TREE_VEC
condition|)
name|init
operator|=
name|store_init_value
argument_list|(
name|decl
argument_list|,
name|init
argument_list|)
expr_stmt|;
comment|/* Don't let anyone try to initialize this variable 	     until we are ready to do so.  */
if|if
condition|(
name|init
condition|)
block|{
name|tree
name|value
decl_stmt|;
if|if
condition|(
name|DECL_COMMON
argument_list|(
name|decl
argument_list|)
condition|)
name|value
operator|=
name|error_mark_node
expr_stmt|;
else|else
name|value
operator|=
name|build
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|type
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|value
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
literal|'t'
operator|&&
operator|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
operator|||
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
operator|)
condition|)
block|{
name|tree
name|ctype
init|=
name|type
decl_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|ctype
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|ctype
operator|=
name|TREE_TYPE
argument_list|(
name|ctype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|ctype
argument_list|)
condition|)
block|{
if|if
condition|(
name|CLASSTYPE_READONLY_FIELDS_NEED_INIT
argument_list|(
name|ctype
argument_list|)
condition|)
name|cp_error
argument_list|(
literal|"structure `%D' with uninitialized const members"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_REF_FIELDS_NEED_INIT
argument_list|(
name|ctype
argument_list|)
condition|)
name|cp_error
argument_list|(
literal|"structure `%D' with uninitialized reference members"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
operator|!
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
name|TYPE_READONLY
argument_list|(
name|type
argument_list|)
operator|||
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
name|cp_error
argument_list|(
literal|"uninitialized const `%D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* Initialize variables in need of static initialization with 	 an empty CONSTRUCTOR to keep assemble_variable from putting them in 	 the wrong program space.  */
if|if
condition|(
name|flag_pic
operator|==
literal|0
operator|&&
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
operator|||
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|error_mark_node
operator|)
operator|&&
operator|!
name|DECL_COMMON
argument_list|(
name|decl
argument_list|)
condition|)
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|build
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|type
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|REFERENCE_TYPE
operator|&&
operator|(
name|TYPE_READONLY
argument_list|(
name|type
argument_list|)
operator|||
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
block|{
comment|/* ``Unless explicitly declared extern, a const object does not have 	 external linkage and must be initialized. ($8.4; $12.1)'' ARM 7.1.6 	 However, if it's `const int foo = 1; const int foo;', don't complain 	 about the second decl, since it does have an initializer before. 	 We deliberately don't complain about arrays, because they're 	 supposed to be initialized by a constructor.  */
if|if
condition|(
operator|!
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|ARRAY_TYPE
operator|&&
operator|(
operator|!
name|pedantic
operator|||
operator|!
name|current_class_type
operator|)
condition|)
name|cp_error
argument_list|(
literal|"uninitialized const `%#D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
comment|/* For top-level declaration, the initial value was read in      the temporary obstack.  MAXINDEX, rtl, etc. to be made below      must go in the permanent obstack; but don't discard the      temporary data yet.  */
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
operator|&&
name|temporary
condition|)
name|end_temporary_allocation
argument_list|()
expr_stmt|;
comment|/* Deduce size of array from initialization, if not already known.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
block|{
name|int
name|do_default
init|=
operator|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
comment|/* Even if pedantic, an external linkage array 	      may have incomplete type at first.  */
condition|?
name|pedantic
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
else|:
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|)
decl_stmt|;
name|tree
name|initializer
init|=
name|init
condition|?
name|init
else|:
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|int
name|failure
init|=
name|complete_array_type
argument_list|(
name|type
argument_list|,
name|initializer
argument_list|,
name|do_default
argument_list|)
decl_stmt|;
if|if
condition|(
name|failure
operator|==
literal|1
condition|)
name|cp_error
argument_list|(
literal|"initializer fails to determine size of `%D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|failure
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|do_default
condition|)
name|cp_error
argument_list|(
literal|"array size missing in `%D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* If a `static' var's size isn't known, make it extern as 	     well as static, so it does not get allocated.  If it's not 	     `static', then don't mark it extern; finish_incomplete_decl 	     will give it a default size and it will get allocated.  */
elseif|else
if|if
condition|(
operator|!
name|pedantic
operator|&&
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|pedantic
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|tree_int_cst_lt
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
condition|)
name|cp_error
argument_list|(
literal|"zero-size array `%D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|layout_decl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
if|if
condition|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|layout_decl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* A static variable with an incomplete type: 	     that is an error if it is initialized. 	     Otherwise, let it through, but if it is not `extern' 	     then it may cause an error message later.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|cp_error
argument_list|(
literal|"storage size of `%D' isn't known"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|init
operator|=
name|NULL_TREE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* An automatic variable with an incomplete type: that is an error. 	     Don't talk about array types here, since we took care of that 	     message in grokdeclarator.  */
name|cp_error
argument_list|(
literal|"storage size of `%D' isn't known"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|ttype
argument_list|)
condition|)
comment|/* Let debugger know it should output info for this type.  */
name|note_debug_info_needed
argument_list|(
name|ttype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|||
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|)
operator|&&
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
operator|!
name|TREE_CONSTANT
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|constant_expression_warning
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|cp_error
argument_list|(
literal|"storage size of `%D' isn't constant"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|int
name|yes
init|=
name|suspend_momentary
argument_list|()
decl_stmt|;
comment|/* If INIT comes from a functional cast, use the cleanup 	     we built for that.  Otherwise, make our own cleanup.  */
if|if
condition|(
name|init
operator|&&
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|WITH_CLEANUP_EXPR
operator|&&
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|cleanup
operator|=
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|init
operator|=
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|current_binding_level
operator|->
name|have_cleanups
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|cleanup
operator|=
name|maybe_build_cleanup
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|resume_momentary
argument_list|(
name|yes
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* PARM_DECLs get cleanups, too.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|PARM_DECL
operator|&&
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|temporary
condition|)
name|end_temporary_allocation
argument_list|()
expr_stmt|;
name|cleanup
operator|=
name|maybe_build_cleanup
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|temporary
condition|)
name|resume_temporary_allocation
argument_list|()
expr_stmt|;
block|}
comment|/* Output the assembler code and/or RTL code for variables and functions,      unless the type is an undefined structure or union.      If not, it will get done when the type is completed.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|RESULT_DECL
condition|)
block|{
comment|/* ??? FIXME: What about nested classes?  */
name|int
name|toplev
init|=
operator|(
name|current_binding_level
operator|==
name|global_binding_level
operator|||
name|pseudo_global_level_p
argument_list|()
operator|)
decl_stmt|;
name|int
name|was_temp
init|=
operator|(
operator|(
name|flag_traditional
operator|||
operator|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
operator|)
operator|)
operator|&&
name|allocation_temporary_p
argument_list|()
operator|)
decl_stmt|;
if|if
condition|(
name|was_temp
condition|)
name|end_temporary_allocation
argument_list|()
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|current_binding_level
operator|!=
name|global_binding_level
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|type_needs_gc_entry
argument_list|(
name|type
argument_list|)
condition|)
name|DECL_GC_OFFSET
argument_list|(
name|decl
argument_list|)
operator|=
name|size_int
argument_list|(
operator|++
name|current_function_obstack_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_VIRTUAL_P
argument_list|(
name|decl
argument_list|)
condition|)
name|make_decl_rtl
argument_list|(
name|decl
argument_list|,
name|NULL_PTR
argument_list|,
name|toplev
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
name|error_mark_node
operator|&&
operator|!
name|EMPTY_CONSTRUCTOR_P
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|save_expr
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|asmspec
condition|)
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
operator|=
name|get_identifier
argument_list|(
name|asmspec
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|toplev
operator|&&
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
operator|&&
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|BLKmode
condition|)
block|{
comment|/* If this variable is really a constant, then fill its DECL_RTL 		 slot with something which won't take up storage. 		 If something later should take its address, we can always give 		 it legitimate RTL at that time.  */
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|=
name|gen_reg_rtx
argument_list|(
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|store_expr
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|,
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|toplev
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* If this is a static const, change its apparent linkage 		 if it belongs to a #pragma interface.  */
if|if
condition|(
operator|!
name|interface_unknown
condition|)
block|{
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
name|interface_only
expr_stmt|;
block|}
name|make_decl_rtl
argument_list|(
name|decl
argument_list|,
name|asmspec
argument_list|,
name|toplev
argument_list|)
expr_stmt|;
block|}
else|else
name|rest_of_decl_compilation
argument_list|(
name|decl
argument_list|,
name|asmspec
argument_list|,
name|toplev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_IN_AGGR_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|init
operator|==
name|NULL_TREE
ifdef|#
directive|ifdef
name|DEFAULT_STATIC_DEFS
comment|/* If this code is dead, then users must 		     explicitly declare static member variables 		     outside the class def'n as well.  */
operator|&&
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
endif|#
directive|endif
condition|)
block|{
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|make_decl_rtl
argument_list|(
name|decl
argument_list|,
name|asmspec
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|rest_of_decl_compilation
argument_list|(
name|decl
argument_list|,
name|asmspec
argument_list|,
name|toplev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Just a constant field.  Should not need any rtl.  */
goto|goto
name|finish_end0
goto|;
block|}
else|else
name|rest_of_decl_compilation
argument_list|(
name|decl
argument_list|,
name|asmspec
argument_list|,
name|toplev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|was_temp
condition|)
name|resume_temporary_allocation
argument_list|()
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|error_mark_node
operator|&&
name|TYPE_LANG_SPECIFIC
argument_list|(
name|type
argument_list|)
operator|&&
name|CLASSTYPE_ABSTRACT_VIRTUALS
argument_list|(
name|type
argument_list|)
condition|)
name|abstract_virtuals_error
argument_list|(
name|decl
argument_list|,
name|type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
operator|)
operator|&&
name|TYPE_LANG_SPECIFIC
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
name|CLASSTYPE_ABSTRACT_VIRTUALS
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|abstract_virtuals_error
argument_list|(
name|decl
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|type
argument_list|)
operator|&&
name|IS_SIGNATURE
argument_list|(
name|type
argument_list|)
condition|)
name|signature_error
argument_list|(
name|decl
argument_list|,
name|type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
operator|)
operator|&&
name|TYPE_LANG_SPECIFIC
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
name|IS_SIGNATURE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|signature_error
argument_list|(
name|decl
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
if|#
directive|if
literal|0
comment|/* C++: Handle overloaded functions with default parameters.  */
block|if (DECL_OVERLOADED (decl)) 	    { 	      tree parmtypes = TYPE_ARG_TYPES (type); 	      tree prev = NULL_TREE; 	      tree original_name = DECL_NAME (decl); 	      struct lang_decl *tmp_lang_decl = DECL_LANG_SPECIFIC (decl);
comment|/* All variants will share an uncollectible lang_decl.  */
block|copy_decl_lang_specific (decl);  	      while (parmtypes&& parmtypes != void_list_node) 		{
comment|/* The default value for the parameter in parmtypes is 		     stored in the TREE_PURPOSE of the TREE_LIST.  */
block|if (TREE_PURPOSE (parmtypes)) 		    { 		      tree fnname, fndecl; 		      tree *argp;  		      argp = prev ?& TREE_CHAIN (prev) 			:& TYPE_ARG_TYPES (type);  		      *argp = NULL_TREE; 		      fnname = build_decl_overload (original_name, 						    TYPE_ARG_TYPES (type), 0); 		      *argp = parmtypes; 		      fndecl = build_decl (FUNCTION_DECL, fnname, type); 		      DECL_EXTERNAL (fndecl) = DECL_EXTERNAL (decl); 		      TREE_PUBLIC (fndecl) = TREE_PUBLIC (decl); 		      DECL_INLINE (fndecl) = DECL_INLINE (decl);
comment|/* Keep G++ from thinking this function is unused. 			 It is only used to speed up search in name space.  */
block|TREE_USED (fndecl) = 1; 		      TREE_ASM_WRITTEN (fndecl) = 1; 		      DECL_INITIAL (fndecl) = NULL_TREE; 		      DECL_LANG_SPECIFIC (fndecl) = DECL_LANG_SPECIFIC (decl); 		      fndecl = pushdecl (fndecl); 		      DECL_INITIAL (fndecl) = error_mark_node; 		      DECL_RTL (fndecl) = DECL_RTL (decl); 		    } 		  prev = parmtypes; 		  parmtypes = TREE_CHAIN (parmtypes); 		} 	      DECL_LANG_SPECIFIC (decl) = tmp_lang_decl; 	    }
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|type
operator|!=
name|error_mark_node
condition|)
block|{
comment|/* Cleanups for static variables are handled by `finish_file'.  */
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
operator|||
name|init
operator|!=
name|NULL_TREE
condition|)
name|expand_static_init
argument_list|(
name|decl
argument_list|,
name|init
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
name|static_aggregates
operator|=
name|perm_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|decl
argument_list|,
name|static_aggregates
argument_list|)
expr_stmt|;
comment|/* Make entry in appropriate vector.  */
if|if
condition|(
name|flag_gc
operator|&&
name|type_needs_gc_entry
argument_list|(
name|type
argument_list|)
condition|)
name|build_static_gc_entry
argument_list|(
name|decl
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|toplev
condition|)
block|{
name|tree
name|old_cleanups
init|=
name|cleanups_this_call
decl_stmt|;
comment|/* This is a declared decl which must live until the 	     end of the binding contour.  It may need a cleanup.  */
comment|/* Recompute the RTL of a local array now 	     if it used to be an incomplete type.  */
if|if
condition|(
name|was_incomplete
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* If we used it already as memory, it must stay in memory.  */
name|TREE_ADDRESSABLE
argument_list|(
name|decl
argument_list|)
operator|=
name|TREE_USED
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* If it's still incomplete now, no init will save it.  */
if|if
condition|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|expand_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|&&
operator|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|)
condition|)
block|{
comment|/* Do this here, because we did not expand this decl's 		 rtl in start_decl.  */
if|if
condition|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_RTX
condition|)
name|expand_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cleanup
condition|)
block|{
comment|/* XXX: Why don't we use decl here?  */
comment|/* Ans: Because it was already expanded? */
if|if
condition|(
operator|!
name|expand_decl_cleanup
argument_list|(
name|NULL_TREE
argument_list|,
name|cleanup
argument_list|)
condition|)
name|cp_error
argument_list|(
literal|"parser lost in parsing declaration of `%D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* Cleanup used up here.  */
name|cleanup
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|&&
name|type
operator|!=
name|error_mark_node
condition|)
block|{
comment|/* Compute and store the initial value.  */
name|expand_decl_init
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|init
operator|||
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|emit_line_note
argument_list|(
name|DECL_SOURCE_FILE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|expand_aggr_init
argument_list|(
name|decl
argument_list|,
name|init
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Set this to 0 so we can tell whether an aggregate which 		 was initialized was ever used.  Don't do this if it has a 		 destructor, so we don't complain about the 'resource 		 allocation is initialization' idiom.  */
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
operator|&&
name|cleanup
operator|==
name|NULL_TREE
condition|)
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Store the cleanup, if there was one.  */
if|if
condition|(
name|cleanup
condition|)
block|{
if|if
condition|(
operator|!
name|expand_decl_cleanup
argument_list|(
name|decl
argument_list|,
name|cleanup
argument_list|)
condition|)
name|cp_error
argument_list|(
literal|"parser lost in parsing declaration of `%D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Cleanup any temporaries needed for the initial value.  */
name|expand_cleanups_to
argument_list|(
name|old_cleanups
argument_list|)
expr_stmt|;
block|}
name|finish_end0
label|:
comment|/* Undo call to `pushclass' that was done in `start_decl' 	 due to initialization of qualified member variable. 	 I.e., Foo::x = 10;  */
block|{
name|tree
name|context
init|=
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|context
operator|&&
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|context
argument_list|)
argument_list|)
operator|==
literal|'t'
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
comment|/* We also have a pushclass done that we need to undo here 		   if we're at top level and declare a method.  */
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
comment|/* If size hasn't been set, we're still defining it, 		       and therefore inside the class body; don't pop 		       the binding level..  */
operator|&&
name|TYPE_SIZE
argument_list|(
name|context
argument_list|)
operator|!=
name|NULL_TREE
comment|/* The binding level gets popped elsewhere for a 		       friend declaration inside another class.  */
comment|/*&& TYPE_IDENTIFIER (context) == current_class_name 		    */
operator|&&
name|context
operator|==
name|current_class_type
operator|)
operator|)
condition|)
name|popclass
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|finish_end
label|:
comment|/* If requested, warn about definitions of large data objects.  */
if|if
condition|(
name|warn_larger_than
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|PARM_DECL
operator|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
block|{
specifier|register
name|tree
name|decl_size
init|=
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|decl_size
operator|&&
name|TREE_CODE
argument_list|(
name|decl_size
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|unsigned
name|units
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|decl_size
argument_list|)
operator|/
name|BITS_PER_UNIT
decl_stmt|;
if|if
condition|(
name|units
operator|>
name|larger_than_size
condition|)
name|warning_with_decl
argument_list|(
name|decl
argument_list|,
literal|"size of `%s' is %u bytes"
argument_list|,
name|units
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|need_pop
condition|)
block|{
comment|/* Resume permanent allocation, if not within a function.  */
comment|/* The corresponding push_obstacks_nochange is in start_decl, 	 start_method, groktypename, and in grokfield.  */
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|was_readonly
condition|)
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|flag_cadillac
condition|)
name|cadillac_finish_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|expand_static_init
parameter_list|(
name|decl
parameter_list|,
name|init
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|tree
name|init
decl_stmt|;
block|{
name|tree
name|oldstatic
init|=
name|value_member
argument_list|(
name|decl
argument_list|,
name|static_aggregates
argument_list|)
decl_stmt|;
name|tree
name|old_cleanups
decl_stmt|;
if|if
condition|(
name|oldstatic
condition|)
block|{
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|oldstatic
argument_list|)
operator|&&
name|init
operator|!=
name|NULL_TREE
condition|)
name|cp_error
argument_list|(
literal|"multiple initializations given for `%D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|current_binding_level
operator|!=
name|global_binding_level
operator|&&
name|current_binding_level
operator|->
name|pseudo_global
operator|==
literal|0
condition|)
block|{
comment|/* Emit code to perform this initialization but once.  */
name|tree
name|temp
decl_stmt|;
comment|/* Remember this information until end of file. */
name|push_obstacks
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|&
name|permanent_obstack
argument_list|)
expr_stmt|;
comment|/* Emit code to perform this initialization but once.  */
name|temp
operator|=
name|get_temp_name
argument_list|(
name|integer_type_node
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rest_of_decl_compilation
argument_list|(
name|temp
argument_list|,
name|NULL_PTR
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_start_cond
argument_list|(
name|build_binary_op
argument_list|(
name|EQ_EXPR
argument_list|,
name|temp
argument_list|,
name|integer_zero_node
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|old_cleanups
operator|=
name|cleanups_this_call
expr_stmt|;
name|expand_assignment
argument_list|(
name|temp
argument_list|,
name|integer_one_node
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
name|expand_aggr_init
argument_list|(
name|decl
argument_list|,
name|init
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
block|}
else|else
name|expand_assignment
argument_list|(
name|decl
argument_list|,
name|init
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Cleanup any temporaries needed for the initial value.  */
name|expand_cleanups_to
argument_list|(
name|old_cleanups
argument_list|)
expr_stmt|;
name|expand_end_cond
argument_list|()
expr_stmt|;
if|if
condition|(
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
name|static_aggregates
operator|=
name|perm_tree_cons
argument_list|(
name|temp
argument_list|,
name|decl
argument_list|,
name|static_aggregates
argument_list|)
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|static_aggregates
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Resume old (possibly temporary) allocation. */
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* This code takes into account memory allocation 	 policy of `start_decl'.  Namely, if TYPE_NEEDS_CONSTRUCTING 	 does not hold for this object, then we must make permanent 	 the storage currently in the temporary obstack.  */
if|if
condition|(
operator|!
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|preserve_initializer
argument_list|()
expr_stmt|;
name|static_aggregates
operator|=
name|perm_tree_cons
argument_list|(
name|init
argument_list|,
name|decl
argument_list|,
name|static_aggregates
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make TYPE a complete type based on INITIAL_VALUE.    Return 0 if successful, 1 if INITIAL_VALUE can't be deciphered,    2 if there was no information (in which case assume 1 if DO_DEFAULT).  */
end_comment

begin_function
name|int
name|complete_array_type
parameter_list|(
name|type
parameter_list|,
name|initial_value
parameter_list|,
name|do_default
parameter_list|)
name|tree
name|type
decl_stmt|,
name|initial_value
decl_stmt|;
name|int
name|do_default
decl_stmt|;
block|{
specifier|register
name|tree
name|maxindex
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|value
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|initial_value
condition|)
block|{
comment|/* Note MAXINDEX  is really the maximum index, 	 one less than the size.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|initial_value
argument_list|)
operator|==
name|STRING_CST
condition|)
name|maxindex
operator|=
name|build_int_2
argument_list|(
name|TREE_STRING_LENGTH
argument_list|(
name|initial_value
argument_list|)
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|initial_value
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
block|{
specifier|register
name|int
name|nelts
init|=
name|list_length
argument_list|(
name|CONSTRUCTOR_ELTS
argument_list|(
name|initial_value
argument_list|)
argument_list|)
decl_stmt|;
name|maxindex
operator|=
name|build_int_2
argument_list|(
name|nelts
operator|-
literal|1
argument_list|,
operator|-
operator|(
name|nelts
operator|==
literal|0
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Make an error message unless that happened already.  */
if|if
condition|(
name|initial_value
operator|!=
name|error_mark_node
condition|)
name|value
operator|=
literal|1
expr_stmt|;
comment|/* Prevent further error messages.  */
name|maxindex
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|maxindex
condition|)
block|{
if|if
condition|(
name|do_default
condition|)
name|maxindex
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|value
operator|=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|maxindex
condition|)
block|{
name|tree
name|itype
decl_stmt|;
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
operator|=
name|build_index_type
argument_list|(
name|maxindex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TREE_TYPE
argument_list|(
name|maxindex
argument_list|)
condition|)
name|TREE_TYPE
argument_list|(
name|maxindex
argument_list|)
operator|=
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|initial_value
condition|)
name|itype
operator|=
name|TREE_TYPE
argument_list|(
name|initial_value
argument_list|)
expr_stmt|;
else|else
name|itype
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|itype
operator|&&
operator|!
name|TYPE_DOMAIN
argument_list|(
name|itype
argument_list|)
condition|)
name|TYPE_DOMAIN
argument_list|(
name|itype
argument_list|)
operator|=
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
comment|/* Lay out the type now that we can get the real answer.  */
name|layout_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return zero if something is declared to be a member of type    CTYPE when in the context of CUR_TYPE.  STRING is the error    message to print in that case.  Otherwise, quietly return 1.  */
end_comment

begin_function
specifier|static
name|int
name|member_function_or_else
parameter_list|(
name|ctype
parameter_list|,
name|cur_type
parameter_list|,
name|string
parameter_list|)
name|tree
name|ctype
decl_stmt|,
name|cur_type
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
block|{
if|if
condition|(
name|ctype
operator|&&
name|ctype
operator|!=
name|cur_type
condition|)
block|{
name|error
argument_list|(
name|string
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|ctype
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutine of `grokdeclarator'.  */
end_comment

begin_comment
comment|/* Generate errors possibly applicable for a given set of specifiers.    This is for ARM $7.1.2.  */
end_comment

begin_function
specifier|static
name|void
name|bad_specifiers
parameter_list|(
name|object
parameter_list|,
name|type
parameter_list|,
name|virtualp
parameter_list|,
name|quals
parameter_list|,
name|inlinep
parameter_list|,
name|friendp
parameter_list|,
name|raises
parameter_list|)
name|tree
name|object
decl_stmt|;
name|char
modifier|*
name|type
decl_stmt|;
name|int
name|virtualp
decl_stmt|,
name|quals
decl_stmt|,
name|friendp
decl_stmt|,
name|raises
decl_stmt|,
name|inlinep
decl_stmt|;
block|{
if|if
condition|(
name|virtualp
condition|)
name|cp_error
argument_list|(
literal|"`%D' declared as a `virtual' %s"
argument_list|,
name|object
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|inlinep
condition|)
name|cp_error
argument_list|(
literal|"`%D' declared as an `inline' %s"
argument_list|,
name|object
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|quals
condition|)
name|cp_error
argument_list|(
literal|"`const' and `volatile' function specifiers on `%D' invalid in %s declaration"
argument_list|,
name|object
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|friendp
condition|)
name|cp_error_at
argument_list|(
literal|"invalid friend declaration"
argument_list|,
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
name|raises
condition|)
name|cp_error_at
argument_list|(
literal|"invalid raises declaration"
argument_list|,
name|object
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* CTYPE is class type, or null if non-class.    TYPE is type this FUNCTION_DECL should have, either FUNCTION_TYPE    or METHOD_TYPE.    DECLARATOR is the function's name.    VIRTUALP is truthvalue of whether the function is virtual or not.    FLAGS are to be passed through to `grokclassfn'.    QUALS are qualifiers indicating whether the function is `const'    or `volatile'.    RAISES is a list of exceptions that this function can raise.    CHECK is 1 if we must find this method in CTYPE, 0 if we should    not look, and -1 if we should not call `grokclassfn' at all.  */
end_comment

begin_function
specifier|static
name|tree
name|grokfndecl
parameter_list|(
name|ctype
parameter_list|,
name|type
parameter_list|,
name|declarator
parameter_list|,
name|virtualp
parameter_list|,
name|flags
parameter_list|,
name|quals
parameter_list|,
name|raises
parameter_list|,
name|check
parameter_list|,
name|publicp
parameter_list|)
name|tree
name|ctype
decl_stmt|,
name|type
decl_stmt|;
name|tree
name|declarator
decl_stmt|;
name|int
name|virtualp
decl_stmt|;
name|enum
name|overload_flags
name|flags
decl_stmt|;
name|tree
name|quals
decl_stmt|,
name|raises
decl_stmt|;
name|int
name|check
decl_stmt|,
name|publicp
decl_stmt|;
block|{
name|tree
name|cname
decl_stmt|,
name|decl
decl_stmt|;
name|int
name|staticp
init|=
name|ctype
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
decl_stmt|;
if|if
condition|(
name|ctype
condition|)
name|cname
operator|=
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|ctype
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
condition|?
name|TYPE_IDENTIFIER
argument_list|(
name|ctype
argument_list|)
else|:
name|TYPE_NAME
argument_list|(
name|ctype
argument_list|)
expr_stmt|;
else|else
name|cname
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|raises
condition|)
block|{
name|type
operator|=
name|build_exception_variant
argument_list|(
name|ctype
argument_list|,
name|type
argument_list|,
name|raises
argument_list|)
expr_stmt|;
name|raises
operator|=
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
name|decl
operator|=
name|build_lang_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|declarator
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* propagate volatile out from type to decl */
if|if
condition|(
name|TYPE_VOLATILE
argument_list|(
name|type
argument_list|)
condition|)
name|TREE_THIS_VOLATILE
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Should probably propagate const out from type to decl I bet (mrs).  */
if|if
condition|(
name|staticp
condition|)
block|{
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|ctype
expr_stmt|;
name|DECL_CLASS_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|ctype
expr_stmt|;
block|}
if|if
condition|(
name|publicp
condition|)
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|quals
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|cp_error
argument_list|(
literal|"%smember function `%D' cannot have `%T' method qualifier"
argument_list|,
operator|(
name|ctype
condition|?
literal|"static "
else|:
literal|"non-"
operator|)
argument_list|,
name|decl
argument_list|,
name|TREE_VALUE
argument_list|(
name|quals
argument_list|)
argument_list|)
expr_stmt|;
name|quals
operator|=
name|NULL_TREE
expr_stmt|;
block|}
if|if
condition|(
name|IDENTIFIER_OPNAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|grok_op_properties
argument_list|(
name|decl
argument_list|,
name|virtualp
argument_list|,
name|check
operator|<
literal|0
argument_list|)
expr_stmt|;
comment|/* Caller will do the rest of this.  */
if|if
condition|(
name|check
operator|<
literal|0
condition|)
return|return
name|decl
return|;
if|if
condition|(
name|flags
operator|==
name|NO_SPECIAL
operator|&&
name|ctype
operator|&&
name|constructor_name
argument_list|(
name|cname
argument_list|)
operator|==
name|declarator
condition|)
block|{
name|tree
name|tmp
decl_stmt|;
comment|/* Just handle constructors here.  We could do this 	 inside the following if stmt, but I think 	 that the code is more legible by breaking this 	 case out.  See comments below for what each of 	 the following calls is supposed to do.  */
name|DECL_CONSTRUCTOR_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|grokclassfn
argument_list|(
name|ctype
argument_list|,
name|declarator
argument_list|,
name|decl
argument_list|,
name|flags
argument_list|,
name|quals
argument_list|)
expr_stmt|;
if|if
condition|(
name|check
condition|)
name|check_classfn
argument_list|(
name|ctype
argument_list|,
name|declarator
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|grok_ctor_properties
argument_list|(
name|ctype
argument_list|,
name|decl
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|check
operator|==
literal|0
operator|&&
operator|!
name|current_function_decl
condition|)
block|{
comment|/* FIXME: this should only need to look at              IDENTIFIER_GLOBAL_VALUE.  */
name|tmp
operator|=
name|lookup_name
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL_TREE
condition|)
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
name|decl
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tmp
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
condition|)
name|cp_error
argument_list|(
literal|"inconsistent declarations for `%D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|else
block|{
name|duplicate_decls
argument_list|(
name|decl
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|decl
operator|=
name|tmp
expr_stmt|;
comment|/* avoid creating circularities.  */
name|DECL_CHAIN
argument_list|(
name|decl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|make_decl_rtl
argument_list|(
name|decl
argument_list|,
name|NULL_PTR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|tree
name|tmp
decl_stmt|;
comment|/* Function gets the ugly name, field gets the nice one. 	 This call may change the type of the function (because 	 of default parameters)!  */
if|if
condition|(
name|ctype
operator|!=
name|NULL_TREE
condition|)
name|grokclassfn
argument_list|(
name|ctype
argument_list|,
name|cname
argument_list|,
name|decl
argument_list|,
name|flags
argument_list|,
name|quals
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctype
operator|!=
name|NULL_TREE
operator|&&
name|check
condition|)
name|check_classfn
argument_list|(
name|ctype
argument_list|,
name|cname
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctype
operator|==
name|NULL_TREE
operator|||
name|check
condition|)
return|return
name|decl
return|;
comment|/* Now install the declaration of this function so that others may 	 find it (esp. its DECL_FRIENDLIST).  Don't do this for local class 	 methods, though.  */
if|if
condition|(
operator|!
name|current_function_decl
condition|)
block|{
comment|/* FIXME: this should only need to look at              IDENTIFIER_GLOBAL_VALUE.  */
name|tmp
operator|=
name|lookup_name
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL_TREE
condition|)
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
name|decl
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tmp
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
condition|)
name|cp_error
argument_list|(
literal|"inconsistent declarations for `%D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|else
block|{
name|duplicate_decls
argument_list|(
name|decl
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|decl
operator|=
name|tmp
expr_stmt|;
comment|/* avoid creating circularities.  */
name|DECL_CHAIN
argument_list|(
name|decl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|make_decl_rtl
argument_list|(
name|decl
argument_list|,
name|NULL_PTR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* If this declaration supersedes the declaration of 	 a method declared virtual in the base class, then 	 mark this field as being virtual as well.  */
block|{
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|TYPE_BINFO
argument_list|(
name|ctype
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baselinks
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baselinks
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_VIRTUAL_P
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
operator|||
name|flag_all_virtual
operator|==
literal|1
condition|)
block|{
name|tmp
operator|=
name|get_matching_virtual
argument_list|(
name|base_binfo
argument_list|,
name|decl
argument_list|,
name|flags
operator|==
name|DTOR_FLAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
condition|)
block|{
comment|/* If this function overrides some virtual in some base 		       class, then the function itself is also necessarily 		       virtual, even if the user didn't explicitly say so.  */
name|DECL_VIRTUAL_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* The TMP we really want is the one from the deepest 		       baseclass on this path, taking care not to 		       duplicate if we have already found it (via another 		       path to its virtual baseclass.  */
if|if
condition|(
name|staticp
condition|)
block|{
name|cp_error
argument_list|(
literal|"method `%D' may not be declared static"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"(since `%D' declared virtual in base class.)"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
break|break;
block|}
name|virtualp
operator|=
literal|1
expr_stmt|;
block|{
comment|/* The argument types may have changed... */
name|tree
name|argtypes
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|base_variant
init|=
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|argtypes
argument_list|)
argument_list|)
decl_stmt|;
name|argtypes
operator|=
name|commonparms
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|tmp
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|argtypes
argument_list|)
argument_list|)
expr_stmt|;
comment|/* But the return type has not.  */
name|type
operator|=
name|build_cplus_method_type
argument_list|(
name|base_variant
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|argtypes
argument_list|)
expr_stmt|;
if|if
condition|(
name|raises
condition|)
block|{
name|type
operator|=
name|build_exception_variant
argument_list|(
name|ctype
argument_list|,
name|type
argument_list|,
name|raises
argument_list|)
expr_stmt|;
name|raises
operator|=
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|type
expr_stmt|;
name|DECL_VINDEX
argument_list|(
name|decl
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|tmp
argument_list|,
name|DECL_VINDEX
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
block|}
if|if
condition|(
name|virtualp
condition|)
block|{
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|DECL_VINDEX
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|IDENTIFIER_VIRTUAL_P
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ctype
operator|&&
name|CLASSTYPE_VTABLE_NEEDS_WRITING
argument_list|(
name|ctype
argument_list|)
comment|/* If this function is derived from a template, don't 		 make it public.  This shouldn't be here, but there's 		 no good way to override the interface pragmas for one 		 function or class only.  Bletch.  */
operator|&&
name|IDENTIFIER_TEMPLATE
argument_list|(
name|TYPE_IDENTIFIER
argument_list|(
name|ctype
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
operator|&&
operator|(
name|write_virtuals
operator|==
literal|2
operator|||
operator|(
name|write_virtuals
operator|==
literal|3
operator|&&
name|CLASSTYPE_INTERFACE_KNOWN
argument_list|(
name|ctype
argument_list|)
operator|)
operator|)
condition|)
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
name|decl
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|grokvardecl
parameter_list|(
name|type
parameter_list|,
name|declarator
parameter_list|,
name|specbits
parameter_list|,
name|initialized
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|declarator
decl_stmt|;
name|RID_BIT_TYPE
name|specbits
decl_stmt|;
name|int
name|initialized
decl_stmt|;
block|{
name|tree
name|decl
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
block|{
comment|/* If you declare a static member so that it 	 can be initialized, the code will reach here.  */
name|tree
name|basetype
init|=
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_lang_field_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|declarator
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|basetype
expr_stmt|;
name|DECL_CLASS_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|basetype
expr_stmt|;
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
operator|=
name|build_static_name
argument_list|(
name|basetype
argument_list|,
name|declarator
argument_list|)
expr_stmt|;
block|}
else|else
name|decl
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|declarator
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_EXTERN
argument_list|,
name|specbits
argument_list|)
condition|)
block|{
name|DECL_THIS_EXTERN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
operator|!
name|initialized
expr_stmt|;
block|}
comment|/* In class context, static means one per class,      public access, and static storage.  */
if|if
condition|(
name|DECL_FIELD_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|DECL_FIELD_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
comment|/* At top level, either `static' or no s.c. makes a definition      (perhaps tentative), and absence of `static' makes it public.  */
elseif|else
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
condition|)
block|{
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
name|RIDBIT_NOTSETP
argument_list|(
name|RID_STATIC
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
comment|/* Not at top level, only `static' makes a static definition.  */
else|else
block|{
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
operator|!
operator|!
name|RIDBIT_SETP
argument_list|(
name|RID_STATIC
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Create a canonical pointer to member function type. */
end_comment

begin_function
name|tree
name|build_ptrmemfunc_type
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|fields
index|[
literal|4
index|]
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|tree
name|u
decl_stmt|;
comment|/* If a canonical type already exists for this type, use it.  We use      this method instead of type_hash_canon, because it only does a      simple equality check on the list of field members.  */
if|if
condition|(
operator|(
name|t
operator|=
name|TYPE_GET_PTRMEMFUNC_TYPE
argument_list|(
name|type
argument_list|)
operator|)
condition|)
return|return
name|t
return|;
name|push_obstacks
argument_list|(
name|TYPE_OBSTACK
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_OBSTACK
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|u
operator|=
name|make_lang_type
argument_list|(
name|UNION_TYPE
argument_list|)
expr_stmt|;
name|fields
index|[
literal|0
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|pfn_identifier
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|fields
index|[
literal|1
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|delta2_identifier
argument_list|,
name|delta_type_node
argument_list|)
expr_stmt|;
name|finish_builtin_type
argument_list|(
name|u
argument_list|,
literal|"__ptrmemfunc_type"
argument_list|,
name|fields
argument_list|,
literal|1
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|u
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|t
operator|=
name|make_lang_type
argument_list|(
name|RECORD_TYPE
argument_list|)
expr_stmt|;
comment|/* Let the front-end know this is a pointer to member function. */
name|TYPE_PTRMEMFUNC_FLAG
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* and not really an aggregate.  */
name|IS_AGGR_TYPE
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
name|fields
index|[
literal|0
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|delta_identifier
argument_list|,
name|delta_type_node
argument_list|)
expr_stmt|;
name|fields
index|[
literal|1
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|index_identifier
argument_list|,
name|delta_type_node
argument_list|)
expr_stmt|;
name|fields
index|[
literal|2
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|pfn_or_delta2_identifier
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|finish_builtin_type
argument_list|(
name|t
argument_list|,
literal|"__ptrmemfunc_type"
argument_list|,
name|fields
argument_list|,
literal|2
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
comment|/* Zap out the name so that the back-end will give us the debugging      information for this anonymous RECORD_TYPE.  */
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|TYPE_SET_PTRMEMFUNC_TYPE
argument_list|(
name|type
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* Seems to be wanted. */
name|CLASSTYPE_GOT_SEMICOLON
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Given declspecs and a declarator,    determine the name and type of the object declared    and construct a ..._DECL node for it.    (In one case we can return a ..._TYPE node instead.     For invalid input we sometimes return 0.)     DECLSPECS is a chain of tree_list nodes whose value fields     are the storage classes and type specifiers.     DECL_CONTEXT says which syntactic context this declaration is in:      NORMAL for most contexts.  Make a VAR_DECL or FUNCTION_DECL or TYPE_DECL.      FUNCDEF for a function definition.  Like NORMAL but a few different       error messages in each case.  Return value may be zero meaning       this definition is too screwy to try to parse.      MEMFUNCDEF for a function definition.  Like FUNCDEF but prepares to       handle member functions (which have FIELD context).       Return value may be zero meaning this definition is too screwy to       try to parse.      PARM for a parameter declaration (either within a function prototype       or before a function body).  Make a PARM_DECL, or return void_type_node.      TYPENAME if for a typename (in a cast or sizeof).       Don't make a DECL node; just return the ..._TYPE node.      FIELD for a struct or union field; make a FIELD_DECL.      BITFIELD for a field with specified width.    INITIALIZED is 1 if the decl has an initializer.     In the TYPENAME case, DECLARATOR is really an absolute declarator.    It may also be so in the PARM case, for a prototype where the    argument type is specified but not the name.     This function is where the complicated C meanings of `static'    and `extern' are interpreted.     For C++, if there is any monkey business to do, the function which    calls this one must do it, i.e., prepending instance variables,    renaming overloaded function names, etc.     Note that for this C++, it is an error to define a method within a class    which does not belong to that class.     Except in the case where SCOPE_REFs are implicitly known (such as    methods within a class being redundantly qualified),    declarations which involve SCOPE_REFs are returned as SCOPE_REFs    (class_name::decl_name).  The caller must also deal with this.     If a constructor or destructor is seen, and the context is FIELD,    then the type gains the attribute TREE_HAS_x.  If such a declaration    is erroneous, NULL_TREE is returned.     QUALS is used only for FUNCDEF and MEMFUNCDEF cases.  For a member    function, these are the qualifiers to give to the `this' pointer.     May return void_type_node if the declarator turned out to be a friend.    See grokfield for details.  */
end_comment

begin_enum
enum|enum
name|return_types
block|{
name|return_normal
block|,
name|return_ctor
block|,
name|return_dtor
block|,
name|return_conversion
block|}
enum|;
end_enum

begin_function
name|tree
name|grokdeclarator
parameter_list|(
name|declarator
parameter_list|,
name|declspecs
parameter_list|,
name|decl_context
parameter_list|,
name|initialized
parameter_list|,
name|raises
parameter_list|)
name|tree
name|declspecs
decl_stmt|;
name|tree
name|declarator
decl_stmt|;
name|enum
name|decl_context
name|decl_context
decl_stmt|;
name|int
name|initialized
decl_stmt|;
name|tree
name|raises
decl_stmt|;
block|{
name|RID_BIT_TYPE
name|specbits
decl_stmt|;
name|int
name|nclasses
init|=
literal|0
decl_stmt|;
name|tree
name|spec
decl_stmt|;
name|tree
name|type
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|longlong
init|=
literal|0
decl_stmt|;
name|int
name|constp
decl_stmt|;
name|int
name|volatilep
decl_stmt|;
name|int
name|virtualp
decl_stmt|,
name|friendp
decl_stmt|,
name|inlinep
decl_stmt|,
name|staticp
decl_stmt|;
name|int
name|explicit_int
init|=
literal|0
decl_stmt|;
name|int
name|explicit_char
init|=
literal|0
decl_stmt|;
name|int
name|opaque_typedef
init|=
literal|0
decl_stmt|;
name|tree
name|typedef_decl
init|=
name|NULL_TREE
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|tree
name|typedef_type
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|funcdef_flag
init|=
literal|0
decl_stmt|;
name|enum
name|tree_code
name|innermost_code
init|=
name|ERROR_MARK
decl_stmt|;
name|int
name|bitfield
init|=
literal|0
decl_stmt|;
name|int
name|size_varies
init|=
literal|0
decl_stmt|;
comment|/* Set this to error_mark_node for FIELD_DECLs we could not handle properly.      All FIELD_DECLs we build here have `init' put into their DECL_INITIAL.  */
name|tree
name|init
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Keep track of what sort of function is being processed      so that we can warn about default return values, or explicit      return values which do not match prescribed defaults.  */
name|enum
name|return_types
name|return_type
init|=
name|return_normal
decl_stmt|;
name|tree
name|dname
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|ctype
init|=
name|current_class_type
decl_stmt|;
name|tree
name|ctor_return_type
init|=
name|NULL_TREE
decl_stmt|;
name|enum
name|overload_flags
name|flags
init|=
name|NO_SPECIAL
decl_stmt|;
name|tree
name|quals
init|=
name|NULL_TREE
decl_stmt|;
name|RIDBIT_RESET_ALL
argument_list|(
name|specbits
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl_context
operator|==
name|FUNCDEF
condition|)
name|funcdef_flag
operator|=
literal|1
operator|,
name|decl_context
operator|=
name|NORMAL
expr_stmt|;
elseif|else
if|if
condition|(
name|decl_context
operator|==
name|MEMFUNCDEF
condition|)
name|funcdef_flag
operator|=
operator|-
literal|1
operator|,
name|decl_context
operator|=
name|FIELD
expr_stmt|;
elseif|else
if|if
condition|(
name|decl_context
operator|==
name|BITFIELD
condition|)
name|bitfield
operator|=
literal|1
operator|,
name|decl_context
operator|=
name|FIELD
expr_stmt|;
if|if
condition|(
name|flag_traditional
operator|&&
name|allocation_temporary_p
argument_list|()
condition|)
name|end_temporary_allocation
argument_list|()
expr_stmt|;
comment|/* Look inside a declarator for the name being declared      and get it as a string, for an error message.  */
block|{
name|tree
name|last
init|=
name|NULL_TREE
decl_stmt|;
specifier|register
name|tree
name|decl
init|=
name|declarator
decl_stmt|;
name|name
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|decl
condition|)
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
case|case
name|COND_EXPR
case|:
name|ctype
operator|=
name|NULL_TREE
expr_stmt|;
name|decl
operator|=
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIT_NOT_EXPR
case|:
comment|/* for C++ destructors!  */
block|{
name|tree
name|name
init|=
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|rename
init|=
name|NULL_TREE
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|flags
operator|==
name|NO_SPECIAL
argument_list|,
literal|152
argument_list|)
expr_stmt|;
name|flags
operator|=
name|DTOR_FLAG
expr_stmt|;
name|return_type
operator|=
name|return_dtor
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|IDENTIFIER_NODE
argument_list|,
literal|153
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctype
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|current_class_type
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"destructors must be member functions"
argument_list|)
expr_stmt|;
name|flags
operator|=
name|NO_SPECIAL
expr_stmt|;
block|}
else|else
block|{
name|tree
name|t
init|=
name|constructor_name
argument_list|(
name|current_class_name
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|!=
name|name
condition|)
name|rename
operator|=
name|t
expr_stmt|;
block|}
block|}
else|else
block|{
name|tree
name|t
init|=
name|constructor_name
argument_list|(
name|ctype
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|!=
name|name
condition|)
name|rename
operator|=
name|t
expr_stmt|;
block|}
if|if
condition|(
name|rename
condition|)
block|{
name|error
argument_list|(
literal|"destructor `%s' must match class name `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|rename
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
operator|=
name|rename
expr_stmt|;
block|}
name|decl
operator|=
name|name
expr_stmt|;
block|}
break|break;
case|case
name|ADDR_EXPR
case|:
comment|/* C++ reference declaration */
comment|/* fall through */
case|case
name|ARRAY_REF
case|:
case|case
name|INDIRECT_REF
case|:
name|ctype
operator|=
name|NULL_TREE
expr_stmt|;
name|innermost_code
operator|=
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|last
operator|=
name|decl
expr_stmt|;
name|decl
operator|=
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|CALL_EXPR
case|:
if|if
condition|(
name|parmlist_is_exprlist
argument_list|(
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
comment|/* This is actually a variable declaration using constructor 		 syntax.  We need to call start_decl and finish_decl so we 		 can get the variable initialized...  */
if|if
condition|(
name|last
condition|)
comment|/* We need to insinuate ourselves into the declarator in place 		   of the CALL_EXPR.  */
name|TREE_OPERAND
argument_list|(
name|last
argument_list|,
literal|0
argument_list|)
operator|=
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|declarator
operator|=
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|init
operator|=
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|decl
operator|=
name|start_decl
argument_list|(
name|declarator
argument_list|,
name|declspecs
argument_list|,
literal|1
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|decl
argument_list|,
name|init
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|innermost_code
operator|=
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|decl
operator|=
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl_context
operator|==
name|FIELD
operator|&&
name|ctype
operator|==
name|NULL_TREE
condition|)
name|ctype
operator|=
name|current_class_type
expr_stmt|;
if|if
condition|(
name|ctype
operator|!=
name|NULL_TREE
operator|&&
name|decl
operator|!=
name|NULL_TREE
operator|&&
name|flags
operator|!=
name|DTOR_FLAG
operator|&&
name|decl
operator|==
name|constructor_name
argument_list|(
name|ctype
argument_list|)
condition|)
block|{
name|return_type
operator|=
name|return_ctor
expr_stmt|;
name|ctor_return_type
operator|=
name|ctype
expr_stmt|;
block|}
name|ctype
operator|=
name|NULL_TREE
expr_stmt|;
break|break;
case|case
name|IDENTIFIER_NODE
case|:
name|dname
operator|=
name|decl
expr_stmt|;
name|decl
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
operator|!
name|IDENTIFIER_OPNAME_P
argument_list|(
name|dname
argument_list|)
comment|/* Linux headers use '__op'.  Arrgh.  */
operator|||
name|IDENTIFIER_TYPENAME_P
argument_list|(
name|dname
argument_list|)
operator|&&
operator|!
name|TREE_TYPE
argument_list|(
name|dname
argument_list|)
condition|)
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|dname
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|IDENTIFIER_TYPENAME_P
argument_list|(
name|dname
argument_list|)
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|flags
operator|==
name|NO_SPECIAL
argument_list|,
literal|154
argument_list|)
expr_stmt|;
name|flags
operator|=
name|TYPENAME_FLAG
expr_stmt|;
name|ctor_return_type
operator|=
name|TREE_TYPE
argument_list|(
name|dname
argument_list|)
expr_stmt|;
name|return_type
operator|=
name|return_conversion
expr_stmt|;
block|}
name|name
operator|=
name|operator_name_string
argument_list|(
name|dname
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
comment|/* Parse error puts this typespec where 	     a declarator should go.  */
name|error
argument_list|(
literal|"declarator name missing"
argument_list|)
expr_stmt|;
name|dname
operator|=
name|TYPE_NAME
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|dname
operator|&&
name|TREE_CODE
argument_list|(
name|dname
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|dname
operator|=
name|DECL_NAME
argument_list|(
name|dname
argument_list|)
expr_stmt|;
name|name
operator|=
name|dname
condition|?
name|IDENTIFIER_POINTER
argument_list|(
name|dname
argument_list|)
else|:
literal|"<nameless>"
expr_stmt|;
name|declspecs
operator|=
name|temp_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|decl
argument_list|,
name|declspecs
argument_list|)
expr_stmt|;
name|decl
operator|=
name|NULL_TREE
expr_stmt|;
break|break;
comment|/* C++ extension */
case|case
name|SCOPE_REF
case|:
block|{
comment|/* Perform error checking, and convert class names to types. 	       We may call grokdeclarator multiple times for the same 	       tree structure, so only do the conversion once.  In this 	       case, we have exactly what we want for `ctype'.  */
name|tree
name|cname
init|=
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|cname
operator|==
name|NULL_TREE
condition|)
name|ctype
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Can't use IS_AGGR_TYPE because CNAME might not be a type.  */
elseif|else
if|if
condition|(
name|IS_AGGR_TYPE_CODE
argument_list|(
name|TREE_CODE
argument_list|(
name|cname
argument_list|)
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|cname
argument_list|)
operator|==
name|UNINSTANTIATED_P_TYPE
condition|)
name|ctype
operator|=
name|cname
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|is_aggr_typedef
argument_list|(
name|cname
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
comment|/* Must test TREE_OPERAND (decl, 1), in case user gives 	       us `typedef (class::memfunc)(int); memfunc *memfuncptr;'  */
elseif|else
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
block|{
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
operator|=
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|cname
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctype
operator|==
name|NULL_TREE
condition|)
block|{
name|ctype
operator|=
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|cname
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
operator|=
name|ctype
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_COMPLEXITY
argument_list|(
name|decl
argument_list|)
operator|==
name|current_class_depth
condition|)
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
operator|=
name|ctype
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|UNIQUELY_DERIVED_FROM_P
argument_list|(
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|cname
argument_list|)
argument_list|,
name|ctype
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"type `%T' is not derived from type `%T'"
argument_list|,
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|cname
argument_list|)
argument_list|,
name|ctype
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
block|{
name|ctype
operator|=
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|cname
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
operator|=
name|ctype
expr_stmt|;
block|}
block|}
name|decl
operator|=
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctype
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|&&
name|constructor_name
argument_list|(
name|ctype
argument_list|)
operator|==
name|decl
condition|)
block|{
name|return_type
operator|=
name|return_ctor
expr_stmt|;
name|ctor_return_type
operator|=
name|ctype
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|BIT_NOT_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|&&
name|constructor_name
argument_list|(
name|ctype
argument_list|)
operator|==
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|return_type
operator|=
name|return_dtor
expr_stmt|;
name|ctor_return_type
operator|=
name|ctype
expr_stmt|;
name|flags
operator|=
name|DTOR_FLAG
expr_stmt|;
name|decl
operator|=
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|ERROR_MARK
case|:
name|decl
operator|=
name|NULL_TREE
expr_stmt|;
break|break;
default|default:
return|return
literal|0
return|;
comment|/* We used to do a 155 abort here.  */
block|}
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
name|name
operator|=
literal|"type name"
expr_stmt|;
block|}
comment|/* A function definition's declarator must have the form of      a function declarator.  */
if|if
condition|(
name|funcdef_flag
operator|&&
name|innermost_code
operator|!=
name|CALL_EXPR
condition|)
return|return
literal|0
return|;
comment|/* Anything declared one level down from the top level      must be one of the parameters of a function      (because the body is at least two levels down).  */
comment|/* This heuristic cannot be applied to C++ nodes! Fixed, however,      by not allowing C++ class definitions to specify their parameters      with xdecls (must be spec.d in the parmlist).       Since we now wait to push a class scope until we are sure that      we are in a legitimate method context, we must set oldcname      explicitly (since current_class_name is not yet alive).  */
if|if
condition|(
name|decl_context
operator|==
name|NORMAL
operator|&&
name|current_binding_level
operator|->
name|level_chain
operator|==
name|global_binding_level
condition|)
name|decl_context
operator|=
name|PARM
expr_stmt|;
comment|/* Look through the decl specs and record which ones appear.      Some typespecs are defined as built-in typenames.      Others, the ones that are modifiers of other types,      are represented by bits in SPECBITS: set the bits for      the modifiers that appear.  Storage class keywords are also in SPECBITS.       If there is a typedef name or a type, store the type in TYPE.      This includes builtin typedefs such as `int'.       Set EXPLICIT_INT if the type is `int' or `char' and did not      come from a user typedef.       Set LONGLONG if `long' is mentioned twice.       For C++, constructors and destructors have their own fast treatment.  */
for|for
control|(
name|spec
operator|=
name|declspecs
init|;
name|spec
condition|;
name|spec
operator|=
name|TREE_CHAIN
argument_list|(
name|spec
argument_list|)
control|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|tree
name|id
decl_stmt|;
comment|/* Certain parse errors slip through.  For example, 	 `int class;' is not caught by the parser. Try 	 weakly to recover here.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|spec
argument_list|)
operator|!=
name|TREE_LIST
condition|)
return|return
literal|0
return|;
name|id
operator|=
name|TREE_VALUE
argument_list|(
name|spec
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
if|if
condition|(
name|id
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_INT
index|]
operator|||
name|id
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CHAR
index|]
operator|||
name|id
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_BOOL
index|]
operator|||
name|id
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_WCHAR
index|]
condition|)
block|{
if|if
condition|(
name|type
condition|)
name|error
argument_list|(
literal|"extraneous `%T' ignored"
argument_list|,
name|id
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|id
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_INT
index|]
condition|)
name|explicit_int
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|id
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CHAR
index|]
condition|)
name|explicit_char
operator|=
literal|1
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
block|}
goto|goto
name|found
goto|;
block|}
comment|/* C++ aggregate types. */
if|if
condition|(
name|IDENTIFIER_HAS_TYPE_VALUE
argument_list|(
name|id
argument_list|)
condition|)
block|{
if|if
condition|(
name|type
condition|)
name|cp_error
argument_list|(
literal|"multiple declarations `%T' and `%T'"
argument_list|,
name|type
argument_list|,
name|id
argument_list|)
expr_stmt|;
else|else
name|type
operator|=
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|id
argument_list|)
expr_stmt|;
goto|goto
name|found
goto|;
block|}
for|for
control|(
name|i
operator|=
operator|(
name|int
operator|)
name|RID_FIRST_MODIFIER
init|;
name|i
operator|<=
operator|(
name|int
operator|)
name|RID_LAST_MODIFIER
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ridpointers
index|[
name|i
index|]
operator|==
name|id
condition|)
block|{
if|if
condition|(
name|i
operator|==
operator|(
name|int
operator|)
name|RID_LONG
operator|&&
name|RIDBIT_SETP
argument_list|(
name|i
argument_list|,
name|specbits
argument_list|)
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
name|flag_ansi
condition|)
name|pedwarn
argument_list|(
literal|"duplicate `long'"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|longlong
condition|)
name|error
argument_list|(
literal|"`long long long' is too long for GCC"
argument_list|)
expr_stmt|;
else|else
name|longlong
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|i
argument_list|,
name|specbits
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"duplicate `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
name|RIDBIT_SET
argument_list|(
name|i
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
goto|goto
name|found
goto|;
block|}
block|}
block|}
if|if
condition|(
name|type
condition|)
name|error
argument_list|(
literal|"two or more data types in declaration of `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
specifier|register
name|tree
name|t
init|=
name|lookup_name
argument_list|(
name|id
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|t
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
name|error
argument_list|(
literal|"`%s' fails to be a typedef or built in type"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|typedef_decl
operator|=
name|t
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|!=
name|ERROR_MARK
condition|)
comment|/* Can't change CLASS nodes into RECORD nodes here!  */
name|type
operator|=
name|id
expr_stmt|;
name|found
label|:
empty_stmt|;
block|}
name|typedef_type
operator|=
name|type
expr_stmt|;
comment|/* No type at all: default to `int', and set EXPLICIT_INT      because it was not a user-defined typedef.      Except when we have a `typedef' inside a signature, in      which case the type defaults to `unknown type' and is      instantiated when assigning to a signature pointer or ref.  */
if|if
condition|(
name|type
operator|==
name|NULL_TREE
operator|&&
operator|(
name|RIDBIT_SETP
argument_list|(
name|RID_SIGNED
argument_list|,
name|specbits
argument_list|)
operator|||
name|RIDBIT_SETP
argument_list|(
name|RID_UNSIGNED
argument_list|,
name|specbits
argument_list|)
operator|||
name|RIDBIT_SETP
argument_list|(
name|RID_LONG
argument_list|,
name|specbits
argument_list|)
operator|||
name|RIDBIT_SETP
argument_list|(
name|RID_SHORT
argument_list|,
name|specbits
argument_list|)
operator|)
condition|)
block|{
comment|/* These imply 'int'.  */
name|type
operator|=
name|integer_type_node
expr_stmt|;
name|explicit_int
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
name|NULL_TREE
condition|)
block|{
name|explicit_int
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|return_type
operator|==
name|return_dtor
condition|)
name|type
operator|=
name|void_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|return_type
operator|==
name|return_ctor
condition|)
name|type
operator|=
name|TYPE_POINTER_TO
argument_list|(
name|ctor_return_type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|return_type
operator|==
name|return_conversion
condition|)
name|type
operator|=
name|ctor_return_type
expr_stmt|;
elseif|else
if|if
condition|(
name|current_class_type
operator|&&
name|IS_SIGNATURE
argument_list|(
name|current_class_type
argument_list|)
operator|&&
operator|(
name|RIDBIT_SETP
argument_list|(
name|RID_TYPEDEF
argument_list|,
name|specbits
argument_list|)
operator|||
name|SIGNATURE_GROKKING_TYPEDEF
argument_list|(
name|current_class_type
argument_list|)
operator|)
operator|&&
operator|(
name|decl_context
operator|==
name|FIELD
operator|||
name|decl_context
operator|==
name|NORMAL
operator|)
condition|)
block|{
name|explicit_int
operator|=
literal|0
expr_stmt|;
name|opaque_typedef
operator|=
literal|1
expr_stmt|;
name|type
operator|=
name|copy_node
argument_list|(
name|opaque_type_node
argument_list|)
expr_stmt|;
block|}
comment|/* access declaration */
elseif|else
if|if
condition|(
name|decl_context
operator|==
name|FIELD
operator|&&
name|declarator
operator|&&
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|SCOPE_REF
condition|)
name|type
operator|=
name|void_type_node
expr_stmt|;
else|else
block|{
if|if
condition|(
name|funcdef_flag
condition|)
block|{
if|if
condition|(
name|warn_return_type
operator|&&
name|return_type
operator|==
name|return_normal
condition|)
comment|/* Save warning until we know what is really going on.  */
name|warn_about_return_type
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_TYPEDEF
argument_list|,
name|specbits
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C++ forbids typedef which does not specify a type"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|declspecs
operator|==
name|NULL_TREE
operator|&&
operator|(
name|innermost_code
operator|!=
name|CALL_EXPR
operator|||
name|pedantic
operator|)
condition|)
name|cp_pedwarn
argument_list|(
literal|"ANSI C++ forbids declaration `%D' with no type or storage class"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
name|type
operator|=
name|integer_type_node
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|return_type
operator|==
name|return_dtor
condition|)
block|{
name|error
argument_list|(
literal|"return type specification for destructor invalid"
argument_list|)
expr_stmt|;
name|type
operator|=
name|void_type_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|return_type
operator|==
name|return_ctor
condition|)
block|{
name|error
argument_list|(
literal|"return type specification for constructor invalid"
argument_list|)
expr_stmt|;
name|type
operator|=
name|TYPE_POINTER_TO
argument_list|(
name|ctor_return_type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|return_type
operator|==
name|return_conversion
condition|)
block|{
if|if
condition|(
name|comp_target_types
argument_list|(
name|type
argument_list|,
name|ctor_return_type
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|cp_error
argument_list|(
literal|"operator `%T' declared to return `%T'"
argument_list|,
name|ctor_return_type
argument_list|,
name|type
argument_list|)
expr_stmt|;
else|else
name|cp_pedwarn
argument_list|(
literal|"return type specified for `operator %T'"
argument_list|,
name|ctor_return_type
argument_list|)
expr_stmt|;
name|type
operator|=
name|ctor_return_type
expr_stmt|;
block|}
comment|/* Catch typedefs that only specify a type, like 'typedef int;'.  */
elseif|else
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_TYPEDEF
argument_list|,
name|specbits
argument_list|)
operator|&&
name|declarator
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* Template "this is a type" syntax; just ignore for now.  */
if|if
condition|(
name|processing_template_defn
condition|)
return|return
name|void_type_node
return|;
block|}
name|ctype
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Now process the modifiers that were specified      and check for invalid combinations.  */
comment|/* Long double is a special combination.  */
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_LONG
argument_list|,
name|specbits
argument_list|)
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|double_type_node
condition|)
block|{
name|RIDBIT_RESET
argument_list|(
name|RID_LONG
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_type_variant
argument_list|(
name|long_double_type_node
argument_list|,
name|TYPE_READONLY
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_VOLATILE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Check all other uses of type modifiers.  */
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_UNSIGNED
argument_list|,
name|specbits
argument_list|)
operator|||
name|RIDBIT_SETP
argument_list|(
name|RID_SIGNED
argument_list|,
name|specbits
argument_list|)
operator|||
name|RIDBIT_SETP
argument_list|(
name|RID_LONG
argument_list|,
name|specbits
argument_list|)
operator|||
name|RIDBIT_SETP
argument_list|(
name|RID_SHORT
argument_list|,
name|specbits
argument_list|)
condition|)
block|{
name|int
name|ok
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REAL_TYPE
condition|)
name|error
argument_list|(
literal|"short, signed or unsigned invalid for `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|INTEGER_TYPE
operator|||
name|type
operator|==
name|wchar_type_node
condition|)
name|error
argument_list|(
literal|"long, short, signed or unsigned invalid for `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_LONG
argument_list|,
name|specbits
argument_list|)
operator|&&
name|RIDBIT_SETP
argument_list|(
name|RID_SHORT
argument_list|,
name|specbits
argument_list|)
condition|)
name|error
argument_list|(
literal|"long and short specified together for `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|RIDBIT_SETP
argument_list|(
name|RID_LONG
argument_list|,
name|specbits
argument_list|)
operator|||
name|RIDBIT_SETP
argument_list|(
name|RID_SHORT
argument_list|,
name|specbits
argument_list|)
operator|)
operator|&&
name|explicit_char
condition|)
name|error
argument_list|(
literal|"long or short specified with char for `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|RIDBIT_SETP
argument_list|(
name|RID_LONG
argument_list|,
name|specbits
argument_list|)
operator|||
name|RIDBIT_SETP
argument_list|(
name|RID_SHORT
argument_list|,
name|specbits
argument_list|)
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REAL_TYPE
condition|)
name|error
argument_list|(
literal|"long or short specified with floating type for `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_SIGNED
argument_list|,
name|specbits
argument_list|)
operator|&&
name|RIDBIT_SETP
argument_list|(
name|RID_UNSIGNED
argument_list|,
name|specbits
argument_list|)
condition|)
name|error
argument_list|(
literal|"signed and unsigned given together for `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
block|{
name|ok
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|explicit_int
operator|&&
operator|!
name|explicit_char
operator|&&
name|pedantic
condition|)
block|{
name|pedwarn
argument_list|(
literal|"long, short, signed or unsigned used invalidly for `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_pedantic_errors
condition|)
name|ok
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Discard the type modifiers if they are invalid.  */
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|RIDBIT_RESET
argument_list|(
name|RID_UNSIGNED
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
name|RIDBIT_RESET
argument_list|(
name|RID_SIGNED
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
name|RIDBIT_RESET
argument_list|(
name|RID_LONG
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
name|RIDBIT_RESET
argument_list|(
name|RID_SHORT
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
name|longlong
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Decide whether an integer type is signed or not.      Optionally treat bitfields as signed by default.  */
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_UNSIGNED
argument_list|,
name|specbits
argument_list|)
comment|/* Traditionally, all bitfields are unsigned.  */
operator|||
operator|(
name|bitfield
operator|&&
name|flag_traditional
operator|)
operator|||
operator|(
name|bitfield
operator|&&
operator|!
name|flag_signed_bitfields
operator|&&
operator|(
name|explicit_int
operator|||
name|explicit_char
comment|/* A typedef for plain `int' without `signed' 		 can be controlled just like plain `int'.  */
operator|||
operator|!
operator|(
name|typedef_decl
operator|!=
name|NULL_TREE
operator|&&
name|C_TYPEDEF_EXPLICITLY_SIGNED
argument_list|(
name|typedef_decl
argument_list|)
operator|)
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|ENUMERAL_TYPE
operator|&&
name|RIDBIT_NOTSETP
argument_list|(
name|RID_SIGNED
argument_list|,
name|specbits
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|longlong
condition|)
name|type
operator|=
name|long_long_unsigned_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_LONG
argument_list|,
name|specbits
argument_list|)
condition|)
name|type
operator|=
name|long_unsigned_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_SHORT
argument_list|,
name|specbits
argument_list|)
condition|)
name|type
operator|=
name|short_unsigned_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|char_type_node
condition|)
name|type
operator|=
name|unsigned_char_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|typedef_decl
condition|)
name|type
operator|=
name|unsigned_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
else|else
name|type
operator|=
name|unsigned_type_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_SIGNED
argument_list|,
name|specbits
argument_list|)
operator|&&
name|type
operator|==
name|char_type_node
condition|)
name|type
operator|=
name|signed_char_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|longlong
condition|)
name|type
operator|=
name|long_long_integer_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_LONG
argument_list|,
name|specbits
argument_list|)
condition|)
name|type
operator|=
name|long_integer_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_SHORT
argument_list|,
name|specbits
argument_list|)
condition|)
name|type
operator|=
name|short_integer_type_node
expr_stmt|;
comment|/* Set CONSTP if this declaration is `const', whether by      explicit specification or via a typedef.      Likewise for VOLATILEP.  */
name|constp
operator|=
operator|!
operator|!
name|RIDBIT_SETP
argument_list|(
name|RID_CONST
argument_list|,
name|specbits
argument_list|)
operator|+
name|TYPE_READONLY
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|volatilep
operator|=
operator|!
operator|!
name|RIDBIT_SETP
argument_list|(
name|RID_VOLATILE
argument_list|,
name|specbits
argument_list|)
operator|+
name|TYPE_VOLATILE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|staticp
operator|=
literal|0
expr_stmt|;
name|inlinep
operator|=
operator|!
operator|!
name|RIDBIT_SETP
argument_list|(
name|RID_INLINE
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* This sort of redundancy is blessed in a footnote to the Sep 94 WP.  */
block|if (constp> 1)     warning ("duplicate `const'");   if (volatilep> 1)     warning ("duplicate `volatile'");
endif|#
directive|endif
name|virtualp
operator|=
name|RIDBIT_SETP
argument_list|(
name|RID_VIRTUAL
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_STATIC
argument_list|,
name|specbits
argument_list|)
condition|)
name|staticp
operator|=
literal|1
operator|+
operator|(
name|decl_context
operator|==
name|FIELD
operator|)
expr_stmt|;
if|if
condition|(
name|virtualp
operator|&&
name|staticp
operator|==
literal|2
condition|)
block|{
name|cp_error
argument_list|(
literal|"member `%D' cannot be declared both virtual and static"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
name|staticp
operator|=
literal|0
expr_stmt|;
block|}
name|friendp
operator|=
name|RIDBIT_SETP
argument_list|(
name|RID_FRIEND
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
name|RIDBIT_RESET
argument_list|(
name|RID_VIRTUAL
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
name|RIDBIT_RESET
argument_list|(
name|RID_FRIEND
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_MUTABLE
argument_list|,
name|specbits
argument_list|)
condition|)
block|{
if|if
condition|(
name|decl_context
operator|==
name|PARM
condition|)
block|{
name|error
argument_list|(
literal|"non-member `%s' cannot be declared mutable"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|RIDBIT_RESET
argument_list|(
name|RID_MUTABLE
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|friendp
operator|||
name|decl_context
operator|==
name|TYPENAME
condition|)
block|{
name|error
argument_list|(
literal|"non-object member `%s' cannot be declared mutable"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|RIDBIT_RESET
argument_list|(
name|RID_MUTABLE
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|staticp
condition|)
block|{
name|error
argument_list|(
literal|"static `%s' cannot be declared mutable"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|RIDBIT_RESET
argument_list|(
name|RID_MUTABLE
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|if (RIDBIT_SETP (RID_TYPEDEF, specbits)) 	{ 	  error ("non-object member `%s' cannot be declared mutable", name); 	  RIDBIT_RESET (RID_MUTABLE, specbits); 	}
comment|/* Because local typedefs are parsed twice, we don't want this 	 message here. */
block|else if (decl_context != FIELD) 	{ 	  error ("non-member `%s' cannot be declared mutable", name); 	  RIDBIT_RESET (RID_MUTABLE, specbits); 	}
endif|#
directive|endif
block|}
comment|/* Warn if two storage classes are given. Default to `auto'.  */
if|if
condition|(
name|RIDBIT_ANY_SET
argument_list|(
name|specbits
argument_list|)
condition|)
block|{
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_STATIC
argument_list|,
name|specbits
argument_list|)
condition|)
name|nclasses
operator|++
expr_stmt|;
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_EXTERN
argument_list|,
name|specbits
argument_list|)
condition|)
name|nclasses
operator|++
expr_stmt|;
if|if
condition|(
name|decl_context
operator|==
name|PARM
operator|&&
name|nclasses
operator|>
literal|0
condition|)
name|error
argument_list|(
literal|"storage class specifiers invalid in parameter declarations"
argument_list|)
expr_stmt|;
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_TYPEDEF
argument_list|,
name|specbits
argument_list|)
condition|)
block|{
if|if
condition|(
name|decl_context
operator|==
name|PARM
condition|)
name|error
argument_list|(
literal|"typedef declaration invalid in parameter declaration"
argument_list|)
expr_stmt|;
name|nclasses
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_AUTO
argument_list|,
name|specbits
argument_list|)
condition|)
name|nclasses
operator|++
expr_stmt|;
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_REGISTER
argument_list|,
name|specbits
argument_list|)
condition|)
name|nclasses
operator|++
expr_stmt|;
block|}
comment|/* Give error if `virtual' is used outside of class declaration.  */
if|if
condition|(
name|virtualp
operator|&&
name|current_class_name
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"virtual outside class declaration"
argument_list|)
expr_stmt|;
name|virtualp
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|current_class_name
operator|==
name|NULL_TREE
operator|&&
name|RIDBIT_SETP
argument_list|(
name|RID_MUTABLE
argument_list|,
name|specbits
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"only members can be declared mutable"
argument_list|)
expr_stmt|;
name|RIDBIT_RESET
argument_list|(
name|RID_MUTABLE
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
block|}
comment|/* Static anonymous unions are dealt with here.  */
if|if
condition|(
name|staticp
operator|&&
name|decl_context
operator|==
name|TYPENAME
operator|&&
name|TREE_CODE
argument_list|(
name|declspecs
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|declspecs
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
operator|&&
name|ANON_AGGRNAME_P
argument_list|(
name|TYPE_IDENTIFIER
argument_list|(
name|TREE_VALUE
argument_list|(
name|declspecs
argument_list|)
argument_list|)
argument_list|)
condition|)
name|decl_context
operator|=
name|FIELD
expr_stmt|;
comment|/* Give error if `const,' `volatile,' `inline,' `friend,' or `virtual'      is used in a signature member function declaration.  */
if|if
condition|(
name|decl_context
operator|==
name|FIELD
operator|&&
name|IS_SIGNATURE
argument_list|(
name|current_class_type
argument_list|)
operator|&&
name|RIDBIT_NOTSETP
argument_list|(
name|RID_TYPEDEF
argument_list|,
name|specbits
argument_list|)
operator|&&
operator|!
name|SIGNATURE_GROKKING_TYPEDEF
argument_list|(
name|current_class_type
argument_list|)
condition|)
block|{
if|if
condition|(
name|constp
condition|)
block|{
name|error
argument_list|(
literal|"`const' specified for signature member function `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|constp
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|volatilep
condition|)
block|{
name|error
argument_list|(
literal|"`volatile' specified for signature member function `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|volatilep
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|inlinep
condition|)
block|{
name|error
argument_list|(
literal|"`inline' specified for signature member function `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Later, we'll make signature member functions inline.  */
name|inlinep
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|friendp
condition|)
block|{
name|error
argument_list|(
literal|"`friend' declaration in signature definition"
argument_list|)
expr_stmt|;
name|friendp
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|virtualp
condition|)
block|{
name|error
argument_list|(
literal|"`virtual' specified for signature member function `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Later, we'll make signature member functions virtual.  */
name|virtualp
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Warn about storage classes that are invalid for certain      kinds of declarations (parameters, typenames, etc.).  */
if|if
condition|(
name|nclasses
operator|>
literal|1
condition|)
name|error
argument_list|(
literal|"multiple storage classes in declaration of `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|decl_context
operator|!=
name|NORMAL
operator|&&
name|nclasses
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|decl_context
operator|==
name|PARM
operator|&&
operator|(
name|RIDBIT_SETP
argument_list|(
name|RID_REGISTER
argument_list|,
name|specbits
argument_list|)
operator|||
name|RIDBIT_SETP
argument_list|(
name|RID_AUTO
argument_list|,
name|specbits
argument_list|)
operator|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|decl_context
operator|==
name|FIELD
operator|&&
name|RIDBIT_SETP
argument_list|(
name|RID_TYPEDEF
argument_list|,
name|specbits
argument_list|)
condition|)
block|{
comment|/* Processing a typedef declaration nested within a class type 	     definition.  */
specifier|register
name|tree
name|scanner
decl_stmt|;
specifier|register
name|tree
name|previous_declspec
decl_stmt|;
name|tree
name|loc_typedecl
decl_stmt|;
if|if
condition|(
name|initialized
condition|)
name|error
argument_list|(
literal|"typedef declaration includes an initializer"
argument_list|)
expr_stmt|;
comment|/* To process a class-local typedef declaration, we descend down 	     the chain of declspecs looking for the `typedef' spec.  When 	     we find it, we replace it with `static', and then recursively 	     call `grokdeclarator' with the original declarator and with 	     the newly adjusted declspecs.  This call should return a 	     FIELD_DECL node with the TREE_TYPE (and other parts) set 	     appropriately.  We can then just change the TREE_CODE on that 	     from FIELD_DECL to TYPE_DECL and we're done.  */
for|for
control|(
name|previous_declspec
operator|=
name|NULL_TREE
operator|,
name|scanner
operator|=
name|declspecs
init|;
name|scanner
condition|;
name|previous_declspec
operator|=
name|scanner
operator|,
name|scanner
operator|=
name|TREE_CHAIN
argument_list|(
name|scanner
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|scanner
argument_list|)
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_TYPEDEF
index|]
condition|)
break|break;
block|}
if|if
condition|(
name|previous_declspec
condition|)
name|TREE_CHAIN
argument_list|(
name|previous_declspec
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|scanner
argument_list|)
expr_stmt|;
else|else
name|declspecs
operator|=
name|TREE_CHAIN
argument_list|(
name|scanner
argument_list|)
expr_stmt|;
name|declspecs
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_STATIC
index|]
argument_list|,
name|declspecs
argument_list|)
expr_stmt|;
comment|/* In the recursive call to grokdeclarator we need to know 	     whether we are working on a signature-local typedef.  */
if|if
condition|(
name|IS_SIGNATURE
argument_list|(
name|current_class_type
argument_list|)
condition|)
name|SIGNATURE_GROKKING_TYPEDEF
argument_list|(
name|current_class_type
argument_list|)
operator|=
literal|1
expr_stmt|;
name|loc_typedecl
operator|=
name|grokdeclarator
argument_list|(
name|declarator
argument_list|,
name|declspecs
argument_list|,
name|FIELD
argument_list|,
literal|0
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|previous_declspec
condition|)
name|TREE_CHAIN
argument_list|(
name|previous_declspec
argument_list|)
operator|=
name|scanner
expr_stmt|;
if|if
condition|(
name|loc_typedecl
operator|!=
name|error_mark_node
condition|)
block|{
specifier|register
name|int
name|i
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|lang_decl_flags
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
decl_stmt|;
specifier|register
name|int
modifier|*
name|pi
decl_stmt|;
name|TREE_SET_CODE
argument_list|(
name|loc_typedecl
argument_list|,
name|TYPE_DECL
argument_list|)
expr_stmt|;
comment|/* This is the same field as DECL_ARGUMENTS, which is set for 		 function typedefs by the above grokdeclarator.  */
name|DECL_NESTED_TYPENAME
argument_list|(
name|loc_typedecl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|pi
operator|=
operator|(
name|int
operator|*
operator|)
name|permalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|lang_decl_flags
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|>
literal|0
condition|)
name|pi
index|[
operator|--
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|DECL_LANG_SPECIFIC
argument_list|(
name|loc_typedecl
argument_list|)
operator|=
operator|(
expr|struct
name|lang_decl
operator|*
operator|)
name|pi
expr_stmt|;
block|}
if|if
condition|(
name|IS_SIGNATURE
argument_list|(
name|current_class_type
argument_list|)
condition|)
block|{
name|SIGNATURE_GROKKING_TYPEDEF
argument_list|(
name|current_class_type
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|loc_typedecl
operator|!=
name|error_mark_node
operator|&&
name|opaque_typedef
condition|)
name|SIGNATURE_HAS_OPAQUE_TYPEDECLS
argument_list|(
name|current_class_type
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|loc_typedecl
return|;
block|}
elseif|else
if|if
condition|(
name|decl_context
operator|==
name|FIELD
operator|&&
operator|(
operator|!
name|IS_SIGNATURE
argument_list|(
name|current_class_type
argument_list|)
operator|||
name|SIGNATURE_GROKKING_TYPEDEF
argument_list|(
name|current_class_type
argument_list|)
operator|)
comment|/* C++ allows static class elements  */
operator|&&
name|RIDBIT_SETP
argument_list|(
name|RID_STATIC
argument_list|,
name|specbits
argument_list|)
condition|)
comment|/* C++ also allows inlines and signed and unsigned elements,  	   but in those cases we don't come in here.  */
empty_stmt|;
else|else
block|{
if|if
condition|(
name|decl_context
operator|==
name|FIELD
condition|)
block|{
name|tree
name|tmp
init|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|register
name|int
name|op
init|=
name|IDENTIFIER_OPNAME_P
argument_list|(
name|tmp
argument_list|)
decl_stmt|;
name|error
argument_list|(
literal|"storage class specified for %s `%s'"
argument_list|,
name|IS_SIGNATURE
argument_list|(
name|current_class_type
argument_list|)
condition|?
operator|(
name|op
condition|?
literal|"signature member operator"
else|:
literal|"signature member function"
operator|)
else|:
operator|(
name|op
condition|?
literal|"member operator"
else|:
literal|"structure field"
operator|)
argument_list|,
name|op
condition|?
name|operator_name_string
argument_list|(
name|tmp
argument_list|)
else|:
name|name
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
operator|(
name|decl_context
operator|==
name|PARM
condition|?
literal|"storage class specified for parameter `%s'"
else|:
literal|"storage class specified for typename"
operator|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|RIDBIT_RESET
argument_list|(
name|RID_REGISTER
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
name|RIDBIT_RESET
argument_list|(
name|RID_AUTO
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
name|RIDBIT_RESET
argument_list|(
name|RID_EXTERN
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl_context
operator|==
name|FIELD
operator|&&
name|IS_SIGNATURE
argument_list|(
name|current_class_type
argument_list|)
condition|)
block|{
name|RIDBIT_RESET
argument_list|(
name|RID_STATIC
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
name|staticp
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_EXTERN
argument_list|,
name|specbits
argument_list|)
operator|&&
name|initialized
operator|&&
operator|!
name|funcdef_flag
condition|)
block|{
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
condition|)
block|{
comment|/* It's common practice (and completely legal) to have a const 	     be initialized and declared extern.  */
if|if
condition|(
operator|!
name|constp
condition|)
name|warning
argument_list|(
literal|"`%s' initialized and declared `extern'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"`%s' has both `extern' and initializer"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_EXTERN
argument_list|,
name|specbits
argument_list|)
operator|&&
name|funcdef_flag
operator|&&
name|current_binding_level
operator|!=
name|global_binding_level
condition|)
name|error
argument_list|(
literal|"nested function `%s' declared `extern'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
condition|)
block|{
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_AUTO
argument_list|,
name|specbits
argument_list|)
condition|)
name|error
argument_list|(
literal|"top-level declaration of `%s' specifies `auto'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (RIDBIT_SETP (RID_REGISTER, specbits)) 	error ("top-level declaration of `%s' specifies `register'", name);
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/* I'm not sure under what circumstances we should turn 	 on the extern bit, and under what circumstances we should 	 warn if other bits are turned on.  */
block|if (decl_context == NORMAL&& RIDBIT_NOSETP (RID_EXTERN, specbits)&& ! root_lang_context_p ()) 	{ 	  RIDBIT_SET (RID_EXTERN, specbits); 	}
endif|#
directive|endif
block|}
comment|/* Now figure out the structure of the declarator proper.      Descend through it, creating more complex types, until we reach      the declared identifier (or NULL_TREE, in an absolute declarator).  */
while|while
condition|(
name|declarator
operator|&&
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|!=
name|IDENTIFIER_NODE
condition|)
block|{
comment|/* Each level of DECLARATOR is either an ARRAY_REF (for ...[..]), 	 an INDIRECT_REF (for *...), 	 a CALL_EXPR (for ...(...)), 	 an identifier (for the name being declared) 	 or a null pointer (for the place in an absolute declarator 	 where the name was omitted). 	 For the last two cases, we have just exited the loop.  	 For C++ it could also be 	 a SCOPE_REF (for class :: ...).  In this case, we have converted 	 sensible names to types, and those are the values we use to 	 qualify the member name. 	 an ADDR_EXPR (for&...), 	 a BIT_NOT_EXPR (for destructors)  	 At this point, TYPE is the type of elements of an array, 	 or for a function to return, or for a pointer to point to. 	 After this sequence of ifs, TYPE is the type of the 	 array or function or pointer, and DECLARATOR has had its 	 outermost layer removed.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ERROR_MARK
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|SCOPE_REF
condition|)
name|declarator
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|declarator
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|quals
operator|!=
name|NULL_TREE
operator|&&
operator|(
name|declarator
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|!=
name|SCOPE_REF
operator|)
condition|)
block|{
if|if
condition|(
name|ctype
operator|==
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|ctype
operator|=
name|TYPE_METHOD_BASETYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctype
operator|!=
name|NULL_TREE
condition|)
block|{
if|#
directive|if
literal|0
comment|/* not yet, should get fixed properly later */
block|tree dummy = make_type_decl (NULL_TREE, type);
else|#
directive|else
name|tree
name|dummy
init|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|type
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|ctype
operator|=
name|grok_method_quals
argument_list|(
name|ctype
argument_list|,
name|dummy
argument_list|,
name|quals
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|dummy
argument_list|)
expr_stmt|;
name|quals
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
condition|)
block|{
case|case
name|ARRAY_REF
case|:
block|{
specifier|register
name|tree
name|itype
init|=
name|NULL_TREE
decl_stmt|;
specifier|register
name|tree
name|size
init|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|declarator
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Check for some types that there cannot be arrays of.  */
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|void_type_node
condition|)
block|{
name|cp_error
argument_list|(
literal|"declaration of `%D' as array of voids"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
name|type
operator|=
name|error_mark_node
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|cp_error
argument_list|(
literal|"declaration of `%D' as array of functions"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
name|type
operator|=
name|error_mark_node
expr_stmt|;
block|}
comment|/* ARM $8.4.3: Since you can't have a pointer to a reference, 	       you can't have arrays of references.  If we allowed them, 	       then we'd be saying x[i] is legal for an array x, but 	       then you'd have to ask: what does `*(x + i)' mean?  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
if|if
condition|(
name|decl_context
operator|==
name|TYPENAME
condition|)
name|cp_error
argument_list|(
literal|"cannot make arrays of references"
argument_list|)
expr_stmt|;
else|else
name|cp_error
argument_list|(
literal|"declaration of `%D' as array of references"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
name|type
operator|=
name|error_mark_node
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
block|{
name|cp_error
argument_list|(
literal|"declaration of `%D' as array of data members"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
name|type
operator|=
name|error_mark_node
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|cp_error
argument_list|(
literal|"declaration of `%D' as array of function members"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
name|type
operator|=
name|error_mark_node
expr_stmt|;
block|}
if|if
condition|(
name|size
operator|==
name|error_mark_node
condition|)
name|type
operator|=
name|error_mark_node
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
continue|continue;
if|if
condition|(
name|size
condition|)
block|{
comment|/* Must suspend_momentary here because the index 		   type may need to live until the end of the function. 		   For example, it is used in the declaration of a 		   variable which requires destructing at the end of 		   the function; then build_vec_delete will need this 		   value.  */
name|int
name|yes
init|=
name|suspend_momentary
argument_list|()
decl_stmt|;
comment|/* might be a cast */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_TYPE
argument_list|(
name|size
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|size
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|size
operator|=
name|TREE_OPERAND
argument_list|(
name|size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If this is a template parameter, it'll be constant, but 		   we don't know what the value is yet.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|TEMPLATE_CONST_PARM
condition|)
goto|goto
name|dont_grok_size
goto|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|size
argument_list|)
argument_list|)
operator|!=
name|INTEGER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|size
argument_list|)
argument_list|)
operator|!=
name|ENUMERAL_TYPE
condition|)
block|{
name|cp_error
argument_list|(
literal|"size of array `%D' has non-integer type"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
name|size
operator|=
name|integer_one_node
expr_stmt|;
block|}
if|if
condition|(
name|TREE_READONLY_DECL_P
argument_list|(
name|size
argument_list|)
condition|)
name|size
operator|=
name|decl_constant_value
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_ansi
operator|&&
name|integer_zerop
argument_list|(
name|size
argument_list|)
condition|)
name|cp_pedwarn
argument_list|(
literal|"ANSI C++ forbids zero-size array `%D'"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|size
argument_list|)
condition|)
block|{
name|constant_expression_warning
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|INT_CST_LT
argument_list|(
name|size
argument_list|,
name|integer_zero_node
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"size of array `%D' is negative"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
name|size
operator|=
name|integer_one_node
expr_stmt|;
block|}
name|itype
operator|=
name|build_index_type
argument_list|(
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|size
argument_list|,
name|integer_one_node
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|flag_ansi
condition|)
block|{
if|if
condition|(
name|dname
condition|)
name|cp_pedwarn
argument_list|(
literal|"ANSI C++ forbids variable-size array `%D'"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
else|else
name|cp_pedwarn
argument_list|(
literal|"ANSI C++ forbids variable-size array"
argument_list|)
expr_stmt|;
block|}
name|dont_grok_size
label|:
name|itype
operator|=
name|build_binary_op
argument_list|(
name|MINUS_EXPR
argument_list|,
name|size
argument_list|,
name|integer_one_node
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Make sure the array size remains visibly nonconstant 		       even if it is (eg) a const variable with known value.  */
name|size_varies
operator|=
literal|1
expr_stmt|;
name|itype
operator|=
name|variable_size
argument_list|(
name|itype
argument_list|)
expr_stmt|;
name|itype
operator|=
name|build_index_type
argument_list|(
name|itype
argument_list|)
expr_stmt|;
block|}
name|resume_momentary
argument_list|(
name|yes
argument_list|)
expr_stmt|;
block|}
comment|/* Build the array type itself, then merge any constancy or 	     volatility into the target type.  We must do it in this order 	     to ensure that the TYPE_MAIN_VARIANT field of the array type 	     is set correctly.  */
name|type
operator|=
name|build_cplus_array_type
argument_list|(
name|type
argument_list|,
name|itype
argument_list|)
expr_stmt|;
if|if
condition|(
name|constp
operator|||
name|volatilep
condition|)
name|type
operator|=
name|cp_build_type_variant
argument_list|(
name|type
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|)
expr_stmt|;
name|ctype
operator|=
name|NULL_TREE
expr_stmt|;
block|}
break|break;
case|case
name|CALL_EXPR
case|:
block|{
name|tree
name|arg_types
decl_stmt|;
name|int
name|funcdecl_p
decl_stmt|;
name|tree
name|inner_parms
init|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|inner_decl
init|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* Declaring a function type. 	       Make sure we have a valid type for the function to return.  */
if|#
directive|if
literal|0
comment|/* Is this an error?  Should they be merged into TYPE here?  */
block|if (pedantic&& (constp || volatilep)) 	      pedwarn ("function declared to return const or volatile result");
else|#
directive|else
comment|/* Merge any constancy or volatility into the function return                type.  */
if|if
condition|(
name|constp
operator|||
name|volatilep
condition|)
block|{
name|type
operator|=
name|cp_build_type_variant
argument_list|(
name|type
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
condition|)
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|constp
operator|=
literal|0
expr_stmt|;
name|volatilep
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Warn about some types functions can't return.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"`%s' declared as function returning a function"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|type
operator|=
name|integer_type_node
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"`%s' declared as function returning an array"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|type
operator|=
name|integer_type_node
expr_stmt|;
block|}
if|if
condition|(
name|inner_decl
operator|&&
name|TREE_CODE
argument_list|(
name|inner_decl
argument_list|)
operator|==
name|SCOPE_REF
condition|)
name|inner_decl
operator|=
name|TREE_OPERAND
argument_list|(
name|inner_decl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Say it's a definition only for the CALL_EXPR 	       closest to the identifier.  */
name|funcdecl_p
operator|=
name|inner_decl
operator|&&
name|TREE_CODE
argument_list|(
name|inner_decl
argument_list|)
operator|==
name|IDENTIFIER_NODE
expr_stmt|;
if|if
condition|(
name|ctype
operator|==
name|NULL_TREE
operator|&&
name|decl_context
operator|==
name|FIELD
operator|&&
name|funcdecl_p
operator|&&
operator|(
name|friendp
operator|==
literal|0
operator|||
name|dname
operator|==
name|current_class_name
operator|)
condition|)
name|ctype
operator|=
name|current_class_type
expr_stmt|;
if|if
condition|(
name|ctype
operator|&&
name|return_type
operator|==
name|return_conversion
condition|)
name|TYPE_HAS_CONVERSION
argument_list|(
name|ctype
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ctype
operator|&&
name|constructor_name
argument_list|(
name|ctype
argument_list|)
operator|==
name|dname
condition|)
block|{
comment|/* We are within a class's scope. If our declarator name 		   is the same as the class name, and we are defining 		   a function, then it is a constructor/destructor, and 		   therefore returns a void type.  */
if|if
condition|(
name|flags
operator|==
name|DTOR_FLAG
condition|)
block|{
comment|/* ANSI C++ June 5 1992 WP 12.4.1.  A destructor may 		       not be declared const or volatile.  A destructor 		       may not be static.  */
if|if
condition|(
name|staticp
operator|==
literal|2
condition|)
name|error
argument_list|(
literal|"destructor cannot be static member function"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_READONLY
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"destructors cannot be declared `const'"
argument_list|)
expr_stmt|;
return|return
name|void_type_node
return|;
block|}
if|if
condition|(
name|TYPE_VOLATILE
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"destructors cannot be declared `volatile'"
argument_list|)
expr_stmt|;
return|return
name|void_type_node
return|;
block|}
if|if
condition|(
name|decl_context
operator|==
name|FIELD
condition|)
block|{
if|if
condition|(
operator|!
name|member_function_or_else
argument_list|(
name|ctype
argument_list|,
name|current_class_type
argument_list|,
literal|"destructor for alien class `%s' cannot be a member"
argument_list|)
condition|)
return|return
name|void_type_node
return|;
block|}
block|}
else|else
comment|/* it's a constructor. */
block|{
comment|/* ANSI C++ June 5 1992 WP 12.1.2.  A constructor may 		       not be declared const or volatile.  A constructor may 		       not be virtual.  A constructor may not be static.  */
if|if
condition|(
name|staticp
operator|==
literal|2
condition|)
name|error
argument_list|(
literal|"constructor cannot be static member function"
argument_list|)
expr_stmt|;
if|if
condition|(
name|virtualp
condition|)
block|{
name|pedwarn
argument_list|(
literal|"constructors cannot be declared virtual"
argument_list|)
expr_stmt|;
name|virtualp
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_READONLY
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"constructors cannot be declared `const'"
argument_list|)
expr_stmt|;
return|return
name|void_type_node
return|;
block|}
if|if
condition|(
name|TYPE_VOLATILE
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"constructors cannot be declared `volatile'"
argument_list|)
expr_stmt|;
return|return
name|void_type_node
return|;
block|}
block|{
name|RID_BIT_TYPE
name|tmp_bits
decl_stmt|;
name|bcopy
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|specbits
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|tmp_bits
argument_list|,
sizeof|sizeof
argument_list|(
name|RID_BIT_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|RIDBIT_RESET
argument_list|(
name|RID_INLINE
argument_list|,
name|tmp_bits
argument_list|)
expr_stmt|;
name|RIDBIT_RESET
argument_list|(
name|RID_STATIC
argument_list|,
name|tmp_bits
argument_list|)
expr_stmt|;
if|if
condition|(
name|RIDBIT_ANY_SET
argument_list|(
name|tmp_bits
argument_list|)
condition|)
name|error
argument_list|(
literal|"return value type specifier for constructor ignored"
argument_list|)
expr_stmt|;
block|}
name|type
operator|=
name|TYPE_POINTER_TO
argument_list|(
name|ctype
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl_context
operator|==
name|FIELD
operator|&&
name|IS_SIGNATURE
argument_list|(
name|current_class_type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"constructor not allowed in signature"
argument_list|)
expr_stmt|;
return|return
name|void_type_node
return|;
block|}
elseif|else
if|if
condition|(
name|decl_context
operator|==
name|FIELD
condition|)
block|{
if|if
condition|(
operator|!
name|member_function_or_else
argument_list|(
name|ctype
argument_list|,
name|current_class_type
argument_list|,
literal|"constructor for alien class `%s' cannot be member"
argument_list|)
condition|)
return|return
name|void_type_node
return|;
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|ctype
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|return_type
operator|!=
name|return_ctor
condition|)
return|return
name|NULL_TREE
return|;
block|}
block|}
if|if
condition|(
name|decl_context
operator|==
name|FIELD
condition|)
name|staticp
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|friendp
operator|&&
name|virtualp
condition|)
block|{
comment|/* Cannot be both friend and virtual.  */
name|error
argument_list|(
literal|"virtual functions cannot be friends"
argument_list|)
expr_stmt|;
name|RIDBIT_RESET
argument_list|(
name|RID_FRIEND
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
name|friendp
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|decl_context
operator|==
name|NORMAL
operator|&&
name|friendp
condition|)
name|error
argument_list|(
literal|"friend declaration not in class definition"
argument_list|)
expr_stmt|;
comment|/* Pick up type qualifiers which should be applied to `this'.  */
name|quals
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Traditionally, declaring return type float means double.  */
if|if
condition|(
name|flag_traditional
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|float_type_node
condition|)
block|{
name|type
operator|=
name|build_type_variant
argument_list|(
name|double_type_node
argument_list|,
name|TYPE_READONLY
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_VOLATILE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Construct the function type and go to the next 	       inner layer of declarator.  */
name|declarator
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* FIXME: This is where default args should be fully 	       processed.  */
name|arg_types
operator|=
name|grokparms
argument_list|(
name|inner_parms
argument_list|,
name|funcdecl_p
condition|?
name|funcdef_flag
else|:
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|declarator
condition|)
block|{
comment|/* Get past destructors, etc. 		   We know we have one because FLAGS will be non-zero.  		   Complain about improper parameter lists here.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|BIT_NOT_EXPR
condition|)
block|{
name|declarator
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strict_prototype
operator|==
literal|0
operator|&&
name|arg_types
operator|==
name|NULL_TREE
condition|)
name|arg_types
operator|=
name|void_list_node
expr_stmt|;
elseif|else
if|if
condition|(
name|arg_types
operator|==
name|NULL_TREE
operator|||
name|arg_types
operator|!=
name|void_list_node
condition|)
block|{
name|error
argument_list|(
literal|"destructors cannot be specified with parameters"
argument_list|)
expr_stmt|;
name|arg_types
operator|=
name|void_list_node
expr_stmt|;
block|}
block|}
block|}
comment|/* ANSI seems to say that `const int foo ();' 	       does not make the function foo const.  */
name|type
operator|=
name|build_function_type
argument_list|(
name|type
argument_list|,
name|flag_traditional
condition|?
literal|0
else|:
name|arg_types
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ADDR_EXPR
case|:
case|case
name|INDIRECT_REF
case|:
comment|/* Filter out pointers-to-references and references-to-references. 	     We can get these if a TYPE_DECL is used.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"cannot declare %s to references"
argument_list|,
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|ADDR_EXPR
condition|?
literal|"references"
else|:
literal|"pointers"
argument_list|)
expr_stmt|;
name|declarator
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Merge any constancy or volatility into the target type 	     for the pointer.  */
if|if
condition|(
name|constp
operator|||
name|volatilep
condition|)
block|{
comment|/* A const or volatile signature pointer/reference is 		 pointing to a const or volatile object, i.e., the 		 `optr' is const or volatile, respectively, not the 		 signature pointer/reference itself.  */
if|if
condition|(
operator|!
name|IS_SIGNATURE
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|type
operator|=
name|cp_build_type_variant
argument_list|(
name|type
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
condition|)
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|constp
operator|=
literal|0
expr_stmt|;
name|volatilep
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|IS_SIGNATURE
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
block|{
if|if
condition|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
condition|)
name|cp_warning
argument_list|(
literal|"empty signature `%T' used in signature reference declaration"
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|type = build_signature_reference_type (type, 							 constp, volatilep);
else|#
directive|else
name|sorry
argument_list|(
literal|"signature reference"
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
endif|#
directive|endif
block|}
else|else
block|{
if|if
condition|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
condition|)
name|cp_warning
argument_list|(
literal|"empty signature `%T' used in signature pointer declaration"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_signature_pointer_type
argument_list|(
name|type
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|)
expr_stmt|;
block|}
name|constp
operator|=
literal|0
expr_stmt|;
name|volatilep
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"cannot declare references to functions; use pointer to function instead"
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|void_type_node
condition|)
name|error
argument_list|(
literal|"invalid type: `void&'"
argument_list|)
expr_stmt|;
else|else
name|type
operator|=
name|build_reference_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|type
operator|=
name|build_ptrmemfunc_type
argument_list|(
name|build_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Process a list of type modifier keywords (such as 	     const or volatile) that were given inside the `*' or `&'.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|declarator
argument_list|)
condition|)
block|{
specifier|register
name|tree
name|typemodlist
decl_stmt|;
name|int
name|erred
init|=
literal|0
decl_stmt|;
for|for
control|(
name|typemodlist
operator|=
name|TREE_TYPE
argument_list|(
name|declarator
argument_list|)
init|;
name|typemodlist
condition|;
name|typemodlist
operator|=
name|TREE_CHAIN
argument_list|(
name|typemodlist
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|typemodlist
argument_list|)
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CONST
index|]
condition|)
name|constp
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|typemodlist
argument_list|)
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_VOLATILE
index|]
condition|)
name|volatilep
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|erred
condition|)
block|{
name|erred
operator|=
literal|1
expr_stmt|;
name|error
argument_list|(
literal|"invalid type modifier within %s declarator"
argument_list|,
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|ADDR_EXPR
condition|?
literal|"reference"
else|:
literal|"pointer"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|constp
operator|>
literal|1
condition|)
name|pedwarn
argument_list|(
literal|"duplicate `const'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|volatilep
operator|>
literal|1
condition|)
name|pedwarn
argument_list|(
literal|"duplicate `volatile'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
operator|(
name|constp
operator|||
name|volatilep
operator|)
condition|)
block|{
if|if
condition|(
name|constp
condition|)
name|warning
argument_list|(
literal|"discarding `const' applied to a reference"
argument_list|)
expr_stmt|;
if|if
condition|(
name|volatilep
condition|)
name|warning
argument_list|(
literal|"discarding `volatile' applied to a reference"
argument_list|)
expr_stmt|;
name|constp
operator|=
name|volatilep
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|declarator
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ctype
operator|=
name|NULL_TREE
expr_stmt|;
break|break;
case|case
name|SCOPE_REF
case|:
block|{
comment|/* We have converted type names to NULL_TREE if the 	       name was bogus, or to a _TYPE node, if not.  	       The variable CTYPE holds the type we will ultimately 	       resolve to.  The code here just needs to build 	       up appropriate member types.  */
name|tree
name|sname
init|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* Destructors can have their visibilities changed as well.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|sname
argument_list|)
operator|==
name|BIT_NOT_EXPR
condition|)
name|sname
operator|=
name|TREE_OPERAND
argument_list|(
name|sname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_COMPLEXITY
argument_list|(
name|declarator
argument_list|)
operator|==
literal|0
condition|)
comment|/* This needs to be here, in case we are called 		 multiple times.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|friendp
operator|&&
operator|(
name|TREE_COMPLEXITY
argument_list|(
name|declarator
argument_list|)
operator|<
literal|2
operator|)
condition|)
comment|/* don't fall out into global scope. Hides real bug? --eichin */
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_COMPLEXITY
argument_list|(
name|declarator
argument_list|)
operator|==
name|current_class_depth
condition|)
block|{
comment|/* This pop_nested_class corresponds to the                    push_nested_class used to push into class scope for                    parsing the argument list of a function decl, in                    qualified_id.  */
name|pop_nested_class
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|TREE_COMPLEXITY
argument_list|(
name|declarator
argument_list|)
operator|=
name|current_class_depth
expr_stmt|;
block|}
else|else
name|my_friendly_abort
argument_list|(
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* We had a reference to a global decl, or 		   perhaps we were given a non-aggregate typedef, 		   in which case we cleared this out, and should just 		   keep going as though it wasn't there.  */
name|declarator
operator|=
name|sname
expr_stmt|;
continue|continue;
block|}
name|ctype
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sname
operator|==
name|NULL_TREE
condition|)
goto|goto
name|done_scoping
goto|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|sname
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
comment|/* This is the `standard' use of the scoping operator: 		   basetype :: member .  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
if|if
condition|(
name|current_class_type
operator|==
name|NULL_TREE
operator|||
name|TYPE_MAIN_VARIANT
argument_list|(
name|ctype
argument_list|)
operator|==
name|current_class_type
operator|||
name|friendp
condition|)
name|type
operator|=
name|build_cplus_method_type
argument_list|(
name|build_type_variant
argument_list|(
name|ctype
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|cp_error
argument_list|(
literal|"cannot declare member function `%T::%s' within `%T'"
argument_list|,
name|ctype
argument_list|,
name|name
argument_list|,
name|current_class_type
argument_list|)
expr_stmt|;
return|return
name|void_type_node
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|ctype
argument_list|)
operator|==
name|current_class_type
condition|)
block|{
if|if
condition|(
name|extra_warnings
condition|)
name|cp_warning
argument_list|(
literal|"redundant qualification `%T' on member `%s' ignored"
argument_list|,
name|ctype
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_offset_type
argument_list|(
name|ctype
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|ctype
argument_list|)
operator|!=
name|NULL_TREE
operator|||
operator|(
name|RIDBIT_SETP
argument_list|(
name|RID_TYPEDEF
argument_list|,
name|specbits
argument_list|)
operator|)
condition|)
block|{
name|tree
name|t
decl_stmt|;
comment|/* have to move this code elsewhere in this function. 		       this code is used for i.e., typedef int A::M; M *pm; */
if|if
condition|(
name|explicit_int
operator|==
operator|-
literal|1
operator|&&
name|decl_context
operator|==
name|FIELD
operator|&&
name|funcdef_flag
operator|==
literal|0
condition|)
block|{
comment|/* The code in here should only be used to build 			   stuff that will be grokked as access decls.  */
name|t
operator|=
name|lookup_field
argument_list|(
name|ctype
argument_list|,
name|sname
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
block|{
name|t
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|build_nt
argument_list|(
name|SCOPE_REF
argument_list|,
name|ctype
argument_list|,
name|t
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
operator|=
name|init
expr_stmt|;
return|return
name|t
return|;
block|}
comment|/* No such field, try member functions.  */
name|t
operator|=
name|lookup_fnfields
argument_list|(
name|TYPE_BINFO
argument_list|(
name|ctype
argument_list|)
argument_list|,
name|sname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
block|{
if|if
condition|(
name|flags
operator|==
name|DTOR_FLAG
condition|)
name|t
operator|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|ctype
argument_list|)
operator|&&
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
operator|==
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|ctype
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* Don't include destructor with constructors.  */
name|t
operator|=
name|DECL_CHAIN
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL_TREE
condition|)
name|error
argument_list|(
literal|"class `%s' does not have any constructors"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|sname
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|build_nt
argument_list|(
name|SCOPE_REF
argument_list|,
name|ctype
argument_list|,
name|t
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
operator|=
name|init
expr_stmt|;
return|return
name|t
return|;
block|}
name|cp_error
argument_list|(
literal|"field `%D' is not a member of structure `%T'"
argument_list|,
name|sname
argument_list|,
name|ctype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|current_class_type
condition|)
block|{
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|ctype
argument_list|)
operator|!=
name|current_class_type
condition|)
block|{
name|cp_error
argument_list|(
literal|"cannot declare member `%T::%s' within `%T'"
argument_list|,
name|ctype
argument_list|,
name|name
argument_list|,
name|current_class_type
argument_list|)
expr_stmt|;
return|return
name|void_type_node
return|;
block|}
elseif|else
if|if
condition|(
name|extra_warnings
condition|)
name|cp_warning
argument_list|(
literal|"extra qualification `%T' on member `%s' ignored"
argument_list|,
name|ctype
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|type
operator|=
name|build_offset_type
argument_list|(
name|ctype
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|uses_template_parms
argument_list|(
name|ctype
argument_list|)
condition|)
block|{
name|enum
name|tree_code
name|c
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|type
operator|=
name|build_cplus_method_type
argument_list|(
name|build_type_variant
argument_list|(
name|ctype
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|=
name|FUNCTION_DECL
expr_stmt|;
block|}
block|}
else|else
block|{
name|cp_error
argument_list|(
literal|"structure `%T' not yet defined"
argument_list|,
name|ctype
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|declarator
operator|=
name|sname
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|sname
argument_list|)
operator|==
name|SCOPE_REF
condition|)
name|my_friendly_abort
argument_list|(
literal|17
argument_list|)
expr_stmt|;
else|else
block|{
name|done_scoping
label|:
name|declarator
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|declarator
operator|&&
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|CALL_EXPR
condition|)
comment|/* In this case, we will deal with it later.  */
empty_stmt|;
else|else
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|type
operator|=
name|build_cplus_method_type
argument_list|(
name|build_type_variant
argument_list|(
name|ctype
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|type
operator|=
name|build_offset_type
argument_list|(
name|ctype
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|BIT_NOT_EXPR
case|:
name|declarator
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
name|declarator
operator|=
name|NULL_TREE
expr_stmt|;
break|break;
case|case
name|ERROR_MARK
case|:
name|declarator
operator|=
name|NULL_TREE
expr_stmt|;
break|break;
default|default:
name|my_friendly_abort
argument_list|(
literal|158
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now TYPE has the actual type.  */
comment|/* If this is declaring a typedef name, return a TYPE_DECL.  */
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_TYPEDEF
argument_list|,
name|specbits
argument_list|)
condition|)
block|{
name|tree
name|decl
decl_stmt|;
comment|/* Note that the grammar rejects storage classes 	 in typenames, fields or parameters.  */
if|if
condition|(
name|constp
operator|||
name|volatilep
condition|)
name|type
operator|=
name|cp_build_type_variant
argument_list|(
name|type
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|)
expr_stmt|;
comment|/* If the user declares "struct {...} foo" then `foo' will have 	 an anonymous name.  Fill that name in now.  Nothing can 	 refer to it, so nothing needs know about the name change. 	 The TYPE_NAME field was filled in by build_struct_xref.  */
if|if
condition|(
name|type
operator|!=
name|error_mark_node
operator|&&
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|ANON_AGGRNAME_P
argument_list|(
name|TYPE_IDENTIFIER
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
comment|/* replace the anonymous name with the real name everywhere.  */
name|lookup_tag_reverse
argument_list|(
name|type
argument_list|,
name|declarator
argument_list|)
expr_stmt|;
name|TYPE_IDENTIFIER
argument_list|(
name|type
argument_list|)
operator|=
name|declarator
expr_stmt|;
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|type
argument_list|)
condition|)
name|TYPE_WAS_ANONYMOUS
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
block|{
name|tree
name|d
init|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
decl_stmt|,
name|c
init|=
name|DECL_CONTEXT
argument_list|(
name|d
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|c
condition|)
name|set_nested_typename
argument_list|(
name|d
argument_list|,
literal|0
argument_list|,
name|declarator
argument_list|,
name|type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|c
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|set_nested_typename
argument_list|(
name|d
argument_list|,
name|DECL_ASSEMBLER_NAME
argument_list|(
name|c
argument_list|)
argument_list|,
name|declarator
argument_list|,
name|type
argument_list|)
expr_stmt|;
else|else
name|set_nested_typename
argument_list|(
name|d
argument_list|,
name|TYPE_NESTED_NAME
argument_list|(
name|c
argument_list|)
argument_list|,
name|declarator
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
block|}
if|#
directive|if
literal|0
comment|/* not yet, should get fixed properly later */
block|decl = make_type_decl (declarator, type);
else|#
directive|else
name|decl
operator|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|declarator
argument_list|,
name|type
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|OFFSET_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"typedef name may not be class-qualified"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
elseif|else
if|if
condition|(
name|quals
condition|)
block|{
if|if
condition|(
name|ctype
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|METHOD_TYPE
condition|)
name|cp_error_at
argument_list|(
literal|"invalid type qualifier for non-method type"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|else
name|ctype
operator|=
name|TYPE_METHOD_BASETYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ctype
operator|!=
name|NULL_TREE
condition|)
name|grok_method_quals
argument_list|(
name|ctype
argument_list|,
name|decl
argument_list|,
name|quals
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_SIGNED
argument_list|,
name|specbits
argument_list|)
operator|||
operator|(
name|typedef_decl
operator|&&
name|C_TYPEDEF_EXPLICITLY_SIGNED
argument_list|(
name|typedef_decl
argument_list|)
operator|)
condition|)
name|C_TYPEDEF_EXPLICITLY_SIGNED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_MUTABLE
argument_list|,
name|specbits
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"non-object member `%s' cannot be declared mutable"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
return|return
name|decl
return|;
block|}
comment|/* Detect the case of an array type of unspecified size      which came, as such, direct from a typedef name.      We must copy the type, so that each identifier gets      a distinct type, so that each identifier's size can be      controlled separately by its own initializer.  */
if|if
condition|(
name|type
operator|==
name|typedef_type
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|type
operator|=
name|build_cplus_array_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If this is a type name (such as, in a cast or sizeof),      compute the type and return it now.  */
if|if
condition|(
name|decl_context
operator|==
name|TYPENAME
condition|)
block|{
comment|/* Note that the grammar rejects storage classes 	 in typenames, fields or parameters.  */
if|if
condition|(
name|constp
operator|||
name|volatilep
condition|)
if|if
condition|(
name|IS_SIGNATURE
argument_list|(
name|type
argument_list|)
condition|)
name|error
argument_list|(
literal|"`const' or `volatile' specified with signature type"
argument_list|)
expr_stmt|;
else|else
name|type
operator|=
name|cp_build_type_variant
argument_list|(
name|type
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|)
expr_stmt|;
comment|/* Special case: "friend class foo" looks like a TYPENAME context.  */
if|if
condition|(
name|friendp
condition|)
block|{
comment|/* A friendly class?  */
if|if
condition|(
name|current_class_type
condition|)
name|make_friend_class
argument_list|(
name|current_class_type
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"trying to make class `%s' a friend of global scope"
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|void_type_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|quals
condition|)
block|{
if|#
directive|if
literal|0
comment|/* not yet, should get fixed properly later */
block|tree dummy = make_type_decl (declarator, type);
else|#
directive|else
name|tree
name|dummy
init|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|declarator
argument_list|,
name|type
argument_list|)
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ctype
operator|==
name|NULL_TREE
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
argument_list|,
literal|159
argument_list|)
expr_stmt|;
name|ctype
operator|=
name|TYPE_METHOD_BASETYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
name|grok_method_quals
argument_list|(
name|ctype
argument_list|,
name|dummy
argument_list|,
name|quals
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|dummy
argument_list|)
expr_stmt|;
block|}
return|return
name|type
return|;
block|}
elseif|else
if|if
condition|(
name|declarator
operator|==
name|NULL_TREE
operator|&&
name|decl_context
operator|!=
name|PARM
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|UNION_TYPE
operator|&&
operator|!
name|bitfield
condition|)
block|{
name|cp_error
argument_list|(
literal|"abstract declarator `%T' used as declaration"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|declarator
operator|=
name|make_anon_name
argument_list|()
expr_stmt|;
block|}
comment|/* `void' at top level (not within pointer)      is allowed only in typedefs or type names.      We don't complain about parms either, but that is because      a better error message can be made later.  */
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|void_type_node
operator|&&
name|decl_context
operator|!=
name|PARM
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
if|if
condition|(
name|IDENTIFIER_OPNAME_P
argument_list|(
name|declarator
argument_list|)
condition|)
if|#
directive|if
literal|0
comment|/* How could this happen? */
then|error ("operator `%s' declared void", 		   operator_name_string (declarator));
else|#
directive|else
name|my_friendly_abort
argument_list|(
literal|356
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|else
name|error
argument_list|(
literal|"variable or field `%s' declared void"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"variable or field declared void"
argument_list|)
expr_stmt|;
name|type
operator|=
name|integer_type_node
expr_stmt|;
block|}
comment|/* Now create the decl, which may be a VAR_DECL, a PARM_DECL      or a FUNCTION_DECL, depending on DECL_CONTEXT and TYPE.  */
block|{
specifier|register
name|tree
name|decl
decl_stmt|;
if|if
condition|(
name|decl_context
operator|==
name|PARM
condition|)
block|{
if|if
condition|(
name|ctype
condition|)
name|error
argument_list|(
literal|"cannot use `::' in parameter declaration"
argument_list|)
expr_stmt|;
comment|/* A parameter declared as an array of T is really a pointer to T. 	   One declared as a function is really a pointer to a function. 	   One declared as a member is really a pointer to member.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
comment|/* Transfer const-ness of array into that of type pointed to. */
name|type
operator|=
name|build_pointer_type
argument_list|(
name|cp_build_type_variant
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|)
argument_list|)
expr_stmt|;
name|volatilep
operator|=
name|constp
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
name|type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|PARM_DECL
argument_list|,
name|declarator
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|bad_specifiers
argument_list|(
name|decl
argument_list|,
literal|"parameter"
argument_list|,
name|virtualp
argument_list|,
name|quals
operator|!=
name|NULL_TREE
argument_list|,
name|inlinep
argument_list|,
name|friendp
argument_list|,
name|raises
operator|!=
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_class_type
operator|&&
name|IS_SIGNATURE
argument_list|(
name|current_class_type
argument_list|)
condition|)
block|{
if|if
condition|(
name|inlinep
condition|)
name|error
argument_list|(
literal|"parameter of signature member function declared `inline'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_AUTO
argument_list|,
name|specbits
argument_list|)
condition|)
name|error
argument_list|(
literal|"parameter of signature member function declared `auto'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_REGISTER
argument_list|,
name|specbits
argument_list|)
condition|)
name|error
argument_list|(
literal|"parameter of signature member function declared `register'"
argument_list|)
expr_stmt|;
block|}
comment|/* Compute the type actually passed in the parmlist, 	   for the case where there is no prototype. 	   (For example, shorts and chars are passed as ints.) 	   When there is a prototype, this is overridden later.  */
name|DECL_ARG_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|type_promotes_to
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|decl_context
operator|==
name|FIELD
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
block|{
comment|/* Happens when declaring arrays of sizes which 	       are error_mark_node, for example.  */
name|decl
operator|=
name|NULL_TREE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|int
name|publicp
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|friendp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ctype
operator|==
name|NULL_TREE
condition|)
name|ctype
operator|=
name|current_class_type
expr_stmt|;
if|if
condition|(
name|ctype
operator|==
name|NULL_TREE
condition|)
block|{
name|cp_error
argument_list|(
literal|"can't make `%D' into a method -- not in a class"
argument_list|,
name|declarator
argument_list|)
expr_stmt|;
return|return
name|void_type_node
return|;
block|}
comment|/* ``A union may [ ... ] not [ have ] virtual functions.'' 		   ARM 9.5 */
if|if
condition|(
name|virtualp
operator|&&
name|TREE_CODE
argument_list|(
name|ctype
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
name|cp_error
argument_list|(
literal|"function `%D' declared virtual inside a union"
argument_list|,
name|declarator
argument_list|)
expr_stmt|;
return|return
name|void_type_node
return|;
block|}
if|if
condition|(
name|declarator
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|NEW_EXPR
index|]
operator|||
name|declarator
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|VEC_NEW_EXPR
index|]
operator|||
name|declarator
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|DELETE_EXPR
index|]
operator|||
name|declarator
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|VEC_DELETE_EXPR
index|]
condition|)
block|{
if|if
condition|(
name|virtualp
condition|)
block|{
name|cp_error
argument_list|(
literal|"`%D' cannot be declared virtual, since it is always static"
argument_list|,
name|declarator
argument_list|)
expr_stmt|;
name|virtualp
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|staticp
operator|<
literal|2
condition|)
name|type
operator|=
name|build_cplus_method_type
argument_list|(
name|build_type_variant
argument_list|(
name|ctype
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Tell grokfndecl if it needs to set TREE_PUBLIC on the node.  */
name|publicp
operator|=
operator|(
name|RIDBIT_SETP
argument_list|(
name|RID_EXTERN
argument_list|,
name|specbits
argument_list|)
operator|||
operator|(
name|ctype
operator|!=
name|NULL_TREE
operator|&&
name|funcdef_flag
operator|>=
literal|0
operator|&&
name|RIDBIT_NOTSETP
argument_list|(
name|RID_INLINE
argument_list|,
name|specbits
argument_list|)
operator|)
operator|||
operator|(
name|friendp
operator|&&
operator|!
name|funcdef_flag
operator|&&
name|RIDBIT_NOTSETP
argument_list|(
name|RID_STATIC
argument_list|,
name|specbits
argument_list|)
operator|&&
name|RIDBIT_NOTSETP
argument_list|(
name|RID_INLINE
argument_list|,
name|specbits
argument_list|)
operator|)
operator|)
expr_stmt|;
name|decl
operator|=
name|grokfndecl
argument_list|(
name|ctype
argument_list|,
name|type
argument_list|,
name|declarator
argument_list|,
name|virtualp
argument_list|,
name|flags
argument_list|,
name|quals
argument_list|,
name|raises
argument_list|,
name|friendp
condition|?
operator|-
literal|1
else|:
literal|0
argument_list|,
name|publicp
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|==
name|NULL_TREE
condition|)
return|return
name|NULL_TREE
return|;
name|DECL_INLINE
argument_list|(
name|decl
argument_list|)
operator|=
name|inlinep
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
comment|/* All method decls are public, so tell grokfndecl to set 	       TREE_PUBLIC, also.  */
name|decl
operator|=
name|grokfndecl
argument_list|(
name|ctype
argument_list|,
name|type
argument_list|,
name|declarator
argument_list|,
name|virtualp
argument_list|,
name|flags
argument_list|,
name|quals
argument_list|,
name|raises
argument_list|,
name|friendp
condition|?
operator|-
literal|1
else|:
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|==
name|NULL_TREE
condition|)
return|return
name|NULL_TREE
return|;
name|DECL_INLINE
argument_list|(
name|decl
argument_list|)
operator|=
name|inlinep
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|CLASSTYPE_DECLARED_EXCEPTION
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* Handle a class-local exception declaration.  */
name|decl
operator|=
name|build_lang_field_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|declarator
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctype
operator|==
name|NULL_TREE
condition|)
name|ctype
operator|=
name|current_class_type
expr_stmt|;
return|return
name|void_type_node
return|;
block|}
elseif|else
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|==
name|NULL_TREE
operator|&&
operator|!
name|staticp
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|ARRAY_TYPE
operator|||
name|initialized
operator|==
literal|0
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"field `%s' has incomplete type"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|declarator
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we're instantiating a template, tell them which 	       instantiation made the field's type be incomplete.  */
if|if
condition|(
name|current_class_type
operator|&&
name|TYPE_NAME
argument_list|(
name|current_class_type
argument_list|)
operator|&&
name|IDENTIFIER_TEMPLATE
argument_list|(
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|current_class_type
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|declspecs
operator|&&
name|TREE_VALUE
argument_list|(
name|declspecs
argument_list|)
operator|&&
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|declspecs
argument_list|)
argument_list|)
operator|==
name|type
condition|)
name|error
argument_list|(
literal|"  in instantiation of template `%s'"
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|current_class_type
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|error_mark_node
expr_stmt|;
name|decl
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|friendp
condition|)
block|{
name|error
argument_list|(
literal|"`%s' is neither function nor method; cannot be declared friend"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|declarator
argument_list|)
argument_list|)
expr_stmt|;
name|friendp
operator|=
literal|0
expr_stmt|;
block|}
name|decl
operator|=
name|NULL_TREE
expr_stmt|;
block|}
if|if
condition|(
name|friendp
condition|)
block|{
comment|/* Friends are treated specially.  */
if|if
condition|(
name|ctype
operator|==
name|current_class_type
condition|)
name|warning
argument_list|(
literal|"member functions are implicitly friends of their class"
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|t
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|decl
operator|&&
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
condition|)
name|t
operator|=
name|do_friend
argument_list|(
name|ctype
argument_list|,
name|declarator
argument_list|,
name|decl
argument_list|,
name|last_function_parms
argument_list|,
name|flags
argument_list|,
name|quals
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|&&
name|funcdef_flag
condition|)
return|return
name|t
return|;
return|return
name|void_type_node
return|;
block|}
block|}
comment|/* Structure field.  It may not be a function, except for C++ */
if|if
condition|(
name|decl
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|initialized
condition|)
block|{
comment|/* Motion 10 at San Diego: If a static const integral data 		   member is initialized with an integral constant 		   expression, the initializer may appear either in the 		   declaration (within the class), or in the definition, 		   but not both.  If it appears in the class, the member is 		   a member constant.  The file-scope definition is always 		   required.  */
if|if
condition|(
name|staticp
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
block|{
if|if
condition|(
operator|!
name|constp
condition|)
name|cp_pedwarn
argument_list|(
literal|"ANSI C++ forbids in-class initialization of non-const static member `%D'"
argument_list|,
name|declarator
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
name|cp_pedwarn
argument_list|(
literal|"ANSI C++ forbids member constant `%D' of non-integral type `%T'"
argument_list|,
name|declarator
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Note that initialization of const members is prohibited 		   by the draft ANSI standard, though it appears to be in 		   common practice.  12.6.2: The argument list is used to 		   initialize the named nonstatic member....  This (or an 		   initializer list) is the only way to initialize 		   nonstatic const and reference members.  */
elseif|else
if|if
condition|(
name|flag_ansi
operator|||
operator|!
name|constp
condition|)
name|cp_pedwarn
argument_list|(
literal|"ANSI C++ forbids initialization of %s `%D'"
argument_list|,
name|constp
condition|?
literal|"const member"
else|:
literal|"member"
argument_list|,
name|declarator
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|staticp
operator|||
operator|(
name|constp
operator|&&
name|initialized
operator|)
condition|)
block|{
comment|/* C++ allows static class members. 		   All other work for this is done by grokfield. 		   This VAR_DECL is built by build_lang_field_decl. 		   All other VAR_DECLs are built by build_decl.  */
name|decl
operator|=
name|build_lang_field_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|declarator
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* In class context, 'static' means public access.  */
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
operator|!
operator|!
name|staticp
expr_stmt|;
block|}
else|else
block|{
name|decl
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|declarator
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_MUTABLE
argument_list|,
name|specbits
argument_list|)
condition|)
block|{
name|DECL_MUTABLE_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|RIDBIT_RESET
argument_list|(
name|RID_MUTABLE
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
block|}
block|}
name|bad_specifiers
argument_list|(
name|decl
argument_list|,
literal|"field"
argument_list|,
name|virtualp
argument_list|,
name|quals
operator|!=
name|NULL_TREE
argument_list|,
name|inlinep
argument_list|,
name|friendp
argument_list|,
name|raises
operator|!=
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|tree
name|original_name
init|=
name|declarator
decl_stmt|;
name|int
name|publicp
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|declarator
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_AUTO
argument_list|,
name|specbits
argument_list|)
condition|)
name|error
argument_list|(
literal|"storage class `auto' invalid for function `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_REGISTER
argument_list|,
name|specbits
argument_list|)
condition|)
name|error
argument_list|(
literal|"storage class `register' invalid for function `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Function declaration not at top level. 	   Storage classes other than `extern' are not allowed 	   and `extern' makes no difference.  */
if|if
condition|(
name|current_binding_level
operator|!=
name|global_binding_level
operator|&&
operator|!
name|processing_template_decl
operator|&&
operator|(
name|RIDBIT_SETP
argument_list|(
name|RID_STATIC
argument_list|,
name|specbits
argument_list|)
operator|||
name|RIDBIT_SETP
argument_list|(
name|RID_INLINE
argument_list|,
name|specbits
argument_list|)
operator|)
operator|&&
name|pedantic
condition|)
block|{
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_STATIC
argument_list|,
name|specbits
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"storage class `static' invalid for function `%s' declared out of global scope"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|pedwarn
argument_list|(
literal|"storage class `inline' invalid for function `%s' declared out of global scope"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ctype
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|virtualp
condition|)
block|{
name|error
argument_list|(
literal|"virtual non-class function `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|virtualp
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|current_lang_name
operator|==
name|lang_name_cplusplus
operator|&&
operator|!
operator|(
name|IDENTIFIER_LENGTH
argument_list|(
name|original_name
argument_list|)
operator|==
literal|4
operator|&&
name|IDENTIFIER_POINTER
argument_list|(
name|original_name
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'m'
operator|&&
name|strcmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|original_name
argument_list|)
argument_list|,
literal|"main"
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|!
operator|(
name|IDENTIFIER_LENGTH
argument_list|(
name|original_name
argument_list|)
operator|>
literal|10
operator|&&
name|IDENTIFIER_POINTER
argument_list|(
name|original_name
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|IDENTIFIER_POINTER
argument_list|(
name|original_name
argument_list|)
index|[
literal|1
index|]
operator|==
literal|'_'
operator|&&
name|strncmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|original_name
argument_list|)
operator|+
literal|2
argument_list|,
literal|"builtin_"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
operator|)
condition|)
comment|/* Plain overloading: will not be grok'd by grokclassfn.  */
name|declarator
operator|=
name|build_decl_overload
argument_list|(
name|dname
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|&&
name|staticp
operator|<
literal|2
condition|)
name|type
operator|=
name|build_cplus_method_type
argument_list|(
name|build_type_variant
argument_list|(
name|ctype
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Record presence of `static'.  In C++, `inline' is like `static'.  */
name|publicp
operator|=
operator|!
operator|(
name|RIDBIT_SETP
argument_list|(
name|RID_STATIC
argument_list|,
name|specbits
argument_list|)
operator|||
name|RIDBIT_SETP
argument_list|(
name|RID_INLINE
argument_list|,
name|specbits
argument_list|)
operator|)
expr_stmt|;
name|decl
operator|=
name|grokfndecl
argument_list|(
name|ctype
argument_list|,
name|type
argument_list|,
name|original_name
argument_list|,
name|virtualp
argument_list|,
name|flags
argument_list|,
name|quals
argument_list|,
name|raises
argument_list|,
name|processing_template_decl
condition|?
literal|0
else|:
name|friendp
condition|?
literal|2
else|:
literal|1
argument_list|,
name|publicp
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|==
name|NULL_TREE
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|ctype
operator|==
name|NULL_TREE
operator|&&
name|DECL_LANGUAGE
argument_list|(
name|decl
argument_list|)
operator|!=
name|lang_c
condition|)
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
operator|=
name|declarator
expr_stmt|;
if|if
condition|(
name|staticp
operator|==
literal|1
condition|)
block|{
name|int
name|illegal_static
init|=
literal|0
decl_stmt|;
comment|/* Don't allow a static member function in a class, and forbid 	       declaring main to be static.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|cp_pedwarn
argument_list|(
literal|"cannot declare member function `%D' to have static linkage"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|illegal_static
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|ctype
operator|&&
name|IDENTIFIER_LENGTH
argument_list|(
name|original_name
argument_list|)
operator|==
literal|4
operator|&&
name|IDENTIFIER_POINTER
argument_list|(
name|original_name
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'m'
operator|&&
operator|!
name|strcmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|original_name
argument_list|)
argument_list|,
literal|"main"
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"cannot declare function `main' to have static linkage"
argument_list|)
expr_stmt|;
name|illegal_static
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|current_function_decl
condition|)
block|{
comment|/* FIXME need arm citation */
name|error
argument_list|(
literal|"cannot declare static function inside another function"
argument_list|)
expr_stmt|;
name|illegal_static
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|illegal_static
condition|)
block|{
name|staticp
operator|=
literal|0
expr_stmt|;
name|RIDBIT_RESET
argument_list|(
name|RID_STATIC
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Record presence of `inline', if it is reasonable.  */
if|if
condition|(
name|inlinep
condition|)
block|{
name|tree
name|last
init|=
name|tree_last
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ctype
operator|&&
operator|!
name|strcmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|original_name
argument_list|)
argument_list|,
literal|"main"
argument_list|)
condition|)
name|error
argument_list|(
literal|"cannot inline function `main'"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|last
operator|&&
name|last
operator|!=
name|void_list_node
condition|)
name|cp_warning
argument_list|(
literal|"cannot inline function `%D' which takes `...'"
argument_list|,
name|original_name
argument_list|)
expr_stmt|;
else|else
comment|/* Assume that otherwise the function can be inlined.  */
name|DECL_INLINE
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_EXTERN
argument_list|,
name|specbits
argument_list|)
condition|)
block|{
name|current_extern_inline
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|flag_ansi
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C++ does not permit `extern inline'"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* It's a variable.  */
comment|/* An uninitialized decl with `extern' is a reference.  */
name|decl
operator|=
name|grokvardecl
argument_list|(
name|type
argument_list|,
name|declarator
argument_list|,
name|specbits
argument_list|,
name|initialized
argument_list|)
expr_stmt|;
name|bad_specifiers
argument_list|(
name|decl
argument_list|,
literal|"variable"
argument_list|,
name|virtualp
argument_list|,
name|quals
operator|!=
name|NULL_TREE
argument_list|,
name|inlinep
argument_list|,
name|friendp
argument_list|,
name|raises
operator|!=
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctype
condition|)
block|{
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|ctype
expr_stmt|;
if|if
condition|(
name|staticp
operator|==
literal|1
condition|)
block|{
name|cp_error
argument_list|(
literal|"static member `%D' re-declared as static"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|staticp
operator|=
literal|0
expr_stmt|;
name|RIDBIT_RESET
argument_list|(
name|RID_STATIC
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_EXTERN
argument_list|,
name|specbits
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"cannot explicitly declare member `%#D' to have extern linkage"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|RIDBIT_RESET
argument_list|(
name|RID_EXTERN
argument_list|,
name|specbits
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_MUTABLE
argument_list|,
name|specbits
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"`%s' cannot be declared mutable"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* Record `register' declaration for warnings on&        and in case doing stupid register allocation.  */
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_REGISTER
argument_list|,
name|specbits
argument_list|)
condition|)
name|DECL_REGISTER
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|RIDBIT_SETP
argument_list|(
name|RID_EXTERN
argument_list|,
name|specbits
argument_list|)
condition|)
name|DECL_THIS_EXTERN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Record constancy and volatility.  */
if|if
condition|(
name|constp
condition|)
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|REFERENCE_TYPE
expr_stmt|;
if|if
condition|(
name|volatilep
condition|)
block|{
name|TREE_SIDE_EFFECTS
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|decl
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Tell if a parmlist/exprlist looks like an exprlist or a parmlist.    An empty exprlist is a parmlist.  An exprlist which    contains only identifiers at the global level    is a parmlist.  Otherwise, it is an exprlist.  */
end_comment

begin_function
name|int
name|parmlist_is_exprlist
parameter_list|(
name|exprs
parameter_list|)
name|tree
name|exprs
decl_stmt|;
block|{
if|if
condition|(
name|exprs
operator|==
name|NULL_TREE
operator|||
name|TREE_PARMLIST
argument_list|(
name|exprs
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
condition|)
block|{
comment|/* At the global level, if these are all identifiers, 	 then it is a parmlist.  */
while|while
condition|(
name|exprs
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|exprs
argument_list|)
argument_list|)
operator|!=
name|IDENTIFIER_NODE
condition|)
return|return
literal|1
return|;
name|exprs
operator|=
name|TREE_CHAIN
argument_list|(
name|exprs
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of `grokparms'.  In a fcn definition, arg types must    be complete.     C++: also subroutine of `start_function'.  */
end_comment

begin_function
specifier|static
name|void
name|require_complete_types_for_parms
parameter_list|(
name|parms
parameter_list|)
name|tree
name|parms
decl_stmt|;
block|{
while|while
condition|(
name|parms
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|parms
argument_list|)
condition|)
name|error
argument_list|(
literal|"parameter `%s' has incomplete type"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|parms
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"parameter has incomplete type"
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* If the arg types are incomplete in a declaration, 	 they must include undefined tags. 	 These tags can never be defined in the scope of the declaration, 	 so the types can never be completed, 	 and no call can be compiled successfully.  */
comment|/* This is not the right behavior for C++, but not having 	 it is also probably wrong.  */
block|else 	{
comment|/* Now warn if is a pointer to an incomplete type.  */
block|while (TREE_CODE (type) == POINTER_TYPE 		 || TREE_CODE (type) == REFERENCE_TYPE) 	    type = TREE_TYPE (type); 	  type = TYPE_MAIN_VARIANT (type); 	  if (TYPE_SIZE (type) == NULL_TREE) 	    { 	      if (DECL_NAME (parm) != NULL_TREE) 		warning ("parameter `%s' points to incomplete type", 			 IDENTIFIER_POINTER (DECL_NAME (parm))); 	      else 		warning ("parameter points to incomplete type"); 	    } 	}
endif|#
directive|endif
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Decode the list of parameter types for a function type.    Given the list of things declared inside the parens,    return a list of types.     The list we receive can have three kinds of elements:    an IDENTIFIER_NODE for names given without types,    a TREE_LIST node for arguments given as typespecs or names with typespecs,    or void_type_node, to mark the end of an argument list    when additional arguments are not permitted (... was not used).     FUNCDEF_FLAG is nonzero for a function definition, 0 for    a mere declaration.  A nonempty identifier-list gets an error message    when FUNCDEF_FLAG is zero.    If FUNCDEF_FLAG is 1, then parameter types must be complete.    If FUNCDEF_FLAG is -1, then parameter types may be incomplete.     If all elements of the input list contain types,    we return a list of the types.    If all elements contain no type (except perhaps a void_type_node    at the end), we return a null list.    If some have types and some do not, it is an error, and we    return a null list.     Also set last_function_parms to either    a list of names (IDENTIFIER_NODEs) or a chain of PARM_DECLs.    A list of names is converted to a chain of PARM_DECLs    by store_parm_decls so that ultimately it is always a chain of decls.     Note that in C++, parameters can take default values.  These default    values are in the TREE_PURPOSE field of the TREE_LIST.  It is    an error to specify default values which are followed by parameters    that have no default values, or an ELLIPSES.  For simplicities sake,    only parameters which are specified with their types can take on    default values.  */
end_comment

begin_function
specifier|static
name|tree
name|grokparms
parameter_list|(
name|first_parm
parameter_list|,
name|funcdef_flag
parameter_list|)
name|tree
name|first_parm
decl_stmt|;
name|int
name|funcdef_flag
decl_stmt|;
block|{
name|tree
name|result
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|decls
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|first_parm
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|first_parm
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
if|if
condition|(
operator|!
name|funcdef_flag
condition|)
name|pedwarn
argument_list|(
literal|"parameter names (without types) in function declaration"
argument_list|)
expr_stmt|;
name|last_function_parms
operator|=
name|first_parm
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
elseif|else
if|if
condition|(
name|first_parm
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|first_parm
argument_list|)
argument_list|)
operator|!=
name|TREE_LIST
operator|&&
name|TREE_VALUE
argument_list|(
name|first_parm
argument_list|)
operator|!=
name|void_type_node
condition|)
name|my_friendly_abort
argument_list|(
literal|145
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Types were specified.  This is a list of declarators 	 each represented as a TREE_LIST node.  */
specifier|register
name|tree
name|parm
decl_stmt|,
name|chain
decl_stmt|;
name|int
name|any_init
init|=
literal|0
decl_stmt|,
name|any_error
init|=
literal|0
decl_stmt|,
name|saw_void
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|first_parm
operator|!=
name|NULL_TREE
condition|)
block|{
name|tree
name|last_result
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|last_decl
init|=
name|NULL_TREE
decl_stmt|;
for|for
control|(
name|parm
operator|=
name|first_parm
init|;
name|parm
operator|!=
name|NULL_TREE
condition|;
name|parm
operator|=
name|chain
control|)
block|{
name|tree
name|type
decl_stmt|,
name|list_node
init|=
name|parm
decl_stmt|;
specifier|register
name|tree
name|decl
init|=
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
decl_stmt|;
name|tree
name|init
init|=
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
decl_stmt|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
expr_stmt|;
comment|/* @@ weak defense against parse errors.  */
if|if
condition|(
name|decl
operator|!=
name|void_type_node
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|TREE_LIST
condition|)
block|{
comment|/* Give various messages as the need arises.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|STRING_CST
condition|)
name|error
argument_list|(
literal|"invalid string constant `%s'"
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|error
argument_list|(
literal|"invalid integer constant in parameter list, did you forget to give parameter name?"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|decl
operator|!=
name|void_type_node
condition|)
block|{
comment|/* @@ May need to fetch out a `raises' here.  */
name|decl
operator|=
name|grokdeclarator
argument_list|(
name|TREE_VALUE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|PARM
argument_list|,
name|init
operator|!=
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|decl
condition|)
continue|continue;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|void_type_node
condition|)
name|decl
operator|=
name|void_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
condition|)
comment|/* Cannot use `error_with_decl' here because 			   we don't have DECL_CONTEXT set up yet.  */
name|error
argument_list|(
literal|"parameter `%s' invalidly declared method type"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"parameter invalidly declared method type"
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|type
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
condition|)
name|error
argument_list|(
literal|"parameter `%s' invalidly declared offset type"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"parameter invalidly declared offset type"
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|type
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|TYPE_LANG_SPECIFIC
argument_list|(
name|type
argument_list|)
operator|&&
name|CLASSTYPE_ABSTRACT_VIRTUALS
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|abstract_virtuals_error
argument_list|(
name|decl
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|any_error
operator|=
literal|1
expr_stmt|;
comment|/* seems like a good idea */
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|TYPE_LANG_SPECIFIC
argument_list|(
name|type
argument_list|)
operator|&&
name|IS_SIGNATURE
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|signature_error
argument_list|(
name|decl
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|any_error
operator|=
literal|1
expr_stmt|;
comment|/* seems like a good idea */
block|}
block|}
if|if
condition|(
name|decl
operator|==
name|void_type_node
condition|)
block|{
if|if
condition|(
name|result
operator|==
name|NULL_TREE
condition|)
block|{
name|result
operator|=
name|void_list_node
expr_stmt|;
name|last_result
operator|=
name|result
expr_stmt|;
block|}
else|else
block|{
name|TREE_CHAIN
argument_list|(
name|last_result
argument_list|)
operator|=
name|void_list_node
expr_stmt|;
name|last_result
operator|=
name|void_list_node
expr_stmt|;
block|}
name|saw_void
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|chain
operator|&&
operator|(
name|chain
operator|!=
name|void_list_node
operator|||
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
operator|)
condition|)
name|error
argument_list|(
literal|"`void' in parameter list must be entire list"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Since there is a prototype, args are passed in their own types.  */
name|DECL_ARG_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PROMOTE_PROTOTYPES
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|)
operator|&&
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
condition|)
name|DECL_ARG_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|any_error
condition|)
block|{
if|if
condition|(
name|init
condition|)
block|{
name|any_init
operator|++
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|SAVE_EXPR
condition|)
name|PARM_DECL_EXPR
argument_list|(
name|init
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
if|if
condition|(
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|init
argument_list|)
argument_list|)
condition|)
block|{
comment|/* ``Local variables may not be used in default 				 argument expressions.'' dpANSI C++ 8.2.6 */
comment|/* If extern int i; within a function is not 				 considered a local variable, then this code is 				 wrong. */
name|cp_error
argument_list|(
literal|"local variable `%D' may not be used as a default argument"
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|any_error
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_READONLY_DECL_P
argument_list|(
name|init
argument_list|)
condition|)
name|init
operator|=
name|decl_constant_value
argument_list|(
name|init
argument_list|)
expr_stmt|;
block|}
else|else
name|init
operator|=
name|require_instantiated_type
argument_list|(
name|type
argument_list|,
name|init
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|any_init
condition|)
block|{
name|error
argument_list|(
literal|"all trailing parameters must have default arguments"
argument_list|)
expr_stmt|;
name|any_error
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
name|init
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|decls
operator|==
name|NULL_TREE
condition|)
block|{
name|decls
operator|=
name|decl
expr_stmt|;
name|last_decl
operator|=
name|decls
expr_stmt|;
block|}
else|else
block|{
name|TREE_CHAIN
argument_list|(
name|last_decl
argument_list|)
operator|=
name|decl
expr_stmt|;
name|last_decl
operator|=
name|decl
expr_stmt|;
block|}
if|if
condition|(
name|TREE_PERMANENT
argument_list|(
name|list_node
argument_list|)
condition|)
block|{
name|TREE_PURPOSE
argument_list|(
name|list_node
argument_list|)
operator|=
name|init
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|list_node
argument_list|)
operator|=
name|type
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|list_node
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
name|list_node
operator|=
name|saveable_tree_cons
argument_list|(
name|init
argument_list|,
name|type
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL_TREE
condition|)
block|{
name|result
operator|=
name|list_node
expr_stmt|;
name|last_result
operator|=
name|result
expr_stmt|;
block|}
else|else
block|{
name|TREE_CHAIN
argument_list|(
name|last_result
argument_list|)
operator|=
name|list_node
expr_stmt|;
name|last_result
operator|=
name|list_node
expr_stmt|;
block|}
block|}
if|if
condition|(
name|last_result
condition|)
name|TREE_CHAIN
argument_list|(
name|last_result
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* If there are no parameters, and the function does not end 	     with `...', then last_decl will be NULL_TREE.  */
if|if
condition|(
name|last_decl
operator|!=
name|NULL_TREE
condition|)
name|TREE_CHAIN
argument_list|(
name|last_decl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
name|last_function_parms
operator|=
name|decls
expr_stmt|;
comment|/* In a fcn definition, arg types must be complete.  */
if|if
condition|(
name|funcdef_flag
operator|>
literal|0
condition|)
name|require_complete_types_for_parms
argument_list|(
name|last_function_parms
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* These memoizing functions keep track of special properties which    a class may have.  `grok_ctor_properties' notices whether a class    has a constructor of the form X(X&), and also complains    if the class has a constructor of the form X(X).    `grok_op_properties' takes notice of the various forms of    operator= which are defined, as well as what sorts of type conversion    may apply.  Both functions take a FUNCTION_DECL as an argument.  */
end_comment

begin_function
name|int
name|grok_ctor_properties
parameter_list|(
name|ctype
parameter_list|,
name|decl
parameter_list|)
name|tree
name|ctype
decl_stmt|,
name|decl
decl_stmt|;
block|{
name|tree
name|parmtypes
init|=
name|FUNCTION_ARG_CHAIN
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|tree
name|parmtype
init|=
name|parmtypes
condition|?
name|TREE_VALUE
argument_list|(
name|parmtypes
argument_list|)
else|:
name|void_type_node
decl_stmt|;
comment|/* When a type has virtual baseclasses, a magical first int argument is      added to any ctor so we can tell if the class has been initialized      yet.  This could screw things up in this function, so we deliberately      ignore the leading int if we're in that situation.  */
if|if
condition|(
name|parmtypes
operator|&&
name|TREE_VALUE
argument_list|(
name|parmtypes
argument_list|)
operator|==
name|integer_type_node
operator|&&
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|ctype
argument_list|)
condition|)
block|{
name|parmtypes
operator|=
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
expr_stmt|;
name|parmtype
operator|=
name|TREE_VALUE
argument_list|(
name|parmtypes
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parmtype
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|parmtype
argument_list|)
argument_list|)
operator|==
name|ctype
condition|)
block|{
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
operator|==
name|NULL_TREE
operator|||
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
operator|==
name|void_list_node
operator|||
name|TREE_PURPOSE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
argument_list|)
condition|)
block|{
name|TYPE_HAS_INIT_REF
argument_list|(
name|ctype
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TYPE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|parmtype
argument_list|)
argument_list|)
condition|)
name|TYPE_HAS_CONST_INIT_REF
argument_list|(
name|ctype
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|TYPE_GETS_INIT_AGGR
argument_list|(
name|ctype
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|parmtype
argument_list|)
operator|==
name|ctype
condition|)
block|{
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
operator|==
name|void_list_node
condition|)
block|{
name|cp_error
argument_list|(
literal|"invalid constructor; you probably meant `%T (%T&)'"
argument_list|,
name|ctype
argument_list|,
name|ctype
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_ERROR_LOCUS
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
name|ctype
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
name|TYPE_GETS_INIT_AGGR
argument_list|(
name|ctype
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parmtype
argument_list|)
operator|==
name|VOID_TYPE
operator|||
name|TREE_PURPOSE
argument_list|(
name|parmtypes
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|TYPE_HAS_DEFAULT_CONSTRUCTOR
argument_list|(
name|ctype
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* An operator with this name can be either unary or binary.  */
end_comment

begin_function
specifier|static
name|int
name|ambi_op_p
parameter_list|(
name|name
parameter_list|)
name|tree
name|name
decl_stmt|;
block|{
return|return
operator|(
name|name
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|INDIRECT_REF
index|]
operator|||
name|name
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|ADDR_EXPR
index|]
operator|||
name|name
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|NEGATE_EXPR
index|]
operator|||
name|name
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|POSTINCREMENT_EXPR
index|]
operator|||
name|name
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|POSTDECREMENT_EXPR
index|]
operator|||
name|name
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|CONVERT_EXPR
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/* An operator with this name can only be unary.  */
end_comment

begin_function
specifier|static
name|int
name|unary_op_p
parameter_list|(
name|name
parameter_list|)
name|tree
name|name
decl_stmt|;
block|{
return|return
operator|(
name|name
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|TRUTH_NOT_EXPR
index|]
operator|||
name|name
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|BIT_NOT_EXPR
index|]
operator|||
name|name
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|COMPONENT_REF
index|]
operator|||
name|OPERATOR_TYPENAME_P
argument_list|(
name|name
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Do a little sanity-checking on how they declared their operator.  */
end_comment

begin_function
specifier|static
name|void
name|grok_op_properties
parameter_list|(
name|decl
parameter_list|,
name|virtualp
parameter_list|,
name|friendp
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|int
name|virtualp
decl_stmt|,
name|friendp
decl_stmt|;
block|{
name|tree
name|argtypes
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|methodp
init|=
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
operator|)
decl_stmt|;
name|tree
name|name
init|=
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|current_class_type
operator|==
name|NULL_TREE
condition|)
name|friendp
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|friendp
condition|)
block|{
if|if
condition|(
name|name
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|MODIFY_EXPR
index|]
condition|)
name|TYPE_HAS_ASSIGNMENT
argument_list|(
name|current_class_type
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|name
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|CALL_EXPR
index|]
condition|)
name|TYPE_OVERLOADS_CALL_EXPR
argument_list|(
name|current_class_type
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|name
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|ARRAY_REF
index|]
condition|)
name|TYPE_OVERLOADS_ARRAY_REF
argument_list|(
name|current_class_type
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|name
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|COMPONENT_REF
index|]
operator|||
name|name
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|MEMBER_REF
index|]
condition|)
name|TYPE_OVERLOADS_ARROW
argument_list|(
name|current_class_type
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|name
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|NEW_EXPR
index|]
condition|)
name|TYPE_GETS_NEW
argument_list|(
name|current_class_type
argument_list|)
operator||=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|name
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|DELETE_EXPR
index|]
condition|)
name|TYPE_GETS_DELETE
argument_list|(
name|current_class_type
argument_list|)
operator||=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|name
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|VEC_NEW_EXPR
index|]
condition|)
name|TYPE_GETS_NEW
argument_list|(
name|current_class_type
argument_list|)
operator||=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|name
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|VEC_DELETE_EXPR
index|]
condition|)
name|TYPE_GETS_DELETE
argument_list|(
name|current_class_type
argument_list|)
operator||=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|name
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|NEW_EXPR
index|]
operator|||
name|name
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|VEC_NEW_EXPR
index|]
condition|)
block|{
comment|/* When the compiler encounters the definition of A::operator new, it 	 doesn't look at the class declaration to find out if it's static.  */
if|if
condition|(
name|methodp
condition|)
name|revert_static_member_fn
argument_list|(
operator|&
name|decl
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Take care of function decl if we had syntax errors.  */
if|if
condition|(
name|argtypes
operator|==
name|NULL_TREE
condition|)
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|hash_tree_chain
argument_list|(
name|integer_type_node
argument_list|,
name|void_list_node
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|coerce_new_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|DELETE_EXPR
index|]
operator|||
name|name
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|VEC_DELETE_EXPR
index|]
condition|)
block|{
if|if
condition|(
name|methodp
condition|)
name|revert_static_member_fn
argument_list|(
operator|&
name|decl
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|argtypes
operator|==
name|NULL_TREE
condition|)
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|hash_tree_chain
argument_list|(
name|ptr_type_node
argument_list|,
name|void_list_node
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|coerce_delete_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|friendp
operator|&&
name|name
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|VEC_DELETE_EXPR
index|]
operator|&&
operator|(
name|TREE_CHAIN
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|void_list_node
operator|)
condition|)
name|TYPE_VEC_DELETE_TAKES_SIZE
argument_list|(
name|current_class_type
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* An operator function must either be a non-static member function 	 or have at least one parameter of a class, a reference to a class, 	 an enumeration, or a reference to an enumeration.  13.4.0.6 */
if|if
condition|(
operator|!
name|methodp
operator|||
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|OPERATOR_TYPENAME_P
argument_list|(
name|name
argument_list|)
operator|||
name|name
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|CALL_EXPR
index|]
operator|||
name|name
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|MODIFY_EXPR
index|]
operator|||
name|name
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|COMPONENT_REF
index|]
operator|||
name|name
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|ARRAY_REF
index|]
condition|)
name|cp_error
argument_list|(
literal|"`%D' must be a nonstatic member function"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|p
init|=
name|argtypes
decl_stmt|;
if|if
condition|(
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|decl
argument_list|)
condition|)
name|cp_error
argument_list|(
literal|"`%D' must be either a non-static member function or a non-member function"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
for|for
control|(
init|;
name|TREE_VALUE
argument_list|(
name|p
argument_list|)
operator|!=
name|void_type_node
condition|;
name|p
operator|=
name|TREE_CHAIN
argument_list|(
name|p
argument_list|)
control|)
block|{
name|tree
name|arg
init|=
name|TREE_VALUE
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|arg
operator|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/* This lets bad template code slip through.  */
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|arg
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|TEMPLATE_TYPE_PARM
condition|)
goto|goto
name|foundaggr
goto|;
block|}
name|cp_error
argument_list|(
literal|"`%D' must have an argument of class or enumerated type"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|foundaggr
label|:
empty_stmt|;
block|}
block|}
if|if
condition|(
name|name
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|CALL_EXPR
index|]
operator|||
name|name
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|METHOD_CALL_EXPR
index|]
condition|)
return|return;
comment|/* no restrictions on args */
if|if
condition|(
name|IDENTIFIER_TYPENAME_P
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|tree
name|t
init|=
name|TREE_TYPE
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|VOID_TYPE
condition|)
name|pedwarn
argument_list|(
literal|"void is not a valid type conversion operator"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|friendp
condition|)
block|{
name|int
name|ref
init|=
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|)
decl_stmt|;
name|char
modifier|*
name|what
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ref
condition|)
name|t
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|current_class_type
condition|)
name|what
operator|=
literal|"the same type"
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|t
argument_list|)
operator|&&
name|DERIVED_FROM_P
argument_list|(
name|t
argument_list|,
name|current_class_type
argument_list|)
condition|)
name|what
operator|=
literal|"a base class"
expr_stmt|;
if|if
condition|(
name|what
condition|)
name|warning
argument_list|(
literal|"conversion to %s%s will never use a type conversion operator"
argument_list|,
name|ref
condition|?
literal|"a reference to "
else|:
literal|""
argument_list|,
name|what
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|name
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|MODIFY_EXPR
index|]
condition|)
block|{
name|tree
name|parmtype
decl_stmt|;
if|if
condition|(
name|list_length
argument_list|(
name|argtypes
argument_list|)
operator|!=
literal|3
operator|&&
name|methodp
condition|)
block|{
name|cp_error
argument_list|(
literal|"`%D' must take exactly one argument"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return;
block|}
name|parmtype
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|argtypes
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|copy_assignment_arg_p
argument_list|(
name|parmtype
argument_list|,
name|virtualp
argument_list|)
operator|&&
operator|!
name|friendp
condition|)
block|{
name|TYPE_HAS_ASSIGN_REF
argument_list|(
name|current_class_type
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parmtype
argument_list|)
operator|!=
name|REFERENCE_TYPE
operator|||
name|TYPE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|parmtype
argument_list|)
argument_list|)
condition|)
name|TYPE_HAS_CONST_ASSIGN_REF
argument_list|(
name|current_class_type
argument_list|)
operator|=
literal|1
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Too soon; done in grok_function_init */
block|if (DECL_ABSTRACT_VIRTUAL_P (decl)) 		TYPE_HAS_ABSTRACT_ASSIGN_REF (current_class_type) = 1;
endif|#
directive|endif
block|}
block|}
elseif|else
if|if
condition|(
name|name
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|COND_EXPR
index|]
condition|)
block|{
comment|/* 13.4.0.3 */
name|pedwarn
argument_list|(
literal|"ANSI C++ prohibits overloading operator ?:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|list_length
argument_list|(
name|argtypes
argument_list|)
operator|!=
literal|4
condition|)
name|cp_error
argument_list|(
literal|"`%D' must take exactly three arguments"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ambi_op_p
argument_list|(
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|list_length
argument_list|(
name|argtypes
argument_list|)
operator|==
literal|2
condition|)
comment|/* prefix */
empty_stmt|;
elseif|else
if|if
condition|(
name|list_length
argument_list|(
name|argtypes
argument_list|)
operator|==
literal|3
condition|)
block|{
if|if
condition|(
operator|(
name|name
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|POSTINCREMENT_EXPR
index|]
operator|||
name|name
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|POSTDECREMENT_EXPR
index|]
operator|)
operator|&&
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|argtypes
argument_list|)
argument_list|)
operator|!=
name|integer_type_node
condition|)
block|{
if|if
condition|(
name|methodp
condition|)
name|cp_error
argument_list|(
literal|"postfix `%D' must take `int' as its argument"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|else
name|cp_error
argument_list|(
literal|"postfix `%D' must take `int' as its second argument"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|methodp
condition|)
name|cp_error
argument_list|(
literal|"`%D' must take either zero or one argument"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|else
name|cp_error
argument_list|(
literal|"`%D' must take either one or two arguments"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|unary_op_p
argument_list|(
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|list_length
argument_list|(
name|argtypes
argument_list|)
operator|!=
literal|2
condition|)
block|{
if|if
condition|(
name|methodp
condition|)
name|cp_error
argument_list|(
literal|"`%D' must take `void'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|else
name|cp_error
argument_list|(
literal|"`%D' must take exactly one argument"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/* if (binary_op_p (name)) */
block|{
if|if
condition|(
name|list_length
argument_list|(
name|argtypes
argument_list|)
operator|!=
literal|3
condition|)
block|{
if|if
condition|(
name|methodp
condition|)
name|cp_error
argument_list|(
literal|"`%D' must take exactly one argument"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|else
name|cp_error
argument_list|(
literal|"`%D' must take exactly two arguments"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 13.4.0.8 */
if|if
condition|(
name|argtypes
condition|)
for|for
control|(
init|;
name|argtypes
operator|!=
name|void_list_node
condition|;
name|argtypes
operator|=
name|TREE_CHAIN
argument_list|(
name|argtypes
argument_list|)
control|)
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|argtypes
argument_list|)
condition|)
block|{
name|TREE_PURPOSE
argument_list|(
name|argtypes
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|POSTINCREMENT_EXPR
index|]
operator|||
name|name
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|POSTDECREMENT_EXPR
index|]
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
name|cp_pedwarn
argument_list|(
literal|"`%D' cannot have default arguments"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
else|else
name|cp_error
argument_list|(
literal|"`%D' cannot have default arguments"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Get the struct, enum or union (CODE says which) with tag NAME.    Define the tag as a forward-reference if it is not defined.     C++: If a class derivation is given, process it here, and report    an error if multiple derivation declarations are not identical.     If this is a definition, come in through xref_tag and only look in    the current frame for the name (since C++ allows new names in any    scope.)  */
end_comment

begin_comment
comment|/* avoid rewriting all callers of xref_tag */
end_comment

begin_decl_stmt
specifier|static
name|int
name|xref_next_defn
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|tree
name|xref_defn_tag
parameter_list|(
name|code_type_node
parameter_list|,
name|name
parameter_list|,
name|binfo
parameter_list|)
name|tree
name|code_type_node
decl_stmt|;
name|tree
name|name
decl_stmt|,
name|binfo
decl_stmt|;
block|{
name|tree
name|rv
decl_stmt|,
name|ncp
decl_stmt|;
name|xref_next_defn
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|class_binding_level
condition|)
block|{
name|tree
name|n1
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
comment|/* we need to build a new IDENTIFIER_NODE for name which nukes        * the pieces... */
comment|/*       n1 = IDENTIFIER_LOCAL_VALUE (current_class_name);       if (n1) 	n1 = DECL_NAME (n1);       else 	n1 = current_class_name; */
name|n1
operator|=
name|TYPE_NAME
argument_list|(
name|current_class_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|n1
condition|)
name|n1
operator|=
name|DECL_NESTED_TYPENAME
argument_list|(
name|n1
argument_list|)
expr_stmt|;
else|else
name|n1
operator|=
name|current_class_name
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|4
operator|+
name|IDENTIFIER_LENGTH
argument_list|(
name|n1
argument_list|)
operator|+
name|IDENTIFIER_LENGTH
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s::%s"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|n1
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|ncp
operator|=
name|get_identifier
argument_list|(
name|buf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SPEW_DEBUG
if|if
condition|(
name|spew_debug
condition|)
name|printf
argument_list|(
literal|"*** %s ***\n"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|ncp
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
literal|0
block|IDENTIFIER_LOCAL_VALUE (name) = 	build_decl (TYPE_DECL, ncp, NULL_TREE);
endif|#
directive|endif
name|rv
operator|=
name|xref_tag
argument_list|(
name|code_type_node
argument_list|,
name|name
argument_list|,
name|binfo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ANON_AGGRNAME_P
argument_list|(
name|name
argument_list|)
condition|)
block|{
specifier|register
name|tree
name|type_decl
init|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|ncp
argument_list|,
name|rv
argument_list|)
decl_stmt|;
name|SET_DECL_ARTIFICIAL
argument_list|(
name|type_decl
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DWARF_DEBUGGING_INFO
comment|/* Mark the TYPE_DECL node created just above as a gratuitous one 	   so that dwarfout.c will know not to generate a TAG_typedef DIE 	   for it.  */
if|if
condition|(
name|write_symbols
operator|==
name|DWARF_DEBUG
condition|)
name|DECL_IGNORED_P
argument_list|(
name|type_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* DWARF_DEBUGGING_INFO */
name|pushdecl_nonclass_level
argument_list|(
name|type_decl
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|rv
operator|=
name|xref_tag
argument_list|(
name|code_type_node
argument_list|,
name|name
argument_list|,
name|binfo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|xref_next_defn
operator|=
literal|0
expr_stmt|;
return|return
name|rv
return|;
block|}
end_function

begin_function
name|tree
name|xref_tag
parameter_list|(
name|code_type_node
parameter_list|,
name|name
parameter_list|,
name|binfo
parameter_list|,
name|globalize
parameter_list|)
name|tree
name|code_type_node
decl_stmt|;
name|tree
name|name
decl_stmt|,
name|binfo
decl_stmt|;
name|int
name|globalize
decl_stmt|;
block|{
name|enum
name|tag_types
name|tag_code
decl_stmt|;
name|enum
name|tree_code
name|code
decl_stmt|;
name|int
name|temp
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
specifier|register
name|tree
name|ref
decl_stmt|,
name|t
decl_stmt|;
name|struct
name|binding_level
modifier|*
name|b
init|=
name|inner_binding_level
decl_stmt|;
name|tag_code
operator|=
operator|(
expr|enum
name|tag_types
operator|)
name|TREE_INT_CST_LOW
argument_list|(
name|code_type_node
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tag_code
condition|)
block|{
case|case
name|record_type
case|:
case|case
name|class_type
case|:
case|case
name|exception_type
case|:
case|case
name|signature_type
case|:
name|code
operator|=
name|RECORD_TYPE
expr_stmt|;
name|len
operator|=
name|list_length
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
break|break;
case|case
name|union_type
case|:
name|code
operator|=
name|UNION_TYPE
expr_stmt|;
if|if
condition|(
name|binfo
condition|)
block|{
name|cp_error
argument_list|(
literal|"derived union `%T' invalid"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|binfo
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|len
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|enum_type
case|:
name|code
operator|=
name|ENUMERAL_TYPE
expr_stmt|;
break|break;
default|default:
name|my_friendly_abort
argument_list|(
literal|18
argument_list|)
expr_stmt|;
block|}
comment|/* If a cross reference is requested, look up the type      already defined for this tag and return it.  */
name|t
operator|=
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|code
condition|)
name|t
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|xref_next_defn
condition|)
block|{
comment|/* If we know we are defining this tag, only look it up in this scope        * and don't try to find it as a type. */
name|xref_next_defn
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|t
operator|&&
name|TYPE_CONTEXT
argument_list|(
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_MANGLED
argument_list|(
name|name
argument_list|)
condition|)
name|ref
operator|=
name|t
expr_stmt|;
else|else
name|ref
operator|=
name|lookup_tag
argument_list|(
name|code
argument_list|,
name|name
argument_list|,
name|b
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|ref
operator|=
name|lookup_tag
argument_list|(
name|code
argument_list|,
name|name
argument_list|,
name|b
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|t
condition|)
name|ref
operator|=
name|t
expr_stmt|;
else|else
name|ref
operator|=
name|lookup_tag
argument_list|(
name|code
argument_list|,
name|name
argument_list|,
name|b
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ref
condition|)
block|{
comment|/* Try finding it as a type declaration.  If that wins, use it.  */
name|ref
operator|=
name|lookup_name
argument_list|(
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ref
operator|&&
name|TREE_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ref
argument_list|)
argument_list|)
operator|==
name|code
condition|)
name|ref
operator|=
name|TREE_TYPE
argument_list|(
name|ref
argument_list|)
expr_stmt|;
else|else
name|ref
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ref
condition|)
block|{
comment|/* If no such tag is yet defined, create a forward-reference node 	 and record it as the "definition". 	 When a real declaration of this type is found, 	 the forward-reference will be altered into a real type.  */
comment|/* In C++, since these migrate into the global scope, we must 	 build them on the permanent obstack.  */
name|temp
operator|=
name|allocation_temporary_p
argument_list|()
expr_stmt|;
if|if
condition|(
name|temp
condition|)
name|end_temporary_allocation
argument_list|()
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|ENUMERAL_TYPE
condition|)
block|{
name|ref
operator|=
name|make_node
argument_list|(
name|ENUMERAL_TYPE
argument_list|)
expr_stmt|;
comment|/* Give the type a default layout like unsigned int 	     to avoid crashing if it does not get defined.  */
name|TYPE_MODE
argument_list|(
name|ref
argument_list|)
operator|=
name|TYPE_MODE
argument_list|(
name|unsigned_type_node
argument_list|)
expr_stmt|;
name|TYPE_ALIGN
argument_list|(
name|ref
argument_list|)
operator|=
name|TYPE_ALIGN
argument_list|(
name|unsigned_type_node
argument_list|)
expr_stmt|;
name|TREE_UNSIGNED
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_PRECISION
argument_list|(
name|ref
argument_list|)
operator|=
name|TYPE_PRECISION
argument_list|(
name|unsigned_type_node
argument_list|)
expr_stmt|;
name|TYPE_MIN_VALUE
argument_list|(
name|ref
argument_list|)
operator|=
name|TYPE_MIN_VALUE
argument_list|(
name|unsigned_type_node
argument_list|)
expr_stmt|;
name|TYPE_MAX_VALUE
argument_list|(
name|ref
argument_list|)
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|unsigned_type_node
argument_list|)
expr_stmt|;
comment|/* Enable us to recognize when a type is created in class context. 	     To do nested classes correctly, this should probably be cleared 	     out when we leave this classes scope.  Currently this in only 	     done in `start_enum'.  */
name|pushtag
argument_list|(
name|name
argument_list|,
name|ref
argument_list|,
name|globalize
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_cadillac
condition|)
name|cadillac_start_enum
argument_list|(
name|ref
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tag_code
operator|==
name|exception_type
condition|)
block|{
name|ref
operator|=
name|make_lang_type
argument_list|(
name|code
argument_list|)
expr_stmt|;
comment|/* Enable us to recognize when an exception type is created in 	     class context.  To do nested classes correctly, this should 	     probably be cleared out when we leave this class's scope.  */
name|CLASSTYPE_DECLARED_EXCEPTION
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
name|pushtag
argument_list|(
name|name
argument_list|,
name|ref
argument_list|,
name|globalize
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_cadillac
condition|)
name|cadillac_start_struct
argument_list|(
name|ref
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|binding_level
modifier|*
name|old_b
init|=
name|class_binding_level
decl_stmt|;
name|ref
operator|=
name|make_lang_type
argument_list|(
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag_code
operator|==
name|signature_type
condition|)
block|{
name|SET_SIGNATURE
argument_list|(
name|ref
argument_list|)
expr_stmt|;
comment|/* Since a signature type will be turned into the type 		 of signature tables, it's not only an interface.  */
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|ref
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SET_CLASSTYPE_INTERFACE_KNOWN
argument_list|(
name|ref
argument_list|)
expr_stmt|;
comment|/* A signature doesn't have a vtable.  */
name|CLASSTYPE_VTABLE_NEEDS_WRITING
argument_list|(
name|ref
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|NONNESTED_CLASSES
comment|/* Class types don't nest the way enums do.  */
name|class_binding_level
operator|=
operator|(
expr|struct
name|binding_level
operator|*
operator|)
literal|0
expr_stmt|;
endif|#
directive|endif
name|pushtag
argument_list|(
name|name
argument_list|,
name|ref
argument_list|,
name|globalize
argument_list|)
expr_stmt|;
name|class_binding_level
operator|=
name|old_b
expr_stmt|;
if|if
condition|(
name|flag_cadillac
condition|)
name|cadillac_start_struct
argument_list|(
name|ref
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|IS_AGGR_TYPE_CODE
argument_list|(
name|code
argument_list|)
condition|)
block|{
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|ref
argument_list|)
operator|&&
operator|(
operator|(
name|tag_code
operator|==
name|exception_type
operator|)
operator|!=
operator|(
name|CLASSTYPE_DECLARED_EXCEPTION
argument_list|(
name|ref
argument_list|)
operator|==
literal|1
operator|)
operator|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"type `%T' is both exception and aggregate type"
argument_list|,
name|ref
argument_list|)
expr_stmt|;
name|CLASSTYPE_DECLARED_EXCEPTION
argument_list|(
name|ref
argument_list|)
operator|=
operator|(
name|tag_code
operator|==
name|exception_type
operator|)
expr_stmt|;
block|}
block|}
comment|/* If it no longer looks like a nested type, make sure it's 	 in global scope.  */
if|if
condition|(
name|b
operator|==
name|global_binding_level
operator|&&
operator|!
name|class_binding_level
operator|&&
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
operator|=
name|TYPE_NAME
argument_list|(
name|ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|binfo
condition|)
block|{
name|tree
name|tt1
init|=
name|binfo
decl_stmt|;
name|tree
name|tt2
init|=
name|TYPE_BINFO_BASETYPES
argument_list|(
name|ref
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_BINFO_BASETYPES
argument_list|(
name|ref
argument_list|)
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|tt1
condition|;
name|i
operator|++
operator|,
name|tt1
operator|=
name|TREE_CHAIN
argument_list|(
name|tt1
argument_list|)
control|)
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|tt1
argument_list|)
operator|!=
name|TYPE_IDENTIFIER
argument_list|(
name|BINFO_TYPE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|tt2
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"redeclaration of derivation chain of type `%#T'"
argument_list|,
name|ref
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|tt1
operator|==
name|NULL_TREE
condition|)
comment|/* The user told us something we already knew.  */
goto|goto
name|just_return
goto|;
comment|/* In C++, since these migrate into the global scope, we must 	     build them on the permanent obstack.  */
name|end_temporary_allocation
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|binfo
condition|)
block|{
comment|/* In the declaration `A : X, Y, ... Z' we mark all the types 	 (A, X, Y, ..., Z) so we can check for duplicates.  */
name|tree
name|binfos
decl_stmt|;
name|SET_CLASSTYPE_MARKED
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|BINFO_BASETYPES
argument_list|(
name|TYPE_BINFO
argument_list|(
name|ref
argument_list|)
argument_list|)
operator|=
name|binfos
operator|=
name|make_tree_vec
argument_list|(
name|len
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|binfo
condition|;
name|binfo
operator|=
name|TREE_CHAIN
argument_list|(
name|binfo
argument_list|)
control|)
block|{
comment|/* The base of a derived struct is public by default.  */
name|int
name|via_public
init|=
operator|(
name|TREE_PURPOSE
argument_list|(
name|binfo
argument_list|)
operator|==
operator|(
name|tree
operator|)
name|access_public
operator|||
name|TREE_PURPOSE
argument_list|(
name|binfo
argument_list|)
operator|==
operator|(
name|tree
operator|)
name|access_public_virtual
operator|||
operator|(
name|tag_code
operator|!=
name|class_type
operator|&&
operator|(
name|TREE_PURPOSE
argument_list|(
name|binfo
argument_list|)
operator|==
operator|(
name|tree
operator|)
name|access_default
operator|||
name|TREE_PURPOSE
argument_list|(
name|binfo
argument_list|)
operator|==
operator|(
name|tree
operator|)
name|access_default_virtual
operator|)
operator|)
operator|)
decl_stmt|;
name|int
name|via_protected
init|=
name|TREE_PURPOSE
argument_list|(
name|binfo
argument_list|)
operator|==
operator|(
name|tree
operator|)
name|access_protected
decl_stmt|;
name|int
name|via_virtual
init|=
operator|(
name|TREE_PURPOSE
argument_list|(
name|binfo
argument_list|)
operator|==
operator|(
name|tree
operator|)
name|access_private_virtual
operator|||
name|TREE_PURPOSE
argument_list|(
name|binfo
argument_list|)
operator|==
operator|(
name|tree
operator|)
name|access_public_virtual
operator|||
name|TREE_PURPOSE
argument_list|(
name|binfo
argument_list|)
operator|==
operator|(
name|tree
operator|)
name|access_default_virtual
operator|)
decl_stmt|;
name|tree
name|basetype
init|=
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|binfo
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|base_binfo
decl_stmt|;
name|GNU_xref_hier
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|binfo
argument_list|)
argument_list|)
argument_list|,
name|via_public
argument_list|,
name|via_virtual
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|basetype
operator|&&
name|TREE_CODE
argument_list|(
name|basetype
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|basetype
operator|=
name|TREE_TYPE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|basetype
operator|||
name|TREE_CODE
argument_list|(
name|basetype
argument_list|)
operator|!=
name|RECORD_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"base type `%s' fails to be a struct or class type"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|binfo
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|#
directive|if
literal|1
comment|/* This code replaces similar code in layout_basetypes.  */
elseif|else
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|basetype
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|cp_error
argument_list|(
literal|"base class `%T' has incomplete type"
argument_list|,
name|basetype
argument_list|)
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
else|else
block|{
if|if
condition|(
name|CLASSTYPE_MARKED
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
if|if
condition|(
name|basetype
operator|==
name|ref
condition|)
name|cp_error
argument_list|(
literal|"recursive type `%T' undefined"
argument_list|,
name|basetype
argument_list|)
expr_stmt|;
else|else
name|cp_error
argument_list|(
literal|"duplicate base type `%T' invalid"
argument_list|,
name|basetype
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Note that the BINFO records which describe individual  		 inheritances are *not* shared in the lattice!  They  		 cannot be shared because a given baseclass may be  		 inherited with different `accessibility' by different  		 derived classes.  (Each BINFO record describing an  		 individual inheritance contains flags which say what  		 the `accessibility' of that particular inheritance is.)  */
name|base_binfo
operator|=
name|make_binfo
argument_list|(
name|integer_zero_node
argument_list|,
name|basetype
argument_list|,
name|TYPE_BINFO_VTABLE
argument_list|(
name|basetype
argument_list|)
argument_list|,
name|TYPE_BINFO_VIRTUALS
argument_list|(
name|basetype
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
operator|=
name|base_binfo
expr_stmt|;
name|TREE_VIA_PUBLIC
argument_list|(
name|base_binfo
argument_list|)
operator|=
name|via_public
expr_stmt|;
name|TREE_VIA_PROTECTED
argument_list|(
name|base_binfo
argument_list|)
operator|=
name|via_protected
expr_stmt|;
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
operator|=
name|via_virtual
expr_stmt|;
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|base_binfo
argument_list|)
operator|=
name|TYPE_BINFO
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|SET_CLASSTYPE_MARKED
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* XYZZY TEST VIRTUAL BASECLASSES */
block|if (CLASSTYPE_N_BASECLASSES (basetype) == NULL_TREE&& TYPE_HAS_DEFAULT_CONSTRUCTOR (basetype)&& via_virtual == 0)   {     warning ("making type `%s' a virtual baseclass", 	     TYPE_NAME_STRING (basetype));     via_virtual = 1;   }
endif|#
directive|endif
comment|/* We are free to modify these bits because they are meaningless 		 at top level, and BASETYPE is a top-level type.  */
if|if
condition|(
name|via_virtual
operator|||
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_USES_COMPLEX_INHERITANCE
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|TYPE_OVERLOADS_METHOD_CALL_EXPR
argument_list|(
name|ref
argument_list|)
operator||=
name|TYPE_OVERLOADS_METHOD_CALL_EXPR
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TYPE_GETS_NEW
argument_list|(
name|ref
argument_list|)
operator||=
name|TYPE_GETS_NEW
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TYPE_GETS_DELETE
argument_list|(
name|ref
argument_list|)
operator||=
name|TYPE_GETS_DELETE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|CLASSTYPE_LOCAL_TYPEDECLS
argument_list|(
name|ref
argument_list|)
operator||=
name|CLASSTYPE_LOCAL_TYPEDECLS
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
condition|)
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
operator|=
name|i
expr_stmt|;
else|else
name|BINFO_BASETYPES
argument_list|(
name|TYPE_BINFO
argument_list|(
name|ref
argument_list|)
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|1
condition|)
name|TYPE_USES_MULTIPLE_INHERITANCE
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
literal|1
condition|)
name|TYPE_USES_MULTIPLE_INHERITANCE
argument_list|(
name|ref
argument_list|)
operator|=
name|TYPE_USES_MULTIPLE_INHERITANCE
argument_list|(
name|BINFO_TYPE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_USES_MULTIPLE_INHERITANCE
argument_list|(
name|ref
argument_list|)
condition|)
name|TYPE_USES_COMPLEX_INHERITANCE
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Unmark all the types.  */
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
name|CLEAR_CLASSTYPE_MARKED
argument_list|(
name|BINFO_TYPE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|CLEAR_CLASSTYPE_MARKED
argument_list|(
name|ref
argument_list|)
expr_stmt|;
block|}
name|just_return
label|:
comment|/* Until the type is defined, tentatively accept whatever      structure tag the user hands us.  */
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|ref
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|ref
operator|!=
name|current_class_type
comment|/* Have to check this, in case we have contradictory tag info.  */
operator|&&
name|IS_AGGR_TYPE_CODE
argument_list|(
name|TREE_CODE
argument_list|(
name|ref
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|tag_code
operator|==
name|class_type
condition|)
name|CLASSTYPE_DECLARED_CLASS
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|tag_code
operator|==
name|record_type
operator|||
name|tag_code
operator|==
name|signature_type
condition|)
name|CLASSTYPE_DECLARED_CLASS
argument_list|(
name|ref
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
name|pop_obstacks
argument_list|()
expr_stmt|;
return|return
name|ref
return|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|tree
name|current_local_enum
init|=
name|NULL_TREE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Begin compiling the definition of an enumeration type.    NAME is its name (or null if anonymous).    Returns the type object, as yet incomplete.    Also records info about it so that build_enumerator    may be used to declare the individual values as they are read.  */
end_comment

begin_function
name|tree
name|start_enum
parameter_list|(
name|name
parameter_list|)
name|tree
name|name
decl_stmt|;
block|{
specifier|register
name|tree
name|enumtype
init|=
name|NULL_TREE
decl_stmt|;
name|struct
name|binding_level
modifier|*
name|b
init|=
name|inner_binding_level
decl_stmt|;
comment|/* If this is the real definition for a previous forward reference,      fill in the contents in the same object that used to be the      forward reference.  */
if|if
condition|(
name|name
operator|!=
name|NULL_TREE
condition|)
name|enumtype
operator|=
name|lookup_tag
argument_list|(
name|ENUMERAL_TYPE
argument_list|,
name|name
argument_list|,
name|b
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|enumtype
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|enumtype
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
name|cp_error
argument_list|(
literal|"multiple definition of enum `%T'"
argument_list|,
name|enumtype
argument_list|)
expr_stmt|;
else|else
block|{
name|enumtype
operator|=
name|make_node
argument_list|(
name|ENUMERAL_TYPE
argument_list|)
expr_stmt|;
name|pushtag
argument_list|(
name|name
argument_list|,
name|enumtype
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|current_class_type
condition|)
name|TREE_ADDRESSABLE
argument_list|(
name|b
operator|->
name|tags
argument_list|)
operator|=
literal|1
expr_stmt|;
name|current_local_enum
operator|=
name|NULL_TREE
expr_stmt|;
if|#
directive|if
literal|0
comment|/* This stuff gets cleared in finish_enum anyway.  */
block|if (TYPE_VALUES (enumtype) != NULL_TREE)
comment|/* Completely replace its old definition.        The old enumerators remain defined, however.  */
block|TYPE_VALUES (enumtype) = NULL_TREE;
comment|/* Initially, set up this enum as like `int'      so that we can create the enumerators' declarations and values.      Later on, the precision of the type may be changed and      it may be laid out again.  */
block|TYPE_PRECISION (enumtype) = TYPE_PRECISION (integer_type_node);   TYPE_SIZE (enumtype) = NULL_TREE;   fixup_signed_type (enumtype);
endif|#
directive|endif
comment|/* We copy this value because enumerated type constants      are really of the type of the enumerator, not integer_type_node.  */
name|enum_next_value
operator|=
name|copy_node
argument_list|(
name|integer_zero_node
argument_list|)
expr_stmt|;
name|enum_overflow
operator|=
literal|0
expr_stmt|;
name|GNU_xref_decl
argument_list|(
name|current_function_decl
argument_list|,
name|enumtype
argument_list|)
expr_stmt|;
return|return
name|enumtype
return|;
block|}
end_function

begin_comment
comment|/* After processing and defining all the values of an enumeration type,    install their decls in the enumeration type and finish it off.    ENUMTYPE is the type object and VALUES a list of name-value pairs.    Returns ENUMTYPE.  */
end_comment

begin_function
name|tree
name|finish_enum
parameter_list|(
name|enumtype
parameter_list|,
name|values
parameter_list|)
specifier|register
name|tree
name|enumtype
decl_stmt|,
name|values
decl_stmt|;
block|{
specifier|register
name|tree
name|minnode
decl_stmt|,
name|maxnode
decl_stmt|;
comment|/* Calculate the maximum value of any enumerator in this type.  */
if|if
condition|(
name|values
condition|)
block|{
specifier|register
name|tree
name|pair
decl_stmt|;
specifier|register
name|tree
name|value
init|=
name|DECL_INITIAL
argument_list|(
name|TREE_VALUE
argument_list|(
name|values
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Speed up the main loop by performing some precalculations */
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|values
argument_list|)
argument_list|)
operator|=
name|enumtype
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
operator|=
name|enumtype
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|values
argument_list|)
operator|=
name|value
expr_stmt|;
name|minnode
operator|=
name|maxnode
operator|=
name|value
expr_stmt|;
for|for
control|(
name|pair
operator|=
name|TREE_CHAIN
argument_list|(
name|values
argument_list|)
init|;
name|pair
condition|;
name|pair
operator|=
name|TREE_CHAIN
argument_list|(
name|pair
argument_list|)
control|)
block|{
name|value
operator|=
name|DECL_INITIAL
argument_list|(
name|TREE_VALUE
argument_list|(
name|pair
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|pair
argument_list|)
argument_list|)
operator|=
name|enumtype
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
operator|=
name|enumtype
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|pair
argument_list|)
operator|=
name|value
expr_stmt|;
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|maxnode
argument_list|,
name|value
argument_list|)
condition|)
name|maxnode
operator|=
name|value
expr_stmt|;
elseif|else
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|value
argument_list|,
name|minnode
argument_list|)
condition|)
name|minnode
operator|=
name|value
expr_stmt|;
block|}
block|}
else|else
name|maxnode
operator|=
name|minnode
operator|=
name|integer_zero_node
expr_stmt|;
name|TYPE_VALUES
argument_list|(
name|enumtype
argument_list|)
operator|=
name|values
expr_stmt|;
block|{
name|int
name|unsignedp
init|=
name|tree_int_cst_sgn
argument_list|(
name|minnode
argument_list|)
operator|>=
literal|0
decl_stmt|;
name|int
name|lowprec
init|=
name|min_precision
argument_list|(
name|minnode
argument_list|,
name|unsignedp
argument_list|)
decl_stmt|;
name|int
name|highprec
init|=
name|min_precision
argument_list|(
name|maxnode
argument_list|,
name|unsignedp
argument_list|)
decl_stmt|;
name|int
name|precision
init|=
name|MAX
argument_list|(
name|lowprec
argument_list|,
name|highprec
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|flag_short_enums
operator|&&
name|precision
operator|<
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
condition|)
name|precision
operator|=
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
expr_stmt|;
comment|/*      *  The following code is unnecessary since the function       *  type_promotes_to deals correctly with promotion of enums of       *  underlying unsigned types to signed integer types.      *  Moreover, it causes an enum bitfield to require one more bit of      *  storage than defined by the ANSI/ISO C++ resolution section r.7.2      *  which defines the range of an enum.       */
if|#
directive|if
literal|0
comment|/* Unlike the C frontend, we prefer signed types.  */
block|if (unsignedp&& int_fits_type_p (maxnode, type_for_size (precision, 0)))       unsignedp = 0;
endif|#
directive|endif
name|TYPE_PRECISION
argument_list|(
name|enumtype
argument_list|)
operator|=
name|precision
expr_stmt|;
name|TYPE_SIZE
argument_list|(
name|enumtype
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|unsignedp
condition|)
name|fixup_unsigned_type
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
else|else
name|fixup_signed_type
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_cadillac
condition|)
name|cadillac_finish_enum
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
block|{
specifier|register
name|tree
name|tem
decl_stmt|;
comment|/* Fix up all variant types of this enum type.  */
for|for
control|(
name|tem
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|enumtype
argument_list|)
init|;
name|tem
condition|;
name|tem
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|tem
argument_list|)
control|)
block|{
name|TYPE_VALUES
argument_list|(
name|tem
argument_list|)
operator|=
name|TYPE_VALUES
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
name|TYPE_MIN_VALUE
argument_list|(
name|tem
argument_list|)
operator|=
name|TYPE_MIN_VALUE
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
name|TYPE_MAX_VALUE
argument_list|(
name|tem
argument_list|)
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
name|TYPE_SIZE
argument_list|(
name|tem
argument_list|)
operator|=
name|TYPE_SIZE
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
name|TYPE_MODE
argument_list|(
name|tem
argument_list|)
operator|=
name|TYPE_MODE
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
name|TYPE_PRECISION
argument_list|(
name|tem
argument_list|)
operator|=
name|TYPE_PRECISION
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
name|TYPE_ALIGN
argument_list|(
name|tem
argument_list|)
operator|=
name|TYPE_ALIGN
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
name|TREE_UNSIGNED
argument_list|(
name|tem
argument_list|)
operator|=
name|TREE_UNSIGNED
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Finish debugging output for this type.  */
if|#
directive|if
literal|0
comment|/* @@ Do we ever generate generate ENUMERAL_TYPE nodes for which debugging      information should *not* be generated?  I think not.  */
block|if (! DECL_IGNORED_P (TYPE_NAME (enumtype)))
endif|#
directive|endif
name|rest_of_type_compilation
argument_list|(
name|enumtype
argument_list|,
name|global_bindings_p
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|enumtype
return|;
block|}
end_function

begin_comment
comment|/* Build and install a CONST_DECL for one value of the    current enumeration type (one that was begun with start_enum).    Return a tree-list containing the name and its value.    Assignment of sequential values by default is handled here.  */
end_comment

begin_function
name|tree
name|build_enumerator
parameter_list|(
name|name
parameter_list|,
name|value
parameter_list|)
name|tree
name|name
decl_stmt|,
name|value
decl_stmt|;
block|{
name|tree
name|decl
decl_stmt|,
name|result
decl_stmt|;
comment|/* Change this to zero if we find VALUE is not shareable.  */
name|int
name|shareable
init|=
literal|1
decl_stmt|;
comment|/* Remove no-op casts from the value.  */
if|if
condition|(
name|value
condition|)
name|STRIP_TYPE_NOPS
argument_list|(
name|value
argument_list|)
expr_stmt|;
comment|/* Validate and default VALUE.  */
if|if
condition|(
name|value
operator|!=
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|TREE_READONLY_DECL_P
argument_list|(
name|value
argument_list|)
condition|)
block|{
name|value
operator|=
name|decl_constant_value
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|shareable
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|value
operator|=
name|default_conversion
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|constant_expression_warning
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cp_error
argument_list|(
literal|"enumerator value for `%D' not integer constant"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|value
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
comment|/* The order of things is reversed here so that we      can check for possible sharing of enum values,      to keep that from happening.  */
comment|/* Default based on previous value.  */
if|if
condition|(
name|value
operator|==
name|NULL_TREE
condition|)
block|{
name|value
operator|=
name|enum_next_value
expr_stmt|;
if|if
condition|(
name|enum_overflow
condition|)
name|cp_error
argument_list|(
literal|"overflow in enumeration values at `%D'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* Remove no-op casts from the value.  */
if|if
condition|(
name|value
condition|)
name|STRIP_TYPE_NOPS
argument_list|(
name|value
argument_list|)
expr_stmt|;
comment|/* Make up for hacks in lex.c.  */
if|if
condition|(
name|value
operator|==
name|integer_zero_node
condition|)
name|value
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|value
operator|==
name|integer_one_node
condition|)
name|value
operator|=
name|build_int_2
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|(
name|shareable
operator|==
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|)
condition|)
block|{
name|value
operator|=
name|copy_node
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
block|}
comment|/* C++ associates enums with global, function, or class declarations.  */
name|decl
operator|=
name|current_scope
argument_list|()
expr_stmt|;
if|if
condition|(
name|decl
operator|&&
name|decl
operator|==
name|current_class_type
condition|)
block|{
comment|/* This enum declaration is local to the class, so we must put 	 it in that class's list of decls.  */
name|decl
operator|=
name|build_lang_field_decl
argument_list|(
name|CONST_DECL
argument_list|,
name|name
argument_list|,
name|integer_type_node
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|value
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|pushdecl_class_level
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
operator|=
name|current_local_enum
expr_stmt|;
name|current_local_enum
operator|=
name|decl
expr_stmt|;
block|}
else|else
block|{
comment|/* It's a global enum, or it's local to a function.  (Note local to 	 a function could mean local to a class method.  */
name|decl
operator|=
name|build_decl
argument_list|(
name|CONST_DECL
argument_list|,
name|name
argument_list|,
name|integer_type_node
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|value
expr_stmt|;
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|GNU_xref_decl
argument_list|(
name|current_function_decl
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
comment|/* Set basis for default for next value.  */
name|enum_next_value
operator|=
name|build_binary_op_nodefault
argument_list|(
name|PLUS_EXPR
argument_list|,
name|value
argument_list|,
name|integer_one_node
argument_list|,
name|PLUS_EXPR
argument_list|)
expr_stmt|;
name|enum_overflow
operator|=
name|tree_int_cst_lt
argument_list|(
name|enum_next_value
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|enum_next_value
operator|==
name|integer_one_node
condition|)
name|enum_next_value
operator|=
name|copy_node
argument_list|(
name|enum_next_value
argument_list|)
expr_stmt|;
name|result
operator|=
name|saveable_tree_cons
argument_list|(
name|name
argument_list|,
name|decl
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|tree
name|grok_enum_decls
parameter_list|(
name|type
parameter_list|,
name|decl
parameter_list|)
name|tree
name|type
decl_stmt|,
name|decl
decl_stmt|;
block|{
name|tree
name|d
init|=
name|current_local_enum
decl_stmt|;
if|if
condition|(
name|d
operator|==
name|NULL_TREE
condition|)
return|return
name|decl
return|;
while|while
condition|(
literal|1
condition|)
block|{
name|TREE_TYPE
argument_list|(
name|d
argument_list|)
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|d
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|TREE_CHAIN
argument_list|(
name|d
argument_list|)
operator|=
name|decl
expr_stmt|;
break|break;
block|}
name|d
operator|=
name|TREE_CHAIN
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
name|decl
operator|=
name|current_local_enum
expr_stmt|;
name|current_local_enum
operator|=
name|NULL_TREE
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create the FUNCTION_DECL for a function definition.    DECLSPECS and DECLARATOR are the parts of the declaration;    they describe the function's name and the type it returns,    but twisted together in a fashion that parallels the syntax of C.     This function creates a binding context for the function body    as well as setting up the FUNCTION_DECL in current_function_decl.     Returns 1 on success.  If the DECLARATOR is not suitable for a function    (it defines a datum instead), we return 0, which tells    yyparse to report a parse error.     For C++, we must first check whether that datum makes any sense.    For example, "class A local_a(1,2);" means that variable local_a    is an aggregate of type A, which should have a constructor    applied to it with the argument list [1, 2].     @@ There is currently no way to retrieve the storage    @@ allocated to FUNCTION (or all of its parms) if we return    @@ something we had previously.  */
end_comment

begin_function
name|int
name|start_function
parameter_list|(
name|declspecs
parameter_list|,
name|declarator
parameter_list|,
name|raises
parameter_list|,
name|pre_parsed_p
parameter_list|)
name|tree
name|declarator
decl_stmt|,
name|declspecs
decl_stmt|,
name|raises
decl_stmt|;
name|int
name|pre_parsed_p
decl_stmt|;
block|{
name|tree
name|decl1
decl_stmt|,
name|olddecl
decl_stmt|;
name|tree
name|ctype
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|fntype
decl_stmt|;
name|tree
name|restype
decl_stmt|;
specifier|extern
name|int
name|have_extern_spec
decl_stmt|;
specifier|extern
name|int
name|used_extern_spec
decl_stmt|;
name|int
name|doing_friend
init|=
literal|0
decl_stmt|;
comment|/* Sanity check.  */
name|my_friendly_assert
argument_list|(
name|TREE_VALUE
argument_list|(
name|void_list_node
argument_list|)
operator|==
name|void_type_node
argument_list|,
literal|160
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CHAIN
argument_list|(
name|void_list_node
argument_list|)
operator|==
name|NULL_TREE
argument_list|,
literal|161
argument_list|)
expr_stmt|;
comment|/* Assume, until we see it does. */
name|current_function_returns_value
operator|=
literal|0
expr_stmt|;
name|current_function_returns_null
operator|=
literal|0
expr_stmt|;
name|warn_about_return_type
operator|=
literal|0
expr_stmt|;
name|current_extern_inline
operator|=
literal|0
expr_stmt|;
name|current_function_assigns_this
operator|=
literal|0
expr_stmt|;
name|current_function_just_assigned_this
operator|=
literal|0
expr_stmt|;
name|current_function_parms_stored
operator|=
literal|0
expr_stmt|;
name|original_result_rtx
operator|=
name|NULL_RTX
expr_stmt|;
name|current_function_obstack_index
operator|=
literal|0
expr_stmt|;
name|current_function_obstack_usage
operator|=
literal|0
expr_stmt|;
name|clear_temp_name
argument_list|()
expr_stmt|;
comment|/* This should only be done once on the top most decl. */
if|if
condition|(
name|have_extern_spec
operator|&&
operator|!
name|used_extern_spec
condition|)
block|{
name|declspecs
operator|=
name|decl_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"extern"
argument_list|)
argument_list|,
name|declspecs
argument_list|)
expr_stmt|;
name|used_extern_spec
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|pre_parsed_p
condition|)
block|{
name|decl1
operator|=
name|declarator
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_ARGUMENTS
argument_list|(
name|decl1
argument_list|)
operator|&&
operator|!
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|decl1
argument_list|)
operator|&&
name|DECL_CONTEXT
argument_list|(
name|decl1
argument_list|)
operator|&&
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl1
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|IDENTIFIER_TEMPLATE
argument_list|(
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"redeclaration of `%#D'"
argument_list|,
name|decl1
argument_list|)
expr_stmt|;
if|if
condition|(
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|decl1
argument_list|)
argument_list|)
condition|)
name|cp_error_at
argument_list|(
literal|"previous declaration here"
argument_list|,
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|decl1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|decl1
argument_list|)
argument_list|)
condition|)
name|cp_error_at
argument_list|(
literal|"previous declaration here"
argument_list|,
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|decl1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|last_function_parms
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
name|last_function_parm_tags
operator|=
name|NULL_TREE
expr_stmt|;
name|fntype
operator|=
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|ctype
operator|=
name|TYPE_METHOD_BASETYPE
argument_list|(
name|fntype
argument_list|)
expr_stmt|;
comment|/* ANSI C++ June 5 1992 WP 11.4.5.  A friend function defined in a 	 class is in the (lexical) scope of the class in which it is 	 defined.  */
if|if
condition|(
operator|!
name|ctype
operator|&&
name|DECL_FRIEND_P
argument_list|(
name|decl1
argument_list|)
condition|)
block|{
name|ctype
operator|=
name|DECL_CLASS_CONTEXT
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
comment|/* CTYPE could be null here if we're dealing with a template; 	     for example, `inline friend float foo()' inside a template 	     will have no CTYPE set.  */
if|if
condition|(
name|ctype
operator|&&
name|TREE_CODE
argument_list|(
name|ctype
argument_list|)
operator|!=
name|RECORD_TYPE
condition|)
name|ctype
operator|=
name|NULL_TREE
expr_stmt|;
else|else
name|doing_friend
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|DECL_VINDEX
argument_list|(
name|decl1
argument_list|)
operator|&&
name|write_virtuals
operator|>=
literal|2
operator|&&
name|CLASSTYPE_VTABLE_NEEDS_WRITING
argument_list|(
name|ctype
argument_list|)
operator|)
condition|)
name|current_extern_inline
operator|=
name|DECL_THIS_EXTERN
argument_list|(
name|decl1
argument_list|)
operator|&&
name|DECL_INLINE
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
name|raises
operator|=
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|fntype
argument_list|)
expr_stmt|;
comment|/* In a fcn definition, arg types must be complete.  */
name|require_complete_types_for_parms
argument_list|(
name|last_function_parms
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|decl1
operator|=
name|grokdeclarator
argument_list|(
name|declarator
argument_list|,
name|declspecs
argument_list|,
name|FUNCDEF
argument_list|,
literal|1
argument_list|,
name|raises
argument_list|)
expr_stmt|;
comment|/* If the declarator is not suitable for a function definition, 	 cause a syntax error.  */
if|if
condition|(
name|decl1
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|decl1
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
return|return
literal|0
return|;
name|fntype
operator|=
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
name|restype
operator|=
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|restype
argument_list|)
operator|&&
operator|!
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|restype
argument_list|)
operator|&&
operator|!
name|CLASSTYPE_GOT_SEMICOLON
argument_list|(
name|restype
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"semicolon missing after declaration of `%#T'"
argument_list|,
name|restype
argument_list|)
expr_stmt|;
name|shadow_tag
argument_list|(
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|restype
argument_list|)
argument_list|)
expr_stmt|;
name|CLASSTYPE_GOT_SEMICOLON
argument_list|(
name|restype
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|fntype
operator|=
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fntype
operator|=
name|build_cplus_method_type
argument_list|(
name|build_type_variant
argument_list|(
name|TYPE_METHOD_BASETYPE
argument_list|(
name|fntype
argument_list|)
argument_list|,
name|TREE_READONLY
argument_list|(
name|decl1
argument_list|)
argument_list|,
name|TREE_SIDE_EFFECTS
argument_list|(
name|decl1
argument_list|)
argument_list|)
argument_list|,
name|integer_type_node
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
operator|=
name|fntype
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|ctype
operator|=
name|TYPE_METHOD_BASETYPE
argument_list|(
name|fntype
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IDENTIFIER_LENGTH
argument_list|(
name|DECL_NAME
argument_list|(
name|decl1
argument_list|)
argument_list|)
operator|==
literal|4
operator|&&
operator|!
name|strcmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl1
argument_list|)
argument_list|)
argument_list|,
literal|"main"
argument_list|)
operator|&&
name|DECL_CONTEXT
argument_list|(
name|decl1
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* If this doesn't return integer_type, complain.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
argument_list|)
operator|!=
name|integer_type_node
condition|)
block|{
if|if
condition|(
name|pedantic
operator|||
name|warn_return_type
condition|)
name|warning
argument_list|(
literal|"return type for `main' changed to integer type"
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
operator|=
name|fntype
operator|=
name|default_function_type
expr_stmt|;
block|}
name|warn_about_return_type
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Warn if function was previously implicitly declared      (but not if we warned then).  */
if|if
condition|(
operator|!
name|warn_implicit
operator|&&
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|DECL_NAME
argument_list|(
name|decl1
argument_list|)
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|cp_warning_at
argument_list|(
literal|"`%D' implicitly declared before its definition"
argument_list|,
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|DECL_NAME
argument_list|(
name|decl1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|current_function_decl
operator|=
name|decl1
expr_stmt|;
if|if
condition|(
name|flag_cadillac
condition|)
name|cadillac_start_function
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
else|else
name|announce_function
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|)
condition|)
name|error_with_aggr_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|,
literal|"return-type `%s' is an incomplete type"
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"return-type is an incomplete type"
argument_list|)
expr_stmt|;
comment|/* Make it return void instead, but don't change the 	 type of the DECL_RESULT, in case we have a named return value.  */
if|if
condition|(
name|ctype
condition|)
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
operator|=
name|build_cplus_method_type
argument_list|(
name|build_type_variant
argument_list|(
name|ctype
argument_list|,
name|TREE_READONLY
argument_list|(
name|decl1
argument_list|)
argument_list|,
name|TREE_SIDE_EFFECTS
argument_list|(
name|decl1
argument_list|)
argument_list|)
argument_list|,
name|void_type_node
argument_list|,
name|FUNCTION_ARG_CHAIN
argument_list|(
name|decl1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
operator|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_RESULT
argument_list|(
name|decl1
argument_list|)
operator|=
name|build_decl
argument_list|(
name|RESULT_DECL
argument_list|,
literal|0
argument_list|,
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|warn_about_return_type
condition|)
name|warning
argument_list|(
literal|"return-type defaults to `int'"
argument_list|)
expr_stmt|;
comment|/* Make the init_value nonzero so pushdecl knows this is not tentative.      error_mark_node is replaced below (in poplevel) with the BLOCK.  */
name|DECL_INITIAL
argument_list|(
name|decl1
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
comment|/* Didn't get anything from C.  */
name|olddecl
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* This function exists in static storage.      (This does not mean `static' in the C sense!)  */
name|TREE_STATIC
argument_list|(
name|decl1
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Record the decl so that the function name is defined.      If we already have a decl for this name, and it is a FUNCTION_DECL,      use the old decl.  */
if|if
condition|(
name|pre_parsed_p
operator|==
literal|0
condition|)
block|{
name|current_function_decl
operator|=
name|decl1
operator|=
name|pushdecl
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
name|DECL_MAIN_VARIANT
argument_list|(
name|decl1
argument_list|)
operator|=
name|decl1
expr_stmt|;
name|fntype
operator|=
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
block|}
else|else
name|current_function_decl
operator|=
name|decl1
expr_stmt|;
comment|/* If this function belongs to an interface, it is public.      If it belongs to someone else's interface, it is also external.      It doesn't matter whether it's inline or not.  */
if|if
condition|(
name|interface_unknown
operator|==
literal|0
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl1
argument_list|)
condition|)
block|{
name|TREE_PUBLIC
argument_list|(
name|decl1
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl1
argument_list|)
operator|=
operator|(
name|interface_only
operator|||
operator|(
name|DECL_INLINE
argument_list|(
name|decl1
argument_list|)
operator|&&
operator|!
name|flag_implement_inlines
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This is a definition, not a reference. 	 So normally clear DECL_EXTERNAL. 	 However, `extern inline' acts like a declaration except for 	 defining how to inline.  So set DECL_EXTERNAL in that case.  */
name|DECL_EXTERNAL
argument_list|(
name|decl1
argument_list|)
operator|=
name|current_extern_inline
expr_stmt|;
name|DECL_DEFER_OUTPUT
argument_list|(
name|decl1
argument_list|)
operator|=
name|DECL_INLINE
argument_list|(
name|decl1
argument_list|)
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl1
argument_list|)
operator|&&
operator|(
name|DECL_FUNCTION_MEMBER_P
argument_list|(
name|decl1
argument_list|)
operator|||
name|DECL_TEMPLATE_INSTANTIATION
argument_list|(
name|decl1
argument_list|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|ctype
operator|!=
name|NULL_TREE
operator|&&
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|decl1
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
operator|=
name|fntype
operator|=
name|build_function_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|last_function_parms
operator|=
name|TREE_CHAIN
argument_list|(
name|last_function_parms
argument_list|)
expr_stmt|;
name|DECL_ARGUMENTS
argument_list|(
name|decl1
argument_list|)
operator|=
name|last_function_parms
expr_stmt|;
name|ctype
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|restype
operator|=
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
expr_stmt|;
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|current_binding_level
operator|->
name|parm_flag
operator|=
literal|1
expr_stmt|;
comment|/* Save the parm names or decls from this function's declarator      where store_parm_decls will find them.  */
name|current_function_parms
operator|=
name|last_function_parms
expr_stmt|;
name|current_function_parm_tags
operator|=
name|last_function_parm_tags
expr_stmt|;
name|GNU_xref_function
argument_list|(
name|decl1
argument_list|,
name|current_function_parms
argument_list|)
expr_stmt|;
name|make_function_rtl
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctype
condition|)
block|{
name|push_nested_class
argument_list|(
name|ctype
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* If we're compiling a friend function, neither of the variables 	 current_class_decl nor current_class_type will have values.  */
if|if
condition|(
operator|!
name|doing_friend
condition|)
block|{
comment|/* We know that this was set up by `grokclassfn'. 	     We do not wait until `store_parm_decls', since evil 	     parse errors may never get us to that point.  Here 	     we keep the consistency between `current_class_type' 	     and `current_class_decl'.  */
name|current_class_decl
operator|=
name|last_function_parms
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|current_class_decl
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|current_class_decl
argument_list|)
operator|==
name|PARM_DECL
argument_list|,
literal|162
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_class_decl
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
name|tree
name|variant
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_class_decl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|CLASSTYPE_INST_VAR
argument_list|(
name|ctype
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* Can't call build_indirect_ref here, because it has special 		     logic to return C_C_D given this argument.  */
name|C_C_D
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|current_class_type
argument_list|,
name|current_class_decl
argument_list|)
expr_stmt|;
name|CLASSTYPE_INST_VAR
argument_list|(
name|ctype
argument_list|)
operator|=
name|C_C_D
expr_stmt|;
block|}
else|else
block|{
name|C_C_D
operator|=
name|CLASSTYPE_INST_VAR
argument_list|(
name|ctype
argument_list|)
expr_stmt|;
comment|/* `current_class_decl' is different for every 		     function we compile.  */
name|TREE_OPERAND
argument_list|(
name|C_C_D
argument_list|,
literal|0
argument_list|)
operator|=
name|current_class_decl
expr_stmt|;
block|}
name|TREE_READONLY
argument_list|(
name|C_C_D
argument_list|)
operator|=
name|TYPE_READONLY
argument_list|(
name|variant
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|C_C_D
argument_list|)
operator|=
name|TYPE_VOLATILE
argument_list|(
name|variant
argument_list|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|C_C_D
argument_list|)
operator|=
name|TYPE_VOLATILE
argument_list|(
name|variant
argument_list|)
expr_stmt|;
block|}
else|else
name|C_C_D
operator|=
name|current_class_decl
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|decl1
argument_list|)
condition|)
name|push_nested_class
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl1
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
else|else
name|push_memoized_context
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Allocate further tree nodes temporarily during compilation      of this function only.  Tiemann moved up here from bottom of fn.  */
name|temporary_allocation
argument_list|()
expr_stmt|;
comment|/* Promote the value to int before returning it.  */
if|if
condition|(
name|C_PROMOTING_INTEGER_TYPE_P
argument_list|(
name|restype
argument_list|)
condition|)
block|{
comment|/* It retains unsignedness if traditional or if it isn't 	 really getting wider.  */
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|restype
argument_list|)
operator|&&
operator|(
name|flag_traditional
operator|||
name|TYPE_PRECISION
argument_list|(
name|restype
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|)
condition|)
name|restype
operator|=
name|unsigned_type_node
expr_stmt|;
else|else
name|restype
operator|=
name|integer_type_node
expr_stmt|;
block|}
if|if
condition|(
name|DECL_RESULT
argument_list|(
name|decl1
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|DECL_RESULT
argument_list|(
name|decl1
argument_list|)
operator|=
name|build_decl
argument_list|(
name|RESULT_DECL
argument_list|,
literal|0
argument_list|,
name|restype
argument_list|)
expr_stmt|;
if|if
condition|(
name|DESTRUCTOR_NAME_P
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl1
argument_list|)
argument_list|)
condition|)
block|{
name|dtor_label
operator|=
name|build_decl
argument_list|(
name|LABEL_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|ctor_label
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
block|{
name|dtor_label
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|decl1
argument_list|)
condition|)
name|ctor_label
operator|=
name|build_decl
argument_list|(
name|LABEL_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
comment|/* If this fcn was already referenced via a block-scope `extern' decl      (or an implicit decl), propagate certain information about the usage.  */
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl1
argument_list|)
argument_list|)
condition|)
name|TREE_ADDRESSABLE
argument_list|(
name|decl1
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Store the parameter declarations into the current function declaration.    This is called after parsing the parameter declarations, before    digesting the body of the function.     Also install to binding contour return value identifier, if any.  */
end_comment

begin_function
name|void
name|store_parm_decls
parameter_list|()
block|{
specifier|register
name|tree
name|fndecl
init|=
name|current_function_decl
decl_stmt|;
specifier|register
name|tree
name|parm
decl_stmt|;
name|int
name|parms_have_cleanups
init|=
literal|0
decl_stmt|;
comment|/* This is either a chain of PARM_DECLs (when a prototype is used).  */
name|tree
name|specparms
init|=
name|current_function_parms
decl_stmt|;
comment|/* This is a list of types declared among parms in a prototype.  */
name|tree
name|parmtags
init|=
name|current_function_parm_tags
decl_stmt|;
comment|/* This is a chain of any other decls that came in among the parm      declarations.  If a parm is declared with  enum {foo, bar} x;      then CONST_DECLs for foo and bar are put here.  */
name|tree
name|nonparms
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
condition|)
name|fatal
argument_list|(
literal|"parse errors have confused me too much"
argument_list|)
expr_stmt|;
comment|/* Initialize RTL machinery.  */
name|init_function_start
argument_list|(
name|fndecl
argument_list|,
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
comment|/* Declare __FUNCTION__ and __PRETTY_FUNCTION__ for this function.  */
name|declare_function_name
argument_list|()
expr_stmt|;
comment|/* Create a binding level for the parms.  */
name|expand_start_bindings
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|specparms
operator|!=
name|NULL_TREE
condition|)
block|{
comment|/* This case is when the function was defined with an ANSI prototype. 	 The parms already have decls, so we need not do anything here 	 except record them as in effect 	 and complain if any redundant old-style parm decls were written.  */
specifier|register
name|tree
name|next
decl_stmt|;
comment|/* Must clear this because it might contain TYPE_DECLs declared 	 at class level.  */
name|storedecls
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
for|for
control|(
name|parm
operator|=
name|nreverse
argument_list|(
name|specparms
argument_list|)
init|;
name|parm
condition|;
name|parm
operator|=
name|next
control|)
block|{
name|next
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|PARM_DECL
condition|)
block|{
name|tree
name|cleanup
init|=
name|maybe_build_cleanup
argument_list|(
name|parm
argument_list|)
decl_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|parm
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
if|#
directive|if
literal|0
block|cp_error_at ("parameter name omitted", parm);
else|#
directive|else
comment|/* for C++, this is not an error.  */
name|pushdecl
argument_list|(
name|parm
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|void_type_node
condition|)
name|cp_error
argument_list|(
literal|"parameter `%D' declared void"
argument_list|,
name|parm
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Now fill in DECL_REFERENCE_SLOT for any of the parm decls. 		     A parameter is assumed not to have any side effects. 		     If this should change for any reason, then this 		     will have to wrap the bashed reference type in a save_expr. 		      		     Also, if the parameter type is declared to be an X 		     and there is an X(X&) constructor, we cannot lay it 		     into the stack (any more), so we make this parameter 		     look like it is really of reference type.  Functions 		     which pass parameters to this function will know to 		     create a temporary in their frame, and pass a reference 		     to that.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|&&
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
argument_list|)
condition|)
name|SET_DECL_REFERENCE_SLOT
argument_list|(
name|parm
argument_list|,
name|convert_from_reference
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|parm
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cleanup
condition|)
block|{
name|expand_decl
argument_list|(
name|parm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|expand_decl_cleanup
argument_list|(
name|parm
argument_list|,
name|cleanup
argument_list|)
condition|)
name|cp_error
argument_list|(
literal|"parser lost in parsing declaration of `%D'"
argument_list|,
name|parm
argument_list|)
expr_stmt|;
name|parms_have_cleanups
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* If we find an enum constant or a type tag, 		 put it aside for the moment.  */
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|nonparms
operator|=
name|chainon
argument_list|(
name|nonparms
argument_list|,
name|parm
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Get the decls in their original chain order 	 and record in the function.  This is all and only the 	 PARM_DECLs that were pushed into scope by the loop above.  */
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
operator|=
name|getdecls
argument_list|()
expr_stmt|;
name|storetags
argument_list|(
name|chainon
argument_list|(
name|parmtags
argument_list|,
name|gettags
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Now store the final chain of decls for the arguments      as the decl-chain of the current lexical scope.      Put the enumerators in as well, at the front so that      DECL_ARGUMENTS is not modified.  */
name|storedecls
argument_list|(
name|chainon
argument_list|(
name|nonparms
argument_list|,
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize the RTL code for the function.  */
name|DECL_SAVED_INSNS
argument_list|(
name|fndecl
argument_list|)
operator|=
name|NULL_RTX
expr_stmt|;
name|expand_function_start
argument_list|(
name|fndecl
argument_list|,
name|parms_have_cleanups
argument_list|)
expr_stmt|;
comment|/* Create a binding contour which can be used to catch      cleanup-generated temporaries.  Also, if the return value needs or      has initialization, deal with that now.  */
if|if
condition|(
name|parms_have_cleanups
condition|)
block|{
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|expand_start_bindings
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|current_function_parms_stored
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|flag_gc
condition|)
block|{
name|maybe_gc_cleanup
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|error_mark_node
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|expand_decl_cleanup
argument_list|(
name|NULL_TREE
argument_list|,
name|maybe_gc_cleanup
argument_list|)
condition|)
name|cp_error
argument_list|(
literal|"parser lost in parsing declaration of `%D'"
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
block|}
comment|/* If this function is `main', emit a call to `__main'      to run global initializers, etc.  */
if|if
condition|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
operator|&&
name|IDENTIFIER_LENGTH
argument_list|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|==
literal|4
operator|&&
name|strcmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|,
literal|"main"
argument_list|)
operator|==
literal|0
operator|&&
name|DECL_CONTEXT
argument_list|(
name|fndecl
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|expand_main_function
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag_gc
condition|)
name|expand_expr
argument_list|(
name|build_function_call
argument_list|(
name|lookup_name
argument_list|(
name|get_identifier
argument_list|(
literal|"__gc_main"
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_dossier
condition|)
name|output_builtin_tdesc_entries
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Bind a name and initialization to the return value of    the current function.  */
end_comment

begin_function
name|void
name|store_return_init
parameter_list|(
name|return_id
parameter_list|,
name|init
parameter_list|)
name|tree
name|return_id
decl_stmt|,
name|init
decl_stmt|;
block|{
name|tree
name|decl
init|=
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|flag_ansi
condition|)
comment|/* Give this error as many times as there are occurrences,        so that users can use Emacs compilation buffers to find        and fix all such places.  */
name|pedwarn
argument_list|(
literal|"ANSI C++ does not permit named return values"
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_id
operator|!=
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|=
name|return_id
expr_stmt|;
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
operator|=
name|return_id
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"return identifier `%s' already in place"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Can't let this happen for constructors.  */
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|current_function_decl
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"can't redefine default return value for constructors"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If we have a named return value, put that in our scope as well.  */
if|if
condition|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
comment|/* If this named return value comes in a register, 	 put it in a pseudo-register.  */
if|if
condition|(
name|DECL_REGISTER
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|original_result_rtx
operator|=
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|=
name|gen_reg_rtx
argument_list|(
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Let `finish_decl' know that this initializer is ok.  */
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|init
expr_stmt|;
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|decl
argument_list|,
name|init
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Finish up a function declaration and compile that function    all the way to assembler language output.  The free the storage    for the function definition.     This is called after parsing the body of the function definition.    LINENO is the current line number.     C++: CALL_POPLEVEL is non-zero if an extra call to poplevel    (and expand_end_bindings) must be made to take care of the binding    contour for the base initializers.  This is only relevant for    constructors.  */
end_comment

begin_function
name|void
name|finish_function
parameter_list|(
name|lineno
parameter_list|,
name|call_poplevel
parameter_list|)
name|int
name|lineno
decl_stmt|;
name|int
name|call_poplevel
decl_stmt|;
block|{
specifier|register
name|tree
name|fndecl
init|=
name|current_function_decl
decl_stmt|;
name|tree
name|fntype
decl_stmt|,
name|ctype
init|=
name|NULL_TREE
decl_stmt|;
name|rtx
name|head
decl_stmt|,
name|last_parm_insn
decl_stmt|,
name|mark
decl_stmt|;
comment|/* Label to use if this function is supposed to return a value.  */
name|tree
name|no_return_label
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|decls
init|=
name|NULL_TREE
decl_stmt|;
comment|/* When we get some parse errors, we can end up without a      current_function_decl, so cope.  */
if|if
condition|(
name|fndecl
operator|==
name|NULL_TREE
condition|)
return|return;
name|fntype
operator|=
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
comment|/*  TREE_READONLY (fndecl) = 1;     This caused&foo to be of type ptr-to-const-function     which then got a warning when stored in a ptr-to-function variable.  */
comment|/* This happens on strange parse errors.  */
if|if
condition|(
operator|!
name|current_function_parms_stored
condition|)
block|{
name|call_poplevel
operator|=
literal|0
expr_stmt|;
name|store_parm_decls
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|write_symbols
operator|!=
name|NO_DEBUG
operator|&&
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
operator|!=
name|METHOD_TYPE
condition|)
block|{
name|tree
name|ttype
init|=
name|target_type
argument_list|(
name|fntype
argument_list|)
decl_stmt|;
name|tree
name|parmdecl
decl_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|ttype
argument_list|)
condition|)
comment|/* Let debugger know it should output info for this type.  */
name|note_debug_info_needed
argument_list|(
name|ttype
argument_list|)
expr_stmt|;
for|for
control|(
name|parmdecl
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
init|;
name|parmdecl
condition|;
name|parmdecl
operator|=
name|TREE_CHAIN
argument_list|(
name|parmdecl
argument_list|)
control|)
block|{
name|ttype
operator|=
name|target_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|parmdecl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|ttype
argument_list|)
condition|)
comment|/* Let debugger know it should output info for this type.  */
name|note_debug_info_needed
argument_list|(
name|ttype
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Clean house because we will need to reorder insns here.  */
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
if|if
condition|(
name|dtor_label
condition|)
block|{
name|tree
name|binfo
init|=
name|TYPE_BINFO
argument_list|(
name|current_class_type
argument_list|)
decl_stmt|;
name|tree
name|cond
init|=
name|integer_one_node
decl_stmt|;
name|tree
name|exprstmt
decl_stmt|,
name|vfields
decl_stmt|;
name|tree
name|in_charge_node
init|=
name|lookup_name
argument_list|(
name|in_charge_identifier
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|virtual_size
decl_stmt|;
name|int
name|ok_to_optimize_dtor
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|current_function_assigns_this
condition|)
name|cond
operator|=
name|build
argument_list|(
name|NE_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|current_class_decl
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|n_baseclasses
init|=
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|current_class_type
argument_list|)
decl_stmt|;
comment|/* If this destructor is empty, then we don't need to check 	     whether `this' is NULL in some cases.  */
name|mark
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|last_parm_insn
operator|=
name|get_first_nonparm_insn
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|flag_this_is_variable
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
name|ok_to_optimize_dtor
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|mark
operator|==
name|last_parm_insn
condition|)
name|ok_to_optimize_dtor
operator|=
operator|(
name|n_baseclasses
operator|==
literal|0
operator|||
operator|(
name|n_baseclasses
operator|==
literal|1
operator|&&
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|TYPE_BINFO_BASETYPE
argument_list|(
name|current_class_type
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|)
expr_stmt|;
block|}
comment|/* These initializations might go inline.  Protect 	 the binding level of the parms.  */
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|expand_start_bindings
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_function_assigns_this
condition|)
block|{
name|current_function_assigns_this
operator|=
literal|0
expr_stmt|;
name|current_function_just_assigned_this
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Generate the code to call destructor on base class. 	 If this destructor belongs to a class with virtual 	 functions, then set the virtual function table 	 pointer to represent the type of our base class.  */
comment|/* This side-effect makes call to `build_delete' generate the 	 code we have to have at the end of this destructor.  */
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|current_class_type
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* These are two cases where we cannot delegate deletion.  */
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|current_class_type
argument_list|)
operator|||
name|TYPE_GETS_REG_DELETE
argument_list|(
name|current_class_type
argument_list|)
condition|)
name|exprstmt
operator|=
name|build_delete
argument_list|(
name|current_class_type
argument_list|,
name|C_C_D
argument_list|,
name|integer_zero_node
argument_list|,
name|LOOKUP_NONVIRTUAL
operator||
name|LOOKUP_DESTRUCTOR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|exprstmt
operator|=
name|build_delete
argument_list|(
name|current_class_type
argument_list|,
name|C_C_D
argument_list|,
name|in_charge_node
argument_list|,
name|LOOKUP_NONVIRTUAL
operator||
name|LOOKUP_DESTRUCTOR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If we did not assign to this, then `this' is non-zero at 	 the end of a destructor.  As a special optimization, don't 	 emit test if this is an empty destructor.  If it does nothing, 	 it does nothing.  If it calls a base destructor, the base 	 destructor will perform the test.  */
if|if
condition|(
name|exprstmt
operator|!=
name|error_mark_node
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|exprstmt
argument_list|)
operator|!=
name|NOP_EXPR
operator|||
name|TREE_OPERAND
argument_list|(
name|exprstmt
argument_list|,
literal|0
argument_list|)
operator|!=
name|integer_zero_node
operator|||
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|current_class_type
argument_list|)
operator|)
condition|)
block|{
name|expand_label
argument_list|(
name|dtor_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|cond
operator|!=
name|integer_one_node
condition|)
name|expand_start_cond
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|exprstmt
operator|!=
name|void_zero_node
condition|)
comment|/* Don't call `expand_expr_stmt' if we're not going to do 	       anything, since -Wall will give a diagnostic.  */
name|expand_expr_stmt
argument_list|(
name|exprstmt
argument_list|)
expr_stmt|;
comment|/* Run destructor on all virtual baseclasses.  */
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|current_class_type
argument_list|)
condition|)
block|{
name|tree
name|vbases
init|=
name|nreverse
argument_list|(
name|copy_list
argument_list|(
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|current_class_type
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|expand_start_cond
argument_list|(
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|in_charge_node
argument_list|,
name|integer_two_node
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|vbases
condition|)
block|{
if|if
condition|(
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|BINFO_TYPE
argument_list|(
name|vbases
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|ptr
init|=
name|convert_pointer_to_vbase
argument_list|(
name|vbases
argument_list|,
name|current_class_decl
argument_list|)
decl_stmt|;
name|expand_expr_stmt
argument_list|(
name|build_delete
argument_list|(
name|TYPE_POINTER_TO
argument_list|(
name|BINFO_TYPE
argument_list|(
name|vbases
argument_list|)
argument_list|)
argument_list|,
name|ptr
argument_list|,
name|integer_zero_node
argument_list|,
name|LOOKUP_NONVIRTUAL
operator||
name|LOOKUP_DESTRUCTOR
operator||
name|LOOKUP_HAS_IN_CHARGE
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|vbases
operator|=
name|TREE_CHAIN
argument_list|(
name|vbases
argument_list|)
expr_stmt|;
block|}
name|expand_end_cond
argument_list|()
expr_stmt|;
block|}
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
if|if
condition|(
name|cond
operator|!=
name|integer_one_node
condition|)
name|expand_end_cond
argument_list|()
expr_stmt|;
block|}
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|current_class_type
argument_list|)
operator|=
literal|1
expr_stmt|;
name|virtual_size
operator|=
name|c_sizeof
argument_list|(
name|current_class_type
argument_list|)
expr_stmt|;
comment|/* At the end, call delete if that's what's requested.  */
if|if
condition|(
name|TYPE_GETS_REG_DELETE
argument_list|(
name|current_class_type
argument_list|)
condition|)
comment|/* This NOP_EXPR means we are in a static call context.  */
name|exprstmt
operator|=
name|build_method_call
argument_list|(
name|build_indirect_ref
argument_list|(
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|current_class_type
argument_list|)
argument_list|,
name|error_mark_node
argument_list|)
argument_list|,
name|NULL_PTR
argument_list|)
argument_list|,
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|DELETE_EXPR
index|]
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|current_class_decl
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|virtual_size
argument_list|)
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|current_class_type
argument_list|)
condition|)
name|exprstmt
operator|=
name|build_x_delete
argument_list|(
name|ptr_type_node
argument_list|,
name|current_class_decl
argument_list|,
literal|0
argument_list|,
name|virtual_size
argument_list|)
expr_stmt|;
else|else
name|exprstmt
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|exprstmt
condition|)
block|{
name|cond
operator|=
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|in_charge_node
argument_list|,
name|integer_one_node
argument_list|)
expr_stmt|;
name|expand_start_cond
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|exprstmt
argument_list|)
expr_stmt|;
name|expand_end_cond
argument_list|()
expr_stmt|;
block|}
comment|/* End of destructor.  */
name|expand_end_bindings
argument_list|(
name|NULL_TREE
argument_list|,
name|getdecls
argument_list|()
operator|!=
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|poplevel
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* XXX change to 1 */
comment|/* Back to the top of destructor.  */
comment|/* Dont execute destructor code if `this' is NULL.  */
name|mark
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|last_parm_insn
operator|=
name|get_first_nonparm_insn
argument_list|()
expr_stmt|;
if|if
condition|(
name|last_parm_insn
operator|==
name|NULL_RTX
condition|)
name|last_parm_insn
operator|=
name|mark
expr_stmt|;
else|else
name|last_parm_insn
operator|=
name|previous_insn
argument_list|(
name|last_parm_insn
argument_list|)
expr_stmt|;
comment|/* Make all virtual function table pointers in non-virtual base 	 classes point to CURRENT_CLASS_TYPE's virtual function 	 tables.  */
name|expand_direct_vtbls_init
argument_list|(
name|binfo
argument_list|,
name|binfo
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|current_class_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|current_class_type
argument_list|)
condition|)
name|expand_indirect_vtbls_init
argument_list|(
name|binfo
argument_list|,
name|C_C_D
argument_list|,
name|current_class_decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok_to_optimize_dtor
condition|)
block|{
name|cond
operator|=
name|build_binary_op
argument_list|(
name|NE_EXPR
argument_list|,
name|current_class_decl
argument_list|,
name|integer_zero_node
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|expand_start_cond
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mark
operator|!=
name|get_last_insn
argument_list|()
condition|)
name|reorder_insns
argument_list|(
name|next_insn
argument_list|(
name|mark
argument_list|)
argument_list|,
name|get_last_insn
argument_list|()
argument_list|,
name|last_parm_insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok_to_optimize_dtor
condition|)
name|expand_end_cond
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|current_function_assigns_this
condition|)
block|{
comment|/* Does not need to call emit_base_init, because 	 that is done (if needed) just after assignment to this 	 is seen.  */
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|current_function_decl
argument_list|)
condition|)
block|{
name|expand_label
argument_list|(
name|ctor_label
argument_list|)
expr_stmt|;
name|ctor_label
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|call_poplevel
condition|)
block|{
name|decls
operator|=
name|getdecls
argument_list|()
expr_stmt|;
name|expand_end_bindings
argument_list|(
name|decls
argument_list|,
name|decls
operator|!=
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|poplevel
argument_list|(
name|decls
operator|!=
name|NULL_TREE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|c_expand_return
argument_list|(
name|current_class_decl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|void_type_node
operator|&&
name|return_label
operator|!=
name|NULL_RTX
condition|)
name|no_return_label
operator|=
name|build_decl
argument_list|(
name|LABEL_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|current_function_assigns_this
operator|=
literal|0
expr_stmt|;
name|current_function_just_assigned_this
operator|=
literal|0
expr_stmt|;
name|base_init_insns
operator|=
name|NULL_RTX
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
name|tree
name|allocated_this
decl_stmt|;
name|tree
name|cond
decl_stmt|,
name|thenclause
decl_stmt|;
comment|/* Allow constructor for a type to get a new instance of the object 	 using `build_new'.  */
name|tree
name|abstract_virtuals
init|=
name|CLASSTYPE_ABSTRACT_VIRTUALS
argument_list|(
name|current_class_type
argument_list|)
decl_stmt|;
name|CLASSTYPE_ABSTRACT_VIRTUALS
argument_list|(
name|current_class_type
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|DECL_RETURNS_FIRST_ARG
argument_list|(
name|fndecl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|flag_this_is_variable
operator|>
literal|0
condition|)
block|{
name|cond
operator|=
name|build_binary_op
argument_list|(
name|EQ_EXPR
argument_list|,
name|current_class_decl
argument_list|,
name|integer_zero_node
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|thenclause
operator|=
name|build_modify_expr
argument_list|(
name|current_class_decl
argument_list|,
name|NOP_EXPR
argument_list|,
name|build_new
argument_list|(
name|NULL_TREE
argument_list|,
name|current_class_type
argument_list|,
name|void_type_node
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|CLASSTYPE_ABSTRACT_VIRTUALS
argument_list|(
name|current_class_type
argument_list|)
operator|=
name|abstract_virtuals
expr_stmt|;
comment|/* must keep the first insn safe.  */
name|head
operator|=
name|get_insns
argument_list|()
expr_stmt|;
comment|/* this note will come up to the top with us.  */
name|mark
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag_this_is_variable
operator|>
literal|0
condition|)
block|{
name|expand_start_cond
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|thenclause
argument_list|)
expr_stmt|;
name|expand_end_cond
argument_list|()
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|if (DECL_NAME (fndecl) == NULL_TREE&& TREE_CHAIN (DECL_ARGUMENTS (fndecl)) != NULL_TREE) 	build_default_constructor (fndecl);
endif|#
directive|endif
comment|/* Emit insns from `emit_base_init' which sets up virtual 	 function table pointer(s).  */
name|emit_insns
argument_list|(
name|base_init_insns
argument_list|)
expr_stmt|;
name|base_init_insns
operator|=
name|NULL_RTX
expr_stmt|;
comment|/* This is where the body of the constructor begins. 	 If there were no insns in this function body, then the 	 last_parm_insn is also the last insn.  	 If optimization is enabled, last_parm_insn may move, so 	 we don't hold on to it (across emit_base_init).  */
name|last_parm_insn
operator|=
name|get_first_nonparm_insn
argument_list|()
expr_stmt|;
if|if
condition|(
name|last_parm_insn
operator|==
name|NULL_RTX
condition|)
name|last_parm_insn
operator|=
name|mark
expr_stmt|;
else|else
name|last_parm_insn
operator|=
name|previous_insn
argument_list|(
name|last_parm_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|mark
operator|!=
name|get_last_insn
argument_list|()
condition|)
name|reorder_insns
argument_list|(
name|next_insn
argument_list|(
name|mark
argument_list|)
argument_list|,
name|get_last_insn
argument_list|()
argument_list|,
name|last_parm_insn
argument_list|)
expr_stmt|;
comment|/* This is where the body of the constructor ends.  */
name|expand_label
argument_list|(
name|ctor_label
argument_list|)
expr_stmt|;
name|ctor_label
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|call_poplevel
condition|)
block|{
name|expand_end_bindings
argument_list|(
name|decls
operator|=
name|getdecls
argument_list|()
argument_list|,
name|decls
operator|!=
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|poplevel
argument_list|(
name|decls
operator|!=
name|NULL_TREE
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|c_expand_return
argument_list|(
name|current_class_decl
argument_list|)
expr_stmt|;
name|current_function_assigns_this
operator|=
literal|0
expr_stmt|;
name|current_function_just_assigned_this
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IDENTIFIER_LENGTH
argument_list|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|==
literal|4
operator|&&
operator|!
name|strcmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|,
literal|"main"
argument_list|)
operator|&&
name|DECL_CONTEXT
argument_list|(
name|fndecl
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* Make it so that `main' always returns 0 by default.  */
ifdef|#
directive|ifdef
name|VMS
name|c_expand_return
argument_list|(
name|integer_one_node
argument_list|)
expr_stmt|;
else|#
directive|else
name|c_expand_return
argument_list|(
name|integer_zero_node
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|return_label
operator|!=
name|NULL_RTX
operator|&&
name|current_function_return_value
operator|==
name|NULL_TREE
operator|&&
operator|!
name|DECL_NAME
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
condition|)
name|no_return_label
operator|=
name|build_decl
argument_list|(
name|LABEL_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_gc
condition|)
name|expand_gc_prologue_and_epilogue
argument_list|()
expr_stmt|;
comment|/* That's the end of the vtable decl's life.  Need to mark it such      if doing stupid register allocation.       Note that current_vtable_decl is really an INDIRECT_REF      on top of a VAR_DECL here.  */
if|if
condition|(
name|obey_regdecls
operator|&&
name|current_vtable_decl
condition|)
name|use_variable
argument_list|(
name|DECL_RTL
argument_list|(
name|TREE_OPERAND
argument_list|(
name|current_vtable_decl
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this function is supposed to return a value, ensure that      we do not fall into the cleanups by mistake.  The end of our      function will look like this:  	user code (may have return stmt somewhere) 	goto no_return_label 	cleanup_label: 	cleanups 	goto return_label 	no_return_label: 	NOTE_INSN_FUNCTION_END 	return_label: 	things for return       If the user omits a return stmt in the USER CODE section, we      will have a control path which reaches NOTE_INSN_FUNCTION_END.      Otherwise, we won't.  */
if|if
condition|(
name|no_return_label
condition|)
block|{
name|DECL_CONTEXT
argument_list|(
name|no_return_label
argument_list|)
operator|=
name|fndecl
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|no_return_label
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|DECL_SOURCE_FILE
argument_list|(
name|no_return_label
argument_list|)
operator|=
name|input_filename
expr_stmt|;
name|DECL_SOURCE_LINE
argument_list|(
name|no_return_label
argument_list|)
operator|=
name|lineno
expr_stmt|;
name|expand_goto
argument_list|(
name|no_return_label
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cleanup_label
condition|)
block|{
comment|/* remove the binding contour which is used 	 to catch cleanup-generated temporaries.  */
name|expand_end_bindings
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|poplevel
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cleanup_label
condition|)
comment|/* Emit label at beginning of cleanup code for parameters.  */
name|emit_label
argument_list|(
name|cleanup_label
argument_list|)
expr_stmt|;
comment|/* Get return value into register if that's where it's supposed to be.  */
if|if
condition|(
name|original_result_rtx
condition|)
name|fixup_result_decl
argument_list|(
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
argument_list|,
name|original_result_rtx
argument_list|)
expr_stmt|;
comment|/* Finish building code that will trigger warnings if users forget      to make their functions return values.  */
if|if
condition|(
name|no_return_label
operator|||
name|cleanup_label
condition|)
name|emit_jump
argument_list|(
name|return_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|no_return_label
condition|)
block|{
comment|/* We don't need to call `expand_*_return' here because we 	 don't need any cleanups here--this path of code is only 	 for error checking purposes.  */
name|expand_label
argument_list|(
name|no_return_label
argument_list|)
expr_stmt|;
block|}
comment|/* reset scope for C++: if we were in the scope of a class,      then when we finish this function, we are not longer so.      This cannot be done until we know for sure that no more      class members will ever be referenced in this function      (i.e., calls to destructors).  */
if|if
condition|(
name|current_class_name
condition|)
block|{
name|ctype
operator|=
name|current_class_type
expr_stmt|;
name|pop_nested_class
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|pop_memoized_context
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Generate rtl for function exit.  */
name|expand_function_end
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_handle_exceptions
condition|)
name|expand_exception_blocks
argument_list|()
expr_stmt|;
comment|/* This must come after expand_function_end because cleanups might      have declarations (from inline functions) that need to go into      this function's blocks.  */
if|if
condition|(
name|current_binding_level
operator|->
name|parm_flag
operator|!=
literal|1
condition|)
name|my_friendly_abort
argument_list|(
literal|122
argument_list|)
expr_stmt|;
name|poplevel
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Must mark the RESULT_DECL as being in this function.  */
name|DECL_CONTEXT
argument_list|(
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|=
name|DECL_INITIAL
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
comment|/* Obey `register' declarations if `setjmp' is called in this fn.  */
if|if
condition|(
name|flag_traditional
operator|&&
name|current_function_calls_setjmp
condition|)
name|setjmp_protect
argument_list|(
name|DECL_INITIAL
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set the BLOCK_SUPERCONTEXT of the outermost function scope to point      to the FUNCTION_DECL node itself.  */
name|BLOCK_SUPERCONTEXT
argument_list|(
name|DECL_INITIAL
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|=
name|fndecl
expr_stmt|;
comment|/* So we can tell if jump_optimize sets it to 1.  */
name|can_reach_end
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|fndecl
argument_list|)
comment|/* This function is just along for the ride.  If we can make 	 it inline, that's great.  Otherwise, just punt it.  */
operator|&&
operator|(
name|DECL_INLINE
argument_list|(
name|fndecl
argument_list|)
operator|==
literal|0
operator|||
name|flag_no_inline
operator|||
name|function_cannot_inline_p
argument_list|(
name|fndecl
argument_list|)
comment|/* ??? Compensate for Sun brain damage in dealing with 	     data segments of PIC code.  */
operator|||
operator|(
name|flag_pic
operator|&&
operator|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|fndecl
argument_list|)
operator|||
name|DESTRUCTOR_NAME_P
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|)
operator|&&
name|CLASSTYPE_NEEDS_VIRTUAL_REINIT
argument_list|(
name|TYPE_METHOD_BASETYPE
argument_list|(
name|fntype
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
block|{
specifier|extern
name|int
name|rtl_dump_and_exit
decl_stmt|;
name|int
name|old_rtl_dump_and_exit
init|=
name|rtl_dump_and_exit
decl_stmt|;
name|int
name|inline_spec
init|=
name|DECL_INLINE
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
comment|/* This throws away the code for FNDECL.  */
name|rtl_dump_and_exit
operator|=
literal|1
expr_stmt|;
comment|/* This throws away the memory of the code for FNDECL.  */
if|if
condition|(
name|flag_no_inline
condition|)
name|DECL_INLINE
argument_list|(
name|fndecl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|rest_of_compilation
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|rtl_dump_and_exit
operator|=
name|old_rtl_dump_and_exit
expr_stmt|;
name|DECL_INLINE
argument_list|(
name|fndecl
argument_list|)
operator|=
name|inline_spec
expr_stmt|;
block|}
else|else
block|{
comment|/* Run the optimizers and output the assembler code for this          function.  */
name|rest_of_compilation
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_INLINE
argument_list|(
name|fndecl
argument_list|)
operator|&&
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|fndecl
argument_list|)
operator|&&
name|DECL_DEFER_OUTPUT
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
name|mark_inline_for_output
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ctype
operator|&&
name|TREE_ASM_WRITTEN
argument_list|(
name|fndecl
argument_list|)
condition|)
name|note_debug_info_needed
argument_list|(
name|ctype
argument_list|)
expr_stmt|;
name|current_function_returns_null
operator||=
name|can_reach_end
expr_stmt|;
comment|/* Since we don't normally go through c_expand_return for constructors,      this normally gets the wrong value.      Also, named return values have their return codes emitted after      NOTE_INSN_FUNCTION_END, confusing jump.c.  */
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|fndecl
argument_list|)
operator|||
name|DECL_NAME
argument_list|(
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|current_function_returns_null
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|fndecl
argument_list|)
operator|&&
name|current_function_returns_null
condition|)
name|cp_warning
argument_list|(
literal|"`noreturn' function `%D' does return"
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|warn_return_type
operator|||
name|pedantic
operator|)
operator|&&
name|current_function_returns_null
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|)
operator|!=
name|void_type_node
condition|)
block|{
comment|/* If this function returns non-void and control can drop through, 	 complain.  */
name|cp_pedwarn
argument_list|(
literal|"control reaches end of non-void function `%D'"
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
block|}
comment|/* With just -W, complain only if function returns both with      and without a value.  */
elseif|else
if|if
condition|(
name|extra_warnings
operator|&&
name|current_function_returns_value
operator|&&
name|current_function_returns_null
condition|)
name|warning
argument_list|(
literal|"this function may return with or without a value"
argument_list|)
expr_stmt|;
comment|/* Free all the tree nodes making up this function.  */
comment|/* Switch back to allocating nodes permanently      until we start another function.  */
name|permanent_allocation
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_cadillac
condition|)
name|cadillac_finish_function
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_SAVED_INSNS
argument_list|(
name|fndecl
argument_list|)
operator|==
name|NULL_RTX
condition|)
block|{
comment|/* Stop pointing to the local nodes about to be freed.  */
comment|/* But DECL_INITIAL must remain nonzero so we know this 	 was an actual function definition.  */
name|DECL_INITIAL
argument_list|(
name|fndecl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_CONSTRUCTOR_P
argument_list|(
name|fndecl
argument_list|)
operator|||
operator|!
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|TYPE_METHOD_BASETYPE
argument_list|(
name|fntype
argument_list|)
argument_list|)
condition|)
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
comment|/* Let the error reporting routines know that we're outside a function.  */
name|current_function_decl
operator|=
name|NULL_TREE
expr_stmt|;
name|named_label_uses
operator|=
name|NULL_TREE
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create the FUNCTION_DECL for a function definition.    LINE1 is the line number that the definition absolutely begins on.    LINE2 is the line number that the name of the function appears on.    DECLSPECS and DECLARATOR are the parts of the declaration;    they describe the return type and the name of the function,    but twisted together in a fashion that parallels the syntax of C.     This function creates a binding context for the function body    as well as setting up the FUNCTION_DECL in current_function_decl.     Returns a FUNCTION_DECL on success.     If the DECLARATOR is not suitable for a function (it defines a datum    instead), we return 0, which tells yyparse to report a parse error.     May return void_type_node indicating that this method is actually    a friend.  See grokfield for more details.     Came here with a `.pushlevel' .     DO NOT MAKE ANY CHANGES TO THIS CODE WITHOUT MAKING CORRESPONDING    CHANGES TO CODE IN `grokfield'.  */
end_comment

begin_function
name|tree
name|start_method
parameter_list|(
name|declspecs
parameter_list|,
name|declarator
parameter_list|,
name|raises
parameter_list|)
name|tree
name|declarator
decl_stmt|,
name|declspecs
decl_stmt|,
name|raises
decl_stmt|;
block|{
name|tree
name|fndecl
init|=
name|grokdeclarator
argument_list|(
name|declarator
argument_list|,
name|declspecs
argument_list|,
name|MEMFUNCDEF
argument_list|,
literal|0
argument_list|,
name|raises
argument_list|)
decl_stmt|;
comment|/* Something too ugly to handle.  */
if|if
condition|(
name|fndecl
operator|==
name|NULL_TREE
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Pass friends other than inline friend functions back.  */
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|fndecl
argument_list|)
operator|==
name|void_type_node
condition|)
return|return
name|fndecl
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fndecl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
comment|/* Not a function, tell parser to report parse error.  */
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|IS_SIGNATURE
argument_list|(
name|current_class_type
argument_list|)
condition|)
block|{
name|IS_DEFAULT_IMPLEMENTATION
argument_list|(
name|fndecl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* In case we need this info later.  */
name|HAS_DEFAULT_IMPLEMENTATION
argument_list|(
name|current_class_type
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|DECL_IN_AGGR_P
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
if|if
condition|(
name|IDENTIFIER_ERROR_LOCUS
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|!=
name|current_class_type
condition|)
block|{
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|fndecl
argument_list|)
condition|)
name|cp_error
argument_list|(
literal|"`%D' is already defined in class %s"
argument_list|,
name|fndecl
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|void_type_node
return|;
block|}
if|if
condition|(
name|flag_default_inline
condition|)
name|DECL_INLINE
argument_list|(
name|fndecl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|processing_template_defn
condition|)
name|SET_DECL_IMPLICIT_INSTANTIATION
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
comment|/* We read in the parameters on the maybepermanent_obstack,      but we won't be getting back to them until after we      may have clobbered them.  So the call to preserve_data      will keep them safe.  */
name|preserve_data
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_FRIEND_P
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_CHAIN
argument_list|(
name|fndecl
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
comment|/* Need a fresh node here so that we don't get circularity 	     when we link these together.  If FNDECL was a friend, then 	     `pushdecl' does the right thing, which is nothing wrt its 	     current value of DECL_CHAIN.  */
name|fndecl
operator|=
name|copy_node
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
name|fndecl
operator|=
name|copy_node
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|fndecl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|grok_ctor_properties
argument_list|(
name|current_class_type
argument_list|,
name|fndecl
argument_list|)
condition|)
return|return
name|void_type_node
return|;
block|}
elseif|else
if|if
condition|(
name|IDENTIFIER_OPNAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
condition|)
name|grok_op_properties
argument_list|(
name|fndecl
argument_list|,
name|DECL_VIRTUAL_P
argument_list|(
name|fndecl
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|finish_decl
argument_list|(
name|fndecl
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Make a place for the parms */
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|current_binding_level
operator|->
name|parm_flag
operator|=
literal|1
expr_stmt|;
name|DECL_IN_AGGR_P
argument_list|(
name|fndecl
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|fndecl
return|;
block|}
end_function

begin_comment
comment|/* Go through the motions of finishing a function definition.    We don't compile this method until after the whole class has    been processed.     FINISH_METHOD must return something that looks as though it    came from GROKFIELD (since we are defining a method, after all).     This is called after parsing the body of the function definition.    STMTS is the chain of statements that makes up the function body.     DECL is the ..._DECL that `start_method' provided.  */
end_comment

begin_function
name|tree
name|finish_method
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
specifier|register
name|tree
name|fndecl
init|=
name|decl
decl_stmt|;
name|tree
name|old_initial
decl_stmt|;
specifier|register
name|tree
name|link
decl_stmt|;
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|decl
argument_list|)
operator|==
name|void_type_node
condition|)
return|return
name|decl
return|;
name|old_initial
operator|=
name|DECL_INITIAL
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
comment|/* Undo the level for the parms (from start_method).      This is like poplevel, but it causes nothing to be      saved.  Saving information here confuses symbol-table      output routines.  Besides, this information will      be correctly output when this method is actually      compiled.  */
comment|/* Clear out the meanings of the local variables of this level;      also record in each decl which block it belongs to.  */
for|for
control|(
name|link
operator|=
name|current_binding_level
operator|->
name|names
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|link
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|link
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|link
argument_list|)
operator|!=
name|FUNCTION_DECL
argument_list|,
literal|163
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|link
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
comment|/* Restore all name-meanings of the outer levels      that were shadowed by this level.  */
for|for
control|(
name|link
operator|=
name|current_binding_level
operator|->
name|shadowed
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
expr_stmt|;
for|for
control|(
name|link
operator|=
name|current_binding_level
operator|->
name|class_shadowed
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
expr_stmt|;
for|for
control|(
name|link
operator|=
name|current_binding_level
operator|->
name|type_shadowed
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
expr_stmt|;
name|GNU_xref_end_scope
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|)
name|current_binding_level
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
name|current_binding_level
operator|->
name|level_chain
argument_list|,
name|current_binding_level
operator|->
name|parm_flag
argument_list|,
name|current_binding_level
operator|->
name|keep
argument_list|,
name|current_binding_level
operator|->
name|tag_transparent
argument_list|)
expr_stmt|;
name|poplevel
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|fndecl
argument_list|)
operator|=
name|old_initial
expr_stmt|;
comment|/* We used to check if the context of FNDECL was different from      current_class_type as another way to get inside here.  This didn't work      for String.cc in libg++.  */
if|if
condition|(
name|DECL_FRIEND_P
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
name|CLASSTYPE_INLINE_FRIENDS
argument_list|(
name|current_class_type
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|fndecl
argument_list|,
name|CLASSTYPE_INLINE_FRIENDS
argument_list|(
name|current_class_type
argument_list|)
argument_list|)
expr_stmt|;
name|decl
operator|=
name|void_type_node
expr_stmt|;
block|}
return|return
name|decl
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Called when a new struct TYPE is defined.    If this structure or union completes the type of any previous    variable declaration, lay it out and output its rtl.  */
end_comment

begin_function
name|void
name|hack_incomplete_structures
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|decl
decl_stmt|;
if|if
condition|(
name|current_binding_level
operator|->
name|n_incomplete
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
operator|!
name|type
condition|)
comment|/* Don't do this for class templates.  */
return|return;
for|for
control|(
name|decl
operator|=
name|current_binding_level
operator|->
name|names
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|==
name|type
operator|||
operator|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|type
operator|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|layout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|toplevel
init|=
name|global_binding_level
operator|==
name|current_binding_level
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|type
condition|)
name|layout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|layout_decl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rest_of_decl_compilation
argument_list|(
name|decl
argument_list|,
name|NULL_PTR
argument_list|,
name|toplevel
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|toplevel
condition|)
block|{
name|tree
name|cleanup
decl_stmt|;
name|expand_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|cleanup
operator|=
name|maybe_build_cleanup
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|expand_decl_init
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|expand_decl_cleanup
argument_list|(
name|decl
argument_list|,
name|cleanup
argument_list|)
condition|)
name|cp_error
argument_list|(
literal|"parser lost in parsing declaration of `%D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
name|my_friendly_assert
argument_list|(
name|current_binding_level
operator|->
name|n_incomplete
operator|>
literal|0
argument_list|,
literal|164
argument_list|)
expr_stmt|;
operator|--
name|current_binding_level
operator|->
name|n_incomplete
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Nonzero if presently building a cleanup.  Needed because    SAVE_EXPRs are not the right things to use inside of cleanups.    They are only ever evaluated once, where the cleanup    might be evaluated several times.  In this case, a later evaluation    of the cleanup might fill in the SAVE_EXPR_RTL, and it will    not be valid for an earlier cleanup.  */
end_comment

begin_decl_stmt
name|int
name|building_cleanup
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If DECL is of a type which needs a cleanup, build that cleanup here.    We don't build cleanups if just going for syntax checking, since    fixup_cleanups does not know how to not handle them.     Don't build these on the momentary obstack; they must live    the life of the binding contour.  */
end_comment

begin_function
name|tree
name|maybe_build_cleanup
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|int
name|temp
init|=
literal|0
decl_stmt|,
name|flags
init|=
name|LOOKUP_NORMAL
operator||
name|LOOKUP_DESTRUCTOR
decl_stmt|;
name|tree
name|rval
decl_stmt|;
name|int
name|old_building_cleanup
init|=
name|building_cleanup
decl_stmt|;
name|building_cleanup
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|PARM_DECL
condition|)
name|temp
operator|=
name|suspend_momentary
argument_list|()
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|rval
operator|=
name|decl
expr_stmt|;
else|else
block|{
name|mark_addressable
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|rval
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Optimize for space over speed here.  */
if|if
condition|(
operator|!
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|type
argument_list|)
operator|||
name|flag_expensive_optimizations
condition|)
name|flags
operator||=
name|LOOKUP_NONVIRTUAL
expr_stmt|;
comment|/* Use TYPE_MAIN_VARIANT so we don't get a warning about 	 calling delete on a `const' variable.  */
if|if
condition|(
name|TYPE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|rval
argument_list|)
argument_list|)
argument_list|)
condition|)
name|rval
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|rval
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|rval
argument_list|)
expr_stmt|;
name|rval
operator|=
name|build_delete
argument_list|(
name|TREE_TYPE
argument_list|(
name|rval
argument_list|)
argument_list|,
name|rval
argument_list|,
name|integer_two_node
argument_list|,
name|flags
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
name|rval
operator|=
name|build_compound_expr
argument_list|(
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|rval
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|build_vbase_delete
argument_list|(
name|type
argument_list|,
name|decl
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|PARM_DECL
condition|)
name|resume_momentary
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|building_cleanup
operator|=
name|old_building_cleanup
expr_stmt|;
return|return
name|rval
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Expand a C++ expression at the statement level.    This is needed to ferret out nodes which have UNKNOWN_TYPE.    The C++ type checker should get all of these out when    expressions are combined with other, type-providing, expressions,    leaving only orphan expressions, such as:&class::bar;		/ / takes its address, but does nothing with it.     */
end_comment

begin_function
name|void
name|cplus_expand_expr_stmt
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
operator|==
name|unknown_type_node
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|ADDR_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|error
argument_list|(
literal|"address of overloaded function with no contextual type information"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
name|warning
argument_list|(
literal|"useless reference to a member function name, did you forget the ()?"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|remove_implicit_immediately
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|cp_warning
argument_list|(
literal|"reference, not call, to function `%D'"
argument_list|,
name|exp
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"at this point in file"
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* We should do this eventually, but right now this causes regex.o from 	 libg++ to miscompile, and tString to core dump.  */
block|exp = build1 (CLEANUP_POINT_EXPR, TREE_TYPE (exp), exp);
endif|#
directive|endif
name|expand_expr_stmt
argument_list|(
name|break_out_cleanups
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Clean up any pending cleanups.  This happens when a function call      returns a cleanup-needing value that nobody uses.  */
name|expand_cleanups_to
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* When a stmt has been parsed, this function is called.     Currently, this function only does something within a    constructor's scope: if a stmt has just assigned to this,    and we are in a derived class, we call `emit_base_init'.  */
end_comment

begin_function
name|void
name|finish_stmt
parameter_list|()
block|{
specifier|extern
name|struct
name|nesting
modifier|*
name|cond_stack
decl_stmt|,
modifier|*
name|loop_stack
decl_stmt|,
modifier|*
name|case_stack
decl_stmt|;
if|if
condition|(
name|current_function_assigns_this
operator|||
operator|!
name|current_function_just_assigned_this
condition|)
return|return;
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|current_function_decl
argument_list|)
condition|)
block|{
comment|/* Constructors must wait until we are out of control 	 zones before calling base constructors.  */
if|if
condition|(
name|cond_stack
operator|||
name|loop_stack
operator|||
name|case_stack
condition|)
return|return;
name|emit_insns
argument_list|(
name|base_init_insns
argument_list|)
expr_stmt|;
name|check_base_init
argument_list|(
name|current_class_type
argument_list|)
expr_stmt|;
block|}
name|current_function_assigns_this
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|flag_cadillac
condition|)
name|cadillac_finish_stmt
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Change a static member function definition into a FUNCTION_TYPE, instead    of the METHOD_TYPE that we create when it's originally parsed.     WARNING: DO NOT pass&TREE_TYPE (decl) to FN or&TYPE_ARG_TYPES    (TREE_TYPE (decl)) to ARGTYPES, as doing so will corrupt the types of    other decls.  Either pass the addresses of local variables or NULL.  */
end_comment

begin_function
name|void
name|revert_static_member_fn
parameter_list|(
name|decl
parameter_list|,
name|fn
parameter_list|,
name|argtypes
parameter_list|)
name|tree
modifier|*
name|decl
decl_stmt|,
decl|*
name|fn
decl_stmt|,
modifier|*
name|argtypes
decl_stmt|;
end_function

begin_block
block|{
name|tree
name|tmp
decl_stmt|;
name|tree
name|function
init|=
name|fn
condition|?
operator|*
name|fn
else|:
name|TREE_TYPE
argument_list|(
operator|*
name|decl
argument_list|)
decl_stmt|;
name|tree
name|args
init|=
name|argtypes
condition|?
operator|*
name|argtypes
else|:
name|TYPE_ARG_TYPES
argument_list|(
name|function
argument_list|)
decl_stmt|;
name|args
operator|=
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|build_function_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|build_type_variant
argument_list|(
name|tmp
argument_list|,
name|TYPE_READONLY
argument_list|(
name|function
argument_list|)
argument_list|,
name|TYPE_VOLATILE
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|build_exception_variant
argument_list|(
name|TYPE_METHOD_BASETYPE
argument_list|(
name|function
argument_list|)
argument_list|,
name|tmp
argument_list|,
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
operator|*
name|decl
argument_list|)
operator|=
name|tmp
expr_stmt|;
name|DECL_STATIC_FUNCTION_P
argument_list|(
operator|*
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|fn
condition|)
operator|*
name|fn
operator|=
name|tmp
expr_stmt|;
if|if
condition|(
name|argtypes
condition|)
operator|*
name|argtypes
operator|=
name|args
expr_stmt|;
block|}
end_block

begin_function
name|int
name|id_in_current_class
parameter_list|(
name|id
parameter_list|)
name|tree
name|id
decl_stmt|;
block|{
return|return
operator|!
operator|!
name|purpose_member
argument_list|(
name|id
argument_list|,
name|class_binding_level
operator|->
name|class_shadowed
argument_list|)
return|;
block|}
end_function

end_unit

