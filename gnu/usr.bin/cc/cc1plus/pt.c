begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Handle parameterized types (templates) for GNU C++.    Copyright (C) 1992, 1993 Free Software Foundation, Inc.    Written by Ken Raeburn (raeburn@cygnus.com) while at Watchmaker Computing.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* Known bugs or deficiencies include:    * templates for class static data don't work (methods only)    * duplicated method templates can crash the compiler    * interface/impl data is taken from file defining the template    * all methods must be provided in header files; can't use a source      file that contains only the method templates and "just win"    * method templates must be seen before the expansion of the      class template is done  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"decl.h"
end_include

begin_include
include|#
directive|include
file|"parse.h"
end_include

begin_include
include|#
directive|include
file|"lex.h"
end_include

begin_decl_stmt
specifier|extern
name|struct
name|obstack
name|permanent_obstack
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|tree
name|grokdeclarator
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|int
name|lineno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|input_filename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pending_inline
modifier|*
name|pending_template_expansions
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|processing_template_decl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|processing_template_defn
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_function_decl
specifier|static
name|int
name|unify
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_pending_template
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|void
name|overload_template_name
argument_list|()
decl_stmt|,
name|pop_template_decls
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We've got a template header coming up; set obstacks up to save the    nodes created permanently.  (There might be cases with nested templates    where we don't have to do this, but they aren't implemented, and it    probably wouldn't be worth the effort.)  */
end_comment

begin_function
name|void
name|begin_template_parm_list
parameter_list|()
block|{
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|push_obstacks
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|&
name|permanent_obstack
argument_list|)
expr_stmt|;
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Process information from new template parameter NEXT and append it to the    LIST being built.  The rules for use of a template parameter type name    by later parameters are not well-defined for us just yet.  However, the    only way to avoid having to parse expressions of unknown complexity (and    with tokens of unknown types) is to disallow it completely.	So for now,    that is what is assumed.  */
end_comment

begin_function
name|tree
name|process_template_parm
parameter_list|(
name|list
parameter_list|,
name|next
parameter_list|)
name|tree
name|list
decl_stmt|,
name|next
decl_stmt|;
block|{
name|tree
name|parm
decl_stmt|;
name|tree
name|decl
init|=
literal|0
decl_stmt|;
name|int
name|is_type
decl_stmt|;
name|parm
operator|=
name|next
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|TREE_LIST
argument_list|,
literal|259
argument_list|)
expr_stmt|;
name|is_type
operator|=
name|TREE_CODE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
expr_stmt|;
if|if
condition|(
operator|!
name|is_type
condition|)
block|{
name|tree
name|tinfo
init|=
literal|0
decl_stmt|;
name|parm
operator|=
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|TREE_LIST
argument_list|,
literal|260
argument_list|)
expr_stmt|;
name|parm
operator|=
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
expr_stmt|;
comment|/* is a const-param */
name|parm
operator|=
name|grokdeclarator
argument_list|(
name|TREE_VALUE
argument_list|(
name|next
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|next
argument_list|)
argument_list|,
name|PARM
argument_list|,
literal|0
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* A template parameter is not modifiable.  */
name|TREE_READONLY
argument_list|(
name|parm
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
name|sorry
argument_list|(
literal|"aggregate template parameter types"
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
operator|=
name|void_type_node
expr_stmt|;
block|}
name|tinfo
operator|=
name|make_node
argument_list|(
name|TEMPLATE_CONST_PARM
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_PERMANENT
argument_list|(
name|tinfo
argument_list|)
argument_list|,
literal|260.5
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_PERMANENT
argument_list|(
name|parm
argument_list|)
operator|==
literal|0
condition|)
block|{
name|parm
operator|=
name|copy_node
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|TREE_PERMANENT
argument_list|(
name|parm
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|TREE_TYPE
argument_list|(
name|tinfo
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|CONST_DECL
argument_list|,
name|DECL_NAME
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|tinfo
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|parm
argument_list|)
operator|=
name|tinfo
expr_stmt|;
block|}
else|else
block|{
name|tree
name|t
init|=
name|make_node
argument_list|(
name|TEMPLATE_TYPE_PARM
argument_list|)
decl_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
operator|=
name|decl
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
operator|=
name|t
expr_stmt|;
block|}
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
return|return
name|chainon
argument_list|(
name|list
argument_list|,
name|parm
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The end of a template parameter list has been reached.  Process the    tree list into a parameter vector, converting each parameter into a more    useful form.	 Type parameters are saved as IDENTIFIER_NODEs, and others    as PARM_DECLs.  */
end_comment

begin_function
name|tree
name|end_template_parm_list
parameter_list|(
name|parms
parameter_list|)
name|tree
name|parms
decl_stmt|;
block|{
name|int
name|nparms
init|=
literal|0
decl_stmt|;
name|tree
name|saved_parmlist
decl_stmt|;
name|tree
name|parm
decl_stmt|;
for|for
control|(
name|parm
operator|=
name|parms
init|;
name|parm
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
control|)
name|nparms
operator|++
expr_stmt|;
name|saved_parmlist
operator|=
name|make_tree_vec
argument_list|(
name|nparms
argument_list|)
expr_stmt|;
for|for
control|(
name|parm
operator|=
name|parms
operator|,
name|nparms
operator|=
literal|0
init|;
name|parm
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
operator|,
name|nparms
operator|++
control|)
block|{
name|tree
name|p
init|=
name|parm
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
name|tree
name|t
init|=
name|TREE_VALUE
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|TREE_VALUE
argument_list|(
name|p
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|p
operator|=
name|TREE_PURPOSE
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|IDENTIFIER_NODE
argument_list|,
literal|261
argument_list|)
expr_stmt|;
name|TEMPLATE_TYPE_SET_INFO
argument_list|(
name|t
argument_list|,
name|saved_parmlist
argument_list|,
name|nparms
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|tinfo
init|=
name|DECL_INITIAL
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|DECL_INITIAL
argument_list|(
name|p
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|TEMPLATE_CONST_SET_INFO
argument_list|(
name|tinfo
argument_list|,
name|saved_parmlist
argument_list|,
name|nparms
argument_list|)
expr_stmt|;
block|}
name|TREE_VEC_ELT
argument_list|(
name|saved_parmlist
argument_list|,
name|nparms
argument_list|)
operator|=
name|p
expr_stmt|;
block|}
name|set_current_level_tags_transparency
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|processing_template_decl
operator|++
expr_stmt|;
return|return
name|saved_parmlist
return|;
block|}
end_function

begin_comment
comment|/* end_template_decl is called after a template declaration is seen.    D1 is template header; D2 is class_head_sans_basetype or a    TEMPLATE_DECL with its DECL_RESULT field set.  */
end_comment

begin_function
name|void
name|end_template_decl
parameter_list|(
name|d1
parameter_list|,
name|d2
parameter_list|,
name|is_class
parameter_list|,
name|defn
parameter_list|)
name|tree
name|d1
decl_stmt|,
name|d2
decl_stmt|,
name|is_class
decl_stmt|;
name|int
name|defn
decl_stmt|;
block|{
name|tree
name|decl
decl_stmt|;
name|struct
name|template_info
modifier|*
name|tmpl
decl_stmt|;
name|tmpl
operator|=
operator|(
expr|struct
name|template_info
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|template_info
argument_list|)
argument_list|)
expr_stmt|;
name|tmpl
operator|->
name|text
operator|=
literal|0
expr_stmt|;
name|tmpl
operator|->
name|length
operator|=
literal|0
expr_stmt|;
name|tmpl
operator|->
name|aggr
operator|=
name|is_class
expr_stmt|;
comment|/* cloned from reinit_parse_for_template */
name|tmpl
operator|->
name|filename
operator|=
name|input_filename
expr_stmt|;
name|tmpl
operator|->
name|lineno
operator|=
name|lineno
expr_stmt|;
name|tmpl
operator|->
name|parm_vec
operator|=
name|d1
expr_stmt|;
comment|/* [eichin:19911015.2306EST] */
if|if
condition|(
name|d2
operator|==
name|NULL_TREE
operator|||
name|d2
operator|==
name|error_mark_node
condition|)
block|{
name|decl
operator|=
literal|0
expr_stmt|;
goto|goto
name|lose
goto|;
block|}
if|if
condition|(
name|is_class
condition|)
block|{
name|decl
operator|=
name|build_lang_decl
argument_list|(
name|TEMPLATE_DECL
argument_list|,
name|d2
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|GNU_xref_decl
argument_list|(
name|current_function_decl
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|d2
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
name|decl
operator|=
name|d2
expr_stmt|;
else|else
block|{
comment|/* Class destructor templates and operator templates are 	     slipping past as non-template nodes.  Process them here, since 	     I haven't figured out where to catch them earlier.  I could 	     go do that, but it's a choice between getting that done and 	     staying only N months behind schedule.  Sorry....  */
name|enum
name|tree_code
name|code
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|d2
argument_list|)
operator|==
name|CALL_EXPR
argument_list|,
literal|263
argument_list|)
expr_stmt|;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|d2
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|code
operator|==
name|BIT_NOT_EXPR
operator|||
name|code
operator|==
name|OP_IDENTIFIER
operator|||
name|code
operator|==
name|SCOPE_REF
argument_list|,
literal|264
argument_list|)
expr_stmt|;
name|d2
operator|=
name|grokdeclarator
argument_list|(
name|d2
argument_list|,
name|NULL_TREE
argument_list|,
name|MEMFUNCDEF
argument_list|,
literal|0
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_lang_decl
argument_list|(
name|TEMPLATE_DECL
argument_list|,
name|DECL_NAME
argument_list|(
name|d2
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|d2
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_TEMPLATE_RESULT
argument_list|(
name|decl
argument_list|)
operator|=
name|d2
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|DECL_CONTEXT
argument_list|(
name|d2
argument_list|)
expr_stmt|;
name|DECL_CLASS_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|DECL_CLASS_CONTEXT
argument_list|(
name|d2
argument_list|)
expr_stmt|;
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|=
name|DECL_NAME
argument_list|(
name|d2
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|d2
argument_list|)
expr_stmt|;
if|if
condition|(
name|interface_unknown
operator|&&
name|flag_external_templates
operator|&&
operator|!
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|decl
argument_list|)
condition|)
name|warn_if_unknown_interface
argument_list|()
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
name|TREE_PUBLIC
argument_list|(
name|d2
argument_list|)
operator|=
name|flag_external_templates
operator|&&
operator|!
name|interface_unknown
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
operator|(
name|DECL_EXTERNAL
argument_list|(
name|d2
argument_list|)
operator|&&
operator|!
operator|(
name|DECL_CLASS_CONTEXT
argument_list|(
name|d2
argument_list|)
operator|&&
operator|!
name|DECL_THIS_EXTERN
argument_list|(
name|d2
argument_list|)
operator|)
operator|)
expr_stmt|;
block|}
comment|/* All routines creating TEMPLATE_DECL nodes should now be using 	 build_lang_decl, which will have set this up already.	*/
name|my_friendly_assert
argument_list|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
argument_list|,
literal|265
argument_list|)
expr_stmt|;
comment|/* @@ Somewhere, permanent allocation isn't being used.  */
if|if
condition|(
operator|!
name|DECL_TEMPLATE_IS_CLASS
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|tree
name|result
init|=
name|DECL_TEMPLATE_RESULT
argument_list|(
name|decl
argument_list|)
decl_stmt|;
comment|/* Will do nothing if allocation was already permanent.  */
name|DECL_ARGUMENTS
argument_list|(
name|result
argument_list|)
operator|=
name|copy_to_permanent
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If this is for a method, there's an extra binding level here.	*/
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
comment|/* @@ Find out where this should be getting set!  */
name|tree
name|r
init|=
name|DECL_TEMPLATE_RESULT
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|r
argument_list|)
operator|&&
name|DECL_CLASS_CONTEXT
argument_list|(
name|r
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|DECL_CLASS_CONTEXT
argument_list|(
name|r
argument_list|)
operator|=
name|DECL_CONTEXT
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
block|}
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
operator|=
name|tmpl
expr_stmt|;
name|DECL_TEMPLATE_PARMS
argument_list|(
name|decl
argument_list|)
operator|=
name|d1
expr_stmt|;
comment|/* So that duplicate_decls can do the right thing.  */
if|if
condition|(
name|defn
condition|)
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
comment|/* If context of decl is non-null (i.e., method template), add it      to the appropriate class template, and pop the binding levels.  */
if|if
condition|(
operator|!
name|is_class
operator|&&
name|DECL_CONTEXT
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
name|tree
name|ctx
init|=
name|DECL_CONTEXT
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|tmpl
decl_stmt|,
name|t
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|ctx
argument_list|)
operator|==
name|UNINSTANTIATED_P_TYPE
argument_list|,
literal|266
argument_list|)
expr_stmt|;
name|tmpl
operator|=
name|UPT_TEMPLATE
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|DECL_TEMPLATE_MEMBERS
argument_list|(
name|tmpl
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
operator|==
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|&&
name|duplicate_decls
argument_list|(
name|decl
argument_list|,
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
goto|goto
name|already_there
goto|;
name|DECL_TEMPLATE_MEMBERS
argument_list|(
name|tmpl
argument_list|)
operator|=
name|perm_tree_cons
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
name|decl
argument_list|,
name|DECL_TEMPLATE_MEMBERS
argument_list|(
name|tmpl
argument_list|)
argument_list|)
expr_stmt|;
name|already_there
label|:
name|poplevel
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|poplevel
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Otherwise, go back to top level first, and push the template decl      again there.  */
else|else
block|{
name|poplevel
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|poplevel
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
name|lose
label|:
if|#
directive|if
literal|0
comment|/* It happens sometimes, with syntactic or semantic errors.  	 One specific case: 	 template<class A, int X, int Y> class Foo { ... }; 	 template<class A, int X, int y> Foo<X,Y>::method (Foo& x) { ... } 	 Note the missing "A" in the class containing "method".  */
block|my_friendly_assert (global_bindings_p (), 267);
else|#
directive|else
while|while
condition|(
operator|!
name|global_bindings_p
argument_list|()
condition|)
name|poplevel
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pop_obstacks
argument_list|()
expr_stmt|;
name|processing_template_decl
operator|--
expr_stmt|;
operator|(
name|void
operator|)
name|get_pending_sizes
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If TYPE contains a template parm type, then substitute that type    with its actual type that is found in TVEC. */
end_comment

begin_function
specifier|static
name|void
name|grok_template_type
parameter_list|(
name|tvec
parameter_list|,
name|type
parameter_list|)
name|tree
name|tvec
decl_stmt|;
name|tree
modifier|*
name|type
decl_stmt|;
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|type
argument_list|)
condition|)
block|{
case|case
name|TEMPLATE_TYPE_PARM
case|:
if|if
condition|(
operator|*
name|type
operator|!=
name|TYPE_MAIN_VARIANT
argument_list|(
operator|*
name|type
argument_list|)
condition|)
block|{
comment|/* we are here for cases like const T* etc. */
name|grok_template_type
argument_list|(
name|tvec
argument_list|,
operator|&
name|TYPE_MAIN_VARIANT
argument_list|(
operator|*
name|type
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|type
operator|=
name|c_build_type_variant
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
operator|*
name|type
argument_list|)
argument_list|,
name|TYPE_READONLY
argument_list|(
operator|*
name|type
argument_list|)
argument_list|,
name|TYPE_VOLATILE
argument_list|(
operator|*
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|type
operator|=
name|TREE_VEC_ELT
argument_list|(
name|tvec
argument_list|,
name|TEMPLATE_TYPE_IDX
argument_list|(
operator|*
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
name|grok_template_type
argument_list|(
name|tvec
argument_list|,
operator|&
name|TREE_TYPE
argument_list|(
operator|*
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|FUNCTION_TYPE
case|:
block|{
name|tree
name|p
decl_stmt|;
comment|/* take care of function's return type first */
name|grok_template_type
argument_list|(
name|tvec
argument_list|,
operator|&
name|TREE_TYPE
argument_list|(
operator|*
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* take care of function's arguments */
for|for
control|(
name|p
operator|=
name|TYPE_ARG_TYPES
argument_list|(
operator|*
name|type
argument_list|)
init|;
name|p
condition|;
name|p
operator|=
name|TREE_CHAIN
argument_list|(
name|p
argument_list|)
control|)
name|grok_template_type
argument_list|(
name|tvec
argument_list|,
operator|&
name|TREE_VALUE
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
default|default:
break|break;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* Convert all template arguments to their appropriate types, and return    a vector containing the resulting values.  If any error occurs, return    error_mark_node.  */
end_comment

begin_function
specifier|static
name|tree
name|coerce_template_parms
parameter_list|(
name|parms
parameter_list|,
name|arglist
parameter_list|,
name|in_decl
parameter_list|)
name|tree
name|parms
decl_stmt|,
name|arglist
decl_stmt|;
name|tree
name|in_decl
decl_stmt|;
block|{
name|int
name|nparms
decl_stmt|,
name|i
decl_stmt|,
name|lost
init|=
literal|0
decl_stmt|;
name|tree
name|vec
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arglist
argument_list|)
operator|==
name|TREE_VEC
condition|)
name|nparms
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
else|else
name|nparms
operator|=
name|list_length
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
name|nparms
operator|!=
name|TREE_VEC_LENGTH
argument_list|(
name|parms
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"incorrect number of parameters (%d, should be %d)"
argument_list|,
name|nparms
argument_list|,
name|TREE_VEC_LENGTH
argument_list|(
name|parms
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_decl
condition|)
name|cp_error_at
argument_list|(
literal|"in template expansion for decl `%D'"
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arglist
argument_list|)
operator|==
name|TREE_VEC
condition|)
name|vec
operator|=
name|copy_node
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
else|else
block|{
name|vec
operator|=
name|make_tree_vec
argument_list|(
name|nparms
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nparms
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|arg
init|=
name|arglist
decl_stmt|;
name|arglist
operator|=
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|error_mark_node
condition|)
name|lost
operator|++
expr_stmt|;
else|else
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|vec
argument_list|,
name|i
argument_list|)
operator|=
name|arg
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nparms
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|arg
init|=
name|TREE_VEC_ELT
argument_list|(
name|vec
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|parm
init|=
name|TREE_VEC_ELT
argument_list|(
name|parms
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|val
init|=
literal|0
decl_stmt|;
name|int
name|is_type
decl_stmt|,
name|requires_type
decl_stmt|;
name|is_type
operator|=
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
literal|'t'
expr_stmt|;
name|requires_type
operator|=
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|IDENTIFIER_NODE
expr_stmt|;
if|if
condition|(
name|is_type
operator|!=
name|requires_type
condition|)
block|{
if|if
condition|(
name|in_decl
condition|)
name|cp_error_at
argument_list|(
literal|"type/value mismatch in template parameter list for `%D'"
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|lost
operator|++
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|vec
argument_list|,
name|i
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|is_type
condition|)
name|val
operator|=
name|groktypename
argument_list|(
name|arg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|STRING_CST
condition|)
block|{
name|cp_error
argument_list|(
literal|"string literal %E is not a valid template argument"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"because it is the address of an object with static linkage"
argument_list|)
expr_stmt|;
name|val
operator|=
name|error_mark_node
expr_stmt|;
block|}
else|else
block|{
name|grok_template_type
argument_list|(
name|vec
argument_list|,
operator|&
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator|=
name|digest_init
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|arg
argument_list|,
operator|(
name|tree
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|error_mark_node
condition|)
empty_stmt|;
comment|/* 14.2: Other template-arguments must be constant-expressions, 	     addresses of objects or functions with external linkage, or of 	     static class members.  */
elseif|else
if|if
condition|(
operator|!
name|TREE_CONSTANT
argument_list|(
name|val
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"non-const `%E' cannot be used as template argument"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|val
operator|=
name|error_mark_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
block|{
name|tree
name|a
init|=
name|TREE_OPERAND
argument_list|(
name|val
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|a
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|a
argument_list|)
operator|==
name|FUNCTION_DECL
operator|)
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|a
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"address of non-extern `%E' cannot be used as template argument"
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|val
operator|=
name|error_mark_node
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|val
operator|==
name|error_mark_node
condition|)
name|lost
operator|++
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|vec
argument_list|,
name|i
argument_list|)
operator|=
name|val
expr_stmt|;
block|}
if|if
condition|(
name|lost
condition|)
return|return
name|error_mark_node
return|;
return|return
name|vec
return|;
block|}
end_function

begin_comment
comment|/* Given class template name and parameter list, produce a user-friendly name    for the instantiation.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|mangle_class_name_for_template
parameter_list|(
name|name
parameter_list|,
name|parms
parameter_list|,
name|arglist
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|tree
name|parms
decl_stmt|,
name|arglist
decl_stmt|;
block|{
specifier|static
name|struct
name|obstack
name|scratch_obstack
decl_stmt|;
specifier|static
name|char
modifier|*
name|scratch_firstobj
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nparms
decl_stmt|;
if|if
condition|(
operator|!
name|scratch_firstobj
condition|)
block|{
name|gcc_obstack_init
argument_list|(
operator|&
name|scratch_obstack
argument_list|)
expr_stmt|;
name|scratch_firstobj
operator|=
name|obstack_alloc
argument_list|(
operator|&
name|scratch_obstack
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|obstack_free
argument_list|(
operator|&
name|scratch_obstack
argument_list|,
name|scratch_firstobj
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
define|#
directive|define
name|buflen
value|sizeof(buf)
define|#
directive|define
name|check
value|if (bufp>= buf+buflen-1) goto too_long
define|#
directive|define
name|ccat
parameter_list|(
name|c
parameter_list|)
value|*bufp++=(c); check
define|#
directive|define
name|advance
value|bufp+=strlen(bufp); check
define|#
directive|define
name|cat
parameter_list|(
name|s
parameter_list|)
value|strncpy(bufp, s, buf+buflen-bufp-1); advance
else|#
directive|else
define|#
directive|define
name|check
define|#
directive|define
name|ccat
parameter_list|(
name|c
parameter_list|)
value|obstack_1grow (&scratch_obstack, (c));
define|#
directive|define
name|advance
define|#
directive|define
name|cat
parameter_list|(
name|s
parameter_list|)
value|obstack_grow (&scratch_obstack, (s), strlen (s))
endif|#
directive|endif
name|cat
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|ccat
argument_list|(
literal|'<'
argument_list|)
expr_stmt|;
name|nparms
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|parms
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|nparms
operator|==
name|TREE_VEC_LENGTH
argument_list|(
name|arglist
argument_list|)
argument_list|,
literal|268
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nparms
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|parm
init|=
name|TREE_VEC_ELT
argument_list|(
name|parms
argument_list|,
name|i
argument_list|)
decl_stmt|,
name|arg
init|=
name|TREE_VEC_ELT
argument_list|(
name|arglist
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
condition|)
name|ccat
argument_list|(
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
name|cat
argument_list|(
name|type_as_string
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|PARM_DECL
argument_list|,
literal|269
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
comment|/* New list cell was built because old chain link was in 	     use.  */
name|my_friendly_assert
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|arg
argument_list|)
operator|==
name|NULL_TREE
argument_list|,
literal|270
argument_list|)
expr_stmt|;
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
comment|/* No need to check arglist against parmlist here; we did that 	 in coerce_template_parms, called from lookup_template_class.  */
name|cat
argument_list|(
name|expr_as_string
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|{
name|char
modifier|*
name|bufp
init|=
name|obstack_next_free
argument_list|(
operator|&
name|scratch_obstack
argument_list|)
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|bufp
index|[
name|offset
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
name|offset
operator|--
expr_stmt|;
name|obstack_blank_fast
argument_list|(
operator|&
name|scratch_obstack
argument_list|,
name|offset
argument_list|)
expr_stmt|;
comment|/* B<C<char>>, not B<C<char>> */
if|if
condition|(
name|bufp
index|[
name|offset
operator|-
literal|1
index|]
operator|==
literal|'>'
condition|)
name|ccat
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
name|ccat
argument_list|(
literal|'>'
argument_list|)
expr_stmt|;
name|ccat
argument_list|(
literal|'\0'
argument_list|)
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
name|obstack_base
argument_list|(
operator|&
name|scratch_obstack
argument_list|)
return|;
if|#
directive|if
literal|0
block|too_long:
endif|#
directive|endif
name|fatal
argument_list|(
literal|"out of (preallocated) string space creating template instantiation name"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Given an IDENTIFIER_NODE (type TEMPLATE_DECL) and a chain of    parameters, find the desired type.     D1 is the PTYPENAME terminal, and ARGLIST is the list of arguments.    Since ARGLIST is build on the decl_obstack, we must copy it here    to keep it from being reclaimed when the decl storage is reclaimed.     IN_DECL, if non-NULL, is the template declaration we are trying to    instantiate.  */
end_comment

begin_function
name|tree
name|lookup_template_class
parameter_list|(
name|d1
parameter_list|,
name|arglist
parameter_list|,
name|in_decl
parameter_list|)
name|tree
name|d1
decl_stmt|,
name|arglist
decl_stmt|;
name|tree
name|in_decl
decl_stmt|;
block|{
name|tree
name|template
decl_stmt|,
name|parmlist
decl_stmt|;
name|char
modifier|*
name|mangled_name
decl_stmt|;
name|tree
name|id
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|d1
argument_list|)
operator|==
name|IDENTIFIER_NODE
argument_list|,
literal|272
argument_list|)
expr_stmt|;
name|template
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|d1
argument_list|)
expr_stmt|;
comment|/* XXX */
if|if
condition|(
operator|!
name|template
condition|)
name|template
operator|=
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|d1
argument_list|)
expr_stmt|;
comment|/* With something like `template<class T> class X class X { ... };'      we could end up with D1 having nothing but an IDENTIFIER_LOCAL_VALUE.      We don't want to do that, but we have to deal with the situation, so      let's give them some syntax errors to chew on instead of a crash.  */
if|if
condition|(
operator|!
name|template
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|template
argument_list|)
operator|!=
name|TEMPLATE_DECL
condition|)
block|{
name|cp_error
argument_list|(
literal|"non-template type `%T' used as a template"
argument_list|,
name|d1
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_decl
condition|)
name|cp_error_at
argument_list|(
literal|"for template declaration `%D'"
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|parmlist
operator|=
name|DECL_TEMPLATE_PARMS
argument_list|(
name|template
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|coerce_template_parms
argument_list|(
name|parmlist
argument_list|,
name|arglist
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|uses_template_parms
argument_list|(
name|arglist
argument_list|)
condition|)
block|{
name|tree
name|t
init|=
name|make_lang_type
argument_list|(
name|UNINSTANTIATED_P_TYPE
argument_list|)
decl_stmt|;
name|tree
name|d
decl_stmt|;
name|id
operator|=
name|make_anon_name
argument_list|()
expr_stmt|;
name|d
operator|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|id
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
operator|=
name|d
expr_stmt|;
name|TYPE_VALUES
argument_list|(
name|t
argument_list|)
operator|=
name|build_tree_list
argument_list|(
name|template
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|pushdecl_top_level
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mangled_name
operator|=
name|mangle_class_name_for_template
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|d1
argument_list|)
argument_list|,
name|parmlist
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|id
operator|=
name|get_identifier
argument_list|(
name|mangled_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|IDENTIFIER_TEMPLATE
argument_list|(
name|id
argument_list|)
condition|)
block|{
name|arglist
operator|=
name|copy_to_permanent
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|IDENTIFIER_TEMPLATE
argument_list|(
name|id
argument_list|)
operator|=
name|perm_tree_cons
argument_list|(
name|template
argument_list|,
name|arglist
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
return|return
name|id
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|push_template_decls
parameter_list|(
name|parmlist
parameter_list|,
name|arglist
parameter_list|,
name|class_level
parameter_list|)
name|tree
name|parmlist
decl_stmt|,
name|arglist
decl_stmt|;
name|int
name|class_level
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|nparms
decl_stmt|;
comment|/* Don't want to push values into global context.  */
if|if
condition|(
operator|!
name|class_level
condition|)
block|{
name|pushlevel
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|declare_pseudo_global_level
argument_list|()
expr_stmt|;
block|}
name|nparms
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|parmlist
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nparms
condition|;
name|i
operator|++
control|)
block|{
name|int
name|requires_type
decl_stmt|,
name|is_type
decl_stmt|;
name|tree
name|parm
init|=
name|TREE_VEC_ELT
argument_list|(
name|parmlist
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|arg
init|=
name|TREE_VEC_ELT
argument_list|(
name|arglist
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|decl
init|=
literal|0
decl_stmt|;
name|requires_type
operator|=
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|IDENTIFIER_NODE
expr_stmt|;
name|is_type
operator|=
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
literal|'t'
expr_stmt|;
if|if
condition|(
name|is_type
condition|)
block|{
comment|/* add typename to namespace */
if|if
condition|(
operator|!
name|requires_type
condition|)
block|{
name|error
argument_list|(
literal|"template use error: type provided where value needed"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|decl
operator|=
name|arg
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
literal|'t'
argument_list|,
literal|273
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|parm
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* add const decl to namespace */
name|tree
name|val
decl_stmt|;
if|if
condition|(
name|requires_type
condition|)
block|{
name|error
argument_list|(
literal|"template use error: value provided where type needed"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|val
operator|=
name|digest_init
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|arg
argument_list|,
operator|(
name|tree
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|error_mark_node
condition|)
block|{
name|decl
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|DECL_NAME
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|val
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|decl
operator|!=
literal|0
condition|)
block|{
name|layout_decl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|class_level
condition|)
name|pushdecl_class_level
argument_list|(
name|decl
argument_list|)
expr_stmt|;
else|else
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|pop_template_decls
parameter_list|(
name|parmlist
parameter_list|,
name|arglist
parameter_list|,
name|class_level
parameter_list|)
name|tree
name|parmlist
decl_stmt|,
name|arglist
decl_stmt|;
name|int
name|class_level
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|class_level
condition|)
name|poplevel
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Should be defined in parse.h.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|yychar
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|uses_template_parms
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|t
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|INDIRECT_REF
case|:
case|case
name|COMPONENT_REF
case|:
comment|/* We assume that the object must be instantiated in order to build 	 the COMPONENT_REF, so we test only whether the type of the 	 COMPONENT_REF uses template parms.  */
return|return
name|uses_template_parms
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
case|case
name|IDENTIFIER_NODE
case|:
if|if
condition|(
operator|!
name|IDENTIFIER_TEMPLATE
argument_list|(
name|t
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|uses_template_parms
argument_list|(
name|TREE_VALUE
argument_list|(
name|IDENTIFIER_TEMPLATE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* aggregates of tree nodes */
case|case
name|TREE_VEC
case|:
block|{
name|int
name|i
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|t
argument_list|)
decl_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
if|if
condition|(
name|uses_template_parms
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
case|case
name|TREE_LIST
case|:
if|if
condition|(
name|uses_template_parms
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|||
name|uses_template_parms
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
name|uses_template_parms
argument_list|(
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
comment|/* constructed type nodes */
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
return|return
name|uses_template_parms
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
if|if
condition|(
operator|!
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|TYPE_IDENTIFIER
argument_list|(
name|t
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|uses_template_parms
argument_list|(
name|TYPE_IDENTIFIER
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
case|case
name|FUNCTION_TYPE
case|:
if|if
condition|(
name|uses_template_parms
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
name|uses_template_parms
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
case|case
name|ARRAY_TYPE
case|:
if|if
condition|(
name|uses_template_parms
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
name|uses_template_parms
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
case|case
name|OFFSET_TYPE
case|:
if|if
condition|(
name|uses_template_parms
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
name|uses_template_parms
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
case|case
name|METHOD_TYPE
case|:
if|if
condition|(
name|uses_template_parms
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|uses_template_parms
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
name|uses_template_parms
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
comment|/* decl nodes */
case|case
name|TYPE_DECL
case|:
return|return
name|uses_template_parms
argument_list|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
case|case
name|FUNCTION_DECL
case|:
if|if
condition|(
name|uses_template_parms
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* fall through */
case|case
name|VAR_DECL
case|:
case|case
name|PARM_DECL
case|:
comment|/* ??? What about FIELD_DECLs?  */
comment|/* The type of a decl can't use template parms if the name of the 	 variable doesn't, because it's impossible to resolve them.  So 	 ignore the type field for now.	 */
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
operator|&&
name|uses_template_parms
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|uses_template_parms
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"template parms used where they can't be resolved"
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
case|case
name|CALL_EXPR
case|:
return|return
name|uses_template_parms
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
case|case
name|ADDR_EXPR
case|:
return|return
name|uses_template_parms
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
comment|/* template parm nodes */
case|case
name|TEMPLATE_TYPE_PARM
case|:
case|case
name|TEMPLATE_CONST_PARM
case|:
return|return
literal|1
return|;
comment|/* simple type nodes */
case|case
name|INTEGER_TYPE
case|:
if|if
condition|(
name|uses_template_parms
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
name|uses_template_parms
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
case|case
name|REAL_TYPE
case|:
case|case
name|VOID_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
return|return
literal|0
return|;
comment|/* constants */
case|case
name|INTEGER_CST
case|:
case|case
name|REAL_CST
case|:
case|case
name|STRING_CST
case|:
return|return
literal|0
return|;
case|case
name|ERROR_MARK
case|:
comment|/* Non-error_mark_node ERROR_MARKs are bad things.  */
name|my_friendly_assert
argument_list|(
name|t
operator|==
name|error_mark_node
argument_list|,
literal|274
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
return|return
literal|0
return|;
case|case
name|UNINSTANTIATED_P_TYPE
case|:
return|return
literal|1
return|;
default|default:
switch|switch
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
block|{
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'<'
case|:
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|tree_code_length
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|t
argument_list|)
index|]
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
if|if
condition|(
name|uses_template_parms
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
default|default:
break|break;
block|}
name|sorry
argument_list|(
literal|"testing %s for template parms"
argument_list|,
name|tree_code_name
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|t
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|my_friendly_abort
argument_list|(
literal|82
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
return|return
literal|0
return|;
block|}
block|}
end_function

begin_function
name|void
name|instantiate_member_templates
parameter_list|(
name|classname
parameter_list|)
name|tree
name|classname
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
name|tree
name|id
init|=
name|classname
decl_stmt|;
name|tree
name|members
init|=
name|DECL_TEMPLATE_MEMBERS
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|IDENTIFIER_TEMPLATE
argument_list|(
name|id
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|t
operator|=
name|members
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|tree
name|parmvec
decl_stmt|,
name|type
decl_stmt|,
name|classparms
decl_stmt|,
name|tdecl
decl_stmt|,
name|t2
decl_stmt|;
name|int
name|nparms
decl_stmt|,
name|xxx
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
operator|!=
name|NULL_TREE
argument_list|,
literal|275
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|TEMPLATE_DECL
argument_list|,
literal|276
argument_list|)
expr_stmt|;
comment|/* @@ Should verify that class parm list is a list of 	 distinct template parameters, and covers all the template 	 parameters.  */
name|tdecl
operator|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|type
operator|=
name|DECL_CONTEXT
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|tdecl
argument_list|)
argument_list|)
expr_stmt|;
name|classparms
operator|=
name|UPT_PARMS
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|nparms
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|classparms
argument_list|)
expr_stmt|;
name|parmvec
operator|=
name|make_tree_vec
argument_list|(
name|nparms
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nparms
condition|;
name|i
operator|++
control|)
name|TREE_VEC_ELT
argument_list|(
name|parmvec
argument_list|,
name|i
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
switch|switch
condition|(
name|unify
argument_list|(
name|DECL_TEMPLATE_PARMS
argument_list|(
name|tdecl
argument_list|)
argument_list|,
operator|&
name|TREE_VEC_ELT
argument_list|(
name|parmvec
argument_list|,
literal|0
argument_list|)
argument_list|,
name|nparms
argument_list|,
name|type
argument_list|,
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|classname
argument_list|)
argument_list|,
operator|&
name|xxx
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* Success -- well, no inconsistency, at least.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nparms
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TREE_VEC_ELT
argument_list|(
name|parmvec
argument_list|,
name|i
argument_list|)
operator|==
name|NULL_TREE
condition|)
goto|goto
name|failure
goto|;
name|t2
operator|=
name|instantiate_template
argument_list|(
name|tdecl
argument_list|,
operator|&
name|TREE_VEC_ELT
argument_list|(
name|parmvec
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|type
operator|!=
literal|0
argument_list|,
literal|277
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_INTERFACE_UNKNOWN
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|DECL_EXTERNAL
argument_list|(
name|t2
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|t2
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|DECL_EXTERNAL
argument_list|(
name|t2
argument_list|)
operator|=
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|t2
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|1
case|:
comment|/* Failure.  */
name|failure
label|:
name|cp_error
argument_list|(
literal|"type unification error instantiating %T::%D"
argument_list|,
name|classname
argument_list|,
name|tdecl
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"for template declaration `%D'"
argument_list|,
name|tdecl
argument_list|)
expr_stmt|;
continue|continue
comment|/* loop of members */
continue|;
default|default:
comment|/* Eek, a bug.  */
name|my_friendly_abort
argument_list|(
literal|83
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_decl_stmt
name|struct
name|tinst_level
modifier|*
name|current_tinst_level
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|tinst_level
modifier|*
name|free_tinst_level
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|push_tinst_level
parameter_list|(
name|name
parameter_list|)
name|tree
name|name
decl_stmt|;
block|{
name|struct
name|tinst_level
modifier|*
name|new
decl_stmt|;
name|tree
name|global
init|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|free_tinst_level
condition|)
block|{
name|new
operator|=
name|free_tinst_level
expr_stmt|;
name|free_tinst_level
operator|=
name|new
operator|->
name|next
expr_stmt|;
block|}
else|else
name|new
operator|=
operator|(
expr|struct
name|tinst_level
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|tinst_level
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|classname
operator|=
name|name
expr_stmt|;
if|if
condition|(
name|global
condition|)
block|{
name|new
operator|->
name|line
operator|=
name|DECL_SOURCE_LINE
argument_list|(
name|global
argument_list|)
expr_stmt|;
name|new
operator|->
name|file
operator|=
name|DECL_SOURCE_FILE
argument_list|(
name|global
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|new
operator|->
name|line
operator|=
name|lineno
expr_stmt|;
name|new
operator|->
name|file
operator|=
name|input_filename
expr_stmt|;
block|}
name|new
operator|->
name|next
operator|=
name|current_tinst_level
expr_stmt|;
name|current_tinst_level
operator|=
name|new
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pop_tinst_level
parameter_list|()
block|{
name|struct
name|tinst_level
modifier|*
name|old
init|=
name|current_tinst_level
decl_stmt|;
name|current_tinst_level
operator|=
name|old
operator|->
name|next
expr_stmt|;
name|old
operator|->
name|next
operator|=
name|free_tinst_level
expr_stmt|;
name|free_tinst_level
operator|=
name|old
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|tinst_level
modifier|*
name|tinst_for_decl
parameter_list|()
block|{
name|struct
name|tinst_level
modifier|*
name|p
init|=
name|current_tinst_level
decl_stmt|;
if|if
condition|(
name|p
condition|)
for|for
control|(
init|;
name|p
operator|->
name|next
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
empty_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
name|tree
name|instantiate_class_template
parameter_list|(
name|classname
parameter_list|,
name|setup_parse
parameter_list|)
name|tree
name|classname
decl_stmt|;
name|int
name|setup_parse
decl_stmt|;
block|{
name|struct
name|template_info
modifier|*
name|template_info
decl_stmt|;
name|tree
name|template
decl_stmt|,
name|t1
decl_stmt|;
if|if
condition|(
name|classname
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|classname
argument_list|)
operator|==
name|IDENTIFIER_NODE
argument_list|,
literal|278
argument_list|)
expr_stmt|;
name|template
operator|=
name|IDENTIFIER_TEMPLATE
argument_list|(
name|classname
argument_list|)
expr_stmt|;
if|if
condition|(
name|IDENTIFIER_HAS_TYPE_VALUE
argument_list|(
name|classname
argument_list|)
condition|)
block|{
name|tree
name|type
init|=
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|classname
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNINSTANTIATED_P_TYPE
condition|)
return|return
name|type
return|;
if|if
condition|(
name|TYPE_BEING_DEFINED
argument_list|(
name|type
argument_list|)
operator|||
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|||
name|CLASSTYPE_USE_TEMPLATE
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|type
return|;
block|}
comment|/* If IDENTIFIER_LOCAL_VALUE is already set on this template classname      (it's something like `foo<int>'), that means we're already working on      the instantiation for it.  Normally, a classname comes in with nothing      but its IDENTIFIER_TEMPLATE slot set.  If we were to try to instantiate      this again, we'd get a redeclaration error.  Since we're already working      on it, we'll pass back this classname's TYPE_DECL (it's the value of      the classname's IDENTIFIER_LOCAL_VALUE).  Only do this if we're setting      things up for the parser, though---if we're just trying to instantiate      it (e.g., via tsubst) we can trip up cuz it may not have an      IDENTIFIER_TYPE_VALUE when it will need one.  */
if|if
condition|(
name|setup_parse
operator|&&
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|classname
argument_list|)
condition|)
return|return
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|classname
argument_list|)
return|;
if|if
condition|(
name|uses_template_parms
argument_list|(
name|classname
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|TREE_TYPE
argument_list|(
name|classname
argument_list|)
condition|)
block|{
name|tree
name|t
init|=
name|make_lang_type
argument_list|(
name|RECORD_TYPE
argument_list|)
decl_stmt|;
name|tree
name|d
init|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|classname
argument_list|,
name|t
argument_list|)
decl_stmt|;
name|DECL_NAME
argument_list|(
name|d
argument_list|)
operator|=
name|classname
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
operator|=
name|d
expr_stmt|;
name|pushdecl
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
name|t1
operator|=
name|TREE_PURPOSE
argument_list|(
name|template
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|TEMPLATE_DECL
argument_list|,
literal|279
argument_list|)
expr_stmt|;
comment|/* If a template is declared but not defined, accept it; don't crash.      Later uses requiring the definition will be flagged as errors by      other code.  Thanks to niklas@appli.se for this bug fix.  */
if|if
condition|(
name|DECL_TEMPLATE_INFO
argument_list|(
name|t1
argument_list|)
operator|->
name|text
operator|==
literal|0
condition|)
name|setup_parse
operator|=
literal|0
expr_stmt|;
name|push_to_top_level
argument_list|()
expr_stmt|;
name|template_info
operator|=
name|DECL_TEMPLATE_INFO
argument_list|(
name|t1
argument_list|)
expr_stmt|;
if|if
condition|(
name|setup_parse
condition|)
block|{
name|push_tinst_level
argument_list|(
name|classname
argument_list|)
expr_stmt|;
name|push_template_decls
argument_list|(
name|DECL_TEMPLATE_PARMS
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|template
argument_list|)
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|template
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_current_level_tags_transparency
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|feed_input
argument_list|(
name|template_info
operator|->
name|text
argument_list|,
name|template_info
operator|->
name|length
argument_list|,
operator|(
expr|struct
name|obstack
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|lineno
operator|=
name|template_info
operator|->
name|lineno
expr_stmt|;
name|input_filename
operator|=
name|template_info
operator|->
name|filename
expr_stmt|;
comment|/* Get interface/implementation back in sync.  */
name|extract_interface_info
argument_list|()
expr_stmt|;
name|overload_template_name
argument_list|(
name|classname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Kludge so that we don't get screwed by our own base classes.  */
name|TYPE_BEING_DEFINED
argument_list|(
name|TREE_TYPE
argument_list|(
name|classname
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
name|yychar
operator|=
name|PRE_PARSED_CLASS_DECL
expr_stmt|;
name|yylval
operator|.
name|ttype
operator|=
name|classname
expr_stmt|;
name|processing_template_defn
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|flag_external_templates
condition|)
name|interface_unknown
operator|++
expr_stmt|;
block|}
else|else
block|{
name|tree
name|t
decl_stmt|,
name|decl
decl_stmt|,
name|id
decl_stmt|,
name|tmpl
decl_stmt|;
name|id
operator|=
name|classname
expr_stmt|;
name|tmpl
operator|=
name|TREE_PURPOSE
argument_list|(
name|IDENTIFIER_TEMPLATE
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|xref_tag
argument_list|(
name|DECL_TEMPLATE_INFO
argument_list|(
name|tmpl
argument_list|)
operator|->
name|aggr
argument_list|,
name|id
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|UNION_TYPE
argument_list|,
literal|280
argument_list|)
expr_stmt|;
comment|/* Now, put a copy of the decl in global scope, to avoid        * recursive expansion.  */
name|decl
operator|=
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|decl
condition|)
name|decl
operator|=
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
argument_list|,
literal|281
argument_list|)
expr_stmt|;
comment|/* We'd better make sure we're on the permanent obstack or else 	   * we'll get a "friendly" abort 124 in pushdecl.  Perhaps a 	   * copy_to_permanent would be sufficient here, but then a 	   * sharing problem might occur.  I don't know -- niklas@appli.se */
name|push_obstacks
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|&
name|permanent_obstack
argument_list|)
expr_stmt|;
name|pushdecl_top_level
argument_list|(
name|copy_node
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
name|pop_from_top_level
argument_list|()
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|list_eq
parameter_list|(
name|t1
parameter_list|,
name|t2
parameter_list|)
name|tree
name|t1
decl_stmt|,
name|t2
decl_stmt|;
block|{
if|if
condition|(
name|t1
operator|==
name|NULL_TREE
condition|)
return|return
name|t2
operator|==
name|NULL_TREE
return|;
if|if
condition|(
name|t2
operator|==
name|NULL_TREE
condition|)
return|return
literal|0
return|;
comment|/* Don't care if one declares its arg const and the other doesn't -- the      main variant of the arg type is all that matters.  */
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_VALUE
argument_list|(
name|t1
argument_list|)
argument_list|)
operator|!=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_VALUE
argument_list|(
name|t2
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|list_eq
argument_list|(
name|TREE_CHAIN
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|t2
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|lookup_nested_type_by_name
parameter_list|(
name|ctype
parameter_list|,
name|name
parameter_list|)
name|tree
name|ctype
decl_stmt|,
name|name
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
name|t
operator|=
name|TREE_VALUE
argument_list|(
name|CLASSTYPE_TAGS
argument_list|(
name|ctype
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|t
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TYPE_IDENTIFIER
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
name|t
return|;
else|else
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|search_nested_type_in_tmpl
parameter_list|(
name|tmpl
parameter_list|,
name|type
parameter_list|)
name|tree
name|tmpl
decl_stmt|,
name|type
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|tmpl
operator|==
name|NULL
operator|||
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|tmpl
return|;
name|t
operator|=
name|search_nested_type_in_tmpl
argument_list|(
name|tmpl
argument_list|,
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
return|return
name|t
return|;
name|t
operator|=
name|lookup_nested_type_by_name
argument_list|(
name|t
argument_list|,
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|tsubst
parameter_list|(
name|t
parameter_list|,
name|args
parameter_list|,
name|nargs
parameter_list|,
name|in_decl
parameter_list|)
name|tree
name|t
decl_stmt|,
decl|*
name|args
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|nargs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|in_decl
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL_TREE
operator|||
name|t
operator|==
name|error_mark_node
condition|)
return|return
name|t
return|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
comment|/* Minor optimization. 	 ?? Are these really the most frequent cases?  Is the savings 	 significant?  */
operator|&&
name|type
operator|!=
name|integer_type_node
operator|&&
name|type
operator|!=
name|void_type_node
operator|&&
name|type
operator|!=
name|char_type_node
condition|)
name|type
operator|=
name|c_build_type_variant
argument_list|(
name|tsubst
argument_list|(
name|type
argument_list|,
name|args
argument_list|,
name|nargs
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|TYPE_READONLY
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_VOLATILE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|RECORD_TYPE
case|:
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|build_ptrmemfunc_type
argument_list|(
name|tsubst
argument_list|(
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|nargs
argument_list|,
name|in_decl
argument_list|)
argument_list|)
return|;
comment|/* else fall through */
case|case
name|ERROR_MARK
case|:
case|case
name|IDENTIFIER_NODE
case|:
case|case
name|OP_IDENTIFIER
case|:
case|case
name|VOID_TYPE
case|:
case|case
name|REAL_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
case|case
name|INTEGER_CST
case|:
case|case
name|REAL_CST
case|:
case|case
name|STRING_CST
case|:
case|case
name|UNION_TYPE
case|:
return|return
name|t
return|;
case|case
name|INTEGER_TYPE
case|:
if|if
condition|(
name|t
operator|==
name|integer_type_node
condition|)
return|return
name|t
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
return|return
name|t
return|;
return|return
name|build_index_2_type
argument_list|(
name|tsubst
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|nargs
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|tsubst
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|nargs
argument_list|,
name|in_decl
argument_list|)
argument_list|)
return|;
case|case
name|TEMPLATE_TYPE_PARM
case|:
return|return
name|c_build_type_variant
argument_list|(
name|args
index|[
name|TEMPLATE_TYPE_IDX
argument_list|(
name|t
argument_list|)
index|]
argument_list|,
name|TYPE_READONLY
argument_list|(
name|t
argument_list|)
argument_list|,
name|TYPE_VOLATILE
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
case|case
name|TEMPLATE_CONST_PARM
case|:
return|return
name|args
index|[
name|TEMPLATE_CONST_IDX
argument_list|(
name|t
argument_list|)
index|]
return|;
case|case
name|FUNCTION_DECL
case|:
block|{
name|tree
name|r
decl_stmt|;
name|tree
name|fnargs
decl_stmt|,
name|result
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|&&
operator|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
operator|!=
literal|'t'
operator|)
condition|)
return|return
name|t
return|;
name|fnargs
operator|=
name|tsubst
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|nargs
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|result
operator|=
name|tsubst
argument_list|(
name|DECL_RESULT
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|nargs
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'t'
condition|)
block|{
comment|/* Look it up in that class, and return the decl node there, 	       instead of creating a new one.  */
name|tree
name|ctx
decl_stmt|,
name|methods
decl_stmt|,
name|name
decl_stmt|,
name|method
decl_stmt|;
name|int
name|n_methods
decl_stmt|;
name|int
name|i
decl_stmt|,
name|found
init|=
literal|0
decl_stmt|;
name|name
operator|=
name|DECL_NAME
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|ctx
operator|=
name|tsubst
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|nargs
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|methods
operator|=
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|methods
operator|==
name|NULL_TREE
condition|)
comment|/* No methods at all -- no way this one can match.  */
goto|goto
name|no_match
goto|;
name|n_methods
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|methods
argument_list|)
expr_stmt|;
name|r
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|OPERATOR_TYPENAME_FORMAT
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|OPERATOR_TYPENAME_FORMAT
argument_list|)
operator|-
literal|1
argument_list|)
condition|)
block|{
comment|/* Type-conversion operator.  Reconstruct the name, in 		   case it's the name of one of the template's parameters.  */
name|name
operator|=
name|build_typename_overload
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'t'
operator|&&
name|constructor_name
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|DECL_NAME
argument_list|(
name|t
argument_list|)
condition|)
name|name
operator|=
name|constructor_name
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|fprintf (stderr, "\nfor function %s in class %s:\n", 		     IDENTIFIER_POINTER (name), 		     IDENTIFIER_POINTER (TYPE_IDENTIFIER (ctx)));
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_methods
condition|;
name|i
operator|++
control|)
block|{
name|int
name|pass
decl_stmt|;
name|method
operator|=
name|TREE_VEC_ELT
argument_list|(
name|methods
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|method
operator|==
name|NULL_TREE
operator|||
name|DECL_NAME
argument_list|(
name|method
argument_list|)
operator|!=
name|name
condition|)
continue|continue;
name|pass
operator|=
literal|0
expr_stmt|;
name|maybe_error
label|:
for|for
control|(
init|;
name|method
condition|;
name|method
operator|=
name|DECL_CHAIN
argument_list|(
name|method
argument_list|)
control|)
block|{
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|method
argument_list|)
operator|==
name|FUNCTION_DECL
argument_list|,
literal|282
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|comptypes
argument_list|(
name|type
argument_list|,
name|TREE_TYPE
argument_list|(
name|method
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|tree
name|mtype
init|=
name|TREE_TYPE
argument_list|(
name|method
argument_list|)
decl_stmt|;
name|tree
name|t1
decl_stmt|,
name|t2
decl_stmt|;
comment|/* Keep looking for a method that matches 			   perfectly.  This takes care of the problem 			   where destructors (which have implicit int args) 			   look like constructors which have an int arg.  */
if|if
condition|(
name|pass
operator|==
literal|0
condition|)
continue|continue;
name|t1
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|mtype
argument_list|)
expr_stmt|;
name|t2
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|mtype
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|t2
operator|=
name|TREE_CHAIN
argument_list|(
name|t2
argument_list|)
expr_stmt|;
if|if
condition|(
name|list_eq
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|mtype
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|tree
name|newtype
decl_stmt|;
name|newtype
operator|=
name|build_function_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|newtype
operator|=
name|build_type_variant
argument_list|(
name|newtype
argument_list|,
name|TYPE_READONLY
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_VOLATILE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|newtype
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
operator|!=
name|TREE_TYPE
argument_list|(
name|mtype
argument_list|)
condition|)
goto|goto
name|maybe_bad_return_type
goto|;
block|}
elseif|else
if|if
condition|(
name|TYPE_METHOD_BASETYPE
argument_list|(
name|mtype
argument_list|)
operator|==
name|TYPE_METHOD_BASETYPE
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* Types didn't match, but arg types and 				   `this' do match, so the return type is 				   all that should be messing it up.  */
name|maybe_bad_return_type
label|:
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
operator|!=
name|TREE_TYPE
argument_list|(
name|mtype
argument_list|)
condition|)
name|error
argument_list|(
literal|"inconsistent return types for method `%s' in class `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TYPE_IDENTIFIER
argument_list|(
name|ctx
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|r
operator|=
name|method
expr_stmt|;
break|break;
block|}
name|found
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|#
directive|if
literal|0
block|fprintf (stderr, "\tfound %s\n\n", 			     IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (method)));
endif|#
directive|endif
if|if
condition|(
name|DECL_ARTIFICIAL
argument_list|(
name|method
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"template for method `%D' which has default implementation in class `%T'"
argument_list|,
name|name
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_decl
condition|)
name|cp_error_at
argument_list|(
literal|"in attempt to instantiate `%D' declared at this point in file"
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|DECL_ARGUMENTS
argument_list|(
name|method
argument_list|)
operator|&&
operator|!
name|TREE_PERMANENT
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|method
argument_list|)
argument_list|)
condition|)
comment|/* @@ Is this early enough?  Might we want to do 			 this instead while processing the expansion?	 */
name|DECL_ARGUMENTS
argument_list|(
name|method
argument_list|)
operator|=
name|tsubst
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|nargs
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|r
operator|=
name|method
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|r
operator|==
name|NULL_TREE
operator|&&
name|pass
operator|==
literal|0
condition|)
block|{
name|pass
operator|=
literal|1
expr_stmt|;
name|method
operator|=
name|TREE_VEC_ELT
argument_list|(
name|methods
argument_list|,
name|i
argument_list|)
expr_stmt|;
goto|goto
name|maybe_error
goto|;
block|}
block|}
if|if
condition|(
name|r
operator|==
name|NULL_TREE
condition|)
block|{
name|no_match
label|:
name|cp_error
argument_list|(
name|found
condition|?
literal|"template for method `%D' doesn't match any in class `%T'"
else|:
literal|"method `%D' not found in class `%T'"
argument_list|,
name|name
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_decl
condition|)
name|cp_error_at
argument_list|(
literal|"in attempt to instantiate `%D' declared at this point in file"
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
else|else
block|{
name|r
operator|=
name|DECL_NAME
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|{
name|tree
name|decls
decl_stmt|;
name|int
name|got_it
init|=
literal|0
decl_stmt|;
name|decls
operator|=
name|lookup_name_nonclass
argument_list|(
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|decls
operator|==
name|NULL_TREE
condition|)
comment|/* no match */
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decls
argument_list|)
operator|==
name|TREE_LIST
condition|)
for|for
control|(
name|decls
operator|=
name|TREE_VALUE
argument_list|(
name|decls
argument_list|)
init|;
name|decls
condition|;
name|decls
operator|=
name|DECL_CHAIN
argument_list|(
name|decls
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decls
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|TREE_TYPE
argument_list|(
name|decls
argument_list|)
operator|==
name|type
condition|)
block|{
name|got_it
operator|=
literal|1
expr_stmt|;
name|r
operator|=
name|decls
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|tree
name|val
init|=
name|decls
decl_stmt|;
name|decls
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
operator|==
name|type
condition|)
block|{
name|got_it
operator|=
literal|1
expr_stmt|;
name|r
operator|=
name|val
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|got_it
condition|)
block|{
name|r
operator|=
name|build_decl_overload
argument_list|(
name|r
argument_list|,
name|TYPE_VALUES
argument_list|(
name|type
argument_list|)
argument_list|,
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
operator|!=
name|NULL_TREE
argument_list|)
expr_stmt|;
name|r
operator|=
name|build_lang_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|r
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_INLINE
argument_list|(
name|r
argument_list|)
operator|&&
name|DECL_SAVED_INSNS
argument_list|(
name|r
argument_list|)
condition|)
block|{
comment|/* This overrides the template version, use it. */
return|return
name|r
return|;
block|}
block|}
block|}
name|TREE_PUBLIC
argument_list|(
name|r
argument_list|)
operator|=
name|TREE_PUBLIC
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|r
argument_list|)
operator|=
name|DECL_EXTERNAL
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|r
argument_list|)
operator|=
name|TREE_STATIC
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|DECL_INLINE
argument_list|(
name|r
argument_list|)
operator|=
name|DECL_INLINE
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|{
if|#
directive|if
literal|0
comment|/* Maybe later.  -jason  */
block|struct tinst_level *til = tinst_for_decl();
comment|/* should always be true under new approach */
block|if (til) 	    { 	      DECL_SOURCE_FILE (r) = til->file; 	      DECL_SOURCE_LINE (r) = til->line; 	    } 	  else
endif|#
directive|endif
block|{
name|DECL_SOURCE_FILE
argument_list|(
name|r
argument_list|)
operator|=
name|DECL_SOURCE_FILE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|DECL_SOURCE_LINE
argument_list|(
name|r
argument_list|)
operator|=
name|DECL_SOURCE_LINE
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
name|DECL_CLASS_CONTEXT
argument_list|(
name|r
argument_list|)
operator|=
name|tsubst
argument_list|(
name|DECL_CLASS_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|nargs
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|make_decl_rtl
argument_list|(
name|r
argument_list|,
name|NULL_PTR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|DECL_ARGUMENTS
argument_list|(
name|r
argument_list|)
operator|=
name|fnargs
expr_stmt|;
name|DECL_RESULT
argument_list|(
name|r
argument_list|)
operator|=
name|result
expr_stmt|;
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
operator|!=
literal|'t'
condition|)
name|push_overloaded_decl_top_level
argument_list|(
name|r
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
case|case
name|PARM_DECL
case|:
block|{
name|tree
name|r
decl_stmt|;
name|r
operator|=
name|build_decl
argument_list|(
name|PARM_DECL
argument_list|,
name|DECL_NAME
argument_list|(
name|t
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|r
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
condition|)
name|TREE_CHAIN
argument_list|(
name|r
argument_list|)
operator|=
name|tsubst
argument_list|(
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|nargs
argument_list|,
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
case|case
name|TREE_LIST
case|:
block|{
name|tree
name|purpose
decl_stmt|,
name|value
decl_stmt|,
name|chain
decl_stmt|,
name|result
decl_stmt|;
name|int
name|via_public
decl_stmt|,
name|via_virtual
decl_stmt|,
name|via_protected
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|void_list_node
condition|)
return|return
name|t
return|;
name|via_public
operator|=
name|TREE_VIA_PUBLIC
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|via_protected
operator|=
name|TREE_VIA_PROTECTED
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|via_virtual
operator|=
name|TREE_VIA_VIRTUAL
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|purpose
operator|=
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|purpose
condition|)
name|purpose
operator|=
name|tsubst
argument_list|(
name|purpose
argument_list|,
name|args
argument_list|,
name|nargs
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|value
operator|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
condition|)
name|value
operator|=
name|tsubst
argument_list|(
name|value
argument_list|,
name|args
argument_list|,
name|nargs
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|chain
operator|&&
name|chain
operator|!=
name|void_type_node
condition|)
name|chain
operator|=
name|tsubst
argument_list|(
name|chain
argument_list|,
name|args
argument_list|,
name|nargs
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|purpose
operator|==
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
operator|&&
name|value
operator|==
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
operator|&&
name|chain
operator|==
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|t
return|;
name|result
operator|=
name|hash_tree_cons
argument_list|(
name|via_public
argument_list|,
name|via_virtual
argument_list|,
name|via_protected
argument_list|,
name|purpose
argument_list|,
name|value
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|TREE_PARMLIST
argument_list|(
name|result
argument_list|)
operator|=
name|TREE_PARMLIST
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
case|case
name|TREE_VEC
case|:
block|{
name|int
name|len
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|t
argument_list|)
decl_stmt|,
name|need_new
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
name|tree
modifier|*
name|elts
init|=
operator|(
name|tree
operator|*
operator|)
name|alloca
argument_list|(
name|len
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
decl_stmt|;
name|bzero
argument_list|(
name|elts
argument_list|,
name|len
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|elts
index|[
name|i
index|]
operator|=
name|tsubst
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
argument_list|,
name|args
argument_list|,
name|nargs
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|elts
index|[
name|i
index|]
operator|!=
name|TREE_VEC_ELT
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
condition|)
name|need_new
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|need_new
condition|)
return|return
name|t
return|;
name|t
operator|=
name|make_tree_vec
argument_list|(
name|len
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|TREE_VEC_ELT
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
operator|=
name|elts
index|[
name|i
index|]
expr_stmt|;
return|return
name|t
return|;
block|}
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
block|{
name|tree
name|r
decl_stmt|;
name|enum
name|tree_code
name|code
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|t
return|;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|POINTER_TYPE
condition|)
name|r
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
else|else
name|r
operator|=
name|build_reference_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|r
operator|=
name|c_build_type_variant
argument_list|(
name|r
argument_list|,
name|TYPE_READONLY
argument_list|(
name|t
argument_list|)
argument_list|,
name|TYPE_VOLATILE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Will this ever be needed for TYPE_..._TO values?  */
name|layout_type
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
case|case
name|OFFSET_TYPE
case|:
return|return
name|build_offset_type
argument_list|(
name|tsubst
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|nargs
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|type
argument_list|)
return|;
case|case
name|FUNCTION_TYPE
case|:
case|case
name|METHOD_TYPE
case|:
block|{
name|tree
name|values
init|=
name|TYPE_VALUES
argument_list|(
name|t
argument_list|)
decl_stmt|;
comment|/* same as TYPE_ARG_TYPES */
name|tree
name|context
init|=
name|TYPE_CONTEXT
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|new_value
decl_stmt|;
comment|/* Don't bother recursing if we know it won't change anything.	*/
if|if
condition|(
name|values
operator|!=
name|void_list_node
condition|)
name|values
operator|=
name|tsubst
argument_list|(
name|values
argument_list|,
name|args
argument_list|,
name|nargs
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
condition|)
name|context
operator|=
name|tsubst
argument_list|(
name|context
argument_list|,
name|args
argument_list|,
name|nargs
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
comment|/* Could also optimize cases where return value and 	   values have common elements (e.g., T min(const&T, const T&).  */
comment|/* If the above parameters haven't changed, just return the type.  */
if|if
condition|(
name|type
operator|==
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|&&
name|values
operator|==
name|TYPE_VALUES
argument_list|(
name|t
argument_list|)
operator|&&
name|context
operator|==
name|TYPE_CONTEXT
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|t
return|;
comment|/* Construct a new type node and return it.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|&&
name|context
operator|==
name|NULL_TREE
condition|)
block|{
name|new_value
operator|=
name|build_function_type
argument_list|(
name|type
argument_list|,
name|values
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|context
operator|==
name|NULL_TREE
condition|)
block|{
name|tree
name|base
init|=
name|tsubst
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|args
argument_list|,
name|nargs
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
name|new_value
operator|=
name|build_cplus_method_type
argument_list|(
name|base
argument_list|,
name|type
argument_list|,
name|TREE_CHAIN
argument_list|(
name|values
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|new_value
operator|=
name|make_node
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|new_value
argument_list|)
operator|=
name|type
expr_stmt|;
name|TYPE_CONTEXT
argument_list|(
name|new_value
argument_list|)
operator|=
name|context
expr_stmt|;
name|TYPE_VALUES
argument_list|(
name|new_value
argument_list|)
operator|=
name|values
expr_stmt|;
name|TYPE_SIZE
argument_list|(
name|new_value
argument_list|)
operator|=
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_ALIGN
argument_list|(
name|new_value
argument_list|)
operator|=
name|TYPE_ALIGN
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_MODE
argument_list|(
name|new_value
argument_list|)
operator|=
name|TYPE_MODE
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_METHOD_BASETYPE
argument_list|(
name|t
argument_list|)
condition|)
name|TYPE_METHOD_BASETYPE
argument_list|(
name|new_value
argument_list|)
operator|=
name|tsubst
argument_list|(
name|TYPE_METHOD_BASETYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|nargs
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
comment|/* Need to generate hash value.  */
name|my_friendly_abort
argument_list|(
literal|84
argument_list|)
expr_stmt|;
block|}
name|new_value
operator|=
name|build_type_variant
argument_list|(
name|new_value
argument_list|,
name|TYPE_READONLY
argument_list|(
name|t
argument_list|)
argument_list|,
name|TYPE_VOLATILE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|new_value
return|;
block|}
case|case
name|ARRAY_TYPE
case|:
block|{
name|tree
name|domain
init|=
name|tsubst
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|nargs
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
name|tree
name|r
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|&&
name|domain
operator|==
name|TYPE_DOMAIN
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|t
return|;
name|r
operator|=
name|build_cplus_array_type
argument_list|(
name|type
argument_list|,
name|domain
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
case|case
name|UNINSTANTIATED_P_TYPE
case|:
block|{
name|int
name|nparms
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|DECL_TEMPLATE_PARMS
argument_list|(
name|UPT_TEMPLATE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|argvec
init|=
name|make_tree_vec
argument_list|(
name|nparms
argument_list|)
decl_stmt|;
name|tree
name|parmvec
init|=
name|UPT_PARMS
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|tree
name|id
decl_stmt|,
name|rt
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nparms
condition|;
name|i
operator|++
control|)
name|TREE_VEC_ELT
argument_list|(
name|argvec
argument_list|,
name|i
argument_list|)
operator|=
name|tsubst
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|parmvec
argument_list|,
name|i
argument_list|)
argument_list|,
name|args
argument_list|,
name|nargs
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|id
operator|=
name|lookup_template_class
argument_list|(
name|DECL_NAME
argument_list|(
name|UPT_TEMPLATE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
name|argvec
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IDENTIFIER_HAS_TYPE_VALUE
argument_list|(
name|id
argument_list|)
condition|)
block|{
name|instantiate_class_template
argument_list|(
name|id
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* set up pending_classes */
name|add_pending_template
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|TYPE_MAIN_VARIANT
argument_list|(
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|id
argument_list|)
argument_list|)
operator|=
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
name|rt
operator|=
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|id
argument_list|)
expr_stmt|;
comment|/* kung: this part handles nested type in template definition */
if|if
condition|(
operator|!
name|ANON_AGGRNAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|rt
operator|=
name|search_nested_type_in_tmpl
argument_list|(
name|rt
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
return|return
name|build_type_variant
argument_list|(
name|rt
argument_list|,
name|TYPE_READONLY
argument_list|(
name|t
argument_list|)
argument_list|,
name|TYPE_VOLATILE
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
block|}
case|case
name|MINUS_EXPR
case|:
case|case
name|PLUS_EXPR
case|:
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|tsubst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|nargs
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|tsubst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|args
argument_list|,
name|nargs
argument_list|,
name|in_decl
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|NEGATE_EXPR
case|:
case|case
name|NOP_EXPR
case|:
return|return
name|fold
argument_list|(
name|build1
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|tsubst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|nargs
argument_list|,
name|in_decl
argument_list|)
argument_list|)
argument_list|)
return|;
default|default:
name|sorry
argument_list|(
literal|"use of `%s' in function template"
argument_list|,
name|tree_code_name
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|t
argument_list|)
index|]
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
end_block

begin_function
name|tree
name|instantiate_template
parameter_list|(
name|tmpl
parameter_list|,
name|targ_ptr
parameter_list|)
name|tree
name|tmpl
decl_stmt|,
decl|*
name|targ_ptr
decl_stmt|;
end_function

begin_block
block|{
name|tree
name|targs
decl_stmt|,
name|fndecl
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
name|struct
name|pending_inline
modifier|*
name|p
decl_stmt|;
name|struct
name|template_info
modifier|*
name|t
decl_stmt|;
name|struct
name|obstack
modifier|*
name|old_fmp_obstack
decl_stmt|;
specifier|extern
name|struct
name|obstack
modifier|*
name|function_maybepermanent_obstack
decl_stmt|;
name|push_obstacks
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|&
name|permanent_obstack
argument_list|)
expr_stmt|;
name|old_fmp_obstack
operator|=
name|function_maybepermanent_obstack
expr_stmt|;
name|function_maybepermanent_obstack
operator|=
operator|&
name|permanent_obstack
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|tmpl
argument_list|)
operator|==
name|TEMPLATE_DECL
argument_list|,
literal|283
argument_list|)
expr_stmt|;
name|len
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|DECL_TEMPLATE_PARMS
argument_list|(
name|tmpl
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|fndecl
operator|=
name|DECL_TEMPLATE_INSTANTIATIONS
argument_list|(
name|tmpl
argument_list|)
init|;
name|fndecl
condition|;
name|fndecl
operator|=
name|TREE_CHAIN
argument_list|(
name|fndecl
argument_list|)
control|)
block|{
name|tree
modifier|*
name|t1
init|=
operator|&
name|TREE_VEC_ELT
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|fndecl
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
name|len
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|t1
index|[
name|i
index|]
operator|!=
name|targ_ptr
index|[
name|i
index|]
condition|)
goto|goto
name|no_match
goto|;
comment|/* Here, we have a match.  */
name|fndecl
operator|=
name|TREE_VALUE
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
goto|goto
name|exit
goto|;
name|no_match
label|:
empty_stmt|;
block|}
name|targs
operator|=
name|make_tree_vec
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|i
operator|=
name|len
expr_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
name|TREE_VEC_ELT
argument_list|(
name|targs
argument_list|,
name|i
argument_list|)
operator|=
name|targ_ptr
index|[
name|i
index|]
expr_stmt|;
comment|/* substitute template parameters */
name|fndecl
operator|=
name|tsubst
argument_list|(
name|DECL_RESULT
argument_list|(
name|tmpl
argument_list|)
argument_list|,
name|targ_ptr
argument_list|,
name|TREE_VEC_LENGTH
argument_list|(
name|targs
argument_list|)
argument_list|,
name|tmpl
argument_list|)
expr_stmt|;
if|if
condition|(
name|fndecl
operator|==
name|error_mark_node
condition|)
goto|goto
name|exit
goto|;
comment|/* If it's a static member fn in the template, we need to change it      into a FUNCTION_TYPE and chop off its this pointer.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|DECL_RESULT
argument_list|(
name|tmpl
argument_list|)
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
operator|&&
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
name|tree
name|olddecl
init|=
name|DECL_RESULT
argument_list|(
name|tmpl
argument_list|)
decl_stmt|;
name|revert_static_member_fn
argument_list|(
operator|&
name|DECL_RESULT
argument_list|(
name|tmpl
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Chop off the this pointer that grokclassfn so kindly added 	 for us (it didn't know yet if the fn was static or not).  */
name|DECL_ARGUMENTS
argument_list|(
name|olddecl
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|olddecl
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|DECL_TEMPLATE_INFO
argument_list|(
name|tmpl
argument_list|)
expr_stmt|;
comment|/* If we have a preexisting version of this function, don't expand      the template version, use the other instead.  */
if|if
condition|(
name|DECL_INLINE
argument_list|(
name|fndecl
argument_list|)
operator|&&
name|DECL_SAVED_INSNS
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
name|SET_DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
expr|struct
name|pending_inline
operator|*
operator|)
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|->
name|text
condition|)
block|{
name|SET_DECL_IMPLICIT_INSTANTIATION
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
expr|struct
name|pending_inline
operator|*
operator|)
name|permalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pending_inline
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|parm_vec
operator|=
name|t
operator|->
name|parm_vec
expr_stmt|;
name|p
operator|->
name|bindings
operator|=
name|targs
expr_stmt|;
name|p
operator|->
name|can_free
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|deja_vu
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|buf
operator|=
name|t
operator|->
name|text
expr_stmt|;
name|p
operator|->
name|len
operator|=
name|t
operator|->
name|length
expr_stmt|;
name|p
operator|->
name|fndecl
operator|=
name|fndecl
expr_stmt|;
block|{
name|int
name|l
init|=
name|lineno
decl_stmt|;
name|char
modifier|*
name|f
init|=
name|input_filename
decl_stmt|;
name|lineno
operator|=
name|p
operator|->
name|lineno
operator|=
name|t
operator|->
name|lineno
expr_stmt|;
name|input_filename
operator|=
name|p
operator|->
name|filename
operator|=
name|t
operator|->
name|filename
expr_stmt|;
name|extract_interface_info
argument_list|()
expr_stmt|;
if|if
condition|(
name|interface_unknown
operator|&&
name|flag_external_templates
operator|&&
operator|!
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|tmpl
argument_list|)
condition|)
name|warn_if_unknown_interface
argument_list|()
expr_stmt|;
if|if
condition|(
name|interface_unknown
operator|||
operator|!
name|flag_external_templates
condition|)
name|p
operator|->
name|interface
operator|=
literal|1
expr_stmt|;
comment|/* unknown */
else|else
name|p
operator|->
name|interface
operator|=
name|interface_only
condition|?
literal|0
else|:
literal|2
expr_stmt|;
name|lineno
operator|=
name|l
expr_stmt|;
name|input_filename
operator|=
name|f
expr_stmt|;
name|extract_interface_info
argument_list|()
expr_stmt|;
block|}
block|}
else|else
name|p
operator|=
operator|(
expr|struct
name|pending_inline
operator|*
operator|)
literal|0
expr_stmt|;
name|DECL_TEMPLATE_INSTANTIATIONS
argument_list|(
name|tmpl
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|targs
argument_list|,
name|fndecl
argument_list|,
name|DECL_TEMPLATE_INSTANTIATIONS
argument_list|(
name|tmpl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
operator|(
expr|struct
name|pending_inline
operator|*
operator|)
literal|0
condition|)
block|{
comment|/* do nothing */
block|}
elseif|else
if|if
condition|(
name|DECL_INLINE
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
name|DECL_PENDING_INLINE_INFO
argument_list|(
name|fndecl
argument_list|)
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|pending_inlines
expr_stmt|;
name|pending_inlines
operator|=
name|p
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|next
operator|=
name|pending_template_expansions
expr_stmt|;
name|pending_template_expansions
operator|=
name|p
expr_stmt|;
block|}
name|exit
label|:
name|function_maybepermanent_obstack
operator|=
name|old_fmp_obstack
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
return|return
name|fndecl
return|;
block|}
end_block

begin_comment
comment|/* classlevel should now never be true.  jason 4/12/94 */
end_comment

begin_function
name|void
name|undo_template_name_overload
parameter_list|(
name|id
parameter_list|,
name|classlevel
parameter_list|)
name|tree
name|id
decl_stmt|;
name|int
name|classlevel
decl_stmt|;
block|{
name|tree
name|template
decl_stmt|;
name|template
operator|=
name|IDENTIFIER_TEMPLATE
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|template
condition|)
return|return;
if|#
directive|if
literal|0
comment|/* not yet, should get fixed properly later */
block|poplevel (0, 0, 0);
endif|#
directive|endif
if|#
directive|if
literal|1
comment|/* XXX */
comment|/* This was a botch... See `overload_template_name' just below.  */
if|if
condition|(
operator|!
name|classlevel
condition|)
name|poplevel
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* classlevel should now never be true.  jason 4/12/94 */
end_comment

begin_function
name|void
name|overload_template_name
parameter_list|(
name|id
parameter_list|,
name|classlevel
parameter_list|)
name|tree
name|id
decl_stmt|;
name|int
name|classlevel
decl_stmt|;
block|{
name|tree
name|template
decl_stmt|,
name|t
decl_stmt|,
name|decl
decl_stmt|;
name|struct
name|template_info
modifier|*
name|tinfo
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|==
name|IDENTIFIER_NODE
argument_list|,
literal|284
argument_list|)
expr_stmt|;
name|template
operator|=
name|IDENTIFIER_TEMPLATE
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|template
condition|)
return|return;
name|template
operator|=
name|TREE_PURPOSE
argument_list|(
name|template
argument_list|)
expr_stmt|;
name|tinfo
operator|=
name|DECL_TEMPLATE_INFO
argument_list|(
name|template
argument_list|)
expr_stmt|;
name|template
operator|=
name|DECL_NAME
argument_list|(
name|template
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|template
operator|!=
name|NULL_TREE
argument_list|,
literal|285
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
comment|/* XXX */
comment|/* This was a botch... names of templates do not get their own private      scopes.  Rather, they should go into the binding level already created      by push_template_decls.  Except that there isn't one of those for      specializations.  */
if|if
condition|(
operator|!
name|classlevel
condition|)
block|{
name|pushlevel
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|declare_pseudo_global_level
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
name|t
operator|=
name|xref_tag
argument_list|(
name|tinfo
operator|->
name|aggr
argument_list|,
name|id
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|UNINSTANTIATED_P_TYPE
argument_list|,
literal|286
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|template
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* fix this later */
comment|/* We don't want to call here if the work has already been done.  */
block|t = (classlevel        ? IDENTIFIER_CLASS_VALUE (template)        : IDENTIFIER_LOCAL_VALUE (template));   if (t&& TREE_CODE (t) == TYPE_DECL&& TREE_TYPE (t) == t)     my_friendly_abort (85);
endif|#
directive|endif
if|if
condition|(
name|classlevel
condition|)
name|pushdecl_class_level
argument_list|(
name|decl
argument_list|)
expr_stmt|;
else|else
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* This seems bogus to me; if it isn't, explain why.  (jason) */
comment|/* Fake this for now, just to make dwarfout.c happy.  It will have to      be done in a proper way later on.  */
block|DECL_CONTEXT (decl) = t;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* NAME is the IDENTIFIER value of a PRE_PARSED_CLASS_DECL. */
end_comment

begin_function
name|void
name|end_template_instantiation
parameter_list|(
name|name
parameter_list|)
name|tree
name|name
decl_stmt|;
block|{
specifier|extern
name|struct
name|pending_input
modifier|*
name|to_be_restored
decl_stmt|;
name|tree
name|t
decl_stmt|,
name|decl
decl_stmt|;
name|processing_template_defn
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|flag_external_templates
condition|)
name|interface_unknown
operator|--
expr_stmt|;
comment|/* Restore the old parser input state.  */
if|if
condition|(
name|yychar
operator|==
name|YYEMPTY
condition|)
name|yychar
operator|=
name|yylex
argument_list|()
expr_stmt|;
if|if
condition|(
name|yychar
operator|!=
name|END_OF_SAVED_INPUT
condition|)
name|error
argument_list|(
literal|"parse error at end of class template"
argument_list|)
expr_stmt|;
else|else
block|{
name|restore_pending_input
argument_list|(
name|to_be_restored
argument_list|)
expr_stmt|;
name|to_be_restored
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Our declarations didn't get stored in the global slot, since      there was a (supposedly tags-transparent) scope in between.  */
name|t
operator|=
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|t
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
literal|'t'
argument_list|,
literal|287
argument_list|)
expr_stmt|;
name|SET_CLASSTYPE_IMPLICIT_INSTANTIATION
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Make methods of template classes static, unless      -fexternal-templates is given.  */
if|if
condition|(
operator|!
name|flag_external_templates
condition|)
name|SET_CLASSTYPE_INTERFACE_UNKNOWN
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|decl
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
argument_list|,
literal|288
argument_list|)
expr_stmt|;
name|undo_template_name_overload
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t
operator|=
name|IDENTIFIER_TEMPLATE
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|pop_template_decls
argument_list|(
name|DECL_TEMPLATE_PARMS
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* This will fix up the type-value field.  */
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|pop_from_top_level
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|DWARF_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|DWARF_DEBUG
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
comment|/* We just completed the definition of a new file-scope type, 	 so we can go ahead and output debug-info for it now.  */
name|TYPE_STUB_DECL
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
name|decl
expr_stmt|;
name|rest_of_type_compilation
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DWARF_DEBUGGING_INFO */
comment|/* Restore interface/implementation settings.	 */
name|extract_interface_info
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Store away the text of an template.  */
end_comment

begin_function
name|void
name|reinit_parse_for_template
parameter_list|(
name|yychar
parameter_list|,
name|d1
parameter_list|,
name|d2
parameter_list|)
name|int
name|yychar
decl_stmt|;
name|tree
name|d1
decl_stmt|,
name|d2
decl_stmt|;
block|{
name|struct
name|template_info
modifier|*
name|template_info
decl_stmt|;
specifier|extern
name|struct
name|obstack
name|inline_text_obstack
decl_stmt|;
comment|/* see comment in lex.c */
if|if
condition|(
name|d2
operator|==
name|NULL_TREE
operator|||
name|d2
operator|==
name|error_mark_node
condition|)
block|{
name|lose
label|:
comment|/* @@ Should use temp obstack, and discard results.  */
name|reinit_parse_for_block
argument_list|(
name|yychar
argument_list|,
operator|&
name|inline_text_obstack
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|d2
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|d2
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|d2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d2
condition|)
goto|goto
name|lose
goto|;
name|template_info
operator|=
name|DECL_TEMPLATE_INFO
argument_list|(
name|d2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|template_info
condition|)
block|{
name|template_info
operator|=
operator|(
expr|struct
name|template_info
operator|*
operator|)
name|permalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|template_info
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|template_info
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|template_info
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_TEMPLATE_INFO
argument_list|(
name|d2
argument_list|)
operator|=
name|template_info
expr_stmt|;
block|}
name|template_info
operator|->
name|filename
operator|=
name|input_filename
expr_stmt|;
name|template_info
operator|->
name|lineno
operator|=
name|lineno
expr_stmt|;
name|reinit_parse_for_block
argument_list|(
name|yychar
argument_list|,
operator|&
name|inline_text_obstack
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|template_info
operator|->
name|text
operator|=
name|obstack_base
argument_list|(
operator|&
name|inline_text_obstack
argument_list|)
expr_stmt|;
name|template_info
operator|->
name|length
operator|=
name|obstack_object_size
argument_list|(
operator|&
name|inline_text_obstack
argument_list|)
expr_stmt|;
name|obstack_finish
argument_list|(
operator|&
name|inline_text_obstack
argument_list|)
expr_stmt|;
name|template_info
operator|->
name|parm_vec
operator|=
name|d1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Type unification.     We have a function template signature with one or more references to    template parameters, and a parameter list we wish to fit to this    template.  If possible, produce a list of parameters for the template    which will cause it to fit the supplied parameter list.     Return zero for success, 2 for an incomplete match that doesn't resolve    all the types, and 1 for complete failure.  An error message will be    printed only for an incomplete match.     TPARMS[NTPARMS] is an array of template parameter types;    TARGS[NTPARMS] is the array of template parameter values.  PARMS is    the function template's signature (using TEMPLATE_PARM_IDX nodes),    and ARGS is the argument list we're trying to match against it.     If SUBR is 1, we're being called recursively (to unify the arguments of    a function or method parameter of a function template), so don't zero    out targs and don't fail on an incomplete match. */
end_comment

begin_function
name|int
name|type_unification
parameter_list|(
name|tparms
parameter_list|,
name|targs
parameter_list|,
name|parms
parameter_list|,
name|args
parameter_list|,
name|nsubsts
parameter_list|,
name|subr
parameter_list|)
name|tree
name|tparms
decl_stmt|,
decl|*
name|targs
decl_stmt|,
name|parms
decl_stmt|,
name|args
decl_stmt|;
end_function

begin_decl_stmt
name|int
modifier|*
name|nsubsts
decl_stmt|,
name|subr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|tree
name|parm
decl_stmt|,
name|arg
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|ntparms
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|tparms
argument_list|)
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|tparms
argument_list|)
operator|==
name|TREE_VEC
argument_list|,
literal|289
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|parms
argument_list|)
operator|==
name|TREE_LIST
argument_list|,
literal|290
argument_list|)
expr_stmt|;
comment|/* ARGS could be NULL (via a call from parse.y to      build_x_function_call).  */
if|if
condition|(
name|args
condition|)
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|args
argument_list|)
operator|==
name|TREE_LIST
argument_list|,
literal|291
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|ntparms
operator|>
literal|0
argument_list|,
literal|292
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|subr
condition|)
name|bzero
argument_list|(
name|targs
argument_list|,
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
operator|*
name|ntparms
argument_list|)
expr_stmt|;
while|while
condition|(
name|parms
operator|&&
name|parms
operator|!=
name|void_list_node
operator|&&
name|args
operator|&&
name|args
operator|!=
name|void_list_node
condition|)
block|{
name|parm
operator|=
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
expr_stmt|;
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
expr_stmt|;
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|args
operator|=
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|error_mark_node
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|arg
operator|==
name|unknown_type_node
condition|)
return|return
literal|1
return|;
if|#
directive|if
literal|0
block|if (TREE_CODE (arg) == VAR_DECL) 	arg = TREE_TYPE (arg);       else if (TREE_CODE_CLASS (TREE_CODE (arg)) == 'e') 	arg = TREE_TYPE (arg);
else|#
directive|else
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|!=
literal|'t'
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
operator|!=
name|NULL_TREE
argument_list|,
literal|293
argument_list|)
expr_stmt|;
name|arg
operator|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|arg
operator|=
name|build_pointer_type
argument_list|(
name|arg
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|ntparms
argument_list|,
name|parm
argument_list|,
name|arg
argument_list|,
name|nsubsts
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
literal|1
case|:
return|return
literal|1
return|;
block|}
block|}
comment|/* Fail if we've reached the end of the parm list, and more args      are present, and the parm list isn't variadic.  */
if|if
condition|(
name|args
operator|&&
name|args
operator|!=
name|void_list_node
operator|&&
name|parms
operator|==
name|void_list_node
condition|)
return|return
literal|1
return|;
comment|/* Fail if parms are left and they don't have default values.	 */
if|if
condition|(
name|parms
operator|&&
name|parms
operator|!=
name|void_list_node
operator|&&
name|TREE_PURPOSE
argument_list|(
name|parms
argument_list|)
operator|==
name|NULL_TREE
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|subr
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntparms
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|targs
index|[
name|i
index|]
condition|)
block|{
name|error
argument_list|(
literal|"incomplete type unification"
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Tail recursion is your friend.  */
end_comment

begin_function
specifier|static
name|int
name|unify
parameter_list|(
name|tparms
parameter_list|,
name|targs
parameter_list|,
name|ntparms
parameter_list|,
name|parm
parameter_list|,
name|arg
parameter_list|,
name|nsubsts
parameter_list|)
name|tree
name|tparms
decl_stmt|,
decl|*
name|targs
decl_stmt|,
name|parm
decl_stmt|,
name|arg
decl_stmt|;
end_function

begin_decl_stmt
name|int
modifier|*
name|nsubsts
decl_stmt|,
name|ntparms
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|idx
decl_stmt|;
comment|/* I don't think this will do the right thing with respect to types.      But the only case I've seen it in so far has been array bounds, where      signedness is the only information lost, and I think that will be      okay.  */
while|while
condition|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|NOP_EXPR
condition|)
name|parm
operator|=
name|TREE_OPERAND
argument_list|(
name|parm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|error_mark_node
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|arg
operator|==
name|unknown_type_node
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|arg
operator|==
name|parm
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|arg
operator|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
condition|)
block|{
case|case
name|TEMPLATE_TYPE_PARM
case|:
operator|(
operator|*
name|nsubsts
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|TEMPLATE_TYPE_TPARMLIST
argument_list|(
name|parm
argument_list|)
operator|!=
name|tparms
condition|)
block|{
name|error
argument_list|(
literal|"mixed template headers?!"
argument_list|)
expr_stmt|;
name|my_friendly_abort
argument_list|(
literal|86
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|idx
operator|=
name|TEMPLATE_TYPE_IDX
argument_list|(
name|parm
argument_list|)
expr_stmt|;
comment|/* Simple cases: Value already set, does match or doesn't.  */
if|if
condition|(
name|targs
index|[
name|idx
index|]
operator|==
name|arg
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|targs
index|[
name|idx
index|]
condition|)
block|{
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|targs
index|[
name|idx
index|]
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|arg
argument_list|)
condition|)
comment|/* allow different parms to have different cv-qualifiers */
empty_stmt|;
else|else
return|return
literal|1
return|;
block|}
comment|/* Check for mixed types and values.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|tparms
argument_list|,
name|idx
argument_list|)
argument_list|)
operator|!=
name|IDENTIFIER_NODE
condition|)
return|return
literal|1
return|;
comment|/* Allow trivial conversions.  */
if|if
condition|(
name|TYPE_READONLY
argument_list|(
name|parm
argument_list|)
operator|<
name|TYPE_READONLY
argument_list|(
name|arg
argument_list|)
operator|||
name|TYPE_VOLATILE
argument_list|(
name|parm
argument_list|)
operator|<
name|TYPE_VOLATILE
argument_list|(
name|arg
argument_list|)
condition|)
return|return
literal|1
return|;
name|targs
index|[
name|idx
index|]
operator|=
name|arg
expr_stmt|;
return|return
literal|0
return|;
case|case
name|TEMPLATE_CONST_PARM
case|:
operator|(
operator|*
name|nsubsts
operator|)
operator|++
expr_stmt|;
name|idx
operator|=
name|TEMPLATE_CONST_IDX
argument_list|(
name|parm
argument_list|)
expr_stmt|;
if|if
condition|(
name|targs
index|[
name|idx
index|]
operator|==
name|arg
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|targs
index|[
name|idx
index|]
condition|)
block|{
name|tree
name|t
init|=
name|targs
index|[
name|idx
index|]
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
condition|)
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
condition|)
block|{
case|case
name|INTEGER_CST
case|:
if|if
condition|(
name|tree_int_cst_equal
argument_list|(
name|t
argument_list|,
name|arg
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
name|REAL_CST
case|:
if|if
condition|(
name|REAL_VALUES_EQUAL
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|t
argument_list|)
argument_list|,
name|TREE_REAL_CST
argument_list|(
name|arg
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
comment|/* STRING_CST values are not valid template const parms.  */
default|default:
empty_stmt|;
block|}
name|my_friendly_abort
argument_list|(
literal|87
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/*	else if (typeof arg != tparms[idx]) 	return 1;*/
name|targs
index|[
name|idx
index|]
operator|=
name|copy_to_permanent
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|POINTER_TYPE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
return|return
literal|1
return|;
return|return
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|ntparms
argument_list|,
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|nsubsts
argument_list|)
return|;
case|case
name|REFERENCE_TYPE
case|:
return|return
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|ntparms
argument_list|,
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|arg
argument_list|,
name|nsubsts
argument_list|)
return|;
case|case
name|ARRAY_TYPE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|ARRAY_TYPE
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|ntparms
argument_list|,
name|TYPE_DOMAIN
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TYPE_DOMAIN
argument_list|(
name|arg
argument_list|)
argument_list|,
name|nsubsts
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
return|return
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|ntparms
argument_list|,
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|nsubsts
argument_list|)
return|;
case|case
name|REAL_TYPE
case|:
case|case
name|INTEGER_TYPE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|INTEGER_TYPE
condition|)
block|{
if|if
condition|(
name|TYPE_MIN_VALUE
argument_list|(
name|parm
argument_list|)
operator|&&
name|TYPE_MIN_VALUE
argument_list|(
name|arg
argument_list|)
operator|&&
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|ntparms
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|nsubsts
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TYPE_MAX_VALUE
argument_list|(
name|parm
argument_list|)
operator|&&
name|TYPE_MAX_VALUE
argument_list|(
name|arg
argument_list|)
operator|&&
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|ntparms
argument_list|,
name|TYPE_MAX_VALUE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TYPE_MAX_VALUE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|nsubsts
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
comment|/* As far as unification is concerned, this wins.	 Later checks 	 will invalidate it if necessary.  */
return|return
literal|0
return|;
comment|/* Types INTEGER_CST and MINUS_EXPR can come from array bounds.  */
case|case
name|INTEGER_CST
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
literal|1
return|;
return|return
operator|!
name|tree_int_cst_equal
argument_list|(
name|parm
argument_list|,
name|arg
argument_list|)
return|;
case|case
name|MINUS_EXPR
case|:
block|{
name|tree
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|t1
operator|=
name|TREE_OPERAND
argument_list|(
name|parm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t2
operator|=
name|TREE_OPERAND
argument_list|(
name|parm
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|!=
name|TEMPLATE_CONST_PARM
condition|)
return|return
literal|1
return|;
return|return
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|ntparms
argument_list|,
name|t1
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|arg
argument_list|,
name|t2
argument_list|)
argument_list|)
argument_list|,
name|nsubsts
argument_list|)
return|;
block|}
case|case
name|TREE_VEC
case|:
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|TREE_VEC
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TREE_VEC_LENGTH
argument_list|(
name|parm
argument_list|)
operator|!=
name|TREE_VEC_LENGTH
argument_list|(
name|arg
argument_list|)
condition|)
return|return
literal|1
return|;
for|for
control|(
name|i
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|parm
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|ntparms
argument_list|,
name|TREE_VEC_ELT
argument_list|(
name|parm
argument_list|,
name|i
argument_list|)
argument_list|,
name|TREE_VEC_ELT
argument_list|(
name|arg
argument_list|,
name|i
argument_list|)
argument_list|,
name|nsubsts
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
case|case
name|UNINSTANTIATED_P_TYPE
case|:
block|{
name|tree
name|a
decl_stmt|;
comment|/* Unification of something that is not a template fails. (mrs) */
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|arg
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
name|a
operator|=
name|IDENTIFIER_TEMPLATE
argument_list|(
name|TYPE_IDENTIFIER
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Unification of something that is not a template fails. (mrs) */
if|if
condition|(
name|a
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|UPT_TEMPLATE
argument_list|(
name|parm
argument_list|)
operator|!=
name|TREE_PURPOSE
argument_list|(
name|a
argument_list|)
condition|)
comment|/* different templates */
return|return
literal|1
return|;
return|return
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|ntparms
argument_list|,
name|UPT_PARMS
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|a
argument_list|)
argument_list|,
name|nsubsts
argument_list|)
return|;
block|}
case|case
name|RECORD_TYPE
case|:
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|parm
argument_list|)
condition|)
return|return
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|ntparms
argument_list|,
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|arg
argument_list|,
name|nsubsts
argument_list|)
return|;
comment|/* Allow trivial conversions.  */
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|parm
argument_list|)
operator|!=
name|TYPE_MAIN_VARIANT
argument_list|(
name|arg
argument_list|)
operator|||
name|TYPE_READONLY
argument_list|(
name|parm
argument_list|)
operator|<
name|TYPE_READONLY
argument_list|(
name|arg
argument_list|)
operator|||
name|TYPE_VOLATILE
argument_list|(
name|parm
argument_list|)
operator|<
name|TYPE_VOLATILE
argument_list|(
name|arg
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
case|case
name|METHOD_TYPE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|METHOD_TYPE
condition|)
return|return
literal|1
return|;
goto|goto
name|check_args
goto|;
case|case
name|FUNCTION_TYPE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|FUNCTION_TYPE
condition|)
return|return
literal|1
return|;
name|check_args
label|:
return|return
name|type_unification
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|arg
argument_list|)
argument_list|,
name|nsubsts
argument_list|,
literal|1
argument_list|)
return|;
case|case
name|OFFSET_TYPE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|OFFSET_TYPE
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|ntparms
argument_list|,
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|nsubsts
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|ntparms
argument_list|,
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|nsubsts
argument_list|)
return|;
default|default:
name|sorry
argument_list|(
literal|"use of `%s' in template type unification"
argument_list|,
name|tree_code_name
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
index|]
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
end_block

begin_escape
end_escape

begin_undef
undef|#
directive|undef
name|DEBUG
end_undef

begin_function
name|int
name|do_pending_expansions
parameter_list|()
block|{
name|struct
name|pending_inline
modifier|*
name|i
decl_stmt|,
modifier|*
name|new_list
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|pending_template_expansions
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n\n\t\t IN DO_PENDING_EXPANSIONS\n\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|i
operator|=
name|pending_template_expansions
expr_stmt|;
while|while
condition|(
name|i
condition|)
block|{
name|tree
name|context
decl_stmt|;
name|struct
name|pending_inline
modifier|*
name|next
init|=
name|i
operator|->
name|next
decl_stmt|;
name|tree
name|t
init|=
name|i
operator|->
name|fndecl
decl_stmt|;
name|int
name|decision
init|=
literal|0
decl_stmt|;
define|#
directive|define
name|DECIDE
parameter_list|(
name|N
parameter_list|)
value|do {decision=(N); goto decided;} while(0)
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|VAR_DECL
argument_list|,
literal|294
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_ASM_WRITTEN
argument_list|(
name|t
argument_list|)
condition|)
name|DECIDE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_EXPLICIT_INSTANTIATION
argument_list|(
name|t
argument_list|)
condition|)
name|DECIDE
argument_list|(
operator|!
name|DECL_EXTERNAL
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|flag_implicit_templates
condition|)
name|DECIDE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* If it's a method, let the class type decide it. 	 @@ What if the method template is in a separate file? 	 Maybe both file contexts should be taken into account? 	 Maybe only do this if i->interface == 1 (unknown)?  */
name|context
operator|=
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|context
argument_list|)
argument_list|)
operator|==
literal|'t'
condition|)
block|{
comment|/* I'm interested in the context of this version of the function, 	     not the original virtual declaration.  */
name|context
operator|=
name|DECL_CLASS_CONTEXT
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* If `unknown', we might want a static copy. 	     If `implementation', we want a global one. 	     If `interface', ext ref.  */
if|if
condition|(
name|CLASSTYPE_INTERFACE_KNOWN
argument_list|(
name|context
argument_list|)
condition|)
name|DECIDE
argument_list|(
operator|!
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|context
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* This doesn't get us stuff needed only by the file initializer.  */
block|DECIDE (TREE_USED (t));
else|#
directive|else
comment|/* This compiles too much stuff, but that's probably better in 	 most cases than never compiling the stuff we need.  */
name|DECIDE
argument_list|(
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|i
operator|->
name|interface
operator|==
literal|1
condition|)
name|DECIDE
argument_list|(
name|TREE_USED
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|DECIDE
argument_list|(
name|i
operator|->
name|interface
argument_list|)
expr_stmt|;
name|decided
label|:
ifdef|#
directive|ifdef
name|DEBUG
name|print_node_brief
argument_list|(
name|stderr
argument_list|,
name|decision
condition|?
literal|"yes: "
else|:
literal|"no: "
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t%s\n"
argument_list|,
operator|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|t
argument_list|)
condition|?
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|decision
condition|)
block|{
name|i
operator|->
name|next
operator|=
name|pending_inlines
expr_stmt|;
name|pending_inlines
operator|=
name|i
expr_stmt|;
block|}
else|else
block|{
name|i
operator|->
name|next
operator|=
name|new_list
expr_stmt|;
name|new_list
operator|=
name|i
expr_stmt|;
block|}
name|i
operator|=
name|next
expr_stmt|;
block|}
name|pending_template_expansions
operator|=
name|new_list
expr_stmt|;
if|if
condition|(
operator|!
name|pending_inlines
condition|)
return|return
literal|0
return|;
name|do_pending_inlines
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_struct
struct|struct
name|pending_template
block|{
name|struct
name|pending_template
modifier|*
name|next
decl_stmt|;
name|tree
name|id
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|pending_template
modifier|*
name|pending_templates
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|do_pending_templates
parameter_list|()
block|{
name|struct
name|pending_template
modifier|*
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
name|pending_templates
init|;
name|t
condition|;
name|t
operator|=
name|t
operator|->
name|next
control|)
block|{
name|instantiate_class_template
argument_list|(
name|t
operator|->
name|id
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|t
operator|=
name|pending_templates
init|;
name|t
condition|;
name|t
operator|=
name|pending_templates
control|)
block|{
name|pending_templates
operator|=
name|t
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|add_pending_template
parameter_list|(
name|pt
parameter_list|)
name|tree
name|pt
decl_stmt|;
block|{
name|struct
name|pending_template
modifier|*
name|p
decl_stmt|;
name|p
operator|=
operator|(
expr|struct
name|pending_template
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pending_template
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|pending_templates
expr_stmt|;
name|pending_templates
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|id
operator|=
name|pt
expr_stmt|;
block|}
end_function

begin_comment
comment|/* called from the parser.  */
end_comment

begin_function
name|void
name|do_function_instantiation
parameter_list|(
name|declspecs
parameter_list|,
name|declarator
parameter_list|,
name|storage
parameter_list|)
name|tree
name|declspecs
decl_stmt|,
name|declarator
decl_stmt|,
name|storage
decl_stmt|;
block|{
name|tree
name|decl
init|=
name|grokdeclarator
argument_list|(
name|declarator
argument_list|,
name|declspecs
argument_list|,
name|NORMAL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|name
init|=
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|tree
name|fn
init|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|tree
name|result
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|fn
condition|)
block|{
for|for
control|(
name|fn
operator|=
name|get_first_fn
argument_list|(
name|fn
argument_list|)
init|;
name|fn
condition|;
name|fn
operator|=
name|DECL_CHAIN
argument_list|(
name|fn
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
name|int
name|ntparms
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|DECL_TEMPLATE_PARMS
argument_list|(
name|fn
argument_list|)
argument_list|)
decl_stmt|;
name|tree
modifier|*
name|targs
init|=
operator|(
name|tree
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
operator|*
name|ntparms
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|dummy
decl_stmt|;
name|i
operator|=
name|type_unification
argument_list|(
name|DECL_TEMPLATE_PARMS
argument_list|(
name|fn
argument_list|)
argument_list|,
name|targs
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
operator|&
name|dummy
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|result
condition|)
name|cp_error
argument_list|(
literal|"ambiguous template instantiation for `%D' requested"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
name|instantiate_template
argument_list|(
name|fn
argument_list|,
name|targs
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|result
condition|)
name|cp_error
argument_list|(
literal|"no matching template for `%D' found"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_external_templates
condition|)
return|return;
if|if
condition|(
name|DECL_EXPLICIT_INSTANTIATION
argument_list|(
name|result
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|result
argument_list|)
condition|)
return|return;
name|SET_DECL_EXPLICIT_INSTANTIATION
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|storage
operator|==
name|NULL_TREE
condition|)
name|DECL_EXTERNAL
argument_list|(
name|result
argument_list|)
operator|=
name|DECL_INLINE
argument_list|(
name|result
argument_list|)
operator|&&
operator|!
name|flag_implement_inlines
expr_stmt|;
elseif|else
if|if
condition|(
name|storage
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_EXTERN
index|]
condition|)
name|DECL_EXTERNAL
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
name|cp_error
argument_list|(
literal|"storage class `%D' applied to template instantiation"
argument_list|,
name|storage
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|do_type_instantiation
parameter_list|(
name|name
parameter_list|,
name|storage
parameter_list|)
name|tree
name|name
decl_stmt|,
name|storage
decl_stmt|;
block|{
name|tree
name|t
init|=
name|TREE_TYPE
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|int
name|extern_p
decl_stmt|;
if|if
condition|(
name|flag_external_templates
condition|)
return|return;
if|if
condition|(
name|CLASSTYPE_EXPLICIT_INSTANTIATION
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|t
argument_list|)
condition|)
return|return;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|cp_error
argument_list|(
literal|"explicit instantiation of `%#T' before definition of template"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|storage
operator|==
name|NULL_TREE
condition|)
name|extern_p
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|storage
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_EXTERN
index|]
condition|)
name|extern_p
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|cp_error
argument_list|(
literal|"storage class `%D' applied to template instantiation"
argument_list|,
name|storage
argument_list|)
expr_stmt|;
name|extern_p
operator|=
literal|0
expr_stmt|;
block|}
name|SET_CLASSTYPE_EXPLICIT_INSTANTIATION
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|CLASSTYPE_VTABLE_NEEDS_WRITING
argument_list|(
name|t
argument_list|)
operator|=
operator|!
name|extern_p
expr_stmt|;
name|SET_CLASSTYPE_INTERFACE_KNOWN
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|t
argument_list|)
operator|=
name|extern_p
expr_stmt|;
if|if
condition|(
operator|!
name|extern_p
condition|)
block|{
name|CLASSTYPE_DEBUG_REQUESTED
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_DECL_SUPPRESS_DEBUG
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|rest_of_type_compilation
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* this should really be done by instantiate_member_templates */
block|{
name|tree
name|method
init|=
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|method
condition|;
name|method
operator|=
name|TREE_CHAIN
argument_list|(
name|method
argument_list|)
control|)
block|{
name|SET_DECL_EXPLICIT_INSTANTIATION
argument_list|(
name|method
argument_list|)
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|method
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|method
argument_list|)
operator|=
operator|(
name|extern_p
operator|||
operator|(
name|DECL_INLINE
argument_list|(
name|method
argument_list|)
operator|&&
operator|!
name|flag_implement_inlines
operator|)
operator|)
expr_stmt|;
block|}
block|}
comment|/* and data member templates, too */
block|}
end_function

begin_function
name|tree
name|create_nested_upt
parameter_list|(
name|scope
parameter_list|,
name|name
parameter_list|)
name|tree
name|scope
decl_stmt|,
name|name
decl_stmt|;
block|{
name|tree
name|t
init|=
name|make_lang_type
argument_list|(
name|UNINSTANTIATED_P_TYPE
argument_list|)
decl_stmt|;
name|tree
name|d
init|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|name
argument_list|,
name|t
argument_list|)
decl_stmt|;
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
operator|=
name|d
expr_stmt|;
name|TYPE_VALUES
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_VALUES
argument_list|(
name|scope
argument_list|)
expr_stmt|;
name|TYPE_CONTEXT
argument_list|(
name|t
argument_list|)
operator|=
name|scope
expr_stmt|;
name|pushdecl
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return
name|d
return|;
block|}
end_function

end_unit

