begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Build expressions with type checking for C++ compiler.    Copyright (C) 1987, 88, 89, 92, 93, 1994 Free Software Foundation, Inc.    Hacked by Michael Tiemann (tiemann@cygnus.com)  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* This file is part of the C++ front end.    It contains routines to build C++ expressions given their operands,    including computing the types of the result, C and C++ specific error    checks, and some optimization.     There are also routines to build RETURN_STMT nodes and CASE_STMT nodes,    and to process initializations in declarations (since they work    like a strange sort of assignment).  */
end_comment

begin_function_decl
specifier|extern
name|void
name|error
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|warning
parameter_list|()
function_decl|;
end_function_decl

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_function_decl
name|int
name|mark_addressable
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|convert_for_assignment
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* static */
end_comment

begin_function_decl
name|tree
name|convert_for_initialization
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|tree
name|shorten_compare
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|binary_op_error
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|pointer_int_sum
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|pointer_diff
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|convert_sequence
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* static */
end_comment

begin_function_decl
name|tree
name|unary_complex_lvalue
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|rtx
name|original_result_rtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return the target type of TYPE, which meas return T for:    T*, T&, T[], T (...), and otherwise, just T.  */
end_comment

begin_function
name|tree
name|target_type
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Do `exp = require_complete_type (exp);' to make sure exp    does not have an incomplete type.  (That includes void types.)  */
end_comment

begin_function
name|tree
name|require_complete_type
parameter_list|(
name|value
parameter_list|)
name|tree
name|value
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
decl_stmt|;
comment|/* First, detect a valid value with a complete type.  */
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
operator|&&
name|type
operator|!=
name|void_type_node
operator|&&
operator|!
operator|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
name|IS_SIGNATURE_POINTER
argument_list|(
name|type
argument_list|)
operator|||
name|IS_SIGNATURE_REFERENCE
argument_list|(
name|type
argument_list|)
operator|)
operator|&&
name|TYPE_SIZE
argument_list|(
name|SIGNATURE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
name|value
return|;
comment|/* If we see X::Y, we build an OFFSET_TYPE which has      not been laid out.  Try to avoid an error by interpreting      it as this->X::Y, if reasonable.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|OFFSET_REF
operator|&&
name|C_C_D
operator|!=
literal|0
operator|&&
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
operator|==
name|C_C_D
condition|)
block|{
name|tree
name|base
decl_stmt|,
name|member
init|=
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|basetype
init|=
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|member
argument_list|)
operator|==
name|FIELD_DECL
argument_list|,
literal|305
argument_list|)
expr_stmt|;
name|base
operator|=
name|convert_pointer_to
argument_list|(
name|basetype
argument_list|,
name|current_class_decl
argument_list|)
expr_stmt|;
name|value
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
argument_list|,
name|build_indirect_ref
argument_list|(
name|base
argument_list|,
name|NULL_PTR
argument_list|)
argument_list|,
name|member
argument_list|)
expr_stmt|;
return|return
name|require_complete_type
argument_list|(
name|value
argument_list|)
return|;
block|}
name|incomplete_type_error
argument_list|(
name|value
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* Return truthvalue of whether type of EXP is instantiated.  */
end_comment

begin_function
name|int
name|type_unknown_p
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
return|return
operator|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|TREE_LIST
operator|||
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
operator|==
name|unknown_type_node
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|OFFSET_TYPE
operator|&&
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|unknown_type_node
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return truthvalue of whether T is function (or pfn) type.  */
end_comment

begin_function
name|int
name|fntype_p
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
return|return
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|METHOD_TYPE
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Do `exp = require_instantiated_type (type, exp);' to make sure EXP    does not have an uninstantiated type.    TYPE is type to instantiate with, if uninstantiated.  */
end_comment

begin_function
name|tree
name|require_instantiated_type
parameter_list|(
name|type
parameter_list|,
name|exp
parameter_list|,
name|errval
parameter_list|)
name|tree
name|type
decl_stmt|,
name|exp
decl_stmt|,
name|errval
decl_stmt|;
block|{
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"argument list may not have an initializer list"
argument_list|)
expr_stmt|;
return|return
name|errval
return|;
block|}
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
operator|==
name|unknown_type_node
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|OFFSET_TYPE
operator|&&
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|unknown_type_node
operator|)
condition|)
block|{
name|exp
operator|=
name|instantiate_type
argument_list|(
name|type
argument_list|,
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|errval
return|;
block|}
return|return
name|exp
return|;
block|}
end_function

begin_comment
comment|/* Return a variant of TYPE which has all the type qualifiers of LIKE    as well as those of TYPE.  */
end_comment

begin_function
specifier|static
name|tree
name|qualify_type
parameter_list|(
name|type
parameter_list|,
name|like
parameter_list|)
name|tree
name|type
decl_stmt|,
name|like
decl_stmt|;
block|{
name|int
name|constflag
init|=
name|TYPE_READONLY
argument_list|(
name|type
argument_list|)
operator|||
name|TYPE_READONLY
argument_list|(
name|like
argument_list|)
decl_stmt|;
name|int
name|volflag
init|=
name|TYPE_VOLATILE
argument_list|(
name|type
argument_list|)
operator|||
name|TYPE_VOLATILE
argument_list|(
name|like
argument_list|)
decl_stmt|;
comment|/* @@ Must do member pointers here.  */
return|return
name|cp_build_type_variant
argument_list|(
name|type
argument_list|,
name|constflag
argument_list|,
name|volflag
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the common type of two parameter lists.    We assume that comptypes has already been done and returned 1;    if that isn't so, this may crash.     As an optimization, free the space we allocate if the parameter    lists are already common.  */
end_comment

begin_function
name|tree
name|commonparms
parameter_list|(
name|p1
parameter_list|,
name|p2
parameter_list|)
name|tree
name|p1
decl_stmt|,
name|p2
decl_stmt|;
block|{
name|tree
name|oldargs
init|=
name|p1
decl_stmt|,
name|newargs
decl_stmt|,
name|n
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
name|int
name|any_change
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|first_obj
init|=
operator|(
name|char
operator|*
operator|)
name|oballoc
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|len
operator|=
name|list_length
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|newargs
operator|=
name|tree_last
argument_list|(
name|p1
argument_list|)
expr_stmt|;
if|if
condition|(
name|newargs
operator|==
name|void_list_node
condition|)
name|i
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|i
operator|=
literal|0
expr_stmt|;
name|newargs
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|newargs
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|newargs
argument_list|)
expr_stmt|;
name|n
operator|=
name|newargs
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|p1
condition|;
name|p1
operator|=
name|TREE_CHAIN
argument_list|(
name|p1
argument_list|)
operator|,
name|p2
operator|=
name|TREE_CHAIN
argument_list|(
name|p2
argument_list|)
operator|,
name|n
operator|=
name|TREE_CHAIN
argument_list|(
name|n
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|p1
argument_list|)
operator|&&
operator|!
name|TREE_PURPOSE
argument_list|(
name|p2
argument_list|)
condition|)
block|{
comment|/* We used to give a warning here that advised about a default 	     argument being given in the prototype but not in the function's 	     declaration.  It's best not to bother.  */
name|TREE_PURPOSE
argument_list|(
name|n
argument_list|)
operator|=
name|TREE_PURPOSE
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|any_change
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|TREE_PURPOSE
argument_list|(
name|p1
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|p2
argument_list|)
condition|)
block|{
name|TREE_PURPOSE
argument_list|(
name|n
argument_list|)
operator|=
name|TREE_PURPOSE
argument_list|(
name|p2
argument_list|)
expr_stmt|;
name|any_change
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|cmp
init|=
name|simple_cst_equal
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|p1
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|p2
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
name|my_friendly_abort
argument_list|(
literal|111
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
name|any_change
operator|=
literal|1
expr_stmt|;
name|TREE_PURPOSE
argument_list|(
name|n
argument_list|)
operator|=
name|TREE_PURPOSE
argument_list|(
name|p2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|p1
argument_list|)
operator|!=
name|TREE_VALUE
argument_list|(
name|p2
argument_list|)
condition|)
block|{
name|any_change
operator|=
literal|1
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|n
argument_list|)
operator|=
name|common_type
argument_list|(
name|TREE_VALUE
argument_list|(
name|p1
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|p2
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|TREE_VALUE
argument_list|(
name|n
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|p1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|any_change
condition|)
block|{
name|obfree
argument_list|(
name|first_obj
argument_list|)
expr_stmt|;
return|return
name|oldargs
return|;
block|}
return|return
name|newargs
return|;
block|}
end_function

begin_comment
comment|/* Return the common type of two types.    We assume that comptypes has already been done and returned 1;    if that isn't so, this may crash.     This is the type for the result of most arithmetic operations    if the operands have the given two types.     We do not deal with enumeral types here because they have already been    converted to integer types.  */
end_comment

begin_function
name|tree
name|common_type
parameter_list|(
name|t1
parameter_list|,
name|t2
parameter_list|)
name|tree
name|t1
decl_stmt|,
name|t2
decl_stmt|;
block|{
specifier|register
name|enum
name|tree_code
name|code1
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|code2
decl_stmt|;
name|tree
name|attributes
decl_stmt|;
comment|/* Save time if the two types are the same.  */
if|if
condition|(
name|t1
operator|==
name|t2
condition|)
return|return
name|t1
return|;
comment|/* If one type is nonsense, use the other.  */
if|if
condition|(
name|t1
operator|==
name|error_mark_node
condition|)
return|return
name|t2
return|;
if|if
condition|(
name|t2
operator|==
name|error_mark_node
condition|)
return|return
name|t1
return|;
comment|/* Merge the attributes */
block|{
specifier|register
name|tree
name|a1
decl_stmt|,
name|a2
decl_stmt|;
name|a1
operator|=
name|TYPE_ATTRIBUTES
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|a2
operator|=
name|TYPE_ATTRIBUTES
argument_list|(
name|t2
argument_list|)
expr_stmt|;
comment|/* Either one unset?  Take the set one.  */
if|if
condition|(
operator|!
operator|(
name|attributes
operator|=
name|a1
operator|)
condition|)
name|attributes
operator|=
name|a2
expr_stmt|;
comment|/* One that completely contains the other?  Take it.  */
elseif|else
if|if
condition|(
name|a2
operator|&&
operator|!
name|attribute_list_contained
argument_list|(
name|a1
argument_list|,
name|a2
argument_list|)
condition|)
if|if
condition|(
name|attribute_list_contained
argument_list|(
name|a2
argument_list|,
name|a1
argument_list|)
condition|)
name|attributes
operator|=
name|a2
expr_stmt|;
else|else
block|{
comment|/* Pick the longest list, and hang on the other 	     list.  */
if|if
condition|(
name|list_length
argument_list|(
name|a1
argument_list|)
operator|<
name|list_length
argument_list|(
name|a2
argument_list|)
condition|)
name|attributes
operator|=
name|a2
operator|,
name|a2
operator|=
name|a1
expr_stmt|;
for|for
control|(
init|;
name|a2
condition|;
name|a2
operator|=
name|TREE_CHAIN
argument_list|(
name|a2
argument_list|)
control|)
if|if
condition|(
operator|!
name|value_member
argument_list|(
name|attributes
argument_list|,
name|a2
argument_list|)
condition|)
block|{
name|a1
operator|=
name|copy_node
argument_list|(
name|a2
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|a1
argument_list|)
operator|=
name|attributes
expr_stmt|;
name|attributes
operator|=
name|a1
expr_stmt|;
block|}
block|}
block|}
comment|/* Treat an enum type as the unsigned integer type of the same width.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
name|t1
operator|=
name|type_for_size
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|t1
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
name|t2
operator|=
name|type_for_size
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|t2
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|code1
operator|=
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|code2
operator|=
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code1
condition|)
block|{
case|case
name|INTEGER_TYPE
case|:
case|case
name|REAL_TYPE
case|:
comment|/* If only one is real, use it as the result.  */
if|if
condition|(
name|code1
operator|==
name|REAL_TYPE
operator|&&
name|code2
operator|!=
name|REAL_TYPE
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
return|;
if|if
condition|(
name|code2
operator|==
name|REAL_TYPE
operator|&&
name|code1
operator|!=
name|REAL_TYPE
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|t2
argument_list|,
name|attributes
argument_list|)
return|;
comment|/* Both real or both integers; use the one with greater precision.  */
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|t1
argument_list|)
operator|>
name|TYPE_PRECISION
argument_list|(
name|t2
argument_list|)
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|t2
argument_list|)
operator|>
name|TYPE_PRECISION
argument_list|(
name|t1
argument_list|)
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|t2
argument_list|,
name|attributes
argument_list|)
return|;
comment|/* Same precision.  Prefer longs to ints even when same size.  */
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t1
argument_list|)
operator|==
name|long_unsigned_type_node
operator|||
name|TYPE_MAIN_VARIANT
argument_list|(
name|t2
argument_list|)
operator|==
name|long_unsigned_type_node
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|long_unsigned_type_node
argument_list|,
name|attributes
argument_list|)
return|;
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t1
argument_list|)
operator|==
name|long_integer_type_node
operator|||
name|TYPE_MAIN_VARIANT
argument_list|(
name|t2
argument_list|)
operator|==
name|long_integer_type_node
condition|)
block|{
comment|/* But preserve unsignedness from the other type, 	     since long cannot hold all the values of an unsigned int.  */
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|t1
argument_list|)
operator|||
name|TREE_UNSIGNED
argument_list|(
name|t2
argument_list|)
condition|)
name|t1
operator|=
name|long_unsigned_type_node
expr_stmt|;
else|else
name|t1
operator|=
name|long_integer_type_node
expr_stmt|;
return|return
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
return|;
block|}
comment|/* Otherwise prefer the unsigned one.  */
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|t1
argument_list|)
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
return|;
else|else
return|return
name|build_type_attribute_variant
argument_list|(
name|t2
argument_list|,
name|attributes
argument_list|)
return|;
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
comment|/* For two pointers, do this recursively on the target type, 	 and combine the qualifiers of the two types' targets.  */
comment|/* This code was turned off; I don't know why.  	 But ANSI C++ specifies doing this with the qualifiers.  	 So I turned it on again.  */
block|{
name|tree
name|target
init|=
name|common_type
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|constp
init|=
name|TYPE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|)
operator|||
name|TYPE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|volatilep
init|=
name|TYPE_VOLATILE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|)
operator|||
name|TYPE_VOLATILE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
decl_stmt|;
name|target
operator|=
name|cp_build_type_variant
argument_list|(
name|target
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|)
expr_stmt|;
if|if
condition|(
name|code1
operator|==
name|POINTER_TYPE
condition|)
name|t1
operator|=
name|build_pointer_type
argument_list|(
name|target
argument_list|)
expr_stmt|;
else|else
name|t1
operator|=
name|build_reference_type
argument_list|(
name|target
argument_list|)
expr_stmt|;
return|return
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
return|;
block|}
if|#
directive|if
literal|0
block|case POINTER_TYPE:       t1 = build_pointer_type (common_type (TREE_TYPE (t1), TREE_TYPE (t2)));       return build_type_attribute_variant (t1, attributes);      case REFERENCE_TYPE:       t1 = build_reference_type (common_type (TREE_TYPE (t1), TREE_TYPE (t2)));       return build_type_attribute_variant (t1, attributes);
endif|#
directive|endif
case|case
name|ARRAY_TYPE
case|:
block|{
name|tree
name|elt
init|=
name|common_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Save space: see if the result is identical to one of the args.  */
if|if
condition|(
name|elt
operator|==
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|t1
argument_list|)
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
return|;
if|if
condition|(
name|elt
operator|==
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|t2
argument_list|)
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|t2
argument_list|,
name|attributes
argument_list|)
return|;
comment|/* Merge the element types, and have a size if either arg has one.  */
name|t1
operator|=
name|build_array_type
argument_list|(
name|elt
argument_list|,
name|TYPE_DOMAIN
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|t1
argument_list|)
condition|?
name|t1
else|:
name|t2
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
return|;
block|}
case|case
name|FUNCTION_TYPE
case|:
comment|/* Function types: prefer the one that specified arg types. 	 If both do, merge the arg types.  Also merge the return types.  */
block|{
name|tree
name|valtype
init|=
name|common_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|p1
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|t1
argument_list|)
decl_stmt|;
name|tree
name|p2
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|t2
argument_list|)
decl_stmt|;
name|tree
name|rval
decl_stmt|,
name|raises
decl_stmt|;
comment|/* Save space: see if the result is identical to one of the args.  */
if|if
condition|(
name|valtype
operator|==
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
operator|&&
operator|!
name|p2
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
return|;
if|if
condition|(
name|valtype
operator|==
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
operator|&&
operator|!
name|p1
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|t2
argument_list|,
name|attributes
argument_list|)
return|;
comment|/* Simple way if one arg fails to specify argument types.  */
if|if
condition|(
name|p1
operator|==
name|NULL_TREE
operator|||
name|TREE_VALUE
argument_list|(
name|p1
argument_list|)
operator|==
name|void_type_node
condition|)
block|{
name|rval
operator|=
name|build_function_type
argument_list|(
name|valtype
argument_list|,
name|p2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|raises
operator|=
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|t2
argument_list|)
operator|)
condition|)
name|rval
operator|=
name|build_exception_variant
argument_list|(
name|NULL_TREE
argument_list|,
name|rval
argument_list|,
name|raises
argument_list|)
expr_stmt|;
return|return
name|build_type_attribute_variant
argument_list|(
name|rval
argument_list|,
name|attributes
argument_list|)
return|;
block|}
name|raises
operator|=
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|t1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2
operator|==
name|NULL_TREE
operator|||
name|TREE_VALUE
argument_list|(
name|p2
argument_list|)
operator|==
name|void_type_node
condition|)
block|{
name|rval
operator|=
name|build_function_type
argument_list|(
name|valtype
argument_list|,
name|p1
argument_list|)
expr_stmt|;
if|if
condition|(
name|raises
condition|)
name|rval
operator|=
name|build_exception_variant
argument_list|(
name|NULL_TREE
argument_list|,
name|rval
argument_list|,
name|raises
argument_list|)
expr_stmt|;
return|return
name|build_type_attribute_variant
argument_list|(
name|rval
argument_list|,
name|attributes
argument_list|)
return|;
block|}
name|rval
operator|=
name|build_function_type
argument_list|(
name|valtype
argument_list|,
name|commonparms
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
argument_list|)
expr_stmt|;
name|rval
operator|=
name|build_exception_variant
argument_list|(
name|NULL_TREE
argument_list|,
name|rval
argument_list|,
name|raises
argument_list|)
expr_stmt|;
return|return
name|build_type_attribute_variant
argument_list|(
name|rval
argument_list|,
name|attributes
argument_list|)
return|;
block|}
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
name|my_friendly_assert
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t1
argument_list|)
operator|==
name|t1
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|t2
argument_list|)
operator|==
name|t2
argument_list|,
literal|306
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|binfo_or_else
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
condition|)
name|compiler_error
argument_list|(
literal|"common_type called with uncommon aggregate types"
argument_list|)
expr_stmt|;
return|return
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
return|;
case|case
name|METHOD_TYPE
case|:
if|if
condition|(
name|comptypes
argument_list|(
name|TYPE_METHOD_BASETYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TYPE_METHOD_BASETYPE
argument_list|(
name|t2
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|)
operator|==
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Get this value the long way, since TYPE_METHOD_BASETYPE 	     is just the main variant of this.  */
name|tree
name|basetype
init|=
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|t1
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|raises
decl_stmt|,
name|t3
decl_stmt|;
name|raises
operator|=
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|t1
argument_list|)
expr_stmt|;
comment|/* If this was a member function type, get back to the 	     original type of type member function (i.e., without 	     the class instance variable up front.  */
name|t1
operator|=
name|build_function_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|t1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|t2
operator|=
name|build_function_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|t2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|t3
operator|=
name|common_type
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
expr_stmt|;
name|t3
operator|=
name|build_cplus_method_type
argument_list|(
name|basetype
argument_list|,
name|TREE_TYPE
argument_list|(
name|t3
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|t3
argument_list|)
argument_list|)
expr_stmt|;
name|t1
operator|=
name|build_exception_variant
argument_list|(
name|basetype
argument_list|,
name|t3
argument_list|,
name|raises
argument_list|)
expr_stmt|;
block|}
else|else
name|compiler_error
argument_list|(
literal|"common_type called with uncommon method types"
argument_list|)
expr_stmt|;
return|return
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
return|;
case|case
name|OFFSET_TYPE
case|:
if|if
condition|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|t1
argument_list|)
operator|==
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|t2
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|)
operator|==
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|basetype
init|=
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|t1
argument_list|)
decl_stmt|;
name|t1
operator|=
name|build_offset_type
argument_list|(
name|basetype
argument_list|,
name|common_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|compiler_error
argument_list|(
literal|"common_type called with uncommon member types"
argument_list|)
expr_stmt|;
comment|/* ... falls through ... */
default|default:
return|return
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if TYPE1 and TYPE2 raise the same exceptions.  */
end_comment

begin_function
name|int
name|compexcepttypes
parameter_list|(
name|t1
parameter_list|,
name|t2
parameter_list|,
name|strict
parameter_list|)
name|tree
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|int
name|strict
decl_stmt|;
block|{
return|return
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|t1
argument_list|)
operator|==
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|t2
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|comp_array_types
argument_list|(
name|cmp
argument_list|,
name|t1
argument_list|,
name|t2
argument_list|,
name|strict
argument_list|)
decl|register
name|int
argument_list|(
operator|*
name|cmp
argument_list|)
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|t1
decl_stmt|,
name|t2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|strict
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|tree
name|d1
init|=
name|TYPE_DOMAIN
argument_list|(
name|t1
argument_list|)
decl_stmt|;
name|tree
name|d2
init|=
name|TYPE_DOMAIN
argument_list|(
name|t2
argument_list|)
decl_stmt|;
comment|/* Target types must match incl. qualifiers.  */
if|if
condition|(
operator|!
operator|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
operator|||
call|(
modifier|*
name|cmp
call|)
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|,
name|strict
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
comment|/* Sizes must match unless one is missing or variable.  */
if|if
condition|(
name|d1
operator|==
literal|0
operator|||
name|d2
operator|==
literal|0
operator|||
name|d1
operator|==
name|d2
operator|||
name|TREE_CODE
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|d1
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|d2
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|d1
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|d2
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
literal|1
return|;
return|return
operator|(
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|d1
argument_list|)
argument_list|)
operator|==
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|d2
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|TREE_INT_CST_HIGH
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|d1
argument_list|)
argument_list|)
operator|==
name|TREE_INT_CST_HIGH
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|d2
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|d1
argument_list|)
argument_list|)
operator|==
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|d2
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|TREE_INT_CST_HIGH
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|d1
argument_list|)
argument_list|)
operator|==
name|TREE_INT_CST_HIGH
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|d2
argument_list|)
argument_list|)
operator|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Return 1 if TYPE1 and TYPE2 are compatible types for assignment    or various other operations.  This is what ANSI C++ speaks of as    "being the same".     For C++: argument STRICT says we should be strict about this    comparison:  	2 : strict, except that if one type is a reference and 	    the other is not, compare the target type of the 	    reference to the type that's not a reference (ARM, p308). 	    This is used for checking for illegal overloading. 	1 : strict (compared according to ANSI C) 	    This is used for checking whether two function decls match. 	0 :<= (compared according to C++) 	-1:<= or>= (relaxed)     Otherwise, pointers involving base classes and derived classes    can be mixed as legal: i.e. a pointer to a base class may be assigned    to a pointer to one of its derived classes, as per C++. A pointer to    a derived class may be passed as a parameter to a function expecting a    pointer to a base classes. These allowances do not commute. In this    case, TYPE1 is assumed to be the base class, and TYPE2 is assumed to    be the derived class.  */
end_comment

begin_function
name|int
name|comptypes
parameter_list|(
name|type1
parameter_list|,
name|type2
parameter_list|,
name|strict
parameter_list|)
name|tree
name|type1
decl_stmt|,
name|type2
decl_stmt|;
name|int
name|strict
decl_stmt|;
block|{
specifier|register
name|tree
name|t1
init|=
name|type1
decl_stmt|;
specifier|register
name|tree
name|t2
init|=
name|type2
decl_stmt|;
name|int
name|attrval
decl_stmt|,
name|val
decl_stmt|;
comment|/* Suppress errors caused by previously reported errors */
if|if
condition|(
name|t1
operator|==
name|t2
condition|)
return|return
literal|1
return|;
comment|/* This should never happen.  */
name|my_friendly_assert
argument_list|(
name|t1
operator|!=
name|error_mark_node
argument_list|,
literal|307
argument_list|)
expr_stmt|;
if|if
condition|(
name|t2
operator|==
name|error_mark_node
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|strict
operator|<
literal|0
condition|)
block|{
comment|/* Treat an enum type as the unsigned integer type of the same width.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
name|t1
operator|=
name|type_for_size
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|t1
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
name|t2
operator|=
name|type_for_size
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|t2
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|t1
operator|==
name|t2
condition|)
return|return
literal|1
return|;
block|}
comment|/* Different classes of types can't be compatible.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
condition|)
block|{
if|if
condition|(
name|strict
operator|==
literal|2
operator|&&
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|)
operator|^
operator|(
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
return|return
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|t2
argument_list|,
literal|1
argument_list|)
return|;
return|return
name|comptypes
argument_list|(
name|t1
argument_list|,
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|,
literal|1
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
if|if
condition|(
name|strict
operator|>
literal|1
condition|)
name|strict
operator|=
literal|1
expr_stmt|;
comment|/* Qualifiers must match.  */
if|if
condition|(
name|TYPE_READONLY
argument_list|(
name|t1
argument_list|)
operator|!=
name|TYPE_READONLY
argument_list|(
name|t2
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TYPE_VOLATILE
argument_list|(
name|t1
argument_list|)
operator|!=
name|TYPE_VOLATILE
argument_list|(
name|t2
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Allow for two different type nodes which have essentially the same      definition.  Note that we already checked for equality of the type      type qualifiers (just above).  */
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t1
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|t2
argument_list|)
condition|)
return|return
literal|1
return|;
ifdef|#
directive|ifdef
name|COMP_TYPE_ATTRIBUTES
if|if
condition|(
operator|!
operator|(
name|attrval
operator|=
name|COMP_TYPE_ATTRIBUTES
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
else|#
directive|else
comment|/* 1 if no need for warning yet, 2 if warning cause has been seen.  */
name|attrval
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* 1 if no need for warning yet, 2 if warning cause has been seen.  */
name|val
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
condition|)
block|{
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
if|if
condition|(
name|strict
operator|<=
literal|0
condition|)
goto|goto
name|look_hard
goto|;
return|return
literal|0
return|;
case|case
name|OFFSET_TYPE
case|:
name|val
operator|=
operator|(
name|comptypes
argument_list|(
name|TYPE_POINTER_TO
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|t1
argument_list|)
argument_list|)
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
argument_list|,
name|strict
argument_list|)
operator|&&
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|,
name|strict
argument_list|)
operator|)
expr_stmt|;
break|break;
case|case
name|METHOD_TYPE
case|:
if|if
condition|(
operator|!
name|compexcepttypes
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|,
name|strict
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* This case is anti-symmetrical! 	 One can pass a base member (or member function) 	 to something expecting a derived member (or member function), 	 but not vice-versa!  */
name|val
operator|=
operator|(
name|comptypes
argument_list|(
name|TYPE_POINTER_TO
argument_list|(
name|TYPE_METHOD_BASETYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|TYPE_METHOD_BASETYPE
argument_list|(
name|t1
argument_list|)
argument_list|)
argument_list|,
name|strict
argument_list|)
operator|&&
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|,
name|strict
argument_list|)
operator|&&
name|compparms
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|t1
argument_list|)
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|t2
argument_list|)
argument_list|)
argument_list|,
name|strict
argument_list|)
operator|)
expr_stmt|;
break|break;
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
name|t1
operator|=
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|t2
operator|=
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
expr_stmt|;
if|if
condition|(
name|t1
operator|==
name|t2
condition|)
block|{
name|val
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|strict
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
block|{
name|int
name|rval
decl_stmt|;
name|look_hard
label|:
name|rval
operator|=
name|t1
operator|==
name|t2
operator|||
name|UNIQUELY_DERIVED_FROM_P
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
condition|)
block|{
name|val
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|strict
operator|<
literal|0
condition|)
block|{
name|val
operator|=
name|UNIQUELY_DERIVED_FROM_P
argument_list|(
name|t2
argument_list|,
name|t1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
literal|0
return|;
block|}
else|else
name|val
operator|=
name|comptypes
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|,
name|strict
argument_list|)
expr_stmt|;
break|break;
case|case
name|FUNCTION_TYPE
case|:
if|if
condition|(
operator|!
name|compexcepttypes
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|,
name|strict
argument_list|)
condition|)
return|return
literal|0
return|;
name|val
operator|=
operator|(
operator|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
operator|||
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|,
name|strict
argument_list|)
operator|)
operator|&&
name|compparms
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|t2
argument_list|)
argument_list|,
name|strict
argument_list|)
operator|)
expr_stmt|;
break|break;
case|case
name|ARRAY_TYPE
case|:
comment|/* Target types must match incl. qualifiers.  */
name|val
operator|=
name|comp_array_types
argument_list|(
name|comptypes
argument_list|,
name|t1
argument_list|,
name|t2
argument_list|,
name|strict
argument_list|)
expr_stmt|;
break|break;
case|case
name|TEMPLATE_TYPE_PARM
case|:
return|return
literal|1
return|;
case|case
name|UNINSTANTIATED_P_TYPE
case|:
return|return
name|UPT_TEMPLATE
argument_list|(
name|t1
argument_list|)
operator|==
name|UPT_TEMPLATE
argument_list|(
name|t2
argument_list|)
return|;
block|}
return|return
name|attrval
operator|==
literal|2
operator|&&
name|val
operator|==
literal|1
condition|?
literal|2
else|:
name|val
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if TTL and TTR are pointers to types that are equivalent,    ignoring their qualifiers.     NPTRS is the number of pointers we can strip off and keep cool.    This is used to permit (for aggr A, aggr B) A, B* to convert to A*,    but to not permit B** to convert to A**.  */
end_comment

begin_function
name|int
name|comp_target_types
parameter_list|(
name|ttl
parameter_list|,
name|ttr
parameter_list|,
name|nptrs
parameter_list|)
name|tree
name|ttl
decl_stmt|,
name|ttr
decl_stmt|;
name|int
name|nptrs
decl_stmt|;
block|{
name|ttl
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|ttl
argument_list|)
expr_stmt|;
name|ttr
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|ttr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ttl
operator|==
name|ttr
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ttl
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ttl
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
return|return
name|comp_ptr_ttypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|ttl
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|ttr
argument_list|)
argument_list|)
return|;
else|else
return|return
name|comp_target_types
argument_list|(
name|TREE_TYPE
argument_list|(
name|ttl
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|ttr
argument_list|)
argument_list|,
name|nptrs
operator|-
literal|1
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
return|return
name|comp_target_types
argument_list|(
name|TREE_TYPE
argument_list|(
name|ttl
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|ttr
argument_list|)
argument_list|,
name|nptrs
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
return|return
name|comp_array_types
argument_list|(
name|comp_target_types
argument_list|,
name|ttl
argument_list|,
name|ttr
argument_list|,
literal|0
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
if|if
condition|(
name|comp_target_types
argument_list|(
name|TREE_TYPE
argument_list|(
name|ttl
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|ttr
argument_list|)
argument_list|,
name|nptrs
argument_list|)
condition|)
switch|switch
condition|(
name|comp_target_parms
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|ttl
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|ttr
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
return|return
literal|0
return|;
case|case
literal|1
case|:
return|return
literal|1
return|;
case|case
literal|2
case|:
name|cp_pedwarn
argument_list|(
literal|"converting `%T' to `%T' is a contravariance violation"
argument_list|,
name|ttr
argument_list|,
name|ttl
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
default|default:
name|my_friendly_abort
argument_list|(
literal|112
argument_list|)
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
comment|/* for C++ */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
block|{
comment|/* Contravariance: we can assign a pointer to base member to a pointer 	 to derived member.  Note difference from simple pointer case, where 	 we can pass a pointer to derived to a pointer to base.  */
if|if
condition|(
name|comptypes
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|ttr
argument_list|)
argument_list|,
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|ttl
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|comp_target_types
argument_list|(
name|TREE_TYPE
argument_list|(
name|ttl
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|ttr
argument_list|)
argument_list|,
name|nptrs
argument_list|)
return|;
elseif|else
if|if
condition|(
name|comptypes
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|ttl
argument_list|)
argument_list|,
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|ttr
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|&&
name|comp_target_types
argument_list|(
name|TREE_TYPE
argument_list|(
name|ttl
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|ttr
argument_list|)
argument_list|,
name|nptrs
argument_list|)
condition|)
block|{
name|cp_pedwarn
argument_list|(
literal|"converting `%T' to `%T' is a contravariance violation"
argument_list|,
name|ttr
argument_list|,
name|ttl
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|ttl
argument_list|)
condition|)
block|{
if|if
condition|(
name|nptrs
operator|<
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|comptypes
argument_list|(
name|TYPE_POINTER_TO
argument_list|(
name|ttl
argument_list|)
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|ttr
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* If two types share a common base type, return that basetype.    If there is not a unique most-derived base type, this function    returns ERROR_MARK_NODE.  */
end_comment

begin_function
name|tree
name|common_base_type
parameter_list|(
name|tt1
parameter_list|,
name|tt2
parameter_list|)
name|tree
name|tt1
decl_stmt|,
name|tt2
decl_stmt|;
block|{
name|tree
name|best
init|=
name|NULL_TREE
decl_stmt|,
name|tmp
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* If one is a baseclass of another, that's good enough.  */
if|if
condition|(
name|UNIQUELY_DERIVED_FROM_P
argument_list|(
name|tt1
argument_list|,
name|tt2
argument_list|)
condition|)
return|return
name|tt1
return|;
if|if
condition|(
name|UNIQUELY_DERIVED_FROM_P
argument_list|(
name|tt2
argument_list|,
name|tt1
argument_list|)
condition|)
return|return
name|tt2
return|;
if|#
directive|if
literal|0
comment|/* If they share a virtual baseclass, that's good enough.  */
block|for (tmp = CLASSTYPE_VBASECLASSES (tt1); tmp; tmp = TREE_CHAIN (tmp))     {       if (binfo_member (BINFO_TYPE (tmp), CLASSTYPE_VBASECLASSES (tt2))) 	return BINFO_TYPE (tmp);     }
endif|#
directive|endif
comment|/* Otherwise, try to find a unique baseclass of TT1      that is shared by TT2, and follow that down.  */
for|for
control|(
name|i
operator|=
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|tt1
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|tree
name|basetype
init|=
name|TYPE_BINFO_BASETYPE
argument_list|(
name|tt1
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|trial
init|=
name|common_base_type
argument_list|(
name|basetype
argument_list|,
name|tt2
argument_list|)
decl_stmt|;
if|if
condition|(
name|trial
condition|)
block|{
if|if
condition|(
name|trial
operator|==
name|error_mark_node
condition|)
return|return
name|trial
return|;
if|if
condition|(
name|best
operator|==
name|NULL_TREE
condition|)
name|best
operator|=
name|trial
expr_stmt|;
elseif|else
if|if
condition|(
name|best
operator|!=
name|trial
condition|)
return|return
name|error_mark_node
return|;
block|}
block|}
comment|/* Same for TT2.  */
for|for
control|(
name|i
operator|=
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|tt2
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|tree
name|basetype
init|=
name|TYPE_BINFO_BASETYPE
argument_list|(
name|tt2
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|trial
init|=
name|common_base_type
argument_list|(
name|tt1
argument_list|,
name|basetype
argument_list|)
decl_stmt|;
if|if
condition|(
name|trial
condition|)
block|{
if|if
condition|(
name|trial
operator|==
name|error_mark_node
condition|)
return|return
name|trial
return|;
if|if
condition|(
name|best
operator|==
name|NULL_TREE
condition|)
name|best
operator|=
name|trial
expr_stmt|;
elseif|else
if|if
condition|(
name|best
operator|!=
name|trial
condition|)
return|return
name|error_mark_node
return|;
block|}
block|}
return|return
name|best
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutines of `comptypes'.  */
end_comment

begin_comment
comment|/* Return 1 if two parameter type lists PARMS1 and PARMS2    are equivalent in the sense that functions with those parameter types    can have equivalent types.    If either list is empty, we win.    Otherwise, the two lists must be equivalent, element by element.     C++: See comment above about TYPE1, TYPE2, STRICT.    If STRICT == 3, it means checking is strict, but do not compare    default parameter values.  */
end_comment

begin_function
name|int
name|compparms
parameter_list|(
name|parms1
parameter_list|,
name|parms2
parameter_list|,
name|strict
parameter_list|)
name|tree
name|parms1
decl_stmt|,
name|parms2
decl_stmt|;
name|int
name|strict
decl_stmt|;
block|{
specifier|register
name|tree
name|t1
init|=
name|parms1
decl_stmt|,
name|t2
init|=
name|parms2
decl_stmt|;
comment|/* An unspecified parmlist matches any specified parmlist      whose argument types don't need default promotions.  */
if|if
condition|(
name|strict
operator|<=
literal|0
operator|&&
name|t1
operator|==
literal|0
condition|)
return|return
name|self_promoting_args_p
argument_list|(
name|t2
argument_list|)
return|;
if|if
condition|(
name|strict
operator|<
literal|0
operator|&&
name|t2
operator|==
literal|0
condition|)
return|return
name|self_promoting_args_p
argument_list|(
name|t1
argument_list|)
return|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|t1
operator|==
literal|0
operator|&&
name|t2
operator|==
literal|0
condition|)
return|return
literal|1
return|;
comment|/* If one parmlist is shorter than the other, 	 they fail to match, unless STRICT is<= 0.  */
if|if
condition|(
name|t1
operator|==
literal|0
operator|||
name|t2
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|strict
operator|>
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|strict
operator|<
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|strict
operator|==
literal|0
condition|)
return|return
name|t1
operator|&&
name|TREE_PURPOSE
argument_list|(
name|t1
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|comptypes
argument_list|(
name|TREE_VALUE
argument_list|(
name|t2
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|strict
argument_list|)
condition|)
block|{
if|if
condition|(
name|strict
operator|>
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|strict
operator|==
literal|0
condition|)
return|return
name|t2
operator|==
name|void_list_node
operator|&&
name|TREE_PURPOSE
argument_list|(
name|t1
argument_list|)
return|;
return|return
name|TREE_PURPOSE
argument_list|(
name|t1
argument_list|)
operator|||
name|TREE_PURPOSE
argument_list|(
name|t2
argument_list|)
return|;
block|}
if|#
directive|if
literal|0
comment|/* Default parms are not part of the type of a function.  */
block|if (strict != 3&& TREE_PURPOSE (t1)&& TREE_PURPOSE (t2)) 	{ 	  int cmp = simple_cst_equal (TREE_PURPOSE (t1), TREE_PURPOSE (t2)); 	  if (cmp< 0) 	    my_friendly_abort (113); 	  if (cmp == 0) 	    return 0; 	}
endif|#
directive|endif
name|t1
operator|=
name|TREE_CHAIN
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|t2
operator|=
name|TREE_CHAIN
argument_list|(
name|t2
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This really wants return whether or not parameter type lists    would make their owning functions assignment compatible or not.  */
end_comment

begin_function
name|int
name|comp_target_parms
parameter_list|(
name|parms1
parameter_list|,
name|parms2
parameter_list|,
name|strict
parameter_list|)
name|tree
name|parms1
decl_stmt|,
name|parms2
decl_stmt|;
name|int
name|strict
decl_stmt|;
block|{
specifier|register
name|tree
name|t1
init|=
name|parms1
decl_stmt|,
name|t2
init|=
name|parms2
decl_stmt|;
name|int
name|warn_contravariance
init|=
literal|0
decl_stmt|;
comment|/* An unspecified parmlist matches any specified parmlist      whose argument types don't need default promotions.      @@@ see 13.3.3 for a counterexample...  */
if|if
condition|(
name|t1
operator|==
literal|0
operator|&&
name|t2
operator|!=
literal|0
condition|)
block|{
name|cp_pedwarn
argument_list|(
literal|"ANSI C++ prohibits conversion from `(%#T)' to `(...)'"
argument_list|,
name|parms2
argument_list|)
expr_stmt|;
return|return
name|self_promoting_args_p
argument_list|(
name|t2
argument_list|)
return|;
block|}
if|if
condition|(
name|t2
operator|==
literal|0
condition|)
return|return
name|self_promoting_args_p
argument_list|(
name|t1
argument_list|)
return|;
for|for
control|(
init|;
name|t1
operator|||
name|t2
condition|;
name|t1
operator|=
name|TREE_CHAIN
argument_list|(
name|t1
argument_list|)
operator|,
name|t2
operator|=
name|TREE_CHAIN
argument_list|(
name|t2
argument_list|)
control|)
block|{
name|tree
name|p1
decl_stmt|,
name|p2
decl_stmt|;
comment|/* If one parmlist is shorter than the other, 	 they fail to match, unless STRICT is<= 0.  */
if|if
condition|(
name|t1
operator|==
literal|0
operator|||
name|t2
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|strict
operator|>
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|strict
operator|<
literal|0
condition|)
return|return
literal|1
operator|+
name|warn_contravariance
return|;
return|return
operator|(
operator|(
name|t1
operator|&&
name|TREE_PURPOSE
argument_list|(
name|t1
argument_list|)
operator|)
operator|+
name|warn_contravariance
operator|)
return|;
block|}
name|p1
operator|=
name|TREE_VALUE
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|p2
operator|=
name|TREE_VALUE
argument_list|(
name|t2
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
operator|==
name|p2
condition|)
continue|continue;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|p1
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|p2
argument_list|)
operator|==
name|POINTER_TYPE
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|p1
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|p2
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|)
condition|)
block|{
if|if
condition|(
name|strict
operator|<=
literal|0
operator|&&
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|p1
argument_list|)
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|p2
argument_list|)
argument_list|)
operator|)
condition|)
continue|continue;
comment|/* The following is wrong for contravariance, 	     but many programs depend on it.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|p1
argument_list|)
operator|==
name|void_type_node
condition|)
continue|continue;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|p2
argument_list|)
operator|==
name|void_type_node
condition|)
block|{
name|warn_contravariance
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|p1
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|comptypes
argument_list|(
name|p2
argument_list|,
name|p1
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|comptypes
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
name|warn_contravariance
operator|=
literal|1
expr_stmt|;
else|else
return|return
literal|0
return|;
block|}
continue|continue;
block|}
block|}
comment|/* Note backwards order due to contravariance.  */
if|if
condition|(
name|comp_target_types
argument_list|(
name|p2
argument_list|,
name|p1
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|comp_target_types
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|warn_contravariance
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strict
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
if|#
directive|if
literal|0
comment|/* What good do these cases do?  */
block|if (strict == 0) 	    return p2 == void_type_node&& TREE_PURPOSE (t1); 	  return TREE_PURPOSE (t1) || TREE_PURPOSE (t2);
endif|#
directive|endif
block|}
comment|/* Target types are compatible--just make sure that if 	 we use parameter lists, that they are ok as well.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|p1
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|p1
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
switch|switch
condition|(
name|comp_target_parms
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|p1
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|p2
argument_list|)
argument_list|,
name|strict
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
return|return
literal|0
return|;
case|case
literal|1
case|:
break|break;
case|case
literal|2
case|:
name|warn_contravariance
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|t1
argument_list|)
operator|&&
name|TREE_PURPOSE
argument_list|(
name|t2
argument_list|)
condition|)
block|{
name|int
name|cmp
init|=
name|simple_cst_equal
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|t2
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
name|my_friendly_abort
argument_list|(
literal|114
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
block|}
return|return
literal|1
operator|+
name|warn_contravariance
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if PARMS specifies a fixed number of parameters    and none of their types is affected by default promotions.  */
end_comment

begin_function
name|int
name|self_promoting_args_p
parameter_list|(
name|parms
parameter_list|)
name|tree
name|parms
decl_stmt|;
block|{
specifier|register
name|tree
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
name|parms
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
specifier|register
name|tree
name|type
init|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|==
literal|0
operator|&&
name|type
operator|!=
name|void_type_node
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|float_type_node
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|type
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|C_PROMOTING_INTEGER_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return an unsigned type the same as TYPE in other respects.     C++: must make these work for type variants as well.  */
end_comment

begin_function
name|tree
name|unsigned_type
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|type1
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|type1
operator|==
name|signed_char_type_node
operator|||
name|type1
operator|==
name|char_type_node
condition|)
return|return
name|unsigned_char_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|integer_type_node
condition|)
return|return
name|unsigned_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|short_integer_type_node
condition|)
return|return
name|short_unsigned_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|long_integer_type_node
condition|)
return|return
name|long_unsigned_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|long_long_integer_type_node
condition|)
return|return
name|long_long_unsigned_type_node
return|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Return a signed type the same as TYPE in other respects.  */
end_comment

begin_function
name|tree
name|signed_type
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|type1
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|type1
operator|==
name|unsigned_char_type_node
operator|||
name|type1
operator|==
name|char_type_node
condition|)
return|return
name|signed_char_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|unsigned_type_node
condition|)
return|return
name|integer_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|short_unsigned_type_node
condition|)
return|return
name|short_integer_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|long_unsigned_type_node
condition|)
return|return
name|long_integer_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|long_long_unsigned_type_node
condition|)
return|return
name|long_long_integer_type_node
return|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Return a type the same as TYPE except unsigned or    signed according to UNSIGNEDP.  */
end_comment

begin_function
name|tree
name|signed_or_unsigned_type
parameter_list|(
name|unsignedp
parameter_list|,
name|type
parameter_list|)
name|int
name|unsignedp
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|type
return|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|signed_char_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_char_type_node
else|:
name|signed_char_type_node
return|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_type_node
else|:
name|integer_type_node
return|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|short_integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|short_unsigned_type_node
else|:
name|short_integer_type_node
return|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|long_integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|long_unsigned_type_node
else|:
name|long_integer_type_node
return|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|long_long_integer_type_node
argument_list|)
condition|)
return|return
operator|(
name|unsignedp
condition|?
name|long_long_unsigned_type_node
else|:
name|long_long_integer_type_node
operator|)
return|;
return|return
name|type
return|;
block|}
end_function

begin_function
name|tree
name|c_sizeof
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|FUNCTION_TYPE
condition|)
block|{
if|if
condition|(
name|pedantic
operator|||
name|warn_pointer_arith
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C++ forbids taking the sizeof a function type"
argument_list|)
expr_stmt|;
return|return
name|size_int
argument_list|(
literal|1
argument_list|)
return|;
block|}
if|if
condition|(
name|code
operator|==
name|METHOD_TYPE
condition|)
block|{
if|if
condition|(
name|pedantic
operator|||
name|warn_pointer_arith
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C++ forbids taking the sizeof a method type"
argument_list|)
expr_stmt|;
return|return
name|size_int
argument_list|(
literal|1
argument_list|)
return|;
block|}
if|if
condition|(
name|code
operator|==
name|VOID_TYPE
condition|)
block|{
if|if
condition|(
name|pedantic
operator|||
name|warn_pointer_arith
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C++ forbids taking the sizeof a void type"
argument_list|)
expr_stmt|;
return|return
name|size_int
argument_list|(
literal|1
argument_list|)
return|;
block|}
if|if
condition|(
name|code
operator|==
name|ERROR_MARK
condition|)
return|return
name|size_int
argument_list|(
literal|1
argument_list|)
return|;
comment|/* ARM $5.3.2: ``When applied to a reference, the result is the size of the      referenced object.'' */
if|if
condition|(
name|code
operator|==
name|REFERENCE_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* We couldn't find anything in the ARM or the draft standard that says,      one way or the other, if doing sizeof on something that doesn't have      an object associated with it is correct or incorrect.  For example, if      you declare `struct S { char str[16]; };', and in your program do      a `sizeof (S::str)', should we flag that as an error or should we give      the size of it?  Since it seems like a reasonable thing to do, we'll go      with giving the value.  */
if|if
condition|(
name|code
operator|==
name|OFFSET_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* @@ This also produces an error for a signature ref.         In that case we should be able to do better.  */
if|if
condition|(
name|IS_SIGNATURE
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"`sizeof' applied to a signature type"
argument_list|)
expr_stmt|;
return|return
name|size_int
argument_list|(
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"`sizeof' applied to an incomplete type"
argument_list|)
expr_stmt|;
return|return
name|size_int
argument_list|(
literal|0
argument_list|)
return|;
block|}
comment|/* Convert in case a char is more than one unit.  */
name|t
operator|=
name|size_binop
argument_list|(
name|CEIL_DIV_EXPR
argument_list|,
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|char_type_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* size_binop does not put the constant in range, so do it now.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|force_fit_type
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
condition|)
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_OVERFLOW
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_function
name|tree
name|c_sizeof_nowarn
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|FUNCTION_TYPE
operator|||
name|code
operator|==
name|METHOD_TYPE
operator|||
name|code
operator|==
name|VOID_TYPE
operator|||
name|code
operator|==
name|ERROR_MARK
condition|)
return|return
name|size_int
argument_list|(
literal|1
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|REFERENCE_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
block|{
if|#
directive|if
literal|0
comment|/* ??? Tiemann, why have any diagnostic here? 	 There is none in the corresponding function for C.  */
block|warning ("sizeof applied to an incomplete type");
endif|#
directive|endif
return|return
name|size_int
argument_list|(
literal|0
argument_list|)
return|;
block|}
comment|/* Convert in case a char is more than one unit.  */
name|t
operator|=
name|size_binop
argument_list|(
name|CEIL_DIV_EXPR
argument_list|,
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|char_type_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|force_fit_type
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Implement the __alignof keyword: Return the minimum required    alignment of TYPE, measured in bytes.  */
end_comment

begin_function
name|tree
name|c_alignof
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|FUNCTION_TYPE
operator|||
name|code
operator|==
name|METHOD_TYPE
condition|)
return|return
name|size_int
argument_list|(
name|FUNCTION_BOUNDARY
operator|/
name|BITS_PER_UNIT
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|VOID_TYPE
operator|||
name|code
operator|==
name|ERROR_MARK
condition|)
return|return
name|size_int
argument_list|(
literal|1
argument_list|)
return|;
comment|/* C++: this is really correct!  */
if|if
condition|(
name|code
operator|==
name|REFERENCE_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* @@ This also produces an error for a signature ref.         In that case we should be able to do better.  */
if|if
condition|(
name|IS_SIGNATURE
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"`__alignof' applied to a signature type"
argument_list|)
expr_stmt|;
return|return
name|size_int
argument_list|(
literal|1
argument_list|)
return|;
block|}
name|t
operator|=
name|size_int
argument_list|(
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|force_fit_type
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Perform default promotions for C data used in expressions.    Arrays and functions are converted to pointers;    enumeral types or short or char, to int.    In addition, manifest constants symbols are replaced by their values.     C++: this will automatically bash references to their target type.  */
end_comment

begin_function
name|tree
name|default_conversion
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
specifier|register
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|OFFSET_TYPE
comment|/* || TREE_CODE (exp) == OFFSET_REF */
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|OFFSET_REF
condition|)
return|return
name|default_conversion
argument_list|(
name|resolve_offset_ref
argument_list|(
name|exp
argument_list|)
argument_list|)
return|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|exp
operator|=
name|convert_from_reference
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
comment|/* Constants can be used directly unless they're not loadable.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONST_DECL
condition|)
name|exp
operator|=
name|DECL_INITIAL
argument_list|(
name|exp
argument_list|)
expr_stmt|;
comment|/* Replace a nonvolatile const static variable with its value.  */
elseif|else
if|if
condition|(
name|TREE_READONLY_DECL_P
argument_list|(
name|exp
argument_list|)
operator|&&
name|DECL_MODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|BLKmode
condition|)
block|{
name|exp
operator|=
name|decl_constant_value
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
block|}
comment|/* build_c_cast puts on a NOP_EXPR to make the result not an lvalue.      Leave such NOP_EXPRs, since RHS is being used in non-lvalue context.  */
if|if
condition|(
name|INTEGRAL_CODE_P
argument_list|(
name|code
argument_list|)
condition|)
block|{
name|tree
name|t
init|=
name|type_promotes_to
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|!=
name|type
condition|)
return|return
name|convert
argument_list|(
name|t
argument_list|,
name|exp
argument_list|)
return|;
block|}
if|if
condition|(
name|flag_traditional
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|float_type_node
condition|)
return|return
name|convert
argument_list|(
name|double_type_node
argument_list|,
name|exp
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|VOID_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"void value not ignored as it ought to be"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|code
operator|==
name|FUNCTION_TYPE
condition|)
block|{
return|return
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|exp
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|code
operator|==
name|METHOD_TYPE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|OFFSET_REF
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
argument_list|,
literal|308
argument_list|)
expr_stmt|;
return|return
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
block|}
return|return
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|exp
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|code
operator|==
name|ARRAY_TYPE
condition|)
block|{
specifier|register
name|tree
name|adr
decl_stmt|;
name|tree
name|restype
decl_stmt|;
name|tree
name|ptrtype
decl_stmt|;
name|int
name|constp
decl_stmt|,
name|volatilep
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
block|{
comment|/* Stripping away the INDIRECT_REF is not the right 	     thing to do for references...  */
name|tree
name|inner
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|inner
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|inner
operator|=
name|build1
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|inner
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|inner
argument_list|)
expr_stmt|;
name|TREE_REFERENCE_EXPR
argument_list|(
name|inner
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|convert
argument_list|(
name|TYPE_POINTER_TO
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|inner
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|COMPOUND_EXPR
condition|)
block|{
name|tree
name|op1
init|=
name|default_conversion
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op1
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|lvalue_p
argument_list|(
name|exp
argument_list|)
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONSTRUCTOR
operator|&&
name|TREE_STATIC
argument_list|(
name|exp
argument_list|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"invalid use of non-lvalue array"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|constp
operator|=
name|volatilep
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
literal|'r'
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
literal|'d'
condition|)
block|{
name|constp
operator|=
name|TREE_READONLY
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|volatilep
operator|=
name|TREE_THIS_VOLATILE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
block|}
name|restype
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_READONLY
argument_list|(
name|type
argument_list|)
operator|||
name|TYPE_VOLATILE
argument_list|(
name|type
argument_list|)
operator|||
name|constp
operator|||
name|volatilep
condition|)
name|restype
operator|=
name|cp_build_type_variant
argument_list|(
name|restype
argument_list|,
name|TYPE_READONLY
argument_list|(
name|type
argument_list|)
operator|||
name|constp
argument_list|,
name|TYPE_VOLATILE
argument_list|(
name|type
argument_list|)
operator|||
name|volatilep
argument_list|)
expr_stmt|;
name|ptrtype
operator|=
name|build_pointer_type
argument_list|(
name|restype
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
comment|/* ??? This is not really quite correct 	     in that the type of the operand of ADDR_EXPR 	     is not the target type of the type of the ADDR_EXPR itself. 	     Question is, can this lossage be avoided?  */
name|adr
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|ptrtype
argument_list|,
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mark_addressable
argument_list|(
name|exp
argument_list|)
operator|==
literal|0
condition|)
return|return
name|error_mark_node
return|;
name|TREE_CONSTANT
argument_list|(
name|adr
argument_list|)
operator|=
name|staticp
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|adr
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Default would be, same as EXP.  */
return|return
name|adr
return|;
block|}
comment|/* This way is better for a COMPONENT_REF since it can 	 simplify the offset for a component.  */
name|adr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|ptrtype
argument_list|,
name|adr
argument_list|)
return|;
block|}
return|return
name|exp
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|tree
name|build_object_ref
parameter_list|(
name|datum
parameter_list|,
name|basetype
parameter_list|,
name|field
parameter_list|)
name|tree
name|datum
decl_stmt|,
name|basetype
decl_stmt|,
name|field
decl_stmt|;
block|{
name|tree
name|dtype
decl_stmt|;
if|if
condition|(
name|datum
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|dtype
operator|=
name|TREE_TYPE
argument_list|(
name|datum
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|dtype
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|dtype
operator|=
name|TREE_TYPE
argument_list|(
name|dtype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IS_AGGR_TYPE_CODE
argument_list|(
name|TREE_CODE
argument_list|(
name|dtype
argument_list|)
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"request for member `%T::%D' in expression of non-aggregate type `%T'"
argument_list|,
name|basetype
argument_list|,
name|field
argument_list|,
name|dtype
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
name|IS_SIGNATURE
argument_list|(
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|basetype
argument_list|)
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"signature name in scope resolution ignored"
argument_list|)
expr_stmt|;
return|return
name|build_component_ref
argument_list|(
name|datum
argument_list|,
name|field
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|is_aggr_typedef
argument_list|(
name|basetype
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|tree
name|real_basetype
init|=
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|basetype
argument_list|)
decl_stmt|;
name|tree
name|binfo
init|=
name|binfo_or_else
argument_list|(
name|real_basetype
argument_list|,
name|TREE_TYPE
argument_list|(
name|datum
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|binfo
condition|)
return|return
name|build_component_ref
argument_list|(
name|build_scoped_ref
argument_list|(
name|datum
argument_list|,
name|basetype
argument_list|)
argument_list|,
name|field
argument_list|,
name|binfo
argument_list|,
literal|1
argument_list|)
return|;
block|}
return|return
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* Like `build_component_ref, but uses an already found field.    Must compute access for C_C_D.  Otherwise, ok.  */
end_comment

begin_function
name|tree
name|build_component_ref_1
parameter_list|(
name|datum
parameter_list|,
name|field
parameter_list|,
name|protect
parameter_list|)
name|tree
name|datum
decl_stmt|,
name|field
decl_stmt|;
name|int
name|protect
decl_stmt|;
block|{
specifier|register
name|tree
name|basetype
init|=
name|TREE_TYPE
argument_list|(
name|datum
argument_list|)
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|basetype
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|ref
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|datum
operator|=
name|convert_from_reference
argument_list|(
name|datum
argument_list|)
expr_stmt|;
name|basetype
operator|=
name|TREE_TYPE
argument_list|(
name|datum
argument_list|)
expr_stmt|;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|IS_AGGR_TYPE_CODE
argument_list|(
name|code
argument_list|)
condition|)
block|{
if|if
condition|(
name|code
operator|!=
name|ERROR_MARK
condition|)
name|cp_error
argument_list|(
literal|"request for member `%D' in `%E', which is of non-aggregate type `%T'"
argument_list|,
name|field
argument_list|,
name|datum
argument_list|,
name|basetype
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|basetype
argument_list|)
operator|==
literal|0
condition|)
block|{
name|incomplete_type_error
argument_list|(
literal|0
argument_list|,
name|basetype
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Look up component name in the structure type definition.  */
if|if
condition|(
name|field
operator|==
name|error_mark_node
condition|)
name|my_friendly_abort
argument_list|(
literal|115
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|field
argument_list|)
condition|)
return|return
name|field
return|;
if|if
condition|(
name|datum
operator|==
name|C_C_D
condition|)
block|{
name|enum
name|access_type
name|access
init|=
name|compute_access
argument_list|(
name|TYPE_BINFO
argument_list|(
name|current_class_type
argument_list|)
argument_list|,
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|access
operator|==
name|access_private
condition|)
block|{
name|cp_error
argument_list|(
literal|"field `%D' is private"
argument_list|,
name|field
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
name|access
operator|==
name|access_protected
condition|)
block|{
name|cp_error
argument_list|(
literal|"field `%D' is protected"
argument_list|,
name|field
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
name|ref
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|datum
argument_list|,
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|datum
argument_list|)
operator|||
name|TREE_READONLY
argument_list|(
name|field
argument_list|)
condition|)
name|TREE_READONLY
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|datum
argument_list|)
operator|||
name|TREE_THIS_VOLATILE
argument_list|(
name|field
argument_list|)
condition|)
name|TREE_THIS_VOLATILE
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|DECL_MUTABLE_P
argument_list|(
name|field
argument_list|)
condition|)
name|TREE_READONLY
argument_list|(
name|ref
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|ref
return|;
block|}
end_function

begin_comment
comment|/* Given a COND_EXPR in T, return it in a form that we can, for    example, use as an lvalue.  This code used to be in unary_complex_lvalue,    but we needed it to deal with `a = (d == c) ? b : c' expressions, where    we're dealing with aggregates.  So, we now call this in unary_complex_lvalue,    and in build_modify_expr.  The case (in particular) that led to this was    with CODE == ADDR_EXPR, since it's not an lvalue when we'd get it there.  */
end_comment

begin_function
specifier|static
name|tree
name|rationalize_conditional_expr
parameter_list|(
name|code
parameter_list|,
name|t
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|t
decl_stmt|;
block|{
return|return
name|build_conditional_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|build_unary_op
argument_list|(
name|code
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|build_unary_op
argument_list|(
name|code
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|tree
name|build_component_ref
parameter_list|(
name|datum
parameter_list|,
name|component
parameter_list|,
name|basetype_path
parameter_list|,
name|protect
parameter_list|)
name|tree
name|datum
decl_stmt|,
name|component
decl_stmt|,
name|basetype_path
decl_stmt|;
name|int
name|protect
decl_stmt|;
block|{
specifier|register
name|tree
name|basetype
init|=
name|TREE_TYPE
argument_list|(
name|datum
argument_list|)
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|basetype
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|field
init|=
name|NULL
decl_stmt|;
specifier|register
name|tree
name|ref
decl_stmt|;
comment|/* If DATUM is a COMPOUND_EXPR or COND_EXPR, move our reference inside it. */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|datum
argument_list|)
condition|)
block|{
case|case
name|COMPOUND_EXPR
case|:
block|{
name|tree
name|value
init|=
name|build_component_ref
argument_list|(
name|TREE_OPERAND
argument_list|(
name|datum
argument_list|,
literal|1
argument_list|)
argument_list|,
name|component
argument_list|,
name|basetype_path
argument_list|,
name|protect
argument_list|)
decl_stmt|;
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|datum
argument_list|,
literal|0
argument_list|)
argument_list|,
name|value
argument_list|)
return|;
block|}
case|case
name|COND_EXPR
case|:
return|return
name|build_conditional_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|datum
argument_list|,
literal|0
argument_list|)
argument_list|,
name|build_component_ref
argument_list|(
name|TREE_OPERAND
argument_list|(
name|datum
argument_list|,
literal|1
argument_list|)
argument_list|,
name|component
argument_list|,
name|basetype_path
argument_list|,
name|protect
argument_list|)
argument_list|,
name|build_component_ref
argument_list|(
name|TREE_OPERAND
argument_list|(
name|datum
argument_list|,
literal|2
argument_list|)
argument_list|,
name|component
argument_list|,
name|basetype_path
argument_list|,
name|protect
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|code
operator|==
name|REFERENCE_TYPE
condition|)
block|{
if|#
directive|if
literal|0
comment|/* TREE_REFERENCE_EXPRs are not converted by `convert_from_reference'. 	 @@ Maybe that is not right.  */
block|if (TREE_REFERENCE_EXPR (datum)) 	datum = build1 (INDIRECT_REF, TREE_TYPE (basetype), datum);       else
endif|#
directive|endif
name|datum
operator|=
name|convert_from_reference
argument_list|(
name|datum
argument_list|)
expr_stmt|;
name|basetype
operator|=
name|TREE_TYPE
argument_list|(
name|datum
argument_list|)
expr_stmt|;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
block|}
comment|/* First, see if there is a field or component with name COMPONENT. */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|component
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
name|my_friendly_assert
argument_list|(
operator|!
operator|(
name|TREE_CHAIN
argument_list|(
name|component
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|DECL_CHAIN
argument_list|(
name|TREE_VALUE
argument_list|(
name|component
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
operator|)
argument_list|,
literal|309
argument_list|)
expr_stmt|;
return|return
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|component
argument_list|)
argument_list|,
name|datum
argument_list|,
name|component
argument_list|)
return|;
block|}
if|#
directive|if
literal|0
block|if (TREE_CODE (component) == TYPE_EXPR)     return build_component_type_expr (datum, component, NULL_TREE, protect);
endif|#
directive|endif
if|if
condition|(
operator|!
name|IS_AGGR_TYPE_CODE
argument_list|(
name|code
argument_list|)
condition|)
block|{
if|if
condition|(
name|code
operator|!=
name|ERROR_MARK
condition|)
name|cp_error
argument_list|(
literal|"request for member `%D' in `%E', which is of non-aggregate type `%T'"
argument_list|,
name|component
argument_list|,
name|datum
argument_list|,
name|basetype
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|basetype
argument_list|)
operator|==
literal|0
condition|)
block|{
name|incomplete_type_error
argument_list|(
literal|0
argument_list|,
name|basetype
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|component
argument_list|)
operator|==
name|BIT_NOT_EXPR
condition|)
block|{
if|if
condition|(
name|TYPE_IDENTIFIER
argument_list|(
name|basetype
argument_list|)
operator|!=
name|TREE_OPERAND
argument_list|(
name|component
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"destructor specifier `%T::~%T' must have matching names"
argument_list|,
name|basetype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|component
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
operator|!
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"type `%T' has no destructor"
argument_list|,
name|basetype
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|basetype
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/* Look up component name in the structure type definition.  */
if|if
condition|(
name|CLASSTYPE_VFIELD
argument_list|(
name|basetype
argument_list|)
operator|&&
name|DECL_NAME
argument_list|(
name|CLASSTYPE_VFIELD
argument_list|(
name|basetype
argument_list|)
argument_list|)
operator|==
name|component
condition|)
comment|/* Special-case this because if we use normal lookups in an ambiguous        hierarchy, the compiler will abort (because vptr lookups are        not supposed to be ambiguous.  */
name|field
operator|=
name|CLASSTYPE_VFIELD
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|basetype_path
operator|==
name|NULL_TREE
condition|)
name|basetype_path
operator|=
name|TYPE_BINFO
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|field
operator|=
name|lookup_field
argument_list|(
name|basetype_path
argument_list|,
name|component
argument_list|,
name|protect
operator|&&
operator|!
name|VFIELD_NAME_P
argument_list|(
name|component
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|field
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|field
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* Not found as a data field, look for it as a method.  If found, 	     then if this is the only possible one, return it, else 	     report ambiguity error.  */
name|tree
name|fndecls
init|=
name|lookup_fnfields
argument_list|(
name|basetype_path
argument_list|,
name|component
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|fndecls
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|fndecls
condition|)
block|{
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|fndecls
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|DECL_CHAIN
argument_list|(
name|TREE_VALUE
argument_list|(
name|fndecls
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|enum
name|access_type
name|access
decl_stmt|;
name|tree
name|fndecl
decl_stmt|;
comment|/* Unique, so use this one now.  */
name|basetype
operator|=
name|TREE_PURPOSE
argument_list|(
name|fndecls
argument_list|)
expr_stmt|;
name|fndecl
operator|=
name|TREE_VALUE
argument_list|(
name|fndecls
argument_list|)
expr_stmt|;
name|access
operator|=
name|compute_access
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|fndecls
argument_list|)
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
operator|==
name|access_public
condition|)
block|{
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|fndecl
argument_list|)
operator|&&
operator|!
name|resolves_to_fixed_type_p
argument_list|(
name|datum
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|tree
name|addr
init|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|datum
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|addr
operator|=
name|convert_pointer_to
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|fndecl
argument_list|)
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|datum
operator|=
name|build_indirect_ref
argument_list|(
name|addr
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|datum
operator|!=
name|error_mark_node
argument_list|,
literal|310
argument_list|)
expr_stmt|;
name|fndecl
operator|=
name|build_vfn_ref
argument_list|(
operator|&
name|addr
argument_list|,
name|datum
argument_list|,
name|DECL_VINDEX
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|fndecl
return|;
block|}
if|if
condition|(
name|access
operator|==
name|access_protected
condition|)
name|cp_error
argument_list|(
literal|"member function `%D' is protected"
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
else|else
name|cp_error
argument_list|(
literal|"member function `%D' is private"
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
else|else
return|return
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|unknown_type_node
argument_list|,
name|datum
argument_list|,
name|fndecls
argument_list|)
return|;
block|}
if|#
directive|if
literal|0
block|if (component == ansi_opname[(int) TYPE_EXPR]) 	    cp_error ("`%#T' has no such type conversion operator", basetype); 	  else
endif|#
directive|endif
name|cp_error
argument_list|(
literal|"`%#T' has no member named `%D'"
argument_list|,
name|basetype
argument_list|,
name|component
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|cp_error
argument_list|(
literal|"invalid use of type decl `%#D' as expression"
argument_list|,
name|field
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|DECL_RTL
argument_list|(
name|field
argument_list|)
operator|!=
literal|0
condition|)
name|assemble_external
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|field
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|field
return|;
block|}
block|}
if|if
condition|(
name|DECL_FIELD_CONTEXT
argument_list|(
name|field
argument_list|)
operator|!=
name|basetype
operator|&&
name|TYPE_USES_COMPLEX_INHERITANCE
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
name|tree
name|addr
init|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|datum
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|integer_zerop
argument_list|(
name|addr
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"invalid reference to NULL ptr, use ptr-to-member instead"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|addr
operator|=
name|convert_pointer_to
argument_list|(
name|DECL_FIELD_CONTEXT
argument_list|(
name|field
argument_list|)
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|datum
operator|=
name|build_indirect_ref
argument_list|(
name|addr
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|datum
operator|!=
name|error_mark_node
argument_list|,
literal|311
argument_list|)
expr_stmt|;
block|}
name|ref
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|break_out_cleanups
argument_list|(
name|datum
argument_list|)
argument_list|,
name|field
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|datum
argument_list|)
operator|||
name|TREE_READONLY
argument_list|(
name|field
argument_list|)
condition|)
name|TREE_READONLY
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|datum
argument_list|)
operator|||
name|TREE_THIS_VOLATILE
argument_list|(
name|field
argument_list|)
condition|)
name|TREE_THIS_VOLATILE
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|DECL_MUTABLE_P
argument_list|(
name|field
argument_list|)
condition|)
name|TREE_READONLY
argument_list|(
name|ref
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|ref
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given an expression PTR for a pointer, return an expression    for the value pointed to.    ERRORSTRING is the name of the operator to appear in error messages.     This function may need to overload OPERATOR_FNNAME.    Must also handle REFERENCE_TYPEs for C++.  */
end_comment

begin_function
name|tree
name|build_x_indirect_ref
parameter_list|(
name|ptr
parameter_list|,
name|errorstring
parameter_list|)
name|tree
name|ptr
decl_stmt|;
name|char
modifier|*
name|errorstring
decl_stmt|;
block|{
name|tree
name|rval
init|=
name|build_opfncall
argument_list|(
name|INDIRECT_REF
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|ptr
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
if|if
condition|(
name|rval
condition|)
return|return
name|rval
return|;
return|return
name|build_indirect_ref
argument_list|(
name|ptr
argument_list|,
name|errorstring
argument_list|)
return|;
block|}
end_function

begin_function
name|tree
name|build_indirect_ref
parameter_list|(
name|ptr
parameter_list|,
name|errorstring
parameter_list|)
name|tree
name|ptr
decl_stmt|;
name|char
modifier|*
name|errorstring
decl_stmt|;
block|{
specifier|register
name|tree
name|pointer
init|=
name|default_conversion
argument_list|(
name|ptr
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|pointer
argument_list|)
decl_stmt|;
if|if
condition|(
name|ptr
operator|==
name|current_class_decl
condition|)
return|return
name|C_C_D
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|pointer
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
operator|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|pointer
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
operator|)
condition|)
return|return
name|TREE_OPERAND
argument_list|(
name|pointer
argument_list|,
literal|0
argument_list|)
return|;
else|else
block|{
name|tree
name|t
init|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|ref
init|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
argument_list|,
name|pointer
argument_list|)
decl_stmt|;
name|TREE_READONLY
argument_list|(
name|ref
argument_list|)
operator|=
name|TYPE_READONLY
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|ref
argument_list|)
operator|=
name|TYPE_VOLATILE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|ref
argument_list|)
operator|=
name|TYPE_VOLATILE
argument_list|(
name|t
argument_list|)
operator|||
name|TREE_SIDE_EFFECTS
argument_list|(
name|pointer
argument_list|)
expr_stmt|;
return|return
name|ref
return|;
block|}
block|}
comment|/* `pointer' won't be an error_mark_node if we were given a      pointer to member, so it's cool to check for this here.  */
elseif|else
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type
argument_list|)
condition|)
name|error
argument_list|(
literal|"invalid use of `%s' on pointer to member function"
argument_list|,
name|errorstring
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
operator|(
name|IS_SIGNATURE_POINTER
argument_list|(
name|type
argument_list|)
operator|||
name|IS_SIGNATURE_REFERENCE
argument_list|(
name|type
argument_list|)
operator|)
condition|)
name|error
argument_list|(
literal|"cannot dereference signature pointer/reference"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pointer
operator|!=
name|error_mark_node
condition|)
block|{
if|if
condition|(
name|errorstring
condition|)
name|error
argument_list|(
literal|"invalid type argument of `%s'"
argument_list|,
name|errorstring
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"invalid type argument"
argument_list|)
expr_stmt|;
block|}
return|return
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* This handles expressions of the form "a[i]", which denotes    an array reference.     This is logically equivalent in C to *(a+i), but we may do it differently.    If A is a variable or a member, we generate a primitive ARRAY_REF.    This avoids forcing the array out of registers, and can work on    arrays that are not lvalues (for example, members of structures returned    by functions).     If INDEX is of some user-defined type, it must be converted to    integer type.  Otherwise, to make a compatible PLUS_EXPR, it    will inherit the type of the array, which will be some pointer type.  */
end_comment

begin_function
name|tree
name|build_x_array_ref
parameter_list|(
name|array
parameter_list|,
name|index
parameter_list|)
name|tree
name|array
decl_stmt|,
name|index
decl_stmt|;
block|{
name|tree
name|rval
init|=
name|build_opfncall
argument_list|(
name|ARRAY_REF
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|array
argument_list|,
name|index
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
if|if
condition|(
name|rval
condition|)
return|return
name|rval
return|;
return|return
name|build_array_ref
argument_list|(
name|array
argument_list|,
name|index
argument_list|)
return|;
block|}
end_function

begin_function
name|tree
name|build_array_ref
parameter_list|(
name|array
parameter_list|,
name|idx
parameter_list|)
name|tree
name|array
decl_stmt|,
name|idx
decl_stmt|;
block|{
name|tree
name|itype
decl_stmt|;
if|if
condition|(
name|idx
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"subscript missing in array reference"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
operator|==
name|error_mark_node
operator|||
name|TREE_TYPE
argument_list|(
name|idx
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|itype
operator|=
name|TREE_TYPE
argument_list|(
name|idx
argument_list|)
expr_stmt|;
comment|/* We must check here for the reference, so we can do the possible      conversions immediately afterwards.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|itype
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|idx
operator|=
name|convert_from_reference
argument_list|(
name|idx
argument_list|)
expr_stmt|;
name|itype
operator|=
name|TREE_TYPE
argument_list|(
name|idx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|itype
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_HAS_INT_CONVERSION
argument_list|(
name|itype
argument_list|)
condition|)
name|idx
operator|=
name|build_type_conversion
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|idx
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
name|error_with_aggr_type
argument_list|(
name|itype
argument_list|,
literal|"type `%s' requires integer conversion for array indexing"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|array
argument_list|)
operator|!=
name|INDIRECT_REF
condition|)
block|{
name|tree
name|rval
decl_stmt|,
name|type
decl_stmt|;
comment|/* Subscripting with type char is likely to lose 	 on a machine where chars are signed. 	 So warn on any machine, but optionally. 	 Don't warn for unsigned char since that type is safe. 	 Don't warn for signed char because anyone who uses that 	 must have done so deliberately.  */
if|if
condition|(
name|warn_char_subscripts
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|idx
argument_list|)
argument_list|)
operator|==
name|char_type_node
condition|)
name|warning
argument_list|(
literal|"array subscript has type `char'"
argument_list|)
expr_stmt|;
comment|/* Apply default promotions *after* noticing character types.  */
name|idx
operator|=
name|default_conversion
argument_list|(
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|idx
argument_list|)
argument_list|)
operator|!=
name|INTEGER_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"array subscript is not an integer"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* An array that is indexed by a non-constant 	 cannot be stored in a register; we must be able to do 	 address arithmetic on its address. 	 Likewise an array of elements of variable size.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|idx
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
operator|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|)
condition|)
block|{
if|if
condition|(
name|mark_addressable
argument_list|(
name|array
argument_list|)
operator|==
literal|0
condition|)
return|return
name|error_mark_node
return|;
block|}
comment|/* An array that is indexed by a constant value which is not within 	 the array bounds cannot be stored in a register either; because we 	 would get a crash in store_bit_field/extract_bit_field when trying 	 to access a non-existent part of the register.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|idx
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TYPE_VALUES
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
operator|&&
operator|!
name|int_fits_type_p
argument_list|(
name|idx
argument_list|,
name|TYPE_VALUES
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|mark_addressable
argument_list|(
name|array
argument_list|)
operator|==
literal|0
condition|)
return|return
name|error_mark_node
return|;
block|}
comment|/* Note in C++ we don't bother warning about subscripting a 	 `register' array, since it's legal in C++ to take the address 	 of something with that storage specification.  */
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|lvalue_p
argument_list|(
name|array
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C++ forbids subscripting non-lvalue array"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pedantic
condition|)
block|{
name|tree
name|foo
init|=
name|array
decl_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|foo
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
name|foo
operator|=
name|TREE_OPERAND
argument_list|(
name|foo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|foo
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_REGISTER
argument_list|(
name|foo
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C++ forbids subscripting non-lvalue array"
argument_list|)
expr_stmt|;
block|}
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|rval
operator|=
name|build
argument_list|(
name|ARRAY_REF
argument_list|,
name|type
argument_list|,
name|array
argument_list|,
name|idx
argument_list|)
expr_stmt|;
comment|/* Array ref is const/volatile if the array elements are 	 or if the array is..  */
name|TREE_READONLY
argument_list|(
name|rval
argument_list|)
operator||=
operator|(
name|TYPE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
argument_list|)
operator||
name|TREE_READONLY
argument_list|(
name|array
argument_list|)
operator|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|rval
argument_list|)
operator||=
operator|(
name|TYPE_VOLATILE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
argument_list|)
operator||
name|TREE_SIDE_EFFECTS
argument_list|(
name|array
argument_list|)
operator|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|rval
argument_list|)
operator||=
operator|(
name|TYPE_VOLATILE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
argument_list|)
comment|/* This was added by rms on 16 Nov 91. 	       It fixes  vol struct foo *a;  a->elts[1]  	       in an inline function. 	       Hope it doesn't break something else.  */
operator||
name|TREE_THIS_VOLATILE
argument_list|(
name|array
argument_list|)
operator|)
expr_stmt|;
return|return
name|require_complete_type
argument_list|(
name|fold
argument_list|(
name|rval
argument_list|)
argument_list|)
return|;
block|}
block|{
name|tree
name|ar
init|=
name|default_conversion
argument_list|(
name|array
argument_list|)
decl_stmt|;
name|tree
name|ind
init|=
name|default_conversion
argument_list|(
name|idx
argument_list|)
decl_stmt|;
comment|/* Put the integer in IND to simplify error checking.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ar
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
condition|)
block|{
name|tree
name|temp
init|=
name|ar
decl_stmt|;
name|ar
operator|=
name|ind
expr_stmt|;
name|ind
operator|=
name|temp
expr_stmt|;
block|}
if|if
condition|(
name|ar
operator|==
name|error_mark_node
condition|)
return|return
name|ar
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ar
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"subscripted value is neither array nor pointer"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ind
argument_list|)
argument_list|)
operator|!=
name|INTEGER_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"array subscript is not an integer"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|build_indirect_ref
argument_list|(
name|build_binary_op_nodefault
argument_list|(
name|PLUS_EXPR
argument_list|,
name|ar
argument_list|,
name|ind
argument_list|,
name|PLUS_EXPR
argument_list|)
argument_list|,
literal|"array indexing"
argument_list|)
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Build a function call to function FUNCTION with parameters PARAMS.    PARAMS is a list--a chain of TREE_LIST nodes--in which the    TREE_VALUE of each node is a parameter-expression.    FUNCTION's data type may be a function type or a pointer-to-function.     For C++: If FUNCTION's data type is a TREE_LIST, then the tree list    is the list of possible methods that FUNCTION could conceivably    be.  If the list of methods comes from a class, then it will be    a list of lists (where each element is associated with the class    that produced it), otherwise it will be a simple list (for    functions overloaded in global scope).     In the first case, TREE_VALUE (function) is the head of one of those    lists, and TREE_PURPOSE is the name of the function.     In the second case, TREE_PURPOSE (function) is the function's    name directly.     DECL is the class instance variable, usually CURRENT_CLASS_DECL.  */
end_comment

begin_comment
comment|/*  * [eichin:19911015.1726EST] actually return a possibly incomplete  * type  */
end_comment

begin_function
name|tree
name|build_x_function_call
parameter_list|(
name|function
parameter_list|,
name|params
parameter_list|,
name|decl
parameter_list|)
name|tree
name|function
decl_stmt|,
name|params
decl_stmt|,
name|decl
decl_stmt|;
block|{
name|tree
name|type
decl_stmt|;
name|int
name|is_method
decl_stmt|;
if|if
condition|(
name|function
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|is_method
operator|=
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|current_class_type
operator|!=
name|NULL_TREE
operator|&&
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|function
argument_list|)
argument_list|)
operator|==
name|function
operator|)
operator|||
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
operator|||
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type
argument_list|)
operator|)
expr_stmt|;
comment|/* Handle methods, friends, and overloaded functions, respectively.  */
if|if
condition|(
name|is_method
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|function
argument_list|)
condition|)
name|function
operator|=
name|DECL_NAME
argument_list|(
name|function
argument_list|)
expr_stmt|;
else|else
name|function
operator|=
name|TYPE_IDENTIFIER
argument_list|(
name|DECL_CLASS_CONTEXT
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
if|#
directive|if
literal|0
block|if (TREE_CODE (TREE_VALUE (function)) == TREE_LIST) 	    function = TREE_PURPOSE (TREE_VALUE (function)); 	  else 	    function = TREE_PURPOSE (function);
else|#
directive|else
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|function
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
argument_list|,
literal|312
argument_list|)
expr_stmt|;
name|function
operator|=
name|TREE_PURPOSE
argument_list|(
name|function
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|!=
name|IDENTIFIER_NODE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|OFFSET_REF
condition|)
block|{
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|0
argument_list|)
condition|)
name|decl
operator|=
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Call via a pointer to member function.  */
if|if
condition|(
name|decl
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"pointer to member function called, but not in class scope"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* What other type of POINTER_TYPE could this be? */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
operator|&&
operator|!
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|!=
name|OFFSET_REF
condition|)
name|function
operator|=
name|build
argument_list|(
name|OFFSET_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|function
argument_list|)
expr_stmt|;
goto|goto
name|do_x_function
goto|;
block|}
comment|/* this is an abbreviated method call.          must go through here in case it is a virtual function. 	 @@ Perhaps this could be optimized.  */
if|if
condition|(
name|decl
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|current_class_type
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"object missing in call to method `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Yow: call from a static member function.  */
name|decl
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|current_class_type
argument_list|)
argument_list|,
name|error_mark_node
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_indirect_ref
argument_list|(
name|decl
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
block|}
return|return
name|build_method_call
argument_list|(
name|decl
argument_list|,
name|function
argument_list|,
name|params
argument_list|,
name|NULL_TREE
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
name|type
operator|==
name|unknown_type_node
condition|)
block|{
comment|/* Should we undo what was done in build_component_ref? */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|==
name|TREE_VEC
condition|)
comment|/* Get the name that build_component_ref hid. */
name|function
operator|=
name|DECL_NAME
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|function
operator|=
name|TREE_PURPOSE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build_method_call
argument_list|(
name|decl
argument_list|,
name|function
argument_list|,
name|params
argument_list|,
name|NULL_TREE
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|function
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|cp_error
argument_list|(
literal|"function `%D' declared overloaded, but no definitions appear with which to resolve it?!?"
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
else|else
block|{
name|tree
name|val
init|=
name|TREE_VALUE
argument_list|(
name|function
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
return|return
name|build_overload_call_maybe
argument_list|(
name|function
argument_list|,
name|params
argument_list|,
name|LOOKUP_COMPLAIN
argument_list|,
operator|(
expr|struct
name|candidate
operator|*
operator|)
literal|0
argument_list|)
return|;
elseif|else
if|if
condition|(
name|DECL_CHAIN
argument_list|(
name|val
argument_list|)
operator|!=
name|NULL_TREE
condition|)
return|return
name|build_overload_call
argument_list|(
name|function
argument_list|,
name|params
argument_list|,
name|LOOKUP_COMPLAIN
argument_list|,
operator|(
expr|struct
name|candidate
operator|*
operator|)
literal|0
argument_list|)
return|;
else|else
name|my_friendly_abort
argument_list|(
literal|360
argument_list|)
expr_stmt|;
block|}
block|}
name|do_x_function
label|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|OFFSET_REF
condition|)
block|{
comment|/* If the component is a data element (or a virtual function), we play 	 games here to make things work.  */
name|tree
name|decl_addr
decl_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|0
argument_list|)
condition|)
name|decl
operator|=
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|decl
operator|=
name|C_C_D
expr_stmt|;
name|decl_addr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|function
operator|=
name|get_member_function_from_ptrfunc
argument_list|(
operator|&
name|decl_addr
argument_list|,
name|decl
argument_list|,
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|params
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|decl_addr
argument_list|,
name|params
argument_list|)
expr_stmt|;
return|return
name|build_function_call
argument_list|(
name|function
argument_list|,
name|params
argument_list|)
return|;
block|}
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|error_mark_node
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_OVERLOADS_CALL_EXPR
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|build_opfncall
argument_list|(
name|CALL_EXPR
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|function
argument_list|,
name|params
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
if|if
condition|(
name|is_method
condition|)
block|{
name|tree
name|fntype
init|=
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
decl_stmt|;
name|tree
name|ctypeptr
decl_stmt|;
comment|/* Explicitly named method?  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|ctypeptr
operator|=
name|TYPE_POINTER_TO
argument_list|(
name|DECL_CLASS_CONTEXT
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Expression with ptr-to-method type?  It could either be a plain 	 usage, or it might be a case where the ptr-to-method is being 	 passed in as an argument.  */
elseif|else
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|fntype
argument_list|)
condition|)
block|{
name|tree
name|rec
init|=
name|TYPE_METHOD_BASETYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|ctypeptr
operator|=
name|TYPE_POINTER_TO
argument_list|(
name|rec
argument_list|)
expr_stmt|;
block|}
comment|/* Unexpected node type?  */
else|else
name|my_friendly_abort
argument_list|(
literal|116
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|current_function_decl
operator|&&
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|current_function_decl
argument_list|)
condition|)
name|error
argument_list|(
literal|"invalid call to member function needing `this' in static member function scope"
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"pointer to member function called, but not in class scope"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
operator|&&
operator|!
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
name|decl
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|decl
operator|=
name|convert_pointer_to
argument_list|(
name|TREE_TYPE
argument_list|(
name|ctypeptr
argument_list|)
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
else|else
name|decl
operator|=
name|build_c_cast
argument_list|(
name|ctypeptr
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|params
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|decl
argument_list|,
name|params
argument_list|)
expr_stmt|;
block|}
return|return
name|build_function_call
argument_list|(
name|function
argument_list|,
name|params
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Resolve a pointer to member function.  INSTANCE is the object    instance to use, if the member points to a virtual member.  */
end_comment

begin_function
name|tree
name|get_member_function_from_ptrfunc
parameter_list|(
name|instance_ptrptr
parameter_list|,
name|instance
parameter_list|,
name|function
parameter_list|)
name|tree
modifier|*
name|instance_ptrptr
decl_stmt|;
name|tree
name|instance
decl_stmt|;
name|tree
name|function
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|OFFSET_REF
condition|)
block|{
name|function
operator|=
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|fntype
init|=
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|index
init|=
name|save_expr
argument_list|(
name|convert
argument_list|(
name|integer_type_node
argument_list|,
name|build_component_ref
argument_list|(
name|function
argument_list|,
name|index_identifier
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|e1
init|=
name|build
argument_list|(
name|GT_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|index
argument_list|,
name|integer_zero_node
argument_list|)
decl_stmt|;
name|tree
name|delta
init|=
name|build_component_ref
argument_list|(
name|function
argument_list|,
name|delta_identifier
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|delta2
init|=
name|DELTA2_FROM_PTRMEMFUNC
argument_list|(
name|function
argument_list|)
decl_stmt|;
name|tree
name|e2
decl_stmt|;
name|tree
name|e3
decl_stmt|;
name|tree
name|aref
decl_stmt|,
name|vtbl
decl_stmt|;
comment|/* convert down to the right base, before using the instance. */
name|instance
operator|=
name|convert_pointer_to_real
argument_list|(
name|TYPE_METHOD_BASETYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|)
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|instance
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|instance
operator|==
name|error_mark_node
condition|)
return|return
name|instance
return|;
name|vtbl
operator|=
name|convert_pointer_to
argument_list|(
name|ptr_type_node
argument_list|,
name|instance
argument_list|)
expr_stmt|;
name|vtbl
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|build_pointer_type
argument_list|(
name|vtable_entry_type
argument_list|)
argument_list|)
argument_list|,
name|vtbl
argument_list|,
name|convert
argument_list|(
name|sizetype
argument_list|,
name|delta2
argument_list|)
argument_list|)
expr_stmt|;
name|vtbl
operator|=
name|build_indirect_ref
argument_list|(
name|vtbl
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|aref
operator|=
name|build_array_ref
argument_list|(
name|vtbl
argument_list|,
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|index
argument_list|,
name|integer_one_node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flag_vtable_thunks
condition|)
block|{
name|aref
operator|=
name|save_expr
argument_list|(
name|aref
argument_list|)
expr_stmt|;
comment|/* Save the intermediate result in a SAVE_EXPR so we don't have to 	     compute each component of the virtual function pointer twice.  */
if|if
condition|(
comment|/* !building_cleanup&& */
name|TREE_CODE
argument_list|(
name|aref
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
name|TREE_OPERAND
argument_list|(
name|aref
argument_list|,
literal|0
argument_list|)
operator|=
name|save_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|aref
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|delta
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|build_conditional_expr
argument_list|(
name|e1
argument_list|,
name|build_component_ref
argument_list|(
name|aref
argument_list|,
name|delta_identifier
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
name|delta
argument_list|)
expr_stmt|;
block|}
operator|*
name|instance_ptrptr
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
operator|*
name|instance_ptrptr
argument_list|)
argument_list|,
operator|*
name|instance_ptrptr
argument_list|,
name|convert
argument_list|(
name|integer_type_node
argument_list|,
name|delta
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_vtable_thunks
condition|)
name|e2
operator|=
name|aref
expr_stmt|;
else|else
name|e2
operator|=
name|build_component_ref
argument_list|(
name|aref
argument_list|,
name|pfn_identifier
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|e3
operator|=
name|PFN_FROM_PTRMEMFUNC
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|e2
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|e3
argument_list|)
expr_stmt|;
name|function
operator|=
name|build_conditional_expr
argument_list|(
name|e1
argument_list|,
name|e2
argument_list|,
name|e3
argument_list|)
expr_stmt|;
block|}
return|return
name|function
return|;
block|}
end_function

begin_function
name|tree
name|build_function_call_real
parameter_list|(
name|function
parameter_list|,
name|params
parameter_list|,
name|require_complete
parameter_list|,
name|flags
parameter_list|)
name|tree
name|function
decl_stmt|,
name|params
decl_stmt|;
name|int
name|require_complete
decl_stmt|,
name|flags
decl_stmt|;
block|{
specifier|register
name|tree
name|fntype
decl_stmt|,
name|fndecl
decl_stmt|;
specifier|register
name|tree
name|value_type
decl_stmt|;
specifier|register
name|tree
name|coerced_params
decl_stmt|;
name|tree
name|name
init|=
name|NULL_TREE
decl_stmt|,
name|assembler_name
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|is_method
decl_stmt|;
comment|/* build_c_cast puts on a NOP_EXPR to make the result not an lvalue.      Strip such NOP_EXPRs, since FUNCTION is used in non-lvalue context.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|function
operator|=
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|name
operator|=
name|DECL_NAME
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|assembler_name
operator|=
name|DECL_ASSEMBLER_NAME
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|GNU_xref_call
argument_list|(
name|current_function_decl
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
condition|?
name|name
else|:
name|TYPE_IDENTIFIER
argument_list|(
name|DECL_CLASS_CONTEXT
argument_list|(
name|function
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assemble_external
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|fndecl
operator|=
name|function
expr_stmt|;
comment|/* Convert anything with function type to a pointer-to-function.  */
if|if
condition|(
name|pedantic
operator|&&
name|name
operator|&&
name|IDENTIFIER_LENGTH
argument_list|(
name|name
argument_list|)
operator|==
literal|4
operator|&&
operator|!
name|strcmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"main"
argument_list|)
operator|&&
name|DECL_CONTEXT
argument_list|(
name|function
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|pedwarn
argument_list|(
literal|"ANSI C++ forbids calling `main' from within program"
argument_list|)
expr_stmt|;
block|}
comment|/* Differs from default_conversion by not setting TREE_ADDRESSABLE 	 (because calling an inline function does not mean the function 	 needs to be separately compiled).  */
if|if
condition|(
name|DECL_INLINE
argument_list|(
name|function
argument_list|)
condition|)
block|{
name|fntype
operator|=
name|build_type_variant
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|,
name|TREE_READONLY
argument_list|(
name|function
argument_list|)
argument_list|,
name|TREE_THIS_VOLATILE
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
name|function
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|fntype
argument_list|)
argument_list|,
name|function
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assemble_external
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|function
argument_list|)
operator|=
literal|1
expr_stmt|;
name|function
operator|=
name|default_conversion
argument_list|(
name|function
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|fndecl
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Convert anything with function type to a pointer-to-function.  */
if|if
condition|(
name|function
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|function
operator|=
name|default_conversion
argument_list|(
name|function
argument_list|)
expr_stmt|;
block|}
name|fntype
operator|=
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|fntype
argument_list|)
condition|)
block|{
name|tree
name|instance_ptr
init|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|C_C_D
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|fntype
operator|=
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|fntype
argument_list|)
expr_stmt|;
name|function
operator|=
name|get_member_function_from_ptrfunc
argument_list|(
operator|&
name|instance_ptr
argument_list|,
name|C_C_D
argument_list|,
name|function
argument_list|)
expr_stmt|;
block|}
name|is_method
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|)
operator|||
name|is_method
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"called object is not a function"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* fntype now gets the type of function pointed to.  */
name|fntype
operator|=
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
expr_stmt|;
comment|/* Convert the parameters to the types declared in the      function prototype, or apply default promotions.  */
if|if
condition|(
name|flags
operator|&
name|LOOKUP_COMPLAIN
condition|)
name|coerced_params
operator|=
name|convert_arguments
argument_list|(
name|NULL_TREE
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
argument_list|,
name|params
argument_list|,
name|fndecl
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
expr_stmt|;
else|else
name|coerced_params
operator|=
name|convert_arguments
argument_list|(
name|NULL_TREE
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
argument_list|,
name|params
argument_list|,
name|fndecl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Check for errors in format strings.  */
if|if
condition|(
name|warn_format
operator|&&
operator|(
name|name
operator|||
name|assembler_name
operator|)
condition|)
name|check_function_format
argument_list|(
name|name
argument_list|,
name|assembler_name
argument_list|,
name|coerced_params
argument_list|)
expr_stmt|;
comment|/* Recognize certain built-in functions so we can make tree-codes      other than CALL_EXPR.  We do this when it enables fold-const.c      to do something useful.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_BUILT_IN
argument_list|(
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
switch|switch
condition|(
name|DECL_FUNCTION_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|BUILT_IN_ABS
case|:
case|case
name|BUILT_IN_LABS
case|:
case|case
name|BUILT_IN_FABS
case|:
if|if
condition|(
name|coerced_params
operator|==
literal|0
condition|)
return|return
name|integer_zero_node
return|;
return|return
name|build_unary_op
argument_list|(
name|ABS_EXPR
argument_list|,
name|TREE_VALUE
argument_list|(
name|coerced_params
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/* C++ */
name|value_type
operator|=
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
condition|?
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
else|:
name|void_type_node
expr_stmt|;
block|{
specifier|register
name|tree
name|result
init|=
name|build
argument_list|(
name|CALL_EXPR
argument_list|,
name|value_type
argument_list|,
name|function
argument_list|,
name|coerced_params
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Remove this sometime. */
name|TREE_RAISES
argument_list|(
name|result
argument_list|)
operator||=
operator|!
operator|!
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|fntype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|require_complete
condition|)
return|return
name|result
return|;
if|if
condition|(
name|value_type
operator|==
name|void_type_node
condition|)
return|return
name|result
return|;
return|return
name|require_complete_type
argument_list|(
name|result
argument_list|)
return|;
block|}
block|}
end_function

begin_function
name|tree
name|build_function_call
parameter_list|(
name|function
parameter_list|,
name|params
parameter_list|)
name|tree
name|function
decl_stmt|,
name|params
decl_stmt|;
block|{
return|return
name|build_function_call_real
argument_list|(
name|function
argument_list|,
name|params
argument_list|,
literal|1
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
return|;
block|}
end_function

begin_function
name|tree
name|build_function_call_maybe
parameter_list|(
name|function
parameter_list|,
name|params
parameter_list|)
name|tree
name|function
decl_stmt|,
name|params
decl_stmt|;
block|{
return|return
name|build_function_call_real
argument_list|(
name|function
argument_list|,
name|params
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Convert the actual parameter expressions in the list VALUES    to the types in the list TYPELIST.    If parmdecls is exhausted, or when an element has NULL as its type,    perform the default conversions.     RETURN_LOC is the location of the return value, if known, NULL_TREE    otherwise.  This is useful in the case where we can avoid creating    a temporary variable in the case where we can initialize the return    value directly.  If we are not eliding constructors, then we set this    to NULL_TREE to avoid this avoidance.     NAME is an IDENTIFIER_NODE or 0.  It is used only for error messages.     This is also where warnings about wrong number of args are generated.        Return a list of expressions for the parameters as converted.     Both VALUES and the returned value are chains of TREE_LIST nodes    with the elements of the list in the TREE_VALUE slots of those nodes.     In C++, unspecified trailing parameters can be filled in with their    default arguments, if such were specified.  Do so here.  */
end_comment

begin_function
name|tree
name|convert_arguments
parameter_list|(
name|return_loc
parameter_list|,
name|typelist
parameter_list|,
name|values
parameter_list|,
name|fndecl
parameter_list|,
name|flags
parameter_list|)
name|tree
name|return_loc
decl_stmt|,
name|typelist
decl_stmt|,
name|values
decl_stmt|,
name|fndecl
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
specifier|extern
name|tree
name|gc_protect_fndecl
decl_stmt|;
specifier|register
name|tree
name|typetail
decl_stmt|,
name|valtail
decl_stmt|;
specifier|register
name|tree
name|result
init|=
name|NULL_TREE
decl_stmt|;
name|char
modifier|*
name|called_thing
decl_stmt|;
name|int
name|maybe_raises
init|=
literal|0
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|flag_elide_constructors
condition|)
name|return_loc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fndecl
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
operator|==
name|NULL_TREE
operator|||
name|IDENTIFIER_HAS_TYPE_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
condition|)
name|called_thing
operator|=
literal|"constructor"
expr_stmt|;
else|else
name|called_thing
operator|=
literal|"member function"
expr_stmt|;
block|}
else|else
name|called_thing
operator|=
literal|"function"
expr_stmt|;
block|}
for|for
control|(
name|valtail
operator|=
name|values
operator|,
name|typetail
operator|=
name|typelist
init|;
name|valtail
condition|;
name|valtail
operator|=
name|TREE_CHAIN
argument_list|(
name|valtail
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
specifier|register
name|tree
name|type
init|=
name|typetail
condition|?
name|TREE_VALUE
argument_list|(
name|typetail
argument_list|)
else|:
literal|0
decl_stmt|;
specifier|register
name|tree
name|val
init|=
name|TREE_VALUE
argument_list|(
name|valtail
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|void_type_node
condition|)
block|{
if|if
condition|(
name|fndecl
condition|)
block|{
name|char
modifier|*
name|buf
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|40
operator|+
name|strlen
argument_list|(
name|called_thing
argument_list|)
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"too many arguments to %s `%%s'"
argument_list|,
name|called_thing
argument_list|)
expr_stmt|;
name|error_with_decl
argument_list|(
name|fndecl
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"at this point in file"
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"too many arguments to function"
argument_list|)
expr_stmt|;
comment|/* In case anybody wants to know if this argument 	     list is valid.  */
if|if
condition|(
name|result
condition|)
name|TREE_TYPE
argument_list|(
name|tree_last
argument_list|(
name|result
argument_list|)
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
break|break;
block|}
comment|/* The tree type of the parameter being passed may not yet be 	 known.  In this case, its type is TYPE_UNKNOWN, and will 	 be instantiated by the type given by TYPE.  If TYPE 	 is also NULL, the tree type of VAL is ERROR_MARK_NODE.  */
if|if
condition|(
name|type
operator|&&
name|type_unknown_p
argument_list|(
name|val
argument_list|)
condition|)
name|val
operator|=
name|require_instantiated_type
argument_list|(
name|type
argument_list|,
name|val
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type_unknown_p
argument_list|(
name|val
argument_list|)
condition|)
block|{
comment|/* Strip the `&' from an overloaded FUNCTION_DECL.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
name|val
operator|=
name|TREE_OPERAND
argument_list|(
name|val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|TREE_CHAIN
argument_list|(
name|val
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
operator|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
operator|==
name|unknown_type_node
operator|||
name|DECL_CHAIN
argument_list|(
name|TREE_VALUE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
operator|)
condition|)
comment|/* Instantiates automatically.  */
name|val
operator|=
name|TREE_VALUE
argument_list|(
name|val
argument_list|)
expr_stmt|;
else|else
block|{
name|error
argument_list|(
literal|"insufficient type information in parameter list"
argument_list|)
expr_stmt|;
name|val
operator|=
name|integer_zero_node
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|OFFSET_REF
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
comment|/* This is unclean.  Should be handled elsewhere. */
name|val
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|OFFSET_REF
condition|)
name|val
operator|=
name|resolve_offset_ref
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|{
if|#
directive|if
literal|0
comment|/* This code forces the assumption that if we have a ptr-to-func 	   type in an arglist, that every routine that wants to check 	   its validity has done so, and thus we need not do any 	   more conversion.  I don't remember why this is necessary.  */
block|else if (TREE_CODE (ttype) == FUNCTION_TYPE&& (type == NULL 		     || TREE_CODE (TREE_TYPE (type)) == FUNCTION_TYPE 		     || TREE_CODE (TREE_TYPE (type)) == VOID_TYPE)) 	  { 	    type = build_pointer_type (ttype); 	  }
endif|#
directive|endif
block|}
comment|/* build_c_cast puts on a NOP_EXPR to make the result not an lvalue. 	 Strip such NOP_EXPRs, since VAL is used in non-lvalue context.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|val
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|(
name|type
operator|==
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|REFERENCE_TYPE
operator|)
condition|)
name|val
operator|=
name|TREE_OPERAND
argument_list|(
name|val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|REFERENCE_TYPE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|val
operator|=
name|default_conversion
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|require_complete_type
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|==
name|error_mark_node
condition|)
continue|continue;
name|maybe_raises
operator||=
name|TREE_RAISES
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
literal|0
condition|)
block|{
comment|/* Formal parm type is specified by a function prototype.  */
name|tree
name|parmval
decl_stmt|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"parameter type of called function is incomplete"
argument_list|)
expr_stmt|;
name|parmval
operator|=
name|val
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
literal|0
operator|&&
name|defined
argument_list|(
name|PROMOTE_PROTOTYPES
argument_list|)
comment|/* This breaks user-defined conversions.  */
comment|/* Rather than truncating and then reextending, 		 convert directly to int, if that's the type we will want.  */
block|if (! flag_traditional&& (TREE_CODE (type) == INTEGER_TYPE 		      || TREE_CODE (type) == ENUMERAL_TYPE)&& (TYPE_PRECISION (type)< TYPE_PRECISION (integer_type_node))) 		type = integer_type_node;
endif|#
directive|endif
name|parmval
operator|=
name|convert_for_initialization
argument_list|(
name|return_loc
argument_list|,
name|type
argument_list|,
name|val
argument_list|,
name|flags
argument_list|,
literal|"argument passing"
argument_list|,
name|fndecl
argument_list|,
name|i
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PROMOTE_PROTOTYPES
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|)
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|)
condition|)
name|parmval
operator|=
name|default_conversion
argument_list|(
name|parmval
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|result
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|parmval
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|val
operator|=
name|convert_from_reference
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|REAL_TYPE
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|double_type_node
argument_list|)
operator|)
condition|)
comment|/* Convert `float' to `double'.  */
name|result
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|convert
argument_list|(
name|double_type_node
argument_list|,
name|val
argument_list|)
argument_list|,
name|result
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|&&
operator|(
name|TYPE_HAS_INIT_REF
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|||
name|TYPE_HAS_ASSIGN_REF
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|cp_warning
argument_list|(
literal|"cannot pass objects of type `%T' through `...'"
argument_list|,
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|val
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Convert `short' and `char' to full-size `int'.  */
name|result
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|default_conversion
argument_list|(
name|val
argument_list|)
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_gc
comment|/* There are certain functions for which we don't need 	     to protect our arguments.  GC_PROTECT_FNDECL is one.  */
operator|&&
name|fndecl
operator|!=
name|gc_protect_fndecl
operator|&&
name|type_needs_gc_entry
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|result
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|!
name|value_safe_from_gc
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_VALUE
argument_list|(
name|result
argument_list|)
argument_list|)
condition|)
comment|/* This will build a temporary variable whose cleanup is 	   to clear the obstack entry.  */
name|TREE_VALUE
argument_list|(
name|result
argument_list|)
operator|=
name|protect_value_from_gc
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_VALUE
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|typetail
condition|)
name|typetail
operator|=
name|TREE_CHAIN
argument_list|(
name|typetail
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|typetail
operator|!=
literal|0
operator|&&
name|typetail
operator|!=
name|void_list_node
condition|)
block|{
comment|/* See if there are default arguments that can be used */
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|typetail
argument_list|)
condition|)
block|{
for|for
control|(
init|;
name|typetail
operator|!=
name|void_list_node
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|type
init|=
name|TREE_VALUE
argument_list|(
name|typetail
argument_list|)
decl_stmt|;
name|tree
name|val
init|=
name|TREE_PURPOSE
argument_list|(
name|typetail
argument_list|)
decl_stmt|;
name|tree
name|parmval
decl_stmt|;
if|if
condition|(
name|val
operator|==
name|NULL_TREE
condition|)
name|parmval
operator|=
name|error_mark_node
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
block|{
name|parmval
operator|=
name|digest_init
argument_list|(
name|type
argument_list|,
name|val
argument_list|,
operator|(
name|tree
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|parmval
operator|=
name|convert_for_initialization
argument_list|(
name|return_loc
argument_list|,
name|type
argument_list|,
name|parmval
argument_list|,
name|flags
argument_list|,
literal|"default constructor"
argument_list|,
name|fndecl
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This could get clobbered by the following call.  */
if|if
condition|(
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|val
argument_list|)
condition|)
name|val
operator|=
name|copy_node
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|parmval
operator|=
name|convert_for_initialization
argument_list|(
name|return_loc
argument_list|,
name|type
argument_list|,
name|val
argument_list|,
name|flags
argument_list|,
literal|"default argument"
argument_list|,
name|fndecl
argument_list|,
name|i
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PROMOTE_PROTOTYPES
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|)
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|)
condition|)
name|parmval
operator|=
name|default_conversion
argument_list|(
name|parmval
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|maybe_raises
operator||=
name|TREE_RAISES
argument_list|(
name|parmval
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_gc
operator|&&
name|type_needs_gc_entry
argument_list|(
name|TREE_TYPE
argument_list|(
name|parmval
argument_list|)
argument_list|)
operator|&&
operator|!
name|value_safe_from_gc
argument_list|(
name|NULL_TREE
argument_list|,
name|parmval
argument_list|)
condition|)
name|parmval
operator|=
name|protect_value_from_gc
argument_list|(
name|NULL_TREE
argument_list|,
name|parmval
argument_list|)
expr_stmt|;
name|result
operator|=
name|tree_cons
argument_list|(
literal|0
argument_list|,
name|parmval
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|typetail
operator|=
name|TREE_CHAIN
argument_list|(
name|typetail
argument_list|)
expr_stmt|;
comment|/* ends with `...'.  */
if|if
condition|(
name|typetail
operator|==
name|NULL_TREE
condition|)
break|break;
block|}
block|}
else|else
block|{
if|if
condition|(
name|fndecl
condition|)
block|{
name|char
modifier|*
name|buf
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|32
operator|+
name|strlen
argument_list|(
name|called_thing
argument_list|)
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"too few arguments to %s `%%#D'"
argument_list|,
name|called_thing
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
name|buf
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"at this point in file"
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"too few arguments to function"
argument_list|)
expr_stmt|;
return|return
name|error_mark_list
return|;
block|}
block|}
if|if
condition|(
name|result
condition|)
name|TREE_RAISES
argument_list|(
name|result
argument_list|)
operator|=
name|maybe_raises
expr_stmt|;
return|return
name|nreverse
argument_list|(
name|result
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Build a binary-operation expression, after performing default    conversions on the operands.  CODE is the kind of expression to build.  */
end_comment

begin_function
name|tree
name|build_x_binary_op
parameter_list|(
name|code
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
block|{
name|tree
name|rval
init|=
name|build_opfncall
argument_list|(
name|code
argument_list|,
name|LOOKUP_SPECULATIVELY
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
if|if
condition|(
name|rval
condition|)
return|return
name|build_opfncall
argument_list|(
name|code
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|NULL_TREE
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|MEMBER_REF
condition|)
return|return
name|build_m_component_ref
argument_list|(
name|build_indirect_ref
argument_list|(
name|arg1
argument_list|,
name|NULL_PTR
argument_list|)
argument_list|,
name|arg2
argument_list|)
return|;
return|return
name|build_binary_op
argument_list|(
name|code
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
name|tree
name|build_binary_op
parameter_list|(
name|code
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|,
name|convert_p
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
name|int
name|convert_p
decl_stmt|;
block|{
name|tree
name|type1
decl_stmt|,
name|type2
decl_stmt|;
name|tree
name|args
index|[
literal|2
index|]
decl_stmt|;
name|args
index|[
literal|0
index|]
operator|=
name|arg1
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|arg2
expr_stmt|;
if|if
condition|(
name|convert_p
condition|)
block|{
name|args
index|[
literal|0
index|]
operator|=
name|default_conversion
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|default_conversion
argument_list|(
name|args
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|type_unknown_p
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|args
index|[
literal|0
index|]
operator|=
name|instantiate_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|args
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|args
index|[
literal|0
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|args
index|[
literal|0
index|]
operator|=
name|default_conversion
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type_unknown_p
argument_list|(
name|args
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|args
index|[
literal|1
index|]
operator|=
name|require_instantiated_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|args
index|[
literal|1
index|]
argument_list|,
name|error_mark_node
argument_list|)
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|default_conversion
argument_list|(
name|args
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|type1
operator|=
name|TREE_TYPE
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|type2
operator|=
name|TREE_TYPE
argument_list|(
name|args
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE_2
argument_list|(
name|type1
argument_list|,
name|type2
argument_list|)
operator|&&
operator|!
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type1
argument_list|)
condition|)
block|{
comment|/* Try to convert this to something reasonable.  */
if|if
condition|(
operator|!
name|build_default_binary_type_conversion
argument_list|(
name|code
argument_list|,
operator|&
name|args
index|[
literal|0
index|]
argument_list|,
operator|&
name|args
index|[
literal|1
index|]
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|IS_AGGR_TYPE
argument_list|(
name|type1
argument_list|)
operator|&&
operator|!
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type1
argument_list|)
operator|)
operator|||
operator|(
name|IS_AGGR_TYPE
argument_list|(
name|type2
argument_list|)
operator|&&
operator|!
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type2
argument_list|)
operator|)
condition|)
block|{
name|int
name|convert_index
init|=
name|IS_AGGR_TYPE
argument_list|(
name|type2
argument_list|)
decl_stmt|;
comment|/* Avoid being tripped up by things like (ARG1 != 0).  */
name|tree
name|types
index|[
literal|2
index|]
decl_stmt|,
name|try
decl_stmt|;
name|types
index|[
literal|0
index|]
operator|=
name|type1
expr_stmt|;
name|types
index|[
literal|1
index|]
operator|=
name|type2
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|TRUTH_ANDIF_EXPR
operator|||
name|code
operator|==
name|TRUTH_ORIF_EXPR
condition|)
name|try
operator|=
name|build_type_conversion
argument_list|(
name|code
argument_list|,
name|bool_type_node
argument_list|,
name|args
index|[
name|convert_index
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
name|try
operator|=
name|build_type_conversion
argument_list|(
name|code
argument_list|,
name|types
index|[
name|convert_index
operator|^
literal|1
index|]
argument_list|,
name|args
index|[
name|convert_index
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|try
operator|==
literal|0
operator|&&
name|args
index|[
literal|1
index|]
operator|==
name|integer_zero_node
operator|&&
operator|(
name|code
operator|==
name|NE_EXPR
operator|||
name|code
operator|==
name|EQ_EXPR
operator|)
condition|)
name|try
operator|=
name|build_type_conversion
argument_list|(
name|code
argument_list|,
name|ptr_type_node
argument_list|,
name|args
index|[
name|convert_index
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|try
operator|==
literal|0
condition|)
block|{
name|cp_error
argument_list|(
literal|"no match for `%O(%#T, %#T)'"
argument_list|,
name|code
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|try
operator|==
name|error_mark_node
condition|)
name|error
argument_list|(
literal|"ambiguous pointer conversion"
argument_list|)
expr_stmt|;
name|args
index|[
name|convert_index
index|]
operator|=
name|try
expr_stmt|;
block|}
block|}
return|return
name|build_binary_op_nodefault
argument_list|(
name|code
argument_list|,
name|args
index|[
literal|0
index|]
argument_list|,
name|args
index|[
literal|1
index|]
argument_list|,
name|code
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Build a binary-operation expression without default conversions.    CODE is the kind of expression to build.    This function differs from `build' in several ways:    the data type of the result is computed and recorded in it,    warnings are generated if arg data types are invalid,    special handling for addition and subtraction of pointers is known,    and some optimization is done (operations on narrow ints    are done in the narrower type when that gives the same result).    Constant folding is also done before the result is returned.     ERROR_CODE is the code that determines what to say in error messages.    It is usually, but not always, the same as CODE.     Note that the operands will never have enumeral types    because either they have just had the default conversions performed    or they have both just been converted to some other type in which    the arithmetic is to be done.     C++: must do special pointer arithmetic when implementing    multiple inheritance, and deal with pointer to member functions.  */
end_comment

begin_function
name|tree
name|build_binary_op_nodefault
parameter_list|(
name|code
parameter_list|,
name|orig_op0
parameter_list|,
name|orig_op1
parameter_list|,
name|error_code
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|orig_op0
decl_stmt|,
name|orig_op1
decl_stmt|;
name|enum
name|tree_code
name|error_code
decl_stmt|;
block|{
name|tree
name|op0
decl_stmt|,
name|op1
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|code0
decl_stmt|,
name|code1
decl_stmt|;
name|tree
name|type0
decl_stmt|,
name|type1
decl_stmt|;
comment|/* Expression code to give to the expression when it is built.      Normally this is CODE, which is what the caller asked for,      but in some special cases we change it.  */
specifier|register
name|enum
name|tree_code
name|resultcode
init|=
name|code
decl_stmt|;
comment|/* Data type in which the computation is to be performed.      In the simplest cases this is the common type of the arguments.  */
specifier|register
name|tree
name|result_type
init|=
name|NULL
decl_stmt|;
comment|/* Nonzero means operands have already been type-converted      in whatever way is necessary.      Zero means they need to be converted to RESULT_TYPE.  */
name|int
name|converted
init|=
literal|0
decl_stmt|;
comment|/* Nonzero means after finally constructing the expression      give it this type.  Otherwise, give it type RESULT_TYPE.  */
name|tree
name|final_type
init|=
literal|0
decl_stmt|;
comment|/* Nonzero if this is an operation like MIN or MAX which can      safely be computed in short if both args are promoted shorts.      Also implies COMMON.      -1 indicates a bitwise operation; this makes a difference      in the exact conditions for when it is safe to do the operation      in a narrower mode.  */
name|int
name|shorten
init|=
literal|0
decl_stmt|;
comment|/* Nonzero if this is a comparison operation;      if both args are promoted shorts, compare the original shorts.      Also implies COMMON.  */
name|int
name|short_compare
init|=
literal|0
decl_stmt|;
comment|/* Nonzero if this is a right-shift operation, which can be computed on the      original short and then promoted if the operand is a promoted short.  */
name|int
name|short_shift
init|=
literal|0
decl_stmt|;
comment|/* Nonzero means set RESULT_TYPE to the common type of the args.  */
name|int
name|common
init|=
literal|0
decl_stmt|;
comment|/* Apply default conversions.  */
name|op0
operator|=
name|default_conversion
argument_list|(
name|orig_op0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|default_conversion
argument_list|(
name|orig_op1
argument_list|)
expr_stmt|;
name|type0
operator|=
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|type1
operator|=
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
expr_stmt|;
comment|/* The expression codes of the data types of the arguments tell us      whether the arguments are integers, floating, pointers, etc.  */
name|code0
operator|=
name|TREE_CODE
argument_list|(
name|type0
argument_list|)
expr_stmt|;
name|code1
operator|=
name|TREE_CODE
argument_list|(
name|type1
argument_list|)
expr_stmt|;
comment|/* Strip NON_LVALUE_EXPRs, etc., since we aren't using as an lvalue.  */
name|STRIP_TYPE_NOPS
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|STRIP_TYPE_NOPS
argument_list|(
name|op1
argument_list|)
expr_stmt|;
comment|/* If an error was already reported for one of the arguments,      avoid reporting another error.  */
if|if
condition|(
name|code0
operator|==
name|ERROR_MARK
operator|||
name|code1
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PLUS_EXPR
case|:
comment|/* Handle the pointer + int case.  */
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
return|return
name|pointer_int_sum
argument_list|(
name|PLUS_EXPR
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
return|;
elseif|else
if|if
condition|(
name|code1
operator|==
name|POINTER_TYPE
operator|&&
name|code0
operator|==
name|INTEGER_TYPE
condition|)
return|return
name|pointer_int_sum
argument_list|(
name|PLUS_EXPR
argument_list|,
name|op1
argument_list|,
name|op0
argument_list|)
return|;
else|else
name|common
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|MINUS_EXPR
case|:
comment|/* Subtraction of two similar pointers. 	 We must subtract them as integers, then divide by object size.  */
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|POINTER_TYPE
operator|&&
name|comp_target_types
argument_list|(
name|type0
argument_list|,
name|type1
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|pointer_diff
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
return|;
comment|/* Handle pointer minus int.  Just like pointer plus int.  */
elseif|else
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
return|return
name|pointer_int_sum
argument_list|(
name|MINUS_EXPR
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
return|;
else|else
name|common
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|MULT_EXPR
case|:
name|common
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|CEIL_DIV_EXPR
case|:
case|case
name|FLOOR_DIV_EXPR
case|:
case|case
name|ROUND_DIV_EXPR
case|:
case|case
name|EXACT_DIV_EXPR
case|:
if|if
condition|(
operator|(
name|code0
operator|==
name|INTEGER_TYPE
operator|||
name|code0
operator|==
name|REAL_TYPE
operator|)
operator|&&
operator|(
name|code1
operator|==
name|INTEGER_TYPE
operator|||
name|code1
operator|==
name|REAL_TYPE
operator|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|integer_zerop
argument_list|(
name|op1
argument_list|)
condition|)
name|cp_warning
argument_list|(
literal|"division by zero in `%E / 0'"
argument_list|,
name|op0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|REAL_CST
operator|&&
name|real_zerop
argument_list|(
name|op1
argument_list|)
condition|)
name|cp_warning
argument_list|(
literal|"division by zero in `%E / 0.'"
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|code0
operator|==
name|INTEGER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
operator|)
condition|)
name|resultcode
operator|=
name|RDIV_EXPR
expr_stmt|;
else|else
comment|/* When dividing two signed integers, we have to promote to int. 	       unless we divide by a conatant != -1.  Note that default 	       conversion will have been performed on the operands at this 	       point, so we have to dig out the original type to find out if 	       it was unsigned.  */
name|shorten
operator|=
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|op1
argument_list|)
operator|!=
operator|-
literal|1
operator|||
name|TREE_INT_CST_HIGH
argument_list|(
name|op1
argument_list|)
operator|!=
operator|-
literal|1
operator|)
operator|)
operator|)
expr_stmt|;
name|common
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|BIT_AND_EXPR
case|:
case|case
name|BIT_ANDTC_EXPR
case|:
case|case
name|BIT_IOR_EXPR
case|:
case|case
name|BIT_XOR_EXPR
case|:
if|if
condition|(
name|code0
operator|==
name|INTEGER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
name|shorten
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* If one operand is a constant, and the other is a short type 	 that has been converted to an int, 	 really do the work in the short type and then convert the 	 result to int.  If we are lucky, the constant will be 0 or 1 	 in the short type, making the entire operation go away.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TYPE_PRECISION
argument_list|(
name|type1
argument_list|)
operator|>
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|final_type
operator|=
name|result_type
expr_stmt|;
name|op1
operator|=
name|TREE_OPERAND
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TYPE_PRECISION
argument_list|(
name|type0
argument_list|)
operator|>
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|final_type
operator|=
name|result_type
expr_stmt|;
name|op0
operator|=
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TRUNC_MOD_EXPR
case|:
case|case
name|FLOOR_MOD_EXPR
case|:
if|if
condition|(
name|code1
operator|==
name|INTEGER_TYPE
operator|&&
name|integer_zerop
argument_list|(
name|op1
argument_list|)
condition|)
name|cp_warning
argument_list|(
literal|"division by zero in `%E % 0'"
argument_list|,
name|op0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code1
operator|==
name|REAL_TYPE
operator|&&
name|real_zerop
argument_list|(
name|op1
argument_list|)
condition|)
name|cp_warning
argument_list|(
literal|"division by zero in `%E % 0.'"
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|code0
operator|==
name|INTEGER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
block|{
comment|/* Although it would be tempting to shorten always here, that loses 	     on some targets, since the modulo instruction is undefined if the 	     quotient can't be represented in the computation mode.  We shorten 	     only if unsigned or if dividing by something we know != -1.  */
name|shorten
operator|=
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|op1
argument_list|)
operator|!=
operator|-
literal|1
operator|||
name|TREE_INT_CST_HIGH
argument_list|(
name|op1
argument_list|)
operator|!=
operator|-
literal|1
operator|)
operator|)
operator|)
expr_stmt|;
name|common
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|TRUTH_ANDIF_EXPR
case|:
case|case
name|TRUTH_ORIF_EXPR
case|:
case|case
name|TRUTH_AND_EXPR
case|:
case|case
name|TRUTH_OR_EXPR
case|:
name|result_type
operator|=
name|bool_type_node
expr_stmt|;
name|op0
operator|=
name|bool_truthvalue_conversion
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|bool_truthvalue_conversion
argument_list|(
name|op1
argument_list|)
expr_stmt|;
name|converted
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* Shift operations: result has same type as first operand; 	 always convert second operand to int. 	 Also set SHORT_SHIFT if shifting rightward.  */
case|case
name|RSHIFT_EXPR
case|:
if|if
condition|(
name|code0
operator|==
name|INTEGER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
block|{
name|result_type
operator|=
name|type0
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|op1
argument_list|,
name|integer_zero_node
argument_list|)
condition|)
name|warning
argument_list|(
literal|"right shift count is negative"
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|TREE_INT_CST_LOW
argument_list|(
name|op1
argument_list|)
operator||
name|TREE_INT_CST_HIGH
argument_list|(
name|op1
argument_list|)
condition|)
name|short_shift
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_INT_CST_HIGH
argument_list|(
name|op1
argument_list|)
operator|!=
literal|0
operator|||
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|TREE_INT_CST_LOW
argument_list|(
name|op1
argument_list|)
operator|>=
name|TYPE_PRECISION
argument_list|(
name|type0
argument_list|)
operator|)
condition|)
name|warning
argument_list|(
literal|"right shift count>= width of type"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Convert the shift-count to an integer, regardless of 	     size of value being shifted.  */
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
operator|!=
name|integer_type_node
condition|)
name|op1
operator|=
name|convert
argument_list|(
name|integer_type_node
argument_list|,
name|op1
argument_list|)
expr_stmt|;
comment|/* Avoid converting op1 to result_type later.  */
name|converted
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|LSHIFT_EXPR
case|:
if|if
condition|(
name|code0
operator|==
name|INTEGER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
block|{
name|result_type
operator|=
name|type0
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|op1
argument_list|,
name|integer_zero_node
argument_list|)
condition|)
name|warning
argument_list|(
literal|"left shift count is negative"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_INT_CST_HIGH
argument_list|(
name|op1
argument_list|)
operator|!=
literal|0
operator|||
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|TREE_INT_CST_LOW
argument_list|(
name|op1
argument_list|)
operator|>=
name|TYPE_PRECISION
argument_list|(
name|type0
argument_list|)
operator|)
condition|)
name|warning
argument_list|(
literal|"left shift count>= width of type"
argument_list|)
expr_stmt|;
block|}
comment|/* Convert the shift-count to an integer, regardless of 	     size of value being shifted.  */
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
operator|!=
name|integer_type_node
condition|)
name|op1
operator|=
name|convert
argument_list|(
name|integer_type_node
argument_list|,
name|op1
argument_list|)
expr_stmt|;
comment|/* Avoid converting op1 to result_type later.  */
name|converted
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|RROTATE_EXPR
case|:
case|case
name|LROTATE_EXPR
case|:
if|if
condition|(
name|code0
operator|==
name|INTEGER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
block|{
name|result_type
operator|=
name|type0
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|op1
argument_list|,
name|integer_zero_node
argument_list|)
condition|)
name|warning
argument_list|(
literal|"%s rotate count is negative"
argument_list|,
operator|(
name|code
operator|==
name|LROTATE_EXPR
operator|)
condition|?
literal|"left"
else|:
literal|"right"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_INT_CST_HIGH
argument_list|(
name|op1
argument_list|)
operator|!=
literal|0
operator|||
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|TREE_INT_CST_LOW
argument_list|(
name|op1
argument_list|)
operator|>=
name|TYPE_PRECISION
argument_list|(
name|type0
argument_list|)
operator|)
condition|)
name|warning
argument_list|(
literal|"%s rotate count>= width of type"
argument_list|,
operator|(
name|code
operator|==
name|LROTATE_EXPR
operator|)
condition|?
literal|"left"
else|:
literal|"right"
argument_list|)
expr_stmt|;
block|}
comment|/* Convert the shift-count to an integer, regardless of 	     size of value being shifted.  */
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
operator|!=
name|integer_type_node
condition|)
name|op1
operator|=
name|convert
argument_list|(
name|integer_type_node
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
name|result_type
operator|=
name|bool_type_node
expr_stmt|;
name|converted
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|code0
operator|==
name|INTEGER_TYPE
operator|||
name|code0
operator|==
name|REAL_TYPE
operator|)
operator|&&
operator|(
name|code1
operator|==
name|INTEGER_TYPE
operator|||
name|code1
operator|==
name|REAL_TYPE
operator|)
condition|)
name|short_compare
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|POINTER_TYPE
condition|)
block|{
specifier|register
name|tree
name|tt0
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|type0
argument_list|)
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|tt1
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|type1
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Anything compares with void *.  void * compares with anything. 	     Otherwise, the targets must be the same.  */
if|if
condition|(
name|tt0
operator|!=
name|tt1
operator|&&
name|TREE_CODE
argument_list|(
name|tt0
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|tt1
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
block|{
name|tree
name|base
init|=
name|common_base_type
argument_list|(
name|tt0
argument_list|,
name|tt1
argument_list|)
decl_stmt|;
if|if
condition|(
name|base
operator|==
name|NULL_TREE
condition|)
name|cp_warning
argument_list|(
literal|"comparison of distinct object pointer types `%T' and `%T'"
argument_list|,
name|type0
argument_list|,
name|type1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|base
operator|==
name|error_mark_node
condition|)
block|{
name|cp_error
argument_list|(
literal|"comparison of pointer types `%T' and `%T' requires conversion to ambiguous supertype"
argument_list|,
name|type0
argument_list|,
name|type1
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
else|else
block|{
if|if
condition|(
name|integer_zerop
argument_list|(
name|op0
argument_list|)
condition|)
name|op0
operator|=
name|null_pointer_node
expr_stmt|;
else|else
name|op0
operator|=
name|convert_pointer_to
argument_list|(
name|base
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|integer_zerop
argument_list|(
name|op1
argument_list|)
condition|)
name|op1
operator|=
name|null_pointer_node
expr_stmt|;
else|else
name|op1
operator|=
name|convert_pointer_to
argument_list|(
name|base
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|comp_target_types
argument_list|(
name|type0
argument_list|,
name|type1
argument_list|,
literal|1
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|tt0
operator|==
name|void_type_node
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
name|TREE_CODE
argument_list|(
name|tt1
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|&&
name|tree_int_cst_lt
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type0
argument_list|)
argument_list|,
name|TYPE_SIZE
argument_list|(
name|type1
argument_list|)
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C++ forbids comparison of `void *' with function pointer"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tt1
operator|==
name|void_type_node
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
name|TREE_CODE
argument_list|(
name|tt0
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|&&
name|tree_int_cst_lt
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type1
argument_list|)
argument_list|,
name|TYPE_SIZE
argument_list|(
name|type0
argument_list|)
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C++ forbids comparison of `void *' with function pointer"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|TYPE_SIZE
argument_list|(
name|tt0
argument_list|)
operator|!=
literal|0
operator|)
operator|!=
operator|(
name|TYPE_SIZE
argument_list|(
name|tt1
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|cp_pedwarn
argument_list|(
literal|"comparison of %scomplete and %scomplete pointers `%T' and `%T'"
argument_list|,
name|TYPE_SIZE
argument_list|(
name|tt0
argument_list|)
operator|==
literal|0
condition|?
literal|"in"
else|:
literal|""
argument_list|,
name|TYPE_SIZE
argument_list|(
name|tt1
argument_list|)
operator|==
literal|0
condition|?
literal|"in"
else|:
literal|""
argument_list|,
name|type0
argument_list|,
name|type1
argument_list|)
expr_stmt|;
else|else
name|cp_pedwarn
argument_list|(
literal|"comparison of distinct pointer types `%T' and `%T' lacks a cast"
argument_list|,
name|type0
argument_list|,
name|type1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|integer_zerop
argument_list|(
name|op1
argument_list|)
condition|)
name|op1
operator|=
name|null_pointer_node
expr_stmt|;
elseif|else
if|if
condition|(
name|code1
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|integer_zerop
argument_list|(
name|op0
argument_list|)
condition|)
name|op0
operator|=
name|null_pointer_node
expr_stmt|;
elseif|else
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"ANSI C++ forbids comparison between pointer and integer"
argument_list|)
expr_stmt|;
name|op1
operator|=
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code0
operator|==
name|INTEGER_TYPE
operator|&&
name|code1
operator|==
name|POINTER_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"ANSI C++ forbids comparison between pointer and integer"
argument_list|)
expr_stmt|;
name|op0
operator|=
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|,
name|op0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type0
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|integer_zerop
argument_list|(
name|op1
argument_list|)
condition|)
block|{
name|op0
operator|=
name|build_component_ref
argument_list|(
name|op0
argument_list|,
name|index_identifier
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|integer_zero_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type1
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|integer_zerop
argument_list|(
name|op0
argument_list|)
condition|)
block|{
name|op0
operator|=
name|build_component_ref
argument_list|(
name|op1
argument_list|,
name|index_identifier
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|integer_zero_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type0
argument_list|)
operator|&&
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type1
argument_list|)
operator|&&
operator|(
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|type0
argument_list|)
operator|==
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|type1
argument_list|)
operator|)
condition|)
block|{
comment|/* The code we generate for the test is:  	  (op0.index == op1.index&& ((op1.index != -1&& op0.delta2 == op1.delta2) 	       || op0.pfn == op1.pfn)) */
name|tree
name|index0
init|=
name|build_component_ref
argument_list|(
name|op0
argument_list|,
name|index_identifier
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|index1
init|=
name|save_expr
argument_list|(
name|build_component_ref
argument_list|(
name|op1
argument_list|,
name|index_identifier
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|pfn0
init|=
name|PFN_FROM_PTRMEMFUNC
argument_list|(
name|op0
argument_list|)
decl_stmt|;
name|tree
name|pfn1
init|=
name|PFN_FROM_PTRMEMFUNC
argument_list|(
name|op1
argument_list|)
decl_stmt|;
name|tree
name|delta20
init|=
name|DELTA2_FROM_PTRMEMFUNC
argument_list|(
name|op0
argument_list|)
decl_stmt|;
name|tree
name|delta21
init|=
name|DELTA2_FROM_PTRMEMFUNC
argument_list|(
name|op1
argument_list|)
decl_stmt|;
name|tree
name|e1
decl_stmt|,
name|e2
decl_stmt|,
name|e3
decl_stmt|;
name|tree
name|integer_neg_one_node
init|=
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|integer_zero_node
argument_list|,
name|integer_one_node
argument_list|)
decl_stmt|;
name|e1
operator|=
name|build_binary_op
argument_list|(
name|EQ_EXPR
argument_list|,
name|index0
argument_list|,
name|index1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|e2
operator|=
name|build_binary_op
argument_list|(
name|NE_EXPR
argument_list|,
name|index1
argument_list|,
name|integer_neg_one_node
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|e2
operator|=
name|build_binary_op
argument_list|(
name|TRUTH_ANDIF_EXPR
argument_list|,
name|e2
argument_list|,
name|build_binary_op
argument_list|(
name|EQ_EXPR
argument_list|,
name|delta20
argument_list|,
name|delta21
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|e3
operator|=
name|build_binary_op
argument_list|(
name|EQ_EXPR
argument_list|,
name|pfn0
argument_list|,
name|pfn1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|e2
operator|=
name|build_binary_op
argument_list|(
name|TRUTH_ORIF_EXPR
argument_list|,
name|e2
argument_list|,
name|e3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|e2
operator|=
name|build_binary_op
argument_list|(
name|TRUTH_ANDIF_EXPR
argument_list|,
name|e1
argument_list|,
name|e2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|EQ_EXPR
condition|)
return|return
name|e2
return|;
return|return
name|build_binary_op
argument_list|(
name|EQ_EXPR
argument_list|,
name|e2
argument_list|,
name|integer_zero_node
argument_list|,
literal|1
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type0
argument_list|)
operator|&&
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|type0
argument_list|)
operator|==
name|type1
condition|)
block|{
name|tree
name|index0
init|=
name|build_component_ref
argument_list|(
name|op0
argument_list|,
name|index_identifier
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|index1
decl_stmt|;
name|tree
name|pfn0
init|=
name|PFN_FROM_PTRMEMFUNC
argument_list|(
name|op0
argument_list|)
decl_stmt|;
name|tree
name|delta20
init|=
name|DELTA2_FROM_PTRMEMFUNC
argument_list|(
name|op0
argument_list|)
decl_stmt|;
name|tree
name|delta21
init|=
name|integer_zero_node
decl_stmt|;
name|tree
name|e1
decl_stmt|,
name|e2
decl_stmt|,
name|e3
decl_stmt|;
name|tree
name|integer_neg_one_node
init|=
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|integer_zero_node
argument_list|,
name|integer_one_node
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_VINDEX
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Map everything down one to make room for the null pointer to member.  */
name|index1
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|DECL_VINDEX
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|integer_one_node
argument_list|)
expr_stmt|;
name|op1
operator|=
name|integer_zero_node
expr_stmt|;
name|delta21
operator|=
name|CLASSTYPE_VFIELD
argument_list|(
name|TYPE_METHOD_BASETYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|delta21
operator|=
name|DECL_FIELD_BITPOS
argument_list|(
name|delta21
argument_list|)
expr_stmt|;
name|delta21
operator|=
name|size_binop
argument_list|(
name|FLOOR_DIV_EXPR
argument_list|,
name|delta21
argument_list|,
name|size_int
argument_list|(
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|index1
operator|=
name|integer_neg_one_node
expr_stmt|;
block|{
name|tree
name|nop1
init|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|type0
argument_list|)
argument_list|,
name|op1
argument_list|)
decl_stmt|;
name|TREE_CONSTANT
argument_list|(
name|nop1
argument_list|)
operator|=
name|TREE_CONSTANT
argument_list|(
name|op1
argument_list|)
expr_stmt|;
name|op1
operator|=
name|nop1
expr_stmt|;
block|}
name|e1
operator|=
name|build_binary_op
argument_list|(
name|EQ_EXPR
argument_list|,
name|index0
argument_list|,
name|index1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|e2
operator|=
name|build_binary_op
argument_list|(
name|NE_EXPR
argument_list|,
name|index1
argument_list|,
name|integer_neg_one_node
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|e2
operator|=
name|build_binary_op
argument_list|(
name|TRUTH_ANDIF_EXPR
argument_list|,
name|e2
argument_list|,
name|build_binary_op
argument_list|(
name|EQ_EXPR
argument_list|,
name|delta20
argument_list|,
name|delta21
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|e3
operator|=
name|build_binary_op
argument_list|(
name|EQ_EXPR
argument_list|,
name|pfn0
argument_list|,
name|op1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|e2
operator|=
name|build_binary_op
argument_list|(
name|TRUTH_ORIF_EXPR
argument_list|,
name|e2
argument_list|,
name|e3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|e2
operator|=
name|build_binary_op
argument_list|(
name|TRUTH_ANDIF_EXPR
argument_list|,
name|e1
argument_list|,
name|e2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|EQ_EXPR
condition|)
return|return
name|e2
return|;
return|return
name|build_binary_op
argument_list|(
name|EQ_EXPR
argument_list|,
name|e2
argument_list|,
name|integer_zero_node
argument_list|,
literal|1
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type1
argument_list|)
operator|&&
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|type1
argument_list|)
operator|==
name|type0
condition|)
block|{
return|return
name|build_binary_op
argument_list|(
name|code
argument_list|,
name|op1
argument_list|,
name|op0
argument_list|,
literal|1
argument_list|)
return|;
block|}
else|else
comment|/* If args are not valid, clear out RESULT_TYPE 	   to cause an error message later.  */
name|result_type
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|MAX_EXPR
case|:
case|case
name|MIN_EXPR
case|:
if|if
condition|(
operator|(
name|code0
operator|==
name|INTEGER_TYPE
operator|||
name|code0
operator|==
name|REAL_TYPE
operator|)
operator|&&
operator|(
name|code1
operator|==
name|INTEGER_TYPE
operator|||
name|code1
operator|==
name|REAL_TYPE
operator|)
condition|)
name|shorten
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|POINTER_TYPE
condition|)
block|{
if|if
condition|(
operator|!
name|comp_target_types
argument_list|(
name|type0
argument_list|,
name|type1
argument_list|,
literal|1
argument_list|)
condition|)
name|cp_pedwarn
argument_list|(
literal|"comparison of distinct pointer types `%T' and `%T' lacks a cast"
argument_list|,
name|type0
argument_list|,
name|type1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type0
argument_list|)
argument_list|)
operator|!=
literal|0
operator|)
operator|!=
operator|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type1
argument_list|)
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|cp_pedwarn
argument_list|(
literal|"comparison of %scomplete and %scomplete pointers"
argument_list|,
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type0
argument_list|)
argument_list|)
operator|==
literal|0
condition|?
literal|"in"
else|:
literal|""
argument_list|,
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type1
argument_list|)
argument_list|)
operator|==
literal|0
condition|?
literal|"in"
else|:
literal|""
argument_list|,
name|type0
argument_list|,
name|type1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pedantic
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type0
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C++ forbids ordered comparisons of pointers to functions"
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|common_type
argument_list|(
name|type0
argument_list|,
name|type1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LE_EXPR
case|:
case|case
name|GE_EXPR
case|:
case|case
name|LT_EXPR
case|:
case|case
name|GT_EXPR
case|:
name|result_type
operator|=
name|bool_type_node
expr_stmt|;
if|if
condition|(
operator|(
name|code0
operator|==
name|INTEGER_TYPE
operator|||
name|code0
operator|==
name|REAL_TYPE
operator|)
operator|&&
operator|(
name|code1
operator|==
name|INTEGER_TYPE
operator|||
name|code1
operator|==
name|REAL_TYPE
operator|)
condition|)
name|short_compare
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|POINTER_TYPE
condition|)
block|{
if|if
condition|(
operator|!
name|comp_target_types
argument_list|(
name|type0
argument_list|,
name|type1
argument_list|,
literal|1
argument_list|)
condition|)
name|cp_pedwarn
argument_list|(
literal|"comparison of distinct pointer types `%T' and `%T' lacks a cast"
argument_list|,
name|type0
argument_list|,
name|type1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type0
argument_list|)
argument_list|)
operator|!=
literal|0
operator|)
operator|!=
operator|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type1
argument_list|)
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|cp_pedwarn
argument_list|(
literal|"comparison of %scomplete and %scomplete pointers"
argument_list|,
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type0
argument_list|)
argument_list|)
operator|==
literal|0
condition|?
literal|"in"
else|:
literal|""
argument_list|,
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type1
argument_list|)
argument_list|)
operator|==
literal|0
condition|?
literal|"in"
else|:
literal|""
argument_list|,
name|type0
argument_list|,
name|type1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pedantic
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type0
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C++ forbids ordered comparisons of pointers to functions"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|integer_zerop
argument_list|(
name|op1
argument_list|)
condition|)
block|{
name|op1
operator|=
name|null_pointer_node
expr_stmt|;
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ordered comparison of pointer with integer zero"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code1
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|integer_zerop
argument_list|(
name|op0
argument_list|)
condition|)
block|{
name|op0
operator|=
name|null_pointer_node
expr_stmt|;
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C++ forbids ordered comparison of pointer with integer zero"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C++ forbids comparison between pointer and integer"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|flag_traditional
condition|)
name|warning
argument_list|(
literal|"comparison between pointer and integer"
argument_list|)
expr_stmt|;
name|op1
operator|=
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code0
operator|==
name|INTEGER_TYPE
operator|&&
name|code1
operator|==
name|POINTER_TYPE
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C++ forbids comparison between pointer and integer"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|flag_traditional
condition|)
name|warning
argument_list|(
literal|"comparison between pointer and integer"
argument_list|)
expr_stmt|;
name|op0
operator|=
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|,
name|op0
argument_list|)
expr_stmt|;
block|}
else|else
name|result_type
operator|=
literal|0
expr_stmt|;
name|converted
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|code0
operator|==
name|INTEGER_TYPE
operator|||
name|code0
operator|==
name|REAL_TYPE
operator|)
operator|&&
operator|(
name|code1
operator|==
name|INTEGER_TYPE
operator|||
name|code1
operator|==
name|REAL_TYPE
operator|)
condition|)
block|{
if|if
condition|(
name|shorten
operator|||
name|common
operator|||
name|short_compare
condition|)
name|result_type
operator|=
name|common_type
argument_list|(
name|type0
argument_list|,
name|type1
argument_list|)
expr_stmt|;
comment|/* For certain operations (which identify themselves by shorten != 0) 	 if both args were extended from the same smaller type, 	 do the arithmetic in that type and then extend.  	 shorten !=0 and !=1 indicates a bitwise operation. 	 For them, this optimization is safe only if 	 both args are zero-extended or both are sign-extended. 	 Otherwise, we might change the result. 	 Eg, (short)-1 | (unsigned short)-1 is (int)-1 	 but calculated in (unsigned short) it would be (unsigned short)-1.  */
if|if
condition|(
name|shorten
condition|)
block|{
name|int
name|unsigned0
decl_stmt|,
name|unsigned1
decl_stmt|;
name|tree
name|arg0
init|=
name|get_narrower
argument_list|(
name|op0
argument_list|,
operator|&
name|unsigned0
argument_list|)
decl_stmt|;
name|tree
name|arg1
init|=
name|get_narrower
argument_list|(
name|op1
argument_list|,
operator|&
name|unsigned1
argument_list|)
decl_stmt|;
comment|/* UNS is 1 if the operation to be done is an unsigned one.  */
name|int
name|uns
init|=
name|TREE_UNSIGNED
argument_list|(
name|result_type
argument_list|)
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|final_type
operator|=
name|result_type
expr_stmt|;
comment|/* Handle the case that OP0 does not *contain* a conversion 	     but it *requires* conversion to FINAL_TYPE.  */
if|if
condition|(
name|op0
operator|==
name|arg0
operator|&&
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
operator|!=
name|final_type
condition|)
name|unsigned0
operator|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|==
name|arg1
operator|&&
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
operator|!=
name|final_type
condition|)
name|unsigned1
operator|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now UNSIGNED0 is 1 if ARG0 zero-extends to FINAL_TYPE.  */
comment|/* For bitwise operations, signedness of nominal type 	     does not matter.  Consider only how operands were extended.  */
if|if
condition|(
name|shorten
operator|==
operator|-
literal|1
condition|)
name|uns
operator|=
name|unsigned0
expr_stmt|;
comment|/* Note that in all three cases below we refrain from optimizing 	     an unsigned operation on sign-extended args. 	     That would not be valid.  */
comment|/* Both args variable: if both extended in same way 	     from same width, do it in that width. 	     Do it unsigned if args were zero-extended.  */
if|if
condition|(
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|result_type
argument_list|)
operator|)
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|)
operator|&&
name|unsigned0
operator|==
name|unsigned1
operator|&&
operator|(
name|unsigned0
operator|||
operator|!
name|uns
operator|)
condition|)
name|result_type
operator|=
name|signed_or_unsigned_type
argument_list|(
name|unsigned0
argument_list|,
name|common_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|(
name|unsigned1
operator|||
operator|!
name|uns
operator|)
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|result_type
argument_list|)
operator|)
operator|&&
operator|(
name|type
operator|=
name|signed_or_unsigned_type
argument_list|(
name|unsigned1
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|,
name|int_fits_type_p
argument_list|(
name|arg0
argument_list|,
name|type
argument_list|)
operator|)
condition|)
name|result_type
operator|=
name|type
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|(
name|unsigned0
operator|||
operator|!
name|uns
operator|)
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|result_type
argument_list|)
operator|)
operator|&&
operator|(
name|type
operator|=
name|signed_or_unsigned_type
argument_list|(
name|unsigned0
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|,
name|int_fits_type_p
argument_list|(
name|arg1
argument_list|,
name|type
argument_list|)
operator|)
condition|)
name|result_type
operator|=
name|type
expr_stmt|;
block|}
comment|/* Shifts can be shortened if shifting right.  */
if|if
condition|(
name|short_shift
condition|)
block|{
name|int
name|unsigned_arg
decl_stmt|;
name|tree
name|arg0
init|=
name|get_narrower
argument_list|(
name|op0
argument_list|,
operator|&
name|unsigned_arg
argument_list|)
decl_stmt|;
name|final_type
operator|=
name|result_type
expr_stmt|;
if|if
condition|(
name|arg0
operator|==
name|op0
operator|&&
name|final_type
operator|==
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
condition|)
name|unsigned_arg
operator|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|result_type
argument_list|)
comment|/* If arg is sign-extended and then unsigned-shifted, 		 we can simulate this with a signed shift in arg's type 		 only if the extended result is at least twice as wide 		 as the arg.  Otherwise, the shift could use up all the 		 ones made by sign-extension and bring in zeros. 		 We can't optimize that case at all, but in most machines 		 it never happens because available widths are 2**N.  */
operator|&&
operator|(
operator|!
name|TREE_UNSIGNED
argument_list|(
name|final_type
argument_list|)
operator|||
name|unsigned_arg
operator|||
operator|(
operator|(
name|unsigned
operator|)
literal|2
operator|*
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|<=
name|TYPE_PRECISION
argument_list|(
name|result_type
argument_list|)
operator|)
operator|)
condition|)
block|{
comment|/* Do an unsigned shift if the operand was zero-extended.  */
name|result_type
operator|=
name|signed_or_unsigned_type
argument_list|(
name|unsigned_arg
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Convert value-to-be-shifted to that type.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
operator|!=
name|result_type
condition|)
name|op0
operator|=
name|convert
argument_list|(
name|result_type
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|converted
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Comparison operations are shortened too but differently. 	 They identify themselves by setting short_compare = 1.  */
if|if
condition|(
name|short_compare
condition|)
block|{
comment|/* Don't write&op0, etc., because that would prevent op0 	     from being kept in a register. 	     Instead, make copies of the our local variables and 	     pass the copies by reference, then copy them back afterward.  */
name|tree
name|xop0
init|=
name|op0
decl_stmt|,
name|xop1
init|=
name|op1
decl_stmt|,
name|xresult_type
init|=
name|result_type
decl_stmt|;
name|enum
name|tree_code
name|xresultcode
init|=
name|resultcode
decl_stmt|;
name|tree
name|val
init|=
name|shorten_compare
argument_list|(
operator|&
name|xop0
argument_list|,
operator|&
name|xop1
argument_list|,
operator|&
name|xresult_type
argument_list|,
operator|&
name|xresultcode
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
return|return
name|convert
argument_list|(
name|bool_type_node
argument_list|,
name|val
argument_list|)
return|;
name|op0
operator|=
name|xop0
operator|,
name|op1
operator|=
name|xop1
operator|,
name|result_type
operator|=
name|bool_type_node
expr_stmt|;
name|resultcode
operator|=
name|xresultcode
expr_stmt|;
block|}
if|if
condition|(
name|short_compare
operator|&&
name|extra_warnings
condition|)
block|{
name|int
name|unsignedp0
decl_stmt|,
name|unsignedp1
decl_stmt|;
name|tree
name|primop0
init|=
name|get_narrower
argument_list|(
name|op0
argument_list|,
operator|&
name|unsignedp0
argument_list|)
decl_stmt|;
name|tree
name|primop1
init|=
name|get_narrower
argument_list|(
name|op1
argument_list|,
operator|&
name|unsignedp1
argument_list|)
decl_stmt|;
comment|/* Warn if signed and unsigned are being compared in a size larger 	     than their original size, as this will always fail.  */
if|if
condition|(
name|unsignedp0
operator|!=
name|unsignedp1
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop0
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|result_type
argument_list|)
operator|)
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop1
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|result_type
argument_list|)
operator|)
condition|)
name|warning
argument_list|(
literal|"comparison between promoted unsigned and signed"
argument_list|)
expr_stmt|;
comment|/* Warn if two unsigned values are being compared in a size 	     larger than their original size, and one (and only one) is the 	     result of a `~' operator.  This comparison will always fail.  	     Also warn if one operand is a constant, and the constant does not 	     have all bits set that are set in the ~ operand when it is 	     extended.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|primop0
argument_list|)
operator|==
name|BIT_NOT_EXPR
operator|^
name|TREE_CODE
argument_list|(
name|primop1
argument_list|)
operator|==
name|BIT_NOT_EXPR
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|primop0
argument_list|)
operator|==
name|BIT_NOT_EXPR
condition|)
name|primop0
operator|=
name|get_narrower
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|unsignedp0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|primop1
argument_list|)
operator|==
name|BIT_NOT_EXPR
condition|)
name|primop1
operator|=
name|get_narrower
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|unsignedp1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|primop0
argument_list|)
operator|==
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|primop1
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|tree
name|primop
decl_stmt|;
name|HOST_WIDE_INT
name|constant
decl_stmt|,
name|mask
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|unsigned
name|bits
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|primop0
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|primop
operator|=
name|primop1
expr_stmt|;
name|unsignedp
operator|=
name|unsignedp1
expr_stmt|;
name|constant
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|primop0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|primop
operator|=
name|primop0
expr_stmt|;
name|unsignedp
operator|=
name|unsignedp0
expr_stmt|;
name|constant
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|primop1
argument_list|)
expr_stmt|;
block|}
name|bits
operator|=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bits
operator|<
name|TYPE_PRECISION
argument_list|(
name|result_type
argument_list|)
operator|&&
name|bits
operator|<
name|HOST_BITS_PER_LONG
operator|&&
name|unsignedp
condition|)
block|{
name|mask
operator|=
operator|(
operator|~
operator|(
name|HOST_WIDE_INT
operator|)
literal|0
operator|)
operator|<<
name|bits
expr_stmt|;
if|if
condition|(
operator|(
name|mask
operator|&
name|constant
operator|)
operator|!=
name|mask
condition|)
name|warning
argument_list|(
literal|"comparison of promoted ~unsigned with constant"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|unsignedp0
operator|&&
name|unsignedp1
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop0
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|result_type
argument_list|)
operator|)
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop1
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|result_type
argument_list|)
operator|)
condition|)
name|warning
argument_list|(
literal|"comparison of promoted ~unsigned with unsigned"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* At this point, RESULT_TYPE must be nonzero to avoid an error message.      If CONVERTED is zero, both args will be converted to type RESULT_TYPE.      Then the expression will be built.      It will be given type FINAL_TYPE if that is nonzero;      otherwise, it will be given type RESULT_TYPE.  */
if|if
condition|(
operator|!
name|result_type
condition|)
block|{
name|binary_op_error
argument_list|(
name|error_code
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
operator|!
name|converted
condition|)
block|{
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
operator|!=
name|result_type
condition|)
name|op0
operator|=
name|convert
argument_list|(
name|result_type
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
operator|!=
name|result_type
condition|)
name|op1
operator|=
name|convert
argument_list|(
name|result_type
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
block|{
specifier|register
name|tree
name|result
init|=
name|build
argument_list|(
name|resultcode
argument_list|,
name|result_type
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|folded
decl_stmt|;
name|folded
operator|=
name|fold
argument_list|(
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|folded
operator|==
name|result
condition|)
name|TREE_CONSTANT
argument_list|(
name|folded
argument_list|)
operator|=
name|TREE_CONSTANT
argument_list|(
name|op0
argument_list|)
operator|&
name|TREE_CONSTANT
argument_list|(
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|final_type
operator|!=
literal|0
condition|)
return|return
name|convert
argument_list|(
name|final_type
argument_list|,
name|folded
argument_list|)
return|;
return|return
name|folded
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a tree for the sum or difference (RESULTCODE says which)    of pointer PTROP and integer INTOP.  */
end_comment

begin_function
specifier|static
name|tree
name|pointer_int_sum
parameter_list|(
name|resultcode
parameter_list|,
name|ptrop
parameter_list|,
name|intop
parameter_list|)
name|enum
name|tree_code
name|resultcode
decl_stmt|;
specifier|register
name|tree
name|ptrop
decl_stmt|,
name|intop
decl_stmt|;
block|{
name|tree
name|size_exp
decl_stmt|;
specifier|register
name|tree
name|result
decl_stmt|;
specifier|register
name|tree
name|folded
init|=
name|fold
argument_list|(
name|intop
argument_list|)
decl_stmt|;
comment|/* The result is a pointer of the same type that is being added.  */
specifier|register
name|tree
name|result_type
init|=
name|TREE_TYPE
argument_list|(
name|ptrop
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|result_type
argument_list|)
argument_list|)
operator|==
name|VOID_TYPE
condition|)
block|{
if|if
condition|(
name|pedantic
operator|||
name|warn_pointer_arith
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C++ forbids using pointer of type `void *' in arithmetic"
argument_list|)
expr_stmt|;
name|size_exp
operator|=
name|integer_one_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|result_type
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
if|if
condition|(
name|pedantic
operator|||
name|warn_pointer_arith
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C++ forbids using pointer to a function in arithmetic"
argument_list|)
expr_stmt|;
name|size_exp
operator|=
name|integer_one_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|result_type
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
if|if
condition|(
name|pedantic
operator|||
name|warn_pointer_arith
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C++ forbids using pointer to a method in arithmetic"
argument_list|)
expr_stmt|;
name|size_exp
operator|=
name|integer_one_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|result_type
argument_list|)
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C++ forbids using pointer to a member in arithmetic"
argument_list|)
expr_stmt|;
name|size_exp
operator|=
name|integer_one_node
expr_stmt|;
block|}
else|else
name|size_exp
operator|=
name|size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|result_type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Needed to make OOPS V2R3 work.  */
name|intop
operator|=
name|folded
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|intop
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_INT_CST_LOW
argument_list|(
name|intop
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|intop
argument_list|)
operator|==
literal|0
condition|)
return|return
name|ptrop
return|;
comment|/* If what we are about to multiply by the size of the elements      contains a constant term, apply distributive law      and multiply that constant term separately.      This helps produce common subexpressions.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|intop
argument_list|)
operator|==
name|PLUS_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|intop
argument_list|)
operator|==
name|MINUS_EXPR
operator|)
operator|&&
operator|!
name|TREE_CONSTANT
argument_list|(
name|intop
argument_list|)
operator|&&
name|TREE_CONSTANT
argument_list|(
name|TREE_OPERAND
argument_list|(
name|intop
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|TREE_CONSTANT
argument_list|(
name|size_exp
argument_list|)
condition|)
block|{
name|enum
name|tree_code
name|subcode
init|=
name|resultcode
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|intop
argument_list|)
operator|==
name|MINUS_EXPR
condition|)
name|subcode
operator|=
operator|(
name|subcode
operator|==
name|PLUS_EXPR
condition|?
name|MINUS_EXPR
else|:
name|PLUS_EXPR
operator|)
expr_stmt|;
name|ptrop
operator|=
name|build_binary_op
argument_list|(
name|subcode
argument_list|,
name|ptrop
argument_list|,
name|TREE_OPERAND
argument_list|(
name|intop
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|intop
operator|=
name|TREE_OPERAND
argument_list|(
name|intop
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Convert the integer argument to a type the same size as a pointer      so the multiply won't overflow spuriously.  */
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|intop
argument_list|)
argument_list|)
operator|!=
name|POINTER_SIZE
condition|)
name|intop
operator|=
name|convert
argument_list|(
name|type_for_size
argument_list|(
name|POINTER_SIZE
argument_list|,
literal|0
argument_list|)
argument_list|,
name|intop
argument_list|)
expr_stmt|;
comment|/* Replace the integer argument with a suitable product by the object size.      Do this multiplication as signed, then convert to the appropriate      pointer type (actually unsigned integral).  */
name|intop
operator|=
name|convert
argument_list|(
name|result_type
argument_list|,
name|build_binary_op
argument_list|(
name|MULT_EXPR
argument_list|,
name|intop
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|intop
argument_list|)
argument_list|,
name|size_exp
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create the sum or difference.  */
name|result
operator|=
name|build
argument_list|(
name|resultcode
argument_list|,
name|result_type
argument_list|,
name|ptrop
argument_list|,
name|intop
argument_list|)
expr_stmt|;
name|folded
operator|=
name|fold
argument_list|(
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|folded
operator|==
name|result
condition|)
name|TREE_CONSTANT
argument_list|(
name|folded
argument_list|)
operator|=
name|TREE_CONSTANT
argument_list|(
name|ptrop
argument_list|)
operator|&
name|TREE_CONSTANT
argument_list|(
name|intop
argument_list|)
expr_stmt|;
return|return
name|folded
return|;
block|}
end_function

begin_comment
comment|/* Return a tree for the difference of pointers OP0 and OP1.    The resulting tree has type int.  */
end_comment

begin_function
specifier|static
name|tree
name|pointer_diff
parameter_list|(
name|op0
parameter_list|,
name|op1
parameter_list|)
specifier|register
name|tree
name|op0
decl_stmt|,
name|op1
decl_stmt|;
block|{
specifier|register
name|tree
name|result
decl_stmt|,
name|folded
decl_stmt|;
name|tree
name|restype
init|=
name|ptrdiff_type_node
decl_stmt|;
name|tree
name|target_type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|pedantic
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|target_type
argument_list|)
operator|==
name|VOID_TYPE
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C++ forbids using pointer of type `void *' in subtraction"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|target_type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C++ forbids using pointer to a function in subtraction"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|target_type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C++ forbids using pointer to a method in subtraction"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|target_type
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C++ forbids using pointer to a member in subtraction"
argument_list|)
expr_stmt|;
block|}
comment|/* First do the subtraction as integers;      then drop through to build the divide operator.  */
name|op0
operator|=
name|build_binary_op
argument_list|(
name|MINUS_EXPR
argument_list|,
name|convert
argument_list|(
name|restype
argument_list|,
name|op0
argument_list|)
argument_list|,
name|convert
argument_list|(
name|restype
argument_list|,
name|op1
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* This generates an error if op1 is a pointer to an incomplete type.  */
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"arithmetic on pointer to an incomplete type"
argument_list|)
expr_stmt|;
name|op1
operator|=
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|target_type
argument_list|)
operator|==
name|VOID_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|target_type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|target_type
argument_list|)
operator|==
name|METHOD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|target_type
argument_list|)
operator|==
name|OFFSET_TYPE
operator|)
condition|?
name|integer_one_node
else|:
name|size_in_bytes
argument_list|(
name|target_type
argument_list|)
operator|)
expr_stmt|;
comment|/* Do the division.  */
name|result
operator|=
name|build
argument_list|(
name|EXACT_DIV_EXPR
argument_list|,
name|restype
argument_list|,
name|op0
argument_list|,
name|convert
argument_list|(
name|restype
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
name|folded
operator|=
name|fold
argument_list|(
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|folded
operator|==
name|result
condition|)
name|TREE_CONSTANT
argument_list|(
name|folded
argument_list|)
operator|=
name|TREE_CONSTANT
argument_list|(
name|op0
argument_list|)
operator|&
name|TREE_CONSTANT
argument_list|(
name|op1
argument_list|)
expr_stmt|;
return|return
name|folded
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Handle the case of taking the address of a COMPONENT_REF.    Called by `build_unary_op' and `build_up_reference'.     ARG is the COMPONENT_REF whose address we want.    ARGTYPE is the pointer type that this address should have.    MSG is an error message to print if this COMPONENT_REF is not    addressable (such as a bitfield).  */
end_comment

begin_function
name|tree
name|build_component_addr
parameter_list|(
name|arg
parameter_list|,
name|argtype
parameter_list|,
name|msg
parameter_list|)
name|tree
name|arg
decl_stmt|,
name|argtype
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
block|{
name|tree
name|field
init|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|basetype
init|=
name|decl_type_context
argument_list|(
name|field
argument_list|)
decl_stmt|;
name|tree
name|rval
init|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|DECL_BIT_FIELD
argument_list|(
name|field
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|msg
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|flag_gc
condition|)
name|cp_warning
argument_list|(
literal|"address of `%T::%D' taken"
argument_list|,
name|basetype
argument_list|,
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
name|TYPE_USES_COMPLEX_INHERITANCE
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
comment|/* Can't convert directly to ARGTYPE, since that 	 may have the same pointer type as one of our 	 baseclasses.  */
name|rval
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|argtype
argument_list|,
name|convert_pointer_to
argument_list|(
name|basetype
argument_list|,
name|rval
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|rval
argument_list|)
operator|=
name|TREE_CONSTANT
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rval
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* This conversion is harmless.  */
name|rval
operator|=
name|convert_force
argument_list|(
name|argtype
argument_list|,
name|rval
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|DECL_FIELD_BITPOS
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|offset
init|=
name|size_binop
argument_list|(
name|EASY_DIV_EXPR
argument_list|,
name|DECL_FIELD_BITPOS
argument_list|(
name|field
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|BITS_PER_UNIT
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|flag
init|=
name|TREE_CONSTANT
argument_list|(
name|rval
argument_list|)
decl_stmt|;
name|rval
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|argtype
argument_list|,
name|rval
argument_list|,
name|convert
argument_list|(
name|argtype
argument_list|,
name|offset
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|rval
argument_list|)
operator|=
name|flag
expr_stmt|;
block|}
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* Construct and perhaps optimize a tree representation    for a unary operation.  CODE, a tree_code, specifies the operation    and XARG is the operand.  */
end_comment

begin_function
name|tree
name|build_x_unary_op
parameter_list|(
name|code
parameter_list|,
name|xarg
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|xarg
decl_stmt|;
block|{
comment|/*& rec, on incomplete RECORD_TYPEs is the simple opr&, not an      error message. */
if|if
condition|(
name|code
operator|!=
name|ADDR_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|xarg
argument_list|)
argument_list|)
operator|!=
name|RECORD_TYPE
operator|||
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|xarg
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|rval
init|=
name|build_opfncall
argument_list|(
name|code
argument_list|,
name|LOOKUP_SPECULATIVELY
argument_list|,
name|xarg
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
if|if
condition|(
name|rval
condition|)
return|return
name|build_opfncall
argument_list|(
name|code
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|xarg
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
return|return
name|build_unary_op
argument_list|(
name|code
argument_list|,
name|xarg
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Just like truthvalue_conversion, but we want a BOOLEAN_TYPE */
end_comment

begin_function
name|tree
name|bool_truthvalue_conversion
parameter_list|(
name|expr
parameter_list|)
name|tree
name|expr
decl_stmt|;
block|{
comment|/* We really want to preform the optimizations in truthvalue_conversion      but, not this way. */
comment|/* expr = truthvalue_conversion (expr); */
return|return
name|convert
argument_list|(
name|bool_type_node
argument_list|,
name|expr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* C++: Must handle pointers to members.     Perhaps type instantiation should be extended to handle conversion    from aggregates to types we don't yet know we want?  (Or are those    cases typically errors which should be reported?)     NOCONVERT nonzero suppresses the default promotions    (such as from short to int).  */
end_comment

begin_function
name|tree
name|build_unary_op
parameter_list|(
name|code
parameter_list|,
name|xarg
parameter_list|,
name|noconvert
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|xarg
decl_stmt|;
name|int
name|noconvert
decl_stmt|;
block|{
comment|/* No default_conversion here.  It causes trouble for ADDR_EXPR.  */
specifier|register
name|tree
name|arg
init|=
name|xarg
decl_stmt|;
specifier|register
name|tree
name|argtype
init|=
literal|0
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|typecode
init|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|errstring
init|=
name|NULL
decl_stmt|;
name|tree
name|val
decl_stmt|;
name|int
name|isaggrtype
decl_stmt|;
if|if
condition|(
name|typecode
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|typecode
operator|==
name|REFERENCE_TYPE
operator|&&
name|code
operator|!=
name|ADDR_EXPR
operator|&&
operator|!
name|noconvert
condition|)
block|{
name|arg
operator|=
name|convert_from_reference
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|typecode
operator|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|typecode
operator|==
name|ENUMERAL_TYPE
condition|)
name|typecode
operator|=
name|INTEGER_TYPE
expr_stmt|;
name|isaggrtype
operator|=
name|IS_AGGR_TYPE_CODE
argument_list|(
name|typecode
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONVERT_EXPR
case|:
comment|/* This is used for unary plus, because a CONVERT_EXPR 	 is enough to prevent anybody from looking inside for 	 associativity, but won't generate any code.  */
if|if
condition|(
operator|!
operator|(
name|typecode
operator|==
name|INTEGER_TYPE
operator|||
name|typecode
operator|==
name|REAL_TYPE
operator|)
condition|)
name|errstring
operator|=
literal|"wrong type argument to unary plus"
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|noconvert
condition|)
name|arg
operator|=
name|default_conversion
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|NEGATE_EXPR
case|:
if|if
condition|(
name|isaggrtype
condition|)
block|{
if|if
condition|(
operator|!
name|noconvert
condition|)
name|arg
operator|=
name|default_conversion
argument_list|(
name|arg
argument_list|)
expr_stmt|;
else|else
block|{
name|cp_error
argument_list|(
literal|"type conversion for type `%T' not allowed"
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|typecode
operator|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|noconvert
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|typecode
operator|==
name|INTEGER_TYPE
operator|||
name|typecode
operator|==
name|REAL_TYPE
operator|)
condition|)
name|errstring
operator|=
literal|"wrong type argument to unary minus"
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|noconvert
condition|)
name|arg
operator|=
name|default_conversion
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIT_NOT_EXPR
case|:
if|if
condition|(
name|isaggrtype
condition|)
block|{
if|if
condition|(
operator|!
name|noconvert
condition|)
name|arg
operator|=
name|default_conversion
argument_list|(
name|arg
argument_list|)
expr_stmt|;
else|else
block|{
name|cp_error
argument_list|(
literal|"type conversion for type `%T' not allowed"
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|typecode
operator|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|noconvert
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|typecode
operator|!=
name|INTEGER_TYPE
condition|)
name|errstring
operator|=
literal|"wrong type argument to bit-complement"
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|noconvert
condition|)
name|arg
operator|=
name|default_conversion
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|ABS_EXPR
case|:
if|if
condition|(
name|isaggrtype
condition|)
block|{
if|if
condition|(
operator|!
name|noconvert
condition|)
name|arg
operator|=
name|default_conversion
argument_list|(
name|arg
argument_list|)
expr_stmt|;
else|else
block|{
name|cp_error
argument_list|(
literal|"type conversion for type `%T' not allowed"
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|typecode
operator|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|noconvert
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|typecode
operator|==
name|INTEGER_TYPE
operator|||
name|typecode
operator|==
name|REAL_TYPE
operator|)
condition|)
name|errstring
operator|=
literal|"wrong type argument to abs"
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|noconvert
condition|)
name|arg
operator|=
name|default_conversion
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRUTH_NOT_EXPR
case|:
name|arg
operator|=
name|bool_truthvalue_conversion
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|val
operator|=
name|invert_truthvalue
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|!=
name|error_mark_node
condition|)
return|return
name|val
return|;
name|errstring
operator|=
literal|"in argument to unary !"
expr_stmt|;
break|break;
case|case
name|NOP_EXPR
case|:
break|break;
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|POSTINCREMENT_EXPR
case|:
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|POSTDECREMENT_EXPR
case|:
comment|/* Handle complex lvalues (when permitted) 	 by reduction to simpler cases.  */
name|val
operator|=
name|unary_complex_lvalue
argument_list|(
name|code
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
return|return
name|val
return|;
comment|/* Report invalid types.  */
if|if
condition|(
name|isaggrtype
condition|)
block|{
name|arg
operator|=
name|default_conversion
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|typecode
operator|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|typecode
operator|!=
name|POINTER_TYPE
operator|&&
name|typecode
operator|!=
name|INTEGER_TYPE
operator|&&
name|typecode
operator|!=
name|REAL_TYPE
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|PREINCREMENT_EXPR
condition|)
name|errstring
operator|=
literal|"no pre-increment operator for type"
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|POSTINCREMENT_EXPR
condition|)
name|errstring
operator|=
literal|"no post-increment operator for type"
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|PREDECREMENT_EXPR
condition|)
name|errstring
operator|=
literal|"no pre-decrement operator for type"
expr_stmt|;
else|else
name|errstring
operator|=
literal|"no post-decrement operator for type"
expr_stmt|;
break|break;
block|}
comment|/* Report something read-only.  */
if|if
condition|(
name|TYPE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|||
name|TREE_READONLY
argument_list|(
name|arg
argument_list|)
condition|)
name|readonly_error
argument_list|(
name|arg
argument_list|,
operator|(
operator|(
name|code
operator|==
name|PREINCREMENT_EXPR
operator|||
name|code
operator|==
name|POSTINCREMENT_EXPR
operator|)
condition|?
literal|"increment"
else|:
literal|"decrement"
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|{
specifier|register
name|tree
name|inc
decl_stmt|;
name|tree
name|result_type
init|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|arg
operator|=
name|get_unwidened
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|argtype
operator|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/* ARM $5.2.5 last annotation says this should be forbidden.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|argtype
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C++ forbids %sing an enum"
argument_list|,
operator|(
name|code
operator|==
name|PREINCREMENT_EXPR
operator|||
name|code
operator|==
name|POSTINCREMENT_EXPR
operator|)
condition|?
literal|"increment"
else|:
literal|"decrement"
argument_list|)
expr_stmt|;
comment|/* Compute the increment.  */
if|if
condition|(
name|typecode
operator|==
name|POINTER_TYPE
condition|)
block|{
name|enum
name|tree_code
name|tmp
init|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|argtype
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|argtype
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|cp_error
argument_list|(
literal|"cannot %s a pointer to incomplete type `%T'"
argument_list|,
operator|(
operator|(
name|code
operator|==
name|PREINCREMENT_EXPR
operator|||
name|code
operator|==
name|POSTINCREMENT_EXPR
operator|)
condition|?
literal|"increment"
else|:
literal|"decrement"
operator|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|argtype
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tmp
operator|==
name|FUNCTION_TYPE
operator|||
name|tmp
operator|==
name|METHOD_TYPE
operator|||
name|tmp
operator|==
name|VOID_TYPE
operator|||
name|tmp
operator|==
name|OFFSET_TYPE
condition|)
name|cp_pedwarn
argument_list|(
literal|"ANSI C++ forbids %sing a pointer of type `%T'"
argument_list|,
operator|(
operator|(
name|code
operator|==
name|PREINCREMENT_EXPR
operator|||
name|code
operator|==
name|POSTINCREMENT_EXPR
operator|)
condition|?
literal|"increment"
else|:
literal|"decrement"
operator|)
argument_list|,
name|argtype
argument_list|)
expr_stmt|;
name|inc
operator|=
name|c_sizeof_nowarn
argument_list|(
name|TREE_TYPE
argument_list|(
name|argtype
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|inc
operator|=
name|integer_one_node
expr_stmt|;
name|inc
operator|=
name|convert
argument_list|(
name|argtype
argument_list|,
name|inc
argument_list|)
expr_stmt|;
comment|/* Handle incrementing a cast-expression.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
condition|)
block|{
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|FLOAT_EXPR
case|:
case|case
name|FIX_TRUNC_EXPR
case|:
case|case
name|FIX_FLOOR_EXPR
case|:
case|case
name|FIX_ROUND_EXPR
case|:
case|case
name|FIX_CEIL_EXPR
case|:
block|{
name|tree
name|incremented
decl_stmt|,
name|modify
decl_stmt|,
name|value
decl_stmt|;
if|if
condition|(
operator|!
name|lvalue_p
argument_list|(
name|arg
argument_list|)
operator|&&
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"cast to non-reference type used as lvalue"
argument_list|)
expr_stmt|;
name|arg
operator|=
name|stabilize_reference
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|PREINCREMENT_EXPR
operator|||
name|code
operator|==
name|PREDECREMENT_EXPR
condition|)
name|value
operator|=
name|arg
expr_stmt|;
else|else
name|value
operator|=
name|save_expr
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|incremented
operator|=
name|build
argument_list|(
operator|(
operator|(
name|code
operator|==
name|PREINCREMENT_EXPR
operator|||
name|code
operator|==
name|POSTINCREMENT_EXPR
operator|)
condition|?
name|PLUS_EXPR
else|:
name|MINUS_EXPR
operator|)
argument_list|,
name|argtype
argument_list|,
name|value
argument_list|,
name|inc
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|incremented
argument_list|)
operator|=
literal|1
expr_stmt|;
name|modify
operator|=
name|build_modify_expr
argument_list|(
name|arg
argument_list|,
name|NOP_EXPR
argument_list|,
name|incremented
argument_list|)
expr_stmt|;
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|modify
argument_list|,
name|value
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|OFFSET_REF
condition|)
name|arg
operator|=
name|resolve_offset_ref
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/* Complain about anything else that is not a true lvalue.  */
if|if
condition|(
operator|!
name|lvalue_or_else
argument_list|(
name|arg
argument_list|,
operator|(
operator|(
name|code
operator|==
name|PREINCREMENT_EXPR
operator|||
name|code
operator|==
name|POSTINCREMENT_EXPR
operator|)
condition|?
literal|"increment"
else|:
literal|"decrement"
operator|)
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
name|val
operator|=
name|build
argument_list|(
name|code
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|arg
argument_list|,
name|inc
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|val
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|convert
argument_list|(
name|result_type
argument_list|,
name|val
argument_list|)
return|;
block|}
case|case
name|ADDR_EXPR
case|:
comment|/* Note that this operation never does default_conversion 	 regardless of NOCONVERT.  */
if|if
condition|(
name|typecode
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|arg
operator|=
name|build1
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|TREE_REFERENCE_EXPR
argument_list|(
name|arg
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|arg
return|;
block|}
elseif|else
if|if
condition|(
name|pedantic
operator|&&
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_NAME
argument_list|(
name|arg
argument_list|)
operator|&&
name|DECL_CONTEXT
argument_list|(
name|arg
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|IDENTIFIER_LENGTH
argument_list|(
name|DECL_NAME
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
literal|4
operator|&&
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|arg
argument_list|)
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'m'
operator|&&
operator|!
name|strcmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|,
literal|"main"
argument_list|)
condition|)
comment|/* ARM $3.4 */
name|pedwarn
argument_list|(
literal|"taking address of function `main'"
argument_list|)
expr_stmt|;
comment|/* Let&* cancel out to simplify resulting code.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
block|{
comment|/* We don't need to have `current_class_decl' wrapped in a 	     NON_LVALUE_EXPR node.  */
if|if
condition|(
name|arg
operator|==
name|C_C_D
condition|)
return|return
name|current_class_decl
return|;
comment|/* Keep `default_conversion' from converting if 	     ARG is of REFERENCE_TYPE.  */
name|arg
operator|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|arg
argument_list|)
operator|&&
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|DECL_INITIAL
argument_list|(
name|arg
argument_list|)
argument_list|)
condition|)
name|arg
operator|=
name|DECL_INITIAL
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|arg
operator|=
name|build1
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|TREE_REFERENCE_EXPR
argument_list|(
name|arg
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|arg
argument_list|)
operator|=
name|TREE_CONSTANT
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lvalue_p
argument_list|(
name|arg
argument_list|)
condition|)
comment|/* Don't let this be an lvalue.  */
return|return
name|non_lvalue
argument_list|(
name|arg
argument_list|)
return|;
return|return
name|arg
return|;
block|}
comment|/* For&x[y], return x+y */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|ARRAY_REF
condition|)
block|{
if|if
condition|(
name|mark_addressable
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
name|error_mark_node
return|;
return|return
name|build_binary_op
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
return|;
block|}
comment|/* For&(++foo), we are really taking the address of the variable 	 being acted upon by the increment/decrement operator.  ARM $5.3.1 	 However, according to ARM $5.2.5, we don't allow postfix ++ and 	 --, since the prefix operators return lvalues, but the postfix 	 operators do not.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|PREINCREMENT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|PREDECREMENT_EXPR
condition|)
name|arg
operator|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Uninstantiated types are all functions.  Taking the 	 address of a function is a no-op, so just return the 	 argument.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|&&
name|IDENTIFIER_OPNAME_P
argument_list|(
name|arg
argument_list|)
condition|)
block|{
name|my_friendly_abort
argument_list|(
literal|117
argument_list|)
expr_stmt|;
comment|/* We don't know the type yet, so just work around the problem. 	     We know that this will resolve to an lvalue.  */
return|return
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|unknown_type_node
argument_list|,
name|arg
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_CHAIN
argument_list|(
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
condition|)
comment|/* Unique overloaded non-member function.  */
return|return
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|arg
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|DECL_CHAIN
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
condition|)
comment|/* Unique overloaded member function.  */
return|return
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|TREE_VALUE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
return|return
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|unknown_type_node
argument_list|,
name|arg
argument_list|)
return|;
block|}
comment|/* Handle complex lvalues (when permitted) 	 by reduction to simpler cases.  */
name|val
operator|=
name|unary_complex_lvalue
argument_list|(
name|code
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
return|return
name|val
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
condition|)
block|{
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|FLOAT_EXPR
case|:
case|case
name|FIX_TRUNC_EXPR
case|:
case|case
name|FIX_FLOOR_EXPR
case|:
case|case
name|FIX_ROUND_EXPR
case|:
case|case
name|FIX_CEIL_EXPR
case|:
if|if
condition|(
operator|!
name|lvalue_p
argument_list|(
name|arg
argument_list|)
operator|&&
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"taking the address of a cast to non-reference type"
argument_list|)
expr_stmt|;
block|}
comment|/* Allow the address of a constructor if all the elements 	 are constant.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|CONSTRUCTOR
operator|&&
name|TREE_CONSTANT
argument_list|(
name|arg
argument_list|)
condition|)
empty_stmt|;
comment|/* Anything not already handled and not a true memory reference 	 is an error.  */
elseif|else
if|if
condition|(
name|typecode
operator|!=
name|FUNCTION_TYPE
operator|&&
name|typecode
operator|!=
name|METHOD_TYPE
operator|&&
operator|!
name|lvalue_or_else
argument_list|(
name|arg
argument_list|,
literal|"unary `&'"
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* Ordinary case; arg is a COMPONENT_REF or a decl.  */
name|argtype
operator|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/* If the lvalue is const or volatile, 	 merge that into the type that the address will point to.  */
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
literal|'d'
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
literal|'r'
condition|)
block|{
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|arg
argument_list|)
operator|||
name|TREE_THIS_VOLATILE
argument_list|(
name|arg
argument_list|)
condition|)
name|argtype
operator|=
name|cp_build_type_variant
argument_list|(
name|argtype
argument_list|,
name|TREE_READONLY
argument_list|(
name|arg
argument_list|)
argument_list|,
name|TREE_THIS_VOLATILE
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|argtype
operator|=
name|build_pointer_type
argument_list|(
name|argtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|mark_addressable
argument_list|(
name|arg
argument_list|)
operator|==
literal|0
condition|)
return|return
name|error_mark_node
return|;
block|{
name|tree
name|addr
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
name|addr
operator|=
name|build_component_addr
argument_list|(
name|arg
argument_list|,
name|argtype
argument_list|,
literal|"attempt to take address of bit-field structure member `%s'"
argument_list|)
expr_stmt|;
else|else
name|addr
operator|=
name|build1
argument_list|(
name|code
argument_list|,
name|argtype
argument_list|,
name|arg
argument_list|)
expr_stmt|;
comment|/* Address of a static or external variable or 	   function counts as a constant */
if|if
condition|(
name|staticp
argument_list|(
name|arg
argument_list|)
condition|)
name|TREE_CONSTANT
argument_list|(
name|addr
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|addr
return|;
block|}
block|}
if|if
condition|(
operator|!
name|errstring
condition|)
block|{
if|if
condition|(
name|argtype
operator|==
literal|0
condition|)
name|argtype
operator|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return
name|fold
argument_list|(
name|build1
argument_list|(
name|code
argument_list|,
name|argtype
argument_list|,
name|arg
argument_list|)
argument_list|)
return|;
block|}
name|error
argument_list|(
name|errstring
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* If CONVERSIONS is a conversion expression or a nested sequence of such,    convert ARG with the same conversions in the same order    and return the result.  */
end_comment

begin_function
specifier|static
name|tree
name|convert_sequence
parameter_list|(
name|conversions
parameter_list|,
name|arg
parameter_list|)
name|tree
name|conversions
decl_stmt|;
name|tree
name|arg
decl_stmt|;
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|conversions
argument_list|)
condition|)
block|{
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|FLOAT_EXPR
case|:
case|case
name|FIX_TRUNC_EXPR
case|:
case|case
name|FIX_FLOOR_EXPR
case|:
case|case
name|FIX_ROUND_EXPR
case|:
case|case
name|FIX_CEIL_EXPR
case|:
return|return
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|conversions
argument_list|)
argument_list|,
name|convert_sequence
argument_list|(
name|TREE_OPERAND
argument_list|(
name|conversions
argument_list|,
literal|0
argument_list|)
argument_list|,
name|arg
argument_list|)
argument_list|)
return|;
default|default:
return|return
name|arg
return|;
block|}
block|}
end_function

begin_comment
comment|/* Apply unary lvalue-demanding operator CODE to the expression ARG    for certain kinds of expressions which are not really lvalues    but which we can accept as lvalues.     If ARG is not a kind of expression we can handle, return zero.  */
end_comment

begin_function
name|tree
name|unary_complex_lvalue
parameter_list|(
name|code
parameter_list|,
name|arg
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|arg
decl_stmt|;
block|{
comment|/* Handle (a, b) used as an "lvalue".  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|COMPOUND_EXPR
condition|)
block|{
name|tree
name|real_result
init|=
name|build_unary_op
argument_list|(
name|code
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|real_result
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|real_result
argument_list|)
return|;
block|}
comment|/* Handle (a ? b : c) used as an "lvalue".  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|COND_EXPR
condition|)
return|return
name|rationalize_conditional_expr
argument_list|(
name|code
argument_list|,
name|arg
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|MODIFY_EXPR
condition|)
return|return
name|unary_complex_lvalue
argument_list|(
name|code
argument_list|,
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|arg
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|code
operator|!=
name|ADDR_EXPR
condition|)
return|return
literal|0
return|;
comment|/* Handle (a = b) used as an "lvalue" for `&'.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|MODIFY_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|INIT_EXPR
condition|)
block|{
name|tree
name|real_result
init|=
name|build_unary_op
argument_list|(
name|code
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|real_result
argument_list|)
argument_list|,
name|arg
argument_list|,
name|real_result
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|WITH_CLEANUP_EXPR
condition|)
block|{
name|tree
name|real_result
init|=
name|build_unary_op
argument_list|(
name|code
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|real_result
operator|=
name|build
argument_list|(
name|WITH_CLEANUP_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|real_result
argument_list|)
argument_list|,
name|real_result
argument_list|,
literal|0
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|real_result
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
block|{
comment|/* The representation of something of type OFFSET_TYPE 	 is really the representation of a pointer to it. 	 Here give the representation its true type.  */
name|tree
name|t
decl_stmt|;
name|tree
name|offset
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|SCOPE_REF
argument_list|,
literal|313
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|OFFSET_REF
condition|)
return|return
literal|0
return|;
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
comment|/* Check all this code for right semantics. */
return|return
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|VAR_DECL
condition|)
return|return
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
return|;
else|else
block|{
comment|/* Can't build a pointer to member if the member must 	     go through virtual base classes.  */
if|if
condition|(
name|virtual_member
argument_list|(
name|DECL_FIELD_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|,
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|sorry
argument_list|(
literal|"pointer to member via virtual baseclass"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|NOP_EXPR
operator|||
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|!=
name|error_mark_node
operator|)
condition|)
block|{
comment|/* Don't know if this should return address to just 		 _DECL, or actual address resolved in this expression.  */
name|sorry
argument_list|(
literal|"address of bound pointer-to-member expression"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|convert
argument_list|(
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|,
name|size_binop
argument_list|(
name|EASY_DIV_EXPR
argument_list|,
name|DECL_FIELD_BITPOS
argument_list|(
name|t
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|BITS_PER_UNIT
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|OFFSET_REF
condition|)
block|{
name|tree
name|left
init|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
decl_stmt|,
name|left_addr
decl_stmt|;
name|tree
name|right_addr
init|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|left
operator|==
literal|0
condition|)
if|if
condition|(
name|current_class_decl
condition|)
name|left_addr
operator|=
name|current_class_decl
expr_stmt|;
else|else
block|{
name|error
argument_list|(
literal|"no `this' for pointer to member"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
else|else
name|left_addr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|left
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|,
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|left_addr
argument_list|)
argument_list|,
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|right_addr
argument_list|)
argument_list|)
return|;
block|}
comment|/* We permit compiler to make function calls returning      objects of aggregate type look like lvalues.  */
block|{
name|tree
name|targ
init|=
name|arg
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|targ
argument_list|)
operator|==
name|SAVE_EXPR
condition|)
name|targ
operator|=
name|TREE_OPERAND
argument_list|(
name|targ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|targ
argument_list|)
operator|==
name|CALL_EXPR
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|targ
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|SAVE_EXPR
condition|)
name|targ
operator|=
name|arg
expr_stmt|;
else|else
name|targ
operator|=
name|build_cplus_new
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|arg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|,
name|targ
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|SAVE_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|targ
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
return|return
name|build
argument_list|(
name|SAVE_EXPR
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|targ
argument_list|,
literal|0
argument_list|)
argument_list|,
name|current_function_decl
argument_list|,
name|NULL
argument_list|)
return|;
comment|/* We shouldn't wrap WITH_CLEANUP_EXPRs inside of SAVE_EXPRs, but in case        we do, here's how to handle it.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|SAVE_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|targ
argument_list|)
operator|==
name|WITH_CLEANUP_EXPR
condition|)
block|{
if|#
directive|if
literal|0
comment|/* Not really a bug, but something to turn on when testing.  */
block|compiler_error ("WITH_CLEANUP_EXPR wrapped in SAVE_EXPR");
endif|#
directive|endif
return|return
name|unary_complex_lvalue
argument_list|(
name|ADDR_EXPR
argument_list|,
name|targ
argument_list|)
return|;
block|}
block|}
comment|/* Don't let anything else be handled specially.  */
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Mark EXP saying that we need to be able to take the    address of it; it should not be allocated in a register.    Value is 1 if successful.     C++: we do not allow `current_class_decl' to be addressable.  */
end_comment

begin_function
name|int
name|mark_addressable
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
specifier|register
name|tree
name|x
init|=
name|exp
decl_stmt|;
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|x
argument_list|)
operator|==
literal|1
condition|)
return|return
literal|1
return|;
while|while
condition|(
literal|1
condition|)
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|ADDR_EXPR
case|:
case|case
name|COMPONENT_REF
case|:
case|case
name|ARRAY_REF
case|:
name|x
operator|=
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARM_DECL
case|:
if|if
condition|(
name|x
operator|==
name|current_class_decl
condition|)
block|{
name|error
argument_list|(
literal|"address of `this' not available"
argument_list|)
expr_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* so compiler doesn't die later */
name|put_var_into_stack
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
case|case
name|VAR_DECL
case|:
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|x
argument_list|)
operator|&&
name|TREE_READONLY
argument_list|(
name|x
argument_list|)
operator|&&
name|DECL_RTL
argument_list|(
name|x
argument_list|)
operator|!=
literal|0
operator|&&
operator|!
name|decl_in_memory_p
argument_list|(
name|x
argument_list|)
condition|)
block|{
comment|/* We thought this would make a good constant variable, 	       but we were wrong.  */
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|end_temporary_allocation
argument_list|()
expr_stmt|;
name|TREE_ASM_WRITTEN
argument_list|(
name|x
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_RTL
argument_list|(
name|x
argument_list|)
operator|=
literal|0
expr_stmt|;
name|rest_of_decl_compilation
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|x
argument_list|)
operator|==
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Caller should not be trying to mark initialized 	   constant fields addressable.  */
name|my_friendly_assert
argument_list|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|x
argument_list|)
operator|==
literal|0
operator|||
name|DECL_IN_AGGR_P
argument_list|(
name|x
argument_list|)
operator|==
literal|0
operator|||
name|TREE_STATIC
argument_list|(
name|x
argument_list|)
operator|||
name|DECL_EXTERNAL
argument_list|(
name|x
argument_list|)
argument_list|,
literal|314
argument_list|)
expr_stmt|;
case|case
name|CONST_DECL
case|:
case|case
name|RESULT_DECL
case|:
comment|/* For C++, we don't warn about taking the address of a register 	   variable for CONST_DECLs; ARM p97 explicitly says it's okay.  */
name|put_var_into_stack
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
case|case
name|FUNCTION_DECL
case|:
comment|/* We have to test both conditions here.  The first may 	   be non-zero in the case of processing a default function. 	   The second may be non-zero in the case of a template function.  */
name|x
operator|=
name|DECL_MAIN_VARIANT
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|DECL_INLINE
argument_list|(
name|x
argument_list|)
operator|||
name|DECL_PENDING_INLINE_INFO
argument_list|(
name|x
argument_list|)
operator|)
operator|&&
operator|(
name|DECL_CONTEXT
argument_list|(
name|x
argument_list|)
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|!=
literal|'t'
operator|||
operator|!
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|mark_inline_for_output
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|current_function_decl
condition|)
name|DECL_EXTERNAL
argument_list|(
name|x
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
name|TREE_ADDRESSABLE
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_USED
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|x
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
default|default:
return|return
literal|1
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Build and return a conditional expression IFEXP ? OP1 : OP2.  */
end_comment

begin_function
name|tree
name|build_x_conditional_expr
parameter_list|(
name|ifexp
parameter_list|,
name|op1
parameter_list|,
name|op2
parameter_list|)
name|tree
name|ifexp
decl_stmt|,
name|op1
decl_stmt|,
name|op2
decl_stmt|;
block|{
name|tree
name|rval
init|=
name|NULL_TREE
decl_stmt|;
comment|/* See comments in `build_x_binary_op'.  */
if|if
condition|(
name|op1
operator|!=
literal|0
condition|)
name|rval
operator|=
name|build_opfncall
argument_list|(
name|COND_EXPR
argument_list|,
name|LOOKUP_SPECULATIVELY
argument_list|,
name|ifexp
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
condition|)
return|return
name|build_opfncall
argument_list|(
name|COND_EXPR
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|ifexp
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
return|;
return|return
name|build_conditional_expr
argument_list|(
name|ifexp
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
return|;
block|}
end_function

begin_function
name|tree
name|build_conditional_expr
parameter_list|(
name|ifexp
parameter_list|,
name|op1
parameter_list|,
name|op2
parameter_list|)
name|tree
name|ifexp
decl_stmt|,
name|op1
decl_stmt|,
name|op2
decl_stmt|;
block|{
specifier|register
name|tree
name|type1
decl_stmt|;
specifier|register
name|tree
name|type2
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|code1
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|code2
decl_stmt|;
specifier|register
name|tree
name|result_type
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|orig_op1
init|=
name|op1
decl_stmt|,
name|orig_op2
init|=
name|op2
decl_stmt|;
comment|/* If second operand is omitted, it is the same as the first one;      make sure it is calculated only once.  */
if|if
condition|(
name|op1
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C++ forbids omitting the middle term of a ?: expression"
argument_list|)
expr_stmt|;
name|ifexp
operator|=
name|op1
operator|=
name|save_expr
argument_list|(
name|ifexp
argument_list|)
expr_stmt|;
block|}
name|ifexp
operator|=
name|bool_truthvalue_conversion
argument_list|(
name|default_conversion
argument_list|(
name|ifexp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ifexp
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
name|op1
operator|=
name|require_instantiated_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|op2
argument_list|)
argument_list|,
name|op1
argument_list|,
name|error_mark_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|op2
operator|=
name|require_instantiated_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|,
name|op2
argument_list|,
name|error_mark_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|op2
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* C++: REFERENCE_TYPES must be dereferenced.  */
name|type1
operator|=
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
expr_stmt|;
name|code1
operator|=
name|TREE_CODE
argument_list|(
name|type1
argument_list|)
expr_stmt|;
name|type2
operator|=
name|TREE_TYPE
argument_list|(
name|op2
argument_list|)
expr_stmt|;
name|code2
operator|=
name|TREE_CODE
argument_list|(
name|type2
argument_list|)
expr_stmt|;
if|if
condition|(
name|code1
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|op1
operator|=
name|convert_from_reference
argument_list|(
name|op1
argument_list|)
expr_stmt|;
name|type1
operator|=
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
expr_stmt|;
name|code1
operator|=
name|TREE_CODE
argument_list|(
name|type1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|code2
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|op2
operator|=
name|convert_from_reference
argument_list|(
name|op2
argument_list|)
expr_stmt|;
name|type2
operator|=
name|TREE_TYPE
argument_list|(
name|op2
argument_list|)
expr_stmt|;
name|code2
operator|=
name|TREE_CODE
argument_list|(
name|type2
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|1
comment|/* Produces wrong result if within sizeof.  Sorry.  */
comment|/* Don't promote the operands separately if they promote      the same way.  Return the unpromoted type and let the combined      value get promoted if necessary.  */
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type1
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|type2
argument_list|)
operator|&&
name|code2
operator|!=
name|ARRAY_TYPE
if|#
directive|if
literal|0
comment|/* For C++, let the enumeral type come through.  */
expr|&& code2 != ENUMERAL_TYPE
endif|#
directive|endif
operator|&&
name|code2
operator|!=
name|FUNCTION_TYPE
operator|&&
name|code2
operator|!=
name|METHOD_TYPE
condition|)
block|{
name|tree
name|result
decl_stmt|;
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|ifexp
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|ifexp
argument_list|)
operator|==
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|ifexp
argument_list|)
operator|==
name|ADDR_EXPR
operator|)
condition|)
return|return
operator|(
name|integer_zerop
argument_list|(
name|ifexp
argument_list|)
condition|?
name|op2
else|:
name|op1
operator|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_DECL
condition|)
name|op1
operator|=
name|DECL_INITIAL
argument_list|(
name|op1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_READONLY_DECL_P
argument_list|(
name|op1
argument_list|)
condition|)
name|op1
operator|=
name|decl_constant_value
argument_list|(
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op2
argument_list|)
operator|==
name|CONST_DECL
condition|)
name|op2
operator|=
name|DECL_INITIAL
argument_list|(
name|op2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_READONLY_DECL_P
argument_list|(
name|op2
argument_list|)
condition|)
name|op2
operator|=
name|decl_constant_value
argument_list|(
name|op2
argument_list|)
expr_stmt|;
if|if
condition|(
name|type1
operator|!=
name|type2
condition|)
name|type1
operator|=
name|cp_build_type_variant
argument_list|(
name|type1
argument_list|,
name|TREE_READONLY
argument_list|(
name|op1
argument_list|)
operator|||
name|TREE_READONLY
argument_list|(
name|op2
argument_list|)
argument_list|,
name|TREE_THIS_VOLATILE
argument_list|(
name|op1
argument_list|)
operator|||
name|TREE_THIS_VOLATILE
argument_list|(
name|op2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ??? This is a kludge to deal with the fact that 	 we don't sort out integers and enums properly, yet.  */
name|result
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|type1
argument_list|,
name|ifexp
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
operator|!=
name|type1
condition|)
name|result
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type1
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
endif|#
directive|endif
comment|/* They don't match; promote them both and then try to reconcile them.      But don't permit mismatching enum types.  */
if|if
condition|(
name|code1
operator|==
name|ENUMERAL_TYPE
condition|)
block|{
if|if
condition|(
name|code2
operator|==
name|ENUMERAL_TYPE
condition|)
block|{
name|message_2_types
argument_list|(
name|error
argument_list|,
literal|"enumeral mismatch in conditional expression: `%s' vs `%s'"
argument_list|,
name|type1
argument_list|,
name|type2
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
name|extra_warnings
operator|&&
operator|!
name|IS_AGGR_TYPE_CODE
argument_list|(
name|code2
argument_list|)
condition|)
name|warning
argument_list|(
literal|"enumeral and non-enumeral type in conditional expression"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|extra_warnings
operator|&&
name|code2
operator|==
name|ENUMERAL_TYPE
operator|&&
operator|!
name|IS_AGGR_TYPE_CODE
argument_list|(
name|code1
argument_list|)
condition|)
name|warning
argument_list|(
literal|"enumeral and non-enumeral type in conditional expression"
argument_list|)
expr_stmt|;
if|if
condition|(
name|code1
operator|!=
name|VOID_TYPE
condition|)
block|{
name|op1
operator|=
name|default_conversion
argument_list|(
name|op1
argument_list|)
expr_stmt|;
name|type1
operator|=
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
expr_stmt|;
name|code1
operator|=
name|TREE_CODE
argument_list|(
name|type1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|code2
operator|!=
name|VOID_TYPE
condition|)
block|{
name|op2
operator|=
name|default_conversion
argument_list|(
name|op2
argument_list|)
expr_stmt|;
name|type2
operator|=
name|TREE_TYPE
argument_list|(
name|op2
argument_list|)
expr_stmt|;
name|code2
operator|=
name|TREE_CODE
argument_list|(
name|type2
argument_list|)
expr_stmt|;
block|}
comment|/* Quickly detect the usual case where op1 and op2 have the same type      after promotion.  */
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type1
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|type2
argument_list|)
condition|)
block|{
if|if
condition|(
name|type1
operator|==
name|type2
condition|)
name|result_type
operator|=
name|type1
expr_stmt|;
else|else
name|result_type
operator|=
name|cp_build_type_variant
argument_list|(
name|type1
argument_list|,
name|TREE_READONLY
argument_list|(
name|op1
argument_list|)
operator|||
name|TREE_READONLY
argument_list|(
name|op2
argument_list|)
argument_list|,
name|TREE_THIS_VOLATILE
argument_list|(
name|op1
argument_list|)
operator|||
name|TREE_THIS_VOLATILE
argument_list|(
name|op2
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|code1
operator|==
name|INTEGER_TYPE
operator|||
name|code1
operator|==
name|REAL_TYPE
operator|)
operator|&&
operator|(
name|code2
operator|==
name|INTEGER_TYPE
operator|||
name|code2
operator|==
name|REAL_TYPE
operator|)
condition|)
block|{
name|result_type
operator|=
name|common_type
argument_list|(
name|type1
argument_list|,
name|type2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code1
operator|==
name|VOID_TYPE
operator|||
name|code2
operator|==
name|VOID_TYPE
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
operator|(
name|code1
operator|!=
name|VOID_TYPE
operator|||
name|code2
operator|!=
name|VOID_TYPE
operator|)
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C++ forbids conditional expr with only one void side"
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|void_type_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code1
operator|==
name|POINTER_TYPE
operator|&&
name|code2
operator|==
name|POINTER_TYPE
condition|)
block|{
if|if
condition|(
name|comp_target_types
argument_list|(
name|type1
argument_list|,
name|type2
argument_list|,
literal|1
argument_list|)
condition|)
name|result_type
operator|=
name|common_type
argument_list|(
name|type1
argument_list|,
name|type2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|integer_zerop
argument_list|(
name|op1
argument_list|)
operator|&&
name|TREE_TYPE
argument_list|(
name|type1
argument_list|)
operator|==
name|void_type_node
operator|&&
name|TREE_CODE
argument_list|(
name|orig_op1
argument_list|)
operator|!=
name|NOP_EXPR
condition|)
name|result_type
operator|=
name|qualify_type
argument_list|(
name|type2
argument_list|,
name|type1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|integer_zerop
argument_list|(
name|op2
argument_list|)
operator|&&
name|TREE_TYPE
argument_list|(
name|type2
argument_list|)
operator|==
name|void_type_node
operator|&&
name|TREE_CODE
argument_list|(
name|orig_op2
argument_list|)
operator|!=
name|NOP_EXPR
condition|)
name|result_type
operator|=
name|qualify_type
argument_list|(
name|type1
argument_list|,
name|type2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|type1
argument_list|)
argument_list|)
operator|==
name|void_type_node
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
name|TREE_CODE
argument_list|(
name|type2
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C++ forbids conditional expr between `void *' and function pointer"
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|qualify_type
argument_list|(
name|type1
argument_list|,
name|type2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|type2
argument_list|)
argument_list|)
operator|==
name|void_type_node
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
name|TREE_CODE
argument_list|(
name|type1
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C++ forbids conditional expr between `void *' and function pointer"
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|qualify_type
argument_list|(
name|type2
argument_list|,
name|type1
argument_list|)
expr_stmt|;
block|}
comment|/* C++ */
elseif|else
if|if
condition|(
name|comptypes
argument_list|(
name|type2
argument_list|,
name|type1
argument_list|,
literal|0
argument_list|)
condition|)
name|result_type
operator|=
name|type2
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type1
argument_list|)
argument_list|)
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type2
argument_list|)
argument_list|)
operator|&&
operator|(
name|result_type
operator|=
name|common_base_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|type2
argument_list|)
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|result_type
operator|==
name|error_mark_node
condition|)
block|{
name|cp_error
argument_list|(
literal|"common base type of types `%T' and `%T' is ambiguous"
argument_list|,
name|TREE_TYPE
argument_list|(
name|type1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|type2
argument_list|)
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|ptr_type_node
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|pedantic
operator|&&
name|result_type
operator|!=
name|TREE_TYPE
argument_list|(
name|type1
argument_list|)
operator|&&
name|result_type
operator|!=
name|TREE_TYPE
argument_list|(
name|type2
argument_list|)
condition|)
name|cp_pedwarn
argument_list|(
literal|"`%T' and `%T' converted to `%T *' in conditional expression"
argument_list|,
name|type1
argument_list|,
name|type2
argument_list|,
name|result_type
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|TYPE_POINTER_TO
argument_list|(
name|result_type
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|pedwarn
argument_list|(
literal|"pointer type mismatch in conditional expression"
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|ptr_type_node
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|code1
operator|==
name|POINTER_TYPE
operator|&&
name|code2
operator|==
name|INTEGER_TYPE
condition|)
block|{
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|op2
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"pointer/integer type mismatch in conditional expression"
argument_list|)
expr_stmt|;
else|else
block|{
name|op2
operator|=
name|null_pointer_node
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Sez who? */
block|if (pedantic&& TREE_CODE (type1) == FUNCTION_TYPE) 	    pedwarn ("ANSI C++ forbids conditional expr between 0 and function pointer");
endif|#
directive|endif
block|}
name|result_type
operator|=
name|type1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code2
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
block|{
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|op1
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"pointer/integer type mismatch in conditional expression"
argument_list|)
expr_stmt|;
else|else
block|{
name|op1
operator|=
name|null_pointer_node
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Sez who? */
block|if (pedantic&& TREE_CODE (type2) == FUNCTION_TYPE) 	    pedwarn ("ANSI C++ forbids conditional expr between 0 and function pointer");
endif|#
directive|endif
block|}
name|result_type
operator|=
name|type2
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|result_type
condition|)
block|{
comment|/* The match does not look good.  If either is 	 an aggregate value, try converting to a scalar type.  */
if|if
condition|(
name|code1
operator|==
name|RECORD_TYPE
operator|&&
name|code2
operator|==
name|RECORD_TYPE
condition|)
block|{
name|message_2_types
argument_list|(
name|error
argument_list|,
literal|"aggregate mismatch in conditional expression: `%s' vs `%s'"
argument_list|,
name|type1
argument_list|,
name|type2
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|code1
operator|==
name|RECORD_TYPE
operator|&&
name|TYPE_HAS_CONVERSION
argument_list|(
name|type1
argument_list|)
condition|)
block|{
name|tree
name|tmp
init|=
name|build_type_conversion
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|type2
argument_list|,
name|op1
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL_TREE
condition|)
block|{
name|cp_error
argument_list|(
literal|"aggregate type `%T' could not convert on lhs of `:'"
argument_list|,
name|type1
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|tmp
operator|==
name|error_mark_node
condition|)
name|error
argument_list|(
literal|"ambiguous pointer conversion"
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|type2
expr_stmt|;
name|op1
operator|=
name|tmp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code2
operator|==
name|RECORD_TYPE
operator|&&
name|TYPE_HAS_CONVERSION
argument_list|(
name|type2
argument_list|)
condition|)
block|{
name|tree
name|tmp
init|=
name|build_type_conversion
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|type1
argument_list|,
name|op2
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL_TREE
condition|)
block|{
name|cp_error
argument_list|(
literal|"aggregate type `%T' could not convert on rhs of `:'"
argument_list|,
name|type2
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|tmp
operator|==
name|error_mark_node
condition|)
name|error
argument_list|(
literal|"ambiguous pointer conversion"
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|type1
expr_stmt|;
name|op2
operator|=
name|tmp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flag_cond_mismatch
condition|)
name|result_type
operator|=
name|void_type_node
expr_stmt|;
else|else
block|{
name|error
argument_list|(
literal|"type mismatch in conditional expression"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
if|if
condition|(
name|result_type
operator|!=
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
condition|)
name|op1
operator|=
name|convert_and_check
argument_list|(
name|result_type
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|result_type
operator|!=
name|TREE_TYPE
argument_list|(
name|op2
argument_list|)
condition|)
name|op2
operator|=
name|convert_and_check
argument_list|(
name|result_type
argument_list|,
name|op2
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* XXX delete me, I've been here for years.  */
block|if (IS_AGGR_TYPE_CODE (code1))     {       result_type = TREE_TYPE (op1);       if (TREE_CONSTANT (ifexp)) 	return (integer_zerop (ifexp) ? op2 : op1);        if (TYPE_MODE (result_type) == BLKmode) 	{ 	  register tree tempvar 	    = build_decl (VAR_DECL, NULL_TREE, result_type); 	  register tree xop1 = build_modify_expr (tempvar, NOP_EXPR, op1); 	  register tree xop2 = build_modify_expr (tempvar, NOP_EXPR, op2); 	  register tree result = fold (build (COND_EXPR, result_type, 					      ifexp, xop1, xop2));  	  layout_decl (tempvar, 0);
comment|/* No way to handle variable-sized objects here. 	     I fear that the entire handling of BLKmode conditional exprs 	     needs to be redone.  */
block|my_friendly_assert (TREE_CONSTANT (DECL_SIZE (tempvar)), 315); 	  DECL_RTL (tempvar) 	    = assign_stack_local (DECL_MODE (tempvar), 				  (TREE_INT_CST_LOW (DECL_SIZE (tempvar)) 				   + BITS_PER_UNIT - 1) 				  / BITS_PER_UNIT, 				  0);  	  TREE_SIDE_EFFECTS (result) 	    = TREE_SIDE_EFFECTS (ifexp) | TREE_SIDE_EFFECTS (op1) 	      | TREE_SIDE_EFFECTS (op2); 	  return build (COMPOUND_EXPR, result_type, result, tempvar); 	}     }
endif|#
directive|endif
comment|/* 0 */
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|ifexp
argument_list|)
condition|)
return|return
name|integer_zerop
argument_list|(
name|ifexp
argument_list|)
condition|?
name|op2
else|:
name|op1
return|;
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|result_type
argument_list|,
name|ifexp
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Handle overloading of the ',' operator when needed.  Otherwise,    this function just builds an expression list.  */
end_comment

begin_function
name|tree
name|build_x_compound_expr
parameter_list|(
name|list
parameter_list|)
name|tree
name|list
decl_stmt|;
block|{
name|tree
name|rest
init|=
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
decl_stmt|;
name|tree
name|result
decl_stmt|;
if|if
condition|(
name|rest
operator|==
name|NULL_TREE
condition|)
return|return
name|build_compound_expr
argument_list|(
name|list
argument_list|)
return|;
name|result
operator|=
name|build_opfncall
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|rest
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
return|return
name|build_x_compound_expr
argument_list|(
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|result
argument_list|,
name|TREE_CHAIN
argument_list|(
name|rest
argument_list|)
argument_list|)
argument_list|)
return|;
return|return
name|build_compound_expr
argument_list|(
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|build_x_compound_expr
argument_list|(
name|rest
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given a list of expressions, return a compound expression    that performs them all and returns the value of the last of them.  */
end_comment

begin_function
name|tree
name|build_compound_expr
parameter_list|(
name|list
parameter_list|)
name|tree
name|list
decl_stmt|;
block|{
specifier|register
name|tree
name|rest
decl_stmt|;
if|if
condition|(
name|TREE_READONLY_DECL_P
argument_list|(
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
argument_list|)
condition|)
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
operator|=
name|decl_constant_value
argument_list|(
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* build_c_cast puts on a NOP_EXPR to make the result not an lvalue. 	 Strip such NOP_EXPRs, since LIST is used in non-lvalue context.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|list
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_TYPE
argument_list|(
name|list
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|list
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|list
operator|=
name|TREE_OPERAND
argument_list|(
name|list
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Convert arrays to pointers.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
return|return
name|default_conversion
argument_list|(
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
argument_list|)
return|;
else|else
return|return
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
return|;
block|}
name|rest
operator|=
name|build_compound_expr
argument_list|(
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
argument_list|)
expr_stmt|;
comment|/* When pedantic, a compound expression can be neither an lvalue      nor an integer constant expression.  */
if|if
condition|(
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
argument_list|)
operator|&&
operator|!
name|pedantic
condition|)
return|return
name|rest
return|;
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|rest
argument_list|)
argument_list|,
name|break_out_cleanups
argument_list|(
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
argument_list|)
argument_list|,
name|rest
argument_list|)
return|;
block|}
end_function

begin_function
name|tree
name|build_static_cast
parameter_list|(
name|type
parameter_list|,
name|expr
parameter_list|)
name|tree
name|type
decl_stmt|,
name|expr
decl_stmt|;
block|{
return|return
name|build_c_cast
argument_list|(
name|type
argument_list|,
name|expr
argument_list|)
return|;
block|}
end_function

begin_function
name|tree
name|build_reinterpret_cast
parameter_list|(
name|type
parameter_list|,
name|expr
parameter_list|)
name|tree
name|type
decl_stmt|,
name|expr
decl_stmt|;
block|{
return|return
name|build_c_cast
argument_list|(
name|type
argument_list|,
name|expr
argument_list|)
return|;
block|}
end_function

begin_function
name|tree
name|build_const_cast
parameter_list|(
name|type
parameter_list|,
name|expr
parameter_list|)
name|tree
name|type
decl_stmt|,
name|expr
decl_stmt|;
block|{
return|return
name|build_c_cast
argument_list|(
name|type
argument_list|,
name|expr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Build an expression representing a cast to type TYPE of expression EXPR.  */
end_comment

begin_function
name|tree
name|build_c_cast
parameter_list|(
name|type
parameter_list|,
name|expr
parameter_list|)
specifier|register
name|tree
name|type
decl_stmt|;
name|tree
name|expr
decl_stmt|;
block|{
specifier|register
name|tree
name|value
init|=
name|expr
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
operator|||
name|expr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* build_c_cast puts on a NOP_EXPR to make the result not an lvalue.      Strip such NOP_EXPRs, since VALUE is being used in non-lvalue context.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|value
operator|=
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|OFFSET_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|OFFSET_TYPE
condition|)
name|value
operator|=
name|resolve_offset_ref
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
comment|/* Allow casting from T1* to T2[] because Cfront allows it. 	 NIHCL uses it. It is not valid ANSI C however, and hence, not 	 valid ANSI C++.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C++ forbids casting to an array type"
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"ANSI C++ forbids casting to an array type"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|cp_error
argument_list|(
literal|"casting to function type `%T'"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|IS_SIGNATURE
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"cast specifies signature type"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* If there's only one function in the overloaded space,      just take it.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|TREE_CHAIN
argument_list|(
name|value
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|value
operator|=
name|TREE_VALUE
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VOID_TYPE
condition|)
name|value
operator|=
name|build1
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|type
argument_list|,
name|value
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
operator|==
name|NULL_TREE
operator|||
name|type_unknown_p
argument_list|(
name|value
argument_list|)
condition|)
block|{
name|value
operator|=
name|instantiate_type
argument_list|(
name|type
argument_list|,
name|value
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Did we lose?  */
if|if
condition|(
name|value
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
block|}
else|else
block|{
name|tree
name|otype
decl_stmt|,
name|ovalue
decl_stmt|;
comment|/* Convert functions and arrays to pointers and 	 convert references to their expanded types, 	 but don't convert any other types.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|value
operator|=
name|default_conversion
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|otype
operator|=
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
expr_stmt|;
comment|/* Optionally warn about potentially worrisome casts.  */
if|if
condition|(
name|warn_cast_qual
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|otype
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
comment|/* For C++ we make these regular warnings, rather than 	     softening them into pedwarns.  */
if|if
condition|(
name|TYPE_VOLATILE
argument_list|(
name|TREE_TYPE
argument_list|(
name|otype
argument_list|)
argument_list|)
operator|&&
operator|!
name|TYPE_VOLATILE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|warning
argument_list|(
literal|"cast discards `volatile' from pointer target type"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|otype
argument_list|)
argument_list|)
operator|&&
operator|!
name|TYPE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|warning
argument_list|(
literal|"cast discards `const' from pointer target type"
argument_list|)
expr_stmt|;
block|}
comment|/* Warn about possible alignment problems.  */
if|if
condition|(
name|STRICT_ALIGNMENT
operator|&&
name|warn_cast_align
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|otype
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|otype
argument_list|)
argument_list|)
operator|!=
name|VOID_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|otype
argument_list|)
argument_list|)
operator|!=
name|FUNCTION_TYPE
operator|&&
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|>
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|otype
argument_list|)
argument_list|)
condition|)
name|warning
argument_list|(
literal|"cast increases required alignment of target type"
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (TREE_CODE (type) == INTEGER_TYPE&& TREE_CODE (otype) == POINTER_TYPE&& TYPE_PRECISION (type) != TYPE_PRECISION (otype)) 	warning ("cast from pointer to integer of different size");        if (TREE_CODE (type) == POINTER_TYPE&& TREE_CODE (otype) == INTEGER_TYPE&& TYPE_PRECISION (type) != TYPE_PRECISION (otype)
comment|/* Don't warn about converting 0 to pointer, 	     provided the 0 was explicit--not cast or made by folding.  */
block|&& !(TREE_CODE (value) == INTEGER_CST&& integer_zerop (value))) 	warning ("cast to pointer from integer of different size");
endif|#
directive|endif
if|if
condition|(
name|TREE_READONLY_DECL_P
argument_list|(
name|value
argument_list|)
condition|)
name|value
operator|=
name|decl_constant_value
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|ovalue
operator|=
name|value
expr_stmt|;
name|value
operator|=
name|convert_force
argument_list|(
name|type
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/* Ignore any integer overflow caused by the cast.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|TREE_OVERFLOW
argument_list|(
name|value
argument_list|)
operator|=
name|TREE_OVERFLOW
argument_list|(
name|ovalue
argument_list|)
expr_stmt|;
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|value
argument_list|)
operator|=
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|ovalue
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Always produce some operator for an explicit cast,        so we can tell (for -pedantic) that the cast is no lvalue.        Also, pedantically, don't let (void *) (FOO *) 0 be a null        pointer constant.  */
if|if
condition|(
name|value
operator|==
name|expr
operator|||
operator|(
name|pedantic
operator|&&
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|!=
name|INTEGER_TYPE
operator|)
condition|)
block|{
name|tree
name|nvalue
init|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|value
argument_list|)
decl_stmt|;
name|TREE_CONSTANT
argument_list|(
name|nvalue
argument_list|)
operator|=
name|TREE_CONSTANT
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
name|nvalue
return|;
block|}
return|return
name|value
return|;
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Build an assignment expression of lvalue LHS from value RHS.     In C++, if the left hand side of the assignment is a REFERENCE_TYPE,    that reference becomes deferenced down to it base type. */
end_comment

begin_comment
comment|/* Return a reference to the BASE_INDEX part of EXPR.  TYPE is    the type to which BASE_INDEX applies.  */
end_comment

begin_comment
unit|static tree get_base_ref (type, base_index, expr)      tree type;      int base_index;      tree expr; {   tree binfos = TYPE_BINFO_BASETYPES (type);   tree base_binfo = TREE_VEC_ELT (binfos, base_index);   tree ref;    if (TREE_CODE (expr) == ARRAY_REF       || ! BINFO_OFFSET_ZEROP (base_binfo)       || TREE_VIA_VIRTUAL (base_binfo)       || TYPE_MODE (type) != TYPE_MODE (BINFO_TYPE (base_binfo)))     {       tree addr = build_unary_op (ADDR_EXPR, expr, 0);       ref = build_indirect_ref (convert_pointer_to (base_binfo, addr), 				NULL_PTR);     }   else     {       ref = copy_node (expr);       TREE_TYPE (ref) = BINFO_TYPE (base_binfo);     }   return ref; }
comment|/* Build an assignment expression of lvalue LHS from value RHS.    MODIFYCODE is the code for a binary operator that we use    to combine the old value of LHS with RHS to get the new value.    Or else MODIFYCODE is NOP_EXPR meaning do a simple assignment.     C++: If MODIFYCODE is INIT_EXPR, then leave references unbashed.     `build_modify_expr_1' implements recursive part of memberwise    assignment operation.  */
end_comment

begin_comment
unit|static tree build_modify_expr_1 (lhs, modifycode, rhs, basetype_path)      tree lhs, rhs;      enum tree_code modifycode;      tree basetype_path; {   register tree result;   tree newrhs = rhs;   tree lhstype = TREE_TYPE (lhs);   tree olhstype = lhstype;
comment|/* Avoid duplicate error messages from operands that had errors.  */
end_comment

begin_comment
unit|if (TREE_CODE (lhs) == ERROR_MARK || TREE_CODE (rhs) == ERROR_MARK)     return error_mark_node;
comment|/* If a binary op has been requested, combine the old LHS value with the RHS      producing the value we should actually store into the LHS.  */
end_comment

begin_comment
unit|if (modifycode == INIT_EXPR)     ;   else if (modifycode == NOP_EXPR)     {
comment|/* must deal with overloading of `operator=' here.  */
end_comment

begin_comment
unit|if (TREE_CODE (lhstype) == REFERENCE_TYPE) 	lhstype = TREE_TYPE (lhstype);       else 	lhstype = olhstype;     }   else     {       lhs = stabilize_reference (lhs);       newrhs = build_binary_op (modifycode, lhs, rhs, 1);       modifycode = NOP_EXPR;     }
comment|/* If storing into a structure or union member,      it has probably been given type `int'.      Compute the type that would go with      the actual amount of storage the member occupies.  */
end_comment

begin_comment
unit|if (TREE_CODE (lhs) == COMPONENT_REF&& (TREE_CODE (lhstype) == INTEGER_TYPE 	  || TREE_CODE (lhstype) == REAL_TYPE 	  || TREE_CODE (lhstype) == ENUMERAL_TYPE))     lhstype = TREE_TYPE (get_unwidened (lhs, 0));
comment|/* C++: The semantics of C++ differ from those of C when an      assignment of an aggregate is desired.  Assignment in C++ is      now defined as memberwise assignment of non-static members      and base class objects.  This rule applies recursively      until a member of a built-in type is found.       Also, we cannot do a bit-wise copy of aggregates which      contain virtual function table pointers.  Those      pointer values must be preserved through the copy.      However, this is handled in expand_expr, and not here.      This is because much better code can be generated at      that stage than this one.  */
end_comment

begin_comment
unit|if (TREE_CODE (lhstype) == RECORD_TYPE&& TYPE_LANG_SPECIFIC (lhstype)&& TYPE_MAIN_VARIANT (lhstype) == TYPE_MAIN_VARIANT (TREE_TYPE (newrhs)))     {       register tree elt;       int i;
comment|/* Perform operation on object.  */
end_comment

begin_comment
unit|if (modifycode == INIT_EXPR&& TYPE_HAS_INIT_REF (lhstype)) 	{ 	  result = build_method_call (lhs, constructor_name_full (lhstype), 				      build_tree_list (NULL_TREE, rhs), 				      basetype_path, LOOKUP_NORMAL); 	  return build_indirect_ref (result, NULL_PTR); 	}       else if (modifycode == NOP_EXPR) 	{
comment|/* `operator=' is not an inheritable operator; see 13.4.3.  */
end_comment

begin_comment
unit|if (TYPE_LANG_SPECIFIC (lhstype)&& TYPE_HAS_ASSIGNMENT (lhstype)) 	    { 	      result = build_opfncall (MODIFY_EXPR, LOOKUP_NORMAL, 				       lhs, rhs, make_node (NOP_EXPR)); 	      if (result == NULL_TREE) 		return error_mark_node; 	      return result; 	    } 	}        if (TYPE_USES_VIRTUAL_BASECLASSES (lhstype) 	  || (modifycode == NOP_EXPR&& TYPE_GETS_ASSIGNMENT (lhstype)) 	  || (modifycode == INIT_EXPR&& TYPE_GETS_INIT_REF (lhstype))) 	{ 	  tree binfos = BINFO_BASETYPES (TYPE_BINFO (lhstype)); 	  result = NULL_TREE;  	  if (binfos != NULL_TREE)
comment|/* Perform operation on each member, depth-first, left-right.  */
end_comment

begin_comment
unit|for (i = 0; i<= TREE_VEC_LENGTH (binfos)-1; i++) 	      { 		tree base_binfo = TREE_VEC_ELT (binfos, i); 		tree base_lhs, base_rhs; 		tree new_result;
comment|/* Assignments from virtual baseclasses handled elsewhere.  */
end_comment

begin_comment
unit|if (TREE_VIA_VIRTUAL (base_binfo)) 		  continue;  		base_lhs = get_base_ref (lhstype, i, lhs); 		base_rhs = get_base_ref (lhstype, i, newrhs);  		BINFO_INHERITANCE_CHAIN (base_binfo) = basetype_path; 		new_result 		  = build_modify_expr_1 (base_lhs, modifycode, base_rhs, 					 base_binfo);
comment|/* We either get back a compound stmt, or a simple one.  */
end_comment

begin_comment
unit|if (new_result&& TREE_CODE (new_result) == TREE_LIST) 		  new_result = build_compound_expr (new_result); 		result = tree_cons (NULL_TREE, new_result, result); 	      }  	  for (elt = TYPE_FIELDS (lhstype); elt; elt = TREE_CHAIN (elt)) 	    { 	      tree vbases = NULL_TREE; 	      tree elt_lhs, elt_rhs;  	      if (TREE_CODE (elt) != FIELD_DECL) 		continue; 	      if (DECL_NAME (elt)&& (VFIELD_NAME_P (DECL_NAME (elt)) 		      || VBASE_NAME_P (DECL_NAME (elt)))) 		continue;  	      if (TREE_READONLY (elt) 		  || TREE_CODE (TREE_TYPE (elt)) == REFERENCE_TYPE) 		{ 		  cp_error ("cannot generate default `%T::operator ='", 			    lhstype); 		  if (TREE_CODE (TREE_TYPE (elt)) == REFERENCE_TYPE) 		    cp_error_at ("because member `%#D' is a reference", elt); 		  else 		    cp_error_at ("because member `%#D' is const", elt);  		  return error_mark_node; 		}  	      if (IS_AGGR_TYPE (TREE_TYPE (elt))&& TYPE_LANG_SPECIFIC (TREE_TYPE (elt))) 		vbases = CLASSTYPE_VBASECLASSES (TREE_TYPE (elt));  	      elt_lhs = build (COMPONENT_REF, TREE_TYPE (elt), lhs, elt); 	      elt_rhs = build (COMPONENT_REF, TREE_TYPE (elt), newrhs, elt);
comment|/* It is not always safe to go through `build_modify_expr_1' 		 when performing element-wise copying.  This is because 		 an element may be of ARRAY_TYPE, which will not 		 be properly copied as a naked element.  */
end_comment

begin_comment
unit|if (TREE_CODE (TREE_TYPE (elt)) == RECORD_TYPE&& TYPE_LANG_SPECIFIC (TREE_TYPE (elt))) 		basetype_path = TYPE_BINFO (TREE_TYPE (elt));  	      while (vbases) 		{ 		  tree elt_lhs_addr = build_unary_op (ADDR_EXPR, elt_lhs, 0); 		  tree elt_rhs_addr = build_unary_op (ADDR_EXPR, elt_rhs, 0);  		  elt_lhs_addr = convert_pointer_to (vbases, elt_lhs_addr); 		  elt_rhs_addr = convert_pointer_to (vbases, elt_rhs_addr); 		  result 		    = tree_cons (NULL_TREE, 				 build_modify_expr_1 				 (build_indirect_ref (elt_lhs_addr, NULL_PTR), 				  modifycode, 				  build_indirect_ref (elt_rhs_addr, NULL_PTR), 				  basetype_path), 				 result); 		  if (TREE_VALUE (result) == error_mark_node) 		    return error_mark_node; 		  vbases = TREE_CHAIN (vbases); 		} 	      elt_lhs = build_modify_expr_1 (elt_lhs, modifycode, elt_rhs, 					     basetype_path); 	      result = tree_cons (NULL_TREE, elt_lhs, result); 	    }  	  if (result) 	    return build_compound_expr (result);
comment|/* No fields to move.  */
end_comment

begin_comment
unit|return integer_zero_node; 	}       else 	{ 	  result = build (modifycode == NOP_EXPR ? MODIFY_EXPR : INIT_EXPR, 			  void_type_node, lhs, rhs); 	  TREE_SIDE_EFFECTS (result) = 1; 	  return result; 	}     }    result = build_modify_expr (lhs, modifycode, newrhs);
comment|/* ARRAY_TYPEs cannot be converted to anything meaningful,      and leaving it there screws up `build_compound_expr' when      it tries to defaultly convert everything.  */
end_comment

begin_endif
unit|if (TREE_CODE (TREE_TYPE (result)) == ARRAY_TYPE)     TREE_TYPE (result) = void_type_node;   return result; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Taken from expr.c:    Subroutine of expand_expr:    record the non-copied parts (LIST) of an expr (LHS), and return a list    which specifies the initial values of these parts.  */
end_comment

begin_function
specifier|static
name|tree
name|init_noncopied_parts
parameter_list|(
name|lhs
parameter_list|,
name|list
parameter_list|)
name|tree
name|lhs
decl_stmt|;
name|tree
name|list
decl_stmt|;
block|{
name|tree
name|tail
decl_stmt|;
name|tree
name|parts
init|=
literal|0
decl_stmt|;
for|for
control|(
name|tail
operator|=
name|list
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|parts
operator|=
name|chainon
argument_list|(
name|parts
argument_list|,
name|init_noncopied_parts
argument_list|(
name|lhs
argument_list|,
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|part
init|=
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
decl_stmt|;
name|tree
name|part_type
init|=
name|TREE_TYPE
argument_list|(
name|part
argument_list|)
decl_stmt|;
name|tree
name|to_be_initialized
init|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|part_type
argument_list|,
name|lhs
argument_list|,
name|part
argument_list|)
decl_stmt|;
name|parts
operator|=
name|tree_cons
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
argument_list|,
name|to_be_initialized
argument_list|,
name|parts
argument_list|)
expr_stmt|;
block|}
return|return
name|parts
return|;
block|}
end_function

begin_comment
comment|/* Build an assignment expression of lvalue LHS from value RHS.    MODIFYCODE is the code for a binary operator that we use    to combine the old value of LHS with RHS to get the new value.    Or else MODIFYCODE is NOP_EXPR meaning do a simple assignment.     C++: If MODIFYCODE is INIT_EXPR, then leave references unbashed. */
end_comment

begin_function
name|tree
name|build_modify_expr
parameter_list|(
name|lhs
parameter_list|,
name|modifycode
parameter_list|,
name|rhs
parameter_list|)
name|tree
name|lhs
decl_stmt|;
name|enum
name|tree_code
name|modifycode
decl_stmt|;
name|tree
name|rhs
decl_stmt|;
block|{
specifier|register
name|tree
name|result
decl_stmt|;
name|tree
name|newrhs
init|=
name|rhs
decl_stmt|;
name|tree
name|lhstype
init|=
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
decl_stmt|;
name|tree
name|olhstype
init|=
name|lhstype
decl_stmt|;
name|tree
name|olhs
init|=
name|lhs
decl_stmt|;
comment|/* Avoid duplicate error messages from operands that had errors.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|ERROR_MARK
operator|||
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
comment|/* Types that aren't fully specified cannot be used in assignments.  */
name|lhs
operator|=
name|require_complete_type
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
comment|/* Decide early if we are going to protect RHS from GC      before assigning it to LHS.  */
if|if
condition|(
name|type_needs_gc_entry
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|&&
operator|!
name|value_safe_from_gc
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|)
condition|)
name|rhs
operator|=
name|protect_value_from_gc
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
name|newrhs
operator|=
name|rhs
expr_stmt|;
comment|/* Handle assignment to signature pointers/refs.  */
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|lhstype
argument_list|)
operator|&&
operator|(
name|IS_SIGNATURE_POINTER
argument_list|(
name|lhstype
argument_list|)
operator|||
name|IS_SIGNATURE_REFERENCE
argument_list|(
name|lhstype
argument_list|)
operator|)
condition|)
block|{
return|return
name|build_signature_pointer_constructor
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|)
return|;
block|}
comment|/* Handle control structure constructs used as "lvalues".  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
condition|)
block|{
comment|/* Handle --foo = 5; as these are valid constructs in C++ */
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|PREINCREMENT_EXPR
case|:
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|lhs
operator|=
name|build
argument_list|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
argument_list|,
name|stabilize_reference
argument_list|(
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|lhstype
argument_list|,
name|lhs
argument_list|,
name|build_modify_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|modifycode
argument_list|,
name|rhs
argument_list|)
argument_list|)
return|;
comment|/* Handle (a, b) used as an "lvalue".  */
case|case
name|COMPOUND_EXPR
case|:
name|newrhs
operator|=
name|build_modify_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|,
name|modifycode
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newrhs
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|lhstype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|newrhs
argument_list|)
return|;
case|case
name|MODIFY_EXPR
case|:
name|newrhs
operator|=
name|build_modify_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|modifycode
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newrhs
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|lhstype
argument_list|,
name|lhs
argument_list|,
name|newrhs
argument_list|)
return|;
comment|/* Handle (a ? b : c) used as an "lvalue".  */
case|case
name|COND_EXPR
case|:
name|rhs
operator|=
name|save_expr
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
block|{
comment|/* Produce (a ? (b = rhs) : (c = rhs)) 	   except that the RHS goes through a save-expr 	   so the code to compute it is only emitted once.  */
name|tree
name|cond
init|=
name|build_conditional_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|build_modify_expr
argument_list|(
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|modifycode
argument_list|,
name|rhs
argument_list|)
argument_list|,
name|build_modify_expr
argument_list|(
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|2
argument_list|)
argument_list|)
argument_list|,
name|modifycode
argument_list|,
name|rhs
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|cond
return|;
comment|/* Make sure the code to compute the rhs comes out 	   before the split.  */
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
argument_list|,
comment|/* Case to void to suppress warning 			 from warn_if_unused_value.  */
name|convert
argument_list|(
name|void_type_node
argument_list|,
name|rhs
argument_list|)
argument_list|,
name|cond
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|OFFSET_REF
condition|)
block|{
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* Static class member?  */
name|tree
name|member
init|=
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|member
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|lhs
operator|=
name|member
expr_stmt|;
else|else
block|{
name|compiler_error
argument_list|(
literal|"invalid static class member"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
else|else
name|lhs
operator|=
name|resolve_offset_ref
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
name|olhstype
operator|=
name|lhstype
operator|=
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|&&
name|modifycode
operator|!=
name|INIT_EXPR
condition|)
block|{
name|lhs
operator|=
name|convert_from_reference
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
name|olhstype
operator|=
name|lhstype
operator|=
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
block|}
comment|/* If a binary op has been requested, combine the old LHS value with the RHS      producing the value we should actually store into the LHS.  */
if|if
condition|(
name|modifycode
operator|==
name|INIT_EXPR
condition|)
block|{
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|lhstype
argument_list|)
operator|&&
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|lhstype
argument_list|)
condition|)
block|{
name|result
operator|=
name|build_method_call
argument_list|(
name|lhs
argument_list|,
name|constructor_name_full
argument_list|(
name|lhstype
argument_list|)
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|rhs
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL_TREE
condition|)
return|return
name|error_mark_node
return|;
return|return
name|result
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|modifycode
operator|==
name|NOP_EXPR
condition|)
block|{
if|#
directive|if
literal|1
comment|/* `operator=' is not an inheritable operator.  */
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|lhstype
argument_list|)
operator|&&
name|TYPE_HAS_ASSIGNMENT
argument_list|(
name|lhstype
argument_list|)
condition|)
block|{
name|result
operator|=
name|build_opfncall
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|lhs
argument_list|,
name|rhs
argument_list|,
name|make_node
argument_list|(
name|NOP_EXPR
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL_TREE
condition|)
return|return
name|error_mark_node
return|;
return|return
name|result
return|;
block|}
else|#
directive|else
comment|/* Treat `operator=' as an inheritable operator.  */
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|lhstype
argument_list|)
operator|&&
name|TYPE_GETS_ASSIGNMENT
argument_list|(
name|lhstype
argument_list|)
condition|)
block|{
name|tree
name|orig_lhstype
init|=
name|lhstype
decl_stmt|;
while|while
condition|(
operator|!
name|TYPE_HAS_ASSIGNMENT
argument_list|(
name|lhstype
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|,
name|n_baseclasses
init|=
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|lhstype
argument_list|)
decl_stmt|;
name|tree
name|basetype
init|=
name|NULL_TREE
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baseclasses
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TYPE_GETS_ASSIGNMENT
argument_list|(
name|TYPE_BINFO_BASETYPE
argument_list|(
name|lhstype
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|basetype
operator|!=
name|NULL_TREE
condition|)
block|{
name|message_2_types
argument_list|(
name|error
argument_list|,
literal|"base classes `%s' and `%s' both have operator ='"
argument_list|,
name|basetype
argument_list|,
name|TYPE_BINFO_BASETYPE
argument_list|(
name|lhstype
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|basetype
operator|=
name|TYPE_BINFO_BASETYPE
argument_list|(
name|lhstype
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|lhstype
operator|=
name|basetype
expr_stmt|;
block|}
if|if
condition|(
name|orig_lhstype
operator|!=
name|lhstype
condition|)
block|{
name|lhs
operator|=
name|build_indirect_ref
argument_list|(
name|convert_pointer_to
argument_list|(
name|lhstype
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|lhs
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|lhs
operator|==
name|error_mark_node
condition|)
block|{
name|cp_error
argument_list|(
literal|"conversion to private basetype `%T'"
argument_list|,
name|lhstype
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
name|result
operator|=
name|build_opfncall
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|lhs
argument_list|,
name|rhs
argument_list|,
name|make_node
argument_list|(
name|NOP_EXPR
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL_TREE
condition|)
return|return
name|error_mark_node
return|;
return|return
name|result
return|;
block|}
endif|#
directive|endif
name|lhstype
operator|=
name|olhstype
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|PROMOTES_TO_AGGR_TYPE
argument_list|(
name|lhstype
argument_list|,
name|REFERENCE_TYPE
argument_list|)
condition|)
block|{
comment|/* This case must convert to some sort of lvalue that 	 can participate in an op= operation.  */
name|tree
name|lhs_tmp
init|=
name|lhs
decl_stmt|;
name|tree
name|rhs_tmp
init|=
name|rhs
decl_stmt|;
if|if
condition|(
name|build_default_binary_type_conversion
argument_list|(
name|modifycode
argument_list|,
operator|&
name|lhs_tmp
argument_list|,
operator|&
name|rhs_tmp
argument_list|)
condition|)
block|{
name|lhs
operator|=
name|stabilize_reference
argument_list|(
name|lhs_tmp
argument_list|)
expr_stmt|;
comment|/* Forget is was ever anything else.  */
name|olhstype
operator|=
name|lhstype
operator|=
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
name|newrhs
operator|=
name|build_binary_op
argument_list|(
name|modifycode
argument_list|,
name|lhs
argument_list|,
name|rhs_tmp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
return|return
name|error_mark_node
return|;
block|}
else|else
block|{
name|lhs
operator|=
name|stabilize_reference
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
name|newrhs
operator|=
name|build_binary_op
argument_list|(
name|modifycode
argument_list|,
name|lhs
argument_list|,
name|rhs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Handle a cast used as an "lvalue".      We have already performed any binary operator using the value as cast.      Now convert the result to the cast type of the lhs,      and then true type of the lhs and store it there;      then convert result back to the cast type to be the value      of the assignment.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
condition|)
block|{
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|FLOAT_EXPR
case|:
case|case
name|FIX_TRUNC_EXPR
case|:
case|case
name|FIX_FLOOR_EXPR
case|:
case|case
name|FIX_ROUND_EXPR
case|:
case|case
name|FIX_CEIL_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|newrhs
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|newrhs
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|newrhs
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|newrhs
argument_list|)
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
name|newrhs
operator|=
name|default_conversion
argument_list|(
name|newrhs
argument_list|)
expr_stmt|;
block|{
name|tree
name|inner_lhs
init|=
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|result
decl_stmt|;
if|if
condition|(
operator|!
name|lvalue_p
argument_list|(
name|lhs
argument_list|)
operator|&&
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"cast to non-reference type used as lvalue"
argument_list|)
expr_stmt|;
name|result
operator|=
name|build_modify_expr
argument_list|(
name|inner_lhs
argument_list|,
name|NOP_EXPR
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|inner_lhs
argument_list|)
argument_list|,
name|convert
argument_list|(
name|lhstype
argument_list|,
name|newrhs
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|result
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|result
return|;
return|return
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
argument_list|,
name|result
argument_list|)
return|;
block|}
block|}
comment|/* Now we have handled acceptable kinds of LHS that are not truly lvalues.      Reject anything strange now.  */
if|if
condition|(
operator|!
name|lvalue_or_else
argument_list|(
name|lhs
argument_list|,
literal|"assignment"
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
name|GNU_xref_assign
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
comment|/* Warn about storing in something that is `const'.  */
comment|/* For C++, don't warn if this is initialization.  */
if|if
condition|(
name|modifycode
operator|!=
name|INIT_EXPR
comment|/* For assignment to `const' signature pointer/reference fields, 	 don't warn either, we already printed a better message before.  */
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
operator|(
name|IS_SIGNATURE_POINTER
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|||
name|IS_SIGNATURE_REFERENCE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|)
operator|&&
operator|(
name|TREE_READONLY
argument_list|(
name|lhs
argument_list|)
operator|||
name|TYPE_READONLY
argument_list|(
name|lhstype
argument_list|)
operator|||
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|UNION_TYPE
operator|)
operator|&&
name|C_TYPE_FIELDS_READONLY
argument_list|(
name|lhstype
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|&&
name|TYPE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|lhstype
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
name|readonly_error
argument_list|(
name|lhs
argument_list|,
literal|"assignment"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If storing into a structure or union member,      it has probably been given type `int'.      Compute the type that would go with      the actual amount of storage the member occupies.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|INTEGER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|REAL_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|)
condition|)
block|{
name|lhstype
operator|=
name|TREE_TYPE
argument_list|(
name|get_unwidened
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If storing in a field that is in actuality a short or narrower 	 than one, we must store in the field in its actual type.  */
if|if
condition|(
name|lhstype
operator|!=
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
condition|)
block|{
name|lhs
operator|=
name|copy_node
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
operator|=
name|lhstype
expr_stmt|;
block|}
block|}
comment|/* check to see if there is an assignment to `this' */
if|if
condition|(
name|lhs
operator|==
name|current_class_decl
condition|)
block|{
if|if
condition|(
name|flag_this_is_variable
operator|>
literal|0
operator|&&
name|DECL_NAME
argument_list|(
name|current_function_decl
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|current_class_name
operator|!=
name|DECL_NAME
argument_list|(
name|current_function_decl
argument_list|)
condition|)
name|warning
argument_list|(
literal|"assignment to `this' not in constructor or destructor"
argument_list|)
expr_stmt|;
name|current_function_just_assigned_this
operator|=
literal|1
expr_stmt|;
block|}
comment|/* The TREE_TYPE of RHS may be TYPE_UNKNOWN.  This can happen      when the type of RHS is not yet known, i.e. its type      is inherited from LHS.  */
name|rhs
operator|=
name|require_instantiated_type
argument_list|(
name|lhstype
argument_list|,
name|newrhs
argument_list|,
name|error_mark_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|rhs
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|newrhs
operator|=
name|rhs
expr_stmt|;
if|if
condition|(
name|modifycode
operator|!=
name|INIT_EXPR
condition|)
block|{
comment|/* Make modifycode now either a NOP_EXPR or an INIT_EXPR.  */
name|modifycode
operator|=
name|NOP_EXPR
expr_stmt|;
comment|/* Reference-bashing */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|tree
name|tmp
init|=
name|convert_from_reference
argument_list|(
name|lhs
argument_list|)
decl_stmt|;
name|lhstype
operator|=
name|TREE_TYPE
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|lhstype
argument_list|)
operator|==
literal|0
condition|)
block|{
name|incomplete_type_error
argument_list|(
name|lhs
argument_list|,
name|lhstype
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|lhs
operator|=
name|tmp
expr_stmt|;
name|olhstype
operator|=
name|lhstype
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|newrhs
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|tree
name|tmp
init|=
name|convert_from_reference
argument_list|(
name|newrhs
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|tmp
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|incomplete_type_error
argument_list|(
name|newrhs
argument_list|,
name|TREE_TYPE
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|newrhs
operator|=
name|tmp
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|lhs
argument_list|)
condition|)
name|lhs
operator|=
name|stabilize_reference
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|newrhs
argument_list|)
condition|)
name|newrhs
operator|=
name|stabilize_reference
argument_list|(
name|newrhs
argument_list|)
expr_stmt|;
comment|/* C++: The semantics of C++ differ from those of C when an      assignment of an aggregate is desired.  Assignment in C++ is      now defined as memberwise assignment of non-static members      and base class objects.  This rule applies recursively      until a member of a built-in type is found.       Also, we cannot do a bit-wise copy of aggregates which      contain virtual function table pointers.  Those      pointer values must be preserved through the copy.      However, this is handled in expand_expr, and not here.      This is because much better code can be generated at      that stage than this one.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
operator|!
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|lhstype
argument_list|)
operator|&&
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|lhstype
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|newrhs
argument_list|)
argument_list|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|newrhs
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|UNIQUELY_DERIVED_FROM_P
argument_list|(
name|lhstype
argument_list|,
name|TREE_TYPE
argument_list|(
name|newrhs
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
block|{
comment|/* This was decided in finish_struct.  */
if|if
condition|(
name|modifycode
operator|==
name|INIT_EXPR
condition|)
name|cp_error
argument_list|(
literal|"can't generate default copy constructor for `%T'"
argument_list|,
name|lhstype
argument_list|)
expr_stmt|;
else|else
name|cp_error
argument_list|(
literal|"can't generate default assignment operator for `%T'"
argument_list|,
name|lhstype
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* This is now done by generating X(X&) and operator=(X&). */
block|tree vbases = CLASSTYPE_VBASECLASSES (lhstype);       tree lhs_addr = build_unary_op (ADDR_EXPR, lhs, 0);       tree rhs_addr;
comment|/* Memberwise assignment would cause NEWRHS to be 	 evaluated for every member that gets assigned. 	 By wrapping side-effecting exprs in a SAVE_EXPR, 	 NEWRHS will only be evaluated once.  */
block|if (IS_AGGR_TYPE (TREE_TYPE (newrhs))&& TREE_SIDE_EFFECTS (newrhs)
comment|/* This are things we don't have to save.  */
block|&& TREE_CODE (newrhs) != COND_EXPR&& TREE_CODE (newrhs) != TARGET_EXPR&& TREE_CODE (newrhs) != WITH_CLEANUP_EXPR)
comment|/* Call `break_out_cleanups' on NEWRHS in case there are cleanups. 	   If NEWRHS is a CALL_EXPR that needs a cleanup, failure to do so 	   will result in expand_expr expanding the call without knowing 	   that it should run the cleanup.  */
block|newrhs = save_expr (break_out_cleanups (newrhs)); 	         if (TREE_CODE (newrhs) == COND_EXPR) 	rhs_addr = rationalize_conditional_expr (ADDR_EXPR, newrhs);       else 	rhs_addr = build_unary_op (ADDR_EXPR, newrhs, 0);        result = tree_cons (NULL_TREE, 			  convert (build_reference_type (lhstype), lhs), 			  NULL_TREE);        if (! comptypes (TREE_TYPE (lhs_addr), TREE_TYPE (rhs_addr), 1)) 	rhs_addr = convert_pointer_to (TREE_TYPE (TREE_TYPE (lhs_addr)), rhs_addr);       { 	tree noncopied_parts = NULL_TREE;  	if (TYPE_NONCOPIED_PARTS (lhstype) != 0) 	  noncopied_parts = init_noncopied_parts (lhs, 						  TYPE_NONCOPIED_PARTS (lhstype)); 	while (noncopied_parts != 0) 	  { 	    result = tree_cons (NULL_TREE, 				build_modify_expr (convert (ptr_type_node, TREE_VALUE (noncopied_parts)), 						   NOP_EXPR, 						   TREE_PURPOSE (noncopied_parts)), 				result); 	    noncopied_parts = TREE_CHAIN (noncopied_parts); 	  }       }
comment|/* Once we have our hands on an address, we must change NEWRHS 	 to work from there.  Otherwise we can get multiple evaluations 	 of NEWRHS.  */
block|if (TREE_CODE (newrhs) != SAVE_EXPR) 	newrhs = build_indirect_ref (rhs_addr, NULL_PTR);        while (vbases) 	{ 	  tree elt_lhs = convert_pointer_to (vbases, lhs_addr); 	  tree elt_rhs = convert_pointer_to (vbases, rhs_addr); 	  result 	    = tree_cons (NULL_TREE, 			 build_modify_expr_1 (build_indirect_ref (elt_lhs, NULL_PTR), 					      modifycode, 					      build_indirect_ref (elt_rhs, NULL_PTR), 					      TYPE_BINFO (lhstype)), 			 result); 	  if (TREE_VALUE (result) == error_mark_node) 	    return error_mark_node; 	  vbases = TREE_CHAIN (vbases); 	}       result = tree_cons (NULL_TREE, 			  build_modify_expr_1 (lhs, 					       modifycode, 					       newrhs, 					       TYPE_BINFO (lhstype)), 			  result);       return build_compound_expr (result);
endif|#
directive|endif
block|}
comment|/* Convert new value to destination type.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|int
name|from_array
decl_stmt|;
comment|/* Allow array assignment in compiler-generated code.  */
if|if
condition|(
operator|(
name|pedantic
operator|||
name|flag_ansi
operator|)
operator|&&
operator|!
name|DECL_ARTIFICIAL
argument_list|(
name|current_function_decl
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C++ forbids assignment of arrays"
argument_list|)
expr_stmt|;
comment|/* Have to wrap this in RTL_EXPR for two cases: 	 in base or member initialization and if we 	 are a branch of a ?: operator.  Since we 	 can't easily know the latter, just do it always.  */
name|result
operator|=
name|make_node
argument_list|(
name|RTL_EXPR
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
operator|=
name|void_type_node
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|start_sequence_for_rtl_expr
argument_list|(
name|result
argument_list|)
expr_stmt|;
comment|/* As a matter of principle, `start_sequence' should do this.  */
name|emit_note
argument_list|(
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|from_array
operator|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|newrhs
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|?
literal|1
operator|+
operator|(
name|modifycode
operator|!=
name|INIT_EXPR
operator|)
else|:
literal|0
expr_stmt|;
name|expand_vec_init
argument_list|(
name|lhs
argument_list|,
name|lhs
argument_list|,
name|array_type_nelts
argument_list|(
name|lhstype
argument_list|)
argument_list|,
name|newrhs
argument_list|,
name|from_array
argument_list|)
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
name|RTL_EXPR_SEQUENCE
argument_list|(
name|result
argument_list|)
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|RTL_EXPR_RTL
argument_list|(
name|result
argument_list|)
operator|=
name|const0_rtx
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
if|if
condition|(
name|modifycode
operator|==
name|INIT_EXPR
condition|)
block|{
name|newrhs
operator|=
name|convert_for_initialization
argument_list|(
name|lhs
argument_list|,
name|lhstype
argument_list|,
name|newrhs
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
literal|"assignment"
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|lhs
operator|==
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|lhs
argument_list|)
condition|)
name|warning
argument_list|(
literal|"return value from function receives multiple initializations"
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|lhs
argument_list|)
operator|=
name|newrhs
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|lhstype
argument_list|)
condition|)
block|{
if|if
condition|(
name|result
operator|=
name|build_opfncall
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|lhs
argument_list|,
name|newrhs
argument_list|,
name|make_node
argument_list|(
name|NOP_EXPR
argument_list|)
argument_list|)
condition|)
return|return
name|result
return|;
block|}
comment|/* Avoid warnings on enum bit fields. */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olhstype
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|INTEGER_TYPE
condition|)
block|{
name|newrhs
operator|=
name|convert_for_assignment
argument_list|(
name|olhstype
argument_list|,
name|newrhs
argument_list|,
literal|"assignment"
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|newrhs
operator|=
name|convert_force
argument_list|(
name|lhstype
argument_list|,
name|newrhs
argument_list|)
expr_stmt|;
block|}
else|else
name|newrhs
operator|=
name|convert_for_assignment
argument_list|(
name|lhstype
argument_list|,
name|newrhs
argument_list|,
literal|"assignment"
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_elide_constructors
operator|==
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|newrhs
argument_list|)
operator|==
name|CALL_EXPR
operator|&&
name|TREE_ADDRESSABLE
argument_list|(
name|lhstype
argument_list|)
condition|)
block|{
comment|/* Can't initialized directly from a CALL_EXPR, since 	     we don't know about what doesn't alias what.  */
name|tree
name|temp
init|=
name|get_temp_name
argument_list|(
name|lhstype
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|newrhs
operator|=
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|lhstype
argument_list|,
name|build_modify_expr
argument_list|(
name|temp
argument_list|,
name|INIT_EXPR
argument_list|,
name|newrhs
argument_list|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newrhs
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newrhs
argument_list|)
operator|==
name|COND_EXPR
condition|)
block|{
name|tree
name|lhs1
decl_stmt|;
name|tree
name|cond
init|=
name|TREE_OPERAND
argument_list|(
name|newrhs
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|lhs
argument_list|)
condition|)
name|cond
operator|=
name|build_compound_expr
argument_list|(
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|lhs
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|cond
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Cannot have two identical lhs on this one tree (result) as preexpand 	 calls will rip them out and fill in RTL for them, but when the 	 rtl is generated, the calls will only be in the first side of the 	 condition, not on both, or before the conditional jump! (mrs) */
name|lhs1
operator|=
name|break_out_calls
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|lhs
operator|==
name|lhs1
condition|)
comment|/* If there's no change, the COND_EXPR behaves like any other rhs.  */
name|result
operator|=
name|build
argument_list|(
name|modifycode
operator|==
name|NOP_EXPR
condition|?
name|MODIFY_EXPR
else|:
name|INIT_EXPR
argument_list|,
name|lhstype
argument_list|,
name|lhs
argument_list|,
name|newrhs
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|result_type
init|=
name|TREE_TYPE
argument_list|(
name|newrhs
argument_list|)
decl_stmt|;
comment|/* We have to convert each arm to the proper type because the 	     types may have been munged by constant folding.  */
name|result
operator|=
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|result_type
argument_list|,
name|cond
argument_list|,
name|build_modify_expr
argument_list|(
name|lhs
argument_list|,
name|modifycode
argument_list|,
name|convert
argument_list|(
name|result_type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|newrhs
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|build_modify_expr
argument_list|(
name|lhs1
argument_list|,
name|modifycode
argument_list|,
name|convert
argument_list|(
name|result_type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|newrhs
argument_list|,
literal|2
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|modifycode
operator|!=
name|INIT_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|newrhs
argument_list|)
operator|==
name|WITH_CLEANUP_EXPR
condition|)
block|{
name|tree
name|cleanup
init|=
name|TREE_OPERAND
argument_list|(
name|newrhs
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|tree
name|slot
decl_stmt|;
comment|/* Finish up by running cleanups and having the "value" of the lhs.  */
name|tree
name|exprlist
init|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|cleanup
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|lhs
argument_list|)
argument_list|)
decl_stmt|;
name|newrhs
operator|=
name|TREE_OPERAND
argument_list|(
name|newrhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newrhs
argument_list|)
operator|==
name|TARGET_EXPR
condition|)
name|slot
operator|=
name|TREE_OPERAND
argument_list|(
name|newrhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newrhs
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
block|{
comment|/* Bad but legal.  */
name|slot
operator|=
name|newrhs
expr_stmt|;
name|warning
argument_list|(
literal|"address taken of temporary object"
argument_list|)
expr_stmt|;
block|}
else|else
name|my_friendly_abort
argument_list|(
literal|118
argument_list|)
expr_stmt|;
comment|/* Copy the value computed in SLOT into LHS.  */
name|exprlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_modify_expr
argument_list|(
name|lhs
argument_list|,
name|modifycode
argument_list|,
name|slot
argument_list|)
argument_list|,
name|exprlist
argument_list|)
expr_stmt|;
comment|/* Evaluate the expression that needs CLEANUP.  This will 	 compute the value into SLOT.  */
name|exprlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|newrhs
argument_list|,
name|exprlist
argument_list|)
expr_stmt|;
name|result
operator|=
name|convert
argument_list|(
name|lhstype
argument_list|,
name|build_compound_expr
argument_list|(
name|exprlist
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|result
operator|=
name|build
argument_list|(
name|modifycode
operator|==
name|NOP_EXPR
condition|?
name|MODIFY_EXPR
else|:
name|INIT_EXPR
argument_list|,
name|lhstype
argument_list|,
name|lhs
argument_list|,
name|newrhs
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* If we got the LHS in a different type for storing in,      convert the result back to the nominal type of LHS      so that the value we return always has the same type      as the LHS argument.  */
if|if
condition|(
name|olhstype
operator|==
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
condition|)
return|return
name|result
return|;
comment|/* Avoid warnings converting integral types back into enums      for enum bit fields. */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|olhstype
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
block|{
name|result
operator|=
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|olhstype
argument_list|,
name|result
argument_list|,
name|olhs
argument_list|)
expr_stmt|;
name|TREE_NO_UNUSED_WARNING
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|result
return|;
block|}
return|return
name|convert_for_assignment
argument_list|(
name|olhstype
argument_list|,
name|result
argument_list|,
literal|"assignment"
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 0 if EXP is not a valid lvalue in this language    even though `lvalue_or_else' would accept it.  */
end_comment

begin_function
name|int
name|language_lvalue_valid
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Get differnce in deltas for different pointer to member function    types.  Return inetger_zero_node, if FROM cannot be converted to a    TO type.  If FORCE is true, then allow reverse conversions as well.  */
end_comment

begin_function
specifier|static
name|tree
name|get_delta_difference
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|,
name|force
parameter_list|)
name|tree
name|from
decl_stmt|,
name|to
decl_stmt|;
name|int
name|force
decl_stmt|;
block|{
name|tree
name|delta
init|=
name|integer_zero_node
decl_stmt|;
name|tree
name|binfo
decl_stmt|;
if|if
condition|(
name|to
operator|==
name|from
condition|)
return|return
name|delta
return|;
comment|/* Should get_base_distance here, so we can check if any thing along the      path is virtual, and we need to make sure we stay      inside the real binfos when going through virtual bases.      Maybe we should replace virtual bases with      binfo_member (...CLASSTYPE_VBASECLASSES...)...  (mrs) */
name|binfo
operator|=
name|get_binfo
argument_list|(
name|from
argument_list|,
name|to
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|binfo
operator|==
name|error_mark_node
condition|)
block|{
name|error
argument_list|(
literal|"   in pointer to member function conversion"
argument_list|)
expr_stmt|;
return|return
name|delta
return|;
block|}
if|if
condition|(
name|binfo
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|force
condition|)
block|{
name|error_not_base_type
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"   in pointer to member function conversion"
argument_list|)
expr_stmt|;
return|return
name|delta
return|;
block|}
name|binfo
operator|=
name|get_binfo
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|binfo
operator|==
name|error_mark_node
condition|)
block|{
name|error
argument_list|(
literal|"   in pointer to member function conversion"
argument_list|)
expr_stmt|;
return|return
name|delta
return|;
block|}
if|if
condition|(
name|binfo
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"cannot convert pointer to member of type %T to unrelated pointer to member of type %T"
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
return|return
name|delta
return|;
block|}
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"pointer to member conversion to virtual base class will only work if your very careful"
argument_list|)
expr_stmt|;
block|}
return|return
name|fold
argument_list|(
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|integer_zero_node
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"pointer to member conversion from virtual base class will only work if your very careful"
argument_list|)
expr_stmt|;
block|}
return|return
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Build a constructor for a pointer to member function.  It can be    used to initialize global variables, local variable, or used    as a value in expressions.  TYPE is the POINTER to METHOD_TYPE we    want to be.     If FORCE is non-zero, then force this conversion, even if    we would rather not do it.  Usually set when using an explicit    cast.     Return error_mark_node, if something goes wrong.  */
end_comment

begin_function
name|tree
name|build_ptrmemfunc
parameter_list|(
name|type
parameter_list|,
name|pfn
parameter_list|,
name|force
parameter_list|)
name|tree
name|type
decl_stmt|,
name|pfn
decl_stmt|;
name|int
name|force
decl_stmt|;
block|{
name|tree
name|index
init|=
name|integer_zero_node
decl_stmt|;
name|tree
name|delta
init|=
name|integer_zero_node
decl_stmt|;
name|tree
name|delta2
init|=
name|integer_zero_node
decl_stmt|;
name|tree
name|vfield_offset
decl_stmt|;
name|tree
name|npfn
decl_stmt|;
name|tree
name|u
decl_stmt|;
comment|/* Handle multiple conversions of pointer to member fucntions. */
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|pfn
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|ndelta
decl_stmt|,
name|ndelta2
decl_stmt|,
name|nindex
decl_stmt|;
comment|/* Is is already the right type? */
if|#
directive|if
literal|0
comment|/* Sorry, can't do this, the backend is too stupid. */
block|if (TYPE_METHOD_BASETYPE (TREE_TYPE (type)) 	  == TYPE_METHOD_BASETYPE (TREE_TYPE (TYPE_PTRMEMFUNC_FN_TYPE (TREE_TYPE (pfn))))) 	{ 	  if (type != TYPE_PTRMEMFUNC_FN_TYPE (TREE_TYPE (pfn))) 	    { 	      npfn = build1 (NOP_EXPR, TYPE_GET_PTRMEMFUNC_TYPE (type), pfn); 	      TREE_CONSTANT (npfn) = TREE_CONSTANT (pfn); 	    } 	  return pfn; 	}
else|#
directive|else
if|if
condition|(
name|type
operator|==
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|pfn
argument_list|)
argument_list|)
condition|)
return|return
name|pfn
return|;
endif|#
directive|endif
if|if
condition|(
name|TREE_CODE
argument_list|(
name|pfn
argument_list|)
operator|!=
name|CONSTRUCTOR
condition|)
block|{
name|tree
name|e1
decl_stmt|,
name|e2
decl_stmt|,
name|e3
decl_stmt|;
name|ndelta
operator|=
name|convert
argument_list|(
name|sizetype
argument_list|,
name|build_component_ref
argument_list|(
name|pfn
argument_list|,
name|delta_identifier
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|ndelta2
operator|=
name|convert
argument_list|(
name|sizetype
argument_list|,
name|DELTA2_FROM_PTRMEMFUNC
argument_list|(
name|pfn
argument_list|)
argument_list|)
expr_stmt|;
name|index
operator|=
name|build_component_ref
argument_list|(
name|pfn
argument_list|,
name|index_identifier
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|delta
operator|=
name|get_delta_difference
argument_list|(
name|TYPE_METHOD_BASETYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|pfn
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|TYPE_METHOD_BASETYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|force
argument_list|)
expr_stmt|;
name|delta
operator|=
name|fold
argument_list|(
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|delta
argument_list|,
name|ndelta
argument_list|)
argument_list|)
expr_stmt|;
name|delta2
operator|=
name|fold
argument_list|(
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|ndelta2
argument_list|,
name|delta2
argument_list|)
argument_list|)
expr_stmt|;
name|e1
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|GT_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|index
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
expr_stmt|;
name|u
operator|=
name|build_nt
argument_list|(
name|CONSTRUCTOR
argument_list|,
literal|0
argument_list|,
name|tree_cons
argument_list|(
name|delta2_identifier
argument_list|,
name|delta2
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
name|u
operator|=
name|build_nt
argument_list|(
name|CONSTRUCTOR
argument_list|,
literal|0
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|delta
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|index
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|u
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|e2
operator|=
name|digest_init
argument_list|(
name|TYPE_GET_PTRMEMFUNC_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|u
argument_list|,
operator|(
name|tree
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|pfn
operator|=
name|PFN_FROM_PTRMEMFUNC
argument_list|(
name|pfn
argument_list|)
expr_stmt|;
name|npfn
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|pfn
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|npfn
argument_list|)
operator|=
name|TREE_CONSTANT
argument_list|(
name|pfn
argument_list|)
expr_stmt|;
name|u
operator|=
name|build_nt
argument_list|(
name|CONSTRUCTOR
argument_list|,
literal|0
argument_list|,
name|tree_cons
argument_list|(
name|pfn_identifier
argument_list|,
name|npfn
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
name|u
operator|=
name|build_nt
argument_list|(
name|CONSTRUCTOR
argument_list|,
literal|0
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|delta
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|index
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|u
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|e3
operator|=
name|digest_init
argument_list|(
name|TYPE_GET_PTRMEMFUNC_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|u
argument_list|,
operator|(
name|tree
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|build_conditional_expr
argument_list|(
name|e1
argument_list|,
name|e2
argument_list|,
name|e3
argument_list|)
return|;
block|}
name|ndelta
operator|=
name|TREE_VALUE
argument_list|(
name|CONSTRUCTOR_ELTS
argument_list|(
name|pfn
argument_list|)
argument_list|)
expr_stmt|;
name|nindex
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|CONSTRUCTOR_ELTS
argument_list|(
name|pfn
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|npfn
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|CONSTRUCTOR_ELTS
argument_list|(
name|pfn
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|npfn
operator|=
name|TREE_VALUE
argument_list|(
name|CONSTRUCTOR_ELTS
argument_list|(
name|npfn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|integer_zerop
argument_list|(
name|nindex
argument_list|)
condition|)
name|pfn
operator|=
name|integer_zero_node
expr_stmt|;
else|else
block|{
name|sorry
argument_list|(
literal|"value casting of varible nonnull pointer to member functions not supported"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
comment|/* Handle null pointer to member function conversions. */
if|if
condition|(
name|integer_zerop
argument_list|(
name|pfn
argument_list|)
condition|)
block|{
name|pfn
operator|=
name|build_c_cast
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
name|u
operator|=
name|build_nt
argument_list|(
name|CONSTRUCTOR
argument_list|,
literal|0
argument_list|,
name|tree_cons
argument_list|(
name|pfn_identifier
argument_list|,
name|pfn
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
name|u
operator|=
name|build_nt
argument_list|(
name|CONSTRUCTOR
argument_list|,
literal|0
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_zero_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_zero_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|u
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|digest_init
argument_list|(
name|TYPE_GET_PTRMEMFUNC_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|u
argument_list|,
operator|(
name|tree
operator|*
operator|)
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|pfn
argument_list|)
operator|==
name|TREE_LIST
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|pfn
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|pfn
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|TREE_LIST
operator|)
condition|)
block|{
name|pfn
operator|=
name|instantiate_type
argument_list|(
name|type
argument_list|,
name|pfn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfn
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|pfn
argument_list|)
operator|!=
name|ADDR_EXPR
condition|)
name|pfn
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|pfn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Allow pointer to member conversions here. */
name|delta
operator|=
name|get_delta_difference
argument_list|(
name|TYPE_METHOD_BASETYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|pfn
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|TYPE_METHOD_BASETYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|force
argument_list|)
expr_stmt|;
name|delta2
operator|=
name|fold
argument_list|(
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|delta2
argument_list|,
name|delta
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|pfn
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
name|warning
argument_list|(
literal|"assuming pointer to member function is non-virtual"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|pfn
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_VINDEX
argument_list|(
name|TREE_OPERAND
argument_list|(
name|pfn
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Find the offset to the vfield pointer in the object. */
name|vfield_offset
operator|=
name|get_binfo
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|TREE_OPERAND
argument_list|(
name|pfn
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|DECL_CLASS_CONTEXT
argument_list|(
name|TREE_OPERAND
argument_list|(
name|pfn
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vfield_offset
operator|=
name|get_vfield_offset
argument_list|(
name|vfield_offset
argument_list|)
expr_stmt|;
name|delta2
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|vfield_offset
argument_list|,
name|delta2
argument_list|)
expr_stmt|;
comment|/* Map everything down one to make room for the null pointer to member.  */
name|index
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|DECL_VINDEX
argument_list|(
name|TREE_OPERAND
argument_list|(
name|pfn
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|integer_one_node
argument_list|)
expr_stmt|;
name|u
operator|=
name|build_nt
argument_list|(
name|CONSTRUCTOR
argument_list|,
literal|0
argument_list|,
name|tree_cons
argument_list|(
name|delta2_identifier
argument_list|,
name|delta2
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|index
operator|=
name|fold
argument_list|(
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|integer_zero_node
argument_list|,
name|integer_one_node
argument_list|)
argument_list|)
expr_stmt|;
name|npfn
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|pfn
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|npfn
argument_list|)
operator|=
name|TREE_CONSTANT
argument_list|(
name|pfn
argument_list|)
expr_stmt|;
name|u
operator|=
name|build_nt
argument_list|(
name|CONSTRUCTOR
argument_list|,
literal|0
argument_list|,
name|tree_cons
argument_list|(
name|pfn_identifier
argument_list|,
name|npfn
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|u
operator|=
name|build_nt
argument_list|(
name|CONSTRUCTOR
argument_list|,
literal|0
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|delta
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|index
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|u
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|digest_init
argument_list|(
name|TYPE_GET_PTRMEMFUNC_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|u
argument_list|,
operator|(
name|tree
operator|*
operator|)
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Convert value RHS to type TYPE as preparation for an assignment    to an lvalue of type TYPE.    The real work of conversion is done by `convert'.    The purpose of this function is to generate error messages    for assignments that are not allowed in C.    ERRTYPE is a string to use in error messages:    "assignment", "return", etc.     C++: attempts to allow `convert' to find conversions involving    implicit type conversion between aggregate and scalar types    as per 8.5.6 of C++ manual.  Does not randomly dereference    pointers to aggregates!  */
end_comment

begin_function
specifier|static
name|tree
name|convert_for_assignment
parameter_list|(
name|type
parameter_list|,
name|rhs
parameter_list|,
name|errtype
parameter_list|,
name|fndecl
parameter_list|,
name|parmnum
parameter_list|)
name|tree
name|type
decl_stmt|,
name|rhs
decl_stmt|;
name|char
modifier|*
name|errtype
decl_stmt|;
name|tree
name|fndecl
decl_stmt|;
name|int
name|parmnum
decl_stmt|;
block|{
specifier|register
name|enum
name|tree_code
name|codel
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|rhstype
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|coder
init|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|coder
operator|==
name|UNKNOWN_TYPE
condition|)
name|rhs
operator|=
name|instantiate_type
argument_list|(
name|type
argument_list|,
name|rhs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|coder
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|codel
operator|==
name|OFFSET_TYPE
condition|)
block|{
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|codel
operator|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
comment|/* Strip NON_LVALUE_EXPRs since we aren't using as an lvalue.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|NON_LVALUE_EXPR
condition|)
name|rhs
operator|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rhs
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|rhs
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
block|{
name|rhs
operator|=
name|resolve_offset_ref
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|rhs
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|rhstype
operator|=
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
name|coder
operator|=
name|TREE_CODE
argument_list|(
name|rhstype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|rhs
operator|=
name|default_conversion
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|rhs
operator|=
name|convert_from_reference
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
name|rhstype
operator|=
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
name|coder
operator|=
name|TREE_CODE
argument_list|(
name|rhstype
argument_list|)
expr_stmt|;
comment|/* This should no longer change types on us.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|CONST_DECL
condition|)
name|rhs
operator|=
name|DECL_INITIAL
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_READONLY_DECL_P
argument_list|(
name|rhs
argument_list|)
condition|)
name|rhs
operator|=
name|decl_constant_value
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|rhstype
condition|)
block|{
name|overflow_warning
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
return|return
name|rhs
return|;
block|}
if|if
condition|(
name|coder
operator|==
name|VOID_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"void value not ignored as it ought to be"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Arithmetic types all interconvert.  */
if|if
condition|(
operator|(
name|codel
operator|==
name|INTEGER_TYPE
operator|||
name|codel
operator|==
name|REAL_TYPE
operator|||
name|codel
operator|==
name|BOOLEAN_TYPE
operator|)
operator|&&
operator|(
name|coder
operator|==
name|INTEGER_TYPE
operator|||
name|coder
operator|==
name|REAL_TYPE
operator|||
name|coder
operator|==
name|BOOLEAN_TYPE
operator|)
condition|)
block|{
comment|/* But we should warn if assigning REAL_TYPE to INTEGER_TYPE.  */
if|if
condition|(
name|coder
operator|==
name|REAL_TYPE
operator|&&
name|codel
operator|==
name|INTEGER_TYPE
condition|)
block|{
if|if
condition|(
name|fndecl
condition|)
name|cp_warning
argument_list|(
literal|"`%T' used for argument %P of `%D'"
argument_list|,
name|rhstype
argument_list|,
name|parmnum
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
else|else
name|cp_warning
argument_list|(
literal|"%s to `%T' from `%T'"
argument_list|,
name|errtype
argument_list|,
name|type
argument_list|,
name|rhstype
argument_list|)
expr_stmt|;
block|}
comment|/* And we should warn if assigning a negative value to 	 an unsigned variable.  */
elseif|else
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|&&
name|codel
operator|!=
name|BOOLEAN_TYPE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_NEGATED_INT
argument_list|(
name|rhs
argument_list|)
condition|)
block|{
if|if
condition|(
name|fndecl
condition|)
name|cp_warning
argument_list|(
literal|"negative value `%E' passed as argument %P of `%D'"
argument_list|,
name|rhs
argument_list|,
name|parmnum
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
else|else
name|cp_warning
argument_list|(
literal|"%s of negative value `%E' to `%T'"
argument_list|,
name|errtype
argument_list|,
name|rhs
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
name|overflow_warning
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|rhs
argument_list|)
condition|)
name|rhs
operator|=
name|fold
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
block|}
return|return
name|convert_and_check
argument_list|(
name|type
argument_list|,
name|rhs
argument_list|)
return|;
block|}
comment|/* Conversions involving enums.  */
elseif|else
if|if
condition|(
operator|(
name|codel
operator|==
name|ENUMERAL_TYPE
operator|&&
operator|(
name|coder
operator|==
name|ENUMERAL_TYPE
operator|||
name|coder
operator|==
name|INTEGER_TYPE
operator|||
name|coder
operator|==
name|REAL_TYPE
operator|)
operator|)
operator|||
operator|(
name|coder
operator|==
name|ENUMERAL_TYPE
operator|&&
operator|(
name|codel
operator|==
name|ENUMERAL_TYPE
operator|||
name|codel
operator|==
name|INTEGER_TYPE
operator|||
name|codel
operator|==
name|REAL_TYPE
operator|)
operator|)
condition|)
block|{
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|rhs
argument_list|)
return|;
block|}
comment|/* Conversions among pointers */
elseif|else
if|if
condition|(
name|codel
operator|==
name|POINTER_TYPE
operator|&&
operator|(
name|coder
operator|==
name|POINTER_TYPE
operator|||
operator|(
name|coder
operator|==
name|RECORD_TYPE
operator|&&
operator|(
name|IS_SIGNATURE_POINTER
argument_list|(
name|rhstype
argument_list|)
operator|||
name|IS_SIGNATURE_REFERENCE
argument_list|(
name|rhstype
argument_list|)
operator|)
operator|)
operator|)
condition|)
block|{
specifier|register
name|tree
name|ttl
init|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|ttr
decl_stmt|;
if|if
condition|(
name|coder
operator|==
name|RECORD_TYPE
condition|)
block|{
name|rhs
operator|=
name|build_optr_ref
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
name|rhstype
operator|=
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
block|}
name|ttr
operator|=
name|TREE_TYPE
argument_list|(
name|rhstype
argument_list|)
expr_stmt|;
comment|/* If both pointers are of aggregate type, then we 	 can give better error messages, and save some work 	 as well.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
block|{
name|tree
name|binfo
decl_stmt|;
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|ttl
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|ttr
argument_list|)
operator|||
name|type
operator|==
name|class_star_type_node
operator|||
name|rhstype
operator|==
name|class_star_type_node
condition|)
name|binfo
operator|=
name|TYPE_BINFO
argument_list|(
name|ttl
argument_list|)
expr_stmt|;
else|else
name|binfo
operator|=
name|get_binfo
argument_list|(
name|ttl
argument_list|,
name|ttr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|binfo
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|binfo
operator|==
literal|0
condition|)
return|return
name|error_not_base_type
argument_list|(
name|ttl
argument_list|,
name|ttr
argument_list|)
return|;
if|if
condition|(
operator|!
name|TYPE_READONLY
argument_list|(
name|ttl
argument_list|)
operator|&&
name|TYPE_READONLY
argument_list|(
name|ttr
argument_list|)
condition|)
block|{
if|if
condition|(
name|fndecl
condition|)
name|cp_pedwarn
argument_list|(
literal|"passing `%T' as argument %P of `%D' discards const"
argument_list|,
name|rhstype
argument_list|,
name|parmnum
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
else|else
name|cp_pedwarn
argument_list|(
literal|"%s to `%T' from `%T' discards const"
argument_list|,
name|errtype
argument_list|,
name|type
argument_list|,
name|rhstype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TYPE_VOLATILE
argument_list|(
name|ttl
argument_list|)
operator|&&
name|TYPE_VOLATILE
argument_list|(
name|ttr
argument_list|)
condition|)
block|{
if|if
condition|(
name|fndecl
condition|)
name|cp_pedwarn
argument_list|(
literal|"passing `%T' as argument %P of `%D' discards volatile"
argument_list|,
name|rhstype
argument_list|,
name|parmnum
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
else|else
name|cp_pedwarn
argument_list|(
literal|"%s to `%T' from `%T' discards volatile"
argument_list|,
name|errtype
argument_list|,
name|type
argument_list|,
name|rhstype
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Any non-function converts to a [const][volatile] void * 	 and vice versa; otherwise, targets must be the same. 	 Meanwhile, the lhs target must have all the qualifiers of the rhs.  */
elseif|else
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|ttl
argument_list|)
operator|==
name|void_type_node
operator|||
name|TYPE_MAIN_VARIANT
argument_list|(
name|ttr
argument_list|)
operator|==
name|void_type_node
operator|||
name|comp_target_types
argument_list|(
name|type
argument_list|,
name|rhstype
argument_list|,
literal|1
argument_list|)
operator|||
operator|(
name|unsigned_type
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|ttl
argument_list|)
argument_list|)
operator|==
name|unsigned_type
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|ttr
argument_list|)
argument_list|)
operator|)
condition|)
block|{
comment|/* ARM $4.8, commentary on p39.  */
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|ttl
argument_list|)
operator|==
name|void_type_node
operator|&&
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"no standard conversion from pointer to member to `void *'"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|ttl
argument_list|)
operator|!=
name|void_type_node
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|ttr
argument_list|)
operator|==
name|void_type_node
operator|&&
name|rhs
operator|!=
name|null_pointer_node
condition|)
block|{
if|if
condition|(
name|coder
operator|==
name|RECORD_TYPE
condition|)
name|pedwarn
argument_list|(
literal|"implicit conversion of signature pointer to type `%s'"
argument_list|,
name|type_as_string
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|pedwarn
argument_list|(
literal|"ANSI C++ forbids implicit conversion from `void *' in %s"
argument_list|,
name|errtype
argument_list|)
expr_stmt|;
block|}
comment|/* Const and volatile mean something different for function types, 	     so the usual warnings are not appropriate.  */
elseif|else
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|!=
name|FUNCTION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|!=
name|METHOD_TYPE
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|!=
name|FUNCTION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|!=
name|METHOD_TYPE
operator|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|==
name|OFFSET_TYPE
operator|&&
name|binfo_member
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|ttr
argument_list|)
argument_list|,
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|ttl
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|sorry
argument_list|(
literal|"%s between pointer to members converting across virtual baseclasses"
argument_list|,
name|errtype
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|TYPE_READONLY
argument_list|(
name|ttl
argument_list|)
operator|&&
name|TYPE_READONLY
argument_list|(
name|ttr
argument_list|)
condition|)
block|{
if|if
condition|(
name|fndecl
condition|)
name|cp_pedwarn
argument_list|(
literal|"passing `%T' as argument %P of `%D' discards const"
argument_list|,
name|rhstype
argument_list|,
name|parmnum
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
else|else
name|cp_pedwarn
argument_list|(
literal|"%s to `%T' from `%T' discards const"
argument_list|,
name|errtype
argument_list|,
name|type
argument_list|,
name|rhstype
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|TYPE_VOLATILE
argument_list|(
name|ttl
argument_list|)
operator|&&
name|TYPE_VOLATILE
argument_list|(
name|ttr
argument_list|)
condition|)
block|{
if|if
condition|(
name|fndecl
condition|)
name|cp_pedwarn
argument_list|(
literal|"passing `%T' as argument %P of `%D' discards volatile"
argument_list|,
name|rhstype
argument_list|,
name|parmnum
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
else|else
name|cp_pedwarn
argument_list|(
literal|"%s to `%T' from `%T' discards volatile"
argument_list|,
name|errtype
argument_list|,
name|type
argument_list|,
name|rhstype
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|==
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|&&
operator|!
name|comp_target_types
argument_list|(
name|type
argument_list|,
name|rhstype
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|fndecl
condition|)
name|cp_pedwarn
argument_list|(
literal|"passing `%T' as argument %P of `%D' changes signedness"
argument_list|,
name|rhstype
argument_list|,
name|parmnum
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
else|else
name|cp_pedwarn
argument_list|(
literal|"%s to `%T' from `%T' changes signedness"
argument_list|,
name|errtype
argument_list|,
name|type
argument_list|,
name|rhstype
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|==
name|OFFSET_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|!=
name|OFFSET_TYPE
condition|)
block|{
comment|/* Normally, pointers to different type codes (other 	     than void) are not compatible, but we perform 	     some type instantiation if that resolves the 	     ambiguity of (X Y::*) and (X *).  */
if|if
condition|(
name|current_class_decl
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|rhs
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|ttr
argument_list|)
argument_list|)
argument_list|,
name|current_class_decl
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
return|return
name|convert_for_assignment
argument_list|(
name|type
argument_list|,
name|rhs
argument_list|,
name|errtype
argument_list|,
name|fndecl
argument_list|,
name|parmnum
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|error
argument_list|(
literal|"%s between pointer-to-method and pointer-to-member types"
argument_list|,
name|errtype
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"%s between pointer and pointer-to-member types"
argument_list|,
name|errtype
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
else|else
block|{
name|int
name|add_quals
init|=
literal|0
decl_stmt|,
name|const_parity
init|=
literal|0
decl_stmt|,
name|volatile_parity
init|=
literal|0
decl_stmt|;
name|int
name|left_const
init|=
literal|1
decl_stmt|;
name|int
name|unsigned_parity
decl_stmt|;
name|int
name|nptrs
init|=
literal|0
decl_stmt|;
comment|/* This code is basically a duplicate of comp_ptr_ttypes_real.  */
for|for
control|(
init|;
condition|;
name|ttl
operator|=
name|TREE_TYPE
argument_list|(
name|ttl
argument_list|)
operator|,
name|ttr
operator|=
name|TREE_TYPE
argument_list|(
name|ttr
argument_list|)
control|)
block|{
name|nptrs
operator|-=
literal|1
expr_stmt|;
name|const_parity
operator||=
name|TYPE_READONLY
argument_list|(
name|ttl
argument_list|)
operator|<
name|TYPE_READONLY
argument_list|(
name|ttr
argument_list|)
expr_stmt|;
name|volatile_parity
operator||=
name|TYPE_VOLATILE
argument_list|(
name|ttl
argument_list|)
operator|<
name|TYPE_VOLATILE
argument_list|(
name|ttr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|left_const
operator|&&
operator|(
name|TYPE_READONLY
argument_list|(
name|ttl
argument_list|)
operator|>
name|TYPE_READONLY
argument_list|(
name|ttr
argument_list|)
operator|||
name|TYPE_VOLATILE
argument_list|(
name|ttl
argument_list|)
operator|>
name|TYPE_VOLATILE
argument_list|(
name|ttr
argument_list|)
operator|)
condition|)
name|add_quals
operator|=
literal|1
expr_stmt|;
name|left_const
operator|&=
name|TYPE_READONLY
argument_list|(
name|ttl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|!=
name|POINTER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
break|break;
block|}
name|unsigned_parity
operator|=
name|TREE_UNSIGNED
argument_list|(
name|ttl
argument_list|)
operator|-
name|TREE_UNSIGNED
argument_list|(
name|ttr
argument_list|)
expr_stmt|;
if|if
condition|(
name|unsigned_parity
condition|)
block|{
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|ttl
argument_list|)
condition|)
name|ttr
operator|=
name|unsigned_type
argument_list|(
name|ttr
argument_list|)
expr_stmt|;
else|else
name|ttl
operator|=
name|unsigned_type
argument_list|(
name|ttl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|comp_target_types
argument_list|(
name|ttl
argument_list|,
name|ttr
argument_list|,
name|nptrs
argument_list|)
condition|)
block|{
if|if
condition|(
name|add_quals
condition|)
block|{
if|if
condition|(
name|fndecl
condition|)
name|cp_pedwarn
argument_list|(
literal|"passing `%T' as argument %P of `%D' adds cv-quals without intervening `const'"
argument_list|,
name|rhstype
argument_list|,
name|parmnum
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
else|else
name|cp_pedwarn
argument_list|(
literal|"%s to `%T' from `%T' adds cv-quals without intervening `const'"
argument_list|,
name|errtype
argument_list|,
name|type
argument_list|,
name|rhstype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|const_parity
condition|)
block|{
if|if
condition|(
name|fndecl
condition|)
name|cp_pedwarn
argument_list|(
literal|"passing `%T' as argument %P of `%D' discards const"
argument_list|,
name|rhstype
argument_list|,
name|parmnum
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
else|else
name|cp_pedwarn
argument_list|(
literal|"%s to `%T' from `%T' discards const"
argument_list|,
name|errtype
argument_list|,
name|type
argument_list|,
name|rhstype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|volatile_parity
condition|)
block|{
if|if
condition|(
name|fndecl
condition|)
name|cp_pedwarn
argument_list|(
literal|"passing `%T' as argument %P of `%D' discards volatile"
argument_list|,
name|rhstype
argument_list|,
name|parmnum
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
else|else
name|cp_pedwarn
argument_list|(
literal|"%s to `%T' from `%T' discards volatile"
argument_list|,
name|errtype
argument_list|,
name|type
argument_list|,
name|rhstype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|unsigned_parity
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|fndecl
condition|)
name|cp_pedwarn
argument_list|(
literal|"passing `%T' as argument %P of `%D' changes signed to unsigned"
argument_list|,
name|rhstype
argument_list|,
name|parmnum
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
else|else
name|cp_pedwarn
argument_list|(
literal|"%s to `%T' from `%T' changes signed to unsigned"
argument_list|,
name|errtype
argument_list|,
name|type
argument_list|,
name|rhstype
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|unsigned_parity
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|fndecl
condition|)
name|cp_pedwarn
argument_list|(
literal|"passing `%T' as argument %P of `%D' changes unsigned to signed"
argument_list|,
name|rhstype
argument_list|,
name|parmnum
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
else|else
name|cp_pedwarn
argument_list|(
literal|"%s to `%T' from `%T' changes unsigned to signed"
argument_list|,
name|errtype
argument_list|,
name|type
argument_list|,
name|rhstype
argument_list|)
expr_stmt|;
block|}
comment|/* C++ is not so friendly about converting function and 		 member function pointers as C.  Emit warnings here.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
if|if
condition|(
operator|!
name|comptypes
argument_list|(
name|ttl
argument_list|,
name|ttr
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"conflicting function types in %s:"
argument_list|,
name|errtype
argument_list|)
expr_stmt|;
name|cp_warning
argument_list|(
literal|"\t`%T' != `%T'"
argument_list|,
name|type
argument_list|,
name|rhstype
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
comment|/* When does this happen?  */
name|my_friendly_abort
argument_list|(
literal|119
argument_list|)
expr_stmt|;
comment|/* Conversion of a pointer-to-member type to void *.  */
name|rhs
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
operator|=
name|type
expr_stmt|;
return|return
name|rhs
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
block|{
comment|/* When does this happen?  */
name|my_friendly_abort
argument_list|(
literal|120
argument_list|)
expr_stmt|;
comment|/* Conversion of a pointer-to-member type to void *.  */
name|rhs
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
operator|=
name|type
expr_stmt|;
return|return
name|rhs
return|;
block|}
else|else
block|{
if|if
condition|(
name|fndecl
condition|)
name|cp_error
argument_list|(
literal|"passing `%T' as argument %P of `%D'"
argument_list|,
name|rhstype
argument_list|,
name|parmnum
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
else|else
name|cp_error
argument_list|(
literal|"%s to `%T' from `%T'"
argument_list|,
name|errtype
argument_list|,
name|type
argument_list|,
name|rhstype
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|rhs
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|codel
operator|==
name|POINTER_TYPE
operator|&&
name|coder
operator|==
name|INTEGER_TYPE
condition|)
block|{
comment|/* An explicit constant 0 can convert to a pointer,          but not a 0 that results from casting or folding.  */
if|if
condition|(
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|integer_zerop
argument_list|(
name|rhs
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|fndecl
condition|)
name|cp_pedwarn
argument_list|(
literal|"passing `%T' to argument %P of `%D' lacks a cast"
argument_list|,
name|rhstype
argument_list|,
name|parmnum
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
else|else
name|cp_pedwarn
argument_list|(
literal|"%s to `%T' from `%T' lacks a cast"
argument_list|,
name|errtype
argument_list|,
name|type
argument_list|,
name|rhstype
argument_list|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|rhs
argument_list|)
return|;
block|}
return|return
name|null_pointer_node
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|codel
operator|==
name|INTEGER_TYPE
operator|||
name|codel
operator|==
name|BOOLEAN_TYPE
operator|)
operator|&&
operator|(
name|coder
operator|==
name|POINTER_TYPE
operator|||
operator|(
name|coder
operator|==
name|RECORD_TYPE
operator|&&
operator|(
name|IS_SIGNATURE_POINTER
argument_list|(
name|rhstype
argument_list|)
operator|||
name|TYPE_PTRMEMFUNC_FLAG
argument_list|(
name|rhstype
argument_list|)
operator|||
name|IS_SIGNATURE_REFERENCE
argument_list|(
name|rhstype
argument_list|)
operator|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|fndecl
condition|)
name|cp_pedwarn
argument_list|(
literal|"passing `%T' to argument %P of `%D' lacks a cast"
argument_list|,
name|rhstype
argument_list|,
name|parmnum
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
else|else
name|cp_pedwarn
argument_list|(
literal|"%s to `%T' from `%T' lacks a cast"
argument_list|,
name|errtype
argument_list|,
name|type
argument_list|,
name|rhstype
argument_list|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|rhs
argument_list|)
return|;
block|}
comment|/* C++ */
elseif|else
if|if
condition|(
operator|(
operator|(
name|coder
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|rhstype
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhstype
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
operator|)
operator|||
name|integer_zerop
argument_list|(
name|rhs
argument_list|)
operator|||
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|)
operator|&&
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* compatible pointer to member functions. */
return|return
name|build_ptrmemfunc
argument_list|(
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|rhs
argument_list|,
literal|0
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|codel
operator|==
name|ERROR_MARK
operator|||
name|coder
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
comment|/* This should no longer happen.  References are initialized via      `convert_for_initialization'.  They should otherwise be      bashed before coming here.  */
elseif|else
if|if
condition|(
name|codel
operator|==
name|REFERENCE_TYPE
condition|)
comment|/* Force an abort.  */
name|my_friendly_assert
argument_list|(
name|codel
operator|!=
name|REFERENCE_TYPE
argument_list|,
literal|317
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|nrhs
init|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|rhs
argument_list|)
decl_stmt|;
name|TREE_CONSTANT
argument_list|(
name|nrhs
argument_list|)
operator|=
name|TREE_CONSTANT
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
return|return
name|nrhs
return|;
block|}
elseif|else
if|if
condition|(
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|type
argument_list|)
operator|||
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
condition|)
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|rhs
argument_list|)
return|;
name|cp_error
argument_list|(
literal|"%s to `%T' from `%T'"
argument_list|,
name|errtype
argument_list|,
name|type
argument_list|,
name|rhstype
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* Convert RHS to be of type TYPE.  If EXP is non-zero,    it is the target of the initialization.    ERRTYPE is a string to use in error messages.     Two major differences between the behavior of    `convert_for_assignment' and `convert_for_initialization'    are that references are bashed in the former, while    copied in the latter, and aggregates are assigned in    the former (operator=) while initialized in the    latter (X(X&)).     If using constructor make sure no conversion operator exists, if one does    exist, an ambiguity exists.  */
end_comment

begin_function
name|tree
name|convert_for_initialization
parameter_list|(
name|exp
parameter_list|,
name|type
parameter_list|,
name|rhs
parameter_list|,
name|flags
parameter_list|,
name|errtype
parameter_list|,
name|fndecl
parameter_list|,
name|parmnum
parameter_list|)
name|tree
name|exp
decl_stmt|,
name|type
decl_stmt|,
name|rhs
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|char
modifier|*
name|errtype
decl_stmt|;
name|tree
name|fndecl
decl_stmt|;
name|int
name|parmnum
decl_stmt|;
block|{
specifier|register
name|enum
name|tree_code
name|codel
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|rhstype
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|coder
decl_stmt|;
comment|/* build_c_cast puts on a NOP_EXPR to make the result not an lvalue.      Strip such NOP_EXPRs, since RHS is used in non-lvalue context.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|codel
operator|!=
name|REFERENCE_TYPE
condition|)
name|rhs
operator|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rhs
operator|==
name|error_mark_node
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|TREE_VALUE
argument_list|(
name|rhs
argument_list|)
operator|==
name|error_mark_node
operator|)
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
block|{
name|rhs
operator|=
name|resolve_offset_ref
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|rhs
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|rhstype
operator|=
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
name|coder
operator|=
name|TREE_CODE
argument_list|(
name|rhstype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|ARRAY_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|REFERENCE_TYPE
operator|)
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|rhs
operator|=
name|default_conversion
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
name|rhstype
operator|=
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
name|coder
operator|=
name|TREE_CODE
argument_list|(
name|rhstype
argument_list|)
expr_stmt|;
if|if
condition|(
name|coder
operator|==
name|UNKNOWN_TYPE
condition|)
block|{
name|rhs
operator|=
name|instantiate_type
argument_list|(
name|type
argument_list|,
name|rhs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rhstype
operator|=
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
name|coder
operator|=
name|TREE_CODE
argument_list|(
name|rhstype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|coder
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
if|#
directive|if
literal|0
comment|/* This is *not* the quick way out!  It is the way to disaster.  */
block|if (type == rhstype)     goto converted;
endif|#
directive|endif
comment|/* We accept references to incomplete types, so we can      return here before checking if RHS is of complete type.  */
if|if
condition|(
name|codel
operator|==
name|REFERENCE_TYPE
condition|)
block|{
comment|/* This should eventually happen in convert_arguments.  */
specifier|extern
name|int
name|warningcount
decl_stmt|,
name|errorcount
decl_stmt|;
name|int
name|savew
decl_stmt|,
name|savee
decl_stmt|;
if|if
condition|(
name|fndecl
condition|)
name|savew
operator|=
name|warningcount
operator|,
name|savee
operator|=
name|errorcount
expr_stmt|;
name|rhs
operator|=
name|convert_to_reference
argument_list|(
name|type
argument_list|,
name|rhs
argument_list|,
name|CONV_IMPLICIT
argument_list|,
name|flags
argument_list|,
name|exp
condition|?
name|exp
else|:
name|error_mark_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|fndecl
condition|)
block|{
if|if
condition|(
name|warningcount
operator|>
name|savew
condition|)
name|cp_warning_at
argument_list|(
literal|"in passing argument %P of `%+D'"
argument_list|,
name|parmnum
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|errorcount
operator|>
name|savee
condition|)
name|cp_error_at
argument_list|(
literal|"in passing argument %P of `%+D'"
argument_list|,
name|parmnum
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
block|}
return|return
name|rhs
return|;
block|}
name|rhs
operator|=
name|require_complete_type
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|rhs
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|exp
operator|!=
literal|0
condition|)
name|exp
operator|=
name|require_complete_type
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhstype
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|rhstype
operator|=
name|TREE_TYPE
argument_list|(
name|rhstype
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
name|IS_SIGNATURE_POINTER
argument_list|(
name|type
argument_list|)
operator|||
name|IS_SIGNATURE_REFERENCE
argument_list|(
name|type
argument_list|)
operator|)
condition|)
return|return
name|build_signature_pointer_constructor
argument_list|(
name|type
argument_list|,
name|rhs
argument_list|)
return|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
operator|||
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|rhs
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|rhstype
argument_list|)
condition|)
block|{
comment|/* This is sufficient to perform initialization.  No need, 	     apparently, to go through X(X&) to do first-cut 	     initialization.  Return through a TARGET_EXPR so that we get 	     cleanups if it is used.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|CALL_EXPR
condition|)
block|{
name|rhs
operator|=
name|build_cplus_new
argument_list|(
name|type
argument_list|,
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|rhs
return|;
block|}
comment|/* Handle the case of default parameter initialization and 	     initialization of static variables.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|INDIRECT_REF
operator|&&
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|rhs
argument_list|)
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CALL_EXPR
argument_list|,
literal|318
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
argument_list|,
literal|316
argument_list|)
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|rhs
operator|=
name|build_cplus_new
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|rhs
return|;
block|}
block|}
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|rhstype
argument_list|)
operator|||
operator|(
name|IS_AGGR_TYPE
argument_list|(
name|rhstype
argument_list|)
operator|&&
name|UNIQUELY_DERIVED_FROM_P
argument_list|(
name|type
argument_list|,
name|rhstype
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|TYPE_HAS_INIT_REF
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
name|init
init|=
name|build_method_call
argument_list|(
name|exp
argument_list|,
name|constructor_name_full
argument_list|(
name|type
argument_list|)
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|rhs
argument_list|)
argument_list|,
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
decl_stmt|;
if|if
condition|(
name|init
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|exp
operator|==
literal|0
condition|)
block|{
name|exp
operator|=
name|build_cplus_new
argument_list|(
name|type
argument_list|,
name|init
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|exp
return|;
block|}
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|type
argument_list|,
name|init
argument_list|,
name|exp
argument_list|)
return|;
block|}
comment|/* ??? The following warnings are turned off because 	     this is another place where the default X(X&) constructor 	     is implemented.  */
if|if
condition|(
name|TYPE_HAS_ASSIGNMENT
argument_list|(
name|type
argument_list|)
condition|)
name|cp_warning
argument_list|(
literal|"bitwise copy: `%T' defines operator="
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|rhs
operator|=
name|convert_from_reference
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|rhstype
condition|)
block|{
name|tree
name|nrhs
init|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|rhs
argument_list|)
decl_stmt|;
name|TREE_CONSTANT
argument_list|(
name|nrhs
argument_list|)
operator|=
name|TREE_CONSTANT
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
name|rhs
operator|=
name|nrhs
expr_stmt|;
block|}
return|return
name|rhs
return|;
block|}
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|rhs
argument_list|)
return|;
block|}
if|if
condition|(
name|type
operator|==
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_READONLY_DECL_P
argument_list|(
name|rhs
argument_list|)
condition|)
name|rhs
operator|=
name|decl_constant_value
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
return|return
name|rhs
return|;
block|}
return|return
name|convert_for_assignment
argument_list|(
name|type
argument_list|,
name|rhs
argument_list|,
name|errtype
argument_list|,
name|fndecl
argument_list|,
name|parmnum
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Expand an ASM statement with operands, handling output operands    that are not variables or INDIRECT_REFS by transforming such    cases into cases that expand_asm_operands can handle.     Arguments are same as for expand_asm_operands.     We don't do default conversions on all inputs, because it can screw    up operands that are expected to be in memory.  */
end_comment

begin_function
name|void
name|c_expand_asm_operands
parameter_list|(
name|string
parameter_list|,
name|outputs
parameter_list|,
name|inputs
parameter_list|,
name|clobbers
parameter_list|,
name|vol
parameter_list|,
name|filename
parameter_list|,
name|line
parameter_list|)
name|tree
name|string
decl_stmt|,
name|outputs
decl_stmt|,
name|inputs
decl_stmt|,
name|clobbers
decl_stmt|;
name|int
name|vol
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
name|int
name|noutputs
init|=
name|list_length
argument_list|(
name|outputs
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* o[I] is the place that output number I should be written.  */
specifier|register
name|tree
modifier|*
name|o
init|=
operator|(
name|tree
operator|*
operator|)
name|alloca
argument_list|(
name|noutputs
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|tail
decl_stmt|;
comment|/* Record the contents of OUTPUTS before it is modified.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|tail
operator|=
name|outputs
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
operator|,
name|i
operator|++
control|)
name|o
index|[
name|i
index|]
operator|=
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
expr_stmt|;
comment|/* Generate the ASM_OPERANDS insn;      store into the TREE_VALUEs of OUTPUTS some trees for      where the values were actually stored.  */
name|expand_asm_operands
argument_list|(
name|string
argument_list|,
name|outputs
argument_list|,
name|inputs
argument_list|,
name|clobbers
argument_list|,
name|vol
argument_list|,
name|filename
argument_list|,
name|line
argument_list|)
expr_stmt|;
comment|/* Copy all the intermediate outputs into the specified outputs.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|tail
operator|=
name|outputs
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|o
index|[
name|i
index|]
operator|!=
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
condition|)
block|{
name|expand_expr
argument_list|(
name|build_modify_expr
argument_list|(
name|o
index|[
name|i
index|]
argument_list|,
name|NOP_EXPR
argument_list|,
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free_temp_slots
argument_list|()
expr_stmt|;
block|}
comment|/* Detect modification of read-only values. 	 (Otherwise done by build_modify_expr.)  */
else|else
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|o
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_READONLY
argument_list|(
name|type
argument_list|)
operator|||
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
operator|)
operator|&&
name|C_TYPE_FIELDS_READONLY
argument_list|(
name|type
argument_list|)
operator|)
condition|)
name|readonly_error
argument_list|(
name|o
index|[
name|i
index|]
argument_list|,
literal|"modification by `asm'"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Those MODIFY_EXPRs could do autoincrements.  */
name|emit_queue
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Expand a C `return' statement.    RETVAL is the expression for what to return,    or a null pointer for `return;' with no value.     C++: upon seeing a `return', we must call destructors on all    variables in scope which had constructors called on them.    This means that if in a destructor, the base class destructors    must be called before returning.     The RETURN statement in C++ has initialization semantics.  */
end_comment

begin_function
name|void
name|c_expand_return
parameter_list|(
name|retval
parameter_list|)
name|tree
name|retval
decl_stmt|;
block|{
specifier|extern
name|struct
name|nesting
modifier|*
name|cond_stack
decl_stmt|,
modifier|*
name|loop_stack
decl_stmt|,
modifier|*
name|case_stack
decl_stmt|;
specifier|extern
name|tree
name|dtor_label
decl_stmt|,
name|ctor_label
decl_stmt|;
name|tree
name|result
init|=
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
decl_stmt|;
name|tree
name|valtype
init|=
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
decl_stmt|;
specifier|register
name|int
name|use_temp
init|=
literal|0
decl_stmt|;
name|int
name|returns_value
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|current_function_decl
argument_list|)
condition|)
name|warning
argument_list|(
literal|"function declared `noreturn' has a `return' statement"
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
name|error_mark_node
condition|)
block|{
name|current_function_returns_null
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|retval
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* A non-named return value does not count.  */
comment|/* Can't just return from a destructor.  */
if|if
condition|(
name|dtor_label
condition|)
block|{
name|expand_goto
argument_list|(
name|dtor_label
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|current_function_decl
argument_list|)
condition|)
name|retval
operator|=
name|current_class_decl
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_NAME
argument_list|(
name|result
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|valtype
argument_list|)
operator|!=
name|VOID_TYPE
condition|)
name|retval
operator|=
name|result
expr_stmt|;
else|else
block|{
name|current_function_returns_null
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|valtype
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|valtype
argument_list|)
operator|!=
name|VOID_TYPE
condition|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|pedwarn
argument_list|(
literal|"`return' with no value, in function returning non-void"
argument_list|)
expr_stmt|;
comment|/* Clear this, so finish_function won't say that we 		     reach the end of a non-void function (which we don't, 		     we gave a return!).  */
name|current_function_returns_null
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|expand_null_return
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|current_function_decl
argument_list|)
operator|&&
name|retval
operator|!=
name|current_class_decl
condition|)
block|{
name|error
argument_list|(
literal|"return from a constructor: use `this = ...' instead"
argument_list|)
expr_stmt|;
name|retval
operator|=
name|current_class_decl
expr_stmt|;
block|}
if|if
condition|(
name|valtype
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|valtype
argument_list|)
operator|==
name|VOID_TYPE
condition|)
block|{
name|current_function_returns_null
operator|=
literal|1
expr_stmt|;
comment|/* We do this here so we'll avoid a warning about how the function 	 "may or may not return a value" in finish_function.  */
name|returns_value
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|retval
condition|)
name|pedwarn
argument_list|(
literal|"`return' with a value, in function returning void"
argument_list|)
expr_stmt|;
name|expand_return
argument_list|(
name|retval
argument_list|)
expr_stmt|;
block|}
comment|/* Add some useful error checking for C++.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|valtype
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|tree
name|whats_returned
decl_stmt|;
name|tree
name|tmp_result
init|=
name|result
decl_stmt|;
comment|/* Don't initialize directly into a non-BLKmode retval, since that 	 could lose when being inlined by another caller.  (GCC can't 	 read the function return register in an inline function when 	 the return value is being ignored).  */
if|if
condition|(
name|result
operator|&&
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|tmp_result
argument_list|)
argument_list|)
operator|!=
name|BLKmode
condition|)
name|tmp_result
operator|=
literal|0
expr_stmt|;
comment|/* convert to reference now, so we can give error if we 	 return an reference to a non-lvalue.  */
name|retval
operator|=
name|convert_for_initialization
argument_list|(
name|tmp_result
argument_list|,
name|valtype
argument_list|,
name|retval
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
literal|"return"
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Sort through common things to see what it is 	 we are returning.  */
name|whats_returned
operator|=
name|retval
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|whats_returned
argument_list|)
operator|==
name|COMPOUND_EXPR
condition|)
block|{
name|whats_returned
operator|=
name|TREE_OPERAND
argument_list|(
name|whats_returned
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|whats_returned
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
name|whats_returned
operator|=
name|TREE_OPERAND
argument_list|(
name|whats_returned
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|whats_returned
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
block|{
name|whats_returned
operator|=
name|TREE_OPERAND
argument_list|(
name|whats_returned
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|whats_returned
argument_list|)
operator|==
name|NEW_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|whats_returned
argument_list|)
operator|==
name|TARGET_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|whats_returned
argument_list|)
operator|==
name|WITH_CLEANUP_EXPR
condition|)
block|{
comment|/* Get the target.  */
name|whats_returned
operator|=
name|TREE_OPERAND
argument_list|(
name|whats_returned
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"returning reference to temporary"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|whats_returned
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_NAME
argument_list|(
name|whats_returned
argument_list|)
condition|)
block|{
if|if
condition|(
name|TEMP_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|whats_returned
argument_list|)
argument_list|)
condition|)
name|warning
argument_list|(
literal|"reference to non-lvalue returned"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|TREE_STATIC
argument_list|(
name|whats_returned
argument_list|)
operator|&&
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|whats_returned
argument_list|)
argument_list|)
condition|)
name|cp_warning_at
argument_list|(
literal|"reference to local variable `%D' returned"
argument_list|,
name|whats_returned
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|retval
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
block|{
name|tree
name|whats_returned
init|=
name|TREE_OPERAND
argument_list|(
name|retval
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|whats_returned
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_NAME
argument_list|(
name|whats_returned
argument_list|)
operator|&&
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|whats_returned
argument_list|)
argument_list|)
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|whats_returned
argument_list|)
condition|)
name|cp_warning_at
argument_list|(
literal|"address of local variable `%D' returned"
argument_list|,
name|whats_returned
argument_list|)
expr_stmt|;
block|}
comment|/* Now deal with possible C++ hair:      (1) Compute the return value.      (2) If there are aggregate values with destructors which      must be cleaned up, clean them (taking care      not to clobber the return value).      (3) If an X(X&) constructor is defined, the return      value must be returned via that.  */
if|if
condition|(
name|retval
operator|==
name|result
comment|/* Watch out for constructors, which "return" aggregates 	 via initialization, but which otherwise "return" a pointer.  */
operator|||
name|DECL_CONSTRUCTOR_P
argument_list|(
name|current_function_decl
argument_list|)
condition|)
block|{
comment|/* This is just an error--it's already been reported.  */
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|valtype
argument_list|)
operator|==
name|NULL_TREE
condition|)
return|return;
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|valtype
argument_list|)
operator|!=
name|BLKmode
operator|&&
name|any_pending_cleanups
argument_list|(
literal|1
argument_list|)
condition|)
block|{
name|retval
operator|=
name|get_temp_regvar
argument_list|(
name|valtype
argument_list|,
name|retval
argument_list|)
expr_stmt|;
name|use_temp
operator|=
name|obey_regdecls
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|valtype
argument_list|)
operator|&&
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|valtype
argument_list|)
condition|)
block|{
comment|/* Throw away the cleanup that `build_functional_cast' gave us.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|retval
argument_list|)
operator|==
name|WITH_CLEANUP_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|retval
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|TARGET_EXPR
condition|)
name|retval
operator|=
name|TREE_OPERAND
argument_list|(
name|retval
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_aggr_init
argument_list|(
name|result
argument_list|,
name|retval
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_cleanups_to
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|result
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|valtype
argument_list|)
operator|==
name|VOIDmode
condition|)
block|{
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|warn_return_type
condition|)
name|warning
argument_list|(
literal|"return of void value in function returning non-void"
argument_list|)
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|retval
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|valtype
argument_list|)
operator|!=
name|BLKmode
operator|&&
name|any_pending_cleanups
argument_list|(
literal|1
argument_list|)
condition|)
block|{
name|retval
operator|=
name|get_temp_regvar
argument_list|(
name|valtype
argument_list|,
name|retval
argument_list|)
expr_stmt|;
name|expand_cleanups_to
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
name|use_temp
operator|=
name|obey_regdecls
expr_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|retval
operator|=
name|convert_for_initialization
argument_list|(
name|result
argument_list|,
name|valtype
argument_list|,
name|retval
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
literal|"return"
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|result
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
if|if
condition|(
name|retval
operator|==
name|error_mark_node
condition|)
return|return;
block|}
name|emit_queue
argument_list|()
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|retval
argument_list|)
argument_list|)
operator|==
literal|'d'
operator|&&
name|cond_stack
operator|==
literal|0
operator|&&
name|loop_stack
operator|==
literal|0
operator|&&
name|case_stack
operator|==
literal|0
condition|)
name|current_function_return_value
operator|=
name|retval
expr_stmt|;
if|if
condition|(
name|result
condition|)
block|{
comment|/* Everything's great--RETVAL is in RESULT.  */
if|if
condition|(
name|original_result_rtx
condition|)
block|{
name|store_expr
argument_list|(
name|result
argument_list|,
name|original_result_rtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_cleanups_to
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|retval
operator|&&
name|retval
operator|!=
name|result
condition|)
block|{
comment|/* Clear this out so the later call to decl_function_context 	     won't end up bombing on us.  */
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|result
argument_list|)
operator|==
name|error_mark_node
condition|)
name|DECL_CONTEXT
argument_list|(
name|result
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Here is where we finally get RETVAL into RESULT. 	     `expand_return' does the magic of protecting 	     RESULT from cleanups.  */
name|retval
operator|=
name|build1
argument_list|(
name|CLEANUP_POINT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
argument_list|,
name|retval
argument_list|)
expr_stmt|;
comment|/* This part _must_ come second, because expand_return looks for 	     the INIT_EXPR as the toplevel node only.  :-( */
name|retval
operator|=
name|build
argument_list|(
name|INIT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
argument_list|,
name|result
argument_list|,
name|retval
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|retval
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_return
argument_list|(
name|retval
argument_list|)
expr_stmt|;
block|}
else|else
name|expand_return
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|use_variable
argument_list|(
name|DECL_RTL
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctor_label
operator|&&
name|TREE_CODE
argument_list|(
name|ctor_label
argument_list|)
operator|!=
name|ERROR_MARK
condition|)
name|expand_goto
argument_list|(
name|ctor_label
argument_list|)
expr_stmt|;
else|else
name|expand_null_return
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* We may still need to put RETVAL into RESULT.  */
name|result
operator|=
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|original_result_rtx
condition|)
block|{
comment|/* Here we have a named return value that went 	     into memory.  We can compute RETVAL into that.  */
if|if
condition|(
name|retval
condition|)
name|expand_assignment
argument_list|(
name|result
argument_list|,
name|retval
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|store_expr
argument_list|(
name|result
argument_list|,
name|original_result_rtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|result
operator|=
name|make_tree
argument_list|(
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
argument_list|,
name|original_result_rtx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctor_label
operator|&&
name|TREE_CODE
argument_list|(
name|ctor_label
argument_list|)
operator|!=
name|ERROR_MARK
condition|)
block|{
comment|/* Here RETVAL is CURRENT_CLASS_DECL, so there's nothing to do.  */
name|expand_goto
argument_list|(
name|ctor_label
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|retval
condition|)
block|{
comment|/* Here is where we finally get RETVAL into RESULT. 	     `expand_return' does the magic of protecting 	     RESULT from cleanups.  */
name|result
operator|=
name|build
argument_list|(
name|INIT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
argument_list|,
name|result
argument_list|,
name|retval
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_return
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
argument_list|)
operator|!=
name|VOIDmode
condition|)
name|expand_return
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
name|current_function_returns_value
operator|=
name|returns_value
expr_stmt|;
if|#
directive|if
literal|0
comment|/* These wind up after the BARRIER, which causes problems for      expand_end_binding.  What purpose were they supposed to serve?  */
block|if (original_result_rtx)     use_variable (original_result_rtx);   if (use_temp)     use_variable (DECL_RTL (DECL_RESULT (current_function_decl)));
endif|#
directive|endif
comment|/* One way to clear out cleanups that EXPR might      generate.  Note that this code will really be      dead code, but that is ok--cleanups that were      needed were handled by the magic of `return'.  */
name|expand_cleanups_to
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Start a C switch statement, testing expression EXP.    Return EXP if it is valid, an error node otherwise.  */
end_comment

begin_function
name|tree
name|c_expand_start_case
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
name|tree
name|type
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|code
decl_stmt|;
comment|/* Convert from references, etc.  */
name|exp
operator|=
name|default_conversion
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE_CODE
argument_list|(
name|code
argument_list|)
condition|)
name|exp
operator|=
name|build_type_conversion
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"switch quantity not an integer"
argument_list|)
expr_stmt|;
name|exp
operator|=
name|error_mark_node
expr_stmt|;
block|}
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|INTEGER_TYPE
operator|&&
name|code
operator|!=
name|ENUMERAL_TYPE
operator|&&
name|code
operator|!=
name|ERROR_MARK
condition|)
block|{
name|error
argument_list|(
literal|"switch quantity not an integer"
argument_list|)
expr_stmt|;
name|exp
operator|=
name|error_mark_node
expr_stmt|;
block|}
else|else
block|{
name|tree
name|index
decl_stmt|;
name|exp
operator|=
name|default_conversion
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|index
operator|=
name|get_unwidened
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* We can't strip a conversion from a signed type to an unsigned, 	 because if we did, int_fits_type_p would do the wrong thing 	 when checking case values for being in range, 	 and it's too hard to do the right thing.  */
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|index
argument_list|)
argument_list|)
condition|)
name|exp
operator|=
name|index
expr_stmt|;
block|}
name|expand_start_case
argument_list|(
literal|1
argument_list|,
name|build1
argument_list|(
name|CLEANUP_POINT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|exp
argument_list|)
argument_list|,
name|type
argument_list|,
literal|"switch statement"
argument_list|)
expr_stmt|;
return|return
name|exp
return|;
block|}
end_function

begin_comment
comment|/* CONSTP remembers whether or not all the intervening pointers in the `to'    type have been const.  */
end_comment

begin_function
name|int
name|comp_ptr_ttypes_real
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|,
name|constp
parameter_list|)
name|tree
name|to
decl_stmt|,
name|from
decl_stmt|;
name|int
name|constp
decl_stmt|;
block|{
for|for
control|(
init|;
condition|;
name|to
operator|=
name|TREE_TYPE
argument_list|(
name|to
argument_list|)
operator|,
name|from
operator|=
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|from
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TYPE_READONLY
argument_list|(
name|from
argument_list|)
operator|>
name|TYPE_READONLY
argument_list|(
name|to
argument_list|)
operator|||
name|TYPE_VOLATILE
argument_list|(
name|from
argument_list|)
operator|>
name|TYPE_VOLATILE
argument_list|(
name|to
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|constp
operator|&&
operator|(
name|TYPE_READONLY
argument_list|(
name|to
argument_list|)
operator|>
name|TYPE_READONLY
argument_list|(
name|from
argument_list|)
operator|||
name|TYPE_VOLATILE
argument_list|(
name|to
argument_list|)
operator|>
name|TYPE_READONLY
argument_list|(
name|from
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
name|constp
operator|&=
name|TYPE_READONLY
argument_list|(
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
return|return
name|comptypes
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|to
argument_list|)
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|from
argument_list|)
argument_list|,
literal|1
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* When comparing, say, char ** to char const **, this function takes the    'char *' and 'char const *'.  Do not pass non-pointer types to this    function.  */
end_comment

begin_function
name|int
name|comp_ptr_ttypes
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|)
name|tree
name|to
decl_stmt|,
name|from
decl_stmt|;
block|{
return|return
name|comp_ptr_ttypes_real
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

end_unit

