begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Breadth-first and depth-first routines for    searching multiple-inheritance lattice for GNU C++.    Copyright (C) 1987, 1989, 1992, 1993 Free Software Foundation, Inc.    Contributed by Michael Tiemann (tiemann@cygnus.com)  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* High-level class interface. */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_function_decl
name|void
name|init_search
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|struct
name|obstack
modifier|*
name|current_obstack
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|"stack.h"
end_include

begin_comment
comment|/* Obstack used for remembering decision points of breadth-first.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|search_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Methods for pushing and popping objects to and from obstacks.  */
end_comment

begin_function
name|struct
name|stack_level
modifier|*
name|push_stack_level
parameter_list|(
name|obstack
parameter_list|,
name|tp
parameter_list|,
name|size
parameter_list|)
name|struct
name|obstack
modifier|*
name|obstack
decl_stmt|;
name|char
modifier|*
name|tp
decl_stmt|;
comment|/* Sony NewsOS 5.0 compiler doesn't like void * here.  */
name|int
name|size
decl_stmt|;
block|{
name|struct
name|stack_level
modifier|*
name|stack
decl_stmt|;
name|obstack_grow
argument_list|(
name|obstack
argument_list|,
name|tp
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|stack
operator|=
operator|(
expr|struct
name|stack_level
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|obstack_next_free
argument_list|(
name|obstack
argument_list|)
operator|-
name|size
operator|)
expr_stmt|;
name|obstack_finish
argument_list|(
name|obstack
argument_list|)
expr_stmt|;
name|stack
operator|->
name|obstack
operator|=
name|obstack
expr_stmt|;
name|stack
operator|->
name|first
operator|=
operator|(
name|tree
operator|*
operator|)
name|obstack_base
argument_list|(
name|obstack
argument_list|)
expr_stmt|;
name|stack
operator|->
name|limit
operator|=
name|obstack_room
argument_list|(
name|obstack
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|tree
operator|*
argument_list|)
expr_stmt|;
return|return
name|stack
return|;
block|}
end_function

begin_function
name|struct
name|stack_level
modifier|*
name|pop_stack_level
parameter_list|(
name|stack
parameter_list|)
name|struct
name|stack_level
modifier|*
name|stack
decl_stmt|;
block|{
name|struct
name|stack_level
modifier|*
name|tem
init|=
name|stack
decl_stmt|;
name|struct
name|obstack
modifier|*
name|obstack
init|=
name|tem
operator|->
name|obstack
decl_stmt|;
name|stack
operator|=
name|tem
operator|->
name|prev
expr_stmt|;
name|obstack_free
argument_list|(
name|obstack
argument_list|,
name|tem
argument_list|)
expr_stmt|;
return|return
name|stack
return|;
block|}
end_function

begin_define
define|#
directive|define
name|search_level
value|stack_level
end_define

begin_decl_stmt
specifier|static
name|struct
name|search_level
modifier|*
name|search_stack
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|tree
name|lookup_field_1
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lookup_fnfields_1
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dfs_walk
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|markedp
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dfs_unmark
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dfs_init_vbase_pointers
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|tree
name|vbase_types
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|vbase_decl
decl_stmt|,
name|vbase_decl_ptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|vbase_decl_ptr_intermediate
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|vbase_init_result
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Allocate a level of searching.  */
end_comment

begin_function
specifier|static
name|struct
name|search_level
modifier|*
name|push_search_level
parameter_list|(
name|stack
parameter_list|,
name|obstack
parameter_list|)
name|struct
name|stack_level
modifier|*
name|stack
decl_stmt|;
name|struct
name|obstack
modifier|*
name|obstack
decl_stmt|;
block|{
name|struct
name|search_level
name|tem
decl_stmt|;
name|tem
operator|.
name|prev
operator|=
name|stack
expr_stmt|;
return|return
name|push_stack_level
argument_list|(
name|obstack
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tem
argument_list|,
sizeof|sizeof
argument_list|(
name|tem
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Discard a level of search allocation.  */
end_comment

begin_function
specifier|static
name|struct
name|search_level
modifier|*
name|pop_search_level
parameter_list|(
name|obstack
parameter_list|)
name|struct
name|stack_level
modifier|*
name|obstack
decl_stmt|;
block|{
specifier|register
name|struct
name|search_level
modifier|*
name|stack
init|=
name|pop_stack_level
argument_list|(
name|obstack
argument_list|)
decl_stmt|;
return|return
name|stack
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Search memoization.  */
end_comment

begin_struct
struct|struct
name|type_level
block|{
name|struct
name|stack_level
name|base
decl_stmt|;
comment|/* First object allocated in obstack of entries.  */
name|char
modifier|*
name|entries
decl_stmt|;
comment|/* Number of types memoized in this context.  */
name|int
name|len
decl_stmt|;
comment|/* Type being memoized; save this if we are saving      memoized contexts.  */
name|tree
name|type
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Obstack used for memoizing member and member function lookup.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|type_obstack
decl_stmt|,
name|type_obstack_entries
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type_level
modifier|*
name|type_stack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|_vptr_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Make things that look like tree nodes, but allocate them    on type_obstack_entries.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|my_tree_node_counter
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|my_tree_cons
argument_list|()
decl_stmt|,
name|my_build_string
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|flag_memoize_lookups
decl_stmt|,
name|flag_save_memoized_contexts
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Variables for gathering statistics.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|my_memoized_entry_counter
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|memoized_fast_finds
index|[
literal|2
index|]
decl_stmt|,
name|memoized_adds
index|[
literal|2
index|]
decl_stmt|,
name|memoized_fast_rejects
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|memoized_fields_searched
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|n_fields_searched
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|n_calls_lookup_field
decl_stmt|,
name|n_calls_lookup_field_1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|n_calls_lookup_fnfields
decl_stmt|,
name|n_calls_lookup_fnfields_1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|n_calls_get_base_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|n_outer_fields_searched
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|n_contexts_saved
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Local variables to help save memoization contexts.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|prev_type_memoized
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type_level
modifier|*
name|prev_type_stack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This list is used by push_class_decls to know what decls need to    be pushed into class scope.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|closed_envelopes
init|=
name|NULL_TREE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Allocate a level of type memoization context.  */
end_comment

begin_function
specifier|static
name|struct
name|type_level
modifier|*
name|push_type_level
parameter_list|(
name|stack
parameter_list|,
name|obstack
parameter_list|)
name|struct
name|stack_level
modifier|*
name|stack
decl_stmt|;
name|struct
name|obstack
modifier|*
name|obstack
decl_stmt|;
block|{
name|struct
name|type_level
name|tem
decl_stmt|;
name|tem
operator|.
name|base
operator|.
name|prev
operator|=
name|stack
expr_stmt|;
name|obstack_finish
argument_list|(
operator|&
name|type_obstack_entries
argument_list|)
expr_stmt|;
name|tem
operator|.
name|entries
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_base
argument_list|(
operator|&
name|type_obstack_entries
argument_list|)
expr_stmt|;
name|tem
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|tem
operator|.
name|type
operator|=
name|NULL_TREE
expr_stmt|;
return|return
operator|(
expr|struct
name|type_level
operator|*
operator|)
name|push_stack_level
argument_list|(
name|obstack
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tem
argument_list|,
sizeof|sizeof
argument_list|(
name|tem
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Discard a level of type memoization context.  */
end_comment

begin_function
specifier|static
name|struct
name|type_level
modifier|*
name|pop_type_level
parameter_list|(
name|stack
parameter_list|)
name|struct
name|type_level
modifier|*
name|stack
decl_stmt|;
block|{
name|obstack_free
argument_list|(
operator|&
name|type_obstack_entries
argument_list|,
name|stack
operator|->
name|entries
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|type_level
operator|*
operator|)
name|pop_stack_level
argument_list|(
operator|(
expr|struct
name|stack_level
operator|*
operator|)
name|stack
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Make something that looks like a TREE_LIST, but    do it on the type_obstack_entries obstack.  */
end_comment

begin_function
specifier|static
name|tree
name|my_tree_cons
parameter_list|(
name|purpose
parameter_list|,
name|value
parameter_list|,
name|chain
parameter_list|)
name|tree
name|purpose
decl_stmt|,
name|value
decl_stmt|,
name|chain
decl_stmt|;
block|{
name|tree
name|p
init|=
operator|(
name|tree
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|type_obstack_entries
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tree_list
argument_list|)
argument_list|)
decl_stmt|;
operator|++
name|my_tree_node_counter
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|p
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
operator|(
operator|(
name|HOST_WIDE_INT
operator|*
operator|)
name|p
operator|)
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|TREE_SET_CODE
argument_list|(
name|p
argument_list|,
name|TREE_LIST
argument_list|)
expr_stmt|;
name|TREE_PURPOSE
argument_list|(
name|p
argument_list|)
operator|=
name|purpose
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|p
argument_list|)
operator|=
name|value
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|p
argument_list|)
operator|=
name|chain
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|my_build_string
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|tree
name|p
init|=
operator|(
name|tree
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|type_obstack_entries
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tree_string
argument_list|)
argument_list|)
decl_stmt|;
operator|++
name|my_tree_node_counter
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|p
argument_list|)
operator|=
literal|0
expr_stmt|;
operator|(
operator|(
name|int
operator|*
operator|)
name|p
operator|)
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|TREE_SET_CODE
argument_list|(
name|p
argument_list|,
name|STRING_CST
argument_list|)
expr_stmt|;
name|TREE_STRING_POINTER
argument_list|(
name|p
argument_list|)
operator|=
name|str
expr_stmt|;
name|TREE_STRING_LENGTH
argument_list|(
name|p
argument_list|)
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Memoizing machinery to make searches for multiple inheritance    reasonably efficient.  */
end_comment

begin_define
define|#
directive|define
name|MEMOIZE_HASHSIZE
value|8
end_define

begin_typedef
typedef|typedef
struct|struct
name|memoized_entry
block|{
name|struct
name|memoized_entry
modifier|*
name|chain
decl_stmt|;
name|int
name|uid
decl_stmt|;
name|tree
name|data_members
index|[
name|MEMOIZE_HASHSIZE
index|]
decl_stmt|;
name|tree
name|function_members
index|[
name|MEMOIZE_HASHSIZE
index|]
decl_stmt|;
block|}
typedef|*
name|ME
typedef|;
end_typedef

begin_define
define|#
directive|define
name|MEMOIZED_CHAIN
parameter_list|(
name|ENTRY
parameter_list|)
value|(((ME)ENTRY)->chain)
end_define

begin_define
define|#
directive|define
name|MEMOIZED_UID
parameter_list|(
name|ENTRY
parameter_list|)
value|(((ME)ENTRY)->uid)
end_define

begin_define
define|#
directive|define
name|MEMOIZED_FIELDS
parameter_list|(
name|ENTRY
parameter_list|,
name|INDEX
parameter_list|)
value|(((ME)ENTRY)->data_members[INDEX])
end_define

begin_define
define|#
directive|define
name|MEMOIZED_FNFIELDS
parameter_list|(
name|ENTRY
parameter_list|,
name|INDEX
parameter_list|)
value|(((ME)ENTRY)->function_members[INDEX])
end_define

begin_comment
comment|/* The following is probably a lousy hash function.  */
end_comment

begin_define
define|#
directive|define
name|MEMOIZED_HASH_FN
parameter_list|(
name|NODE
parameter_list|)
value|(((long)(NODE)>>4)&(MEMOIZE_HASHSIZE - 1))
end_define

begin_function
specifier|static
name|struct
name|memoized_entry
modifier|*
name|my_new_memoized_entry
parameter_list|(
name|chain
parameter_list|)
name|struct
name|memoized_entry
modifier|*
name|chain
decl_stmt|;
block|{
name|struct
name|memoized_entry
modifier|*
name|p
init|=
operator|(
expr|struct
name|memoized_entry
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|type_obstack_entries
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|memoized_entry
argument_list|)
argument_list|)
decl_stmt|;
name|bzero
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|memoized_entry
argument_list|)
argument_list|)
expr_stmt|;
name|MEMOIZED_CHAIN
argument_list|(
name|p
argument_list|)
operator|=
name|chain
expr_stmt|;
name|MEMOIZED_UID
argument_list|(
name|p
argument_list|)
operator|=
operator|++
name|my_memoized_entry_counter
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Make an entry in the memoized table for type TYPE    that the entry for NAME is FIELD.  */
end_comment

begin_function
name|tree
name|make_memoized_table_entry
parameter_list|(
name|type
parameter_list|,
name|name
parameter_list|,
name|function_p
parameter_list|)
name|tree
name|type
decl_stmt|,
name|name
decl_stmt|;
name|int
name|function_p
decl_stmt|;
block|{
name|int
name|index
init|=
name|MEMOIZED_HASH_FN
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|tree
name|entry
decl_stmt|,
modifier|*
name|prev_entry
decl_stmt|;
name|memoized_adds
index|[
name|function_p
index|]
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_MTABLE_ENTRY
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
block|{
name|obstack_ptr_grow
argument_list|(
operator|&
name|type_obstack
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|obstack_blank
argument_list|(
operator|&
name|type_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|memoized_entry
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|CLASSTYPE_MTABLE_ENTRY
argument_list|(
name|type
argument_list|)
operator|=
operator|(
name|char
operator|*
operator|)
name|my_new_memoized_entry
argument_list|(
operator|(
expr|struct
name|memoized_entry
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|type_stack
operator|->
name|len
operator|++
expr_stmt|;
if|if
condition|(
name|type_stack
operator|->
name|len
operator|*
literal|2
operator|>=
name|type_stack
operator|->
name|base
operator|.
name|limit
condition|)
name|my_friendly_abort
argument_list|(
literal|88
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|function_p
condition|)
name|prev_entry
operator|=
operator|&
name|MEMOIZED_FNFIELDS
argument_list|(
name|CLASSTYPE_MTABLE_ENTRY
argument_list|(
name|type
argument_list|)
argument_list|,
name|index
argument_list|)
expr_stmt|;
else|else
name|prev_entry
operator|=
operator|&
name|MEMOIZED_FIELDS
argument_list|(
name|CLASSTYPE_MTABLE_ENTRY
argument_list|(
name|type
argument_list|)
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|entry
operator|=
name|my_tree_cons
argument_list|(
name|name
argument_list|,
name|NULL_TREE
argument_list|,
operator|*
name|prev_entry
argument_list|)
expr_stmt|;
operator|*
name|prev_entry
operator|=
name|entry
expr_stmt|;
comment|/* Don't know the error message to give yet.  */
name|TREE_TYPE
argument_list|(
name|entry
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
return|return
name|entry
return|;
block|}
end_function

begin_comment
comment|/* When a new function or class context is entered, we build    a table of types which have been searched for members.    The table is an array (obstack) of types.  When a type is    entered into the obstack, its CLASSTYPE_MTABLE_ENTRY    field is set to point to a new record, of type struct memoized_entry.     A non-NULL TREE_TYPE of the entry contains an access control error message.     The slots for the data members are arrays of tree nodes.    These tree nodes are lists, with the TREE_PURPOSE    of this list the known member name, and the TREE_VALUE    as the FIELD_DECL for the member.     For member functions, the TREE_PURPOSE is again the    name of the member functions for that class,    and the TREE_VALUE of the list is a pairs    whose TREE_PURPOSE is a member functions of this name,    and whose TREE_VALUE is a list of known argument lists this    member function has been called with.  The TREE_TYPE of the pair,    if non-NULL, is an error message to print.  */
end_comment

begin_comment
comment|/* Tell search machinery that we are entering a new context, and    to update tables appropriately.     TYPE is the type of the context we are entering, which can    be NULL_TREE if we are not in a class's scope.     USE_OLD, if nonzero tries to use previous context.  */
end_comment

begin_function
name|void
name|push_memoized_context
parameter_list|(
name|type
parameter_list|,
name|use_old
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
name|use_old
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
name|tree
modifier|*
name|tem
decl_stmt|;
if|if
condition|(
name|prev_type_stack
condition|)
block|{
if|if
condition|(
name|use_old
operator|&&
name|prev_type_memoized
operator|==
name|type
condition|)
block|{
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_contexts_saved
operator|++
expr_stmt|;
endif|#
directive|endif
name|type_stack
operator|=
name|prev_type_stack
expr_stmt|;
name|prev_type_stack
operator|=
literal|0
expr_stmt|;
name|tem
operator|=
operator|&
name|type_stack
operator|->
name|base
operator|.
name|first
index|[
literal|0
index|]
expr_stmt|;
name|len
operator|=
name|type_stack
operator|->
name|len
expr_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
name|CLASSTYPE_MTABLE_ENTRY
argument_list|(
name|tem
index|[
name|len
operator|*
literal|2
index|]
argument_list|)
operator|=
operator|(
name|char
operator|*
operator|)
name|tem
index|[
name|len
operator|*
literal|2
operator|+
literal|1
index|]
expr_stmt|;
return|return;
block|}
comment|/* Otherwise, need to pop old stack here.  */
name|type_stack
operator|=
name|pop_type_level
argument_list|(
name|prev_type_stack
argument_list|)
expr_stmt|;
name|prev_type_memoized
operator|=
literal|0
expr_stmt|;
name|prev_type_stack
operator|=
literal|0
expr_stmt|;
block|}
name|type_stack
operator|=
name|push_type_level
argument_list|(
operator|(
expr|struct
name|stack_level
operator|*
operator|)
name|type_stack
argument_list|,
operator|&
name|type_obstack
argument_list|)
expr_stmt|;
name|type_stack
operator|->
name|type
operator|=
name|type
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Tell search machinery that we have left a context.    We do not currently save these contexts for later use.    If we wanted to, we could not use pop_search_level, since    poping that level allows the data we have collected to    be clobbered; a stack of obstacks would be needed.  */
end_comment

begin_function
name|void
name|pop_memoized_context
parameter_list|(
name|use_old
parameter_list|)
name|int
name|use_old
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
name|tree
modifier|*
name|tem
init|=
operator|&
name|type_stack
operator|->
name|base
operator|.
name|first
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|flag_save_memoized_contexts
condition|)
name|use_old
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|use_old
condition|)
block|{
name|len
operator|=
name|type_stack
operator|->
name|len
expr_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
name|tem
index|[
name|len
operator|*
literal|2
operator|+
literal|1
index|]
operator|=
operator|(
name|tree
operator|)
name|CLASSTYPE_MTABLE_ENTRY
argument_list|(
name|tem
index|[
name|len
operator|*
literal|2
index|]
argument_list|)
expr_stmt|;
name|prev_type_stack
operator|=
name|type_stack
expr_stmt|;
name|prev_type_memoized
operator|=
name|type_stack
operator|->
name|type
expr_stmt|;
block|}
if|if
condition|(
name|flag_memoize_lookups
condition|)
block|{
name|len
operator|=
name|type_stack
operator|->
name|len
expr_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
name|CLASSTYPE_MTABLE_ENTRY
argument_list|(
name|tem
index|[
name|len
operator|*
literal|2
index|]
argument_list|)
operator|=
operator|(
name|char
operator|*
operator|)
name|MEMOIZED_CHAIN
argument_list|(
name|CLASSTYPE_MTABLE_ENTRY
argument_list|(
name|tem
index|[
name|len
operator|*
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|use_old
condition|)
name|type_stack
operator|=
name|pop_type_level
argument_list|(
name|type_stack
argument_list|)
expr_stmt|;
else|else
name|type_stack
operator|=
operator|(
expr|struct
name|type_level
operator|*
operator|)
name|type_stack
operator|->
name|base
operator|.
name|prev
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* unused */
end_comment

begin_comment
comment|/* This is the newer recursive depth first search routine. */
end_comment

begin_comment
comment|/* Return non-zero if PARENT is directly derived from TYPE.  By directly    we mean it's only one step up the inheritance lattice.  We check this    by walking horizontally across the types that TYPE directly inherits    from, to see if PARENT is among them.  This is used by get_binfo and    by compute_access.  */
end_comment

begin_endif
unit|static int immediately_derived (parent, type)      tree parent, type; {   if (TYPE_BINFO (type))     {       tree binfos = BINFO_BASETYPES (TYPE_BINFO (type));       int i, n_baselinks = binfos ? TREE_VEC_LENGTH (binfos) : 0;        for (i = 0; i< n_baselinks; i++) 	{ 	  tree base_binfo = TREE_VEC_ELT (binfos, i);  	  if (parent == BINFO_TYPE (base_binfo)) 	    return 1; 	}     }   return 0; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Check whether the type given in BINFO is derived from PARENT.  If    it isn't, return 0.  If it is, but the derivation is MI-ambiguous    AND protect != 0, emit an error message and return error_mark_node.     Otherwise, if TYPE is derived from PARENT, return the actual base    information, unless a one of the protection violations below    occurs, in which case emit an error message and return error_mark_node.     If PROTECT is 1, then check if access to a public field of PARENT    would be private.  Also check for ambiguity.  */
end_comment

begin_function
name|tree
name|get_binfo
parameter_list|(
name|parent
parameter_list|,
name|binfo
parameter_list|,
name|protect
parameter_list|)
specifier|register
name|tree
name|parent
decl_stmt|,
name|binfo
decl_stmt|;
name|int
name|protect
decl_stmt|;
block|{
name|tree
name|type
decl_stmt|;
name|int
name|dist
decl_stmt|;
name|tree
name|rval
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parent
argument_list|)
operator|==
name|TREE_VEC
condition|)
name|parent
operator|=
name|BINFO_TYPE
argument_list|(
name|parent
argument_list|)
expr_stmt|;
comment|/* unions cannot participate in inheritance relationships */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parent
argument_list|)
operator|==
name|UNION_TYPE
condition|)
return|return
name|NULL_TREE
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parent
argument_list|)
operator|!=
name|RECORD_TYPE
condition|)
name|my_friendly_abort
argument_list|(
literal|89
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|binfo
argument_list|)
operator|==
name|TREE_VEC
condition|)
name|type
operator|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|binfo
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
name|type
operator|=
name|binfo
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|binfo
argument_list|)
operator|==
name|UNION_TYPE
condition|)
return|return
name|NULL_TREE
return|;
else|else
name|my_friendly_abort
argument_list|(
literal|90
argument_list|)
expr_stmt|;
name|dist
operator|=
name|get_base_distance
argument_list|(
name|parent
argument_list|,
name|binfo
argument_list|,
name|protect
argument_list|,
operator|&
name|rval
argument_list|)
expr_stmt|;
if|if
condition|(
name|dist
operator|==
operator|-
literal|3
condition|)
block|{
name|cp_error
argument_list|(
literal|"fields of `%T' are inaccessible in `%T' due to private inheritance"
argument_list|,
name|parent
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
name|dist
operator|==
operator|-
literal|2
operator|&&
name|protect
condition|)
block|{
name|cp_error
argument_list|(
literal|"type `%T' is ambiguous base class for type `%T'"
argument_list|,
name|parent
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* This is the newer depth first get_base_distance routine.  */
end_comment

begin_function
specifier|static
name|int
name|get_base_distance_recursive
parameter_list|(
name|binfo
parameter_list|,
name|depth
parameter_list|,
name|is_private
parameter_list|,
name|basetype_path
parameter_list|,
name|rval
parameter_list|,
name|rval_private_ptr
parameter_list|,
name|new_binfo_ptr
parameter_list|,
name|parent
parameter_list|,
name|path_ptr
parameter_list|,
name|protect
parameter_list|,
name|via_virtual_ptr
parameter_list|,
name|via_virtual
parameter_list|)
name|tree
name|binfo
decl_stmt|,
name|basetype_path
decl_stmt|,
decl|*
name|new_binfo_ptr
decl_stmt|,
name|parent
decl_stmt|,
modifier|*
name|path_ptr
decl_stmt|;
end_function

begin_decl_stmt
name|int
modifier|*
name|rval_private_ptr
decl_stmt|,
name|depth
decl_stmt|,
name|is_private
decl_stmt|,
name|rval
decl_stmt|,
name|protect
decl_stmt|,
modifier|*
name|via_virtual_ptr
decl_stmt|,
name|via_virtual
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|tree
name|binfos
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baselinks
decl_stmt|;
if|if
condition|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
operator|==
name|parent
operator|||
name|binfo
operator|==
name|parent
condition|)
block|{
if|if
condition|(
name|rval
operator|==
operator|-
literal|1
condition|)
block|{
name|rval
operator|=
name|depth
expr_stmt|;
operator|*
name|rval_private_ptr
operator|=
name|is_private
expr_stmt|;
operator|*
name|new_binfo_ptr
operator|=
name|binfo
expr_stmt|;
operator|*
name|via_virtual_ptr
operator|=
name|via_virtual
expr_stmt|;
block|}
else|else
block|{
name|int
name|same_object
init|=
operator|(
name|tree_int_cst_equal
argument_list|(
name|BINFO_OFFSET
argument_list|(
operator|*
name|new_binfo_ptr
argument_list|)
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
argument_list|)
operator|&&
operator|*
name|via_virtual_ptr
operator|&&
name|via_virtual
operator|)
decl_stmt|;
if|if
condition|(
operator|*
name|via_virtual_ptr
operator|&&
name|via_virtual
operator|==
literal|0
condition|)
block|{
operator|*
name|rval_private_ptr
operator|=
name|is_private
expr_stmt|;
operator|*
name|new_binfo_ptr
operator|=
name|binfo
expr_stmt|;
operator|*
name|via_virtual_ptr
operator|=
name|via_virtual
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|same_object
condition|)
block|{
if|if
condition|(
operator|*
name|rval_private_ptr
operator|&&
operator|!
name|is_private
condition|)
block|{
operator|*
name|rval_private_ptr
operator|=
name|is_private
expr_stmt|;
operator|*
name|new_binfo_ptr
operator|=
name|binfo
expr_stmt|;
operator|*
name|via_virtual_ptr
operator|=
name|via_virtual
expr_stmt|;
block|}
return|return
name|rval
return|;
block|}
name|rval
operator|=
operator|-
literal|2
expr_stmt|;
block|}
return|return
name|rval
return|;
block|}
name|binfos
operator|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
name|n_baselinks
operator|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
expr_stmt|;
name|depth
operator|+=
literal|1
expr_stmt|;
comment|/* Process base types.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baselinks
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
comment|/* Find any specific instance of a virtual base, when searching with 	 a binfo... */
if|if
condition|(
name|BINFO_MARKED
argument_list|(
name|base_binfo
argument_list|)
operator|==
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|parent
argument_list|)
operator|==
name|TREE_VEC
condition|)
block|{
name|int
name|via_private
init|=
operator|(
name|protect
operator|&&
operator|(
name|is_private
operator|||
operator|(
operator|!
name|TREE_VIA_PUBLIC
argument_list|(
name|base_binfo
argument_list|)
operator|&&
operator|!
name|is_friend
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|current_scope
argument_list|()
argument_list|)
operator|)
operator|)
operator|)
decl_stmt|;
name|int
name|this_virtual
init|=
name|via_virtual
operator|||
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
decl_stmt|;
name|int
name|was
decl_stmt|;
comment|/* When searching for a non-virtual, we cannot mark 	     virtually found binfos. */
if|if
condition|(
operator|!
name|this_virtual
condition|)
name|SET_BINFO_MARKED
argument_list|(
name|base_binfo
argument_list|)
expr_stmt|;
define|#
directive|define
name|WATCH_VALUES
parameter_list|(
name|rval
parameter_list|,
name|via_private
parameter_list|)
value|(rval == -1 ? 3 : via_private)
name|was
operator|=
name|WATCH_VALUES
argument_list|(
name|rval
argument_list|,
operator|*
name|via_virtual_ptr
argument_list|)
expr_stmt|;
name|rval
operator|=
name|get_base_distance_recursive
argument_list|(
name|base_binfo
argument_list|,
name|depth
argument_list|,
name|via_private
argument_list|,
name|binfo
argument_list|,
name|rval
argument_list|,
name|rval_private_ptr
argument_list|,
name|new_binfo_ptr
argument_list|,
name|parent
argument_list|,
name|path_ptr
argument_list|,
name|protect
argument_list|,
name|via_virtual_ptr
argument_list|,
name|this_virtual
argument_list|)
expr_stmt|;
comment|/* watch for updates; only update if path is good. */
if|if
condition|(
name|path_ptr
operator|&&
name|WATCH_VALUES
argument_list|(
name|rval
argument_list|,
operator|*
name|via_virtual_ptr
argument_list|)
operator|!=
name|was
condition|)
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|base_binfo
argument_list|)
operator|=
name|binfo
expr_stmt|;
if|if
condition|(
name|rval
operator|==
operator|-
literal|2
operator|&&
operator|*
name|via_virtual_ptr
operator|==
literal|0
condition|)
return|return
name|rval
return|;
undef|#
directive|undef
name|WATCH_VALUES
block|}
block|}
return|return
name|rval
return|;
block|}
end_block

begin_comment
comment|/* Return the number of levels between type PARENT and the type given    in BINFO, following the leftmost path to PARENT not found along a    virtual path, if there are no real PARENTs (all come from virtual    base classes), then follow the leftmost path to PARENT.     Return -1 if TYPE is not derived from PARENT.    Return -2 if PARENT is an ambiguous base class of TYPE, and PROTECT is     non-negative.    Return -3 if PARENT is private to TYPE, and PROTECT is non-zero.     If PATH_PTR is non-NULL, then also build the list of types    from PARENT to TYPE, with TREE_VIA_VIRUAL and TREE_VIA_PUBLIC    set.     PARENT can also be a binfo, in which case that exact parent is found    and no other.  convert_pointer_to_real uses this functionality.     If BINFO is a binfo, its BINFO_INHERITANCE_CHAIN will be left alone.  */
end_comment

begin_function
name|int
name|get_base_distance
parameter_list|(
name|parent
parameter_list|,
name|binfo
parameter_list|,
name|protect
parameter_list|,
name|path_ptr
parameter_list|)
specifier|register
name|tree
name|parent
decl_stmt|,
name|binfo
decl_stmt|;
name|int
name|protect
decl_stmt|;
name|tree
modifier|*
name|path_ptr
decl_stmt|;
block|{
name|int
name|rval
decl_stmt|;
name|int
name|rval_private
init|=
literal|0
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|tree
name|new_binfo
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|via_virtual
decl_stmt|;
name|int
name|watch_access
init|=
name|protect
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parent
argument_list|)
operator|!=
name|TREE_VEC
condition|)
name|parent
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|binfo
argument_list|)
operator|==
name|TREE_VEC
condition|)
name|type
operator|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_AGGR_TYPE_CODE
argument_list|(
name|TREE_CODE
argument_list|(
name|binfo
argument_list|)
argument_list|)
condition|)
block|{
name|type
operator|=
name|binfo
expr_stmt|;
name|binfo
operator|=
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|path_ptr
condition|)
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|binfo
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
name|my_friendly_abort
argument_list|(
literal|92
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
operator|==
name|type
operator|||
name|parent
operator|==
name|binfo
condition|)
block|{
comment|/* If the distance is 0, then we don't really need 	 a path pointer, but we shouldn't let garbage go back.  */
if|if
condition|(
name|path_ptr
condition|)
operator|*
name|path_ptr
operator|=
name|binfo
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|path_ptr
condition|)
name|watch_access
operator|=
literal|1
expr_stmt|;
name|rval
operator|=
name|get_base_distance_recursive
argument_list|(
name|binfo
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL_TREE
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|rval_private
argument_list|,
operator|&
name|new_binfo
argument_list|,
name|parent
argument_list|,
name|path_ptr
argument_list|,
name|watch_access
argument_list|,
operator|&
name|via_virtual
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dfs_walk
argument_list|(
name|binfo
argument_list|,
name|dfs_unmark
argument_list|,
name|markedp
argument_list|)
expr_stmt|;
comment|/* Access restrictions don't count if we found an ambiguous basetype.  */
if|if
condition|(
name|rval
operator|==
operator|-
literal|2
operator|&&
name|protect
operator|>=
literal|0
condition|)
name|rval_private
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rval
operator|&&
name|protect
operator|&&
name|rval_private
condition|)
return|return
operator|-
literal|3
return|;
comment|/* find real virtual base classes. */
if|if
condition|(
name|rval
operator|==
operator|-
literal|1
operator|&&
name|TREE_CODE
argument_list|(
name|parent
argument_list|)
operator|==
name|TREE_VEC
operator|&&
name|parent
operator|==
name|binfo_member
argument_list|(
name|BINFO_TYPE
argument_list|(
name|parent
argument_list|)
argument_list|,
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|parent
argument_list|)
operator|=
name|binfo
expr_stmt|;
name|new_binfo
operator|=
name|parent
expr_stmt|;
name|rval
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|path_ptr
condition|)
operator|*
name|path_ptr
operator|=
name|new_binfo
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* Search for a member with name NAME in a multiple inheritance lattice    specified by TYPE.  If it does not exist, return NULL_TREE.    If the member is ambiguously referenced, return `error_mark_node'.    Otherwise, return the FIELD_DECL.  */
end_comment

begin_comment
comment|/* Do a 1-level search for NAME as a member of TYPE.  The caller must    figure out whether it can access this field.  (Since it is only one    level, this is reasonable.)  */
end_comment

begin_function
specifier|static
name|tree
name|lookup_field_1
parameter_list|(
name|type
parameter_list|,
name|name
parameter_list|)
name|tree
name|type
decl_stmt|,
name|name
decl_stmt|;
block|{
specifier|register
name|tree
name|field
init|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_calls_lookup_field_1
operator|++
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|field
condition|)
block|{
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_fields_searched
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
name|tree
name|temp
init|=
name|lookup_field_1
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|temp
condition|)
return|return
name|temp
return|;
block|}
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|==
name|name
condition|)
block|{
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|CONST_DECL
operator|)
operator|&&
name|DECL_ASSEMBLER_NAME
argument_list|(
name|field
argument_list|)
operator|!=
name|NULL
condition|)
name|GNU_xref_ref
argument_list|(
name|current_function_decl
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|field
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|field
return|;
block|}
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
comment|/* Not found.  */
if|if
condition|(
name|name
operator|==
name|_vptr_name
condition|)
block|{
comment|/* Give the user what s/he thinks s/he wants.  */
if|if
condition|(
name|TYPE_VIRTUAL_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|CLASSTYPE_VFIELD
argument_list|(
name|type
argument_list|)
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* There are a number of cases we need to be aware of here: 			 current_class_type	current_function_decl    * global			NULL			NULL    * fn-local			NULL			SET    * class-local		SET			NULL    * class->fn			SET			SET    * fn->class			SET			SET     Those last two make life interesting.  If we're in a function which is    itself inside a class, we need decls to go into the fn's decls (our    second case below).  But if we're in a class and the class itself is    inside a function, we need decls to go into the decls for the class.  To    achieve this last goal, we must see if, when both current_class_decl and    current_function_decl are set, the class was declared inside that    function.  If so, we know to put the decls into the class's scope.  */
end_comment

begin_function
name|tree
name|current_scope
parameter_list|()
block|{
if|if
condition|(
name|current_function_decl
operator|==
name|NULL_TREE
condition|)
return|return
name|current_class_type
return|;
if|if
condition|(
name|current_class_type
operator|==
name|NULL_TREE
condition|)
return|return
name|current_function_decl
return|;
if|if
condition|(
name|DECL_CLASS_CONTEXT
argument_list|(
name|current_function_decl
argument_list|)
operator|==
name|current_class_type
condition|)
return|return
name|current_function_decl
return|;
return|return
name|current_class_type
return|;
block|}
end_function

begin_comment
comment|/* Compute the access of FIELD.  This is done by computing    the access available to each type in BASETYPES (which comes    as a list of [via_public/basetype] in reverse order, namely base    class before derived class).  The first one which defines a    access defines the access for the field.  Otherwise, the    access of the field is that which occurs normally.     Uses global variables CURRENT_CLASS_TYPE and    CURRENT_FUNCTION_DECL to use friend relationships    if necessary.     This will be static when lookup_fnfield comes into this file.     access_public means that the field can be accessed by the current lexical    scope.     access_protected means that the field cannot be accessed by the current    lexical scope because it is protected.     access_private means that the field cannot be accessed by the current    lexical scope because it is private. */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_define
define|#
directive|define
name|PUBLIC_RETURN
value|return (DECL_PUBLIC (field) = 1), access_public
end_define

begin_define
define|#
directive|define
name|PROTECTED_RETURN
value|return (DECL_PROTECTED (field) = 1), access_protected
end_define

begin_define
define|#
directive|define
name|PRIVATE_RETURN
value|return (DECL_PRIVATE (field) = 1), access_private
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PUBLIC_RETURN
value|return access_public
end_define

begin_define
define|#
directive|define
name|PROTECTED_RETURN
value|return access_protected
end_define

begin_define
define|#
directive|define
name|PRIVATE_RETURN
value|return access_private
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Disabled with DECL_PUBLIC&c.  */
end_comment

begin_endif
unit|static tree previous_scope = NULL_TREE;
endif|#
directive|endif
end_endif

begin_function
name|enum
name|access_type
name|compute_access
parameter_list|(
name|basetype_path
parameter_list|,
name|field
parameter_list|)
name|tree
name|basetype_path
decl_stmt|,
name|field
decl_stmt|;
block|{
name|enum
name|access_type
name|access
decl_stmt|;
name|tree
name|types
decl_stmt|;
name|tree
name|context
decl_stmt|;
name|int
name|protected_ok
decl_stmt|,
name|via_protected
decl_stmt|;
if|#
directive|if
literal|1
comment|/* Replaces static decl above.  */
name|tree
name|previous_scope
decl_stmt|;
endif|#
directive|endif
name|int
name|static_mem
init|=
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|field
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|&&
name|TREE_STATIC
argument_list|(
name|field
argument_list|)
operator|)
operator|)
decl_stmt|;
comment|/* The field lives in the current class.  */
if|if
condition|(
name|BINFO_TYPE
argument_list|(
name|basetype_path
argument_list|)
operator|==
name|current_class_type
condition|)
return|return
name|access_public
return|;
if|#
directive|if
literal|0
comment|/* Disabled until pushing function scope clears these out.  If ever.  */
comment|/* Make these special cases fast.  */
block|if (current_scope () == previous_scope)     {       if (DECL_PUBLIC (field)) 	return access_public;       if (DECL_PROTECTED (field)) 	return access_protected;       if (DECL_PRIVATE (field)) 	return access_private;     }
endif|#
directive|endif
name|previous_scope
operator|=
name|current_scope
argument_list|()
expr_stmt|;
name|context
operator|=
name|DECL_CLASS_CONTEXT
argument_list|(
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|==
name|NULL_TREE
condition|)
name|context
operator|=
name|DECL_CONTEXT
argument_list|(
name|field
argument_list|)
expr_stmt|;
comment|/* Fields coming from nested anonymous unions have their DECL_CLASS_CONTEXT      slot set to the union type rather than the record type containing      the anonymous union.  In this case, DECL_FIELD_CONTEXT is correct.  */
if|if
condition|(
name|context
operator|&&
name|TREE_CODE
argument_list|(
name|context
argument_list|)
operator|==
name|UNION_TYPE
operator|&&
name|ANON_AGGRNAME_P
argument_list|(
name|TYPE_IDENTIFIER
argument_list|(
name|context
argument_list|)
argument_list|)
condition|)
name|context
operator|=
name|DECL_FIELD_CONTEXT
argument_list|(
name|field
argument_list|)
expr_stmt|;
comment|/* Virtual function tables are never private.  But we should know that      we are looking for this, and not even try to hide it.  */
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|&&
name|VFIELD_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
literal|1
condition|)
name|PUBLIC_RETURN
expr_stmt|;
comment|/* Member found immediately within object.  */
if|if
condition|(
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|basetype_path
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* Are we (or an enclosing scope) friends with the class that has          FIELD? */
if|if
condition|(
name|is_friend
argument_list|(
name|context
argument_list|,
name|previous_scope
argument_list|)
condition|)
name|PUBLIC_RETURN
expr_stmt|;
comment|/* If it's private, it's private, you letch.  */
if|if
condition|(
name|TREE_PRIVATE
argument_list|(
name|field
argument_list|)
condition|)
name|PRIVATE_RETURN
expr_stmt|;
comment|/* ARM $11.5.  Member functions of a derived class can access the 	 non-static protected members of a base class only through a 	 pointer to the derived class, a reference to it, or an object 	 of it. Also any subsequently derived classes also have 	 access.  */
elseif|else
if|if
condition|(
name|TREE_PROTECTED
argument_list|(
name|field
argument_list|)
condition|)
block|{
if|if
condition|(
name|current_class_type
operator|&&
name|static_mem
operator|&&
name|ACCESSIBLY_DERIVED_FROM_P
argument_list|(
name|context
argument_list|,
name|current_class_type
argument_list|)
condition|)
name|PUBLIC_RETURN
expr_stmt|;
else|else
name|PROTECTED_RETURN
expr_stmt|;
block|}
else|else
name|PUBLIC_RETURN
expr_stmt|;
block|}
comment|/* must reverse more than one element */
name|basetype_path
operator|=
name|reverse_path
argument_list|(
name|basetype_path
argument_list|)
expr_stmt|;
name|types
operator|=
name|basetype_path
expr_stmt|;
name|via_protected
operator|=
literal|0
expr_stmt|;
name|access
operator|=
name|access_default
expr_stmt|;
name|protected_ok
operator|=
name|static_mem
operator|&&
name|current_class_type
operator|&&
name|ACCESSIBLY_DERIVED_FROM_P
argument_list|(
name|BINFO_TYPE
argument_list|(
name|types
argument_list|)
argument_list|,
name|current_class_type
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|tree
name|member
decl_stmt|;
name|tree
name|binfo
init|=
name|types
decl_stmt|;
name|tree
name|type
init|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|int
name|private_ok
init|=
literal|0
decl_stmt|;
comment|/* Friends of a class can see protected members of its bases.          Note that classes are their own friends.  */
if|if
condition|(
name|is_friend
argument_list|(
name|type
argument_list|,
name|previous_scope
argument_list|)
condition|)
block|{
name|protected_ok
operator|=
literal|1
expr_stmt|;
name|private_ok
operator|=
literal|1
expr_stmt|;
block|}
name|member
operator|=
name|purpose_member
argument_list|(
name|type
argument_list|,
name|DECL_ACCESS
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|member
condition|)
block|{
name|access
operator|=
operator|(
expr|enum
name|access_type
operator|)
name|TREE_VALUE
argument_list|(
name|member
argument_list|)
expr_stmt|;
break|break;
block|}
name|types
operator|=
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|types
argument_list|)
expr_stmt|;
comment|/* If the next type was VIA_PROTECTED, then fields of all remaining 	 classes past that one are *at least* protected.  */
if|if
condition|(
name|types
condition|)
block|{
if|if
condition|(
name|TREE_VIA_PROTECTED
argument_list|(
name|types
argument_list|)
condition|)
name|via_protected
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|TREE_VIA_PUBLIC
argument_list|(
name|types
argument_list|)
operator|&&
operator|!
name|private_ok
condition|)
block|{
name|access
operator|=
name|access_private
expr_stmt|;
break|break;
block|}
block|}
else|else
break|break;
block|}
name|reverse_path
argument_list|(
name|basetype_path
argument_list|)
expr_stmt|;
comment|/* No special visibilities apply.  Use normal rules.  */
if|if
condition|(
name|access
operator|==
name|access_default
condition|)
block|{
if|if
condition|(
name|is_friend
argument_list|(
name|context
argument_list|,
name|previous_scope
argument_list|)
condition|)
name|access
operator|=
name|access_public
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_PRIVATE
argument_list|(
name|field
argument_list|)
condition|)
name|access
operator|=
name|access_private
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_PROTECTED
argument_list|(
name|field
argument_list|)
condition|)
name|access
operator|=
name|access_protected
expr_stmt|;
else|else
name|access
operator|=
name|access_public
expr_stmt|;
block|}
if|if
condition|(
name|access
operator|==
name|access_public
operator|&&
name|via_protected
condition|)
name|access
operator|=
name|access_protected
expr_stmt|;
if|if
condition|(
name|access
operator|==
name|access_protected
operator|&&
name|protected_ok
condition|)
name|access
operator|=
name|access_public
expr_stmt|;
if|#
directive|if
literal|0
block|if (access == access_public)     DECL_PUBLIC (field) = 1;   else if (access == access_protected)     DECL_PROTECTED (field) = 1;   else if (access == access_private)     DECL_PRIVATE (field) = 1;   else my_friendly_abort (96);
endif|#
directive|endif
return|return
name|access
return|;
block|}
end_function

begin_comment
comment|/* Routine to see if the sub-object denoted by the binfo PARENT can be    found as a base class and sub-object of the object denoted by    BINFO.  This routine relies upon binfos not being shared, except    for binfos for virtual bases.  */
end_comment

begin_function
specifier|static
name|int
name|is_subobject_of_p
parameter_list|(
name|parent
parameter_list|,
name|binfo
parameter_list|)
name|tree
name|parent
decl_stmt|,
name|binfo
decl_stmt|;
block|{
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baselinks
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|parent
operator|==
name|binfo
condition|)
return|return
literal|1
return|;
comment|/* Process and/or queue base types.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baselinks
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
condition|)
name|base_binfo
operator|=
name|TYPE_BINFO
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_subobject_of_p
argument_list|(
name|parent
argument_list|,
name|base_binfo
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* See if a one FIELD_DECL hides another.  This routine is meant to    correspond to ANSI working paper Sept 17, 1992 10p4.  The two    binfos given are the binfos corresponding to the particular places    the FIELD_DECLs are found.  This routine relies upon binfos not    being shared, except for virtual bases. */
end_comment

begin_function
specifier|static
name|int
name|hides
parameter_list|(
name|hider_binfo
parameter_list|,
name|hidee_binfo
parameter_list|)
name|tree
name|hider_binfo
decl_stmt|,
name|hidee_binfo
decl_stmt|;
block|{
comment|/* hider hides hidee, if hider has hidee as a base class and      the instance of hidee is a sub-object of hider.  The first      part is always true is the second part is true.       When hider and hidee are the same (two ways to get to the exact      same member) we consider either one as hiding the other. */
return|return
name|is_subobject_of_p
argument_list|(
name|hidee_binfo
argument_list|,
name|hider_binfo
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Very similar to lookup_fnfields_1 but it ensures that at least one    function was declared inside the class given by TYPE.  It really should    only return functions that match the given TYPE.  */
end_comment

begin_function
specifier|static
name|int
name|lookup_fnfields_here
parameter_list|(
name|type
parameter_list|,
name|name
parameter_list|)
name|tree
name|type
decl_stmt|,
name|name
decl_stmt|;
block|{
name|int
name|index
init|=
name|lookup_fnfields_1
argument_list|(
name|type
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|tree
name|fndecls
decl_stmt|;
if|if
condition|(
name|index
operator|<=
literal|0
condition|)
return|return
name|index
return|;
name|fndecls
operator|=
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
argument_list|,
name|index
argument_list|)
expr_stmt|;
while|while
condition|(
name|fndecls
condition|)
block|{
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|DECL_CLASS_CONTEXT
argument_list|(
name|fndecls
argument_list|)
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|index
return|;
name|fndecls
operator|=
name|TREE_CHAIN
argument_list|(
name|fndecls
argument_list|)
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Look for a field named NAME in an inheritance lattice dominated by    XBASETYPE.  PROTECT is zero if we can avoid computing access    information, otherwise it is 1.  WANT_TYPE is 1 when we should only    return TYPE_DECLs, if no TYPE_DECL can be found return NULL_TREE.     It was not clear what should happen if WANT_TYPE is set, and an    ambiguity is found.  At least one use (lookup_name) to not see    the error.  */
end_comment

begin_function
name|tree
name|lookup_field
parameter_list|(
name|xbasetype
parameter_list|,
name|name
parameter_list|,
name|protect
parameter_list|,
name|want_type
parameter_list|)
specifier|register
name|tree
name|xbasetype
decl_stmt|,
name|name
decl_stmt|;
name|int
name|protect
decl_stmt|,
name|want_type
decl_stmt|;
block|{
name|int
name|head
init|=
literal|0
decl_stmt|,
name|tail
init|=
literal|0
decl_stmt|;
name|tree
name|rval
decl_stmt|,
name|rval_binfo
init|=
name|NULL_TREE
decl_stmt|,
name|rval_binfo_h
decl_stmt|;
name|tree
name|type
decl_stmt|,
name|basetype_chain
decl_stmt|,
name|basetype_path
decl_stmt|;
name|enum
name|access_type
name|this_v
init|=
name|access_default
decl_stmt|;
name|tree
name|entry
decl_stmt|,
name|binfo
decl_stmt|,
name|binfo_h
decl_stmt|;
name|enum
name|access_type
name|own_access
init|=
name|access_default
decl_stmt|;
name|int
name|vbase_name_p
init|=
name|VBASE_NAME_P
argument_list|(
name|name
argument_list|)
decl_stmt|;
comment|/* rval_binfo is the binfo associated with the found member, note,      this can be set with useful information, even when rval is not      set, because it must deal with ALL members, not just non-function      members.  It is used for ambiguity checking and the hidden      checks.  Whereas rval is only set if a proper (not hidden)      non-function member is found.  */
comment|/* rval_binfo_h and binfo_h are binfo values used when we perform the      hiding checks, as virtual base classes may not be shared.  The strategy      is we always go into the the binfo hierarchy owned by TYPE_BINFO of      virtual base classes, as we cross virtual base class lines.  This way      we know that binfo of a virtual base class will always == itself when      found along any line.  (mrs)  */
name|char
modifier|*
name|errstr
init|=
literal|0
decl_stmt|;
comment|/* Set this to nonzero if we don't know how to compute      accurate error messages for access control.  */
name|int
name|index
init|=
name|MEMOIZED_HASH_FN
argument_list|(
name|name
argument_list|)
decl_stmt|;
comment|/* If we are looking for a constructor in a templated type, use the      unspecialized name, as that is how we store it.  */
if|if
condition|(
name|IDENTIFIER_TEMPLATE
argument_list|(
name|name
argument_list|)
condition|)
name|name
operator|=
name|constructor_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|xbasetype
argument_list|)
operator|==
name|TREE_VEC
condition|)
block|{
name|type
operator|=
name|BINFO_TYPE
argument_list|(
name|xbasetype
argument_list|)
expr_stmt|;
name|basetype_path
operator|=
name|xbasetype
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_AGGR_TYPE_CODE
argument_list|(
name|TREE_CODE
argument_list|(
name|xbasetype
argument_list|)
argument_list|)
condition|)
block|{
name|type
operator|=
name|xbasetype
expr_stmt|;
name|basetype_path
operator|=
name|TYPE_BINFO
argument_list|(
name|xbasetype
argument_list|)
expr_stmt|;
name|BINFO_VIA_PUBLIC
argument_list|(
name|basetype_path
argument_list|)
operator|=
literal|1
expr_stmt|;
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|basetype_path
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
name|my_friendly_abort
argument_list|(
literal|97
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_MTABLE_ENTRY
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
name|tem
init|=
name|MEMOIZED_FIELDS
argument_list|(
name|CLASSTYPE_MTABLE_ENTRY
argument_list|(
name|type
argument_list|)
argument_list|,
name|index
argument_list|)
decl_stmt|;
while|while
condition|(
name|tem
operator|&&
name|TREE_PURPOSE
argument_list|(
name|tem
argument_list|)
operator|!=
name|name
condition|)
block|{
name|memoized_fields_searched
index|[
literal|0
index|]
operator|++
expr_stmt|;
name|tem
operator|=
name|TREE_CHAIN
argument_list|(
name|tem
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tem
condition|)
block|{
if|if
condition|(
name|protect
operator|&&
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|DECL_FIELD_CONTEXT
argument_list|(
name|TREE_VALUE
argument_list|(
name|tem
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|tem
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|memoized_fast_rejects
index|[
literal|0
index|]
operator|+=
literal|1
expr_stmt|;
else|else
name|memoized_fast_finds
index|[
literal|0
index|]
operator|+=
literal|1
expr_stmt|;
return|return
name|TREE_VALUE
argument_list|(
name|tem
argument_list|)
return|;
block|}
block|}
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_calls_lookup_field
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|protect
operator|&&
name|flag_memoize_lookups
operator|&&
operator|!
name|global_bindings_p
argument_list|()
condition|)
name|entry
operator|=
name|make_memoized_table_entry
argument_list|(
name|type
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|entry
operator|=
literal|0
expr_stmt|;
name|rval
operator|=
name|lookup_field_1
argument_list|(
name|type
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|||
name|lookup_fnfields_here
argument_list|(
name|type
argument_list|,
name|name
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|rval_binfo
operator|=
name|basetype_path
expr_stmt|;
name|rval_binfo_h
operator|=
name|rval_binfo
expr_stmt|;
block|}
if|if
condition|(
name|rval
operator|&&
name|TREE_CODE
argument_list|(
name|rval
argument_list|)
operator|!=
name|TYPE_DECL
operator|&&
name|want_type
condition|)
name|rval
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|rval
condition|)
block|{
if|if
condition|(
name|protect
condition|)
block|{
if|if
condition|(
name|TREE_PRIVATE
argument_list|(
name|rval
argument_list|)
operator||
name|TREE_PROTECTED
argument_list|(
name|rval
argument_list|)
condition|)
name|this_v
operator|=
name|compute_access
argument_list|(
name|basetype_path
argument_list|,
name|rval
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rval
argument_list|)
operator|==
name|CONST_DECL
condition|)
block|{
if|if
condition|(
name|this_v
operator|==
name|access_private
condition|)
name|errstr
operator|=
literal|"enum `%D' is a private value of class `%T'"
expr_stmt|;
elseif|else
if|if
condition|(
name|this_v
operator|==
name|access_protected
condition|)
name|errstr
operator|=
literal|"enum `%D' is a protected value of class `%T'"
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|this_v
operator|==
name|access_private
condition|)
name|errstr
operator|=
literal|"member `%D' is a private member of class `%T'"
expr_stmt|;
elseif|else
if|if
condition|(
name|this_v
operator|==
name|access_protected
condition|)
name|errstr
operator|=
literal|"member `%D' is a protected member of class `%T'"
expr_stmt|;
block|}
block|}
if|if
condition|(
name|entry
condition|)
block|{
if|if
condition|(
name|errstr
condition|)
block|{
comment|/* This depends on behavior of lookup_field_1!  */
name|tree
name|error_string
init|=
name|my_build_string
argument_list|(
name|errstr
argument_list|)
decl_stmt|;
name|TREE_TYPE
argument_list|(
name|entry
argument_list|)
operator|=
name|error_string
expr_stmt|;
block|}
else|else
block|{
comment|/* Let entry know there is no problem with this access.  */
name|TREE_TYPE
argument_list|(
name|entry
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|TREE_VALUE
argument_list|(
name|entry
argument_list|)
operator|=
name|rval
expr_stmt|;
block|}
if|if
condition|(
name|errstr
operator|&&
name|protect
condition|)
block|{
name|cp_error
argument_list|(
name|errstr
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|rval
return|;
block|}
name|basetype_chain
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|basetype_path
argument_list|)
expr_stmt|;
name|TREE_VIA_PUBLIC
argument_list|(
name|basetype_chain
argument_list|)
operator|=
name|TREE_VIA_PUBLIC
argument_list|(
name|basetype_path
argument_list|)
expr_stmt|;
name|TREE_VIA_PROTECTED
argument_list|(
name|basetype_chain
argument_list|)
operator|=
name|TREE_VIA_PROTECTED
argument_list|(
name|basetype_path
argument_list|)
expr_stmt|;
name|TREE_VIA_VIRTUAL
argument_list|(
name|basetype_chain
argument_list|)
operator|=
name|TREE_VIA_VIRTUAL
argument_list|(
name|basetype_path
argument_list|)
expr_stmt|;
comment|/* The ambiguity check relies upon breadth first searching. */
name|search_stack
operator|=
name|push_search_level
argument_list|(
name|search_stack
argument_list|,
operator|&
name|search_obstack
argument_list|)
expr_stmt|;
name|binfo
operator|=
name|basetype_path
expr_stmt|;
name|binfo_h
operator|=
name|binfo
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baselinks
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
name|tree
name|nval
decl_stmt|;
comment|/* Process and/or queue base types.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baselinks
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|BINFO_FIELDS_MARKED
argument_list|(
name|base_binfo
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tree
name|btypes
decl_stmt|;
name|SET_BINFO_FIELDS_MARKED
argument_list|(
name|base_binfo
argument_list|)
expr_stmt|;
name|btypes
operator|=
name|my_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|base_binfo
argument_list|,
name|basetype_chain
argument_list|)
expr_stmt|;
name|TREE_VIA_PUBLIC
argument_list|(
name|btypes
argument_list|)
operator|=
name|TREE_VIA_PUBLIC
argument_list|(
name|base_binfo
argument_list|)
expr_stmt|;
name|TREE_VIA_PROTECTED
argument_list|(
name|btypes
argument_list|)
operator|=
name|TREE_VIA_PROTECTED
argument_list|(
name|base_binfo
argument_list|)
expr_stmt|;
name|TREE_VIA_VIRTUAL
argument_list|(
name|btypes
argument_list|)
operator|=
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
condition|)
name|btypes
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|TYPE_BINFO
argument_list|(
name|BINFO_TYPE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|BINFO_BASETYPES
argument_list|(
name|binfo_h
argument_list|)
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|btypes
argument_list|)
expr_stmt|;
else|else
name|btypes
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_VEC_ELT
argument_list|(
name|BINFO_BASETYPES
argument_list|(
name|binfo_h
argument_list|)
argument_list|,
name|i
argument_list|)
argument_list|,
name|btypes
argument_list|)
expr_stmt|;
name|obstack_ptr_grow
argument_list|(
operator|&
name|search_obstack
argument_list|,
name|btypes
argument_list|)
expr_stmt|;
name|tail
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|tail
operator|>=
name|search_stack
operator|->
name|limit
condition|)
name|my_friendly_abort
argument_list|(
literal|98
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Process head of queue, if one exists.  */
if|if
condition|(
name|head
operator|>=
name|tail
condition|)
break|break;
name|basetype_chain
operator|=
name|search_stack
operator|->
name|first
index|[
name|head
operator|++
index|]
expr_stmt|;
name|binfo_h
operator|=
name|TREE_VALUE
argument_list|(
name|basetype_chain
argument_list|)
expr_stmt|;
name|basetype_chain
operator|=
name|TREE_CHAIN
argument_list|(
name|basetype_chain
argument_list|)
expr_stmt|;
name|basetype_path
operator|=
name|TREE_VALUE
argument_list|(
name|basetype_chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|basetype_chain
argument_list|)
condition|)
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|basetype_path
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|basetype_chain
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|basetype_path
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|binfo
operator|=
name|basetype_path
expr_stmt|;
name|type
operator|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
comment|/* See if we can find NAME in TYPE.  If RVAL is nonzero, 	 and we do find NAME in TYPE, verify that such a second 	 sighting is in fact legal.  */
name|nval
operator|=
name|lookup_field_1
argument_list|(
name|type
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|nval
operator|||
name|lookup_fnfields_here
argument_list|(
name|type
argument_list|,
name|name
argument_list|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|nval
operator|&&
name|nval
operator|==
name|rval
operator|&&
name|SHARED_MEMBER_P
argument_list|(
name|nval
argument_list|)
condition|)
block|{
comment|/* This is ok, the member found is the same [class.ambig] */
block|}
elseif|else
if|if
condition|(
name|rval_binfo
operator|&&
name|hides
argument_list|(
name|rval_binfo_h
argument_list|,
name|binfo_h
argument_list|)
condition|)
block|{
comment|/* This is ok, the member found is in rval_binfo, not 		 here (binfo). */
block|}
elseif|else
if|if
condition|(
name|rval_binfo
operator|==
name|NULL_TREE
operator|||
name|hides
argument_list|(
name|binfo_h
argument_list|,
name|rval_binfo_h
argument_list|)
condition|)
block|{
comment|/* This is ok, the member found is here (binfo), not in 		 rval_binfo. */
if|if
condition|(
name|nval
condition|)
block|{
name|rval
operator|=
name|nval
expr_stmt|;
if|if
condition|(
name|entry
operator|||
name|protect
condition|)
name|this_v
operator|=
name|compute_access
argument_list|(
name|basetype_path
argument_list|,
name|rval
argument_list|)
expr_stmt|;
comment|/* These may look ambiguous, but they really are not.  */
if|if
condition|(
name|vbase_name_p
condition|)
break|break;
block|}
else|else
block|{
comment|/* Undo finding it before, as something else hides it. */
name|rval
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|rval_binfo
operator|=
name|binfo
expr_stmt|;
name|rval_binfo_h
operator|=
name|binfo_h
expr_stmt|;
block|}
else|else
block|{
comment|/* This is ambiguous. */
name|errstr
operator|=
literal|"request for member `%D' is ambiguous"
expr_stmt|;
name|protect
operator|=
literal|2
expr_stmt|;
break|break;
block|}
block|}
block|}
block|{
name|tree
modifier|*
name|tp
init|=
name|search_stack
operator|->
name|first
decl_stmt|;
name|tree
modifier|*
name|search_tail
init|=
name|tp
operator|+
name|tail
decl_stmt|;
if|if
condition|(
name|entry
condition|)
name|TREE_VALUE
argument_list|(
name|entry
argument_list|)
operator|=
name|rval
expr_stmt|;
if|if
condition|(
name|want_type
operator|&&
operator|(
name|rval
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|rval
argument_list|)
operator|!=
name|TYPE_DECL
operator|)
condition|)
block|{
name|rval
operator|=
name|NULL_TREE
expr_stmt|;
name|errstr
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If this FIELD_DECL defines its own access level, deal with that.  */
if|if
condition|(
name|rval
operator|&&
name|errstr
operator|==
literal|0
operator|&&
operator|(
operator|(
name|protect
operator|&
literal|1
operator|)
operator|||
name|entry
operator|)
operator|&&
name|DECL_LANG_SPECIFIC
argument_list|(
name|rval
argument_list|)
operator|&&
name|DECL_ACCESS
argument_list|(
name|rval
argument_list|)
condition|)
block|{
while|while
condition|(
name|tp
operator|<
name|search_tail
condition|)
block|{
comment|/* If is possible for one of the derived types on the path to 	       have defined special access for this field.  Look for such 	       declarations and report an error if a conflict is found.  */
name|enum
name|access_type
name|new_v
decl_stmt|;
if|if
condition|(
name|this_v
operator|!=
name|access_default
condition|)
name|new_v
operator|=
name|compute_access
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|)
argument_list|,
name|rval
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_v
operator|!=
name|access_default
operator|&&
name|new_v
operator|!=
name|this_v
condition|)
block|{
name|errstr
operator|=
literal|"conflicting access to member `%D'"
expr_stmt|;
name|this_v
operator|=
name|access_default
expr_stmt|;
block|}
name|own_access
operator|=
name|new_v
expr_stmt|;
name|CLEAR_BINFO_FIELDS_MARKED
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|tp
operator|+=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|tp
operator|<
name|search_tail
condition|)
block|{
name|CLEAR_BINFO_FIELDS_MARKED
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|tp
operator|+=
literal|1
expr_stmt|;
block|}
block|}
block|}
name|search_stack
operator|=
name|pop_search_level
argument_list|(
name|search_stack
argument_list|)
expr_stmt|;
if|if
condition|(
name|errstr
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|own_access
operator|==
name|access_private
condition|)
name|errstr
operator|=
literal|"member `%D' declared private"
expr_stmt|;
elseif|else
if|if
condition|(
name|own_access
operator|==
name|access_protected
condition|)
name|errstr
operator|=
literal|"member `%D' declared protected"
expr_stmt|;
elseif|else
if|if
condition|(
name|this_v
operator|==
name|access_private
condition|)
name|errstr
operator|=
name|TREE_PRIVATE
argument_list|(
name|rval
argument_list|)
condition|?
literal|"member `%D' is private"
else|:
literal|"member `%D' is from private base class"
expr_stmt|;
elseif|else
if|if
condition|(
name|this_v
operator|==
name|access_protected
condition|)
name|errstr
operator|=
name|TREE_PROTECTED
argument_list|(
name|rval
argument_list|)
condition|?
literal|"member `%D' is protected"
else|:
literal|"member `%D' is from protected base class"
expr_stmt|;
block|}
if|if
condition|(
name|entry
condition|)
block|{
if|if
condition|(
name|errstr
condition|)
block|{
name|tree
name|error_string
init|=
name|my_build_string
argument_list|(
name|errstr
argument_list|)
decl_stmt|;
comment|/* Save error message with entry.  */
name|TREE_TYPE
argument_list|(
name|entry
argument_list|)
operator|=
name|error_string
expr_stmt|;
block|}
else|else
block|{
comment|/* Mark entry as having no error string.  */
name|TREE_TYPE
argument_list|(
name|entry
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|errstr
operator|&&
name|protect
condition|)
block|{
name|cp_error
argument_list|(
name|errstr
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|rval
operator|=
name|error_mark_node
expr_stmt|;
block|}
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* Try to find NAME inside a nested class.  */
end_comment

begin_function
name|tree
name|lookup_nested_field
parameter_list|(
name|name
parameter_list|,
name|complain
parameter_list|)
name|tree
name|name
decl_stmt|;
name|int
name|complain
decl_stmt|;
block|{
specifier|register
name|tree
name|t
decl_stmt|;
name|tree
name|id
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|current_class_type
argument_list|)
condition|)
block|{
comment|/* Climb our way up the nested ladder, seeing if we're trying to 	 modify a field in an enclosing class.  If so, we should only 	 be able to modify if it's static.  */
for|for
control|(
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|current_class_type
argument_list|)
init|;
name|t
operator|&&
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|)
operator|!=
name|RECORD_TYPE
condition|)
break|break;
comment|/* N.B.: lookup_field will do the access checking for us */
name|id
operator|=
name|lookup_field
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|,
name|name
argument_list|,
name|complain
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|==
name|error_mark_node
condition|)
block|{
name|id
operator|=
name|NULL_TREE
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|id
operator|!=
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|id
argument_list|)
operator|&&
name|TREE_TYPE
argument_list|(
name|id
argument_list|)
operator|!=
name|error_mark_node
condition|)
block|{
if|if
condition|(
name|complain
condition|)
block|{
comment|/* At parse time, we don't want to give this error, since 			 we won't have enough state to make this kind of 			 decision properly.  But there are times (e.g., with 			 enums in nested classes) when we do need to call 			 this fn at parse time.  So, in those cases, we pass 			 complain as a 0 and just return a NULL_TREE.  */
name|error
argument_list|(
literal|"assignment to non-static member `%s' of enclosing class `%s'"
argument_list|,
name|lang_printable_name
argument_list|(
name|id
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TYPE_IDENTIFIER
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Mark this for do_identifier().  It would otherwise 			 claim that the variable was undeclared.  */
name|TREE_TYPE
argument_list|(
name|id
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
else|else
block|{
name|id
operator|=
name|NULL_TREE
expr_stmt|;
continue|continue;
block|}
block|}
break|break;
block|}
block|}
block|}
return|return
name|id
return|;
block|}
end_function

begin_comment
comment|/* TYPE is a class type. Return the index of the fields within    the method vector with name NAME, or -1 is no such field exists.  */
end_comment

begin_function
specifier|static
name|int
name|lookup_fnfields_1
parameter_list|(
name|type
parameter_list|,
name|name
parameter_list|)
name|tree
name|type
decl_stmt|,
name|name
decl_stmt|;
block|{
specifier|register
name|tree
name|method_vec
init|=
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|method_vec
operator|!=
literal|0
condition|)
block|{
specifier|register
name|tree
modifier|*
name|methods
init|=
operator|&
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|register
name|tree
modifier|*
name|end
init|=
name|TREE_VEC_END
argument_list|(
name|method_vec
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_calls_lookup_fnfields_1
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|*
name|methods
operator|&&
name|name
operator|==
name|constructor_name
argument_list|(
name|type
argument_list|)
condition|)
return|return
literal|0
return|;
while|while
condition|(
operator|++
name|methods
operator|!=
name|end
condition|)
block|{
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_outer_fields_searched
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|DECL_NAME
argument_list|(
operator|*
name|methods
argument_list|)
operator|==
name|name
condition|)
break|break;
block|}
if|if
condition|(
name|methods
operator|!=
name|end
condition|)
return|return
name|methods
operator|-
operator|&
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|0
argument_list|)
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Starting from BASETYPE, return a TREE_BASELINK-like object    which gives the following information (in a list):     TREE_TYPE: list of basetypes needed to get to...    TREE_VALUE: list of all functions in of given type    which have name NAME.     No access information is computed by this function,    other then to adorn the list of basetypes with    TREE_VIA_PUBLIC.     If there are two ways to find a name (two members), if COMPLAIN is    non-zero, then error_mark_node is returned, and an error message is    printed, otherwise, just an error_mark_node is returned.     As a special case, is COMPLAIN is -1, we don't complain, and we    don't return error_mark_node, but rather the complete list of    virtuals.  This is used by get_virtuals_named_this.  */
end_comment

begin_function
name|tree
name|lookup_fnfields
parameter_list|(
name|basetype_path
parameter_list|,
name|name
parameter_list|,
name|complain
parameter_list|)
name|tree
name|basetype_path
decl_stmt|,
name|name
decl_stmt|;
name|int
name|complain
decl_stmt|;
block|{
name|int
name|head
init|=
literal|0
decl_stmt|,
name|tail
init|=
literal|0
decl_stmt|;
name|tree
name|type
decl_stmt|,
name|rval
decl_stmt|,
name|rval_binfo
init|=
name|NULL_TREE
decl_stmt|,
name|rvals
init|=
name|NULL_TREE
decl_stmt|,
name|rval_binfo_h
decl_stmt|;
name|tree
name|entry
decl_stmt|,
name|binfo
decl_stmt|,
name|basetype_chain
decl_stmt|,
name|binfo_h
decl_stmt|;
name|int
name|find_all
init|=
literal|0
decl_stmt|;
comment|/* rval_binfo is the binfo associated with the found member, note,      this can be set with useful information, even when rval is not      set, because it must deal with ALL members, not just function      members.  It is used for ambiguity checking and the hidden      checks.  Whereas rval is only set if a proper (not hidden)      function member is found.  */
comment|/* rval_binfo_h and binfo_h are binfo values used when we perform the      hiding checks, as virtual base classes may not be shared.  The strategy      is we always go into the the binfo hierarchy owned by TYPE_BINFO of      virtual base classes, as we cross virtual base class lines.  This way      we know that binfo of a virtual base class will always == itself when      found along any line.  (mrs)  */
comment|/* For now, don't try this.  */
name|int
name|protect
init|=
name|complain
decl_stmt|;
name|char
modifier|*
name|errstr
init|=
literal|0
decl_stmt|;
comment|/* Set this to nonzero if we don't know how to compute      accurate error messages for access control.  */
name|int
name|index
init|=
name|MEMOIZED_HASH_FN
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|complain
operator|==
operator|-
literal|1
condition|)
block|{
name|find_all
operator|=
literal|1
expr_stmt|;
name|protect
operator|=
name|complain
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If we are looking for a constructor in a templated type, use the      unspecialized name, as that is how we store it.  */
if|if
condition|(
name|IDENTIFIER_TEMPLATE
argument_list|(
name|name
argument_list|)
condition|)
name|name
operator|=
name|constructor_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|binfo
operator|=
name|basetype_path
expr_stmt|;
name|binfo_h
operator|=
name|binfo
expr_stmt|;
name|type
operator|=
name|BINFO_TYPE
argument_list|(
name|basetype_path
argument_list|)
expr_stmt|;
comment|/* The memoization code is in need of maintenance. */
if|if
condition|(
operator|!
name|find_all
operator|&&
name|CLASSTYPE_MTABLE_ENTRY
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
name|tem
init|=
name|MEMOIZED_FNFIELDS
argument_list|(
name|CLASSTYPE_MTABLE_ENTRY
argument_list|(
name|type
argument_list|)
argument_list|,
name|index
argument_list|)
decl_stmt|;
while|while
condition|(
name|tem
operator|&&
name|TREE_PURPOSE
argument_list|(
name|tem
argument_list|)
operator|!=
name|name
condition|)
block|{
name|memoized_fields_searched
index|[
literal|1
index|]
operator|++
expr_stmt|;
name|tem
operator|=
name|TREE_CHAIN
argument_list|(
name|tem
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tem
condition|)
block|{
if|if
condition|(
name|protect
operator|&&
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|DECL_CLASS_CONTEXT
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tem
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|tem
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|memoized_fast_rejects
index|[
literal|1
index|]
operator|+=
literal|1
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
else|else
block|{
comment|/* Want to return this, but we must make sure 		 that access information is consistent.  */
name|tree
name|baselink
init|=
name|TREE_VALUE
argument_list|(
name|tem
argument_list|)
decl_stmt|;
name|tree
name|memoized_basetypes
init|=
name|TREE_PURPOSE
argument_list|(
name|baselink
argument_list|)
decl_stmt|;
name|tree
name|these_basetypes
init|=
name|basetype_path
decl_stmt|;
while|while
condition|(
name|memoized_basetypes
operator|&&
name|these_basetypes
condition|)
block|{
name|memoized_fields_searched
index|[
literal|1
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|memoized_basetypes
argument_list|)
operator|!=
name|these_basetypes
condition|)
break|break;
name|memoized_basetypes
operator|=
name|TREE_CHAIN
argument_list|(
name|memoized_basetypes
argument_list|)
expr_stmt|;
name|these_basetypes
operator|=
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|these_basetypes
argument_list|)
expr_stmt|;
block|}
comment|/* The following statement is true only when both are NULL.  */
if|if
condition|(
name|memoized_basetypes
operator|==
name|these_basetypes
condition|)
block|{
name|memoized_fast_finds
index|[
literal|1
index|]
operator|+=
literal|1
expr_stmt|;
return|return
name|TREE_VALUE
argument_list|(
name|tem
argument_list|)
return|;
block|}
comment|/* else, we must re-find this field by hand.  */
name|baselink
operator|=
name|tree_cons
argument_list|(
name|basetype_path
argument_list|,
name|TREE_VALUE
argument_list|(
name|baselink
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|baselink
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|baselink
return|;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_calls_lookup_fnfields
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|protect
operator|&&
name|flag_memoize_lookups
operator|&&
operator|!
name|global_bindings_p
argument_list|()
condition|)
name|entry
operator|=
name|make_memoized_table_entry
argument_list|(
name|type
argument_list|,
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|entry
operator|=
literal|0
expr_stmt|;
name|index
operator|=
name|lookup_fnfields_here
argument_list|(
name|type
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|>=
literal|0
operator|||
name|lookup_field_1
argument_list|(
name|type
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|rval_binfo
operator|=
name|basetype_path
expr_stmt|;
name|rval_binfo_h
operator|=
name|rval_binfo
expr_stmt|;
block|}
if|if
condition|(
name|index
operator|>=
literal|0
condition|)
block|{
name|rval
operator|=
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|rvals
operator|=
name|my_tree_cons
argument_list|(
name|basetype_path
argument_list|,
name|rval
argument_list|,
name|rvals
argument_list|)
expr_stmt|;
if|if
condition|(
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
operator|&&
name|CLASSTYPE_BASELINK_VEC
argument_list|(
name|type
argument_list|)
condition|)
name|TREE_TYPE
argument_list|(
name|rvals
argument_list|)
operator|=
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_BASELINK_VEC
argument_list|(
name|type
argument_list|)
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
condition|)
block|{
name|TREE_VALUE
argument_list|(
name|entry
argument_list|)
operator|=
name|rvals
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|entry
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
return|return
name|rvals
return|;
block|}
name|rval
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|basetype_path
operator|==
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|basetype_chain
operator|=
name|CLASSTYPE_BINFO_AS_LIST
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TREE_VIA_PUBLIC
argument_list|(
name|basetype_chain
argument_list|)
operator|=
literal|1
expr_stmt|;
name|BINFO_VIA_PUBLIC
argument_list|(
name|basetype_path
argument_list|)
operator|=
literal|1
expr_stmt|;
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|basetype_path
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
block|{
name|basetype_chain
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|basetype_path
argument_list|)
expr_stmt|;
name|TREE_VIA_PUBLIC
argument_list|(
name|basetype_chain
argument_list|)
operator|=
name|TREE_VIA_PUBLIC
argument_list|(
name|basetype_path
argument_list|)
expr_stmt|;
name|TREE_VIA_PROTECTED
argument_list|(
name|basetype_chain
argument_list|)
operator|=
name|TREE_VIA_PROTECTED
argument_list|(
name|basetype_path
argument_list|)
expr_stmt|;
name|TREE_VIA_VIRTUAL
argument_list|(
name|basetype_chain
argument_list|)
operator|=
name|TREE_VIA_VIRTUAL
argument_list|(
name|basetype_path
argument_list|)
expr_stmt|;
block|}
comment|/* The ambiguity check relies upon breadth first searching. */
name|search_stack
operator|=
name|push_search_level
argument_list|(
name|search_stack
argument_list|,
operator|&
name|search_obstack
argument_list|)
expr_stmt|;
name|binfo
operator|=
name|basetype_path
expr_stmt|;
name|binfo_h
operator|=
name|binfo
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baselinks
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
name|int
name|index
decl_stmt|;
comment|/* Process and/or queue base types.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baselinks
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|BINFO_FIELDS_MARKED
argument_list|(
name|base_binfo
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tree
name|btypes
decl_stmt|;
name|SET_BINFO_FIELDS_MARKED
argument_list|(
name|base_binfo
argument_list|)
expr_stmt|;
name|btypes
operator|=
name|my_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|base_binfo
argument_list|,
name|basetype_chain
argument_list|)
expr_stmt|;
name|TREE_VIA_PUBLIC
argument_list|(
name|btypes
argument_list|)
operator|=
name|TREE_VIA_PUBLIC
argument_list|(
name|base_binfo
argument_list|)
expr_stmt|;
name|TREE_VIA_PROTECTED
argument_list|(
name|btypes
argument_list|)
operator|=
name|TREE_VIA_PROTECTED
argument_list|(
name|base_binfo
argument_list|)
expr_stmt|;
name|TREE_VIA_VIRTUAL
argument_list|(
name|btypes
argument_list|)
operator|=
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
condition|)
name|btypes
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|TYPE_BINFO
argument_list|(
name|BINFO_TYPE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|BINFO_BASETYPES
argument_list|(
name|binfo_h
argument_list|)
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|btypes
argument_list|)
expr_stmt|;
else|else
name|btypes
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_VEC_ELT
argument_list|(
name|BINFO_BASETYPES
argument_list|(
name|binfo_h
argument_list|)
argument_list|,
name|i
argument_list|)
argument_list|,
name|btypes
argument_list|)
expr_stmt|;
name|obstack_ptr_grow
argument_list|(
operator|&
name|search_obstack
argument_list|,
name|btypes
argument_list|)
expr_stmt|;
name|tail
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|tail
operator|>=
name|search_stack
operator|->
name|limit
condition|)
name|my_friendly_abort
argument_list|(
literal|99
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Process head of queue, if one exists.  */
if|if
condition|(
name|head
operator|>=
name|tail
condition|)
break|break;
name|basetype_chain
operator|=
name|search_stack
operator|->
name|first
index|[
name|head
operator|++
index|]
expr_stmt|;
name|binfo_h
operator|=
name|TREE_VALUE
argument_list|(
name|basetype_chain
argument_list|)
expr_stmt|;
name|basetype_chain
operator|=
name|TREE_CHAIN
argument_list|(
name|basetype_chain
argument_list|)
expr_stmt|;
name|basetype_path
operator|=
name|TREE_VALUE
argument_list|(
name|basetype_chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|basetype_chain
argument_list|)
condition|)
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|basetype_path
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|basetype_chain
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|basetype_path
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|binfo
operator|=
name|basetype_path
expr_stmt|;
name|type
operator|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
comment|/* See if we can find NAME in TYPE.  If RVAL is nonzero, 	 and we do find NAME in TYPE, verify that such a second 	 sighting is in fact legal.  */
name|index
operator|=
name|lookup_fnfields_here
argument_list|(
name|type
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|>=
literal|0
operator|||
operator|(
name|lookup_field_1
argument_list|(
name|type
argument_list|,
name|name
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
operator|!
name|find_all
operator|)
condition|)
block|{
if|if
condition|(
name|rval_binfo
operator|&&
operator|!
name|find_all
operator|&&
name|hides
argument_list|(
name|rval_binfo_h
argument_list|,
name|binfo_h
argument_list|)
condition|)
block|{
comment|/* This is ok, the member found is in rval_binfo, not 		 here (binfo). */
block|}
elseif|else
if|if
condition|(
name|rval_binfo
operator|==
name|NULL_TREE
operator|||
name|find_all
operator|||
name|hides
argument_list|(
name|binfo_h
argument_list|,
name|rval_binfo_h
argument_list|)
condition|)
block|{
comment|/* This is ok, the member found is here (binfo), not in 		 rval_binfo. */
if|if
condition|(
name|index
operator|>=
literal|0
condition|)
block|{
name|rval
operator|=
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
argument_list|,
name|index
argument_list|)
expr_stmt|;
comment|/* Note, rvals can only be previously set if find_all is 		     true.  */
name|rvals
operator|=
name|my_tree_cons
argument_list|(
name|basetype_path
argument_list|,
name|rval
argument_list|,
name|rvals
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_BINFO_BASETYPES
argument_list|(
name|type
argument_list|)
operator|&&
name|CLASSTYPE_BASELINK_VEC
argument_list|(
name|type
argument_list|)
condition|)
name|TREE_TYPE
argument_list|(
name|rvals
argument_list|)
operator|=
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_BASELINK_VEC
argument_list|(
name|type
argument_list|)
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Undo finding it before, as something else hides it. */
name|rval
operator|=
name|NULL_TREE
expr_stmt|;
name|rvals
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|rval_binfo
operator|=
name|binfo
expr_stmt|;
name|rval_binfo_h
operator|=
name|binfo_h
expr_stmt|;
block|}
else|else
block|{
comment|/* This is ambiguous. */
name|errstr
operator|=
literal|"request for method `%D' is ambiguous"
expr_stmt|;
name|rvals
operator|=
name|error_mark_node
expr_stmt|;
break|break;
block|}
block|}
block|}
block|{
name|tree
modifier|*
name|tp
init|=
name|search_stack
operator|->
name|first
decl_stmt|;
name|tree
modifier|*
name|search_tail
init|=
name|tp
operator|+
name|tail
decl_stmt|;
while|while
condition|(
name|tp
operator|<
name|search_tail
condition|)
block|{
name|CLEAR_BINFO_FIELDS_MARKED
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|tp
operator|+=
literal|1
expr_stmt|;
block|}
block|}
name|search_stack
operator|=
name|pop_search_level
argument_list|(
name|search_stack
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
condition|)
block|{
if|if
condition|(
name|errstr
condition|)
block|{
name|tree
name|error_string
init|=
name|my_build_string
argument_list|(
name|errstr
argument_list|)
decl_stmt|;
comment|/* Save error message with entry.  */
name|TREE_TYPE
argument_list|(
name|entry
argument_list|)
operator|=
name|error_string
expr_stmt|;
block|}
else|else
block|{
comment|/* Mark entry as having no error string.  */
name|TREE_TYPE
argument_list|(
name|entry
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|entry
argument_list|)
operator|=
name|rvals
expr_stmt|;
block|}
block|}
if|if
condition|(
name|errstr
operator|&&
name|protect
condition|)
block|{
name|cp_error
argument_list|(
name|errstr
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|rvals
operator|=
name|error_mark_node
expr_stmt|;
block|}
return|return
name|rvals
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* BREADTH-FIRST SEARCH ROUTINES.  */
end_comment

begin_comment
comment|/* Search a multiple inheritance hierarchy by breadth-first search.     TYPE is an aggregate type, possibly in a multiple-inheritance hierarchy.    TESTFN is a function, which, if true, means that our condition has been met,    and its return value should be returned.    QFN, if non-NULL, is a predicate dictating whether the type should    even be queued.  */
end_comment

begin_decl_stmt
name|HOST_WIDE_INT
name|breadth_first_search
argument_list|(
name|binfo
argument_list|,
name|testfn
argument_list|,
name|qfn
argument_list|)
name|tree
name|binfo
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|testfn
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
function_decl|(
modifier|*
name|qfn
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
name|int
name|head
init|=
literal|0
decl_stmt|,
name|tail
init|=
literal|0
decl_stmt|;
name|int
name|rval
init|=
literal|0
decl_stmt|;
name|search_stack
operator|=
name|push_search_level
argument_list|(
name|search_stack
argument_list|,
operator|&
name|search_obstack
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|int
name|n_baselinks
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Process and/or queue base types.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baselinks
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|BINFO_MARKED
argument_list|(
name|base_binfo
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|qfn
operator|==
literal|0
operator|||
call|(
modifier|*
name|qfn
call|)
argument_list|(
name|binfo
argument_list|,
name|i
argument_list|)
operator|)
condition|)
block|{
name|SET_BINFO_MARKED
argument_list|(
name|base_binfo
argument_list|)
expr_stmt|;
name|obstack_ptr_grow
argument_list|(
operator|&
name|search_obstack
argument_list|,
name|binfo
argument_list|)
expr_stmt|;
name|obstack_ptr_grow
argument_list|(
operator|&
name|search_obstack
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
name|i
argument_list|)
expr_stmt|;
name|tail
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|tail
operator|>=
name|search_stack
operator|->
name|limit
condition|)
name|my_friendly_abort
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Process head of queue, if one exists.  */
if|if
condition|(
name|head
operator|>=
name|tail
condition|)
block|{
name|rval
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|binfo
operator|=
name|search_stack
operator|->
name|first
index|[
name|head
operator|++
index|]
expr_stmt|;
name|i
operator|=
operator|(
name|HOST_WIDE_INT
operator|)
name|search_stack
operator|->
name|first
index|[
name|head
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|rval
operator|=
call|(
modifier|*
name|testfn
call|)
argument_list|(
name|binfo
argument_list|,
name|i
argument_list|)
condition|)
break|break;
name|binfo
operator|=
name|BINFO_BASETYPE
argument_list|(
name|binfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|{
name|tree
modifier|*
name|tp
init|=
name|search_stack
operator|->
name|first
decl_stmt|;
name|tree
modifier|*
name|search_tail
init|=
name|tp
operator|+
name|tail
decl_stmt|;
while|while
condition|(
name|tp
operator|<
name|search_tail
condition|)
block|{
name|tree
name|binfo
init|=
operator|*
name|tp
operator|++
decl_stmt|;
name|int
name|i
init|=
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|*
name|tp
operator|++
argument_list|)
decl_stmt|;
name|CLEAR_BINFO_MARKED
argument_list|(
name|BINFO_BASETYPE
argument_list|(
name|binfo
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|search_stack
operator|=
name|pop_search_level
argument_list|(
name|search_stack
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
end_block

begin_comment
comment|/* Functions to use in breadth first searches.  */
end_comment

begin_typedef
typedef|typedef
name|tree
function_decl|(
modifier|*
name|pft
function_decl|)
parameter_list|()
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|pfi
function_decl|)
parameter_list|()
function_decl|;
end_typedef

begin_function
name|int
name|tree_needs_constructor_p
parameter_list|(
name|binfo
parameter_list|,
name|i
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|int
name|i
decl_stmt|;
block|{
name|tree
name|basetype
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|i
operator|!=
literal|0
argument_list|,
literal|296
argument_list|)
expr_stmt|;
name|basetype
operator|=
name|BINFO_TYPE
argument_list|(
name|BINFO_BASETYPE
argument_list|(
name|binfo
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|basetype
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|tree
name|declarator
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|tree
name|get_virtuals_named_this
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
name|tree
name|fields
decl_stmt|;
name|fields
operator|=
name|lookup_fnfields
argument_list|(
name|binfo
argument_list|,
name|declarator
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* fields cannot be error_mark_node */
if|if
condition|(
name|fields
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Get to the function decls, and return the first virtual function      with this name, if there is one.  */
while|while
condition|(
name|fields
condition|)
block|{
name|tree
name|fndecl
decl_stmt|;
for|for
control|(
name|fndecl
operator|=
name|TREE_VALUE
argument_list|(
name|fields
argument_list|)
init|;
name|fndecl
condition|;
name|fndecl
operator|=
name|DECL_CHAIN
argument_list|(
name|fndecl
argument_list|)
control|)
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|fndecl
argument_list|)
condition|)
return|return
name|fields
return|;
name|fields
operator|=
name|next_baselink
argument_list|(
name|fields
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|get_virtual_destructor
parameter_list|(
name|binfo
parameter_list|,
name|i
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|int
name|i
decl_stmt|;
block|{
name|tree
name|type
init|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
name|type
operator|=
name|BINFO_TYPE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
operator|&&
name|DECL_VINDEX
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|tree_has_any_destructor_p
parameter_list|(
name|binfo
parameter_list|,
name|i
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|int
name|i
decl_stmt|;
block|{
name|tree
name|type
init|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
name|type
operator|=
name|BINFO_TYPE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given a class type TYPE, and a function decl FNDECL, look for a    virtual function in TYPE's hierarchy which FNDECL could match as a    virtual function.  It doesn't matter which one we find.     DTORP is nonzero if we are looking for a destructor.  Destructors    need special treatment because they do not match by name.  */
end_comment

begin_function
name|tree
name|get_matching_virtual
parameter_list|(
name|binfo
parameter_list|,
name|fndecl
parameter_list|,
name|dtorp
parameter_list|)
name|tree
name|binfo
decl_stmt|,
name|fndecl
decl_stmt|;
name|int
name|dtorp
decl_stmt|;
block|{
name|tree
name|tmp
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Breadth first search routines start searching basetypes      of TYPE, so we must perform first ply of search here.  */
if|if
condition|(
name|dtorp
condition|)
block|{
if|if
condition|(
name|tree_has_any_destructor_p
argument_list|(
name|binfo
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
name|tmp
operator|=
name|get_virtual_destructor
argument_list|(
name|binfo
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
condition|)
return|return
name|tmp
return|;
name|tmp
operator|=
operator|(
name|tree
operator|)
name|breadth_first_search
argument_list|(
name|binfo
argument_list|,
operator|(
name|pfi
operator|)
name|get_virtual_destructor
argument_list|,
name|tree_has_any_destructor_p
argument_list|)
expr_stmt|;
return|return
name|tmp
return|;
block|}
else|else
block|{
name|tree
name|drettype
decl_stmt|,
name|dtypes
decl_stmt|,
name|btypes
decl_stmt|,
name|instptr_type
decl_stmt|;
name|tree
name|basetype
init|=
name|DECL_CLASS_CONTEXT
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|tree
name|baselink
decl_stmt|,
name|best
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|name
init|=
name|DECL_ASSEMBLER_NAME
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|declarator
operator|=
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|IDENTIFIER_VIRTUAL_P
argument_list|(
name|declarator
argument_list|)
operator|==
literal|0
condition|)
return|return
name|NULL_TREE
return|;
name|drettype
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
name|dtypes
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|fndecl
argument_list|)
condition|)
name|instptr_type
operator|=
name|NULL_TREE
expr_stmt|;
else|else
name|instptr_type
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|dtypes
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|baselink
operator|=
name|get_virtuals_named_this
argument_list|(
name|binfo
argument_list|)
init|;
name|baselink
condition|;
name|baselink
operator|=
name|next_baselink
argument_list|(
name|baselink
argument_list|)
control|)
block|{
for|for
control|(
name|tmp
operator|=
name|TREE_VALUE
argument_list|(
name|baselink
argument_list|)
init|;
name|tmp
condition|;
name|tmp
operator|=
name|DECL_CHAIN
argument_list|(
name|tmp
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|DECL_VINDEX
argument_list|(
name|tmp
argument_list|)
condition|)
continue|continue;
name|btypes
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|instptr_type
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|compparms
argument_list|(
name|TREE_CHAIN
argument_list|(
name|btypes
argument_list|)
argument_list|,
name|dtypes
argument_list|,
literal|3
argument_list|)
condition|)
comment|/* Caller knows to give error in this case.  */
return|return
name|tmp
return|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
operator|(
name|TYPE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|btypes
argument_list|)
argument_list|)
argument_list|)
operator|==
name|TYPE_READONLY
argument_list|(
name|instptr_type
argument_list|)
operator|)
operator|&&
name|compparms
argument_list|(
name|TREE_CHAIN
argument_list|(
name|btypes
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|dtypes
argument_list|)
argument_list|,
literal|3
argument_list|)
condition|)
block|{
if|if
condition|(
name|IDENTIFIER_ERROR_LOCUS
argument_list|(
name|name
argument_list|)
operator|==
name|NULL_TREE
operator|&&
operator|!
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|tmp
argument_list|)
argument_list|)
argument_list|,
name|drettype
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"conflicting return type specified for virtual function `%#D'"
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
name|cp_error
argument_list|(
literal|"overriding definition as `%#D'"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_ERROR_LOCUS
argument_list|(
name|name
argument_list|,
name|basetype
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|tmp
condition|)
block|{
name|best
operator|=
name|tmp
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|best
operator|==
name|NULL_TREE
operator|&&
name|warn_overloaded_virtual
condition|)
name|cp_warning_at
argument_list|(
literal|"conflicting specification deriving virtual function `%D'"
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
return|return
name|best
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return the list of virtual functions which are abstract in type    TYPE that come from non virtual base classes.  See    expand_direct_vtbls_init for the style of search we do.  */
end_comment

begin_function
specifier|static
name|tree
name|get_abstract_virtuals_1
parameter_list|(
name|binfo
parameter_list|,
name|do_self
parameter_list|,
name|abstract_virtuals
parameter_list|)
name|tree
name|binfo
decl_stmt|,
name|abstract_virtuals
decl_stmt|;
name|int
name|do_self
decl_stmt|;
block|{
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baselinks
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baselinks
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|int
name|is_not_base_vtable
init|=
name|i
operator|!=
name|CLASSTYPE_VFIELD_PARENT
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
condition|)
name|abstract_virtuals
operator|=
name|get_abstract_virtuals_1
argument_list|(
name|base_binfo
argument_list|,
name|is_not_base_vtable
argument_list|,
name|abstract_virtuals
argument_list|)
expr_stmt|;
block|}
comment|/* Should we use something besides CLASSTYPE_VFIELDS? */
if|if
condition|(
name|do_self
operator|&&
name|CLASSTYPE_VFIELDS
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|tmp
init|=
name|TREE_CHAIN
argument_list|(
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Get around dossier entry if there is one.  */
if|if
condition|(
name|flag_dossier
condition|)
name|tmp
operator|=
name|TREE_CHAIN
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
while|while
condition|(
name|tmp
condition|)
block|{
name|tree
name|base_pfn
init|=
name|FNADDR_FROM_VTABLE_ENTRY
argument_list|(
name|TREE_VALUE
argument_list|(
name|tmp
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|base_fndecl
init|=
name|TREE_OPERAND
argument_list|(
name|base_pfn
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|DECL_ABSTRACT_VIRTUAL_P
argument_list|(
name|base_fndecl
argument_list|)
condition|)
name|abstract_virtuals
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|base_fndecl
argument_list|,
name|abstract_virtuals
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|TREE_CHAIN
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|abstract_virtuals
return|;
block|}
end_function

begin_comment
comment|/* Return the list of virtual functions which are abstract in type TYPE.    This information is cached, and so must be built on a    non-temporary obstack.  */
end_comment

begin_function
name|tree
name|get_abstract_virtuals
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|vbases
decl_stmt|,
name|tmp
decl_stmt|;
name|tree
name|abstract_virtuals
init|=
name|CLASSTYPE_ABSTRACT_VIRTUALS
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/* First get all from non-virtual bases. */
name|abstract_virtuals
operator|=
name|get_abstract_virtuals_1
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abstract_virtuals
argument_list|)
expr_stmt|;
for|for
control|(
name|vbases
operator|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|type
argument_list|)
init|;
name|vbases
condition|;
name|vbases
operator|=
name|TREE_CHAIN
argument_list|(
name|vbases
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|BINFO_VIRTUALS
argument_list|(
name|vbases
argument_list|)
condition|)
continue|continue;
name|tmp
operator|=
name|TREE_CHAIN
argument_list|(
name|BINFO_VIRTUALS
argument_list|(
name|vbases
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|tmp
condition|)
block|{
name|tree
name|base_pfn
init|=
name|FNADDR_FROM_VTABLE_ENTRY
argument_list|(
name|TREE_VALUE
argument_list|(
name|tmp
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|base_fndecl
init|=
name|TREE_OPERAND
argument_list|(
name|base_pfn
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|DECL_ABSTRACT_VIRTUAL_P
argument_list|(
name|base_fndecl
argument_list|)
condition|)
name|abstract_virtuals
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|base_fndecl
argument_list|,
name|abstract_virtuals
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|TREE_CHAIN
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|nreverse
argument_list|(
name|abstract_virtuals
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* For the type TYPE, return a list of member functions available from    base classes with name NAME.  The TREE_VALUE of the list is a chain of    member functions with name NAME.  The TREE_PURPOSE of the list is a    basetype, or a list of base types (in reverse order) which were    traversed to reach the chain of member functions.  If we reach a base    type which provides a member function of name NAME, and which has at    most one base type itself, then we can terminate the search.  */
end_comment

begin_function
name|tree
name|get_baselinks
parameter_list|(
name|type_as_binfo_list
parameter_list|,
name|type
parameter_list|,
name|name
parameter_list|)
name|tree
name|type_as_binfo_list
decl_stmt|;
name|tree
name|type
decl_stmt|,
name|name
decl_stmt|;
block|{
name|int
name|head
init|=
literal|0
decl_stmt|,
name|tail
init|=
literal|0
decl_stmt|,
name|index
decl_stmt|;
name|tree
name|rval
init|=
literal|0
decl_stmt|,
name|nval
init|=
literal|0
decl_stmt|;
name|tree
name|basetypes
init|=
name|type_as_binfo_list
decl_stmt|;
name|tree
name|binfo
init|=
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|search_stack
operator|=
name|push_search_level
argument_list|(
name|search_stack
argument_list|,
operator|&
name|search_obstack
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baselinks
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
comment|/* Process and/or queue base types.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baselinks
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|btypes
decl_stmt|;
name|btypes
operator|=
name|hash_tree_cons
argument_list|(
name|TREE_VIA_PUBLIC
argument_list|(
name|base_binfo
argument_list|)
argument_list|,
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
argument_list|,
name|TREE_VIA_PROTECTED
argument_list|(
name|base_binfo
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|base_binfo
argument_list|,
name|basetypes
argument_list|)
expr_stmt|;
name|obstack_ptr_grow
argument_list|(
operator|&
name|search_obstack
argument_list|,
name|btypes
argument_list|)
expr_stmt|;
name|search_stack
operator|->
name|first
operator|=
operator|(
name|tree
operator|*
operator|)
name|obstack_base
argument_list|(
operator|&
name|search_obstack
argument_list|)
expr_stmt|;
name|tail
operator|+=
literal|1
expr_stmt|;
block|}
name|dont_queue
label|:
comment|/* Process head of queue, if one exists.  */
if|if
condition|(
name|head
operator|>=
name|tail
condition|)
break|break;
name|basetypes
operator|=
name|search_stack
operator|->
name|first
index|[
name|head
operator|++
index|]
expr_stmt|;
name|binfo
operator|=
name|TREE_VALUE
argument_list|(
name|basetypes
argument_list|)
expr_stmt|;
name|type
operator|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
name|index
operator|=
name|lookup_fnfields_1
argument_list|(
name|type
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|>=
literal|0
condition|)
block|{
name|nval
operator|=
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|rval
operator|=
name|hash_tree_cons
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|basetypes
argument_list|,
name|nval
argument_list|,
name|rval
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_BINFO_BASETYPES
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|dont_queue
goto|;
elseif|else
if|if
condition|(
name|TREE_VEC_LENGTH
argument_list|(
name|TYPE_BINFO_BASETYPES
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|CLASSTYPE_BASELINK_VEC
argument_list|(
name|type
argument_list|)
condition|)
name|TREE_TYPE
argument_list|(
name|rval
argument_list|)
operator|=
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_BASELINK_VEC
argument_list|(
name|type
argument_list|)
argument_list|,
name|index
argument_list|)
expr_stmt|;
goto|goto
name|dont_queue
goto|;
block|}
block|}
name|nval
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|search_stack
operator|=
name|pop_search_level
argument_list|(
name|search_stack
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_function
name|tree
name|next_baselink
parameter_list|(
name|baselink
parameter_list|)
name|tree
name|baselink
decl_stmt|;
block|{
name|tree
name|tmp
init|=
name|TREE_TYPE
argument_list|(
name|baselink
argument_list|)
decl_stmt|;
name|baselink
operator|=
name|TREE_CHAIN
argument_list|(
name|baselink
argument_list|)
expr_stmt|;
while|while
condition|(
name|tmp
condition|)
block|{
comment|/* @@ does not yet add previous base types.  */
name|baselink
operator|=
name|tree_cons
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tmp
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|tmp
argument_list|)
argument_list|,
name|baselink
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|baselink
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|TREE_CHAIN
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
return|return
name|baselink
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* DEPTH-FIRST SEARCH ROUTINES.  */
end_comment

begin_comment
comment|/* Assign unique numbers to _CLASSTYPE members of the lattice    specified by TYPE.  The root nodes are marked first; the nodes    are marked depth-fisrt, left-right.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Matrix implementing a relation from CLASSTYPE X CLASSTYPE => INT.    Relation yields 1 if C1<= C2, 0 otherwise.  */
end_comment

begin_typedef
typedef|typedef
name|char
name|mi_boolean
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|mi_boolean
modifier|*
name|mi_matrix
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Type for which this matrix is defined.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|mi_type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size of the matrix for indexing purposes.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mi_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return nonzero if class C2 derives from class C1.  */
end_comment

begin_define
define|#
directive|define
name|BINFO_DERIVES_FROM
parameter_list|(
name|C1
parameter_list|,
name|C2
parameter_list|)
define|\
value|((mi_matrix+mi_size*(BINFO_CID (C1)-1))[BINFO_CID (C2)-1])
end_define

begin_define
define|#
directive|define
name|TYPE_DERIVES_FROM
parameter_list|(
name|C1
parameter_list|,
name|C2
parameter_list|)
define|\
value|((mi_matrix+mi_size*(CLASSTYPE_CID (C1)-1))[CLASSTYPE_CID (C2)-1])
end_define

begin_define
define|#
directive|define
name|BINFO_DERIVES_FROM_STAR
parameter_list|(
name|C
parameter_list|)
define|\
value|(mi_matrix+(BINFO_CID (C)-1))
end_define

begin_comment
comment|/* This routine converts a pointer to be a pointer of an immediate    base class.  The normal convert_pointer_to routine would diagnose    the conversion as ambiguous, under MI code that has the base class    as an ambiguous base class. */
end_comment

begin_function
specifier|static
name|tree
name|convert_pointer_to_single_level
parameter_list|(
name|to_type
parameter_list|,
name|expr
parameter_list|)
name|tree
name|to_type
decl_stmt|,
name|expr
decl_stmt|;
block|{
name|tree
name|binfo_of_derived
decl_stmt|;
name|tree
name|last
decl_stmt|;
name|binfo_of_derived
operator|=
name|TYPE_BINFO
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|last
operator|=
name|get_binfo
argument_list|(
name|to_type
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|last
argument_list|)
operator|=
name|binfo_of_derived
expr_stmt|;
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|binfo_of_derived
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
return|return
name|build_vbase_path
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|to_type
argument_list|)
argument_list|,
name|expr
argument_list|,
name|last
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The main function which implements depth first search.     This routine has to remember the path it walked up, when    dfs_init_vbase_pointers is the work function, as otherwise there    would be no record. */
end_comment

begin_decl_stmt
specifier|static
name|void
name|dfs_walk
argument_list|(
name|binfo
argument_list|,
name|fn
argument_list|,
name|qfn
argument_list|)
name|tree
name|binfo
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
function_decl|(
modifier|*
name|fn
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
function_decl|(
modifier|*
name|qfn
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baselinks
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baselinks
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
call|(
modifier|*
name|qfn
call|)
argument_list|(
name|base_binfo
argument_list|)
condition|)
block|{
if|if
condition|(
name|fn
operator|==
name|dfs_init_vbase_pointers
condition|)
block|{
comment|/* When traversing an arbitrary MI hierarchy, we need to keep 		 a record of the path we took to get down to the final base 		 type, as otherwise there would be no record of it, and just 		 trying to blindly convert at the bottom would be ambiguous.  		 The easiest way is to do the conversions one step at a time, 		 as we know we want the immediate base class at each step.  		 The only special trick to converting one step at a time, 		 is that when we hit the last virtual base class, we must 		 use the SLOT value for it, and not use the normal convert 		 routine.  We use the last virtual base class, as in our 		 implementation, we have pointers to all virtual base 		 classes in the base object.  */
name|tree
name|saved_vbase_decl_ptr_intermediate
init|=
name|vbase_decl_ptr_intermediate
decl_stmt|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
condition|)
block|{
comment|/* No need for the conversion here, as we know it is the 		     right type.  */
name|vbase_decl_ptr_intermediate
operator|=
operator|(
name|tree
operator|)
name|CLASSTYPE_SEARCH_SLOT
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vbase_decl_ptr_intermediate
operator|=
name|convert_pointer_to_single_level
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|,
name|vbase_decl_ptr_intermediate
argument_list|)
expr_stmt|;
block|}
name|dfs_walk
argument_list|(
name|base_binfo
argument_list|,
name|fn
argument_list|,
name|qfn
argument_list|)
expr_stmt|;
name|vbase_decl_ptr_intermediate
operator|=
name|saved_vbase_decl_ptr_intermediate
expr_stmt|;
block|}
else|else
name|dfs_walk
argument_list|(
name|base_binfo
argument_list|,
name|fn
argument_list|,
name|qfn
argument_list|)
expr_stmt|;
block|}
block|}
name|fn
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Predicate functions which serve for dfs_walk.  */
end_comment

begin_function
specifier|static
name|int
name|numberedp
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
return|return
name|BINFO_CID
argument_list|(
name|binfo
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unnumberedp
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
return|return
name|BINFO_CID
argument_list|(
name|binfo
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|markedp
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
return|return
name|BINFO_MARKED
argument_list|(
name|binfo
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bfs_markedp
parameter_list|(
name|binfo
parameter_list|,
name|i
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|int
name|i
decl_stmt|;
block|{
return|return
name|BINFO_MARKED
argument_list|(
name|BINFO_BASETYPE
argument_list|(
name|binfo
argument_list|,
name|i
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unmarkedp
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
return|return
name|BINFO_MARKED
argument_list|(
name|binfo
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bfs_unmarkedp
parameter_list|(
name|binfo
parameter_list|,
name|i
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|int
name|i
decl_stmt|;
block|{
return|return
name|BINFO_MARKED
argument_list|(
name|BINFO_BASETYPE
argument_list|(
name|binfo
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|marked_vtable_pathp
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
return|return
name|BINFO_VTABLE_PATH_MARKED
argument_list|(
name|binfo
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bfs_marked_vtable_pathp
parameter_list|(
name|binfo
parameter_list|,
name|i
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|int
name|i
decl_stmt|;
block|{
return|return
name|BINFO_VTABLE_PATH_MARKED
argument_list|(
name|BINFO_BASETYPE
argument_list|(
name|binfo
argument_list|,
name|i
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unmarked_vtable_pathp
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
return|return
name|BINFO_VTABLE_PATH_MARKED
argument_list|(
name|binfo
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bfs_unmarked_vtable_pathp
parameter_list|(
name|binfo
parameter_list|,
name|i
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|int
name|i
decl_stmt|;
block|{
return|return
name|BINFO_VTABLE_PATH_MARKED
argument_list|(
name|BINFO_BASETYPE
argument_list|(
name|binfo
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|marked_new_vtablep
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
return|return
name|BINFO_NEW_VTABLE_MARKED
argument_list|(
name|binfo
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bfs_marked_new_vtablep
parameter_list|(
name|binfo
parameter_list|,
name|i
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|int
name|i
decl_stmt|;
block|{
return|return
name|BINFO_NEW_VTABLE_MARKED
argument_list|(
name|BINFO_BASETYPE
argument_list|(
name|binfo
argument_list|,
name|i
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unmarked_new_vtablep
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
return|return
name|BINFO_NEW_VTABLE_MARKED
argument_list|(
name|binfo
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bfs_unmarked_new_vtablep
parameter_list|(
name|binfo
parameter_list|,
name|i
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|int
name|i
decl_stmt|;
block|{
return|return
name|BINFO_NEW_VTABLE_MARKED
argument_list|(
name|BINFO_BASETYPE
argument_list|(
name|binfo
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dfs_search_slot_nonempty_p
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
return|return
name|CLASSTYPE_SEARCH_SLOT
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
operator|!=
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dfs_debug_unmarkedp
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
return|return
name|CLASSTYPE_DEBUG_REQUESTED
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/* The worker functions for `dfs_walk'.  These do not need to    test anything (vis a vis marking) if they are paired with    a predicate function (above).  */
end_comment

begin_comment
comment|/* Assign each type within the lattice a number which is unique    in the lattice.  The first number assigned is 1.  */
end_comment

begin_function
specifier|static
name|void
name|dfs_number
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
name|BINFO_CID
argument_list|(
name|binfo
argument_list|)
operator|=
operator|++
name|cid
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dfs_unnumber
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
name|BINFO_CID
argument_list|(
name|binfo
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dfs_mark
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
name|SET_BINFO_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dfs_unmark
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
name|CLEAR_BINFO_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dfs_mark_vtable_path
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
name|SET_BINFO_VTABLE_PATH_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dfs_unmark_vtable_path
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
name|CLEAR_BINFO_VTABLE_PATH_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dfs_mark_new_vtable
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
name|SET_BINFO_NEW_VTABLE_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dfs_unmark_new_vtable
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
name|CLEAR_BINFO_NEW_VTABLE_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dfs_clear_search_slot
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
name|CLASSTYPE_SEARCH_SLOT
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dfs_debug_mark
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
name|tree
name|t
init|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
comment|/* Use heuristic that if there are virtual functions,      ignore until we see a non-inline virtual function.  */
name|tree
name|methods
init|=
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|CLASSTYPE_DEBUG_REQUESTED
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* If interface info is known, the value of (?@@?) is correct.  */
if|if
condition|(
name|methods
operator|==
literal|0
operator|||
name|CLASSTYPE_INTERFACE_KNOWN
argument_list|(
name|t
argument_list|)
operator|||
operator|(
name|write_virtuals
operator|==
literal|2
operator|&&
name|TYPE_VIRTUAL_P
argument_list|(
name|t
argument_list|)
operator|)
condition|)
return|return;
comment|/* If debug info is requested from this context for this type, supply it.      If debug info is requested from another context for this type,      see if some third context can supply it.  */
if|if
condition|(
name|current_function_decl
operator|==
name|NULL_TREE
operator|||
name|DECL_CLASS_CONTEXT
argument_list|(
name|current_function_decl
argument_list|)
operator|!=
name|t
condition|)
block|{
if|if
condition|(
name|TREE_VEC_ELT
argument_list|(
name|methods
argument_list|,
literal|0
argument_list|)
condition|)
name|methods
operator|=
name|TREE_VEC_ELT
argument_list|(
name|methods
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|methods
operator|=
name|TREE_VEC_ELT
argument_list|(
name|methods
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|methods
condition|)
block|{
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|methods
argument_list|)
operator|&&
name|DECL_SAVED_INSNS
argument_list|(
name|methods
argument_list|)
operator|==
literal|0
operator|&&
name|DECL_PENDING_INLINE_INFO
argument_list|(
name|methods
argument_list|)
operator|==
literal|0
operator|&&
name|DECL_ABSTRACT_VIRTUAL_P
argument_list|(
name|methods
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Somebody, somewhere is going to have to define this 		 virtual function.  When they do, they will provide 		 the debugging info.  */
return|return;
block|}
name|methods
operator|=
name|TREE_CHAIN
argument_list|(
name|methods
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* We cannot rely on some alien method to solve our problems,      so we must write out the debug info ourselves.  */
name|TYPE_DECL_SUPPRESS_DEBUG
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|rest_of_type_compilation
argument_list|(
name|t
argument_list|,
name|global_bindings_p
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  Attach to the type of the virtual base class, the pointer to the     virtual base class, given the global pointer vbase_decl_ptr.      We use the global vbase_types.  ICK!  */
end_comment

begin_function
specifier|static
name|void
name|dfs_find_vbases
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baselinks
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
name|n_baselinks
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
operator|&&
name|CLASSTYPE_SEARCH_SLOT
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tree
name|vbase
init|=
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
decl_stmt|;
name|tree
name|binfo
init|=
name|binfo_member
argument_list|(
name|vbase
argument_list|,
name|vbase_types
argument_list|)
decl_stmt|;
name|CLASSTYPE_SEARCH_SLOT
argument_list|(
name|vbase
argument_list|)
operator|=
operator|(
name|char
operator|*
operator|)
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|vbase
argument_list|)
argument_list|,
name|vbase_decl_ptr
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|SET_BINFO_VTABLE_PATH_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
name|SET_BINFO_NEW_VTABLE_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dfs_init_vbase_pointers
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
name|tree
name|type
init|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|tree
name|fields
init|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|this_vbase_ptr
decl_stmt|;
name|CLEAR_BINFO_VTABLE_PATH_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
comment|/* If there is a dossier, it is the first field, though perhaps from      the base class.  Otherwise, the first fields are virtual base class      pointer fields.  */
if|if
condition|(
name|CLASSTYPE_DOSSIER
argument_list|(
name|type
argument_list|)
operator|&&
name|VFIELD_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
argument_list|)
condition|)
comment|/* Get past vtable for the object.  */
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
expr_stmt|;
if|if
condition|(
name|fields
operator|==
name|NULL_TREE
operator|||
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
operator|==
name|NULL_TREE
operator|||
operator|!
name|VBASE_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
argument_list|)
condition|)
return|return;
name|this_vbase_ptr
operator|=
name|vbase_decl_ptr_intermediate
expr_stmt|;
if|if
condition|(
name|TYPE_POINTER_TO
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|this_vbase_ptr
argument_list|)
argument_list|)
condition|)
name|my_friendly_abort
argument_list|(
literal|125
argument_list|)
expr_stmt|;
while|while
condition|(
name|fields
operator|&&
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
operator|&&
name|VBASE_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|ref
init|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|fields
argument_list|)
argument_list|,
name|build_indirect_ref
argument_list|(
name|this_vbase_ptr
argument_list|,
name|NULL_PTR
argument_list|)
argument_list|,
name|fields
argument_list|)
decl_stmt|;
name|tree
name|init
init|=
operator|(
name|tree
operator|)
name|CLASSTYPE_SEARCH_SLOT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fields
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|vbase_init_result
operator|=
name|tree_cons
argument_list|(
name|binfo_member
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fields
argument_list|)
argument_list|)
argument_list|,
name|vbase_types
argument_list|)
argument_list|,
name|build_modify_expr
argument_list|(
name|ref
argument_list|,
name|NOP_EXPR
argument_list|,
name|init
argument_list|)
argument_list|,
name|vbase_init_result
argument_list|)
expr_stmt|;
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Sometimes this needs to clear both VTABLE_PATH and NEW_VTABLE.  Other    times, just NEW_VTABLE, but optimizer should make both with equal    efficiency (though it does not currently).  */
end_comment

begin_function
specifier|static
name|void
name|dfs_clear_vbase_slots
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
name|tree
name|type
init|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|CLASSTYPE_SEARCH_SLOT
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
name|CLEAR_BINFO_VTABLE_PATH_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
name|CLEAR_BINFO_NEW_VTABLE_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|tree
name|init_vbase_pointers
parameter_list|(
name|type
parameter_list|,
name|decl_ptr
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|decl_ptr
decl_stmt|;
block|{
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|int
name|old_flag
init|=
name|flag_this_is_variable
decl_stmt|;
name|tree
name|binfo
init|=
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|flag_this_is_variable
operator|=
operator|-
literal|2
expr_stmt|;
name|vbase_types
operator|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|vbase_decl_ptr
operator|=
name|decl_ptr
expr_stmt|;
name|vbase_decl
operator|=
name|build_indirect_ref
argument_list|(
name|decl_ptr
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|vbase_decl_ptr_intermediate
operator|=
name|vbase_decl_ptr
expr_stmt|;
name|vbase_init_result
operator|=
name|NULL_TREE
expr_stmt|;
name|dfs_walk
argument_list|(
name|binfo
argument_list|,
name|dfs_find_vbases
argument_list|,
name|unmarked_vtable_pathp
argument_list|)
expr_stmt|;
name|dfs_walk
argument_list|(
name|binfo
argument_list|,
name|dfs_init_vbase_pointers
argument_list|,
name|marked_vtable_pathp
argument_list|)
expr_stmt|;
name|dfs_walk
argument_list|(
name|binfo
argument_list|,
name|dfs_clear_vbase_slots
argument_list|,
name|marked_new_vtablep
argument_list|)
expr_stmt|;
name|flag_this_is_variable
operator|=
name|old_flag
expr_stmt|;
return|return
name|vbase_init_result
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Build a COMPOUND_EXPR which when expanded will generate the code    needed to initialize all the virtual function table slots of all    the virtual baseclasses.  MAIN_BINFO is the binfo which determines    the virtual baseclasses to use; TYPE is the type of the object to    which the initialization applies.  TRUE_EXP is the true object we    are initializing, and DECL_PTR is the pointer to the sub-object we    are initializing.     When USE_COMPUTED_OFFSETS is non-zero, we can assume that the    object was laidout by a top-level contructor and the computed    offsets are valid to store vtables.  When zero, we must store new    vtables through virtual baseclass pointers.     We setup and use the globals: vbase_decl, vbase_decl_ptr, vbase_types    ICK!  */
end_comment

begin_function
name|void
name|expand_indirect_vtbls_init
parameter_list|(
name|binfo
parameter_list|,
name|true_exp
parameter_list|,
name|decl_ptr
parameter_list|,
name|use_computed_offsets
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|tree
name|true_exp
decl_stmt|,
name|decl_ptr
decl_stmt|;
name|int
name|use_computed_offsets
decl_stmt|;
block|{
name|tree
name|type
init|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|int
name|old_flag
init|=
name|flag_this_is_variable
decl_stmt|;
name|tree
name|vbases
init|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|vbase_types
operator|=
name|vbases
expr_stmt|;
name|vbase_decl_ptr
operator|=
name|true_exp
condition|?
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|true_exp
argument_list|,
literal|0
argument_list|)
else|:
name|decl_ptr
expr_stmt|;
name|vbase_decl
operator|=
name|true_exp
condition|?
name|true_exp
else|:
name|build_indirect_ref
argument_list|(
name|decl_ptr
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_computed_offsets
condition|)
block|{
comment|/* This is an object of type IN_TYPE,  */
name|flag_this_is_variable
operator|=
operator|-
literal|2
expr_stmt|;
name|dfs_walk
argument_list|(
name|binfo
argument_list|,
name|dfs_find_vbases
argument_list|,
name|unmarked_new_vtablep
argument_list|)
expr_stmt|;
block|}
comment|/* Initialized with vtables of type TYPE.  */
for|for
control|(
init|;
name|vbases
condition|;
name|vbases
operator|=
name|TREE_CHAIN
argument_list|(
name|vbases
argument_list|)
control|)
block|{
name|tree
name|addr
decl_stmt|;
if|if
condition|(
name|use_computed_offsets
condition|)
name|addr
operator|=
operator|(
name|tree
operator|)
name|CLASSTYPE_SEARCH_SLOT
argument_list|(
name|BINFO_TYPE
argument_list|(
name|vbases
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|vbinfo
init|=
name|get_binfo
argument_list|(
name|TREE_TYPE
argument_list|(
name|vbases
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|vbase_decl
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* See is we can get lucky.  */
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|vbinfo
argument_list|)
condition|)
name|addr
operator|=
name|convert_pointer_to_real
argument_list|(
name|vbinfo
argument_list|,
name|vbase_decl_ptr
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* We go through all these contortions to avoid this 		     call, as it will fail when the virtual base type 		     is ambiguous from here.  We don't yet have a way 		     to search for and find just an instance of the 		     virtual base class.  Searching for the binfo in 		     vbases won't work, as we don't have the vbase 		     pointer field, for all vbases in the main class, 		     only direct vbases.  */
name|addr
operator|=
name|convert_pointer_to_real
argument_list|(
name|TREE_TYPE
argument_list|(
name|vbases
argument_list|)
argument_list|,
name|vbase_decl_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|==
name|error_mark_node
condition|)
continue|continue;
block|}
block|}
comment|/* Do all vtables from this virtual base. */
comment|/* This assumes that virtual bases can never serve as parent 	     binfos.  (in the CLASSTPE_VFIELD_PARENT sense)  */
name|expand_direct_vtbls_init
argument_list|(
name|vbases
argument_list|,
name|TYPE_BINFO
argument_list|(
name|BINFO_TYPE
argument_list|(
name|vbases
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
name|dfs_walk
argument_list|(
name|binfo
argument_list|,
name|dfs_clear_vbase_slots
argument_list|,
name|marked_new_vtablep
argument_list|)
expr_stmt|;
name|flag_this_is_variable
operator|=
name|old_flag
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|clear_search_slots
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|dfs_walk
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|dfs_clear_search_slot
argument_list|,
name|dfs_search_slot_nonempty_p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* get virtual base class types.    This adds type to the vbase_types list in reverse dfs order.    Ordering is very important, so don't change it.  */
end_comment

begin_function
specifier|static
name|void
name|dfs_get_vbase_types
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
operator|&&
operator|!
name|BINFO_VBASE_MARKED
argument_list|(
name|binfo
argument_list|)
condition|)
block|{
name|vbase_types
operator|=
name|make_binfo
argument_list|(
name|integer_zero_node
argument_list|,
name|binfo
argument_list|,
name|BINFO_VTABLE
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|vbase_types
argument_list|)
expr_stmt|;
name|TREE_VIA_VIRTUAL
argument_list|(
name|vbase_types
argument_list|)
operator|=
literal|1
expr_stmt|;
name|SET_BINFO_VBASE_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
block|}
name|SET_BINFO_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* get a list of virtual base classes in dfs order.  */
end_comment

begin_function
name|tree
name|get_vbase_types
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|vbases
decl_stmt|;
name|tree
name|binfo
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TREE_VEC
condition|)
name|binfo
operator|=
name|type
expr_stmt|;
else|else
name|binfo
operator|=
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|vbase_types
operator|=
name|NULL_TREE
expr_stmt|;
name|dfs_walk
argument_list|(
name|binfo
argument_list|,
name|dfs_get_vbase_types
argument_list|,
name|unmarkedp
argument_list|)
expr_stmt|;
name|dfs_walk
argument_list|(
name|binfo
argument_list|,
name|dfs_unmark
argument_list|,
name|markedp
argument_list|)
expr_stmt|;
comment|/* Rely upon the reverse dfs ordering from dfs_get_vbase_types, and now      reverse it so that we get normal dfs ordering.  */
name|vbase_types
operator|=
name|nreverse
argument_list|(
name|vbase_types
argument_list|)
expr_stmt|;
comment|/* unmark marked vbases */
for|for
control|(
name|vbases
operator|=
name|vbase_types
init|;
name|vbases
condition|;
name|vbases
operator|=
name|TREE_CHAIN
argument_list|(
name|vbases
argument_list|)
control|)
name|CLEAR_BINFO_VBASE_MARKED
argument_list|(
name|vbases
argument_list|)
expr_stmt|;
return|return
name|vbase_types
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|dfs_record_inheritance
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baselinks
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
name|mi_boolean
modifier|*
name|derived_row
init|=
name|BINFO_DERIVES_FROM_STAR
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
name|n_baselinks
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|int
name|j
decl_stmt|;
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|baseclass
init|=
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
decl_stmt|;
name|mi_boolean
modifier|*
name|base_row
init|=
name|BINFO_DERIVES_FROM_STAR
argument_list|(
name|base_binfo
argument_list|)
decl_stmt|;
comment|/* Don't search if there's nothing there!  MI_SIZE can be 	 zero as a result of parse errors.  */
if|if
condition|(
name|TYPE_BINFO_BASETYPES
argument_list|(
name|baseclass
argument_list|)
operator|&&
name|mi_size
operator|>
literal|0
condition|)
for|for
control|(
name|j
operator|=
name|mi_size
operator|*
operator|(
name|CLASSTYPE_CID
argument_list|(
name|baseclass
argument_list|)
operator|-
literal|1
operator|)
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|-=
name|mi_size
control|)
name|derived_row
index|[
name|j
index|]
operator||=
name|base_row
index|[
name|j
index|]
expr_stmt|;
name|TYPE_DERIVES_FROM
argument_list|(
name|baseclass
argument_list|,
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|SET_BINFO_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a _CLASSTYPE node in a multiple inheritance lattice,    convert the lattice into a simple relation such that,    given to CIDs, C1 and C2, one can determine if C1<= C2    or C2<= C1 or C1<> C2.     Once constructed, we walk the lattice depth fisrt,    applying various functions to elements as they are encountered.     We use xmalloc here, in case we want to randomly free these tables.  */
end_comment

begin_define
define|#
directive|define
name|SAVE_MI_MATRIX
end_define

begin_function
name|void
name|build_mi_matrix
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|binfo
init|=
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|cid
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|SAVE_MI_MATRIX
if|if
condition|(
name|CLASSTYPE_MI_MATRIX
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|mi_size
operator|=
name|CLASSTYPE_N_SUPERCLASSES
argument_list|(
name|type
argument_list|)
operator|+
name|CLASSTYPE_N_VBASECLASSES
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|mi_matrix
operator|=
name|CLASSTYPE_MI_MATRIX
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|mi_type
operator|=
name|type
expr_stmt|;
name|dfs_walk
argument_list|(
name|binfo
argument_list|,
name|dfs_number
argument_list|,
name|unnumberedp
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|mi_size
operator|=
name|CLASSTYPE_N_SUPERCLASSES
argument_list|(
name|type
argument_list|)
operator|+
name|CLASSTYPE_N_VBASECLASSES
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|mi_matrix
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|mi_size
operator|+
literal|1
operator|)
operator|*
operator|(
name|mi_size
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|mi_type
operator|=
name|type
expr_stmt|;
name|bzero
argument_list|(
name|mi_matrix
argument_list|,
operator|(
name|mi_size
operator|+
literal|1
operator|)
operator|*
operator|(
name|mi_size
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|dfs_walk
argument_list|(
name|binfo
argument_list|,
name|dfs_number
argument_list|,
name|unnumberedp
argument_list|)
expr_stmt|;
name|dfs_walk
argument_list|(
name|binfo
argument_list|,
name|dfs_record_inheritance
argument_list|,
name|unmarkedp
argument_list|)
expr_stmt|;
name|dfs_walk
argument_list|(
name|binfo
argument_list|,
name|dfs_unmark
argument_list|,
name|markedp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|free_mi_matrix
parameter_list|()
block|{
name|dfs_walk
argument_list|(
name|TYPE_BINFO
argument_list|(
name|mi_type
argument_list|)
argument_list|,
name|dfs_unnumber
argument_list|,
name|numberedp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SAVE_MI_MATRIX
name|CLASSTYPE_MI_MATRIX
argument_list|(
name|mi_type
argument_list|)
operator|=
name|mi_matrix
expr_stmt|;
else|#
directive|else
name|free
argument_list|(
name|mi_matrix
argument_list|)
expr_stmt|;
name|mi_size
operator|=
literal|0
expr_stmt|;
name|cid
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If we want debug info for a type TYPE, make sure all its base types    are also marked as being potentially interesting.  This avoids    the problem of not writing any debug info for intermediate basetypes    that have abstract virtual functions.  */
end_comment

begin_function
name|void
name|note_debug_info_needed
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|dfs_walk
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|dfs_debug_mark
argument_list|,
name|dfs_debug_unmarkedp
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutines of push_class_decls ().  */
end_comment

begin_comment
comment|/* Add the instance variables which this class contributed to the    current class binding contour.  When a redefinition occurs,    if the redefinition is strictly within a single inheritance path,    we just overwrite (in the case of a data field) or    cons (in the case of a member function) the old declaration with    the new.  If the fields are not within a single inheritance path,    we must cons them in either case.     In order to know what decls are new (stemming from the current    invocation of push_class_decls) we enclose them in an "envelope",    which is a TREE_LIST node where the TREE_PURPOSE slot contains the    new decl (or possibly a list of competing ones), the TREE_VALUE slot    points to the old value and the TREE_CHAIN slot chains together all    envelopes which needs to be "opened" in push_class_decls.  Opening an    envelope means: push the old value onto the class_shadowed list,    install the new one and if it's a TYPE_DECL do the same to the    IDENTIFIER_TYPE_VALUE.  Such an envelope is recognized by seeing that    the TREE_PURPOSE slot is non-null, and that it is not an identifier.    Because if it is, it could be a set of overloaded methods from an    outer scope.  */
end_comment

begin_function
specifier|static
name|void
name|dfs_pushdecls
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
name|tree
name|type
init|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|tree
name|fields
decl_stmt|,
modifier|*
name|methods
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|tree
name|method_vec
decl_stmt|;
for|for
control|(
name|fields
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|fields
condition|;
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
control|)
block|{
comment|/* Unmark so that if we are in a constructor, and then find that 	 this field was initialized by a base initializer, 	 we can emit an error message.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fields
argument_list|)
operator|==
name|FIELD_DECL
condition|)
name|TREE_USED
argument_list|(
name|fields
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Recurse into anonymous unions.  */
if|if
condition|(
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fields
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
name|dfs_pushdecls
argument_list|(
name|TYPE_BINFO
argument_list|(
name|TREE_TYPE
argument_list|(
name|fields
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|#
directive|if
literal|0
block|if (TREE_CODE (fields) != TYPE_DECL) 	{ 	  DECL_PUBLIC (fields) = 0; 	  DECL_PROTECTED (fields) = 0; 	  DECL_PRIVATE (fields) = 0; 	}
endif|#
directive|endif
if|if
condition|(
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
condition|)
block|{
name|tree
name|class_value
init|=
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
argument_list|)
decl_stmt|;
comment|/* If the class value is an envelope of the kind described in 	     the comment above, we try to rule out possible ambiguities. 	     If we can't do that, keep a TREE_LIST with possibly ambiguous 	     decls in there.  */
if|if
condition|(
name|class_value
operator|&&
name|TREE_CODE
argument_list|(
name|class_value
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|TREE_PURPOSE
argument_list|(
name|class_value
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|class_value
argument_list|)
argument_list|)
operator|!=
name|IDENTIFIER_NODE
operator|)
condition|)
block|{
name|tree
name|value
init|=
name|TREE_PURPOSE
argument_list|(
name|class_value
argument_list|)
decl_stmt|;
name|tree
name|context
decl_stmt|;
comment|/* Possible ambiguity.  If its defining type(s) 		 is (are all) derived from us, no problem.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|!=
name|TREE_LIST
condition|)
block|{
name|context
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_VIRTUAL_P
argument_list|(
name|value
argument_list|)
operator|)
condition|?
name|DECL_CLASS_CONTEXT
argument_list|(
name|value
argument_list|)
else|:
name|DECL_CONTEXT
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|&&
operator|(
name|context
operator|==
name|type
operator|||
name|TYPE_DERIVES_FROM
argument_list|(
name|context
argument_list|,
name|type
argument_list|)
operator|)
condition|)
name|value
operator|=
name|fields
expr_stmt|;
else|else
name|value
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|fields
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* All children may derive from us, in which case 		     there is no problem.  Otherwise, we have to 		     keep lists around of what the ambiguities might be.  */
name|tree
name|values
decl_stmt|;
name|int
name|problem
init|=
literal|0
decl_stmt|;
for|for
control|(
name|values
operator|=
name|value
init|;
name|values
condition|;
name|values
operator|=
name|TREE_CHAIN
argument_list|(
name|values
argument_list|)
control|)
block|{
name|tree
name|sub_values
init|=
name|TREE_VALUE
argument_list|(
name|values
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|sub_values
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
for|for
control|(
init|;
name|sub_values
condition|;
name|sub_values
operator|=
name|TREE_CHAIN
argument_list|(
name|sub_values
argument_list|)
control|)
block|{
specifier|register
name|tree
name|list_mbr
init|=
name|TREE_VALUE
argument_list|(
name|sub_values
argument_list|)
decl_stmt|;
name|context
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|list_mbr
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_VIRTUAL_P
argument_list|(
name|list_mbr
argument_list|)
operator|)
condition|?
name|DECL_CLASS_CONTEXT
argument_list|(
name|list_mbr
argument_list|)
else|:
name|DECL_CONTEXT
argument_list|(
name|list_mbr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_DERIVES_FROM
argument_list|(
name|context
argument_list|,
name|type
argument_list|)
condition|)
block|{
name|value
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_VALUE
argument_list|(
name|values
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|problem
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
name|context
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|sub_values
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_VIRTUAL_P
argument_list|(
name|sub_values
argument_list|)
operator|)
condition|?
name|DECL_CLASS_CONTEXT
argument_list|(
name|sub_values
argument_list|)
else|:
name|DECL_CONTEXT
argument_list|(
name|sub_values
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|&&
operator|!
name|TYPE_DERIVES_FROM
argument_list|(
name|context
argument_list|,
name|type
argument_list|)
condition|)
block|{
name|value
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|values
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|problem
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|problem
condition|)
name|value
operator|=
name|fields
expr_stmt|;
block|}
comment|/* Mark this as a potentially ambiguous member.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
comment|/* Leaving TREE_TYPE blank is intentional. 		     We cannot use `error_mark_node' (lookup_name) 		     or `unknown_type_node' (all member functions use this).  */
name|TREE_NONLOCAL_FLAG
argument_list|(
name|value
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Put the new contents in our envelope.  */
name|TREE_PURPOSE
argument_list|(
name|class_value
argument_list|)
operator|=
name|value
expr_stmt|;
block|}
else|else
block|{
comment|/* See comment above for a description of envelopes.  */
name|tree
name|envelope
init|=
name|tree_cons
argument_list|(
name|fields
argument_list|,
name|class_value
argument_list|,
name|closed_envelopes
argument_list|)
decl_stmt|;
name|closed_envelopes
operator|=
name|envelope
expr_stmt|;
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
argument_list|)
operator|=
name|envelope
expr_stmt|;
block|}
block|}
block|}
name|method_vec
operator|=
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|method_vec
operator|!=
literal|0
condition|)
block|{
comment|/* Farm out constructors and destructors.  */
name|methods
operator|=
operator|&
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|end
operator|=
name|TREE_VEC_END
argument_list|(
name|method_vec
argument_list|)
expr_stmt|;
comment|/* This does not work for multiple inheritance yet.  */
while|while
condition|(
name|methods
operator|!=
name|end
condition|)
block|{
comment|/* This will cause lookup_name to return a pointer 	     to the tree_list of possible methods of this name. 	     If the order is a problem, we can nreverse them.  */
name|tree
name|tmp
decl_stmt|;
name|tree
name|class_value
init|=
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
operator|*
name|methods
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|class_value
operator|&&
name|TREE_CODE
argument_list|(
name|class_value
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|TREE_PURPOSE
argument_list|(
name|class_value
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|class_value
argument_list|)
argument_list|)
operator|!=
name|IDENTIFIER_NODE
condition|)
block|{
name|tree
name|old
init|=
name|TREE_PURPOSE
argument_list|(
name|class_value
argument_list|)
decl_stmt|;
name|maybe_push_cache_obstack
argument_list|()
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|old
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|tmp
operator|=
name|tree_cons
argument_list|(
name|DECL_NAME
argument_list|(
operator|*
name|methods
argument_list|)
argument_list|,
operator|*
name|methods
argument_list|,
name|old
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Only complain if we shadow something we can access.  */
if|if
condition|(
name|old
operator|&&
name|warn_shadow
operator|&&
operator|(
operator|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|old
argument_list|)
operator|&&
name|DECL_CLASS_CONTEXT
argument_list|(
name|old
argument_list|)
operator|==
name|current_class_type
operator|)
operator|||
operator|!
name|TREE_PRIVATE
argument_list|(
name|old
argument_list|)
operator|)
condition|)
comment|/* Should figure out access control more accurately.  */
block|{
name|cp_warning_at
argument_list|(
literal|"member `%#D' is shadowed"
argument_list|,
name|old
argument_list|)
expr_stmt|;
name|cp_warning_at
argument_list|(
literal|"by member function `%#D'"
argument_list|,
operator|*
name|methods
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"in this context"
argument_list|)
expr_stmt|;
block|}
name|tmp
operator|=
name|build_tree_list
argument_list|(
name|DECL_NAME
argument_list|(
operator|*
name|methods
argument_list|)
argument_list|,
operator|*
name|methods
argument_list|)
expr_stmt|;
block|}
name|pop_obstacks
argument_list|()
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|tmp
argument_list|)
operator|=
name|unknown_type_node
expr_stmt|;
if|#
directive|if
literal|0
block|TREE_OVERLOADED (tmp) = DECL_OVERLOADED (*methods);
endif|#
directive|endif
name|TREE_NONLOCAL_FLAG
argument_list|(
name|tmp
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Put the new contents in our envelope.  */
name|TREE_PURPOSE
argument_list|(
name|class_value
argument_list|)
operator|=
name|tmp
expr_stmt|;
block|}
else|else
block|{
name|maybe_push_cache_obstack
argument_list|()
expr_stmt|;
name|tmp
operator|=
name|build_tree_list
argument_list|(
name|DECL_NAME
argument_list|(
operator|*
name|methods
argument_list|)
argument_list|,
operator|*
name|methods
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|tmp
argument_list|)
operator|=
name|unknown_type_node
expr_stmt|;
if|#
directive|if
literal|0
block|TREE_OVERLOADED (tmp) = DECL_OVERLOADED (*methods);
endif|#
directive|endif
name|TREE_NONLOCAL_FLAG
argument_list|(
name|tmp
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* See comment above for a description of envelopes.  */
name|closed_envelopes
operator|=
name|tree_cons
argument_list|(
name|tmp
argument_list|,
name|class_value
argument_list|,
name|closed_envelopes
argument_list|)
expr_stmt|;
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
operator|*
name|methods
argument_list|)
argument_list|)
operator|=
name|closed_envelopes
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|tmp = *methods; 	  while (tmp != 0) 	    { 	      DECL_PUBLIC (tmp) = 0; 	      DECL_PROTECTED (tmp) = 0; 	      DECL_PRIVATE (tmp) = 0; 	      tmp = DECL_CHAIN (tmp); 	    }
endif|#
directive|endif
name|methods
operator|++
expr_stmt|;
block|}
block|}
name|SET_BINFO_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Consolidate unique (by name) member functions.  */
end_comment

begin_function
specifier|static
name|void
name|dfs_compress_decls
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
name|tree
name|type
init|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|tree
name|method_vec
init|=
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|method_vec
operator|!=
literal|0
condition|)
block|{
comment|/* Farm out constructors and destructors.  */
name|tree
modifier|*
name|methods
init|=
operator|&
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
modifier|*
name|end
init|=
name|TREE_VEC_END
argument_list|(
name|method_vec
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|methods
operator|!=
name|end
condition|;
name|methods
operator|++
control|)
block|{
comment|/* This is known to be an envelope of the kind described before 	     dfs_pushdecls.  */
name|tree
name|class_value
init|=
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
operator|*
name|methods
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|tmp
init|=
name|TREE_PURPOSE
argument_list|(
name|class_value
argument_list|)
decl_stmt|;
comment|/* This was replaced in scope by somebody else.  Just leave it 	     alone.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tmp
argument_list|)
operator|!=
name|TREE_LIST
condition|)
continue|continue;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|tmp
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|TREE_VALUE
argument_list|(
name|tmp
argument_list|)
operator|&&
name|DECL_CHAIN
argument_list|(
name|TREE_VALUE
argument_list|(
name|tmp
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|TREE_PURPOSE
argument_list|(
name|class_value
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|CLEAR_BINFO_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* When entering the scope of a class, we cache all of the    fields that that class provides within its inheritance    lattice.  Where ambiguities result, we mark them    with `error_mark_node' so that if they are encountered    without explicit qualification, we can emit an error    message.  */
end_comment

begin_function
name|void
name|push_class_decls
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|id
decl_stmt|;
name|struct
name|obstack
modifier|*
name|ambient_obstack
init|=
name|current_obstack
decl_stmt|;
if|#
directive|if
literal|0
block|tree tags = CLASSTYPE_TAGS (type);    while (tags)     {       tree code_type_node;       tree tag;        switch (TREE_CODE (TREE_VALUE (tags))) 	{ 	case ENUMERAL_TYPE: 	  code_type_node = enum_type_node; 	  break; 	case RECORD_TYPE: 	  code_type_node = record_type_node; 	  break; 	case CLASS_TYPE: 	  code_type_node = class_type_node; 	  break; 	case UNION_TYPE: 	  code_type_node = union_type_node; 	  break; 	default: 	  my_friendly_abort (297); 	}       tag = xref_tag (code_type_node, TREE_PURPOSE (tags), 		      TYPE_BINFO_BASETYPE (TREE_VALUE (tags), 0), 0);
if|#
directive|if
literal|0
comment|/* not yet, should get fixed properly later */
block|pushdecl (make_type_decl (TREE_PURPOSE (tags), TREE_VALUE (tags)));
else|#
directive|else
block|pushdecl (build_decl (TYPE_DECL, TREE_PURPOSE (tags), TREE_VALUE (tags)));
endif|#
directive|endif
block|}
endif|#
directive|endif
name|search_stack
operator|=
name|push_search_level
argument_list|(
name|search_stack
argument_list|,
operator|&
name|search_obstack
argument_list|)
expr_stmt|;
name|id
operator|=
name|TYPE_IDENTIFIER
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (IDENTIFIER_TEMPLATE (id) != 0)     {       tree tmpl = IDENTIFIER_TEMPLATE (id);       push_template_decls (DECL_ARGUMENTS (TREE_PURPOSE (tmpl)), 			   TREE_VALUE (tmpl), 1);       overload_template_name (id, 1);     }
endif|#
directive|endif
comment|/* Push class fields into CLASS_VALUE scope, and mark.  */
name|dfs_walk
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|dfs_pushdecls
argument_list|,
name|unmarkedp
argument_list|)
expr_stmt|;
comment|/* Compress fields which have only a single entry      by a given name, and unmark.  */
name|dfs_walk
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|dfs_compress_decls
argument_list|,
name|markedp
argument_list|)
expr_stmt|;
comment|/* Open up all the closed envelopes and push the contained decls into      class scope.  */
while|while
condition|(
name|closed_envelopes
condition|)
block|{
name|tree
name|new
init|=
name|TREE_PURPOSE
argument_list|(
name|closed_envelopes
argument_list|)
decl_stmt|;
name|tree
name|id
decl_stmt|;
comment|/* This is messy because the class value may be a *_DECL, or a 	 TREE_LIST of overloaded *_DECLs or even a TREE_LIST of ambiguous 	 *_DECLs.  The name is stored at different places in these three 	 cases.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|new
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|new
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|id
operator|=
name|TREE_PURPOSE
argument_list|(
name|new
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|node
init|=
name|TREE_VALUE
argument_list|(
name|new
argument_list|)
decl_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|node
operator|=
name|TREE_VALUE
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|id
operator|=
name|DECL_NAME
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|id
operator|=
name|DECL_NAME
argument_list|(
name|new
argument_list|)
expr_stmt|;
comment|/* Install the original class value in order to make 	 pushdecl_class_level work correctly.  */
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|id
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|closed_envelopes
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|new
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|push_class_level_binding
argument_list|(
name|id
argument_list|,
name|new
argument_list|)
expr_stmt|;
else|else
name|pushdecl_class_level
argument_list|(
name|new
argument_list|)
expr_stmt|;
name|closed_envelopes
operator|=
name|TREE_CHAIN
argument_list|(
name|closed_envelopes
argument_list|)
expr_stmt|;
block|}
name|current_obstack
operator|=
name|ambient_obstack
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Here's a subroutine we need because C lacks lambdas.  */
end_comment

begin_function
specifier|static
name|void
name|dfs_unuse_fields
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|tree
name|fields
decl_stmt|;
for|for
control|(
name|fields
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|fields
condition|;
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fields
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
continue|continue;
name|TREE_USED
argument_list|(
name|fields
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fields
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
condition|)
name|unuse_fields
argument_list|(
name|TREE_TYPE
argument_list|(
name|fields
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|unuse_fields
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|dfs_walk
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|dfs_unuse_fields
argument_list|,
name|unmarkedp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pop_class_decls
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
comment|/* We haven't pushed a search level when dealing with cached classes,      so we'd better not try to pop it.  */
if|if
condition|(
name|search_stack
condition|)
name|search_stack
operator|=
name|pop_search_level
argument_list|(
name|search_stack
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|print_search_statistics
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
if|if
condition|(
name|flag_memoize_lookups
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d memoized contexts saved\n"
argument_list|,
name|n_contexts_saved
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d local tree nodes made\n"
argument_list|,
name|my_tree_node_counter
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d local hash nodes made\n"
argument_list|,
name|my_memoized_entry_counter
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"fields statistics:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  memoized finds = %d; rejects = %d; (searches = %d)\n"
argument_list|,
name|memoized_fast_finds
index|[
literal|0
index|]
argument_list|,
name|memoized_fast_rejects
index|[
literal|0
index|]
argument_list|,
name|memoized_fields_searched
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  memoized_adds = %d\n"
argument_list|,
name|memoized_adds
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"fnfields statistics:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  memoized finds = %d; rejects = %d; (searches = %d)\n"
argument_list|,
name|memoized_fast_finds
index|[
literal|1
index|]
argument_list|,
name|memoized_fast_rejects
index|[
literal|1
index|]
argument_list|,
name|memoized_fields_searched
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  memoized_adds = %d\n"
argument_list|,
name|memoized_adds
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d fields searched in %d[%d] calls to lookup_field[_1]\n"
argument_list|,
name|n_fields_searched
argument_list|,
name|n_calls_lookup_field
argument_list|,
name|n_calls_lookup_field_1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d fnfields searched in %d calls to lookup_fnfields\n"
argument_list|,
name|n_outer_fields_searched
argument_list|,
name|n_calls_lookup_fnfields
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d calls to get_base_type\n"
argument_list|,
name|n_calls_get_base_type
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"no search statistics\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|init_search_processing
parameter_list|()
block|{
name|gcc_obstack_init
argument_list|(
operator|&
name|search_obstack
argument_list|)
expr_stmt|;
name|gcc_obstack_init
argument_list|(
operator|&
name|type_obstack
argument_list|)
expr_stmt|;
name|gcc_obstack_init
argument_list|(
operator|&
name|type_obstack_entries
argument_list|)
expr_stmt|;
comment|/* This gives us room to build our chains of basetypes,      whether or not we decide to memoize them.  */
name|type_stack
operator|=
name|push_type_level
argument_list|(
literal|0
argument_list|,
operator|&
name|type_obstack
argument_list|)
expr_stmt|;
name|_vptr_name
operator|=
name|get_identifier
argument_list|(
literal|"_vptr"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|reinit_search_statistics
parameter_list|()
block|{
name|my_memoized_entry_counter
operator|=
literal|0
expr_stmt|;
name|memoized_fast_finds
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|memoized_fast_finds
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|memoized_adds
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|memoized_adds
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|memoized_fast_rejects
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|memoized_fast_rejects
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|memoized_fields_searched
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|memoized_fields_searched
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|n_fields_searched
operator|=
literal|0
expr_stmt|;
name|n_calls_lookup_field
operator|=
literal|0
operator|,
name|n_calls_lookup_field_1
operator|=
literal|0
expr_stmt|;
name|n_calls_lookup_fnfields
operator|=
literal|0
operator|,
name|n_calls_lookup_fnfields_1
operator|=
literal|0
expr_stmt|;
name|n_calls_get_base_type
operator|=
literal|0
expr_stmt|;
name|n_outer_fields_searched
operator|=
literal|0
expr_stmt|;
name|n_contexts_saved
operator|=
literal|0
expr_stmt|;
block|}
end_function

end_unit

