begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Handle exceptional things in C++.    Copyright (C) 1989, 1992, 1993, 1994 Free Software Foundation, Inc.    Contributed by Michael Tiemann<tiemann@cygnus.com>    Rewritten by Mike Stump<mrs@cygnus.com>, based upon an    initial re-implementation courtesy Tad Hunt.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* High-level class interface. */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_extern
extern|extern void (*interim_eh_hook
end_extern

begin_expr_stmt
unit|)
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* holds the fndecl for __builtin_return_address () */
end_comment

begin_decl_stmt
name|tree
name|builtin_return_address_fndecl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Define at your own risk!  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CROSS_COMPILE
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|sun
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|sparc
end_ifdef

begin_define
define|#
directive|define
name|TRY_NEW_EH
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TRY_NEW_EH
end_ifndef

begin_function
specifier|static
name|void
name|sorry_no_eh
parameter_list|()
block|{
specifier|static
name|int
name|warned
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|warned
condition|)
block|{
name|sorry
argument_list|(
literal|"exception handling not supported"
argument_list|)
expr_stmt|;
name|warned
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|build_exception_table
parameter_list|()
block|{ }
end_function

begin_function
name|void
name|expand_exception_blocks
parameter_list|()
block|{ }
end_function

begin_function
name|void
name|start_protect
parameter_list|()
block|{ }
end_function

begin_function
name|void
name|end_protect
parameter_list|(
name|finalization
parameter_list|)
name|tree
name|finalization
decl_stmt|;
block|{ }
end_function

begin_function
name|void
name|expand_start_try_stmts
parameter_list|()
block|{
name|sorry_no_eh
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|expand_end_try_stmts
parameter_list|()
block|{ }
end_function

begin_function
name|void
name|expand_start_all_catch
parameter_list|()
block|{ }
end_function

begin_function
name|void
name|expand_end_all_catch
parameter_list|()
block|{ }
end_function

begin_function
name|void
name|expand_start_catch_block
parameter_list|(
name|declspecs
parameter_list|,
name|declarator
parameter_list|)
name|tree
name|declspecs
decl_stmt|,
name|declarator
decl_stmt|;
block|{ }
end_function

begin_function
name|void
name|expand_end_catch_block
parameter_list|()
block|{ }
end_function

begin_function
name|void
name|init_exception_processing
parameter_list|()
block|{ }
end_function

begin_function
name|void
name|expand_throw
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
name|sorry_no_eh
argument_list|()
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|int
name|doing_eh
parameter_list|(
name|do_warn
parameter_list|)
name|int
name|do_warn
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|flag_handle_exceptions
condition|)
block|{
specifier|static
name|int
name|warned
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|warned
operator|&&
name|do_warn
condition|)
block|{
name|error
argument_list|(
literal|"exception handling disabled, use -fhandle-exceptions to enable."
argument_list|)
expr_stmt|;
name|warned
operator|=
literal|1
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* NO GNEWS IS GOOD GNEWS WITH GARRY GNUS: This version is much closer to supporting exception handling as per Stroustrup's 2nd edition. It is a complete rewrite of all the EH stuff that was here before 	Shortcomings: 		1. The type of the throw and catch must still match 		   exactly (no support yet for matching base classes) 		2. Throw specifications of functions still doesnt't work. 	Cool Things: 		1. Destructors are called properly :-) 		2. No overhead for the non-exception thrown case. 		3. Fixing shortcomings 1 and 2 is simple. 			-Tad Hunt	(tad@mail.csh.rit.edu)  */
end_comment

begin_comment
comment|/* A couple of backend routines from m88k.c */
end_comment

begin_comment
comment|/* used to cache a call to __builtin_return_address () */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|BuiltinReturnAddress
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/* XXX - Tad: for EH */
end_comment

begin_comment
comment|/* output an exception table entry */
end_comment

begin_function
specifier|static
name|void
name|output_exception_table_entry
parameter_list|(
name|file
parameter_list|,
name|start_label
parameter_list|,
name|end_label
parameter_list|,
name|eh_label
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|rtx
name|start_label
decl_stmt|,
name|end_label
decl_stmt|,
name|eh_label
decl_stmt|;
block|{
name|char
name|label
index|[
literal|100
index|]
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t%s\t "
argument_list|,
name|ASM_LONG
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|start_label
argument_list|)
operator|==
name|CODE_LABEL
condition|)
block|{
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|label
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|start_label
argument_list|)
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|start_label
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"YYYYYYYYYEEEEEEEESSSSSSSSSSSS!!!!!!!!!!\n"
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|XSTR
argument_list|(
name|start_label
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t%s\t "
argument_list|,
name|ASM_LONG
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|label
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|end_label
argument_list|)
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t%s\t "
argument_list|,
name|ASM_LONG
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|label
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|eh_label
argument_list|)
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* blank line */
block|}
end_function

begin_function
specifier|static
name|void
name|easy_expand_asm
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|expand_asm
argument_list|(
name|build_string
argument_list|(
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
argument_list|,
name|str
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* unwind the stack. */
end_comment

begin_function
specifier|static
name|void
name|do_unwind
parameter_list|(
name|throw_label
parameter_list|)
name|rtx
name|throw_label
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|sparc
specifier|extern
name|FILE
modifier|*
name|asm_out_file
decl_stmt|;
name|tree
name|fcall
decl_stmt|;
name|tree
name|params
decl_stmt|;
name|rtx
name|return_val_rtx
decl_stmt|;
comment|/* call to  __builtin_return_address () */
name|params
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_zero_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|fcall
operator|=
name|build_function_call
argument_list|(
name|BuiltinReturnAddress
argument_list|,
name|params
argument_list|)
expr_stmt|;
name|return_val_rtx
operator|=
name|expand_expr
argument_list|(
name|fcall
argument_list|,
name|NULL_RTX
argument_list|,
name|SImode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* In the return, the new pc is pc+8, as the value comming in is      really the address of the call insn, not the next insn.  */
name|emit_move_insn
argument_list|(
name|return_val_rtx
argument_list|,
name|plus_constant
argument_list|(
name|gen_rtx
argument_list|(
name|LABEL_REF
argument_list|,
name|Pmode
argument_list|,
name|throw_label
argument_list|)
argument_list|,
operator|-
literal|8
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We use three values, PC, type, and value */
name|easy_expand_asm
argument_list|(
literal|"st %l0,[%fp]"
argument_list|)
expr_stmt|;
name|easy_expand_asm
argument_list|(
literal|"st %l1,[%fp+4]"
argument_list|)
expr_stmt|;
name|easy_expand_asm
argument_list|(
literal|"st %l2,[%fp+8]"
argument_list|)
expr_stmt|;
name|easy_expand_asm
argument_list|(
literal|"ret"
argument_list|)
expr_stmt|;
name|easy_expand_asm
argument_list|(
literal|"restore"
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|m88k
name|rtx
name|temp_frame
init|=
name|frame_pointer_rtx
decl_stmt|;
name|temp_frame
operator|=
name|memory_address
argument_list|(
name|Pmode
argument_list|,
name|temp_frame
argument_list|)
expr_stmt|;
name|temp_frame
operator|=
name|copy_to_reg
argument_list|(
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|Pmode
argument_list|,
name|temp_frame
argument_list|)
argument_list|)
expr_stmt|;
comment|/* hopefully this will successfully pop the frame! */
name|emit_move_insn
argument_list|(
name|frame_pointer_rtx
argument_list|,
name|temp_frame
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|frame_pointer_rtx
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|arg_pointer_rtx
argument_list|,
name|frame_pointer_rtx
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_add2_insn
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
name|m88k_debugger_offset
argument_list|(
name|stack_pointer_rtx
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|emit_insn (gen_add2_insn (arg_pointer_rtx, gen_rtx (CONST_INT, VOIDmode, 						   -(HOST_WIDE_INT)m88k_debugger_offset (arg_pointer_rtx, 0))));    emit_move_insn (stack_pointer_rtx, arg_pointer_rtx);    emit_insn (gen_add2_insn (stack_pointer_rtx, gen_rtx (CONST_INT, VOIDmode, 						     (HOST_WIDE_INT)m88k_debugger_offset (arg_pointer_rtx, 0))));
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* This is the startup, and finish stuff per exception table. */
end_comment

begin_comment
comment|/* XXX - Tad: exception handling section */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|EXCEPT_SECTION_ASM_OP
end_ifndef

begin_define
define|#
directive|define
name|EXCEPT_SECTION_ASM_OP
value|"section\t.gcc_except_table,\"a\",@progbits"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EXCEPT_SECTION_ASM_OP
end_ifdef

begin_endif
unit|typedef struct {     void *start_protect;     void *end_protect;     void *exception_handler;  } exception_table;
endif|#
directive|endif
end_endif

begin_comment
comment|/* EXCEPT_SECTION_ASM_OP */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|EXCEPT_SECTION_ASM_OP
end_ifdef

begin_comment
comment|/* on machines which support it, the exception table lives in another section, 	but it needs a label so we can reference it...  This sets up that     label! */
end_comment

begin_endif
unit|asm (EXCEPT_SECTION_ASM_OP); exception_table __EXCEPTION_TABLE__[1] = { (void*)0, (void*)0, (void*)0 }; asm (TEXT_SECTION_ASM_OP);
endif|#
directive|endif
end_endif

begin_comment
comment|/* EXCEPT_SECTION_ASM_OP */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|EXCEPT_SECTION_ASM_OP
end_ifdef

begin_comment
comment|/* we need to know where the end of the exception table is... so this     is how we do it! */
end_comment

begin_endif
unit|asm (EXCEPT_SECTION_ASM_OP); exception_table __EXCEPTION_END__[1] = { (void*)-1, (void*)-1, (void*)-1 }; asm (TEXT_SECTION_ASM_OP);
endif|#
directive|endif
end_endif

begin_comment
comment|/* EXCEPT_SECTION_ASM_OP */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|exception_section
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|ASM_OUTPUT_SECTION_NAME
name|named_section
argument_list|(
literal|".gcc_except_table"
argument_list|)
expr_stmt|;
else|#
directive|else
name|text_section
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* from: my-cp-except.c */
end_comment

begin_comment
comment|/* VI: ":set ts=4" */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_include
include|#
directive|include
file|<stdio.h>
include|*/
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"decl.h"
end_include

begin_if
if|#
directive|if
literal|0
end_if

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"insn-flags.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_if
if|#
directive|if
literal|0
end_if

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ======================================================================    Briefly the algorithm works like this:       When a constructor or start of a try block is encountered,      push_eh_entry (&eh_stack) is called.  Push_eh_entry () creates a      new entry in the unwind protection stack and returns a label to      output to start the protection for that block.       When a destructor or end try block is encountered, pop_eh_entry      (&eh_stack) is called.  Pop_eh_entry () returns the ehEntry it      created when push_eh_entry () was called.  The ehEntry structure      contains three things at this point.  The start protect label,      the end protect label, and the exception handler label.  The end      protect label should be output before the call to the destructor      (if any). If it was a destructor, then its parse tree is stored      in the finalization variable in the ehEntry structure.  Otherwise      the finalization variable is set to NULL to reflect the fact that      is the the end of a try block.  Next, this modified ehEntry node      is enqueued in the finalizations queue by calling      enqueue_eh_entry (&queue,entry).  	+---------------------------------------------------------------+ 	|XXX: Will need modification to deal with partially		| 	|			constructed arrays of objects		| 	|								| 	|	Basically, this consists of keeping track of how many	| 	|	of the objects have been constructed already (this	| 	|	should be in a register though, so that shouldn't be a	| 	|	problem.						| 	+---------------------------------------------------------------+       When a catch block is encountered, there is a lot of work to be      done.       Since we don't want to generate the catch block inline with the      regular flow of the function, we need to have some way of doing      so.  Luckily, we have a couple of routines "get_last_insn ()" and      "set_last_insn ()" provided.  When the start of a catch block is      encountered, we save a pointer to the last insn generated.  After      the catch block is generated, we save a pointer to the first      catch block insn and the last catch block insn with the routines      "NEXT_INSN ()" and "get_last_insn ()".  We then set the last insn      to be the last insn generated before the catch block, and set the      NEXT_INSN (last_insn) to zero.       Since catch blocks might be nested inside other catch blocks, and      we munge the chain of generated insns after the catch block is      generated, we need to store the pointers to the last insn      generated in a stack, so that when the end of a catch block is      encountered, the last insn before the current catch block can be      popped and set to be the last insn, and the first and last insns      of the catch block just generated can be enqueue'd for output at      a later time.   		      Next we must insure that when the catch block is executed, all      finalizations for the matching try block have been completed.  If      any of those finalizations throw an exception, we must call      terminate according to the ARM (section r.15.6.1).  What this      means is that we need to dequeue and emit finalizations for each      entry in the ehQueue until we get to an entry with a NULL      finalization field.  For any of the finalization entries, if it      is not a call to terminate (), we must protect it by giving it      another start label, end label, and exception handler label,      setting its finalization tree to be a call to terminate (), and      enqueue'ing this new ehEntry to be output at an outer level.      Finally, after all that is done, we can get around to outputting      the catch block which basically wraps all the "catch (...) {...}"      statements in a big if/then/else construct that matches the      correct block to call.            ===================================================================== */
end_comment

begin_decl_stmt
specifier|extern
name|rtx
name|emit_insn
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|rtx
name|gen_nop
name|PROTO
argument_list|(
operator|(
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* local globals for function calls    ====================================================================== */
end_comment

begin_comment
comment|/* used to cache "terminate ()", "unexpected ()", "set_terminate ()", and    "set_unexpected ()" after default_conversion. (lib-except.c) */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|Terminate
decl_stmt|,
name|Unexpected
decl_stmt|,
name|SetTerminate
decl_stmt|,
name|SetUnexpected
decl_stmt|,
name|CatchMatch
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* used to cache __find_first_exception_table_match ()    for throw (lib-except.c)  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|FirstExceptionMatch
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* used to cache a call to __unwind_function () (lib-except.c) */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|Unwind
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* holds a ready to emit call to "terminate ()". */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|TerminateFunctionCall
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ====================================================================== */
end_comment

begin_comment
comment|/* data structures for my various quick and dirty stacks and queues    Eventually, most of this should go away, because I think it can be    integrated with stuff already built into the compiler. */
end_comment

begin_comment
comment|/* =================================================================== */
end_comment

begin_struct
struct|struct
name|labelNode
block|{
name|rtx
name|label
decl_stmt|;
name|struct
name|labelNode
modifier|*
name|chain
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* this is the most important structure here.  Basically this is how I store    an exception table entry internally. */
end_comment

begin_struct
struct|struct
name|ehEntry
block|{
name|rtx
name|start_label
decl_stmt|;
name|rtx
name|end_label
decl_stmt|;
name|rtx
name|exception_handler_label
decl_stmt|;
name|tree
name|finalization
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ehNode
block|{
name|struct
name|ehEntry
modifier|*
name|entry
decl_stmt|;
name|struct
name|ehNode
modifier|*
name|chain
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ehStack
block|{
name|struct
name|ehNode
modifier|*
name|top
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ehQueue
block|{
name|struct
name|ehNode
modifier|*
name|head
decl_stmt|;
name|struct
name|ehNode
modifier|*
name|tail
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|exceptNode
block|{
name|rtx
name|catchstart
decl_stmt|;
name|rtx
name|catchend
decl_stmt|;
name|struct
name|exceptNode
modifier|*
name|chain
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|exceptStack
block|{
name|struct
name|exceptNode
modifier|*
name|top
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* ========================================================================= */
end_comment

begin_comment
comment|/* local globals - these local globals are for storing data necessary for    generating the exception table and code in the correct order.     ========================================================================= */
end_comment

begin_comment
comment|/* Holds the pc for doing "throw" */
end_comment

begin_decl_stmt
name|rtx
name|saved_pc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Holds the type of the thing being thrown. */
end_comment

begin_decl_stmt
name|rtx
name|saved_throw_type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Holds the value being thrown.  */
end_comment

begin_decl_stmt
name|rtx
name|saved_throw_value
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|throw_label
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ehStack
name|ehstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ehQueue
name|ehqueue
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ehQueue
name|eh_table_output_queue
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|exceptStack
name|exceptstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|labelNode
modifier|*
name|false_label_stack
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|labelNode
modifier|*
name|caught_return_label_stack
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ========================================================================= */
end_comment

begin_comment
comment|/* function prototypes */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ehEntry
modifier|*
name|pop_eh_entry
name|PROTO
argument_list|(
operator|(
expr|struct
name|ehStack
operator|*
name|stack
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|enqueue_eh_entry
name|PROTO
argument_list|(
operator|(
expr|struct
name|ehQueue
operator|*
name|queue
operator|,
expr|struct
name|ehEntry
operator|*
name|entry
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|push_except_stmts
name|PROTO
argument_list|(
operator|(
expr|struct
name|exceptStack
operator|*
name|exceptstack
operator|,
name|rtx
name|catchstart
operator|,
name|rtx
name|catchend
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pop_except_stmts
name|PROTO
argument_list|(
operator|(
expr|struct
name|exceptStack
operator|*
name|exceptstack
operator|,
name|rtx
operator|*
name|catchstart
operator|,
name|rtx
operator|*
name|catchend
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|push_eh_entry
name|PROTO
argument_list|(
operator|(
expr|struct
name|ehStack
operator|*
name|stack
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ehEntry
modifier|*
name|dequeue_eh_entry
name|PROTO
argument_list|(
operator|(
expr|struct
name|ehQueue
operator|*
name|queue
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|new_eh_queue
name|PROTO
argument_list|(
operator|(
expr|struct
name|ehQueue
operator|*
name|queue
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|new_eh_stack
name|PROTO
argument_list|(
operator|(
expr|struct
name|ehStack
operator|*
name|stack
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|new_except_stack
name|PROTO
argument_list|(
operator|(
expr|struct
name|exceptStack
operator|*
name|queue
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|push_last_insn
name|PROTO
argument_list|(
operator|(
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|pop_last_insn
name|PROTO
argument_list|(
operator|(
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|push_label_entry
name|PROTO
argument_list|(
operator|(
expr|struct
name|labelNode
operator|*
operator|*
name|labelstack
operator|,
name|rtx
name|label
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|pop_label_entry
name|PROTO
argument_list|(
operator|(
expr|struct
name|labelNode
operator|*
operator|*
name|labelstack
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|top_label_entry
name|PROTO
argument_list|(
operator|(
expr|struct
name|labelNode
operator|*
operator|*
name|labelstack
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ehEntry
modifier|*
name|copy_eh_entry
name|PROTO
argument_list|(
operator|(
expr|struct
name|ehEntry
operator|*
name|entry
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* All my cheesy stack/queue/misc data structure handling routines     ========================================================================= */
end_comment

begin_function
specifier|static
name|void
name|push_label_entry
parameter_list|(
name|labelstack
parameter_list|,
name|label
parameter_list|)
name|struct
name|labelNode
modifier|*
modifier|*
name|labelstack
decl_stmt|;
name|rtx
name|label
decl_stmt|;
block|{
name|struct
name|labelNode
modifier|*
name|newnode
init|=
operator|(
expr|struct
name|labelNode
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|labelNode
argument_list|)
argument_list|)
decl_stmt|;
name|newnode
operator|->
name|label
operator|=
name|label
expr_stmt|;
name|newnode
operator|->
name|chain
operator|=
operator|*
name|labelstack
expr_stmt|;
operator|*
name|labelstack
operator|=
name|newnode
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|pop_label_entry
parameter_list|(
name|labelstack
parameter_list|)
name|struct
name|labelNode
modifier|*
modifier|*
name|labelstack
decl_stmt|;
block|{
name|rtx
name|label
decl_stmt|;
name|struct
name|labelNode
modifier|*
name|tempnode
decl_stmt|;
if|if
condition|(
operator|!
operator|*
name|labelstack
condition|)
return|return
name|NULL_RTX
return|;
name|tempnode
operator|=
operator|*
name|labelstack
expr_stmt|;
name|label
operator|=
name|tempnode
operator|->
name|label
expr_stmt|;
operator|*
name|labelstack
operator|=
operator|(
operator|*
name|labelstack
operator|)
operator|->
name|chain
expr_stmt|;
name|free
argument_list|(
name|tempnode
argument_list|)
expr_stmt|;
return|return
name|label
return|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|top_label_entry
parameter_list|(
name|labelstack
parameter_list|)
name|struct
name|labelNode
modifier|*
modifier|*
name|labelstack
decl_stmt|;
block|{
if|if
condition|(
operator|!
operator|*
name|labelstack
condition|)
return|return
name|NULL_RTX
return|;
return|return
operator|(
operator|*
name|labelstack
operator|)
operator|->
name|label
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|push_except_stmts
parameter_list|(
name|exceptstack
parameter_list|,
name|catchstart
parameter_list|,
name|catchend
parameter_list|)
name|struct
name|exceptStack
modifier|*
name|exceptstack
decl_stmt|;
name|rtx
name|catchstart
decl_stmt|,
name|catchend
decl_stmt|;
block|{
name|struct
name|exceptNode
modifier|*
name|newnode
init|=
operator|(
expr|struct
name|exceptNode
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|exceptNode
argument_list|)
argument_list|)
decl_stmt|;
name|newnode
operator|->
name|catchstart
operator|=
name|catchstart
expr_stmt|;
name|newnode
operator|->
name|catchend
operator|=
name|catchend
expr_stmt|;
name|newnode
operator|->
name|chain
operator|=
name|exceptstack
operator|->
name|top
expr_stmt|;
name|exceptstack
operator|->
name|top
operator|=
name|newnode
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pop_except_stmts
parameter_list|(
name|exceptstack
parameter_list|,
name|catchstart
parameter_list|,
name|catchend
parameter_list|)
name|struct
name|exceptStack
modifier|*
name|exceptstack
decl_stmt|;
name|rtx
modifier|*
name|catchstart
decl_stmt|,
decl|*
name|catchend
decl_stmt|;
end_function

begin_block
block|{
name|struct
name|exceptNode
modifier|*
name|tempnode
decl_stmt|;
if|if
condition|(
operator|!
name|exceptstack
operator|->
name|top
condition|)
block|{
operator|*
name|catchstart
operator|=
operator|*
name|catchend
operator|=
name|NULL_RTX
expr_stmt|;
return|return
literal|0
return|;
block|}
name|tempnode
operator|=
name|exceptstack
operator|->
name|top
expr_stmt|;
name|exceptstack
operator|->
name|top
operator|=
name|exceptstack
operator|->
name|top
operator|->
name|chain
expr_stmt|;
operator|*
name|catchstart
operator|=
name|tempnode
operator|->
name|catchstart
expr_stmt|;
operator|*
name|catchend
operator|=
name|tempnode
operator|->
name|catchend
expr_stmt|;
name|free
argument_list|(
name|tempnode
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/* Push to permanent obstack for rtl generation.    One level only!  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
modifier|*
name|saved_rtl_obstack
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|push_rtl_perm
parameter_list|()
block|{
specifier|extern
name|struct
name|obstack
name|permanent_obstack
decl_stmt|;
specifier|extern
name|struct
name|obstack
modifier|*
name|rtl_obstack
decl_stmt|;
name|saved_rtl_obstack
operator|=
name|rtl_obstack
expr_stmt|;
name|rtl_obstack
operator|=
operator|&
name|permanent_obstack
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pop back to normal rtl handling.  */
end_comment

begin_function
specifier|static
name|void
name|pop_rtl_from_perm
parameter_list|()
block|{
specifier|extern
name|struct
name|obstack
name|permanent_obstack
decl_stmt|;
specifier|extern
name|struct
name|obstack
modifier|*
name|rtl_obstack
decl_stmt|;
name|rtl_obstack
operator|=
name|saved_rtl_obstack
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|push_eh_entry
parameter_list|(
name|stack
parameter_list|)
name|struct
name|ehStack
modifier|*
name|stack
decl_stmt|;
block|{
name|struct
name|ehNode
modifier|*
name|node
init|=
operator|(
expr|struct
name|ehNode
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ehNode
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|ehEntry
modifier|*
name|entry
init|=
operator|(
expr|struct
name|ehEntry
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ehEntry
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|stack
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
return|return
name|NULL_RTX
return|;
block|}
comment|/* These are saved for the exception table.  */
name|push_rtl_perm
argument_list|()
expr_stmt|;
name|entry
operator|->
name|start_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|entry
operator|->
name|end_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|entry
operator|->
name|exception_handler_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|pop_rtl_from_perm
argument_list|()
expr_stmt|;
name|entry
operator|->
name|finalization
operator|=
name|NULL_TREE
expr_stmt|;
name|node
operator|->
name|entry
operator|=
name|entry
expr_stmt|;
name|node
operator|->
name|chain
operator|=
name|stack
operator|->
name|top
expr_stmt|;
name|stack
operator|->
name|top
operator|=
name|node
expr_stmt|;
name|enqueue_eh_entry
argument_list|(
operator|&
name|eh_table_output_queue
argument_list|,
name|copy_eh_entry
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|entry
operator|->
name|start_label
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ehEntry
modifier|*
name|pop_eh_entry
parameter_list|(
name|stack
parameter_list|)
name|struct
name|ehStack
modifier|*
name|stack
decl_stmt|;
block|{
name|struct
name|ehNode
modifier|*
name|tempnode
decl_stmt|;
name|struct
name|ehEntry
modifier|*
name|tempentry
decl_stmt|;
if|if
condition|(
name|stack
operator|&&
operator|(
name|tempnode
operator|=
name|stack
operator|->
name|top
operator|)
condition|)
block|{
name|tempentry
operator|=
name|tempnode
operator|->
name|entry
expr_stmt|;
name|stack
operator|->
name|top
operator|=
name|stack
operator|->
name|top
operator|->
name|chain
expr_stmt|;
name|free
argument_list|(
name|tempnode
argument_list|)
expr_stmt|;
return|return
name|tempentry
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ehEntry
modifier|*
name|copy_eh_entry
parameter_list|(
name|entry
parameter_list|)
name|struct
name|ehEntry
modifier|*
name|entry
decl_stmt|;
block|{
name|struct
name|ehEntry
modifier|*
name|newentry
decl_stmt|;
name|newentry
operator|=
operator|(
expr|struct
name|ehEntry
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ehEntry
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|void
operator|*
operator|)
name|newentry
argument_list|,
operator|(
name|void
operator|*
operator|)
name|entry
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ehEntry
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|newentry
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|enqueue_eh_entry
parameter_list|(
name|queue
parameter_list|,
name|entry
parameter_list|)
name|struct
name|ehQueue
modifier|*
name|queue
decl_stmt|;
name|struct
name|ehEntry
modifier|*
name|entry
decl_stmt|;
block|{
name|struct
name|ehNode
modifier|*
name|node
init|=
operator|(
expr|struct
name|ehNode
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ehNode
argument_list|)
argument_list|)
decl_stmt|;
name|node
operator|->
name|entry
operator|=
name|entry
expr_stmt|;
name|node
operator|->
name|chain
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|queue
operator|->
name|head
operator|==
name|NULL
condition|)
block|{
name|queue
operator|->
name|head
operator|=
name|node
expr_stmt|;
block|}
else|else
block|{
name|queue
operator|->
name|tail
operator|->
name|chain
operator|=
name|node
expr_stmt|;
block|}
name|queue
operator|->
name|tail
operator|=
name|node
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ehEntry
modifier|*
name|dequeue_eh_entry
parameter_list|(
name|queue
parameter_list|)
name|struct
name|ehQueue
modifier|*
name|queue
decl_stmt|;
block|{
name|struct
name|ehNode
modifier|*
name|tempnode
decl_stmt|;
name|struct
name|ehEntry
modifier|*
name|tempentry
decl_stmt|;
if|if
condition|(
name|queue
operator|->
name|head
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|tempnode
operator|=
name|queue
operator|->
name|head
expr_stmt|;
name|queue
operator|->
name|head
operator|=
name|queue
operator|->
name|head
operator|->
name|chain
expr_stmt|;
name|tempentry
operator|=
name|tempnode
operator|->
name|entry
expr_stmt|;
name|free
argument_list|(
name|tempnode
argument_list|)
expr_stmt|;
return|return
name|tempentry
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|new_eh_queue
parameter_list|(
name|queue
parameter_list|)
name|struct
name|ehQueue
modifier|*
name|queue
decl_stmt|;
block|{
name|queue
operator|->
name|head
operator|=
name|queue
operator|->
name|tail
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|new_eh_stack
parameter_list|(
name|stack
parameter_list|)
name|struct
name|ehStack
modifier|*
name|stack
decl_stmt|;
block|{
name|stack
operator|->
name|top
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|new_except_stack
parameter_list|(
name|stack
parameter_list|)
name|struct
name|exceptStack
modifier|*
name|stack
decl_stmt|;
block|{
name|stack
operator|->
name|top
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ========================================================================= */
end_comment

begin_function
name|void
name|lang_interim_eh
parameter_list|(
name|finalization
parameter_list|)
name|tree
name|finalization
decl_stmt|;
block|{
if|if
condition|(
name|finalization
condition|)
name|end_protect
argument_list|(
name|finalization
argument_list|)
expr_stmt|;
else|else
name|start_protect
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* sets up all the global eh stuff that needs to be initialized at the    start of compilation.     This includes: 		- Setting up all the function call trees 		- Initializing the ehqueue 		- Initializing the eh_table_output_queue 		- Initializing the ehstack 		- Initializing the exceptstack */
end_comment

begin_function
name|void
name|init_exception_processing
parameter_list|()
block|{
specifier|extern
name|tree
name|define_function
parameter_list|()
function_decl|;
name|tree
name|unexpected_fndecl
decl_stmt|,
name|terminate_fndecl
decl_stmt|;
name|tree
name|set_unexpected_fndecl
decl_stmt|,
name|set_terminate_fndecl
decl_stmt|;
name|tree
name|catch_match_fndecl
decl_stmt|;
name|tree
name|find_first_exception_match_fndecl
decl_stmt|;
name|tree
name|unwind_fndecl
decl_stmt|;
name|tree
name|temp
decl_stmt|,
name|PFV
decl_stmt|;
name|interim_eh_hook
operator|=
name|lang_interim_eh
expr_stmt|;
comment|/* void (*)() */
name|PFV
operator|=
name|build_pointer_type
argument_list|(
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|void_list_node
argument_list|)
argument_list|)
expr_stmt|;
comment|/* arg list for the build_function_type call for set_terminate () and      set_unexpected () */
name|temp
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|PFV
argument_list|,
name|void_list_node
argument_list|)
expr_stmt|;
name|push_lang_context
argument_list|(
name|lang_name_c
argument_list|)
expr_stmt|;
name|set_terminate_fndecl
operator|=
name|define_function
argument_list|(
literal|"set_terminate"
argument_list|,
name|build_function_type
argument_list|(
name|PFV
argument_list|,
name|temp
argument_list|)
argument_list|,
name|NOT_BUILT_IN
argument_list|,
name|pushdecl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_unexpected_fndecl
operator|=
name|define_function
argument_list|(
literal|"set_unexpected"
argument_list|,
name|build_function_type
argument_list|(
name|PFV
argument_list|,
name|temp
argument_list|)
argument_list|,
name|NOT_BUILT_IN
argument_list|,
name|pushdecl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|unexpected_fndecl
operator|=
name|define_function
argument_list|(
literal|"unexpected"
argument_list|,
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|void_list_node
argument_list|)
argument_list|,
name|NOT_BUILT_IN
argument_list|,
name|pushdecl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|terminate_fndecl
operator|=
name|define_function
argument_list|(
literal|"terminate"
argument_list|,
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|void_list_node
argument_list|)
argument_list|,
name|NOT_BUILT_IN
argument_list|,
name|pushdecl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|catch_match_fndecl
operator|=
name|define_function
argument_list|(
literal|"__throw_type_match"
argument_list|,
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|string_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|void_list_node
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|NOT_BUILT_IN
argument_list|,
name|pushdecl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|find_first_exception_match_fndecl
operator|=
name|define_function
argument_list|(
literal|"__find_first_exception_table_match"
argument_list|,
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|void_list_node
argument_list|)
argument_list|)
argument_list|,
name|NOT_BUILT_IN
argument_list|,
name|pushdecl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|unwind_fndecl
operator|=
name|define_function
argument_list|(
literal|"__unwind_function"
argument_list|,
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|void_list_node
argument_list|)
argument_list|)
argument_list|,
name|NOT_BUILT_IN
argument_list|,
name|pushdecl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Unexpected
operator|=
name|default_conversion
argument_list|(
name|unexpected_fndecl
argument_list|)
expr_stmt|;
name|Terminate
operator|=
name|default_conversion
argument_list|(
name|terminate_fndecl
argument_list|)
expr_stmt|;
name|SetTerminate
operator|=
name|default_conversion
argument_list|(
name|set_terminate_fndecl
argument_list|)
expr_stmt|;
name|SetUnexpected
operator|=
name|default_conversion
argument_list|(
name|set_unexpected_fndecl
argument_list|)
expr_stmt|;
name|CatchMatch
operator|=
name|default_conversion
argument_list|(
name|catch_match_fndecl
argument_list|)
expr_stmt|;
name|FirstExceptionMatch
operator|=
name|default_conversion
argument_list|(
name|find_first_exception_match_fndecl
argument_list|)
expr_stmt|;
name|Unwind
operator|=
name|default_conversion
argument_list|(
name|unwind_fndecl
argument_list|)
expr_stmt|;
name|BuiltinReturnAddress
operator|=
name|default_conversion
argument_list|(
name|builtin_return_address_fndecl
argument_list|)
expr_stmt|;
name|TerminateFunctionCall
operator|=
name|build_function_call
argument_list|(
name|Terminate
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|pop_lang_context
argument_list|()
expr_stmt|;
name|throw_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|saved_pc
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|Pmode
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|saved_throw_type
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|Pmode
argument_list|,
literal|17
argument_list|)
expr_stmt|;
name|saved_throw_value
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|Pmode
argument_list|,
literal|18
argument_list|)
expr_stmt|;
name|new_eh_queue
argument_list|(
operator|&
name|ehqueue
argument_list|)
expr_stmt|;
name|new_eh_queue
argument_list|(
operator|&
name|eh_table_output_queue
argument_list|)
expr_stmt|;
name|new_eh_stack
argument_list|(
operator|&
name|ehstack
argument_list|)
expr_stmt|;
name|new_except_stack
argument_list|(
operator|&
name|exceptstack
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* call this to begin a block of unwind protection (ie: when an object is    constructed) */
end_comment

begin_function
name|void
name|start_protect
parameter_list|()
block|{
if|if
condition|(
name|doing_eh
argument_list|(
literal|0
argument_list|)
condition|)
block|{
name|emit_label
argument_list|(
name|push_eh_entry
argument_list|(
operator|&
name|ehstack
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* call this to end a block of unwind protection.  the finalization tree is    the finalization which needs to be run in order to cleanly unwind through    this level of protection. (ie: call this when a scope is exited)*/
end_comment

begin_function
name|void
name|end_protect
parameter_list|(
name|finalization
parameter_list|)
name|tree
name|finalization
decl_stmt|;
block|{
name|struct
name|ehEntry
modifier|*
name|entry
init|=
name|pop_eh_entry
argument_list|(
operator|&
name|ehstack
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|doing_eh
argument_list|(
literal|0
argument_list|)
condition|)
return|return;
name|emit_label
argument_list|(
name|entry
operator|->
name|end_label
argument_list|)
expr_stmt|;
name|entry
operator|->
name|finalization
operator|=
name|finalization
expr_stmt|;
name|enqueue_eh_entry
argument_list|(
operator|&
name|ehqueue
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* call this on start of a try block. */
end_comment

begin_function
name|void
name|expand_start_try_stmts
parameter_list|()
block|{
if|if
condition|(
name|doing_eh
argument_list|(
literal|1
argument_list|)
condition|)
block|{
name|start_protect
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|expand_end_try_stmts
parameter_list|()
block|{
name|end_protect
argument_list|(
name|integer_zero_node
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|insn_save_node
block|{
name|rtx
name|last
decl_stmt|;
name|struct
name|insn_save_node
modifier|*
name|chain
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|insn_save_node
modifier|*
name|InsnSave
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used to keep track of where the catch blocks start.  */
end_comment

begin_function
specifier|static
name|void
name|push_last_insn
parameter_list|()
block|{
name|struct
name|insn_save_node
modifier|*
name|newnode
init|=
operator|(
expr|struct
name|insn_save_node
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|insn_save_node
argument_list|)
argument_list|)
decl_stmt|;
name|newnode
operator|->
name|last
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|newnode
operator|->
name|chain
operator|=
name|InsnSave
expr_stmt|;
name|InsnSave
operator|=
name|newnode
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Use to keep track of where the catch blocks start.  */
end_comment

begin_function
specifier|static
name|rtx
name|pop_last_insn
parameter_list|()
block|{
name|struct
name|insn_save_node
modifier|*
name|tempnode
decl_stmt|;
name|rtx
name|temprtx
decl_stmt|;
if|if
condition|(
operator|!
name|InsnSave
condition|)
return|return
name|NULL_RTX
return|;
name|tempnode
operator|=
name|InsnSave
expr_stmt|;
name|temprtx
operator|=
name|tempnode
operator|->
name|last
expr_stmt|;
name|InsnSave
operator|=
name|InsnSave
operator|->
name|chain
expr_stmt|;
name|free
argument_list|(
name|tempnode
argument_list|)
expr_stmt|;
return|return
name|temprtx
return|;
block|}
end_function

begin_comment
comment|/* call this to start processing of all the catch blocks. */
end_comment

begin_function
name|void
name|expand_start_all_catch
parameter_list|()
block|{
name|struct
name|ehEntry
modifier|*
name|entry
decl_stmt|;
name|rtx
name|label
decl_stmt|;
if|if
condition|(
operator|!
name|doing_eh
argument_list|(
literal|1
argument_list|)
condition|)
return|return;
name|emit_line_note
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
comment|/* The label for the exception handling block we will save.  */
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|push_label_entry
argument_list|(
operator|&
name|caught_return_label_stack
argument_list|,
name|label
argument_list|)
expr_stmt|;
comment|/* Remember where we started. */
name|push_last_insn
argument_list|()
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_nop
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Will this help us not stomp on it? */
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|USE
argument_list|,
name|VOIDmode
argument_list|,
name|saved_throw_type
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|USE
argument_list|,
name|VOIDmode
argument_list|,
name|saved_throw_value
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|entry
operator|=
name|dequeue_eh_entry
argument_list|(
operator|&
name|ehqueue
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|entry
operator|->
name|exception_handler_label
argument_list|)
expr_stmt|;
name|expand_expr
argument_list|(
name|entry
operator|->
name|finalization
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* When we get down to the matching entry, stop.  */
if|if
condition|(
name|entry
operator|->
name|finalization
operator|==
name|integer_zero_node
condition|)
break|break;
name|free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
comment|/* This goes when the below moves out of our way.  */
if|#
directive|if
literal|1
name|label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_jump
argument_list|(
name|label
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* All this should be out of line, and saved back in the exception handler      block area.  */
if|#
directive|if
literal|1
name|entry
operator|->
name|start_label
operator|=
name|entry
operator|->
name|exception_handler_label
expr_stmt|;
comment|/* These are saved for the exception table.  */
name|push_rtl_perm
argument_list|()
expr_stmt|;
name|entry
operator|->
name|end_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|entry
operator|->
name|exception_handler_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|entry
operator|->
name|finalization
operator|=
name|TerminateFunctionCall
expr_stmt|;
name|pop_rtl_from_perm
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|entry
operator|->
name|end_label
argument_list|)
expr_stmt|;
name|enqueue_eh_entry
argument_list|(
operator|&
name|eh_table_output_queue
argument_list|,
name|copy_eh_entry
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
comment|/* After running the finalization, continue on out to the next      cleanup, if we have nothing better to do.  */
name|emit_move_insn
argument_list|(
name|saved_pc
argument_list|,
name|gen_rtx
argument_list|(
name|LABEL_REF
argument_list|,
name|Pmode
argument_list|,
name|entry
operator|->
name|end_label
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Will this help us not stomp on it? */
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|USE
argument_list|,
name|VOIDmode
argument_list|,
name|saved_throw_type
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|USE
argument_list|,
name|VOIDmode
argument_list|,
name|saved_throw_value
argument_list|)
argument_list|)
expr_stmt|;
name|emit_jump
argument_list|(
name|throw_label
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|entry
operator|->
name|exception_handler_label
argument_list|)
expr_stmt|;
name|expand_expr
argument_list|(
name|entry
operator|->
name|finalization
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* call this to end processing of all the catch blocks. */
end_comment

begin_function
name|void
name|expand_end_all_catch
parameter_list|()
block|{
name|rtx
name|catchstart
decl_stmt|,
name|catchend
decl_stmt|,
name|last
decl_stmt|;
name|rtx
name|label
decl_stmt|;
if|if
condition|(
operator|!
name|doing_eh
argument_list|(
literal|1
argument_list|)
condition|)
return|return;
comment|/* Find the start of the catch block.  */
name|last
operator|=
name|pop_last_insn
argument_list|()
expr_stmt|;
name|catchstart
operator|=
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
expr_stmt|;
name|catchend
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
operator|=
literal|0
expr_stmt|;
name|set_last_insn
argument_list|(
name|last
argument_list|)
expr_stmt|;
comment|/* this level of catch blocks is done, so set up the successful catch jump      label for the next layer of catch blocks. */
name|pop_label_entry
argument_list|(
operator|&
name|caught_return_label_stack
argument_list|)
expr_stmt|;
name|push_except_stmts
argument_list|(
operator|&
name|exceptstack
argument_list|,
name|catchstart
argument_list|,
name|catchend
argument_list|)
expr_stmt|;
comment|/* Here we fall through into the continuation code.  */
block|}
end_function

begin_comment
comment|/* this is called from expand_exception_blocks () to expand the toplevel    finalizations for a function. */
end_comment

begin_function
name|void
name|expand_leftover_cleanups
parameter_list|()
block|{
name|struct
name|ehEntry
modifier|*
name|entry
decl_stmt|;
name|rtx
name|first_label
init|=
name|NULL_RTX
decl_stmt|;
if|if
condition|(
operator|!
name|doing_eh
argument_list|(
literal|0
argument_list|)
condition|)
return|return;
comment|/* Will this help us not stomp on it? */
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|USE
argument_list|,
name|VOIDmode
argument_list|,
name|saved_throw_type
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|USE
argument_list|,
name|VOIDmode
argument_list|,
name|saved_throw_value
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|entry
operator|=
name|dequeue_eh_entry
argument_list|(
operator|&
name|ehqueue
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|first_label
condition|)
name|first_label
operator|=
name|entry
operator|->
name|exception_handler_label
expr_stmt|;
name|emit_label
argument_list|(
name|entry
operator|->
name|exception_handler_label
argument_list|)
expr_stmt|;
name|expand_expr
argument_list|(
name|entry
operator|->
name|finalization
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* leftover try block, opps.  */
if|if
condition|(
name|entry
operator|->
name|finalization
operator|==
name|integer_zero_node
condition|)
name|abort
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|first_label
condition|)
block|{
name|rtx
name|label
decl_stmt|;
name|struct
name|ehEntry
name|entry
decl_stmt|;
comment|/* These are saved for the exception table.  */
name|push_rtl_perm
argument_list|()
expr_stmt|;
name|label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|entry
operator|.
name|start_label
operator|=
name|first_label
expr_stmt|;
name|entry
operator|.
name|end_label
operator|=
name|label
expr_stmt|;
name|entry
operator|.
name|exception_handler_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|entry
operator|.
name|finalization
operator|=
name|TerminateFunctionCall
expr_stmt|;
name|pop_rtl_from_perm
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|enqueue_eh_entry
argument_list|(
operator|&
name|eh_table_output_queue
argument_list|,
name|copy_eh_entry
argument_list|(
operator|&
name|entry
argument_list|)
argument_list|)
expr_stmt|;
comment|/* After running the finalization, continue on out to the next 	 cleanup, if we have nothing better to do.  */
name|emit_move_insn
argument_list|(
name|saved_pc
argument_list|,
name|gen_rtx
argument_list|(
name|LABEL_REF
argument_list|,
name|Pmode
argument_list|,
name|entry
operator|.
name|end_label
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Will this help us not stomp on it? */
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|USE
argument_list|,
name|VOIDmode
argument_list|,
name|saved_throw_type
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|USE
argument_list|,
name|VOIDmode
argument_list|,
name|saved_throw_value
argument_list|)
argument_list|)
expr_stmt|;
name|emit_jump
argument_list|(
name|throw_label
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|entry
operator|.
name|exception_handler_label
argument_list|)
expr_stmt|;
name|expand_expr
argument_list|(
name|entry
operator|.
name|finalization
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* call this to start a catch block. Typename is the typename, and identifier    is the variable to place the object in or NULL if the variable doesn't    matter.  If typename is NULL, that means its a "catch (...)" or catch    everything.  In that case we don't need to do any type checking.    (ie: it ends up as the "else" clause rather than an "else if" clause) */
end_comment

begin_function
name|void
name|expand_start_catch_block
parameter_list|(
name|declspecs
parameter_list|,
name|declarator
parameter_list|)
name|tree
name|declspecs
decl_stmt|,
name|declarator
decl_stmt|;
block|{
name|rtx
name|false_label_rtx
decl_stmt|;
name|rtx
name|protect_label_rtx
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|tree
name|init
decl_stmt|;
if|if
condition|(
operator|!
name|doing_eh
argument_list|(
literal|1
argument_list|)
condition|)
return|return;
comment|/* Create a binding level for the parm.  */
name|expand_start_bindings
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|declspecs
condition|)
block|{
name|tree
name|init_type
decl_stmt|;
name|decl
operator|=
name|grokdeclarator
argument_list|(
name|declarator
argument_list|,
name|declspecs
argument_list|,
name|NORMAL
argument_list|,
literal|1
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* Figure out the type that the initializer is. */
name|init_type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init_type
argument_list|)
operator|!=
name|REFERENCE_TYPE
condition|)
name|init_type
operator|=
name|build_reference_type
argument_list|(
name|init_type
argument_list|)
expr_stmt|;
name|init
operator|=
name|convert_from_reference
argument_list|(
name|save_expr
argument_list|(
name|make_tree
argument_list|(
name|init_type
argument_list|,
name|saved_throw_value
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Do we need the below two lines? */
comment|/* Let `finish_decl' know that this initializer is ok.  */
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|init
expr_stmt|;
comment|/* This needs to be preallocated under the try block, 	 in a union of all catch variables. */
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* peel back references, so they match. */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
else|else
name|type
operator|=
name|NULL_TREE
expr_stmt|;
name|false_label_rtx
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|push_label_entry
argument_list|(
operator|&
name|false_label_stack
argument_list|,
name|false_label_rtx
argument_list|)
expr_stmt|;
comment|/* This is saved for the exception table.  */
name|push_rtl_perm
argument_list|()
expr_stmt|;
name|protect_label_rtx
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|pop_rtl_from_perm
argument_list|()
expr_stmt|;
name|push_label_entry
argument_list|(
operator|&
name|false_label_stack
argument_list|,
name|protect_label_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
condition|)
block|{
name|tree
name|params
decl_stmt|;
name|char
modifier|*
name|typestring
decl_stmt|;
name|rtx
name|call_rtx
decl_stmt|,
name|return_value_rtx
decl_stmt|;
name|tree
name|catch_match_fcall
decl_stmt|;
name|tree
name|catchmatch_arg
decl_stmt|,
name|argval
decl_stmt|;
name|typestring
operator|=
name|build_overload_name
argument_list|(
name|type
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|params
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|combine_strings
argument_list|(
name|build_string
argument_list|(
name|strlen
argument_list|(
name|typestring
argument_list|)
operator|+
literal|1
argument_list|,
name|typestring
argument_list|)
argument_list|)
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|make_tree
argument_list|(
name|ptr_type_node
argument_list|,
name|saved_throw_type
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
name|catch_match_fcall
operator|=
name|build_function_call
argument_list|(
name|CatchMatch
argument_list|,
name|params
argument_list|)
expr_stmt|;
name|call_rtx
operator|=
name|expand_call
argument_list|(
name|catch_match_fcall
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|return_value_rtx
operator|=
name|hard_function_value
argument_list|(
name|integer_type_node
argument_list|,
name|catch_match_fcall
argument_list|)
expr_stmt|;
comment|/* did the throw type match function return TRUE? */
name|emit_cmp_insn
argument_list|(
name|return_value_rtx
argument_list|,
name|const0_rtx
argument_list|,
name|NE
argument_list|,
name|NULL_RTX
argument_list|,
name|GET_MODE
argument_list|(
name|return_value_rtx
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* if it returned FALSE, jump over the catch block, else fall into it */
name|emit_jump_insn
argument_list|(
name|gen_bne
argument_list|(
name|false_label_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|decl
argument_list|,
name|init
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Fall into the catch all section. */
block|}
comment|/* This is the starting of something to protect.  */
name|emit_label
argument_list|(
name|protect_label_rtx
argument_list|)
expr_stmt|;
name|emit_line_note
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Call this to end a catch block.  Its responsible for emitting the    code to handle jumping back to the correct place, and for emitting    the label to jump to if this catch block didn't match.  */
end_comment

begin_function
name|void
name|expand_end_catch_block
parameter_list|()
block|{
if|if
condition|(
name|doing_eh
argument_list|(
literal|1
argument_list|)
condition|)
block|{
name|rtx
name|start_protect_label_rtx
decl_stmt|;
name|rtx
name|end_protect_label_rtx
decl_stmt|;
name|tree
name|decls
decl_stmt|;
name|struct
name|ehEntry
name|entry
decl_stmt|;
comment|/* label we jump to if we caught the exception */
name|emit_jump
argument_list|(
name|top_label_entry
argument_list|(
operator|&
name|caught_return_label_stack
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Code to throw out to outer context, if we get an throw from within 	 our catch handler. */
comment|/* These are saved for the exception table.  */
name|push_rtl_perm
argument_list|()
expr_stmt|;
name|entry
operator|.
name|exception_handler_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|pop_rtl_from_perm
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|entry
operator|.
name|exception_handler_label
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|saved_pc
argument_list|,
name|gen_rtx
argument_list|(
name|LABEL_REF
argument_list|,
name|Pmode
argument_list|,
name|top_label_entry
argument_list|(
operator|&
name|caught_return_label_stack
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_jump
argument_list|(
name|throw_label
argument_list|)
expr_stmt|;
comment|/* No associated finalization.  */
name|entry
operator|.
name|finalization
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Because we are reordered out of line, we have to protect this. */
comment|/* label for the start of the protection region.  */
name|start_protect_label_rtx
operator|=
name|pop_label_entry
argument_list|(
operator|&
name|false_label_stack
argument_list|)
expr_stmt|;
comment|/* Cleanup the EH paramater.  */
name|expand_end_bindings
argument_list|(
name|decls
operator|=
name|getdecls
argument_list|()
argument_list|,
name|decls
operator|!=
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* label we emit to jump to if this catch block didn't match. */
name|emit_label
argument_list|(
name|end_protect_label_rtx
operator|=
name|pop_label_entry
argument_list|(
operator|&
name|false_label_stack
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Because we are reordered out of line, we have to protect this. */
name|entry
operator|.
name|start_label
operator|=
name|start_protect_label_rtx
expr_stmt|;
name|entry
operator|.
name|end_label
operator|=
name|end_protect_label_rtx
expr_stmt|;
comment|/* These set up a call to throw the caught exception into the outer        context.  */
name|enqueue_eh_entry
argument_list|(
operator|&
name|eh_table_output_queue
argument_list|,
name|copy_eh_entry
argument_list|(
operator|&
name|entry
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* cheesyness to save some typing. returns the return value rtx */
end_comment

begin_function
name|rtx
name|do_function_call
parameter_list|(
name|func
parameter_list|,
name|params
parameter_list|,
name|return_type
parameter_list|)
name|tree
name|func
decl_stmt|,
name|params
decl_stmt|,
name|return_type
decl_stmt|;
block|{
name|tree
name|func_call
decl_stmt|;
name|func_call
operator|=
name|build_function_call
argument_list|(
name|func
argument_list|,
name|params
argument_list|)
expr_stmt|;
name|expand_call
argument_list|(
name|func_call
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_type
operator|!=
name|NULL_TREE
condition|)
return|return
name|hard_function_value
argument_list|(
name|return_type
argument_list|,
name|func_call
argument_list|)
return|;
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_comment
comment|/* is called from expand_excpetion_blocks () to generate the code in a function    to "throw" if anything in the function needs to preform a throw.     expands "throw" as the following psuedo code:  	throw: 		eh = find_first_exception_match (saved_pc); 	    if (!eh) goto gotta_rethrow_it; 		goto eh;  	gotta_rethrow_it: 		saved_pc = __builtin_return_address (0); 		pop_to_previous_level (); 		goto throw;   */
end_comment

begin_function
specifier|static
name|void
name|expand_builtin_throw
parameter_list|()
block|{
name|tree
name|fcall
decl_stmt|;
name|tree
name|params
decl_stmt|;
name|rtx
name|return_val_rtx
decl_stmt|;
name|rtx
name|gotta_rethrow_it
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|rtx
name|gotta_call_terminate
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|rtx
name|unwind_and_throw
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|rtx
name|goto_unwind_and_throw
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|emit_label
argument_list|(
name|throw_label
argument_list|)
expr_stmt|;
comment|/* search for an exception handler for the saved_pc */
name|return_val_rtx
operator|=
name|do_function_call
argument_list|(
name|FirstExceptionMatch
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|make_tree
argument_list|(
name|ptr_type_node
argument_list|,
name|saved_pc
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
comment|/* did we find one? */
name|emit_cmp_insn
argument_list|(
name|return_val_rtx
argument_list|,
name|const0_rtx
argument_list|,
name|EQ
argument_list|,
name|NULL_RTX
argument_list|,
name|GET_MODE
argument_list|(
name|return_val_rtx
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* if not, jump to gotta_rethrow_it */
name|emit_jump_insn
argument_list|(
name|gen_beq
argument_list|(
name|gotta_rethrow_it
argument_list|)
argument_list|)
expr_stmt|;
comment|/* we found it, so jump to it */
name|emit_indirect_jump
argument_list|(
name|return_val_rtx
argument_list|)
expr_stmt|;
comment|/* code to deal with unwinding and looking for it again */
name|emit_label
argument_list|(
name|gotta_rethrow_it
argument_list|)
expr_stmt|;
comment|/* call to  __builtin_return_address () */
name|params
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_zero_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|fcall
operator|=
name|build_function_call
argument_list|(
name|BuiltinReturnAddress
argument_list|,
name|params
argument_list|)
expr_stmt|;
name|return_val_rtx
operator|=
name|expand_expr
argument_list|(
name|fcall
argument_list|,
name|NULL_RTX
argument_list|,
name|SImode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* did __builtin_return_address () return a valid address? */
name|emit_cmp_insn
argument_list|(
name|return_val_rtx
argument_list|,
name|const0_rtx
argument_list|,
name|EQ
argument_list|,
name|NULL_RTX
argument_list|,
name|GET_MODE
argument_list|(
name|return_val_rtx
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_beq
argument_list|(
name|gotta_call_terminate
argument_list|)
argument_list|)
expr_stmt|;
comment|/* yes it did */
name|emit_move_insn
argument_list|(
name|saved_pc
argument_list|,
name|return_val_rtx
argument_list|)
expr_stmt|;
name|do_unwind
argument_list|(
name|throw_label
argument_list|)
expr_stmt|;
name|emit_jump
argument_list|(
name|throw_label
argument_list|)
expr_stmt|;
comment|/* no it didn't --> therefore we need to call terminate */
name|emit_label
argument_list|(
name|gotta_call_terminate
argument_list|)
expr_stmt|;
name|do_function_call
argument_list|(
name|Terminate
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is called to expand all the toplevel exception handling    finalization for a function.  It should only be called once per    function.  */
end_comment

begin_function
name|void
name|expand_exception_blocks
parameter_list|()
block|{
name|rtx
name|catchstart
decl_stmt|,
name|catchend
decl_stmt|;
name|rtx
name|last
decl_stmt|;
specifier|static
name|rtx
name|funcend
decl_stmt|;
name|funcend
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_jump
argument_list|(
name|funcend
argument_list|)
expr_stmt|;
comment|/* expand_null_return (); */
while|while
condition|(
name|pop_except_stmts
argument_list|(
operator|&
name|exceptstack
argument_list|,
operator|&
name|catchstart
argument_list|,
operator|&
name|catchend
argument_list|)
condition|)
block|{
name|last
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
operator|=
name|catchstart
expr_stmt|;
name|PREV_INSN
argument_list|(
name|catchstart
argument_list|)
operator|=
name|last
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|catchend
argument_list|)
operator|=
literal|0
expr_stmt|;
name|set_last_insn
argument_list|(
name|catchend
argument_list|)
expr_stmt|;
block|}
name|expand_leftover_cleanups
argument_list|()
expr_stmt|;
block|{
specifier|static
name|int
name|have_done
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|have_done
operator|&&
name|TREE_PUBLIC
argument_list|(
name|current_function_decl
argument_list|)
operator|&&
operator|!
name|DECL_INLINE
argument_list|(
name|current_function_decl
argument_list|)
condition|)
block|{
name|have_done
operator|=
literal|1
expr_stmt|;
name|expand_builtin_throw
argument_list|()
expr_stmt|;
block|}
block|}
name|emit_label
argument_list|(
name|funcend
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* call this to expand a throw statement.  This follows the following    algorithm:  	1. Allocate space to save the current PC onto the stack. 	2. Generate and emit a label and save its address into the 		newly allocate stack space since we can't save the pc directly. 	3. If this is the first call to throw in this function: 		generate a label for the throw block 	4. jump to the throw block label.  */
end_comment

begin_function
name|void
name|expand_throw
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
name|rtx
name|label
decl_stmt|;
name|tree
name|type
decl_stmt|;
if|if
condition|(
operator|!
name|doing_eh
argument_list|(
literal|1
argument_list|)
condition|)
return|return;
comment|/* This is the label that represents where in the code we were, when      we got an exception.  This needs to be updated when we rethrow an      exception, so that the matching routine knows to search out.  */
name|label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|saved_pc
argument_list|,
name|gen_rtx
argument_list|(
name|LABEL_REF
argument_list|,
name|Pmode
argument_list|,
name|label
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
condition|)
block|{
comment|/* throw expression */
comment|/* First, decay it. */
name|exp
operator|=
name|default_conversion
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
block|{
name|char
modifier|*
name|typestring
init|=
name|build_overload_name
argument_list|(
name|type
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|throw_type
init|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|ptr_type_node
argument_list|,
name|combine_strings
argument_list|(
name|build_string
argument_list|(
name|strlen
argument_list|(
name|typestring
argument_list|)
operator|+
literal|1
argument_list|,
name|typestring
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|throw_type_rtx
init|=
name|expand_expr
argument_list|(
name|throw_type
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|throw_value_rtx
decl_stmt|;
name|emit_move_insn
argument_list|(
name|saved_throw_type
argument_list|,
name|throw_type_rtx
argument_list|)
expr_stmt|;
name|exp
operator|=
name|convert_to_reference
argument_list|(
name|build_reference_type
argument_list|(
name|build_type_variant
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|exp
argument_list|,
name|CONV_STATIC
argument_list|,
name|LOOKUP_COMPLAIN
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|==
name|error_mark_node
condition|)
name|error
argument_list|(
literal|"  in thrown expression"
argument_list|)
expr_stmt|;
name|throw_value_rtx
operator|=
name|expand_expr
argument_list|(
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|saved_throw_value
argument_list|,
name|throw_value_rtx
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* rethrow current exception */
comment|/* This part is easy, as we dont' have to do anything else.  */
block|}
name|emit_jump
argument_list|(
name|throw_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* output the exception table */
end_comment

begin_function
name|void
name|build_exception_table
parameter_list|()
block|{
specifier|extern
name|FILE
modifier|*
name|asm_out_file
decl_stmt|;
name|struct
name|ehEntry
modifier|*
name|entry
decl_stmt|;
if|if
condition|(
operator|!
name|doing_eh
argument_list|(
literal|0
argument_list|)
condition|)
return|return;
name|exception_section
argument_list|()
expr_stmt|;
comment|/* Beginning marker for table. */
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"        .global ___EXCEPTION_TABLE__\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"        .align 4\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"___EXCEPTION_TABLE__:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"        .word   0, 0, 0\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|entry
operator|=
name|dequeue_eh_entry
argument_list|(
operator|&
name|eh_table_output_queue
argument_list|)
condition|)
block|{
name|output_exception_table_entry
argument_list|(
name|asm_out_file
argument_list|,
name|entry
operator|->
name|start_label
argument_list|,
name|entry
operator|->
name|end_label
argument_list|,
name|entry
operator|->
name|exception_handler_label
argument_list|)
expr_stmt|;
block|}
comment|/* Ending marker for table. */
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"        .global ___EXCEPTION_END__\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"___EXCEPTION_END__:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"        .word   -1, -1, -1\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* end of: my-cp-except.c */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Build a throw expression.  */
end_comment

begin_function
name|tree
name|build_throw
parameter_list|(
name|e
parameter_list|)
name|tree
name|e
decl_stmt|;
block|{
name|e
operator|=
name|build1
argument_list|(
name|THROW_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|e
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|e
return|;
block|}
end_function

end_unit

