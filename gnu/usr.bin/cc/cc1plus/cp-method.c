begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Handle the hair of processing (but not expanding) inline functions.    Also manage function and variable name overloading.    Copyright (C) 1987, 1989, 1992, 1993 Free Software Foundation, Inc.    Contributed by Michael Tiemann (tiemann@cygnus.com)     This file is part of GNU CC.     GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PARM_CAN_BE_ARRAY_TYPE
end_ifndef

begin_define
define|#
directive|define
name|PARM_CAN_BE_ARRAY_TYPE
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Handle method declarations.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_comment
comment|/* TREE_LIST of the current inline functions that need to be    processed.  */
end_comment

begin_decl_stmt
name|struct
name|pending_inline
modifier|*
name|pending_inlines
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Obstack where we build text strings for overloading, etc.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|scratch_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|scratch_firstobj
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|OB_INIT
parameter_list|()
value|(scratch_firstobj ? (obstack_free (&scratch_obstack, scratch_firstobj), 0) : 0)
end_define

begin_define
define|#
directive|define
name|OB_PUTC
parameter_list|(
name|C
parameter_list|)
value|(obstack_1grow (&scratch_obstack, (C)))
end_define

begin_define
define|#
directive|define
name|OB_PUTC2
parameter_list|(
name|C1
parameter_list|,
name|C2
parameter_list|)
define|\
value|(obstack_1grow (&scratch_obstack, (C1)), obstack_1grow (&scratch_obstack, (C2)))
end_define

begin_define
define|#
directive|define
name|OB_PUTS
parameter_list|(
name|S
parameter_list|)
value|(obstack_grow (&scratch_obstack, (S), sizeof (S) - 1))
end_define

begin_define
define|#
directive|define
name|OB_PUTID
parameter_list|(
name|ID
parameter_list|)
define|\
value|(obstack_grow (&scratch_obstack, IDENTIFIER_POINTER (ID),	\ 		 IDENTIFIER_LENGTH (ID)))
end_define

begin_define
define|#
directive|define
name|OB_PUTCP
parameter_list|(
name|S
parameter_list|)
value|(obstack_grow (&scratch_obstack, (S), strlen (S)))
end_define

begin_define
define|#
directive|define
name|OB_FINISH
parameter_list|()
value|(obstack_1grow (&scratch_obstack, '\0'))
end_define

begin_comment
comment|/* Counter to help build parameter names in case they were omitted.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|dummy_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|in_parmlist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This points to a safe place to resume processing in case an expression    generates an error while we're trying to format it.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|scratch_error_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_type
argument_list|()
decl_stmt|,
name|dump_decl
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_init
argument_list|()
decl_stmt|,
name|dump_unary_op
argument_list|()
decl_stmt|,
name|dump_binary_op
argument_list|()
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|NO_AUTO_OVERLOAD
end_ifdef

begin_function_decl
name|int
name|is_overloaded
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|init_method
parameter_list|()
block|{
name|gcc_obstack_init
argument_list|(
operator|&
name|scratch_obstack
argument_list|)
expr_stmt|;
name|scratch_firstobj
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|scratch_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|tree
name|make_anon_parm_name
parameter_list|()
block|{
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
name|ANON_PARMNAME_FORMAT
argument_list|,
name|dummy_name
operator|++
argument_list|)
expr_stmt|;
return|return
name|get_identifier
argument_list|(
name|buf
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|clear_anon_parm_name
parameter_list|()
block|{
comment|/* recycle these names.  */
name|dummy_name
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_readonly_or_volatile
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
if|if
condition|(
name|TYPE_READONLY
argument_list|(
name|t
argument_list|)
condition|)
name|OB_PUTS
argument_list|(
literal|"const "
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_VOLATILE
argument_list|(
name|t
argument_list|)
condition|)
name|OB_PUTS
argument_list|(
literal|"volatile "
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_aggr_type
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|tree
name|name
decl_stmt|;
name|char
modifier|*
name|aggr_string
decl_stmt|;
name|char
modifier|*
name|context_string
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TYPE_READONLY
argument_list|(
name|t
argument_list|)
condition|)
name|OB_PUTS
argument_list|(
literal|"const "
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_VOLATILE
argument_list|(
name|t
argument_list|)
condition|)
name|OB_PUTS
argument_list|(
literal|"volatile "
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
name|aggr_string
operator|=
literal|"enum"
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|UNION_TYPE
condition|)
name|aggr_string
operator|=
literal|"union"
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
operator|&&
name|CLASSTYPE_DECLARED_CLASS
argument_list|(
name|t
argument_list|)
condition|)
name|aggr_string
operator|=
literal|"class"
expr_stmt|;
else|else
name|aggr_string
operator|=
literal|"struct"
expr_stmt|;
name|name
operator|=
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
if|#
directive|if
literal|0
comment|/* not yet, should get fixed properly later */
block|if (DECL_CONTEXT (name)) 	context_string = TYPE_NAME_STRING (DECL_CONTEXT (name));
else|#
directive|else
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|name
argument_list|)
operator|&&
name|DECL_CLASS_CONTEXT
argument_list|(
name|name
argument_list|)
condition|)
name|context_string
operator|=
name|TYPE_NAME_STRING
argument_list|(
name|DECL_CLASS_CONTEXT
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|name
operator|=
name|DECL_NAME
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
name|obstack_grow
argument_list|(
operator|&
name|scratch_obstack
argument_list|,
name|aggr_string
argument_list|,
name|strlen
argument_list|(
name|aggr_string
argument_list|)
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|context_string
condition|)
block|{
name|obstack_grow
argument_list|(
operator|&
name|scratch_obstack
argument_list|,
name|context_string
argument_list|,
name|strlen
argument_list|(
name|context_string
argument_list|)
argument_list|)
expr_stmt|;
name|OB_PUTC2
argument_list|(
literal|':'
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
block|}
name|OB_PUTID
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This must be large enough to hold any anonymous parm name.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|anon_buffer
index|[
sizeof|sizeof
argument_list|(
name|ANON_PARMNAME_FORMAT
argument_list|)
operator|+
literal|20
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This must be large enough to hold any printed integer or floatingpoint value.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|digit_buffer
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|dump_type_prefix
parameter_list|(
name|t
parameter_list|,
name|p
parameter_list|)
name|tree
name|t
decl_stmt|;
name|int
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|old_p
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL_TREE
condition|)
return|return;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|ERROR_MARK
case|:
name|sprintf
argument_list|(
name|anon_buffer
argument_list|,
name|ANON_PARMNAME_FORMAT
argument_list|,
name|dummy_name
operator|++
argument_list|)
expr_stmt|;
name|OB_PUTCP
argument_list|(
name|anon_buffer
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNKNOWN_TYPE
case|:
name|OB_PUTS
argument_list|(
literal|"<unknown type>"
argument_list|)
expr_stmt|;
return|return;
case|case
name|TREE_LIST
case|:
name|dump_type
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
operator|&
name|old_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|!=
name|void_list_node
condition|)
block|{
name|OB_PUTC
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|dump_type
argument_list|(
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
argument_list|,
operator|&
name|old_p
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|OB_PUTS
argument_list|(
literal|"..."
argument_list|)
expr_stmt|;
return|return;
case|case
name|POINTER_TYPE
case|:
operator|*
name|p
operator|+=
literal|1
expr_stmt|;
name|dump_type_prefix
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
name|OB_PUTC
argument_list|(
literal|'*'
argument_list|)
expr_stmt|;
operator|*
name|p
operator|-=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_READONLY
argument_list|(
name|t
argument_list|)
condition|)
name|OB_PUTS
argument_list|(
literal|"const "
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_VOLATILE
argument_list|(
name|t
argument_list|)
condition|)
name|OB_PUTS
argument_list|(
literal|"volatile "
argument_list|)
expr_stmt|;
return|return;
case|case
name|OFFSET_TYPE
case|:
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_parmlist
condition|)
name|OB_PUTS
argument_list|(
literal|"auto "
argument_list|)
expr_stmt|;
block|}
name|dump_type_prefix
argument_list|(
name|type
argument_list|,
operator|&
name|old_p
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
name|dump_type
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|t
argument_list|)
argument_list|,
operator|&
name|old_p
argument_list|)
expr_stmt|;
name|OB_PUTC2
argument_list|(
literal|':'
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
name|OB_PUTC
argument_list|(
literal|'*'
argument_list|)
expr_stmt|;
operator|*
name|p
operator|-=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_READONLY
argument_list|(
name|t
argument_list|)
operator||
name|TYPE_VOLATILE
argument_list|(
name|t
argument_list|)
condition|)
name|dump_readonly_or_volatile
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|METHOD_TYPE
case|:
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|in_parmlist
condition|)
name|OB_PUTS
argument_list|(
literal|"auto "
argument_list|)
expr_stmt|;
name|dump_type_prefix
argument_list|(
name|type
argument_list|,
operator|&
name|old_p
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
name|dump_type
argument_list|(
name|TYPE_METHOD_BASETYPE
argument_list|(
name|t
argument_list|)
argument_list|,
operator|&
name|old_p
argument_list|)
expr_stmt|;
name|OB_PUTC2
argument_list|(
literal|':'
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
name|OB_PUTC
argument_list|(
literal|'*'
argument_list|)
expr_stmt|;
operator|*
name|p
operator|-=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_READONLY
argument_list|(
name|t
argument_list|)
operator||
name|TYPE_VOLATILE
argument_list|(
name|t
argument_list|)
condition|)
name|dump_readonly_or_volatile
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|REFERENCE_TYPE
case|:
name|dump_type_prefix
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|'&'
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_READONLY
argument_list|(
name|t
argument_list|)
operator||
name|TYPE_VOLATILE
argument_list|(
name|t
argument_list|)
condition|)
name|dump_readonly_or_volatile
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return;
case|case
name|ARRAY_TYPE
case|:
if|if
condition|(
name|TYPE_READONLY
argument_list|(
name|t
argument_list|)
operator||
name|TYPE_VOLATILE
argument_list|(
name|t
argument_list|)
condition|)
name|dump_readonly_or_volatile
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|dump_type_prefix
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return;
case|case
name|FUNCTION_TYPE
case|:
if|if
condition|(
name|in_parmlist
condition|)
name|OB_PUTS
argument_list|(
literal|"auto "
argument_list|)
expr_stmt|;
name|dump_type_prefix
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
operator|&
name|old_p
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
name|OB_PUTC
argument_list|(
literal|'*'
argument_list|)
expr_stmt|;
operator|*
name|p
operator|-=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_READONLY
argument_list|(
name|t
argument_list|)
operator||
name|TYPE_VOLATILE
argument_list|(
name|t
argument_list|)
condition|)
name|dump_readonly_or_volatile
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return;
case|case
name|IDENTIFIER_NODE
case|:
name|OB_PUTID
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
break|break;
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
name|dump_aggr_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_DECL
case|:
if|if
condition|(
name|TYPE_READONLY
argument_list|(
name|t
argument_list|)
condition|)
name|OB_PUTS
argument_list|(
literal|"const "
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_VOLATILE
argument_list|(
name|t
argument_list|)
condition|)
name|OB_PUTS
argument_list|(
literal|"volatile "
argument_list|)
expr_stmt|;
name|OB_PUTID
argument_list|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
break|break;
case|case
name|INTEGER_TYPE
case|:
if|#
directive|if
literal|0
comment|/* Normally, `unsigned' is part of the deal.  Not so if it comes 	 with `const' or `volatile'.  */
block|if (TYPE_MAIN_VARIANT (t) == unsigned_type (TYPE_MAIN_VARIANT (t))&& (TYPE_READONLY (t) || TYPE_VOLATILE (t))) 	OB_PUTS ("unsigned ");
endif|#
directive|endif
comment|/* fall through.  */
case|case
name|REAL_TYPE
case|:
case|case
name|VOID_TYPE
case|:
if|if
condition|(
name|TYPE_READONLY
argument_list|(
name|t
argument_list|)
condition|)
name|OB_PUTS
argument_list|(
literal|"const "
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_VOLATILE
argument_list|(
name|t
argument_list|)
condition|)
name|OB_PUTS
argument_list|(
literal|"volatile "
argument_list|)
expr_stmt|;
name|OB_PUTID
argument_list|(
name|TYPE_IDENTIFIER
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
break|break;
default|default:
name|my_friendly_abort
argument_list|(
literal|65
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dump_type_suffix
parameter_list|(
name|t
parameter_list|,
name|p
parameter_list|)
name|tree
name|t
decl_stmt|;
name|int
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|old_p
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL_TREE
condition|)
return|return;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|ERROR_MARK
case|:
name|sprintf
argument_list|(
name|anon_buffer
argument_list|,
name|ANON_PARMNAME_FORMAT
argument_list|,
name|dummy_name
operator|++
argument_list|)
expr_stmt|;
name|OB_PUTCP
argument_list|(
name|anon_buffer
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNKNOWN_TYPE
case|:
return|return;
case|case
name|POINTER_TYPE
case|:
name|dump_type_suffix
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return;
case|case
name|OFFSET_TYPE
case|:
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|OB_PUTC
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
if|#
directive|if
literal|0
block|tree next_arg = TREE_CHAIN (TYPE_ARG_TYPES (type)); 	    OB_PUTC ('('); 	    if (next_arg) 	      { 		if (next_arg != void_list_node) 		  { 		    in_parmlist++; 		    dump_type (next_arg,&old_p); 		    in_parmlist--; 		  } 	      } 	    else OB_PUTS ("..."); 	    OB_PUTC (')'); 	    dump_type_suffix (TREE_TYPE (type), p);
else|#
directive|else
name|my_friendly_abort
argument_list|(
literal|66
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return;
block|}
case|case
name|METHOD_TYPE
case|:
block|{
name|tree
name|next_arg
decl_stmt|;
name|OB_PUTC
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
name|next_arg
operator|=
name|TREE_CHAIN
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_arg
condition|)
block|{
if|if
condition|(
name|next_arg
operator|!=
name|void_list_node
condition|)
block|{
name|in_parmlist
operator|++
expr_stmt|;
name|dump_type
argument_list|(
name|next_arg
argument_list|,
operator|&
name|old_p
argument_list|)
expr_stmt|;
name|in_parmlist
operator|--
expr_stmt|;
block|}
block|}
else|else
name|OB_PUTS
argument_list|(
literal|"..."
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
name|dump_readonly_or_volatile
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|dump_type_suffix
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|REFERENCE_TYPE
case|:
name|dump_type_suffix
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return;
case|case
name|ARRAY_TYPE
case|:
name|dump_type_suffix
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|OB_PUTC2
argument_list|(
literal|'['
argument_list|,
literal|']'
argument_list|)
expr_stmt|;
return|return;
case|case
name|FUNCTION_TYPE
case|:
name|OB_PUTC2
argument_list|(
literal|')'
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_ARG_TYPES
argument_list|(
name|t
argument_list|)
operator|&&
name|TYPE_ARG_TYPES
argument_list|(
name|t
argument_list|)
operator|!=
name|void_list_node
condition|)
block|{
name|in_parmlist
operator|++
expr_stmt|;
name|dump_type
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|t
argument_list|)
argument_list|,
operator|&
name|old_p
argument_list|)
expr_stmt|;
name|in_parmlist
operator|--
expr_stmt|;
block|}
name|OB_PUTC
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
name|dump_type_suffix
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return;
case|case
name|IDENTIFIER_NODE
case|:
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|TYPE_DECL
case|:
case|case
name|INTEGER_TYPE
case|:
case|case
name|REAL_TYPE
case|:
case|case
name|VOID_TYPE
case|:
return|return;
default|default:
name|my_friendly_abort
argument_list|(
literal|67
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dump_type
parameter_list|(
name|t
parameter_list|,
name|p
parameter_list|)
name|tree
name|t
decl_stmt|;
name|int
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|old_p
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL_TREE
condition|)
return|return;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|ERROR_MARK
case|:
name|sprintf
argument_list|(
name|anon_buffer
argument_list|,
name|ANON_PARMNAME_FORMAT
argument_list|,
name|dummy_name
operator|++
argument_list|)
expr_stmt|;
name|OB_PUTCP
argument_list|(
name|anon_buffer
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNKNOWN_TYPE
case|:
name|OB_PUTS
argument_list|(
literal|"<unknown type>"
argument_list|)
expr_stmt|;
return|return;
case|case
name|TREE_LIST
case|:
name|dump_type
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
operator|&
name|old_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|!=
name|void_list_node
condition|)
block|{
name|OB_PUTC
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|dump_type
argument_list|(
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
argument_list|,
operator|&
name|old_p
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|OB_PUTS
argument_list|(
literal|"..."
argument_list|)
expr_stmt|;
return|return;
case|case
name|POINTER_TYPE
case|:
if|if
condition|(
name|TYPE_READONLY
argument_list|(
name|t
argument_list|)
operator||
name|TYPE_VOLATILE
argument_list|(
name|t
argument_list|)
condition|)
name|dump_readonly_or_volatile
argument_list|(
name|t
argument_list|)
expr_stmt|;
operator|*
name|p
operator|+=
literal|1
expr_stmt|;
name|dump_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
name|OB_PUTC
argument_list|(
literal|'*'
argument_list|)
expr_stmt|;
operator|*
name|p
operator|-=
literal|1
expr_stmt|;
block|}
return|return;
case|case
name|REFERENCE_TYPE
case|:
if|if
condition|(
name|TYPE_READONLY
argument_list|(
name|t
argument_list|)
operator||
name|TYPE_VOLATILE
argument_list|(
name|t
argument_list|)
condition|)
name|dump_readonly_or_volatile
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|dump_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|'&'
argument_list|)
expr_stmt|;
return|return;
case|case
name|ARRAY_TYPE
case|:
if|if
condition|(
name|TYPE_READONLY
argument_list|(
name|t
argument_list|)
operator||
name|TYPE_VOLATILE
argument_list|(
name|t
argument_list|)
condition|)
name|dump_readonly_or_volatile
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|dump_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|OB_PUTC2
argument_list|(
literal|'['
argument_list|,
literal|']'
argument_list|)
expr_stmt|;
return|return;
case|case
name|OFFSET_TYPE
case|:
case|case
name|METHOD_TYPE
case|:
case|case
name|FUNCTION_TYPE
case|:
name|dump_type_prefix
argument_list|(
name|t
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|dump_type_suffix
argument_list|(
name|t
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return;
case|case
name|IDENTIFIER_NODE
case|:
name|OB_PUTID
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
break|break;
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
name|dump_aggr_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_DECL
case|:
if|if
condition|(
name|TYPE_READONLY
argument_list|(
name|t
argument_list|)
operator||
name|TYPE_VOLATILE
argument_list|(
name|t
argument_list|)
condition|)
name|dump_readonly_or_volatile
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|OB_PUTID
argument_list|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
break|break;
case|case
name|INTEGER_TYPE
case|:
comment|/* Normally, `unsigned' is part of the deal.  Not so if it comes 	 with `const' or `volatile'.  */
if|if
condition|(
name|TYPE_READONLY
argument_list|(
name|t
argument_list|)
operator||
name|TYPE_VOLATILE
argument_list|(
name|t
argument_list|)
condition|)
name|dump_readonly_or_volatile
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (TYPE_MAIN_VARIANT (t) == unsigned_type (TYPE_MAIN_VARIANT (t))&& (TYPE_READONLY (t) | TYPE_VOLATILE (t))) 	OB_PUTS ("unsigned ");
endif|#
directive|endif
name|OB_PUTID
argument_list|(
name|TYPE_IDENTIFIER
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
break|break;
case|case
name|REAL_TYPE
case|:
case|case
name|VOID_TYPE
case|:
if|if
condition|(
name|TYPE_READONLY
argument_list|(
name|t
argument_list|)
operator||
name|TYPE_VOLATILE
argument_list|(
name|t
argument_list|)
condition|)
name|dump_readonly_or_volatile
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|OB_PUTID
argument_list|(
name|TYPE_IDENTIFIER
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
break|break;
case|case
name|TEMPLATE_TYPE_PARM
case|:
name|OB_PUTS
argument_list|(
literal|"<template type parm "
argument_list|)
expr_stmt|;
name|OB_PUTID
argument_list|(
name|TYPE_IDENTIFIER
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|'>'
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNINSTANTIATED_P_TYPE
case|:
name|OB_PUTID
argument_list|(
name|DECL_NAME
argument_list|(
name|UPT_TEMPLATE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|OB_PUTS
argument_list|(
literal|"<...>"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|my_friendly_abort
argument_list|(
literal|68
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dump_decl
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|int
name|p
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL_TREE
condition|)
return|return;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|ERROR_MARK
case|:
name|OB_PUTS
argument_list|(
literal|" /* decl error */ "
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARM_DECL
case|:
name|dump_type_prefix
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
condition|)
name|dump_decl
argument_list|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|sprintf
argument_list|(
name|anon_buffer
argument_list|,
name|ANON_PARMNAME_FORMAT
argument_list|,
name|dummy_name
operator|++
argument_list|)
expr_stmt|;
name|OB_PUTCP
argument_list|(
name|anon_buffer
argument_list|)
expr_stmt|;
break|break;
block|}
name|dump_type_suffix
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
return|return;
case|case
name|CALL_EXPR
case|:
name|dump_decl
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
name|in_parmlist
operator|++
expr_stmt|;
name|dump_decl
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|in_parmlist
operator|--
expr_stmt|;
name|t
operator|=
name|tree_last
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
operator|||
name|t
operator|!=
name|void_list_node
condition|)
name|OB_PUTS
argument_list|(
literal|"..."
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
return|return;
case|case
name|ARRAY_REF
case|:
name|dump_decl
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
name|dump_decl
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
return|return;
case|case
name|TYPE_DECL
case|:
name|OB_PUTID
argument_list|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_EXPR
case|:
name|my_friendly_abort
argument_list|(
literal|69
argument_list|)
expr_stmt|;
break|break;
case|case
name|IDENTIFIER_NODE
case|:
if|if
condition|(
name|t
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|TYPE_EXPR
index|]
condition|)
block|{
name|OB_PUTS
argument_list|(
literal|"operator "
argument_list|)
expr_stmt|;
comment|/* Not exactly IDENTIFIER_TYPE_VALUE.  */
name|dump_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|IDENTIFIER_OPNAME_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|char
modifier|*
name|name_string
init|=
name|operator_name_string
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|OB_PUTS
argument_list|(
literal|"operator "
argument_list|)
expr_stmt|;
name|OB_PUTCP
argument_list|(
name|name_string
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OB_PUTID
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|BIT_NOT_EXPR
case|:
name|OB_PUTC2
argument_list|(
literal|'~'
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|dump_decl
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|SCOPE_REF
case|:
name|OB_PUTID
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OB_PUTC2
argument_list|(
literal|':'
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
name|dump_decl
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|INDIRECT_REF
case|:
name|OB_PUTC
argument_list|(
literal|'*'
argument_list|)
expr_stmt|;
name|dump_decl
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|ADDR_EXPR
case|:
name|OB_PUTC
argument_list|(
literal|'&'
argument_list|)
expr_stmt|;
name|dump_decl
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return;
default|default:
name|my_friendly_abort
argument_list|(
literal|70
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dump_init_list
parameter_list|(
name|l
parameter_list|)
name|tree
name|l
decl_stmt|;
block|{
while|while
condition|(
name|l
condition|)
block|{
name|dump_init
argument_list|(
name|TREE_VALUE
argument_list|(
name|l
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|l
argument_list|)
condition|)
name|OB_PUTC
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|l
operator|=
name|TREE_CHAIN
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dump_init
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|int
name|dummy
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|VAR_DECL
case|:
case|case
name|PARM_DECL
case|:
name|OB_PUTC
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|OB_PUTID
argument_list|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
break|break;
case|case
name|FUNCTION_DECL
case|:
block|{
name|tree
name|name
init|=
name|DECL_ASSEMBLER_NAME
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|DESTRUCTOR_NAME_P
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|OB_PUTC2
argument_list|(
literal|' '
argument_list|,
literal|'~'
argument_list|)
expr_stmt|;
name|OB_PUTID
argument_list|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IDENTIFIER_TYPENAME_P
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|dummy
operator|=
literal|0
expr_stmt|;
name|OB_PUTS
argument_list|(
literal|"operator "
argument_list|)
expr_stmt|;
name|dump_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|name
argument_list|)
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IDENTIFIER_OPNAME_P
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|char
modifier|*
name|name_string
init|=
name|operator_name_string
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|OB_PUTS
argument_list|(
literal|"operator "
argument_list|)
expr_stmt|;
name|OB_PUTCP
argument_list|(
name|name_string
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OB_PUTC
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|OB_PUTID
argument_list|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|OB_PUTC
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CONST_DECL
case|:
name|dummy
operator|=
literal|0
expr_stmt|;
name|OB_PUTC2
argument_list|(
literal|'('
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
name|dump_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
name|dump_init
argument_list|(
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
return|return;
case|case
name|INTEGER_CST
case|:
comment|/* If it's an enum, output its tag, rather than its value.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
block|{
name|char
modifier|*
name|p
init|=
name|enum_name_string
argument_list|(
name|t
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
decl_stmt|;
name|OB_PUTC
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|OB_PUTCP
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
else|else
name|sprintf
argument_list|(
name|digit_buffer
argument_list|,
literal|" %d "
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|OB_PUTCP
argument_list|(
name|digit_buffer
argument_list|)
expr_stmt|;
break|break;
case|case
name|REAL_CST
case|:
name|sprintf
argument_list|(
name|digit_buffer
argument_list|,
literal|" %g "
argument_list|,
name|TREE_REAL_CST
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|OB_PUTCP
argument_list|(
name|digit_buffer
argument_list|)
expr_stmt|;
break|break;
case|case
name|STRING_CST
case|:
block|{
name|char
modifier|*
name|p
init|=
name|TREE_STRING_POINTER
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|TREE_STRING_LENGTH
argument_list|(
name|t
argument_list|)
operator|-
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|;
name|OB_PUTC
argument_list|(
literal|'\"'
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|char
name|c
init|=
name|p
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\"'
operator|||
name|c
operator|==
literal|'\\'
condition|)
name|OB_PUTC
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|' '
operator|&&
name|c
operator|<
literal|0177
condition|)
name|OB_PUTC
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|else
block|{
name|sprintf
argument_list|(
name|digit_buffer
argument_list|,
literal|"\\%03o"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|OB_PUTCP
argument_list|(
name|digit_buffer
argument_list|)
expr_stmt|;
block|}
block|}
name|OB_PUTC
argument_list|(
literal|'\"'
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|COMPOUND_EXPR
case|:
name|dump_binary_op
argument_list|(
literal|","
argument_list|,
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|COND_EXPR
case|:
name|OB_PUTC
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
name|dump_init
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OB_PUTS
argument_list|(
literal|" ? "
argument_list|)
expr_stmt|;
name|dump_init
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OB_PUTS
argument_list|(
literal|" : "
argument_list|)
expr_stmt|;
name|dump_init
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
return|return;
case|case
name|SAVE_EXPR
case|:
if|if
condition|(
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|dummy
operator|=
literal|0
expr_stmt|;
name|OB_PUTS
argument_list|(
literal|"new "
argument_list|)
expr_stmt|;
name|dump_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
name|PARM_DECL_EXPR
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|sorry
argument_list|(
literal|"operand of SAVE_EXPR not understood"
argument_list|)
expr_stmt|;
name|scratch_obstack
operator|.
name|next_free
operator|=
name|obstack_base
argument_list|(
operator|&
name|scratch_obstack
argument_list|)
operator|+
name|scratch_error_offset
expr_stmt|;
block|}
return|return;
case|case
name|NEW_EXPR
case|:
name|OB_PUTID
argument_list|(
name|TYPE_IDENTIFIER
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
name|dump_init_list
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
return|return;
case|case
name|CALL_EXPR
case|:
name|OB_PUTC
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
name|dump_init
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|dump_init_list
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
return|return;
case|case
name|WITH_CLEANUP_EXPR
case|:
comment|/* Note that this only works for G++ cleanups.  If somebody 	 builds a general cleanup, there's no way to represent it.  */
name|dump_init
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|TARGET_EXPR
case|:
comment|/* Note that this only works for G++ target exprs.  If somebody 	 builds a general TARGET_EXPR, there's no way to represent that 	 it initializes anything other that the parameter slot for the 	 default argument.  Note we may have cleared out the first 	 operand in expand_expr, so don't go killing ourselves.  */
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
condition|)
name|dump_init
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|MODIFY_EXPR
case|:
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
case|case
name|MULT_EXPR
case|:
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|TRUNC_MOD_EXPR
case|:
case|case
name|MIN_EXPR
case|:
case|case
name|MAX_EXPR
case|:
case|case
name|LSHIFT_EXPR
case|:
case|case
name|RSHIFT_EXPR
case|:
case|case
name|BIT_IOR_EXPR
case|:
case|case
name|BIT_XOR_EXPR
case|:
case|case
name|BIT_AND_EXPR
case|:
case|case
name|BIT_ANDTC_EXPR
case|:
case|case
name|TRUTH_ANDIF_EXPR
case|:
case|case
name|TRUTH_ORIF_EXPR
case|:
case|case
name|LT_EXPR
case|:
case|case
name|LE_EXPR
case|:
case|case
name|GT_EXPR
case|:
case|case
name|GE_EXPR
case|:
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
name|dump_binary_op
argument_list|(
name|opname_tab
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|t
argument_list|)
index|]
argument_list|,
name|t
argument_list|,
name|strlen
argument_list|(
name|opname_tab
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|t
argument_list|)
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|CEIL_DIV_EXPR
case|:
case|case
name|FLOOR_DIV_EXPR
case|:
case|case
name|ROUND_DIV_EXPR
case|:
name|dump_binary_op
argument_list|(
literal|"/"
argument_list|,
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
case|case
name|CEIL_MOD_EXPR
case|:
case|case
name|FLOOR_MOD_EXPR
case|:
case|case
name|ROUND_MOD_EXPR
case|:
name|dump_binary_op
argument_list|(
literal|"%"
argument_list|,
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
case|case
name|COMPONENT_REF
case|:
name|dump_binary_op
argument_list|(
literal|"."
argument_list|,
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
case|case
name|CONVERT_EXPR
case|:
name|dump_unary_op
argument_list|(
literal|"+"
argument_list|,
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
case|case
name|ADDR_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|STRING_CST
condition|)
name|dump_init
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|dump_unary_op
argument_list|(
literal|"&"
argument_list|,
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
case|case
name|INDIRECT_REF
case|:
if|if
condition|(
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|CALL_EXPR
argument_list|,
literal|237
argument_list|)
expr_stmt|;
name|dump_init
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
name|dump_init_list
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
block|}
else|else
name|dump_unary_op
argument_list|(
literal|"*"
argument_list|,
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
case|case
name|NEGATE_EXPR
case|:
case|case
name|BIT_NOT_EXPR
case|:
case|case
name|TRUTH_NOT_EXPR
case|:
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|PREINCREMENT_EXPR
case|:
name|dump_unary_op
argument_list|(
name|opname_tab
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|t
argument_list|)
index|]
argument_list|,
name|t
argument_list|,
name|strlen
argument_list|(
name|opname_tab
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|t
argument_list|)
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|POSTDECREMENT_EXPR
case|:
case|case
name|POSTINCREMENT_EXPR
case|:
name|OB_PUTC
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
name|dump_init
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OB_PUTCP
argument_list|(
name|opname_tab
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|t
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
return|return;
case|case
name|NOP_EXPR
case|:
name|dummy
operator|=
literal|0
expr_stmt|;
name|OB_PUTC2
argument_list|(
literal|'('
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
name|dump_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
name|dump_init
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
return|return;
case|case
name|CONSTRUCTOR
case|:
name|OB_PUTC
argument_list|(
literal|'{'
argument_list|)
expr_stmt|;
name|dump_init_list
argument_list|(
name|CONSTRUCTOR_ELTS
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
return|return;
comment|/*  This list is incomplete, but should suffice for now. 	  It is very important that `sorry' does not call 	  `report_error_function'.  That could cause an infinite loop.  */
default|default:
name|sorry
argument_list|(
literal|"`%s' not supported for default parameters"
argument_list|,
name|tree_code_name
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|t
argument_list|)
index|]
argument_list|)
expr_stmt|;
comment|/* fall through to ERROR_MARK...  */
case|case
name|ERROR_MARK
case|:
name|scratch_obstack
operator|.
name|next_free
operator|=
name|obstack_base
argument_list|(
operator|&
name|scratch_obstack
argument_list|)
operator|+
name|scratch_error_offset
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dump_binary_op
parameter_list|(
name|opstring
parameter_list|,
name|t
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|opstring
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|OB_PUTC
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
name|dump_init
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|OB_PUTCP
argument_list|(
name|opstring
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|dump_init
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_unary_op
parameter_list|(
name|opstring
parameter_list|,
name|t
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|opstring
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|OB_PUTC
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|OB_PUTCP
argument_list|(
name|opstring
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|dump_init
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pretty printing for announce_function.  CNAME is the TYPE_DECL for    the class that FNDECL belongs to, if we could not figure that out    from FNDECL itself.  FNDECL is the declaration of the function we    are interested in seeing.  PRINT_RET_TYPE_P is non-zero if we    should print the type that this function returns.  */
end_comment

begin_function
name|char
modifier|*
name|fndecl_as_string
parameter_list|(
name|cname
parameter_list|,
name|fndecl
parameter_list|,
name|print_ret_type_p
parameter_list|)
name|tree
name|cname
decl_stmt|,
name|fndecl
decl_stmt|;
name|int
name|print_ret_type_p
decl_stmt|;
block|{
name|tree
name|name
init|=
name|DECL_ASSEMBLER_NAME
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|tree
name|fntype
init|=
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|tree
name|parmtypes
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
decl_stmt|;
name|int
name|p
init|=
literal|0
decl_stmt|;
name|int
name|spaces
init|=
literal|0
decl_stmt|;
name|OB_INIT
argument_list|()
expr_stmt|;
if|if
condition|(
name|DECL_CLASS_CONTEXT
argument_list|(
name|fndecl
argument_list|)
condition|)
name|cname
operator|=
name|TYPE_NAME
argument_list|(
name|DECL_CLASS_CONTEXT
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|fndecl
argument_list|)
condition|)
name|OB_PUTS
argument_list|(
literal|"static "
argument_list|)
expr_stmt|;
if|if
condition|(
name|print_ret_type_p
operator|&&
operator|!
name|IDENTIFIER_TYPENAME_P
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|dump_type_prefix
argument_list|(
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cname
condition|)
block|{
name|dump_type
argument_list|(
name|cname
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|(
name|char
operator|*
operator|)
name|obstack_next_free
argument_list|(
operator|&
name|scratch_obstack
argument_list|)
operator|-
literal|1
operator|)
operator|=
literal|':'
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
operator|==
name|METHOD_TYPE
operator|&&
name|parmtypes
condition|)
name|parmtypes
operator|=
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_CONSTRUCTOR_FOR_VBASE_P
argument_list|(
name|fndecl
argument_list|)
condition|)
comment|/* Skip past "in_charge" identifier.  */
name|parmtypes
operator|=
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DESTRUCTOR_NAME_P
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|OB_PUTC
argument_list|(
literal|'~'
argument_list|)
expr_stmt|;
name|parmtypes
operator|=
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
expr_stmt|;
name|dump_decl
argument_list|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IDENTIFIER_TYPENAME_P
argument_list|(
name|name
argument_list|)
condition|)
block|{
comment|/* This cannot use the hack that the operator's return 	 type is stashed off of its name because it may be 	 used for error reporting.  In the case of conflicting 	 declarations, both will have the same name, yet 	 the types will be different, hence the TREE_TYPE field 	 of the first name will be clobbered by the second.  */
name|OB_PUTS
argument_list|(
literal|"operator "
argument_list|)
expr_stmt|;
name|dump_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IDENTIFIER_OPNAME_P
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|char
modifier|*
name|name_string
init|=
name|operator_name_string
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|OB_PUTS
argument_list|(
literal|"operator "
argument_list|)
expr_stmt|;
name|OB_PUTCP
argument_list|(
name|name_string
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
else|else
name|dump_decl
argument_list|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
if|if
condition|(
name|parmtypes
condition|)
block|{
name|in_parmlist
operator|++
expr_stmt|;
if|if
condition|(
name|parmtypes
operator|!=
name|void_list_node
condition|)
name|spaces
operator|=
literal|2
expr_stmt|;
while|while
condition|(
name|parmtypes
operator|&&
name|parmtypes
operator|!=
name|void_list_node
condition|)
block|{
name|char
modifier|*
name|last_space
decl_stmt|;
name|dump_type
argument_list|(
name|TREE_VALUE
argument_list|(
name|parmtypes
argument_list|)
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
name|last_space
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_next_free
argument_list|(
operator|&
name|scratch_obstack
argument_list|)
expr_stmt|;
while|while
condition|(
name|last_space
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
name|last_space
operator|--
expr_stmt|;
name|scratch_obstack
operator|.
name|next_free
operator|=
name|last_space
expr_stmt|;
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|parmtypes
argument_list|)
condition|)
block|{
name|scratch_error_offset
operator|=
name|obstack_object_size
argument_list|(
operator|&
name|scratch_obstack
argument_list|)
expr_stmt|;
name|OB_PUTS
argument_list|(
literal|" (= "
argument_list|)
expr_stmt|;
name|dump_init
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|parmtypes
argument_list|)
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
block|}
name|OB_PUTC2
argument_list|(
literal|','
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|parmtypes
operator|=
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
expr_stmt|;
block|}
name|in_parmlist
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|parmtypes
condition|)
block|{
if|if
condition|(
name|spaces
condition|)
name|scratch_obstack
operator|.
name|next_free
operator|=
name|obstack_next_free
argument_list|(
operator|&
name|scratch_obstack
argument_list|)
operator|-
name|spaces
expr_stmt|;
block|}
else|else
name|OB_PUTS
argument_list|(
literal|"..."
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
if|if
condition|(
name|print_ret_type_p
operator|&&
operator|!
name|IDENTIFIER_TYPENAME_P
argument_list|(
name|name
argument_list|)
condition|)
name|dump_type_suffix
argument_list|(
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|dump_readonly_or_volatile
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|OB_FINISH
argument_list|()
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
name|obstack_base
argument_list|(
operator|&
name|scratch_obstack
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Same, but handtype a _TYPE.  */
end_comment

begin_function
name|char
modifier|*
name|type_as_string
parameter_list|(
name|typ
parameter_list|)
name|tree
name|typ
decl_stmt|;
block|{
name|int
name|p
init|=
literal|0
decl_stmt|;
name|OB_INIT
argument_list|()
expr_stmt|;
name|dump_type
argument_list|(
name|typ
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
name|OB_FINISH
argument_list|()
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
name|obstack_base
argument_list|(
operator|&
name|scratch_obstack
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* A cross between type_as_string and fndecl_as_string.  */
end_comment

begin_function
name|char
modifier|*
name|decl_as_string
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|OB_INIT
argument_list|()
expr_stmt|;
name|dump_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|OB_FINISH
argument_list|()
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
name|obstack_base
argument_list|(
operator|&
name|scratch_obstack
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Move inline function definitions out of structure so that they    can be processed normally.  CNAME is the name of the class    we are working from, METHOD_LIST is the list of method lists    of the structure.  We delete friend methods here, after    saving away their inline function definitions (if any).  */
end_comment

begin_function
name|void
name|do_inline_function_hair
parameter_list|(
name|type
parameter_list|,
name|friend_list
parameter_list|)
name|tree
name|type
decl_stmt|,
name|friend_list
decl_stmt|;
block|{
name|tree
name|method
init|=
name|TYPE_METHODS
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|method
operator|&&
name|TREE_CODE
argument_list|(
name|method
argument_list|)
operator|==
name|TREE_VEC
condition|)
block|{
if|if
condition|(
name|TREE_VEC_ELT
argument_list|(
name|method
argument_list|,
literal|0
argument_list|)
condition|)
name|method
operator|=
name|TREE_VEC_ELT
argument_list|(
name|method
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|method
operator|=
name|TREE_VEC_ELT
argument_list|(
name|method
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|method
condition|)
block|{
comment|/* Do inline member functions.  */
name|struct
name|pending_inline
modifier|*
name|info
init|=
name|DECL_PENDING_INLINE_INFO
argument_list|(
name|method
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
condition|)
block|{
name|tree
name|args
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|info
operator|->
name|fndecl
operator|==
name|method
argument_list|,
literal|238
argument_list|)
expr_stmt|;
name|args
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|method
argument_list|)
expr_stmt|;
while|while
condition|(
name|args
condition|)
block|{
name|DECL_CONTEXT
argument_list|(
name|args
argument_list|)
operator|=
name|method
expr_stmt|;
name|args
operator|=
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
comment|/* Allow this decl to be seen in global scope */
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|method
argument_list|)
argument_list|)
operator|=
name|method
expr_stmt|;
block|}
name|method
operator|=
name|TREE_CHAIN
argument_list|(
name|method
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|friend_list
condition|)
block|{
name|tree
name|fndecl
init|=
name|TREE_VALUE
argument_list|(
name|friend_list
argument_list|)
decl_stmt|;
name|struct
name|pending_inline
modifier|*
name|info
init|=
name|DECL_PENDING_INLINE_INFO
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
condition|)
block|{
name|tree
name|args
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|info
operator|->
name|fndecl
operator|==
name|fndecl
argument_list|,
literal|239
argument_list|)
expr_stmt|;
name|args
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
while|while
condition|(
name|args
condition|)
block|{
name|DECL_CONTEXT
argument_list|(
name|args
argument_list|)
operator|=
name|fndecl
expr_stmt|;
name|args
operator|=
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
comment|/* Allow this decl to be seen in global scope */
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|=
name|fndecl
expr_stmt|;
block|}
name|friend_list
operator|=
name|TREE_CHAIN
argument_list|(
name|friend_list
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Report an argument type mismatch between the best declared function    we could find and the current argument list that we have.  */
end_comment

begin_function
name|void
name|report_type_mismatch
parameter_list|(
name|cp
parameter_list|,
name|parmtypes
parameter_list|,
name|name_kind
parameter_list|,
name|err_name
parameter_list|)
name|struct
name|candidate
modifier|*
name|cp
decl_stmt|;
name|tree
name|parmtypes
decl_stmt|;
name|char
modifier|*
name|name_kind
decl_stmt|,
decl|*
name|err_name
decl_stmt|;
end_function

begin_block
block|{
name|int
name|i
init|=
name|cp
operator|->
name|u
operator|.
name|bad_arg
decl_stmt|;
name|tree
name|ttf
decl_stmt|,
name|tta
decl_stmt|;
name|char
modifier|*
name|tmp_firstobj
decl_stmt|;
switch|switch
condition|(
name|i
condition|)
block|{
case|case
operator|-
literal|4
case|:
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|cp
operator|->
name|function
argument_list|)
operator|==
name|TEMPLATE_DECL
argument_list|,
literal|240
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"type unification failed for function template `%s'"
argument_list|,
name|err_name
argument_list|)
expr_stmt|;
return|return;
case|case
operator|-
literal|3
case|:
if|if
condition|(
name|TYPE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|parmtypes
argument_list|)
argument_list|)
argument_list|)
condition|)
name|error
argument_list|(
literal|"call to const %s `%s' with non-const object"
argument_list|,
name|name_kind
argument_list|,
name|err_name
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"call to non-const %s `%s' with const object"
argument_list|,
name|name_kind
argument_list|,
name|err_name
argument_list|)
expr_stmt|;
return|return;
case|case
operator|-
literal|2
case|:
name|error
argument_list|(
literal|"too few arguments for %s `%s'"
argument_list|,
name|name_kind
argument_list|,
name|err_name
argument_list|)
expr_stmt|;
return|return;
case|case
operator|-
literal|1
case|:
name|error
argument_list|(
literal|"too many arguments for %s `%s'"
argument_list|,
name|name_kind
argument_list|,
name|err_name
argument_list|)
expr_stmt|;
return|return;
case|case
literal|0
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|cp
operator|->
name|function
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
comment|/* Happens when we have an ambiguous base class.  */
name|my_friendly_assert
argument_list|(
name|get_binfo
argument_list|(
name|DECL_CLASS_CONTEXT
argument_list|(
name|cp
operator|->
name|function
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|parmtypes
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|error_mark_node
argument_list|,
literal|241
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|ttf
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|cp
operator|->
name|function
argument_list|)
argument_list|)
expr_stmt|;
name|tta
operator|=
name|parmtypes
expr_stmt|;
while|while
condition|(
name|i
operator|--
operator|>
literal|0
condition|)
block|{
name|ttf
operator|=
name|TREE_CHAIN
argument_list|(
name|ttf
argument_list|)
expr_stmt|;
name|tta
operator|=
name|TREE_CHAIN
argument_list|(
name|tta
argument_list|)
expr_stmt|;
block|}
name|OB_INIT
argument_list|()
expr_stmt|;
name|OB_PUTS
argument_list|(
literal|"bad argument "
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|digit_buffer
argument_list|,
literal|"%d"
argument_list|,
name|cp
operator|->
name|u
operator|.
name|bad_arg
operator|-
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|cp
operator|->
name|function
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|OB_PUTCP
argument_list|(
name|digit_buffer
argument_list|)
expr_stmt|;
name|OB_PUTS
argument_list|(
literal|" for function `"
argument_list|)
expr_stmt|;
name|tmp_firstobj
operator|=
name|scratch_firstobj
expr_stmt|;
name|scratch_firstobj
operator|=
literal|0
expr_stmt|;
name|fndecl_as_string
argument_list|(
literal|0
argument_list|,
name|cp
operator|->
name|function
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|scratch_firstobj
operator|=
name|tmp_firstobj
expr_stmt|;
comment|/* We know that the last char written is next_free-1.  */
operator|(
operator|(
name|char
operator|*
operator|)
name|obstack_next_free
argument_list|(
operator|&
name|scratch_obstack
argument_list|)
operator|)
index|[
operator|-
literal|1
index|]
operator|=
literal|'\''
expr_stmt|;
name|OB_PUTS
argument_list|(
literal|" (type was "
argument_list|)
expr_stmt|;
comment|/* Reset `i' so that type printing routines do the right thing.  */
if|if
condition|(
name|tta
condition|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tta
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|ERROR_MARK
condition|)
name|OB_PUTS
argument_list|(
literal|"(failed type instantiation)"
argument_list|)
expr_stmt|;
else|else
block|{
name|i
operator|=
operator|(
name|code
operator|==
name|FUNCTION_TYPE
operator|||
name|code
operator|==
name|METHOD_TYPE
operator|)
expr_stmt|;
name|dump_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tta
argument_list|)
argument_list|)
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|OB_PUTS
argument_list|(
literal|"void"
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
name|OB_FINISH
argument_list|()
expr_stmt|;
name|tmp_firstobj
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|obstack_object_size
argument_list|(
operator|&
name|scratch_obstack
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|obstack_base
argument_list|(
operator|&
name|scratch_obstack
argument_list|)
argument_list|,
name|tmp_firstobj
argument_list|,
name|obstack_object_size
argument_list|(
operator|&
name|scratch_obstack
argument_list|)
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|tmp_firstobj
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Here is where overload code starts.  */
end_comment

begin_comment
comment|/* Array of types seen so far in top-level call to `build_overload_name'.    Allocated and deallocated by caller.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
modifier|*
name|typevec
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of types interned by `build_overload_name' so far.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|maxtype
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of occurrences of last type seen.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nrepeats
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we should not try folding parameter types.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nofold
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ALLOCATE_TYPEVEC
parameter_list|(
name|PARMTYPES
parameter_list|)
define|\
value|do { maxtype = 0, nrepeats = 0; \        typevec = (tree *)alloca (list_length (PARMTYPES) * sizeof (tree)); } while (0)
end_define

begin_define
define|#
directive|define
name|DEALLOCATE_TYPEVEC
parameter_list|(
name|PARMTYPES
parameter_list|)
define|\
value|do { tree t = (PARMTYPES); \        while (t) { TREE_USED (TREE_VALUE (t)) = 0; t = TREE_CHAIN (t); } \   } while (0)
end_define

begin_comment
comment|/* Code to concatenate an asciified integer to a string.  */
end_comment

begin_function
specifier|static
ifdef|#
directive|ifdef
name|__GNUC__
name|__inline
endif|#
directive|endif
name|void
name|icat
parameter_list|(
name|i
parameter_list|)
name|int
name|i
decl_stmt|;
block|{
comment|/* Handle this case first, to go really quickly.  For many common values,      the result of i/10 below is 1.  */
if|if
condition|(
name|i
operator|==
literal|1
condition|)
block|{
name|OB_PUTC
argument_list|(
literal|'1'
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|OB_PUTC
argument_list|(
literal|'m'
argument_list|)
expr_stmt|;
name|i
operator|=
operator|-
name|i
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
literal|10
condition|)
name|OB_PUTC
argument_list|(
literal|'0'
operator|+
name|i
argument_list|)
expr_stmt|;
else|else
block|{
name|icat
argument_list|(
name|i
operator|/
literal|10
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|'0'
operator|+
operator|(
name|i
operator|%
literal|10
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
ifdef|#
directive|ifdef
name|__GNUC__
name|__inline
endif|#
directive|endif
name|void
name|flush_repeats
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|int
name|tindex
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|typevec
index|[
name|tindex
index|]
operator|!=
name|type
condition|)
name|tindex
operator|++
expr_stmt|;
if|if
condition|(
name|nrepeats
operator|>
literal|1
condition|)
block|{
name|OB_PUTC
argument_list|(
literal|'N'
argument_list|)
expr_stmt|;
name|icat
argument_list|(
name|nrepeats
argument_list|)
expr_stmt|;
if|if
condition|(
name|nrepeats
operator|>
literal|9
condition|)
name|OB_PUTC
argument_list|(
literal|'_'
argument_list|)
expr_stmt|;
block|}
else|else
name|OB_PUTC
argument_list|(
literal|'T'
argument_list|)
expr_stmt|;
name|nrepeats
operator|=
literal|0
expr_stmt|;
name|icat
argument_list|(
name|tindex
argument_list|)
expr_stmt|;
if|if
condition|(
name|tindex
operator|>
literal|9
condition|)
name|OB_PUTC
argument_list|(
literal|'_'
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|build_overload_identifier
parameter_list|()
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|build_overload_nested_name
parameter_list|(
name|context
parameter_list|)
name|tree
name|context
decl_stmt|;
block|{
comment|/* We use DECL_NAME here, because pushtag now sets the DECL_ASSEMBLER_NAME.  */
name|tree
name|name
init|=
name|DECL_NAME
argument_list|(
name|context
argument_list|)
decl_stmt|;
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|context
argument_list|)
condition|)
block|{
name|context
operator|=
name|DECL_CONTEXT
argument_list|(
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|context
argument_list|)
argument_list|)
operator|==
literal|'t'
condition|)
name|context
operator|=
name|TYPE_NAME
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|build_overload_nested_name
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
name|build_overload_identifier
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|build_overload_value
parameter_list|(
name|type
parameter_list|,
name|value
parameter_list|)
name|tree
name|type
decl_stmt|,
name|value
decl_stmt|;
block|{
while|while
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|NON_LVALUE_EXPR
condition|)
name|value
operator|=
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|PARM_DECL
argument_list|,
literal|242
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|INTEGER_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
block|{
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|INTEGER_CST
argument_list|,
literal|243
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|value
argument_list|)
operator|==
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|value
argument_list|,
name|integer_zero_node
argument_list|)
condition|)
block|{
name|OB_PUTC
argument_list|(
literal|'m'
argument_list|)
expr_stmt|;
name|value
operator|=
name|build_int_2
argument_list|(
operator|~
name|TREE_INT_CST_LOW
argument_list|(
name|value
argument_list|)
argument_list|,
operator|-
name|TREE_INT_CST_HIGH
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_INT_CST_HIGH
argument_list|(
name|value
argument_list|)
operator|!=
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|value
argument_list|)
operator|>>
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
comment|/* need to print a DImode value in decimal */
name|sorry
argument_list|(
literal|"conversion of long long as PT parameter"
argument_list|)
expr_stmt|;
block|}
comment|/* else fall through to print in smaller mode */
block|}
comment|/* Wordsize or smaller */
name|icat
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
ifndef|#
directive|ifndef
name|REAL_IS_NOT_DOUBLE
case|case
name|REAL_TYPE
case|:
block|{
name|REAL_VALUE_TYPE
name|val
decl_stmt|;
name|char
modifier|*
name|bufp
init|=
name|digit_buffer
decl_stmt|;
specifier|extern
name|char
modifier|*
name|index
parameter_list|()
function_decl|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|REAL_CST
argument_list|,
literal|244
argument_list|)
expr_stmt|;
name|val
operator|=
name|TREE_REAL_CST
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
block|{
name|val
operator|=
operator|-
name|val
expr_stmt|;
operator|*
name|bufp
operator|++
operator|=
literal|'m'
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|bufp
argument_list|,
literal|"%e"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|bufp
operator|=
operator|(
name|char
operator|*
operator|)
name|index
argument_list|(
name|bufp
argument_list|,
literal|'e'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bufp
condition|)
name|strcat
argument_list|(
name|digit_buffer
argument_list|,
literal|"e0"
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|bufp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|bufp
operator|==
literal|'-'
condition|)
block|{
operator|*
name|bufp
operator|++
operator|=
literal|'m'
expr_stmt|;
block|}
name|p
operator|=
name|bufp
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'+'
condition|)
name|p
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|'0'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
block|{
operator|*
name|bufp
operator|++
operator|=
literal|'0'
expr_stmt|;
operator|*
name|bufp
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|!=
name|bufp
condition|)
block|{
while|while
condition|(
operator|*
name|p
condition|)
operator|*
name|bufp
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|bufp
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|OB_PUTCP
argument_list|(
name|digit_buffer
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
case|case
name|POINTER_TYPE
case|:
name|value
operator|=
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|DECL_NAME
argument_list|(
name|value
argument_list|)
operator|!=
literal|0
argument_list|,
literal|245
argument_list|)
expr_stmt|;
name|build_overload_identifier
argument_list|(
name|DECL_NAME
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|DECL_NAME
argument_list|(
name|value
argument_list|)
operator|!=
literal|0
argument_list|,
literal|246
argument_list|)
expr_stmt|;
name|build_overload_identifier
argument_list|(
name|DECL_NAME
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|my_friendly_abort
argument_list|(
literal|71
argument_list|)
expr_stmt|;
break|break;
comment|/* not really needed */
default|default:
name|sorry
argument_list|(
literal|"conversion of %s as PT parameter"
argument_list|,
name|tree_code_name
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|type
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|my_friendly_abort
argument_list|(
literal|72
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|build_overload_identifier
parameter_list|(
name|name
parameter_list|)
name|tree
name|name
decl_stmt|;
block|{
if|if
condition|(
name|IDENTIFIER_TEMPLATE
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|tree
name|template
decl_stmt|,
name|parmlist
decl_stmt|,
name|arglist
decl_stmt|,
name|tname
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nparms
decl_stmt|;
name|template
operator|=
name|IDENTIFIER_TEMPLATE
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|TREE_VALUE
argument_list|(
name|template
argument_list|)
expr_stmt|;
name|template
operator|=
name|TREE_PURPOSE
argument_list|(
name|template
argument_list|)
expr_stmt|;
name|tname
operator|=
name|DECL_NAME
argument_list|(
name|template
argument_list|)
expr_stmt|;
name|parmlist
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|template
argument_list|)
expr_stmt|;
name|nparms
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|parmlist
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|'t'
argument_list|)
expr_stmt|;
name|icat
argument_list|(
name|IDENTIFIER_LENGTH
argument_list|(
name|tname
argument_list|)
argument_list|)
expr_stmt|;
name|OB_PUTID
argument_list|(
name|tname
argument_list|)
expr_stmt|;
name|icat
argument_list|(
name|nparms
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nparms
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|parm
init|=
name|TREE_VEC_ELT
argument_list|(
name|parmlist
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|arg
init|=
name|TREE_VEC_ELT
argument_list|(
name|arglist
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
comment|/* This parameter is a type.  */
name|OB_PUTC
argument_list|(
literal|'Z'
argument_list|)
expr_stmt|;
name|build_overload_name
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* It's a PARM_DECL.  */
name|build_overload_name
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|build_overload_value
argument_list|(
name|parm
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|icat
argument_list|(
name|IDENTIFIER_LENGTH
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|OB_PUTID
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Given a list of parameters in PARMTYPES, create an unambiguous    overload string. Should distinguish any type that C (or C++) can    distinguish. I.e., pointers to functions are treated correctly.     Caller must deal with whether a final `e' goes on the end or not.     Any default conversions must take place before this function    is called.     BEGIN and END control initialization and finalization of the    obstack where we build the string.  */
end_comment

begin_function
name|char
modifier|*
name|build_overload_name
parameter_list|(
name|parmtypes
parameter_list|,
name|begin
parameter_list|,
name|end
parameter_list|)
name|tree
name|parmtypes
decl_stmt|;
name|int
name|begin
decl_stmt|,
name|end
decl_stmt|;
block|{
name|int
name|just_one
decl_stmt|;
name|tree
name|parmtype
decl_stmt|;
if|if
condition|(
name|begin
condition|)
name|OB_INIT
argument_list|()
expr_stmt|;
if|if
condition|(
name|just_one
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|parmtypes
argument_list|)
operator|!=
name|TREE_LIST
operator|)
condition|)
block|{
name|parmtype
operator|=
name|parmtypes
expr_stmt|;
goto|goto
name|only_one
goto|;
block|}
while|while
condition|(
name|parmtypes
condition|)
block|{
name|parmtype
operator|=
name|TREE_VALUE
argument_list|(
name|parmtypes
argument_list|)
expr_stmt|;
name|only_one
label|:
if|if
condition|(
operator|!
name|nofold
condition|)
block|{
if|if
condition|(
operator|!
name|just_one
condition|)
comment|/* Every argument gets counted.  */
name|typevec
index|[
name|maxtype
operator|++
index|]
operator|=
name|parmtype
expr_stmt|;
if|if
condition|(
name|TREE_USED
argument_list|(
name|parmtype
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|just_one
operator|&&
name|parmtype
operator|==
name|typevec
index|[
name|maxtype
operator|-
literal|2
index|]
condition|)
name|nrepeats
operator|++
expr_stmt|;
else|else
block|{
if|if
condition|(
name|nrepeats
condition|)
name|flush_repeats
argument_list|(
name|parmtype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|just_one
operator|&&
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
operator|&&
name|parmtype
operator|==
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
argument_list|)
condition|)
name|nrepeats
operator|++
expr_stmt|;
else|else
block|{
name|int
name|tindex
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|typevec
index|[
name|tindex
index|]
operator|!=
name|parmtype
condition|)
name|tindex
operator|++
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|'T'
argument_list|)
expr_stmt|;
name|icat
argument_list|(
name|tindex
argument_list|)
expr_stmt|;
if|if
condition|(
name|tindex
operator|>
literal|9
condition|)
name|OB_PUTC
argument_list|(
literal|'_'
argument_list|)
expr_stmt|;
block|}
block|}
goto|goto
name|next
goto|;
block|}
if|if
condition|(
name|nrepeats
condition|)
name|flush_repeats
argument_list|(
name|typevec
index|[
name|maxtype
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|just_one
comment|/* Only cache types which take more than one character.  */
operator|&&
operator|(
name|parmtype
operator|!=
name|TYPE_MAIN_VARIANT
argument_list|(
name|parmtype
argument_list|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|parmtype
argument_list|)
operator|!=
name|INTEGER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|parmtype
argument_list|)
operator|!=
name|REAL_TYPE
operator|)
operator|)
condition|)
name|TREE_USED
argument_list|(
name|parmtype
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|parmtype
argument_list|)
condition|)
name|OB_PUTC
argument_list|(
literal|'C'
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parmtype
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|parmtype
argument_list|)
operator|==
name|unsigned_type
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|parmtype
argument_list|)
argument_list|)
condition|)
name|OB_PUTC
argument_list|(
literal|'U'
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_VOLATILE
argument_list|(
name|parmtype
argument_list|)
condition|)
name|OB_PUTC
argument_list|(
literal|'V'
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|parmtype
argument_list|)
condition|)
block|{
case|case
name|OFFSET_TYPE
case|:
name|OB_PUTC
argument_list|(
literal|'O'
argument_list|)
expr_stmt|;
name|build_overload_name
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|parmtype
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|'_'
argument_list|)
expr_stmt|;
name|build_overload_name
argument_list|(
name|TREE_TYPE
argument_list|(
name|parmtype
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|REFERENCE_TYPE
case|:
name|OB_PUTC
argument_list|(
literal|'R'
argument_list|)
expr_stmt|;
goto|goto
name|more
goto|;
case|case
name|ARRAY_TYPE
case|:
if|#
directive|if
name|PARM_CAN_BE_ARRAY_TYPE
block|{
name|tree
name|length
decl_stmt|;
name|OB_PUTC
argument_list|(
literal|'A'
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_DOMAIN
argument_list|(
name|parmtype
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"parameter type with unspecified array bounds invalid"
argument_list|)
expr_stmt|;
name|icat
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|length
operator|=
name|array_type_nelts
argument_list|(
name|parmtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|length
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|icat
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|length
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|OB_PUTC
argument_list|(
literal|'_'
argument_list|)
expr_stmt|;
goto|goto
name|more
goto|;
block|}
else|#
directive|else
name|OB_PUTC
argument_list|(
literal|'P'
argument_list|)
expr_stmt|;
goto|goto
name|more
goto|;
endif|#
directive|endif
case|case
name|POINTER_TYPE
case|:
name|OB_PUTC
argument_list|(
literal|'P'
argument_list|)
expr_stmt|;
name|more
label|:
name|build_overload_name
argument_list|(
name|TREE_TYPE
argument_list|(
name|parmtype
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|FUNCTION_TYPE
case|:
case|case
name|METHOD_TYPE
case|:
block|{
name|tree
name|firstarg
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|parmtype
argument_list|)
decl_stmt|;
comment|/* Otherwise have to implement reentrant typevecs, 	       unmark and remark types, etc.  */
name|int
name|old_nofold
init|=
name|nofold
decl_stmt|;
name|nofold
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|nrepeats
condition|)
name|flush_repeats
argument_list|(
name|typevec
index|[
name|maxtype
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* @@ It may be possible to pass a function type in 	       which is not preceded by a 'P'.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parmtype
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|OB_PUTC
argument_list|(
literal|'F'
argument_list|)
expr_stmt|;
if|if
condition|(
name|firstarg
operator|==
name|NULL_TREE
condition|)
name|OB_PUTC
argument_list|(
literal|'e'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|firstarg
operator|==
name|void_list_node
condition|)
name|OB_PUTC
argument_list|(
literal|'v'
argument_list|)
expr_stmt|;
else|else
name|build_overload_name
argument_list|(
name|firstarg
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|constp
init|=
name|TYPE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|firstarg
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|volatilep
init|=
name|TYPE_VOLATILE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|firstarg
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|OB_PUTC
argument_list|(
literal|'M'
argument_list|)
expr_stmt|;
name|firstarg
operator|=
name|TREE_CHAIN
argument_list|(
name|firstarg
argument_list|)
expr_stmt|;
name|build_overload_name
argument_list|(
name|TYPE_METHOD_BASETYPE
argument_list|(
name|parmtype
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|constp
condition|)
name|OB_PUTC
argument_list|(
literal|'C'
argument_list|)
expr_stmt|;
if|if
condition|(
name|volatilep
condition|)
name|OB_PUTC
argument_list|(
literal|'V'
argument_list|)
expr_stmt|;
comment|/* For cfront 2.0 compatibility.  */
name|OB_PUTC
argument_list|(
literal|'F'
argument_list|)
expr_stmt|;
if|if
condition|(
name|firstarg
operator|==
name|NULL_TREE
condition|)
name|OB_PUTC
argument_list|(
literal|'e'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|firstarg
operator|==
name|void_list_node
condition|)
name|OB_PUTC
argument_list|(
literal|'v'
argument_list|)
expr_stmt|;
else|else
name|build_overload_name
argument_list|(
name|firstarg
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Separate args from return type.  */
name|OB_PUTC
argument_list|(
literal|'_'
argument_list|)
expr_stmt|;
name|build_overload_name
argument_list|(
name|TREE_TYPE
argument_list|(
name|parmtype
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nofold
operator|=
name|old_nofold
expr_stmt|;
break|break;
block|}
case|case
name|INTEGER_TYPE
case|:
name|parmtype
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|parmtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|parmtype
operator|==
name|integer_type_node
operator|||
name|parmtype
operator|==
name|unsigned_type_node
condition|)
name|OB_PUTC
argument_list|(
literal|'i'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|parmtype
operator|==
name|long_integer_type_node
operator|||
name|parmtype
operator|==
name|long_unsigned_type_node
condition|)
name|OB_PUTC
argument_list|(
literal|'l'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|parmtype
operator|==
name|short_integer_type_node
operator|||
name|parmtype
operator|==
name|short_unsigned_type_node
condition|)
name|OB_PUTC
argument_list|(
literal|'s'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|parmtype
operator|==
name|signed_char_type_node
condition|)
block|{
name|OB_PUTC
argument_list|(
literal|'S'
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|'c'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parmtype
operator|==
name|char_type_node
operator|||
name|parmtype
operator|==
name|unsigned_char_type_node
condition|)
name|OB_PUTC
argument_list|(
literal|'c'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|parmtype
operator|==
name|wchar_type_node
condition|)
name|OB_PUTC
argument_list|(
literal|'w'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|parmtype
operator|==
name|long_long_integer_type_node
operator|||
name|parmtype
operator|==
name|long_long_unsigned_type_node
condition|)
name|OB_PUTC
argument_list|(
literal|'x'
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* it would seem there is no way to enter these in source code, 	     yet.  (mrs) */
if|else if (parmtype == long_long_long_integer_type_node 	      || parmtype == long_long_long_unsigned_type_node) 	    OB_PUTC ('q');
endif|#
directive|endif
else|else
name|my_friendly_abort
argument_list|(
literal|73
argument_list|)
expr_stmt|;
break|break;
case|case
name|REAL_TYPE
case|:
name|parmtype
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|parmtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|parmtype
operator|==
name|long_double_type_node
condition|)
name|OB_PUTC
argument_list|(
literal|'r'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|parmtype
operator|==
name|double_type_node
condition|)
name|OB_PUTC
argument_list|(
literal|'d'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|parmtype
operator|==
name|float_type_node
condition|)
name|OB_PUTC
argument_list|(
literal|'f'
argument_list|)
expr_stmt|;
else|else
name|my_friendly_abort
argument_list|(
literal|74
argument_list|)
expr_stmt|;
break|break;
case|case
name|VOID_TYPE
case|:
if|if
condition|(
operator|!
name|just_one
condition|)
block|{
if|#
directive|if
literal|0
block|extern tree void_list_node;
comment|/* See if anybody is wasting memory.  */
block|my_friendly_assert (parmtypes == void_list_node, 247);
endif|#
directive|endif
comment|/* This is the end of a parameter list.  */
if|if
condition|(
name|end
condition|)
name|OB_FINISH
argument_list|()
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
name|obstack_base
argument_list|(
operator|&
name|scratch_obstack
argument_list|)
return|;
block|}
name|OB_PUTC
argument_list|(
literal|'v'
argument_list|)
expr_stmt|;
break|break;
case|case
name|ERROR_MARK
case|:
comment|/* not right, but nothing is anyway */
break|break;
comment|/* have to do these */
case|case
name|UNION_TYPE
case|:
case|case
name|RECORD_TYPE
case|:
if|if
condition|(
operator|!
name|just_one
condition|)
comment|/* Make this type signature look incompatible 	       with AT&T.  */
name|OB_PUTC
argument_list|(
literal|'G'
argument_list|)
expr_stmt|;
goto|goto
name|common
goto|;
case|case
name|ENUMERAL_TYPE
case|:
name|common
label|:
block|{
name|tree
name|name
init|=
name|TYPE_NAME
argument_list|(
name|parmtype
argument_list|)
decl_stmt|;
name|int
name|i
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|tree
name|context
init|=
name|name
decl_stmt|;
while|while
condition|(
name|DECL_CONTEXT
argument_list|(
name|context
argument_list|)
condition|)
block|{
name|i
operator|+=
literal|1
expr_stmt|;
name|context
operator|=
name|DECL_CONTEXT
argument_list|(
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|context
argument_list|)
argument_list|)
operator|==
literal|'t'
condition|)
name|context
operator|=
name|TYPE_NAME
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
name|name
operator|=
name|DECL_NAME
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|IDENTIFIER_NODE
argument_list|,
literal|248
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|1
condition|)
block|{
name|OB_PUTC
argument_list|(
literal|'Q'
argument_list|)
expr_stmt|;
name|icat
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|build_overload_nested_name
argument_list|(
name|TYPE_NAME
argument_list|(
name|parmtype
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|build_overload_identifier
argument_list|(
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|UNKNOWN_TYPE
case|:
comment|/* This will take some work.  */
name|OB_PUTC
argument_list|(
literal|'?'
argument_list|)
expr_stmt|;
break|break;
case|case
name|TEMPLATE_TYPE_PARM
case|:
case|case
name|TEMPLATE_CONST_PARM
case|:
case|case
name|UNINSTANTIATED_P_TYPE
case|:
comment|/* We don't ever want this output, but it's inconvenient not to 	     be able to build the string.  This should cause assembler 	     errors we'll notice.  */
block|{
specifier|static
name|int
name|n
decl_stmt|;
name|sprintf
argument_list|(
name|digit_buffer
argument_list|,
literal|" *%d"
argument_list|,
name|n
operator|++
argument_list|)
expr_stmt|;
name|OB_PUTCP
argument_list|(
name|digit_buffer
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|my_friendly_abort
argument_list|(
literal|75
argument_list|)
expr_stmt|;
block|}
name|next
label|:
if|if
condition|(
name|just_one
condition|)
break|break;
name|parmtypes
operator|=
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|just_one
condition|)
block|{
if|if
condition|(
name|nrepeats
condition|)
name|flush_repeats
argument_list|(
name|typevec
index|[
name|maxtype
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* To get here, parms must end with `...'. */
name|OB_PUTC
argument_list|(
literal|'e'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|end
condition|)
name|OB_FINISH
argument_list|()
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
name|obstack_base
argument_list|(
operator|&
name|scratch_obstack
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate an identifier that encodes the (ANSI) exception TYPE. */
end_comment

begin_comment
comment|/* This should be part of `ansi_opname', or at least be defined by the std.  */
end_comment

begin_define
define|#
directive|define
name|EXCEPTION_NAME_PREFIX
value|"__ex"
end_define

begin_define
define|#
directive|define
name|EXCEPTION_NAME_LENGTH
value|4
end_define

begin_function
name|tree
name|cplus_exception_name
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|OB_INIT
argument_list|()
expr_stmt|;
name|OB_PUTS
argument_list|(
name|EXCEPTION_NAME_PREFIX
argument_list|)
expr_stmt|;
return|return
name|get_identifier
argument_list|(
name|build_overload_name
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Change the name of a function definition so that it may be    overloaded. NAME is the name of the function to overload,    PARMS is the parameter list (which determines what name the    final function obtains).     FOR_METHOD is 1 if this overload is being performed    for a method, rather than a function type.  It is 2 if    this overload is being performed for a constructor.  */
end_comment

begin_function
name|tree
name|build_decl_overload
parameter_list|(
name|dname
parameter_list|,
name|parms
parameter_list|,
name|for_method
parameter_list|)
name|tree
name|dname
decl_stmt|;
name|tree
name|parms
decl_stmt|;
name|int
name|for_method
decl_stmt|;
block|{
name|char
modifier|*
name|name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|dname
argument_list|)
decl_stmt|;
if|if
condition|(
name|dname
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|NEW_EXPR
index|]
operator|&&
name|parms
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|parms
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
operator|==
name|sizetype
operator|&&
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
operator|==
name|void_list_node
condition|)
return|return
name|get_identifier
argument_list|(
literal|"__builtin_new"
argument_list|)
return|;
elseif|else
if|if
condition|(
name|dname
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|DELETE_EXPR
index|]
operator|&&
name|parms
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|parms
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
operator|==
name|ptr_type_node
operator|&&
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
operator|==
name|void_list_node
condition|)
return|return
name|get_identifier
argument_list|(
literal|"__builtin_delete"
argument_list|)
return|;
elseif|else
if|if
condition|(
name|dname
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|DELETE_EXPR
index|]
operator|&&
name|parms
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|parms
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
operator|==
name|ptr_type_node
operator|&&
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|==
name|sizetype
operator|&&
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|==
name|void_list_node
condition|)
return|return
name|get_identifier
argument_list|(
literal|"__builtin_delete"
argument_list|)
return|;
name|OB_INIT
argument_list|()
expr_stmt|;
if|if
condition|(
name|for_method
operator|!=
literal|2
condition|)
name|OB_PUTCP
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* Otherwise, we can divine that this is a constructor,      and figure out its name without any extra encoding.  */
name|OB_PUTC2
argument_list|(
literal|'_'
argument_list|,
literal|'_'
argument_list|)
expr_stmt|;
if|if
condition|(
name|for_method
condition|)
block|{
if|#
directive|if
literal|0
comment|/* We can get away without doing this.  */
block|OB_PUTC ('M');
endif|#
directive|endif
name|parms
operator|=
name|temp_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|OB_PUTC
argument_list|(
literal|'F'
argument_list|)
expr_stmt|;
if|if
condition|(
name|parms
operator|==
name|NULL_TREE
condition|)
name|OB_PUTC2
argument_list|(
literal|'e'
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|parms
operator|==
name|void_list_node
condition|)
name|OB_PUTC2
argument_list|(
literal|'v'
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
else|else
block|{
name|ALLOCATE_TYPEVEC
argument_list|(
name|parms
argument_list|)
expr_stmt|;
name|nofold
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|for_method
condition|)
block|{
name|build_overload_name
argument_list|(
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typevec
index|[
name|maxtype
operator|++
index|]
operator|=
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
condition|)
name|build_overload_name
argument_list|(
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|OB_PUTC2
argument_list|(
literal|'e'
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
block|}
else|else
name|build_overload_name
argument_list|(
name|parms
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|DEALLOCATE_TYPEVEC
argument_list|(
name|parms
argument_list|)
expr_stmt|;
block|}
return|return
name|get_identifier
argument_list|(
name|obstack_base
argument_list|(
operator|&
name|scratch_obstack
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Build an overload name for the type expression TYPE.  */
end_comment

begin_function
name|tree
name|build_typename_overload
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|id
decl_stmt|;
name|OB_INIT
argument_list|()
expr_stmt|;
name|OB_PUTID
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|TYPE_EXPR
index|]
argument_list|)
expr_stmt|;
name|nofold
operator|=
literal|1
expr_stmt|;
name|build_overload_name
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|id
operator|=
name|get_identifier
argument_list|(
name|obstack_base
argument_list|(
operator|&
name|scratch_obstack
argument_list|)
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|id
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|id
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|NO_DOLLAR_IN_LABEL
end_ifndef

begin_define
define|#
directive|define
name|T_DESC_FORMAT
value|"TD$"
end_define

begin_define
define|#
directive|define
name|I_DESC_FORMAT
value|"ID$"
end_define

begin_define
define|#
directive|define
name|M_DESC_FORMAT
value|"MD$"
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|NO_DOT_IN_LABEL
argument_list|)
end_if

begin_define
define|#
directive|define
name|T_DESC_FORMAT
value|"TD."
end_define

begin_define
define|#
directive|define
name|I_DESC_FORMAT
value|"ID."
end_define

begin_define
define|#
directive|define
name|M_DESC_FORMAT
value|"MD."
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|T_DESC_FORMAT
value|"__t_desc_"
end_define

begin_define
define|#
directive|define
name|I_DESC_FORMAT
value|"__i_desc_"
end_define

begin_define
define|#
directive|define
name|M_DESC_FORMAT
value|"__m_desc_"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Build an overload name for the type expression TYPE.  */
end_comment

begin_function
name|tree
name|build_t_desc_overload
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|OB_INIT
argument_list|()
expr_stmt|;
name|OB_PUTS
argument_list|(
name|T_DESC_FORMAT
argument_list|)
expr_stmt|;
name|nofold
operator|=
literal|1
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Use a different format if the type isn't defined yet.  */
block|if (TYPE_SIZE (type) == NULL_TREE)     {       char *p;       int changed;        for (p = tname; *p; p++) 	if (isupper (*p)) 	  { 	    changed = 1; 	    *p = tolower (*p); 	  }
comment|/* If there's no change, we have an inappropriate T_DESC_FORMAT.  */
block|my_friendly_assert (changed != 0, 249);     }
endif|#
directive|endif
name|build_overload_name
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|get_identifier
argument_list|(
name|obstack_base
argument_list|(
operator|&
name|scratch_obstack
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Top-level interface to explicit overload requests. Allow NAME    to be overloaded. Error if NAME is already declared for the current    scope. Warning if function is redundantly overloaded. */
end_comment

begin_function
name|void
name|declare_overloaded
parameter_list|(
name|name
parameter_list|)
name|tree
name|name
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|NO_AUTO_OVERLOAD
if|if
condition|(
name|is_overloaded
argument_list|(
name|name
argument_list|)
condition|)
name|warning
argument_list|(
literal|"function `%s' already declared overloaded"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
condition|)
name|error
argument_list|(
literal|"overloading function `%s' that is already defined"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|TREE_OVERLOADED
argument_list|(
name|name
argument_list|)
operator|=
literal|1
expr_stmt|;
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
operator|=
name|build_tree_list
argument_list|(
name|name
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
argument_list|)
operator|=
name|unknown_type_node
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|current_lang_name
operator|==
name|lang_name_cplusplus
condition|)
block|{
if|if
condition|(
literal|0
condition|)
name|warning
argument_list|(
literal|"functions are implicitly overloaded in C++"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|current_lang_name
operator|==
name|lang_name_c
condition|)
name|error
argument_list|(
literal|"overloading function `%s' cannot be done in C language context"
argument_list|)
expr_stmt|;
else|else
name|my_friendly_abort
argument_list|(
literal|76
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|NO_AUTO_OVERLOAD
end_ifdef

begin_comment
comment|/* Check to see if NAME is overloaded. For first approximation,    check to see if its TREE_OVERLOADED is set.  This is used on    IDENTIFIER nodes.  */
end_comment

begin_function
name|int
name|is_overloaded
parameter_list|(
name|name
parameter_list|)
name|tree
name|name
decl_stmt|;
block|{
comment|/* @@ */
return|return
operator|(
name|TREE_OVERLOADED
argument_list|(
name|name
argument_list|)
operator|&&
operator|(
operator|!
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|name
argument_list|)
operator|||
name|current_class_type
operator|==
literal|0
operator|)
operator|&&
operator|!
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|name
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Given a tree_code CODE, and some arguments (at least one),    attempt to use an overloaded operator on the arguments.     For unary operators, only the first argument need be checked.    For binary operators, both arguments may need to be checked.     Member functions can convert class references to class pointers,    for one-level deep indirection.  More than that is not supported.    Operators [](), ()(), and ->() must be member functions.     We call function call building calls with nonzero complain if    they are our only hope.  This is true when we see a vanilla operator    applied to something of aggregate type.  If this fails, we are free to    return `error_mark_node', because we will have reported the error.     Operators NEW and DELETE overload in funny ways: operator new takes    a single `size' parameter, and operator delete takes a pointer to the    storage being deleted.  When overloading these operators, success is    assumed.  If there is a failure, report an error message and return    `error_mark_node'.  */
end_comment

begin_comment
comment|/* NOSTRICT */
end_comment

begin_function
name|tree
name|build_opfncall
parameter_list|(
name|code
parameter_list|,
name|flags
parameter_list|,
name|xarg1
parameter_list|,
name|xarg2
parameter_list|,
name|arg3
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|tree
name|xarg1
decl_stmt|,
name|xarg2
decl_stmt|,
name|arg3
decl_stmt|;
block|{
name|tree
name|rval
init|=
literal|0
decl_stmt|;
name|tree
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
name|tree
name|type1
decl_stmt|,
name|type2
decl_stmt|,
name|fnname
decl_stmt|;
name|tree
name|fields1
init|=
literal|0
decl_stmt|,
name|parms
init|=
literal|0
decl_stmt|;
name|tree
name|global_fn
decl_stmt|;
name|int
name|try_second
decl_stmt|;
name|int
name|binary_is_unary
decl_stmt|;
if|if
condition|(
name|xarg1
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|code
operator|==
name|COND_EXPR
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|xarg2
argument_list|)
operator|==
name|ERROR_MARK
operator|||
name|TREE_CODE
argument_list|(
name|arg3
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|code
operator|==
name|COMPONENT_REF
condition|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|xarg1
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
return|return
name|rval
return|;
comment|/* First, see if we can work with the first argument */
name|type1
operator|=
name|TREE_TYPE
argument_list|(
name|xarg1
argument_list|)
expr_stmt|;
comment|/* Some tree codes have length> 1, but we really only want to      overload them if their first argument has a user defined type.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|POSTINCREMENT_EXPR
case|:
case|case
name|POSTDECREMENT_EXPR
case|:
case|case
name|COMPONENT_REF
case|:
name|binary_is_unary
operator|=
literal|1
expr_stmt|;
name|try_second
operator|=
literal|0
expr_stmt|;
break|break;
comment|/* ARRAY_REFs and CALL_EXPRs must overload successfully. 	 If they do not, return error_mark_node instead of NULL_TREE.  */
case|case
name|ARRAY_REF
case|:
if|if
condition|(
name|xarg2
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
case|case
name|CALL_EXPR
case|:
name|rval
operator|=
name|error_mark_node
expr_stmt|;
name|binary_is_unary
operator|=
literal|0
expr_stmt|;
name|try_second
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|NEW_EXPR
case|:
block|{
comment|/* For operators `new' (`delete'), only check visibility 	   if we are in a constructor (destructor), and we are 	   allocating for that constructor's (destructor's) type.  */
name|fnname
operator|=
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|NEW_EXPR
index|]
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|LOOKUP_GLOBAL
condition|)
return|return
name|build_overload_call
argument_list|(
name|fnname
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|xarg2
argument_list|,
name|arg3
argument_list|)
argument_list|,
name|flags
operator|&
name|LOOKUP_COMPLAIN
argument_list|,
operator|(
expr|struct
name|candidate
operator|*
operator|)
literal|0
argument_list|)
return|;
if|if
condition|(
name|current_function_decl
operator|==
name|NULL_TREE
operator|||
operator|!
name|DECL_CONSTRUCTOR_P
argument_list|(
name|current_function_decl
argument_list|)
operator|||
name|current_class_type
operator|!=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type1
argument_list|)
condition|)
name|flags
operator|=
name|LOOKUP_COMPLAIN
expr_stmt|;
name|rval
operator|=
name|build_method_call
argument_list|(
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|xarg1
argument_list|,
name|error_mark_node
argument_list|)
argument_list|,
name|fnname
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|xarg2
argument_list|,
name|arg3
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|==
name|error_mark_node
condition|)
comment|/* User might declare fancy operator new, but invoke it 	     like standard one.  */
return|return
name|rval
return|;
name|TREE_TYPE
argument_list|(
name|rval
argument_list|)
operator|=
name|xarg1
expr_stmt|;
name|TREE_CALLS_NEW
argument_list|(
name|rval
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|rval
return|;
block|}
break|break;
case|case
name|DELETE_EXPR
case|:
block|{
comment|/* See comment above.  */
name|fnname
operator|=
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|DELETE_EXPR
index|]
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|LOOKUP_GLOBAL
condition|)
return|return
name|build_overload_call
argument_list|(
name|fnname
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|xarg1
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|xarg2
argument_list|)
argument_list|)
argument_list|,
name|flags
operator|&
name|LOOKUP_COMPLAIN
argument_list|,
operator|(
expr|struct
name|candidate
operator|*
operator|)
literal|0
argument_list|)
return|;
if|if
condition|(
name|current_function_decl
operator|==
name|NULL_TREE
operator|||
operator|!
name|DESTRUCTOR_NAME_P
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
operator|||
name|current_class_type
operator|!=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type1
argument_list|)
condition|)
name|flags
operator|=
name|LOOKUP_COMPLAIN
expr_stmt|;
name|rval
operator|=
name|build_method_call
argument_list|(
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|xarg1
argument_list|)
argument_list|,
name|error_mark_node
argument_list|)
argument_list|,
name|fnname
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|xarg1
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|xarg2
argument_list|)
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* This happens when the user mis-declares `operator delete'. 	   Should now be impossible.  */
name|my_friendly_assert
argument_list|(
name|rval
operator|!=
name|error_mark_node
argument_list|,
literal|250
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|rval
argument_list|)
operator|=
name|void_type_node
expr_stmt|;
return|return
name|rval
return|;
block|}
break|break;
default|default:
name|binary_is_unary
operator|=
literal|0
expr_stmt|;
name|try_second
operator|=
name|tree_code_length
index|[
operator|(
name|int
operator|)
name|code
index|]
operator|==
literal|2
expr_stmt|;
if|if
condition|(
name|try_second
operator|&&
name|xarg2
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
break|break;
block|}
if|if
condition|(
name|try_second
operator|&&
name|xarg2
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* What ever it was, we do not know how to deal with it.  */
if|if
condition|(
name|type1
operator|==
name|NULL_TREE
condition|)
return|return
name|rval
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type1
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
name|type1
operator|=
name|TREE_TYPE
argument_list|(
name|type1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type1
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|arg1
operator|=
name|convert_from_reference
argument_list|(
name|xarg1
argument_list|)
expr_stmt|;
name|type1
operator|=
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arg1
operator|=
name|xarg1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|type1
argument_list|)
condition|)
block|{
comment|/* Try to fail. First, fail if unary */
if|if
condition|(
operator|!
name|try_second
condition|)
return|return
name|rval
return|;
comment|/* Second, see if second argument is non-aggregate. */
name|type2
operator|=
name|TREE_TYPE
argument_list|(
name|xarg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type2
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
name|type2
operator|=
name|TREE_TYPE
argument_list|(
name|type2
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type2
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|arg2
operator|=
name|convert_from_reference
argument_list|(
name|xarg2
argument_list|)
expr_stmt|;
name|type2
operator|=
name|TREE_TYPE
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arg2
operator|=
name|xarg2
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|type2
argument_list|)
condition|)
return|return
name|rval
return|;
name|try_second
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|try_second
condition|)
block|{
comment|/* First arg may succeed; see whether second should.  */
name|type2
operator|=
name|TREE_TYPE
argument_list|(
name|xarg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type2
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
name|type2
operator|=
name|TREE_TYPE
argument_list|(
name|type2
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type2
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|arg2
operator|=
name|convert_from_reference
argument_list|(
name|xarg2
argument_list|)
expr_stmt|;
name|type2
operator|=
name|TREE_TYPE
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arg2
operator|=
name|xarg2
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|type2
argument_list|)
condition|)
name|try_second
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|type1
operator|==
name|unknown_type_node
operator|||
operator|(
name|try_second
operator|&&
name|TREE_TYPE
argument_list|(
name|xarg2
argument_list|)
operator|==
name|unknown_type_node
operator|)
condition|)
block|{
comment|/* This will not be implemented in the foreseeable future.  */
return|return
name|rval
return|;
block|}
if|if
condition|(
name|code
operator|==
name|MODIFY_EXPR
condition|)
name|fnname
operator|=
name|ansi_assopname
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|arg3
argument_list|)
index|]
expr_stmt|;
else|else
name|fnname
operator|=
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|code
index|]
expr_stmt|;
name|global_fn
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|fnname
argument_list|)
expr_stmt|;
comment|/* This is the last point where we will accept failure.  This      may be too eager if we wish an overloaded operator not to match,      but would rather a normal operator be called on a type-converted      argument.  */
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|type1
argument_list|)
condition|)
block|{
name|fields1
operator|=
name|lookup_fnfields
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type1
argument_list|)
argument_list|,
name|fnname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* ARM $13.4.7, prefix/postfix ++/--.  */
if|if
condition|(
name|code
operator|==
name|POSTINCREMENT_EXPR
operator|||
name|code
operator|==
name|POSTDECREMENT_EXPR
condition|)
block|{
name|xarg2
operator|=
name|integer_zero_node
expr_stmt|;
name|binary_is_unary
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fields1
condition|)
block|{
name|tree
name|t
decl_stmt|,
name|t2
decl_stmt|;
name|int
name|have_postfix
init|=
literal|0
decl_stmt|;
comment|/* Look for an `operator++ (int)'.  If they didn't have 		 one, then we fall back to the old way of doing things.  */
for|for
control|(
name|t
operator|=
name|TREE_VALUE
argument_list|(
name|fields1
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|t2
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|t2
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|t2
argument_list|)
argument_list|)
operator|==
name|integer_type_node
condition|)
block|{
name|have_postfix
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|have_postfix
condition|)
block|{
name|char
modifier|*
name|op
init|=
name|POSTINCREMENT_EXPR
condition|?
literal|"++"
else|:
literal|"--"
decl_stmt|;
comment|/* There's probably a LOT of code in the world that 		     relies upon this old behavior.  So we'll only give this 		     warning when we've been given -pedantic.  A few 		     releases after 2.4, we'll convert this to be a pedwarn 		     or something else more appropriate.  */
if|if
condition|(
name|pedantic
condition|)
name|warning
argument_list|(
literal|"no `operator%s (int)' declared for postfix `%s'"
argument_list|,
name|op
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|xarg2
operator|=
name|NULL_TREE
expr_stmt|;
name|binary_is_unary
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|fields1
operator|==
name|NULL_TREE
operator|&&
name|global_fn
operator|==
name|NULL_TREE
condition|)
return|return
name|rval
return|;
comment|/* If RVAL winds up being `error_mark_node', we will return      that... There is no way that normal semantics of these      operators will succeed.  */
comment|/* This argument may be an uncommitted OFFSET_REF.  This is      the case for example when dealing with static class members      which are referenced from their class name rather than      from a class instance.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|xarg1
argument_list|)
operator|==
name|OFFSET_REF
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|xarg1
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|xarg1
operator|=
name|TREE_OPERAND
argument_list|(
name|xarg1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|try_second
operator|&&
name|xarg2
operator|&&
name|TREE_CODE
argument_list|(
name|xarg2
argument_list|)
operator|==
name|OFFSET_REF
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|xarg2
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|xarg2
operator|=
name|TREE_OPERAND
argument_list|(
name|xarg2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|global_fn
condition|)
name|flags
operator||=
name|LOOKUP_GLOBAL
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|CALL_EXPR
condition|)
block|{
comment|/* This can only be a member function.  */
return|return
name|build_method_call
argument_list|(
name|xarg1
argument_list|,
name|fnname
argument_list|,
name|xarg2
argument_list|,
name|NULL_TREE
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|tree_code_length
index|[
operator|(
name|int
operator|)
name|code
index|]
operator|==
literal|1
operator|||
name|binary_is_unary
condition|)
block|{
name|parms
operator|=
name|NULL_TREE
expr_stmt|;
name|rval
operator|=
name|build_method_call
argument_list|(
name|xarg1
argument_list|,
name|fnname
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|COND_EXPR
condition|)
block|{
name|parms
operator|=
name|tree_cons
argument_list|(
literal|0
argument_list|,
name|xarg2
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arg3
argument_list|)
argument_list|)
expr_stmt|;
name|rval
operator|=
name|build_method_call
argument_list|(
name|xarg1
argument_list|,
name|fnname
argument_list|,
name|parms
argument_list|,
name|NULL_TREE
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|METHOD_CALL_EXPR
condition|)
block|{
comment|/* must be a member function.  */
name|parms
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|xarg2
argument_list|,
name|arg3
argument_list|)
expr_stmt|;
return|return
name|build_method_call
argument_list|(
name|xarg1
argument_list|,
name|fnname
argument_list|,
name|parms
argument_list|,
name|NULL_TREE
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|fields1
condition|)
block|{
name|parms
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|xarg2
argument_list|)
expr_stmt|;
name|rval
operator|=
name|build_method_call
argument_list|(
name|xarg1
argument_list|,
name|fnname
argument_list|,
name|parms
argument_list|,
name|NULL_TREE
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|parms
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|xarg1
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|xarg2
argument_list|)
argument_list|)
expr_stmt|;
name|rval
operator|=
name|build_overload_call
argument_list|(
name|fnname
argument_list|,
name|parms
argument_list|,
name|flags
operator|&
name|LOOKUP_COMPLAIN
argument_list|,
operator|(
expr|struct
name|candidate
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* If we did not win, do not lose yet, since type conversion may work.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rval
argument_list|)
operator|==
name|ERROR_MARK
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|LOOKUP_COMPLAIN
condition|)
return|return
name|rval
return|;
return|return
literal|0
return|;
block|}
return|return
name|rval
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This function takes an identifier, ID, and attempts to figure out what    it means. There are a number of possible scenarios, presented in increasing    order of hair:     1) not in a class's scope    2) in class's scope, member name of the class's method    3) in class's scope, but not a member name of the class    4) in class's scope, member name of a class's variable     NAME is $1 from the bison rule. It is an IDENTIFIER_NODE.    VALUE is $$ from the bison rule. It is the value returned by lookup_name ($1)    yychar is the pending input character (suitably encoded :-).     As a last ditch, try to look up the name as a label and return that    address.     Values which are declared as being of REFERENCE_TYPE are    automatically dereferenced here (as a hack to make the    compiler faster).  */
end_comment

begin_function
name|tree
name|hack_identifier
parameter_list|(
name|value
parameter_list|,
name|name
parameter_list|,
name|yychar
parameter_list|)
name|tree
name|value
decl_stmt|,
name|name
decl_stmt|;
name|int
name|yychar
decl_stmt|;
block|{
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|ERROR_MARK
condition|)
block|{
if|if
condition|(
name|current_class_name
condition|)
block|{
name|tree
name|fields
init|=
name|lookup_fnfields
argument_list|(
name|TYPE_BINFO
argument_list|(
name|current_class_type
argument_list|)
argument_list|,
name|name
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|fields
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|fields
condition|)
block|{
name|tree
name|fndecl
decl_stmt|;
name|fndecl
operator|=
name|TREE_VALUE
argument_list|(
name|fields
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|fndecl
argument_list|)
operator|==
name|FUNCTION_DECL
argument_list|,
literal|251
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_CHAIN
argument_list|(
name|fndecl
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|warning
argument_list|(
literal|"methods cannot be converted to function pointers"
argument_list|)
expr_stmt|;
return|return
name|fndecl
return|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"ambiguous request for method pointer `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
block|}
if|if
condition|(
name|flag_labels_ok
operator|&&
name|IDENTIFIER_LABEL_VALUE
argument_list|(
name|name
argument_list|)
condition|)
block|{
return|return
name|IDENTIFIER_LABEL_VALUE
argument_list|(
name|name
argument_list|)
return|;
block|}
return|return
name|error_mark_node
return|;
block|}
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
if|if
condition|(
name|current_class_decl
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"request for member `%s' in static member function"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|TREE_USED
argument_list|(
name|current_class_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|yychar
operator|==
literal|'('
condition|)
if|if
condition|(
operator|!
operator|(
operator|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_OVERLOADS_CALL_EXPR
argument_list|(
name|type
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|&&
name|TYPE_LANG_SPECIFIC
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
name|TYPE_OVERLOADS_CALL_EXPR
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|FUNCTION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|METHOD_TYPE
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|POINTER_TYPE
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|FUNCTION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|METHOD_TYPE
operator|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"component `%s' is not a method"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Mark so that if we are in a constructor, and then find that 	 this field was initialized by a base initializer, 	 we can emit an error message.  */
name|TREE_USED
argument_list|(
name|value
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|build_component_ref
argument_list|(
name|C_C_D
argument_list|,
name|name
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
name|tree
name|t
init|=
name|value
decl_stmt|;
while|while
condition|(
name|t
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
name|assemble_external
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|assemble_external
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|value
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
literal|'d'
operator|&&
name|DECL_NONLOCAL
argument_list|(
name|value
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_CLASS_CONTEXT
argument_list|(
name|value
argument_list|)
operator|!=
name|current_class_type
condition|)
block|{
name|tree
name|path
decl_stmt|;
name|enum
name|visibility_type
name|visibility
decl_stmt|;
specifier|register
name|tree
name|context
init|=
operator|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_VIRTUAL_P
argument_list|(
name|value
argument_list|)
operator|)
condition|?
name|DECL_CLASS_CONTEXT
argument_list|(
name|value
argument_list|)
else|:
name|DECL_CONTEXT
argument_list|(
name|value
argument_list|)
decl_stmt|;
name|get_base_distance
argument_list|(
name|context
argument_list|,
name|current_class_type
argument_list|,
literal|0
argument_list|,
operator|&
name|path
argument_list|)
expr_stmt|;
name|visibility
operator|=
name|compute_visibility
argument_list|(
name|path
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|visibility
operator|!=
name|visibility_public
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|error
argument_list|(
literal|"static member `%s' is from private base class"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"enum `%s' is from private base class"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
return|return
name|value
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|TREE_NONLOCAL_FLAG
argument_list|(
name|value
argument_list|)
condition|)
block|{
if|if
condition|(
name|type
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"request for member `%s' is ambiguous in multiple inheritance lattice"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|value
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|PARM_DECL
operator|||
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|RESULT_DECL
argument_list|,
literal|252
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_REFERENCE_SLOT
argument_list|(
name|value
argument_list|)
condition|)
return|return
name|DECL_REFERENCE_SLOT
argument_list|(
name|value
argument_list|)
return|;
block|}
return|return
name|value
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given an object OF, and a type conversion operator COMPONENT    build a call to the conversion operator, if a call is requested,    or return the address (as a pointer to member function) if one is not.     OF can be a TYPE_DECL or any kind of datum that would normally    be passed to `build_component_ref'.  It may also be NULL_TREE,    in which case `current_class_type' and `current_class_decl'    provide default values.     BASETYPE_PATH, if non-null, is the path of basetypes    to go through before we get the the instance of interest.     PROTECT says whether we apply C++ scoping rules or not.  */
end_comment

begin_function
name|tree
name|build_component_type_expr
parameter_list|(
name|of
parameter_list|,
name|component
parameter_list|,
name|basetype_path
parameter_list|,
name|protect
parameter_list|)
name|tree
name|of
decl_stmt|,
name|component
decl_stmt|,
name|basetype_path
decl_stmt|;
name|int
name|protect
decl_stmt|;
block|{
name|tree
name|cname
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|tmp
decl_stmt|,
name|last
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|int
name|flags
init|=
name|protect
condition|?
name|LOOKUP_NORMAL
else|:
name|LOOKUP_COMPLAIN
decl_stmt|;
if|if
condition|(
name|of
condition|)
name|my_friendly_assert
argument_list|(
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|of
argument_list|)
argument_list|)
argument_list|,
literal|253
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|component
argument_list|)
operator|==
name|TYPE_EXPR
argument_list|,
literal|254
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|TREE_OPERAND
argument_list|(
name|component
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|last
operator|=
name|NULL_TREE
expr_stmt|;
while|while
condition|(
name|tmp
condition|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|tmp
argument_list|)
condition|)
block|{
case|case
name|CALL_EXPR
case|:
if|if
condition|(
name|last
condition|)
name|TREE_OPERAND
argument_list|(
name|last
argument_list|,
literal|0
argument_list|)
operator|=
name|TREE_OPERAND
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|TREE_OPERAND
argument_list|(
name|component
argument_list|,
literal|0
argument_list|)
operator|=
name|TREE_OPERAND
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
operator|&&
name|TREE_OPERAND
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
operator|!=
name|void_list_node
condition|)
block|{
name|error
argument_list|(
literal|"operator<typename> requires empty parameter list"
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|last
operator|=
name|groktypename
argument_list|(
name|build_tree_list
argument_list|(
name|TREE_TYPE
argument_list|(
name|component
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|component
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|name
operator|=
name|build_typename_overload
argument_list|(
name|last
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|name
argument_list|)
operator|=
name|last
expr_stmt|;
if|if
condition|(
name|of
operator|&&
name|TREE_CODE
argument_list|(
name|of
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
return|return
name|build_method_call
argument_list|(
name|of
argument_list|,
name|name
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|flags
argument_list|)
return|;
elseif|else
if|if
condition|(
name|of
condition|)
block|{
name|tree
name|this_this
decl_stmt|;
if|if
condition|(
name|current_class_decl
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"object required for `operator<typename>' call"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|this_this
operator|=
name|convert_pointer_to
argument_list|(
name|TREE_TYPE
argument_list|(
name|of
argument_list|)
argument_list|,
name|current_class_decl
argument_list|)
expr_stmt|;
return|return
name|build_method_call
argument_list|(
name|this_this
argument_list|,
name|name
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|flags
operator||
name|LOOKUP_NONVIRTUAL
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|current_class_decl
condition|)
return|return
name|build_method_call
argument_list|(
name|tmp
argument_list|,
name|name
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|flags
argument_list|)
return|;
name|error
argument_list|(
literal|"object required for `operator<typename>' call"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
case|case
name|INDIRECT_REF
case|:
case|case
name|ADDR_EXPR
case|:
case|case
name|ARRAY_REF
case|:
break|break;
case|case
name|SCOPE_REF
case|:
name|my_friendly_assert
argument_list|(
name|cname
operator|==
literal|0
argument_list|,
literal|255
argument_list|)
expr_stmt|;
name|cname
operator|=
name|TREE_OPERAND
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|TREE_OPERAND
argument_list|(
name|tmp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|my_friendly_abort
argument_list|(
literal|77
argument_list|)
expr_stmt|;
block|}
name|last
operator|=
name|tmp
expr_stmt|;
name|tmp
operator|=
name|TREE_OPERAND
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|last
operator|=
name|groktypename
argument_list|(
name|build_tree_list
argument_list|(
name|TREE_TYPE
argument_list|(
name|component
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|component
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|name
operator|=
name|build_typename_overload
argument_list|(
name|last
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|name
argument_list|)
operator|=
name|last
expr_stmt|;
if|if
condition|(
name|of
operator|&&
name|TREE_CODE
argument_list|(
name|of
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
if|if
condition|(
name|cname
operator|==
name|NULL_TREE
condition|)
block|{
name|cname
operator|=
name|DECL_NAME
argument_list|(
name|of
argument_list|)
expr_stmt|;
name|of
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
name|my_friendly_assert
argument_list|(
name|cname
operator|==
name|DECL_NAME
argument_list|(
name|of
argument_list|)
argument_list|,
literal|256
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|of
condition|)
block|{
name|tree
name|this_this
decl_stmt|;
if|if
condition|(
name|current_class_decl
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"object required for `operator<typename>' call"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|this_this
operator|=
name|convert_pointer_to
argument_list|(
name|TREE_TYPE
argument_list|(
name|of
argument_list|)
argument_list|,
name|current_class_decl
argument_list|)
expr_stmt|;
return|return
name|build_component_ref
argument_list|(
name|this_this
argument_list|,
name|name
argument_list|,
literal|0
argument_list|,
name|protect
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|cname
condition|)
return|return
name|build_offset_ref
argument_list|(
name|cname
argument_list|,
name|name
argument_list|)
return|;
elseif|else
if|if
condition|(
name|current_class_name
condition|)
return|return
name|build_offset_ref
argument_list|(
name|current_class_name
argument_list|,
name|name
argument_list|)
return|;
name|error
argument_list|(
literal|"object required for `operator<typename>' member reference"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_function

end_unit

