begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Garbage collection primitives for GNU C++.    Copyright (C) 1992, 1993 Free Software Foundation, Inc.    Contributed by Michael Tiemann (tiemann@cygnus.com)  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_undef
undef|#
directive|undef
name|NULL
end_undef

begin_define
define|#
directive|define
name|NULL
value|0
end_define

begin_function_decl
specifier|extern
name|tree
name|define_function
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|tree
name|build_t_desc_overload
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* This is the function decl for the (pseudo-builtin) __gc_protect    function.  Args are (class *value, int index); Returns value.  */
end_comment

begin_decl_stmt
name|tree
name|gc_protect_fndecl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the function decl for the (pseudo-builtin) __gc_unprotect    function.  Args are (int index); void return.  */
end_comment

begin_decl_stmt
name|tree
name|gc_unprotect_fndecl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the function decl for the (pseudo-builtin) __gc_push    function.  Args are (int length); void return.  */
end_comment

begin_decl_stmt
name|tree
name|gc_push_fndecl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the function decl for the (pseudo-builtin) __gc_pop    function.  Args are void; void return.  */
end_comment

begin_decl_stmt
name|tree
name|gc_pop_fndecl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Special integers that are used to represent bits in gc-safe objects.  */
end_comment

begin_decl_stmt
name|tree
name|gc_nonobject
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|gc_visible
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|gc_white
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|gc_offwhite
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|gc_grey
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|gc_black
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* in c-common.c */
end_comment

begin_decl_stmt
specifier|extern
name|tree
name|combine_strings
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Predicate that returns non-zero if TYPE needs some kind of    entry for the GC.  Returns zero otherwise.  */
end_comment

begin_function
name|int
name|type_needs_gc_entry
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|ttype
init|=
name|type
decl_stmt|;
if|if
condition|(
operator|!
name|flag_gc
operator|||
name|type
operator|==
name|error_mark_node
condition|)
return|return
literal|0
return|;
comment|/* Aggregate types need gc entries if any of their members      need gc entries.  */
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
name|binfos
decl_stmt|;
name|tree
name|fields
init|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* We don't care about certain pointers.  Pointers 	 to virtual baseclasses are always up front.  We also 	 cull out virtual function table pointers because it's 	 easy, and it simplifies the logic.*/
while|while
condition|(
name|fields
operator|&&
operator|(
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
operator|==
name|NULL_TREE
operator|||
name|VFIELD_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
argument_list|)
operator|||
name|VBASE_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
argument_list|)
argument_list|,
literal|"__bits"
argument_list|)
operator|)
condition|)
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
expr_stmt|;
while|while
condition|(
name|fields
condition|)
block|{
if|if
condition|(
name|type_needs_gc_entry
argument_list|(
name|TREE_TYPE
argument_list|(
name|fields
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
expr_stmt|;
block|}
name|binfos
operator|=
name|TYPE_BINFO_BASETYPES
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|binfos
condition|)
for|for
control|(
name|i
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|type_needs_gc_entry
argument_list|(
name|BINFO_TYPE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
while|while
condition|(
name|TREE_CODE
argument_list|(
name|ttype
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ttype
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|ttype
operator|=
name|TREE_TYPE
argument_list|(
name|ttype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|ttype
argument_list|)
operator|==
name|POINTER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|ttype
argument_list|)
operator|==
name|ARRAY_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|ttype
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|)
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ttype
argument_list|)
argument_list|)
operator|&&
name|CLASSTYPE_DOSSIER
argument_list|(
name|TREE_TYPE
argument_list|(
name|ttype
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Predicate that returns non-zero iff FROM is safe from the GC.        If TO is nonzero, it means we know that FROM is being stored    in TO, which make make it safe.  */
end_comment

begin_function
name|int
name|value_safe_from_gc
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|)
name|tree
name|to
decl_stmt|,
name|from
decl_stmt|;
block|{
comment|/* First, return non-zero for easy cases: parameters,      static variables.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|PARM_DECL
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_STATIC
argument_list|(
name|from
argument_list|)
operator|)
condition|)
return|return
literal|1
return|;
comment|/* If something has its address taken, it cannot be      in the heap, so it doesn't need to be protected.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|ADDR_EXPR
operator|||
name|TREE_REFERENCE_EXPR
argument_list|(
name|from
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* If we are storing into a static variable, then what      we store will be safe from the gc.  */
if|if
condition|(
name|to
operator|&&
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_STATIC
argument_list|(
name|to
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Now recurse on structure of FROM.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|from
argument_list|)
condition|)
block|{
case|case
name|COMPONENT_REF
case|:
comment|/* These guys are special, and safe.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|from
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
operator|(
name|VFIELD_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|TREE_OPERAND
argument_list|(
name|from
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|||
name|VBASE_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|TREE_OPERAND
argument_list|(
name|from
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
return|return
literal|1
return|;
comment|/* fall through...  */
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|NON_LVALUE_EXPR
case|:
case|case
name|WITH_CLEANUP_EXPR
case|:
case|case
name|SAVE_EXPR
case|:
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|POSTDECREMENT_EXPR
case|:
case|case
name|POSTINCREMENT_EXPR
case|:
if|if
condition|(
name|value_safe_from_gc
argument_list|(
name|to
argument_list|,
name|TREE_OPERAND
argument_list|(
name|from
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|VAR_DECL
case|:
case|case
name|PARM_DECL
case|:
comment|/* We can safely pass these things as parameters to functions.  */
if|if
condition|(
name|to
operator|==
literal|0
condition|)
return|return
literal|1
return|;
case|case
name|ARRAY_REF
case|:
case|case
name|INDIRECT_REF
case|:
case|case
name|RESULT_DECL
case|:
case|case
name|OFFSET_REF
case|:
case|case
name|CALL_EXPR
case|:
case|case
name|METHOD_CALL_EXPR
case|:
break|break;
case|case
name|COMPOUND_EXPR
case|:
case|case
name|TARGET_EXPR
case|:
if|if
condition|(
name|value_safe_from_gc
argument_list|(
name|to
argument_list|,
name|TREE_OPERAND
argument_list|(
name|from
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|COND_EXPR
case|:
if|if
condition|(
name|value_safe_from_gc
argument_list|(
name|to
argument_list|,
name|TREE_OPERAND
argument_list|(
name|from
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|value_safe_from_gc
argument_list|(
name|to
argument_list|,
name|TREE_OPERAND
argument_list|(
name|from
argument_list|,
literal|2
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
if|if
condition|(
operator|(
name|type_needs_gc_entry
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|from
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|||
name|value_safe_from_gc
argument_list|(
name|to
argument_list|,
name|TREE_OPERAND
argument_list|(
name|from
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|type_needs_gc_entry
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|from
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|0
operator|||
name|value_safe_from_gc
argument_list|(
name|to
argument_list|,
name|TREE_OPERAND
argument_list|(
name|from
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|RTL_EXPR
case|:
comment|/* Every time we build an RTL_EXPR in the front-end, we must 	 ensure that everything in it is safe from the garbage collector. 	 ??? This has only been done for `build_new'.  */
return|return
literal|1
return|;
default|default:
name|my_friendly_abort
argument_list|(
literal|41
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|to
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* FROM wasn't safe.  But other properties of TO might make it safe.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|to
argument_list|)
condition|)
block|{
case|case
name|VAR_DECL
case|:
case|case
name|PARM_DECL
case|:
comment|/* We already culled out static VAR_DECLs above.  */
return|return
literal|0
return|;
case|case
name|COMPONENT_REF
case|:
comment|/* These guys are special, and safe.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
operator|(
name|VFIELD_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|TREE_OPERAND
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|||
name|VBASE_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|TREE_OPERAND
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
return|return
literal|1
return|;
comment|/* fall through...  */
case|case
name|NOP_EXPR
case|:
case|case
name|NON_LVALUE_EXPR
case|:
case|case
name|WITH_CLEANUP_EXPR
case|:
case|case
name|SAVE_EXPR
case|:
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|POSTDECREMENT_EXPR
case|:
case|case
name|POSTINCREMENT_EXPR
case|:
return|return
name|value_safe_from_gc
argument_list|(
name|TREE_OPERAND
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
argument_list|,
name|from
argument_list|)
return|;
case|case
name|COMPOUND_EXPR
case|:
case|case
name|TARGET_EXPR
case|:
return|return
name|value_safe_from_gc
argument_list|(
name|TREE_OPERAND
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
argument_list|,
name|from
argument_list|)
return|;
case|case
name|COND_EXPR
case|:
return|return
operator|(
name|value_safe_from_gc
argument_list|(
name|TREE_OPERAND
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
argument_list|,
name|from
argument_list|)
operator|&&
name|value_safe_from_gc
argument_list|(
name|TREE_OPERAND
argument_list|(
name|to
argument_list|,
literal|2
argument_list|)
argument_list|,
name|from
argument_list|)
operator|)
return|;
case|case
name|INDIRECT_REF
case|:
case|case
name|ARRAY_REF
case|:
comment|/* This used to be 0, but our current restricted model 	 allows this to be 1.  We'll never get arrays this way.  */
return|return
literal|1
return|;
default|default:
name|my_friendly_abort
argument_list|(
literal|42
argument_list|)
expr_stmt|;
block|}
comment|/* Catch-all case is that TO/FROM is not safe.  */
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Function to build a static GC entry for DECL.  TYPE is DECL's type.     For objects of type `class *', this is just an entry in the    static vector __PTR_LIST__.     For objects of type `class[]', this requires building an entry    in the static vector __ARR_LIST__.     For aggregates, this records all fields of type `class *'    and `class[]' in the respective lists above.  */
end_comment

begin_function
name|void
name|build_static_gc_entry
parameter_list|(
name|decl
parameter_list|,
name|type
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
comment|/* Now, figure out what sort of entry to build.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|assemble_gc_entry
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
block|{
name|tree
name|ref
init|=
name|get_temp_name
argument_list|(
name|build_reference_type
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|DECL_INITIAL
argument_list|(
name|ref
argument_list|)
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|ref
argument_list|)
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|DECL_INITIAL
argument_list|(
name|ref
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
name|finish_decl
argument_list|(
name|ref
argument_list|,
name|DECL_INITIAL
argument_list|(
name|ref
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Not yet implemented. 	  	 Cons up a static variable that holds address and length info 	 and add that to ___ARR_LIST__.  */
name|my_friendly_abort
argument_list|(
literal|43
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Protect FROM from the GC, assuming FROM is going to be    stored into TO.  We handle three cases for TO here:     case 1: TO is a stack variable.    case 2: TO is zero (which means it is a parameter).    case 3: TO is a return value.  */
end_comment

begin_function
name|tree
name|protect_value_from_gc
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|)
name|tree
name|to
decl_stmt|,
name|from
decl_stmt|;
block|{
if|if
condition|(
name|to
operator|==
literal|0
condition|)
block|{
name|tree
name|cleanup
decl_stmt|;
name|to
operator|=
name|get_temp_regvar
argument_list|(
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
argument_list|,
name|from
argument_list|)
expr_stmt|;
comment|/* Convert from integer to list form since we'll use it twice.  */
name|DECL_GC_OFFSET
argument_list|(
name|to
argument_list|)
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|DECL_GC_OFFSET
argument_list|(
name|to
argument_list|)
argument_list|)
expr_stmt|;
name|cleanup
operator|=
name|build_function_call
argument_list|(
name|gc_unprotect_fndecl
argument_list|,
name|DECL_GC_OFFSET
argument_list|(
name|to
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|expand_decl_cleanup
argument_list|(
name|to
argument_list|,
name|cleanup
argument_list|)
condition|)
block|{
name|compiler_error
argument_list|(
literal|"cannot unprotect parameter in this scope"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
comment|/* Should never need to protect a value that's headed for static storage.  */
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|to
argument_list|)
condition|)
name|my_friendly_abort
argument_list|(
literal|44
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|to
argument_list|)
condition|)
block|{
case|case
name|COMPONENT_REF
case|:
case|case
name|INDIRECT_REF
case|:
return|return
name|protect_value_from_gc
argument_list|(
name|TREE_OPERAND
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
argument_list|,
name|from
argument_list|)
return|;
case|case
name|VAR_DECL
case|:
case|case
name|PARM_DECL
case|:
block|{
name|tree
name|rval
decl_stmt|;
if|if
condition|(
name|DECL_GC_OFFSET
argument_list|(
name|to
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* Because of a cast or a conversion, we might stick 	       a value into a variable that would not normally 	       have a GC entry.  */
name|DECL_GC_OFFSET
argument_list|(
name|to
argument_list|)
operator|=
name|size_int
argument_list|(
operator|++
name|current_function_obstack_index
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_GC_OFFSET
argument_list|(
name|to
argument_list|)
argument_list|)
operator|!=
name|TREE_LIST
condition|)
block|{
name|DECL_GC_OFFSET
argument_list|(
name|to
argument_list|)
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|DECL_GC_OFFSET
argument_list|(
name|to
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|current_function_obstack_usage
operator|=
literal|1
expr_stmt|;
name|rval
operator|=
name|build_function_call
argument_list|(
name|gc_protect_fndecl
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|from
argument_list|,
name|DECL_GC_OFFSET
argument_list|(
name|to
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|rval
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
block|}
comment|/* If we fall through the switch, assume we lost.  */
name|my_friendly_abort
argument_list|(
literal|45
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given the expression EXP of type `class *', return the head    of the object pointed to by EXP.  */
end_comment

begin_function
name|tree
name|build_headof
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|tree
name|vptr
decl_stmt|,
name|offset
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"`headof' applied to non-pointer type"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|flag_vtable_thunks
condition|)
name|abort
argument_list|()
expr_stmt|;
name|vptr
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|vtable_entry_type
argument_list|)
argument_list|,
name|exp
argument_list|)
expr_stmt|;
name|offset
operator|=
name|build_component_ref
argument_list|(
name|build_array_ref
argument_list|(
name|vptr
argument_list|,
name|integer_one_node
argument_list|)
argument_list|,
name|get_identifier
argument_list|(
name|VTABLE_DELTA_NAME
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|class_star_type_node
argument_list|,
name|exp
argument_list|,
name|convert
argument_list|(
name|integer_type_node
argument_list|,
name|offset
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given the expression EXP of type `class *', return the    type descriptor for the object pointed to by EXP.  */
end_comment

begin_function
name|tree
name|build_classof
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|tree
name|vptr
decl_stmt|;
name|tree
name|t_desc_entry
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"`classof' applied to non-pointer type"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|vptr
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|vtable_entry_type
argument_list|)
argument_list|,
name|exp
argument_list|)
expr_stmt|;
name|t_desc_entry
operator|=
name|build_component_ref
argument_list|(
name|build_array_ref
argument_list|(
name|vptr
argument_list|,
name|integer_one_node
argument_list|)
argument_list|,
name|get_identifier
argument_list|(
name|VTABLE_PFN_NAME
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t_desc_entry
argument_list|)
operator|=
name|TYPE_POINTER_TO
argument_list|(
name|__t_desc_type_node
argument_list|)
expr_stmt|;
return|return
name|t_desc_entry
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the Type_info node associated with the expression EXP.  If EXP is    a reference to a polymorphic class, return the dynamic type; otherwise    return the static type of the expression.  */
end_comment

begin_function
name|tree
name|build_typeid
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|exp
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
comment|/* if b is an instance of B, typeid(b) == typeid(B).  Do this before      reference trickiness.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
return|return
name|get_typeid
argument_list|(
name|type
argument_list|)
return|;
comment|/* Apply trivial conversion T -> T& for dereferenced ptrs.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
name|type
operator|=
name|build_reference_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* If exp is a reference to polymorphic type, get the real Type_info.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|&&
name|TYPE_VIRTUAL_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
comment|/* build reference to Type_info from vtable.  */
name|sorry
argument_list|(
literal|"finding Type_info for an object"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* otherwise return the Type_info for the static type of the expr.  */
return|return
name|get_typeid
argument_list|(
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the Type_info object for TYPE, creating it if necessary.  */
end_comment

begin_function
name|tree
name|get_typeid
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* Is it useful (and/or correct) to have different typeids for `T&'      and `T'?  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* build reference to static Type_info */
if|#
directive|if
literal|1
name|sorry
argument_list|(
literal|"finding Type_info for a type"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
else|#
directive|else
specifier|register
name|tree
name|t
init|=
name|TYPE_TINFO
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
condition|)
return|return
name|t
return|;
comment|/* ... */
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Execute a dynamic cast, as described in section 5.2.6 of the 9/93 working    paper.  */
end_comment

begin_function
name|tree
name|build_dynamic_cast
parameter_list|(
name|type
parameter_list|,
name|expr
parameter_list|)
name|tree
name|type
decl_stmt|,
name|expr
decl_stmt|;
block|{
name|enum
name|tree_code
name|tc
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|exprtype
init|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
decl_stmt|;
name|enum
name|tree_code
name|ec
init|=
name|TREE_CODE
argument_list|(
name|exprtype
argument_list|)
decl_stmt|;
name|tree
name|retval
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
operator|||
name|expr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
switch|switch
condition|(
name|tc
condition|)
block|{
case|case
name|POINTER_TYPE
case|:
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
operator|==
name|void_type_node
condition|)
break|break;
comment|/* else fall through */
case|case
name|REFERENCE_TYPE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|NULL_TREE
condition|)
break|break;
comment|/* else fall through */
default|default:
name|cp_error
argument_list|(
literal|"`%#T' is not a valid type argument for dynamic_cast"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"(must be either pointer or reference to defined class or void *)"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Apply trivial conversion T -> T& for dereferenced ptrs.  */
if|if
condition|(
name|ec
operator|==
name|RECORD_TYPE
condition|)
block|{
name|exprtype
operator|=
name|build_reference_type
argument_list|(
name|exprtype
argument_list|)
expr_stmt|;
name|ec
operator|=
name|REFERENCE_TYPE
expr_stmt|;
block|}
comment|/* the TREE_CODE of exprtype must match that of type.  */
if|if
condition|(
name|ec
operator|!=
name|tc
condition|)
block|{
name|cp_error
argument_list|(
literal|"`%E' (of type `%#T') fails to be of %s type"
argument_list|,
name|expr
argument_list|,
name|exprtype
argument_list|,
name|tc
operator|==
name|POINTER_TYPE
condition|?
literal|"pointer"
else|:
literal|"reference"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* If *type is an unambiguous accessible base class of *exprtype,      convert statically.  */
block|{
name|int
name|distance
decl_stmt|;
name|tree
name|path
decl_stmt|;
name|distance
operator|=
name|get_base_distance
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|exprtype
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|distance
operator|>=
literal|0
condition|)
return|return
name|build_vbase_path
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|,
name|path
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/* Otherwise *exprtype must be a polymorphic class (have a vtbl).  */
if|if
condition|(
name|TYPE_VIRTUAL_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|exprtype
argument_list|)
argument_list|)
condition|)
block|{
comment|/* if TYPE is `void *', return pointer to complete object.  */
if|if
condition|(
name|tc
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
operator|==
name|void_type_node
condition|)
block|{
comment|/* if b is an object, dynamic_cast<void *>(&b) == (void *)&b.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
return|return
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
return|;
name|sorry
argument_list|(
literal|"finding pointer to complete object"
argument_list|)
expr_stmt|;
return|return
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
return|;
block|}
else|else
block|{
name|tree
name|retval
decl_stmt|;
comment|/* If we got here, we can't convert statically.  Therefore, 	     dynamic_cast<D&>(b) (b an object) cannot succeed.  */
if|if
condition|(
name|ec
operator|==
name|REFERENCE_TYPE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
block|{
name|cp_warning
argument_list|(
literal|"dynamic_cast of `%#D' to `%#T' can never succeed"
argument_list|,
name|expr
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* cplus_expand_throw (Bad_cast_node); */
name|sorry
argument_list|(
literal|"throwing Bad_cast"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
comment|/* Ditto for dynamic_cast<D*>(&b).  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
block|{
name|tree
name|op
init|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
block|{
name|cp_warning
argument_list|(
literal|"dynamic_cast of `%E' to `%#T' can never succeed"
argument_list|,
name|expr
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|retval
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|retval
argument_list|)
operator|=
name|type
expr_stmt|;
return|return
name|retval
return|;
block|}
block|}
comment|/* Build run-time conversion.  */
name|sorry
argument_list|(
literal|"run-time type conversion"
argument_list|)
expr_stmt|;
name|retval
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|retval
argument_list|)
operator|=
name|type
expr_stmt|;
return|return
name|retval
return|;
block|}
block|}
name|cp_error
argument_list|(
literal|"cannot dynamic_cast `%E' (of type `%#T') to type `%#T'"
argument_list|,
name|expr
argument_list|,
name|exprtype
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Build and initialize various sorts of descriptors.  Every descriptor    node has a name associated with it (the name created by mangling).    For this reason, we use the identifier as our access to the __*_desc    nodes, instead of sticking them directly in the types.  Otherwise we    would burden all built-in types (and pointer types) with slots that    we don't necessarily want to use.     For each descriptor we build, we build a variable that contains    the descriptor's information.  When we need this info at runtime,    all we need is access to these variables.     Note: these constructors always return the address of the descriptor    info, since that is simplest for their mutual interaction.  */
end_comment

begin_function
specifier|static
name|tree
name|build_generic_desc
parameter_list|(
name|decl
parameter_list|,
name|elems
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|tree
name|elems
decl_stmt|;
block|{
name|tree
name|init
init|=
name|build
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|elems
argument_list|)
decl_stmt|;
name|TREE_CONSTANT
argument_list|(
name|init
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|init
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|init
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|init
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|layout_decl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|decl
argument_list|,
name|init
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|IDENTIFIER_AS_DESC
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Build an initializer for a __t_desc node.  So that we can take advantage    of recursion, we accept NULL for TYPE.    DEFINITION is greater than zero iff we must define the type descriptor    (as opposed to merely referencing it).  1 means treat according to    #pragma interface/#pragma implementation rules.  2 means define as    global and public, no matter what.  */
end_comment

begin_function
name|tree
name|build_t_desc
parameter_list|(
name|type
parameter_list|,
name|definition
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
name|definition
decl_stmt|;
block|{
name|tree
name|tdecl
decl_stmt|;
name|tree
name|tname
decl_stmt|,
name|name_string
decl_stmt|;
name|tree
name|elems
decl_stmt|,
name|fields
decl_stmt|;
name|tree
name|parents
decl_stmt|,
name|vbases
decl_stmt|,
name|offsets
decl_stmt|,
name|ivars
decl_stmt|,
name|methods
decl_stmt|,
name|target_type
decl_stmt|;
name|int
name|method_count
init|=
literal|0
decl_stmt|,
name|field_count
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL_TREE
condition|)
return|return
name|NULL_TREE
return|;
name|tname
operator|=
name|build_t_desc_overload
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|IDENTIFIER_AS_DESC
argument_list|(
name|tname
argument_list|)
operator|&&
operator|(
operator|!
name|definition
operator|||
name|TREE_ASM_WRITTEN
argument_list|(
name|IDENTIFIER_AS_DESC
argument_list|(
name|tname
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|IDENTIFIER_AS_DESC
argument_list|(
name|tname
argument_list|)
return|;
name|tdecl
operator|=
name|lookup_name
argument_list|(
name|tname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdecl
operator|==
name|NULL_TREE
condition|)
block|{
name|tdecl
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|tname
argument_list|,
name|__t_desc_type_node
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|tdecl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|tdecl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|tdecl
operator|=
name|pushdecl_top_level
argument_list|(
name|tdecl
argument_list|)
expr_stmt|;
block|}
comment|/* If we previously defined it, return the defined result.  */
elseif|else
if|if
condition|(
name|definition
operator|&&
name|DECL_INITIAL
argument_list|(
name|tdecl
argument_list|)
condition|)
return|return
name|IDENTIFIER_AS_DESC
argument_list|(
name|tname
argument_list|)
return|;
if|if
condition|(
name|definition
condition|)
block|{
name|tree
name|taggr
init|=
name|type
decl_stmt|;
comment|/* Let T* and T& be written only when T is written (if T is an aggr).          We do this for const, but not for volatile, since volatile 	 is rare and const is not.  */
if|if
condition|(
operator|!
name|TYPE_VOLATILE
argument_list|(
name|taggr
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|taggr
argument_list|)
operator|==
name|POINTER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|taggr
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|)
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|taggr
argument_list|)
argument_list|)
condition|)
name|taggr
operator|=
name|TREE_TYPE
argument_list|(
name|taggr
argument_list|)
expr_stmt|;
comment|/* If we know that we don't need to write out this type's 	 vtable, then don't write out it's dossier.  Somebody 	 else will take care of that.  */
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|taggr
argument_list|)
operator|&&
name|CLASSTYPE_VFIELD
argument_list|(
name|taggr
argument_list|)
condition|)
block|{
if|if
condition|(
name|CLASSTYPE_VTABLE_NEEDS_WRITING
argument_list|(
name|taggr
argument_list|)
condition|)
block|{
name|TREE_PUBLIC
argument_list|(
name|tdecl
argument_list|)
operator|=
operator|!
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|taggr
argument_list|)
operator|&&
name|CLASSTYPE_INTERFACE_KNOWN
argument_list|(
name|taggr
argument_list|)
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|tdecl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|tdecl
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|write_virtuals
operator|!=
literal|0
condition|)
name|TREE_PUBLIC
argument_list|(
name|tdecl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|DECL_EXTERNAL
argument_list|(
name|tdecl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|tdecl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|tdecl
argument_list|)
operator|=
operator|(
name|definition
operator|>
literal|1
operator|)
expr_stmt|;
block|}
block|}
name|SET_IDENTIFIER_AS_DESC
argument_list|(
name|tname
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|tdecl
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|definition
operator|||
name|DECL_EXTERNAL
argument_list|(
name|tdecl
argument_list|)
condition|)
block|{
comment|/* That's it!  */
name|finish_decl
argument_list|(
name|tdecl
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|IDENTIFIER_AS_DESC
argument_list|(
name|tname
argument_list|)
return|;
block|}
comment|/* Show that we are defining the t_desc for this type.  */
name|DECL_INITIAL
argument_list|(
name|tdecl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|parents
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
name|vbases
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
name|offsets
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
name|methods
operator|=
name|NULL_TREE
expr_stmt|;
name|ivars
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|int
name|i
init|=
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|method_vec
init|=
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
modifier|*
name|meth
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|tree
name|binfos
init|=
name|TYPE_BINFO_BASETYPES
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|vb
init|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|type
argument_list|)
decl_stmt|;
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
name|parents
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_t_desc
argument_list|(
name|BINFO_TYPE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|parents
argument_list|)
expr_stmt|;
while|while
condition|(
name|vb
condition|)
block|{
name|vbases
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_t_desc
argument_list|(
name|BINFO_TYPE
argument_list|(
name|vb
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|vbases
argument_list|)
expr_stmt|;
name|offsets
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|vb
argument_list|)
argument_list|,
name|offsets
argument_list|)
expr_stmt|;
name|vb
operator|=
name|TREE_CHAIN
argument_list|(
name|vb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|method_vec
condition|)
for|for
control|(
name|meth
operator|=
name|TREE_VEC_END
argument_list|(
name|method_vec
argument_list|)
operator|,
name|end
operator|=
operator|&
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|0
argument_list|)
init|;
name|meth
operator|--
operator|!=
name|end
condition|;
control|)
if|if
condition|(
operator|*
name|meth
condition|)
block|{
name|methods
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_m_desc
argument_list|(
operator|*
name|meth
argument_list|)
argument_list|,
name|methods
argument_list|)
expr_stmt|;
name|method_count
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
condition|)
block|{
for|for
control|(
name|fields
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|fields
condition|;
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fields
argument_list|)
operator|==
name|FIELD_DECL
operator|||
name|TREE_CODE
argument_list|(
name|fields
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
name|ivars
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_i_desc
argument_list|(
name|fields
argument_list|)
argument_list|,
name|ivars
argument_list|)
expr_stmt|;
name|field_count
operator|++
expr_stmt|;
block|}
name|ivars
operator|=
name|nreverse
argument_list|(
name|ivars
argument_list|)
expr_stmt|;
block|}
name|parents
operator|=
name|finish_table
argument_list|(
literal|0
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|__t_desc_type_node
argument_list|)
argument_list|,
name|parents
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vbases
operator|=
name|finish_table
argument_list|(
literal|0
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|__t_desc_type_node
argument_list|)
argument_list|,
name|vbases
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|offsets
operator|=
name|finish_table
argument_list|(
literal|0
argument_list|,
name|integer_type_node
argument_list|,
name|offsets
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|methods
operator|==
name|NULL_TREE
condition|)
name|methods
operator|=
name|null_pointer_node
expr_stmt|;
else|else
name|methods
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|finish_table
argument_list|(
literal|0
argument_list|,
name|__m_desc_type_node
argument_list|,
name|methods
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ivars
operator|==
name|NULL_TREE
condition|)
name|ivars
operator|=
name|null_pointer_node
expr_stmt|;
else|else
name|ivars
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|finish_table
argument_list|(
literal|0
argument_list|,
name|__i_desc_type_node
argument_list|,
name|ivars
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
condition|)
name|target_type
operator|=
name|build_t_desc
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|definition
argument_list|)
expr_stmt|;
else|else
name|target_type
operator|=
name|integer_zero_node
expr_stmt|;
name|name_string
operator|=
name|combine_strings
argument_list|(
name|build_string
argument_list|(
name|IDENTIFIER_LENGTH
argument_list|(
name|tname
argument_list|)
operator|+
literal|1
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|tname
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|elems
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|name_string
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
condition|?
name|size_in_bytes
argument_list|(
name|type
argument_list|)
else|:
name|integer_zero_node
argument_list|,
comment|/* really should use bitfield initialization here.  */
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_zero_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|target_type
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
name|field_count
argument_list|,
literal|2
argument_list|)
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
name|method_count
argument_list|,
literal|2
argument_list|)
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ivars
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|methods
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|parents
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|vbases
argument_list|,
literal|0
argument_list|)
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|offsets
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build_generic_desc
argument_list|(
name|tdecl
argument_list|,
name|elems
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Build an initializer for a __i_desc node.  */
end_comment

begin_function
name|tree
name|build_i_desc
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|tree
name|elems
decl_stmt|,
name|name_string
decl_stmt|;
name|tree
name|taggr
decl_stmt|;
name|name_string
operator|=
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|name_string
operator|=
name|combine_strings
argument_list|(
name|build_string
argument_list|(
name|IDENTIFIER_LENGTH
argument_list|(
name|name_string
argument_list|)
operator|+
literal|1
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name_string
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now decide whether this ivar should cause it's type to get      def'd or ref'd in this file.  If the type we are looking at      has a proxy definition, we look at the proxy (i.e., a      `foo *' is equivalent to a `foo').  */
name|taggr
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|taggr
argument_list|)
operator|==
name|POINTER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|taggr
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|)
operator|&&
name|TYPE_VOLATILE
argument_list|(
name|taggr
argument_list|)
operator|==
literal|0
condition|)
name|taggr
operator|=
name|TREE_TYPE
argument_list|(
name|taggr
argument_list|)
expr_stmt|;
name|elems
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|name_string
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|DECL_FIELD_BITPOS
argument_list|(
name|decl
argument_list|)
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|build_t_desc
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|taggr
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|taggr
operator|=
name|build
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|__i_desc_type_node
argument_list|,
name|NULL_TREE
argument_list|,
name|elems
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|taggr
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|taggr
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|taggr
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|taggr
return|;
block|}
end_function

begin_comment
comment|/* Build an initializer for a __m_desc node.  */
end_comment

begin_function
name|tree
name|build_m_desc
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|tree
name|taggr
decl_stmt|,
name|elems
decl_stmt|,
name|name_string
decl_stmt|;
name|tree
name|parm_count
decl_stmt|,
name|req_count
decl_stmt|,
name|vindex
decl_stmt|,
name|vcontext
decl_stmt|;
name|tree
name|parms
decl_stmt|;
name|int
name|p_count
decl_stmt|,
name|r_count
decl_stmt|;
name|tree
name|parm_types
init|=
name|NULL_TREE
decl_stmt|;
for|for
control|(
name|parms
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|,
name|p_count
operator|=
literal|0
operator|,
name|r_count
operator|=
literal|0
init|;
name|parms
operator|!=
name|NULL_TREE
condition|;
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
operator|,
name|p_count
operator|++
control|)
block|{
name|taggr
operator|=
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|taggr
argument_list|)
operator|==
name|POINTER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|taggr
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|)
operator|&&
name|TYPE_VOLATILE
argument_list|(
name|taggr
argument_list|)
operator|==
literal|0
condition|)
name|taggr
operator|=
name|TREE_TYPE
argument_list|(
name|taggr
argument_list|)
expr_stmt|;
name|parm_types
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_t_desc
argument_list|(
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
argument_list|,
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|taggr
argument_list|)
argument_list|)
argument_list|,
name|parm_types
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|parms
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|r_count
operator|++
expr_stmt|;
block|}
name|parm_types
operator|=
name|finish_table
argument_list|(
literal|0
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|__t_desc_type_node
argument_list|)
argument_list|,
name|nreverse
argument_list|(
name|parm_types
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|parm_count
operator|=
name|build_int_2
argument_list|(
name|p_count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|req_count
operator|=
name|build_int_2
argument_list|(
name|r_count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|decl
argument_list|)
condition|)
name|vindex
operator|=
name|DECL_VINDEX
argument_list|(
name|decl
argument_list|)
expr_stmt|;
else|else
name|vindex
operator|=
name|integer_zero_node
expr_stmt|;
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'t'
condition|)
name|vcontext
operator|=
name|build_t_desc
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|vcontext
operator|=
name|integer_zero_node
expr_stmt|;
name|name_string
operator|=
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|name_string
operator|==
name|NULL
condition|)
name|name_string
operator|=
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|name_string
operator|=
name|combine_strings
argument_list|(
name|build_string
argument_list|(
name|IDENTIFIER_LENGTH
argument_list|(
name|name_string
argument_list|)
operator|+
literal|1
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name_string
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now decide whether the return type of this mvar      should cause it's type to get def'd or ref'd in this file.      If the type we are looking at has a proxy definition,      we look at the proxy (i.e., a `foo *' is equivalent to a `foo').  */
name|taggr
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|taggr
argument_list|)
operator|==
name|POINTER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|taggr
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|)
operator|&&
name|TYPE_VOLATILE
argument_list|(
name|taggr
argument_list|)
operator|==
literal|0
condition|)
name|taggr
operator|=
name|TREE_TYPE
argument_list|(
name|taggr
argument_list|)
expr_stmt|;
name|elems
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|name_string
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|vindex
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|vcontext
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_t_desc
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|taggr
argument_list|)
argument_list|)
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_c_cast
argument_list|(
name|TYPE_POINTER_TO
argument_list|(
name|default_function_type
argument_list|)
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|decl
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|parm_count
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|req_count
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|parm_types
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|taggr
operator|=
name|build
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|__m_desc_type_node
argument_list|,
name|NULL_TREE
argument_list|,
name|elems
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|taggr
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|taggr
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|taggr
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|taggr
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Conditionally emit code to set up an unwind-protect for the    garbage collector.  If this function doesn't do anything that involves    the garbage collector, then do nothing.  Otherwise, call __gc_push    at the beginning and __gc_pop at the end.     NOTE!  The __gc_pop function must operate transparently, since    it comes where the logical return label lies.  This means that    at runtime *it* must preserve any return value registers.  */
end_comment

begin_function
name|void
name|expand_gc_prologue_and_epilogue
parameter_list|()
block|{
specifier|extern
name|tree
name|maybe_gc_cleanup
decl_stmt|;
name|struct
name|rtx_def
modifier|*
name|last_parm_insn
decl_stmt|,
modifier|*
name|mark
decl_stmt|;
specifier|extern
name|struct
name|rtx_def
modifier|*
name|get_last_insn
parameter_list|()
function_decl|;
specifier|extern
name|struct
name|rtx_def
modifier|*
name|get_first_nonparm_insn
parameter_list|()
function_decl|;
specifier|extern
name|struct
name|rtx_def
modifier|*
name|previous_insn
parameter_list|()
function_decl|;
name|tree
name|action
decl_stmt|;
comment|/* If we didn't need the obstack, don't cons any space.  */
if|if
condition|(
name|current_function_obstack_index
operator|==
literal|0
operator|||
name|current_function_obstack_usage
operator|==
literal|0
condition|)
return|return;
name|mark
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|last_parm_insn
operator|=
name|get_first_nonparm_insn
argument_list|()
expr_stmt|;
if|if
condition|(
name|last_parm_insn
operator|==
literal|0
condition|)
name|last_parm_insn
operator|=
name|mark
expr_stmt|;
else|else
name|last_parm_insn
operator|=
name|previous_insn
argument_list|(
name|last_parm_insn
argument_list|)
expr_stmt|;
name|action
operator|=
name|build_function_call
argument_list|(
name|gc_push_fndecl
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|size_int
argument_list|(
operator|++
name|current_function_obstack_index
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|action
argument_list|)
expr_stmt|;
name|reorder_insns
argument_list|(
name|next_insn
argument_list|(
name|mark
argument_list|)
argument_list|,
name|get_last_insn
argument_list|()
argument_list|,
name|last_parm_insn
argument_list|)
expr_stmt|;
comment|/* This will be expanded as a cleanup.  */
name|TREE_VALUE
argument_list|(
name|maybe_gc_cleanup
argument_list|)
operator|=
name|build_function_call
argument_list|(
name|gc_pop_fndecl
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Some day we'll use this function as a call-back and clean    up all the unnecessary gc dribble that we otherwise create.  */
end_comment

begin_function
name|void
name|lang_expand_end_bindings
parameter_list|(
name|first
parameter_list|,
name|last
parameter_list|)
name|struct
name|rtx_def
modifier|*
name|first
decl_stmt|,
decl|*
name|last
decl_stmt|;
end_function

begin_block
block|{ }
end_block

begin_escape
end_escape

begin_function
name|void
name|init_gc_processing
parameter_list|()
block|{
name|tree
name|parmtypes
init|=
name|hash_tree_chain
argument_list|(
name|class_star_type_node
argument_list|,
name|hash_tree_chain
argument_list|(
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
decl_stmt|;
name|gc_protect_fndecl
operator|=
name|define_function
argument_list|(
literal|"__gc_protect"
argument_list|,
name|build_function_type
argument_list|(
name|class_star_type_node
argument_list|,
name|parmtypes
argument_list|)
argument_list|,
name|NOT_BUILT_IN
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|parmtypes
operator|=
name|hash_tree_chain
argument_list|(
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|gc_unprotect_fndecl
operator|=
name|define_function
argument_list|(
literal|"__gc_unprotect"
argument_list|,
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|parmtypes
argument_list|)
argument_list|,
name|NOT_BUILT_IN
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gc_push_fndecl
operator|=
name|define_function
argument_list|(
literal|"__gc_push"
argument_list|,
name|TREE_TYPE
argument_list|(
name|gc_unprotect_fndecl
argument_list|)
argument_list|,
name|NOT_BUILT_IN
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gc_pop_fndecl
operator|=
name|define_function
argument_list|(
literal|"__gc_pop"
argument_list|,
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|void_list_node
argument_list|)
argument_list|,
name|NOT_BUILT_IN
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gc_nonobject
operator|=
name|build_int_2
argument_list|(
literal|0x80000000
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gc_visible
operator|=
name|build_int_2
argument_list|(
literal|0x40000000
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gc_white
operator|=
name|integer_zero_node
expr_stmt|;
name|gc_offwhite
operator|=
name|build_int_2
argument_list|(
literal|0x10000000
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gc_grey
operator|=
name|build_int_2
argument_list|(
literal|0x20000000
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gc_black
operator|=
name|build_int_2
argument_list|(
literal|0x30000000
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

