begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Allocate registers within a basic block, for GNU compiler.    Copyright (C) 1987, 1988, 1991, 1993, 1994 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* Allocation of hard register numbers to pseudo registers is done in    two passes.  In this pass we consider only regs that are born and    die once within one basic block.  We do this one basic block at a    time.  Then the next pass allocates the registers that remain.    Two passes are used because this pass uses methods that work only    on linear code, but that do a better job than the general methods    used in global_alloc, and more quickly too.     The assignments made are recorded in the vector reg_renumber    whose space is allocated here.  The rtl code itself is not altered.     We assign each instruction in the basic block a number    which is its order from the beginning of the block.    Then we can represent the lifetime of a pseudo register with    a pair of numbers, and check for conflicts easily.    We can record the availability of hard registers with a    HARD_REG_SET for each instruction.  The HARD_REG_SET    contains 0 or 1 for each hard reg.     To avoid register shuffling, we tie registers together when one    dies by being copied into another, or dies in an instruction that    does arithmetic to produce another.  The tied registers are    allocated as one.  Registers with different reg class preferences    can never be tied unless the class preferred by one is a subclass    of the one preferred by the other.     Tying is represented with "quantity numbers".    A non-tied register is given a new quantity number.    Tied registers have the same quantity number.        We have provision to exempt registers, even when they are contained    within the block, that can be tied to others that are not contained in it.    This is so that global_alloc could process them both and tie them then.    But this is currently disabled since tying in global_alloc is not    yet implemented.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* Pseudos allocated here cannot be reallocated by global.c if the hard    register is used as a spill register.  So we don't allocate such pseudos    here if their preferred class is likely to be used by spills.     On most machines, the appropriate test is if the class has one    register, so we default to that.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CLASS_LIKELY_SPILLED_P
end_ifndef

begin_define
define|#
directive|define
name|CLASS_LIKELY_SPILLED_P
parameter_list|(
name|CLASS
parameter_list|)
value|(reg_class_size[(int) (CLASS)] == 1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Next quantity number available for allocation.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|next_qty
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* In all the following vectors indexed by quantity number.  */
end_comment

begin_comment
comment|/* Element Q is the hard reg number chosen for quantity Q,    or -1 if none was found.  */
end_comment

begin_decl_stmt
specifier|static
name|short
modifier|*
name|qty_phys_reg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We maintain two hard register sets that indicate suggested hard registers    for each quantity.  The first, qty_phys_copy_sugg, contains hard registers    that are tied to the quantity by a simple copy.  The second contains all    hard registers that are tied to the quantity via an arithmetic operation.     The former register set is given priority for allocation.  This tends to    eliminate copy insns.  */
end_comment

begin_comment
comment|/* Element Q is a set of hard registers that are suggested for quantity Q by    copy insns.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
modifier|*
name|qty_phys_copy_sugg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Element Q is a set of hard registers that are suggested for quantity Q by    arithmetic insns.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
modifier|*
name|qty_phys_sugg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Element Q is the number of suggested registers in qty_phys_copy_sugg.  */
end_comment

begin_decl_stmt
specifier|static
name|short
modifier|*
name|qty_phys_num_copy_sugg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Element Q is the number of suggested registers in qty_phys_sugg. */
end_comment

begin_decl_stmt
specifier|static
name|short
modifier|*
name|qty_phys_num_sugg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Element Q is the number of refs to quantity Q.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|qty_n_refs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Element Q is a reg class contained in (smaller than) the    preferred classes of all the pseudo regs that are tied in quantity Q.    This is the preferred class for allocating that quantity.  */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|reg_class
modifier|*
name|qty_min_class
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Insn number (counting from head of basic block)    where quantity Q was born.  -1 if birth has not been recorded.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|qty_birth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Insn number (counting from head of basic block)    where quantity Q died.  Due to the way tying is done,    and the fact that we consider in this pass only regs that die but once,    a quantity can die only once.  Each quantity's life span    is a set of consecutive insns.  -1 if death has not been recorded.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|qty_death
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of words needed to hold the data in quantity Q.    This depends on its machine mode.  It is used for these purposes:    1. It is used in computing the relative importances of qtys,       which determines the order in which we look for regs for them.    2. It is used in rules that prevent tying several registers of       different sizes in a way that is geometrically impossible       (see combine_regs).  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|qty_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This holds the mode of the registers that are tied to qty Q,    or VOIDmode if registers with differing modes are tied together.  */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|machine_mode
modifier|*
name|qty_mode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of times a reg tied to qty Q lives across a CALL_INSN.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|qty_n_calls_crossed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Register class within which we allocate qty Q if we can't get    its preferred class.  */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|reg_class
modifier|*
name|qty_alternate_class
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Element Q is the SCRATCH expression for which this quantity is being    allocated or 0 if this quantity is allocating registers.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|qty_scratch_rtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Element Q is nonzero if this quantity has been used in a SUBREG    that changes its size.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|qty_changes_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Element Q is the register number of one pseudo register whose    reg_qty value is Q, or -1 is this quantity is for a SCRATCH.  This    register should be the head of the chain maintained in reg_next_in_qty.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|qty_first_reg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If (REG N) has been assigned a quantity number, is a register number    of another register assigned the same quantity number, or -1 for the    end of the chain.  qty_first_reg point to the head of this chain.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|reg_next_in_qty
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* reg_qty[N] (where N is a pseudo reg number) is the qty number of that reg    if it is>= 0,    of -1 if this register cannot be allocated by local-alloc,    or -2 if not known yet.     Note that if we see a use or death of pseudo register N with    reg_qty[N] == -2, register N must be local to the current block.  If    it were used in more than one block, we would have reg_qty[N] == -1.    This relies on the fact that if reg_basic_block[N] is>= 0, register N    will not appear in any other block.  We save a considerable number of    tests by exploiting this.     If N is< FIRST_PSEUDO_REGISTER, reg_qty[N] is undefined and should not    be referenced.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|reg_qty
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The offset (in words) of register N within its quantity.    This can be nonzero if register N is SImode, and has been tied    to a subreg of a DImode register.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|reg_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Vector of substitutions of register numbers,    used to map pseudo regs into hardware regs.    This is set up as a result of register allocation.    Element N is the hard reg assigned to pseudo reg N,    or is -1 if no hard reg was assigned.    If N is a hard reg number, element N is N.  */
end_comment

begin_decl_stmt
name|short
modifier|*
name|reg_renumber
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set of hard registers live at the current point in the scan    of the instructions in a basic block.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|regs_live
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Each set of hard registers indicates registers live at a particular    point in the basic block.  For N even, regs_live_at[N] says which    hard registers are needed *after* insn N/2 (i.e., they may not    conflict with the outputs of insn N/2 or the inputs of insn N/2 + 1.     If an object is to conflict with the inputs of insn J but not the    outputs of insn J + 1, we say it is born at index J*2 - 1.  Similarly,    if it is to conflict with the outputs of insn J but not the inputs of    insn J + 1, it is said to die at index J*2 + 1.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
modifier|*
name|regs_live_at
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|scratch_block
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
modifier|*
name|scratch_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|scratch_list_length
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|scratch_index
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Communicate local vars `insn_number' and `insn'    from `block_alloc' to `reg_is_set', `wipe_dead_reg', and `alloc_qty'.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|this_insn_number
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|this_insn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|alloc_qty
name|PROTO
argument_list|(
operator|(
name|int
operator|,
expr|enum
name|machine_mode
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|alloc_qty_for_scratch
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|,
name|rtx
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|validate_equiv_mem_from_store
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|validate_equiv_mem
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|memref_referenced_p
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|memref_used_between_p
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|optimize_reg_copy_1
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|optimize_reg_copy_2
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|update_equiv_regs
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|block_alloc
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|qty_sugg_compare
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|qty_sugg_compare_1
name|PROTO
argument_list|(
operator|(
name|int
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|qty_compare
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|qty_compare_1
name|PROTO
argument_list|(
operator|(
name|int
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|combine_regs
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|,
name|int
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reg_meets_class_p
name|PROTO
argument_list|(
operator|(
name|int
operator|,
expr|enum
name|reg_class
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reg_classes_overlap_p
name|PROTO
argument_list|(
operator|(
expr|enum
name|reg_class
operator|,
expr|enum
name|reg_class
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|update_qty_class
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|reg_is_set
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|reg_is_born
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|wipe_dead_reg
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|find_free_reg
name|PROTO
argument_list|(
operator|(
expr|enum
name|reg_class
operator|,
expr|enum
name|machine_mode
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_life
name|PROTO
argument_list|(
operator|(
name|int
operator|,
expr|enum
name|machine_mode
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|post_mark_life
name|PROTO
argument_list|(
operator|(
name|int
operator|,
expr|enum
name|machine_mode
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|no_conflict_p
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|requires_inout
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Allocate a new quantity (new within current basic block)    for register number REGNO which is born at index BIRTH    within the block.  MODE and SIZE are info on reg REGNO.  */
end_comment

begin_function
specifier|static
name|void
name|alloc_qty
parameter_list|(
name|regno
parameter_list|,
name|mode
parameter_list|,
name|size
parameter_list|,
name|birth
parameter_list|)
name|int
name|regno
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|size
decl_stmt|,
name|birth
decl_stmt|;
block|{
specifier|register
name|int
name|qty
init|=
name|next_qty
operator|++
decl_stmt|;
name|reg_qty
index|[
name|regno
index|]
operator|=
name|qty
expr_stmt|;
name|reg_offset
index|[
name|regno
index|]
operator|=
literal|0
expr_stmt|;
name|reg_next_in_qty
index|[
name|regno
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|qty_first_reg
index|[
name|qty
index|]
operator|=
name|regno
expr_stmt|;
name|qty_size
index|[
name|qty
index|]
operator|=
name|size
expr_stmt|;
name|qty_mode
index|[
name|qty
index|]
operator|=
name|mode
expr_stmt|;
name|qty_birth
index|[
name|qty
index|]
operator|=
name|birth
expr_stmt|;
name|qty_n_calls_crossed
index|[
name|qty
index|]
operator|=
name|reg_n_calls_crossed
index|[
name|regno
index|]
expr_stmt|;
name|qty_min_class
index|[
name|qty
index|]
operator|=
name|reg_preferred_class
argument_list|(
name|regno
argument_list|)
expr_stmt|;
name|qty_alternate_class
index|[
name|qty
index|]
operator|=
name|reg_alternate_class
argument_list|(
name|regno
argument_list|)
expr_stmt|;
name|qty_n_refs
index|[
name|qty
index|]
operator|=
name|reg_n_refs
index|[
name|regno
index|]
expr_stmt|;
name|qty_changes_size
index|[
name|qty
index|]
operator|=
name|reg_changes_size
index|[
name|regno
index|]
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Similar to `alloc_qty', but allocates a quantity for a SCRATCH rtx    used as operand N in INSN.  We assume here that the SCRATCH is used in    a CLOBBER.  */
end_comment

begin_function
specifier|static
name|void
name|alloc_qty_for_scratch
parameter_list|(
name|scratch
parameter_list|,
name|n
parameter_list|,
name|insn
parameter_list|,
name|insn_code_num
parameter_list|,
name|insn_number
parameter_list|)
name|rtx
name|scratch
decl_stmt|;
name|int
name|n
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|insn_code_num
decl_stmt|,
name|insn_number
decl_stmt|;
block|{
specifier|register
name|int
name|qty
decl_stmt|;
name|enum
name|reg_class
name|class
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
name|c
decl_stmt|;
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|REGISTER_CONSTRAINTS
comment|/* If we haven't yet computed which alternative will be used, do so now.      Then set P to the constraints for that alternative.  */
if|if
condition|(
name|which_alternative
operator|==
operator|-
literal|1
condition|)
if|if
condition|(
operator|!
name|constrain_operands
argument_list|(
name|insn_code_num
argument_list|,
literal|0
argument_list|)
condition|)
return|return;
for|for
control|(
name|p
operator|=
name|insn_operand_constraint
index|[
name|insn_code_num
index|]
index|[
name|n
index|]
operator|,
name|i
operator|=
literal|0
init|;
operator|*
name|p
operator|&&
name|i
operator|<
name|which_alternative
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|','
condition|)
name|i
operator|++
expr_stmt|;
comment|/* Compute the class required for this SCRATCH.  If we don't need a      register, the class will remain NO_REGS.  If we guessed the alternative      number incorrectly, reload will fix things up for us.  */
name|class
operator|=
name|NO_REGS
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|'\0'
operator|&&
name|c
operator|!=
literal|','
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'='
case|:
case|case
literal|'+'
case|:
case|case
literal|'?'
case|:
case|case
literal|'#'
case|:
case|case
literal|'&'
case|:
case|case
literal|'!'
case|:
case|case
literal|'*'
case|:
case|case
literal|'%'
case|:
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'m'
case|:
case|case
literal|'<'
case|:
case|case
literal|'>'
case|:
case|case
literal|'V'
case|:
case|case
literal|'o'
case|:
case|case
literal|'E'
case|:
case|case
literal|'F'
case|:
case|case
literal|'G'
case|:
case|case
literal|'H'
case|:
case|case
literal|'s'
case|:
case|case
literal|'i'
case|:
case|case
literal|'n'
case|:
case|case
literal|'I'
case|:
case|case
literal|'J'
case|:
case|case
literal|'K'
case|:
case|case
literal|'L'
case|:
case|case
literal|'M'
case|:
case|case
literal|'N'
case|:
case|case
literal|'O'
case|:
case|case
literal|'P'
case|:
ifdef|#
directive|ifdef
name|EXTRA_CONSTRAINT
case|case
literal|'Q'
case|:
case|case
literal|'R'
case|:
case|case
literal|'S'
case|:
case|case
literal|'T'
case|:
case|case
literal|'U'
case|:
endif|#
directive|endif
case|case
literal|'p'
case|:
comment|/* These don't say anything we care about.  */
break|break;
case|case
literal|'X'
case|:
comment|/* We don't need to allocate this SCRATCH.  */
return|return;
case|case
literal|'g'
case|:
case|case
literal|'r'
case|:
name|class
operator|=
name|reg_class_subunion
index|[
operator|(
name|int
operator|)
name|class
index|]
index|[
operator|(
name|int
operator|)
name|GENERAL_REGS
index|]
expr_stmt|;
break|break;
default|default:
name|class
operator|=
name|reg_class_subunion
index|[
operator|(
name|int
operator|)
name|class
index|]
index|[
operator|(
name|int
operator|)
name|REG_CLASS_FROM_LETTER
argument_list|(
name|c
argument_list|)
index|]
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|class
operator|==
name|NO_REGS
condition|)
return|return;
else|#
directive|else
comment|/* REGISTER_CONSTRAINTS */
name|class
operator|=
name|GENERAL_REGS
expr_stmt|;
endif|#
directive|endif
name|qty
operator|=
name|next_qty
operator|++
expr_stmt|;
name|qty_first_reg
index|[
name|qty
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|qty_scratch_rtx
index|[
name|qty
index|]
operator|=
name|scratch
expr_stmt|;
name|qty_size
index|[
name|qty
index|]
operator|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|scratch
argument_list|)
argument_list|)
expr_stmt|;
name|qty_mode
index|[
name|qty
index|]
operator|=
name|GET_MODE
argument_list|(
name|scratch
argument_list|)
expr_stmt|;
name|qty_birth
index|[
name|qty
index|]
operator|=
literal|2
operator|*
name|insn_number
operator|-
literal|1
expr_stmt|;
name|qty_death
index|[
name|qty
index|]
operator|=
literal|2
operator|*
name|insn_number
operator|+
literal|1
expr_stmt|;
name|qty_n_calls_crossed
index|[
name|qty
index|]
operator|=
literal|0
expr_stmt|;
name|qty_min_class
index|[
name|qty
index|]
operator|=
name|class
expr_stmt|;
name|qty_alternate_class
index|[
name|qty
index|]
operator|=
name|NO_REGS
expr_stmt|;
name|qty_n_refs
index|[
name|qty
index|]
operator|=
literal|1
expr_stmt|;
name|qty_changes_size
index|[
name|qty
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Main entry point of this file.  */
end_comment

begin_function
name|void
name|local_alloc
parameter_list|()
block|{
specifier|register
name|int
name|b
decl_stmt|,
name|i
decl_stmt|;
name|int
name|max_qty
decl_stmt|;
comment|/* Leaf functions and non-leaf functions have different needs.      If defined, let the machine say what kind of ordering we      should use.  */
ifdef|#
directive|ifdef
name|ORDER_REGS_FOR_LOCAL_ALLOC
name|ORDER_REGS_FOR_LOCAL_ALLOC
expr_stmt|;
endif|#
directive|endif
comment|/* Promote REG_EQUAL notes to REG_EQUIV notes and adjust status of affected      registers.  */
name|update_equiv_regs
argument_list|()
expr_stmt|;
comment|/* This sets the maximum number of quantities we can have.  Quantity      numbers start at zero and we can have one for each pseudo plus the      number of SCRATCHes in the largest block, in the worst case.  */
name|max_qty
operator|=
operator|(
name|max_regno
operator|-
name|FIRST_PSEUDO_REGISTER
operator|)
operator|+
name|max_scratch
expr_stmt|;
comment|/* Allocate vectors of temporary data.      See the declarations of these variables, above,      for what they mean.  */
comment|/* There can be up to MAX_SCRATCH * N_BASIC_BLOCKS SCRATCHes to allocate.      Instead of allocating this much memory from now until the end of      reload, only allocate space for MAX_QTY SCRATCHes.  If there are more      reload will allocate them.  */
name|scratch_list_length
operator|=
name|max_qty
expr_stmt|;
name|scratch_list
operator|=
operator|(
name|rtx
operator|*
operator|)
name|xmalloc
argument_list|(
name|scratch_list_length
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|scratch_list
argument_list|,
name|scratch_list_length
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|scratch_block
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|scratch_list_length
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|scratch_block
argument_list|,
name|scratch_list_length
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|scratch_index
operator|=
literal|0
expr_stmt|;
name|qty_phys_reg
operator|=
operator|(
name|short
operator|*
operator|)
name|alloca
argument_list|(
name|max_qty
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|qty_phys_copy_sugg
operator|=
operator|(
name|HARD_REG_SET
operator|*
operator|)
name|alloca
argument_list|(
name|max_qty
operator|*
sizeof|sizeof
argument_list|(
name|HARD_REG_SET
argument_list|)
argument_list|)
expr_stmt|;
name|qty_phys_num_copy_sugg
operator|=
operator|(
name|short
operator|*
operator|)
name|alloca
argument_list|(
name|max_qty
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|qty_phys_sugg
operator|=
operator|(
name|HARD_REG_SET
operator|*
operator|)
name|alloca
argument_list|(
name|max_qty
operator|*
sizeof|sizeof
argument_list|(
name|HARD_REG_SET
argument_list|)
argument_list|)
expr_stmt|;
name|qty_phys_num_sugg
operator|=
operator|(
name|short
operator|*
operator|)
name|alloca
argument_list|(
name|max_qty
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|qty_birth
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|max_qty
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|qty_death
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|max_qty
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|qty_scratch_rtx
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|max_qty
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|qty_first_reg
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|max_qty
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|qty_size
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|max_qty
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|qty_mode
operator|=
operator|(
expr|enum
name|machine_mode
operator|*
operator|)
name|alloca
argument_list|(
name|max_qty
operator|*
sizeof|sizeof
argument_list|(
expr|enum
name|machine_mode
argument_list|)
argument_list|)
expr_stmt|;
name|qty_n_calls_crossed
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|max_qty
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|qty_min_class
operator|=
operator|(
expr|enum
name|reg_class
operator|*
operator|)
name|alloca
argument_list|(
name|max_qty
operator|*
sizeof|sizeof
argument_list|(
expr|enum
name|reg_class
argument_list|)
argument_list|)
expr_stmt|;
name|qty_alternate_class
operator|=
operator|(
expr|enum
name|reg_class
operator|*
operator|)
name|alloca
argument_list|(
name|max_qty
operator|*
sizeof|sizeof
argument_list|(
expr|enum
name|reg_class
argument_list|)
argument_list|)
expr_stmt|;
name|qty_n_refs
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|max_qty
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|qty_changes_size
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|max_qty
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|reg_qty
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|reg_offset
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|reg_next_in_qty
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|reg_renumber
operator|=
operator|(
name|short
operator|*
operator|)
name|oballoc
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_regno
condition|;
name|i
operator|++
control|)
name|reg_renumber
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Determine which pseudo-registers can be allocated by local-alloc.      In general, these are the registers used only in a single block and      which only die once.  However, if a register's preferred class has only      a few entries, don't allocate this register here unless it is preferred      or nothing since retry_global_alloc won't be able to move it to      GENERAL_REGS if a reload register of this class is needed.       We need not be concerned with which block actually uses the register      since we will never see it outside that block.  */
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
name|max_regno
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|reg_basic_block
index|[
name|i
index|]
operator|>=
literal|0
operator|&&
name|reg_n_deaths
index|[
name|i
index|]
operator|==
literal|1
operator|&&
operator|(
name|reg_alternate_class
argument_list|(
name|i
argument_list|)
operator|==
name|NO_REGS
operator|||
operator|!
name|CLASS_LIKELY_SPILLED_P
argument_list|(
name|reg_preferred_class
argument_list|(
name|i
argument_list|)
argument_list|)
operator|)
condition|)
name|reg_qty
index|[
name|i
index|]
operator|=
operator|-
literal|2
expr_stmt|;
else|else
name|reg_qty
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Force loop below to initialize entire quantity array.  */
name|next_qty
operator|=
name|max_qty
expr_stmt|;
comment|/* Allocate each block's local registers, block by block.  */
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|n_basic_blocks
condition|;
name|b
operator|++
control|)
block|{
comment|/* NEXT_QTY indicates which elements of the `qty_...' 	 vectors might need to be initialized because they were used 	 for the previous block; it is set to the entire array before 	 block 0.  Initialize those, with explicit loop if there are few, 	 else with bzero and bcopy.  Do not initialize vectors that are 	 explicit set by `alloc_qty'.  */
if|if
condition|(
name|next_qty
operator|<
literal|6
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|next_qty
condition|;
name|i
operator|++
control|)
block|{
name|qty_scratch_rtx
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|qty_phys_copy_sugg
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|qty_phys_num_copy_sugg
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|qty_phys_sugg
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|qty_phys_num_sugg
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
define|#
directive|define
name|CLEAR
parameter_list|(
name|vector
parameter_list|)
define|\
value|bzero ((char *) (vector), (sizeof (*(vector))) * next_qty);
name|CLEAR
argument_list|(
name|qty_scratch_rtx
argument_list|)
expr_stmt|;
name|CLEAR
argument_list|(
name|qty_phys_copy_sugg
argument_list|)
expr_stmt|;
name|CLEAR
argument_list|(
name|qty_phys_num_copy_sugg
argument_list|)
expr_stmt|;
name|CLEAR
argument_list|(
name|qty_phys_sugg
argument_list|)
expr_stmt|;
name|CLEAR
argument_list|(
name|qty_phys_num_sugg
argument_list|)
expr_stmt|;
block|}
name|next_qty
operator|=
literal|0
expr_stmt|;
name|block_alloc
argument_list|(
name|b
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_C_ALLOCA
name|alloca
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Depth of loops we are in while in update_equiv_regs.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|loop_depth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used for communication between the following two functions: contains    a MEM that we wish to ensure remains unchanged.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|equiv_mem
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set nonzero if EQUIV_MEM is modified.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|equiv_mem_modified
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If EQUIV_MEM is modified by modifying DEST, indicate that it is modified.    Called via note_stores.  */
end_comment

begin_function
specifier|static
name|void
name|validate_equiv_mem_from_store
parameter_list|(
name|dest
parameter_list|,
name|set
parameter_list|)
name|rtx
name|dest
decl_stmt|;
name|rtx
name|set
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|dest
argument_list|,
name|equiv_mem
argument_list|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|MEM
operator|&&
name|true_dependence
argument_list|(
name|dest
argument_list|,
name|equiv_mem
argument_list|)
operator|)
condition|)
name|equiv_mem_modified
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Verify that no store between START and the death of REG invalidates    MEMREF.  MEMREF is invalidated by modifying a register used in MEMREF,    by storing into an overlapping memory location, or with a non-const    CALL_INSN.     Return 1 if MEMREF remains valid.  */
end_comment

begin_function
specifier|static
name|int
name|validate_equiv_mem
parameter_list|(
name|start
parameter_list|,
name|reg
parameter_list|,
name|memref
parameter_list|)
name|rtx
name|start
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
name|rtx
name|memref
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
name|rtx
name|note
decl_stmt|;
name|equiv_mem
operator|=
name|memref
expr_stmt|;
name|equiv_mem_modified
operator|=
literal|0
expr_stmt|;
comment|/* If the memory reference has side effects or is volatile, it isn't a      valid equivalence.  */
if|if
condition|(
name|side_effects_p
argument_list|(
name|memref
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|insn
operator|=
name|start
init|;
name|insn
operator|&&
operator|!
name|equiv_mem_modified
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
literal|'i'
condition|)
continue|continue;
if|if
condition|(
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|reg
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|&&
operator|!
name|RTX_UNCHANGING_P
argument_list|(
name|memref
argument_list|)
operator|&&
operator|!
name|CONST_CALL_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return
literal|0
return|;
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|validate_equiv_mem_from_store
argument_list|)
expr_stmt|;
comment|/* If a register mentioned in MEMREF is modified via an 	 auto-increment, we lose the equivalence.  Do the same if one 	 dies; although we could extend the life, it doesn't seem worth 	 the trouble.  */
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
operator|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_INC
operator|||
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_DEAD
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|memref
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* TRUE if X references a memory location that would be affected by a store    to MEMREF.  */
end_comment

begin_function
specifier|static
name|int
name|memref_referenced_p
parameter_list|(
name|memref
parameter_list|,
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|memref
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
modifier|*
name|fmt
decl_stmt|;
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST
case|:
case|case
name|LABEL_REF
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|HIGH
case|:
case|case
name|LO_SUM
case|:
return|return
literal|0
return|;
case|case
name|MEM
case|:
if|if
condition|(
name|true_dependence
argument_list|(
name|memref
argument_list|,
name|x
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|SET
case|:
comment|/* If we are setting a MEM, it doesn't count (its address does), but any 	 other SET_DEST that has a MEM in it is referencing the MEM.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
name|memref_referenced_p
argument_list|(
name|memref
argument_list|,
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|memref_referenced_p
argument_list|(
name|memref
argument_list|,
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
name|memref_referenced_p
argument_list|(
name|memref
argument_list|,
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
return|;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
switch|switch
condition|(
name|fmt
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'e'
case|:
if|if
condition|(
name|memref_referenced_p
argument_list|(
name|memref
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
literal|'E'
case|:
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|memref_referenced_p
argument_list|(
name|memref
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* TRUE if some insn in the range (START, END] references a memory location    that would be affected by a store to MEMREF.  */
end_comment

begin_function
specifier|static
name|int
name|memref_used_between_p
parameter_list|(
name|memref
parameter_list|,
name|start
parameter_list|,
name|end
parameter_list|)
name|rtx
name|memref
decl_stmt|;
name|rtx
name|start
decl_stmt|;
name|rtx
name|end
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|start
argument_list|)
init|;
name|insn
operator|!=
name|NEXT_INSN
argument_list|(
name|end
argument_list|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
operator|&&
name|memref_referenced_p
argument_list|(
name|memref
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* INSN is a copy from SRC to DEST, both registers, and SRC does not die    in INSN.     Search forward to see if SRC dies before either it or DEST is modified,    but don't scan past the end of a basic block.  If so, we can replace SRC    with DEST and let SRC die in INSN.      This will reduce the number of registers live in that range and may enable    DEST to be tied to SRC, thus often saving one register in addition to a    register-register copy.  */
end_comment

begin_function
specifier|static
name|void
name|optimize_reg_copy_1
parameter_list|(
name|insn
parameter_list|,
name|dest
parameter_list|,
name|src
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|dest
decl_stmt|;
name|rtx
name|src
decl_stmt|;
block|{
name|rtx
name|p
decl_stmt|,
name|q
decl_stmt|;
name|rtx
name|note
decl_stmt|;
name|rtx
name|dest_death
init|=
literal|0
decl_stmt|;
name|int
name|sregno
init|=
name|REGNO
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|int
name|dregno
init|=
name|REGNO
argument_list|(
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
name|sregno
operator|==
name|dregno
ifdef|#
directive|ifdef
name|SMALL_REGISTER_CLASSES
comment|/* We don't want to mess with hard regs if register classes are small. */
operator|||
name|sregno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|||
name|dregno
operator|<
name|FIRST_PSEUDO_REGISTER
endif|#
directive|endif
comment|/* We don't see all updates to SP if they are in an auto-inc memory 	 reference, so we must disallow this optimization on them.  */
operator|||
name|sregno
operator|==
name|STACK_POINTER_REGNUM
operator|||
name|dregno
operator|==
name|STACK_POINTER_REGNUM
condition|)
return|return;
for|for
control|(
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
init|;
name|p
condition|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CODE_LABEL
operator|||
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
operator|||
operator|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE
operator|&&
operator|(
name|NOTE_LINE_NUMBER
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE_INSN_LOOP_END
operator|)
operator|)
condition|)
break|break;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
argument_list|)
operator|!=
literal|'i'
condition|)
continue|continue;
if|if
condition|(
name|reg_set_p
argument_list|(
name|src
argument_list|,
name|p
argument_list|)
operator|||
name|reg_set_p
argument_list|(
name|dest
argument_list|,
name|p
argument_list|)
comment|/* Don't change a USE of a register.  */
operator|||
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
name|USE
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|src
argument_list|,
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
break|break;
comment|/* See if all of SRC dies in P.  This test is slightly more 	 conservative than it needs to be. */
if|if
condition|(
operator|(
name|note
operator|=
name|find_regno_note
argument_list|(
name|p
argument_list|,
name|REG_DEAD
argument_list|,
name|sregno
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|src
argument_list|)
condition|)
block|{
name|int
name|failed
init|=
literal|0
decl_stmt|;
name|int
name|length
init|=
literal|0
decl_stmt|;
name|int
name|d_length
init|=
literal|0
decl_stmt|;
name|int
name|n_calls
init|=
literal|0
decl_stmt|;
name|int
name|d_n_calls
init|=
literal|0
decl_stmt|;
comment|/* We can do the optimization.  Scan forward from INSN again, 	     replacing regs as we go.  Set FAILED if a replacement can't 	     be done.  In that case, we can't move the death note for SRC. 	     This should be rare.  */
comment|/* Set to stop at next insn.  */
for|for
control|(
name|q
operator|=
name|next_real_insn
argument_list|(
name|insn
argument_list|)
init|;
name|q
operator|!=
name|next_real_insn
argument_list|(
name|p
argument_list|)
condition|;
name|q
operator|=
name|next_real_insn
argument_list|(
name|q
argument_list|)
control|)
block|{
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|src
argument_list|,
name|PATTERN
argument_list|(
name|q
argument_list|)
argument_list|)
condition|)
block|{
comment|/* If SRC is a hard register, we might miss some 		     overlapping registers with validate_replace_rtx, 		     so we would have to undo it.  We can't if DEST is 		     present in the insn, so fail in that combination 		     of cases.  */
if|if
condition|(
name|sregno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|reg_mentioned_p
argument_list|(
name|dest
argument_list|,
name|PATTERN
argument_list|(
name|q
argument_list|)
argument_list|)
condition|)
name|failed
operator|=
literal|1
expr_stmt|;
comment|/* Replace all uses and make sure that the register 		     isn't still present.  */
elseif|else
if|if
condition|(
name|validate_replace_rtx
argument_list|(
name|src
argument_list|,
name|dest
argument_list|,
name|q
argument_list|)
operator|&&
operator|(
name|sregno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
operator|!
name|reg_overlap_mentioned_p
argument_list|(
name|src
argument_list|,
name|PATTERN
argument_list|(
name|q
argument_list|)
argument_list|)
operator|)
condition|)
block|{
comment|/* We assume that a register is used exactly once per 			 insn in the updates below.  If this is not correct, 			 no great harm is done.  */
if|if
condition|(
name|sregno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|reg_n_refs
index|[
name|sregno
index|]
operator|-=
name|loop_depth
expr_stmt|;
if|if
condition|(
name|dregno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|reg_n_refs
index|[
name|dregno
index|]
operator|+=
name|loop_depth
expr_stmt|;
block|}
else|else
block|{
name|validate_replace_rtx
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|failed
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Count the insns and CALL_INSNs passed.  If we passed the 		 death note of DEST, show increased live length.  */
name|length
operator|++
expr_stmt|;
if|if
condition|(
name|dest_death
condition|)
name|d_length
operator|++
expr_stmt|;
comment|/* If the insn in which SRC dies is a CALL_INSN, don't count it 		 as a call that has been crossed.  Otherwise, count it.  */
if|if
condition|(
name|q
operator|!=
name|p
operator|&&
name|GET_CODE
argument_list|(
name|q
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|n_calls
operator|++
expr_stmt|;
if|if
condition|(
name|dest_death
condition|)
name|d_n_calls
operator|++
expr_stmt|;
block|}
comment|/* If DEST dies here, remove the death note and save it for 		 later.  Make sure ALL of DEST dies here; again, this is 		 overly conservative.  */
if|if
condition|(
name|dest_death
operator|==
literal|0
operator|&&
operator|(
name|dest_death
operator|=
name|find_regno_note
argument_list|(
name|q
argument_list|,
name|REG_DEAD
argument_list|,
name|dregno
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|dest_death
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|dest
argument_list|)
condition|)
name|remove_note
argument_list|(
name|q
argument_list|,
name|dest_death
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|failed
condition|)
block|{
if|if
condition|(
name|sregno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|reg_live_length
index|[
name|sregno
index|]
operator|-=
name|length
expr_stmt|;
comment|/* reg_live_length is only an approximation after combine 		     if sched is not run, so make sure that we still have 		     a reasonable value.  */
if|if
condition|(
name|reg_live_length
index|[
name|sregno
index|]
operator|<
literal|2
condition|)
name|reg_live_length
index|[
name|sregno
index|]
operator|=
literal|2
expr_stmt|;
name|reg_n_calls_crossed
index|[
name|sregno
index|]
operator|-=
name|n_calls
expr_stmt|;
block|}
if|if
condition|(
name|dregno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|reg_live_length
index|[
name|dregno
index|]
operator|+=
name|d_length
expr_stmt|;
name|reg_n_calls_crossed
index|[
name|dregno
index|]
operator|+=
name|d_n_calls
expr_stmt|;
block|}
comment|/* Move death note of SRC from P to INSN.  */
name|remove_note
argument_list|(
name|p
argument_list|,
name|note
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|note
expr_stmt|;
block|}
comment|/* Put death note of DEST on P if we saw it die.  */
if|if
condition|(
name|dest_death
condition|)
block|{
name|XEXP
argument_list|(
name|dest_death
argument_list|,
literal|1
argument_list|)
operator|=
name|REG_NOTES
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|p
argument_list|)
operator|=
name|dest_death
expr_stmt|;
block|}
return|return;
block|}
comment|/* If SRC is a hard register which is set or killed in some other 	 way, we can't do this optimization.  */
elseif|else
if|if
condition|(
name|sregno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|dead_or_set_p
argument_list|(
name|p
argument_list|,
name|src
argument_list|)
condition|)
break|break;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* INSN is a copy of SRC to DEST, in which SRC dies.  See if we now have    a sequence of insns that modify DEST followed by an insn that sets    SRC to DEST in which DEST dies, with no prior modification of DEST.    (There is no need to check if the insns in between actually modify    DEST.  We should not have cases where DEST is not modified, but    the optimization is safe if no such modification is detected.)    In that case, we can replace all uses of DEST, starting with INSN and    ending with the set of SRC to DEST, with SRC.  We do not do this    optimization if a CALL_INSN is crossed unless SRC already crosses a    call.     It is assumed that DEST and SRC are pseudos; it is too complicated to do    this for hard registers since the substitutions we may make might fail.  */
end_comment

begin_function
specifier|static
name|void
name|optimize_reg_copy_2
parameter_list|(
name|insn
parameter_list|,
name|dest
parameter_list|,
name|src
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|dest
decl_stmt|;
name|rtx
name|src
decl_stmt|;
block|{
name|rtx
name|p
decl_stmt|,
name|q
decl_stmt|;
name|rtx
name|set
decl_stmt|;
name|int
name|sregno
init|=
name|REGNO
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|int
name|dregno
init|=
name|REGNO
argument_list|(
name|dest
argument_list|)
decl_stmt|;
for|for
control|(
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
init|;
name|p
condition|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CODE_LABEL
operator|||
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
operator|||
operator|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE
operator|&&
operator|(
name|NOTE_LINE_NUMBER
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE_INSN_LOOP_END
operator|)
operator|)
condition|)
break|break;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
argument_list|)
operator|!=
literal|'i'
condition|)
continue|continue;
name|set
operator|=
name|single_set
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
operator|&&
name|SET_SRC
argument_list|(
name|set
argument_list|)
operator|==
name|dest
operator|&&
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|==
name|src
operator|&&
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_DEAD
argument_list|,
name|dest
argument_list|)
condition|)
block|{
comment|/* We can do the optimization.  Scan forward from INSN again, 	     replacing regs as we go.  */
comment|/* Set to stop at next insn.  */
for|for
control|(
name|q
operator|=
name|insn
init|;
name|q
operator|!=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
condition|;
name|q
operator|=
name|NEXT_INSN
argument_list|(
name|q
argument_list|)
control|)
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|q
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
block|{
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|dest
argument_list|,
name|PATTERN
argument_list|(
name|q
argument_list|)
argument_list|)
condition|)
block|{
name|PATTERN
argument_list|(
name|q
argument_list|)
operator|=
name|replace_rtx
argument_list|(
name|PATTERN
argument_list|(
name|q
argument_list|)
argument_list|,
name|dest
argument_list|,
name|src
argument_list|)
expr_stmt|;
comment|/* We assume that a register is used exactly once per 		       insn in the updates below.  If this is not correct, 		       no great harm is done.  */
name|reg_n_refs
index|[
name|dregno
index|]
operator|-=
name|loop_depth
expr_stmt|;
name|reg_n_refs
index|[
name|sregno
index|]
operator|+=
name|loop_depth
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|q
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|reg_n_calls_crossed
index|[
name|dregno
index|]
operator|--
expr_stmt|;
name|reg_n_calls_crossed
index|[
name|sregno
index|]
operator|++
expr_stmt|;
block|}
block|}
name|remove_note
argument_list|(
name|p
argument_list|,
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_DEAD
argument_list|,
name|dest
argument_list|)
argument_list|)
expr_stmt|;
name|reg_n_deaths
index|[
name|dregno
index|]
operator|--
expr_stmt|;
name|remove_note
argument_list|(
name|insn
argument_list|,
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|src
argument_list|)
argument_list|)
expr_stmt|;
name|reg_n_deaths
index|[
name|sregno
index|]
operator|--
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|reg_set_p
argument_list|(
name|src
argument_list|,
name|p
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CALL_INSN
operator|&&
name|reg_n_calls_crossed
index|[
name|sregno
index|]
operator|==
literal|0
operator|)
condition|)
break|break;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find registers that are equivalent to a single value throughout the    compilation (either because they can be referenced in memory or are set once    from a single constant).  Lower their priority for a register.     If such a register is only referenced once, try substituting its value    into the using insn.  If it succeeds, we can eliminate the register    completely.  */
end_comment

begin_function
specifier|static
name|void
name|update_equiv_regs
parameter_list|()
block|{
name|rtx
modifier|*
name|reg_equiv_init_insn
init|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|rtx
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
modifier|*
name|reg_equiv_replacement
init|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|rtx
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reg_equiv_init_insn
argument_list|,
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|rtx
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reg_equiv_replacement
argument_list|,
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|rtx
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|init_alias_analysis
argument_list|()
expr_stmt|;
name|loop_depth
operator|=
literal|1
expr_stmt|;
comment|/* Scan the insns and find which registers have equivalences.  Do this      in a separate scan of the insns because (due to -fcse-follow-jumps)      a register can be set below its use.  */
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|rtx
name|note
decl_stmt|;
name|rtx
name|set
init|=
name|single_set
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|dest
decl_stmt|;
name|int
name|regno
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
block|{
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
condition|)
name|loop_depth
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_END
condition|)
name|loop_depth
operator|--
expr_stmt|;
block|}
comment|/* If this insn contains more (or less) than a single SET, ignore it.  */
if|if
condition|(
name|set
operator|==
literal|0
condition|)
continue|continue;
name|dest
operator|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
expr_stmt|;
comment|/* If this sets a MEM to the contents of a REG that is only used 	 in a single basic block, see if the register is always equivalent 	 to that memory location and if moving the store from INSN to the 	 insn that set REG is safe.  If so, put a REG_EQUIV note on the 	 initializing insn.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|regno
operator|=
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|reg_basic_block
index|[
name|regno
index|]
operator|>=
literal|0
operator|&&
name|reg_equiv_init_insn
index|[
name|regno
index|]
operator|!=
literal|0
operator|&&
name|validate_equiv_mem
argument_list|(
name|reg_equiv_init_insn
index|[
name|regno
index|]
argument_list|,
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|dest
argument_list|)
operator|&&
operator|!
name|memref_used_between_p
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|reg_equiv_init_insn
index|[
name|regno
index|]
argument_list|,
name|insn
argument_list|)
condition|)
name|REG_NOTES
argument_list|(
name|reg_equiv_init_insn
index|[
name|regno
index|]
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|REG_EQUIV
argument_list|,
name|dest
argument_list|,
name|REG_NOTES
argument_list|(
name|reg_equiv_init_insn
index|[
name|regno
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this is a register-register copy where SRC is not dead, see if we 	 can optimize it.  */
if|if
condition|(
name|flag_expensive_optimizations
operator|&&
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|!
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
condition|)
name|optimize_reg_copy_1
argument_list|(
name|insn
argument_list|,
name|dest
argument_list|,
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Similarly for a pseudo-pseudo copy when SRC is dead.  */
elseif|else
if|if
condition|(
name|flag_expensive_optimizations
operator|&&
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|dest
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
condition|)
name|optimize_reg_copy_2
argument_list|(
name|insn
argument_list|,
name|dest
argument_list|,
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Otherwise, we only handle the case of a pseudo register being set 	 once.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|!=
name|REG
operator|||
operator|(
name|regno
operator|=
name|REGNO
argument_list|(
name|dest
argument_list|)
operator|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|||
name|reg_n_sets
index|[
name|regno
index|]
operator|!=
literal|1
condition|)
continue|continue;
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
comment|/* Record this insn as initializing this register.  */
name|reg_equiv_init_insn
index|[
name|regno
index|]
operator|=
name|insn
expr_stmt|;
comment|/* If this register is known to be equal to a constant, record that 	 it is always equivalent to the constant.  */
if|if
condition|(
name|note
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|PUT_MODE
argument_list|(
name|note
argument_list|,
operator|(
expr|enum
name|machine_mode
operator|)
name|REG_EQUIV
argument_list|)
expr_stmt|;
comment|/* If this insn introduces a "constant" register, decrease the priority 	 of that register.  Record this insn if the register is only used once 	 more and the equivalence value is the same as our source.  	 The latter condition is checked for two reasons:  First, it is an 	 indication that it may be more efficient to actually emit the insn 	 as written (if no registers are available, reload will substitute 	 the equivalence).  Secondly, it avoids problems with any registers 	 dying in this insn whose death notes would be missed.  	 If we don't have a REG_EQUIV note, see if this insn is loading 	 a register used only in one basic block from a MEM.  If so, and the 	 MEM remains unchanged for the life of the register, add a REG_EQUIV 	 note.  */
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EQUIV
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|note
operator|==
literal|0
operator|&&
name|reg_basic_block
index|[
name|regno
index|]
operator|>=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|validate_equiv_mem
argument_list|(
name|insn
argument_list|,
name|dest
argument_list|,
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
condition|)
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|note
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|REG_EQUIV
argument_list|,
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Don't mess with things live during setjmp.  */
if|if
condition|(
name|note
operator|&&
name|reg_live_length
index|[
name|regno
index|]
operator|>=
literal|0
condition|)
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|dest
argument_list|)
decl_stmt|;
comment|/* Note that the statement below does not affect the priority 	     in local-alloc!  */
name|reg_live_length
index|[
name|regno
index|]
operator|*=
literal|2
expr_stmt|;
comment|/* If the register is referenced exactly twice, meaning it is set 	     once and used once, indicate that the reference may be replaced 	     by the equivalence we computed above.  If the register is only 	     used in one basic block, this can't succeed or combine would 	     have done it.  	     It would be nice to use "loop_depth * 2" in the compare 	     below.  Unfortunately, LOOP_DEPTH need not be constant within 	     a basic block so this would be too complicated.  	     This case normally occurs when a parameter is read from memory 	     and then used exactly once, not in a loop.  */
if|if
condition|(
name|reg_n_refs
index|[
name|regno
index|]
operator|==
literal|2
operator|&&
name|reg_basic_block
index|[
name|regno
index|]
operator|<
literal|0
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
condition|)
name|reg_equiv_replacement
index|[
name|regno
index|]
operator|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now scan all regs killed in an insn to see if any of them are registers      only used that once.  If so, see if we can replace the reference with      the equivalent from.  If we can, delete the initializing reference      and this register will go away.  */
for|for
control|(
name|insn
operator|=
name|next_active_insn
argument_list|(
name|get_insns
argument_list|()
argument_list|)
init|;
name|insn
condition|;
name|insn
operator|=
name|next_active_insn
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|rtx
name|link
decl_stmt|;
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_DEAD
comment|/* Make sure this insn still refers to the register.  */
operator|&&
name|reg_mentioned_p
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|reg_equiv_replacement
index|[
name|regno
index|]
operator|&&
name|validate_replace_rtx
argument_list|(
name|regno_reg_rtx
index|[
name|regno
index|]
argument_list|,
name|reg_equiv_replacement
index|[
name|regno
index|]
argument_list|,
name|insn
argument_list|)
condition|)
block|{
name|rtx
name|equiv_insn
init|=
name|reg_equiv_init_insn
index|[
name|regno
index|]
decl_stmt|;
name|remove_death
argument_list|(
name|regno
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|reg_n_refs
index|[
name|regno
index|]
operator|=
literal|0
expr_stmt|;
name|PUT_CODE
argument_list|(
name|equiv_insn
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|equiv_insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|equiv_insn
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Allocate hard regs to the pseudo regs used only within block number B.    Only the pseudos that die but once can be handled.  */
end_comment

begin_function
specifier|static
name|void
name|block_alloc
parameter_list|(
name|b
parameter_list|)
name|int
name|b
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|q
decl_stmt|;
specifier|register
name|rtx
name|insn
decl_stmt|;
name|rtx
name|note
decl_stmt|;
name|int
name|insn_number
init|=
literal|0
decl_stmt|;
name|int
name|insn_count
init|=
literal|0
decl_stmt|;
name|int
name|max_uid
init|=
name|get_max_uid
argument_list|()
decl_stmt|;
name|int
modifier|*
name|qty_order
decl_stmt|;
name|int
name|no_conflict_combined_regno
init|=
operator|-
literal|1
decl_stmt|;
comment|/* Counter to prevent allocating more SCRATCHes than can be stored      in SCRATCH_LIST.  */
name|int
name|scratches_allocated
init|=
name|scratch_index
decl_stmt|;
comment|/* Count the instructions in the basic block.  */
name|insn
operator|=
name|basic_block_end
index|[
name|b
index|]
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
condition|)
if|if
condition|(
operator|++
name|insn_count
operator|>
name|max_uid
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|basic_block_head
index|[
name|b
index|]
condition|)
break|break;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* +2 to leave room for a post_mark_life at the last insn and for      the birth of a CLOBBER in the first insn.  */
name|regs_live_at
operator|=
operator|(
name|HARD_REG_SET
operator|*
operator|)
name|alloca
argument_list|(
operator|(
literal|2
operator|*
name|insn_count
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|HARD_REG_SET
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|regs_live_at
argument_list|,
operator|(
literal|2
operator|*
name|insn_count
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|HARD_REG_SET
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize table of hardware registers currently live.  */
ifdef|#
directive|ifdef
name|HARD_REG_SET
name|regs_live
operator|=
operator|*
name|basic_block_live_at_start
index|[
name|b
index|]
expr_stmt|;
else|#
directive|else
name|COPY_HARD_REG_SET
argument_list|(
name|regs_live
argument_list|,
name|basic_block_live_at_start
index|[
name|b
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* This loop scans the instructions of the basic block      and assigns quantities to registers.      It computes which registers to tie.  */
name|insn
operator|=
name|basic_block_head
index|[
name|b
index|]
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
specifier|register
name|rtx
name|body
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
condition|)
name|insn_number
operator|++
expr_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
block|{
specifier|register
name|rtx
name|link
decl_stmt|,
name|set
decl_stmt|;
specifier|register
name|int
name|win
init|=
literal|0
decl_stmt|;
specifier|register
name|rtx
name|r0
decl_stmt|,
name|r1
decl_stmt|;
name|int
name|combined_regno
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|insn_code_number
init|=
name|recog_memoized
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|this_insn_number
operator|=
name|insn_number
expr_stmt|;
name|this_insn
operator|=
name|insn
expr_stmt|;
if|if
condition|(
name|insn_code_number
operator|>=
literal|0
condition|)
name|insn_extract
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|which_alternative
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Is this insn suitable for tying two registers? 	     If so, try doing that. 	     Suitable insns are those with at least two operands and where 	     operand 0 is an output that is a register that is not 	     earlyclobber.  	     We can tie operand 0 with some operand that dies in this insn. 	     First look for operands that are required to be in the same 	     register as operand 0.  If we find such, only try tying that 	     operand or one that can be put into that operand if the 	     operation is commutative.  If we don't find an operand 	     that is required to be in the same register as operand 0, 	     we can tie with any operand.  	     Subregs in place of regs are also ok.  	     If tying is done, WIN is set nonzero.  */
if|if
condition|(
name|insn_code_number
operator|>=
literal|0
ifdef|#
directive|ifdef
name|REGISTER_CONSTRAINTS
operator|&&
name|insn_n_operands
index|[
name|insn_code_number
index|]
operator|>
literal|1
operator|&&
name|insn_operand_constraint
index|[
name|insn_code_number
index|]
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
literal|'='
operator|&&
name|insn_operand_constraint
index|[
name|insn_code_number
index|]
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|!=
literal|'&'
else|#
directive|else
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|rtx_equal_p
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
name|recog_operand
index|[
literal|0
index|]
argument_list|)
endif|#
directive|endif
condition|)
block|{
ifdef|#
directive|ifdef
name|REGISTER_CONSTRAINTS
comment|/* If non-negative, is an operand that must match operand 0.  */
name|int
name|must_match_0
init|=
operator|-
literal|1
decl_stmt|;
comment|/* Counts number of alternatives that require a match with 		 operand 0.  */
name|int
name|n_matching_alts
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|insn_n_operands
index|[
name|insn_code_number
index|]
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|p
init|=
name|insn_operand_constraint
index|[
name|insn_code_number
index|]
index|[
name|i
index|]
decl_stmt|;
name|int
name|this_match
init|=
operator|(
name|requires_inout
argument_list|(
name|p
argument_list|)
operator|)
decl_stmt|;
name|n_matching_alts
operator|+=
name|this_match
expr_stmt|;
if|if
condition|(
name|this_match
operator|==
name|insn_n_alternatives
index|[
name|insn_code_number
index|]
condition|)
name|must_match_0
operator|=
name|i
expr_stmt|;
block|}
endif|#
directive|endif
name|r0
operator|=
name|recog_operand
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|insn_n_operands
index|[
name|insn_code_number
index|]
condition|;
name|i
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|REGISTER_CONSTRAINTS
comment|/* Skip this operand if we found an operand that 		     must match operand 0 and this operand isn't it 		     and can't be made to be it by commutativity.  */
if|if
condition|(
name|must_match_0
operator|>=
literal|0
operator|&&
name|i
operator|!=
name|must_match_0
operator|&&
operator|!
operator|(
name|i
operator|==
name|must_match_0
operator|+
literal|1
operator|&&
name|insn_operand_constraint
index|[
name|insn_code_number
index|]
index|[
name|i
operator|-
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'%'
operator|)
operator|&&
operator|!
operator|(
name|i
operator|==
name|must_match_0
operator|-
literal|1
operator|&&
name|insn_operand_constraint
index|[
name|insn_code_number
index|]
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'%'
operator|)
condition|)
continue|continue;
comment|/* Likewise if each alternative has some operand that 		     must match operand zero.  In that case, skip any  		     operand that doesn't list operand 0 since we know that 		     the operand always conflicts with operand 0.  We 		     ignore commutatity in this case to keep things simple.  */
if|if
condition|(
name|n_matching_alts
operator|==
name|insn_n_alternatives
index|[
name|insn_code_number
index|]
operator|&&
operator|(
literal|0
operator|==
name|requires_inout
argument_list|(
name|insn_operand_constraint
index|[
name|insn_code_number
index|]
index|[
name|i
index|]
argument_list|)
operator|)
condition|)
continue|continue;
endif|#
directive|endif
name|r1
operator|=
name|recog_operand
index|[
name|i
index|]
expr_stmt|;
comment|/* If the operand is an address, find a register in it. 		     There may be more than one register, but we only try one 		     of them.  */
if|if
condition|(
ifdef|#
directive|ifdef
name|REGISTER_CONSTRAINTS
name|insn_operand_constraint
index|[
name|insn_code_number
index|]
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'p'
else|#
directive|else
name|insn_operand_address_p
index|[
name|insn_code_number
index|]
index|[
name|i
index|]
endif|#
directive|endif
condition|)
while|while
condition|(
name|GET_CODE
argument_list|(
name|r1
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|r1
argument_list|)
operator|==
name|MULT
condition|)
name|r1
operator|=
name|XEXP
argument_list|(
name|r1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|r0
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|r0
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
comment|/* We have two priorities for hard register preferences. 			 If we have a move insn or an insn whose first input 			 can only be in the same register as the output, give 			 priority to an equivalence found from that insn.  */
name|int
name|may_save_copy
init|=
operator|(
operator|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
operator|==
name|r0
operator|&&
name|SET_SRC
argument_list|(
name|body
argument_list|)
operator|==
name|r1
operator|)
ifdef|#
directive|ifdef
name|REGISTER_CONSTRAINTS
operator|||
operator|(
name|r1
operator|==
name|recog_operand
index|[
name|i
index|]
operator|&&
name|must_match_0
operator|>=
literal|0
operator|)
endif|#
directive|endif
operator|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|r1
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|r1
argument_list|)
operator|==
name|SUBREG
condition|)
name|win
operator|=
name|combine_regs
argument_list|(
name|r1
argument_list|,
name|r0
argument_list|,
name|may_save_copy
argument_list|,
name|insn_number
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Recognize an insn sequence with an ultimate result 	     which can safely overlap one of the inputs. 	     The sequence begins with a CLOBBER of its result, 	     and ends with an insn that copies the result to itself 	     and has a REG_EQUAL note for an equivalent formula. 	     That note indicates what the inputs are. 	     The result and the input can overlap if each insn in 	     the sequence either doesn't mention the input 	     or has a REG_NO_CONFLICT note to inhibit the conflict.  	     We do the combining test at the CLOBBER so that the 	     destination register won't have had a quantity number 	     assigned, since that would prevent combining.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
operator|&&
operator|(
name|r0
operator|=
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|,
name|GET_CODE
argument_list|(
name|r0
argument_list|)
operator|==
name|REG
operator|)
operator|&&
operator|(
name|link
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_LIBCALL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|INSN
operator|&&
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|==
name|r0
operator|&&
name|SET_SRC
argument_list|(
name|set
argument_list|)
operator|==
name|r0
operator|&&
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|r1
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
operator|,
name|GET_CODE
argument_list|(
name|r1
argument_list|)
operator|==
name|REG
comment|/* Check that we have such a sequence.  */
operator|&&
name|no_conflict_p
argument_list|(
name|insn
argument_list|,
name|r0
argument_list|,
name|r1
argument_list|)
condition|)
name|win
operator|=
name|combine_regs
argument_list|(
name|r1
argument_list|,
name|r0
argument_list|,
literal|1
argument_list|,
name|insn_number
argument_list|,
name|insn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'e'
operator|&&
operator|(
name|r1
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|,
name|GET_CODE
argument_list|(
name|r1
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|r1
argument_list|)
operator|==
name|SUBREG
operator|)
operator|&&
name|no_conflict_p
argument_list|(
name|insn
argument_list|,
name|r0
argument_list|,
name|r1
argument_list|)
condition|)
name|win
operator|=
name|combine_regs
argument_list|(
name|r1
argument_list|,
name|r0
argument_list|,
literal|0
argument_list|,
name|insn_number
argument_list|,
name|insn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Here we care if the operation to be computed is 		 commutative.  */
elseif|else
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|EQ
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|NE
operator|||
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'c'
operator|)
operator|&&
operator|(
name|r1
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|,
operator|(
name|GET_CODE
argument_list|(
name|r1
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|r1
argument_list|)
operator|==
name|SUBREG
operator|)
operator|)
operator|&&
name|no_conflict_p
argument_list|(
name|insn
argument_list|,
name|r0
argument_list|,
name|r1
argument_list|)
condition|)
name|win
operator|=
name|combine_regs
argument_list|(
name|r1
argument_list|,
name|r0
argument_list|,
literal|0
argument_list|,
name|insn_number
argument_list|,
name|insn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* If we did combine something, show the register number 		 in question so that we know to ignore its death.  */
if|if
condition|(
name|win
condition|)
name|no_conflict_combined_regno
operator|=
name|REGNO
argument_list|(
name|r1
argument_list|)
expr_stmt|;
block|}
comment|/* If registers were just tied, set COMBINED_REGNO 	     to the number of the register used in this insn 	     that was tied to the register set in this insn. 	     This register's qty should not be "killed".  */
if|if
condition|(
name|win
condition|)
block|{
while|while
condition|(
name|GET_CODE
argument_list|(
name|r1
argument_list|)
operator|==
name|SUBREG
condition|)
name|r1
operator|=
name|SUBREG_REG
argument_list|(
name|r1
argument_list|)
expr_stmt|;
name|combined_regno
operator|=
name|REGNO
argument_list|(
name|r1
argument_list|)
expr_stmt|;
block|}
comment|/* Mark the death of everything that dies in this instruction, 	     except for anything that was just combined.  */
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_DEAD
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|combined_regno
operator|!=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|(
name|no_conflict_combined_regno
operator|!=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
operator|!
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_NO_CONFLICT
argument_list|,
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
name|wipe_dead_reg
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Allocate qty numbers for all registers local to this block 	     that are born (set) in this instruction. 	     A pseudo that already has a qty is not changed.  */
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|reg_is_set
argument_list|)
expr_stmt|;
comment|/* If anything is set in this insn and then unused, mark it as dying 	     after this insn, so it will conflict with our outputs.  This 	     can't match with something that combined, and it doesn't matter 	     if it did.  Do this after the calls to reg_is_set since these 	     die after, not during, the current insn.  */
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_UNUSED
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|wipe_dead_reg
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Allocate quantities for any SCRATCH operands of this insn.  */
if|if
condition|(
name|insn_code_number
operator|>=
literal|0
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|insn_n_operands
index|[
name|insn_code_number
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
operator|==
name|SCRATCH
operator|&&
name|scratches_allocated
operator|++
operator|<
name|scratch_list_length
condition|)
name|alloc_qty_for_scratch
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|,
name|i
argument_list|,
name|insn
argument_list|,
name|insn_code_number
argument_list|,
name|insn_number
argument_list|)
expr_stmt|;
comment|/* If this is an insn that has a REG_RETVAL note pointing at a  	     CLOBBER insn, we have reached the end of a REG_NO_CONFLICT 	     block, so clear any register number that combined within it.  */
if|if
condition|(
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
name|no_conflict_combined_regno
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Set the registers live after INSN_NUMBER.  Note that we never 	 record the registers live before the block's first insn, since no 	 pseudos we care about are live before that insn.  */
name|IOR_HARD_REG_SET
argument_list|(
name|regs_live_at
index|[
literal|2
operator|*
name|insn_number
index|]
argument_list|,
name|regs_live
argument_list|)
expr_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
name|regs_live_at
index|[
literal|2
operator|*
name|insn_number
operator|+
literal|1
index|]
argument_list|,
name|regs_live
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|basic_block_end
index|[
name|b
index|]
condition|)
break|break;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* Now every register that is local to this basic block      should have been given a quantity, or else -1 meaning ignore it.      Every quantity should have a known birth and death.         Order the qtys so we assign them registers in order of the      number of suggested registers they need so we allocate those with      the most restrictive needs first.  */
name|qty_order
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|next_qty
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|next_qty
condition|;
name|i
operator|++
control|)
name|qty_order
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
define|#
directive|define
name|EXCHANGE
parameter_list|(
name|I1
parameter_list|,
name|I2
parameter_list|)
define|\
value|{ i = qty_order[I1]; qty_order[I1] = qty_order[I2]; qty_order[I2] = i; }
switch|switch
condition|(
name|next_qty
condition|)
block|{
case|case
literal|3
case|:
comment|/* Make qty_order[2] be the one to allocate last.  */
if|if
condition|(
name|qty_sugg_compare
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
operator|>
literal|0
condition|)
name|EXCHANGE
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|qty_sugg_compare
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
operator|>
literal|0
condition|)
name|EXCHANGE
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* ... Fall through ... */
case|case
literal|2
case|:
comment|/* Put the best one to allocate in qty_order[0].  */
if|if
condition|(
name|qty_sugg_compare
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
operator|>
literal|0
condition|)
name|EXCHANGE
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* ... Fall through ... */
case|case
literal|1
case|:
case|case
literal|0
case|:
comment|/* Nothing to do here.  */
break|break;
default|default:
name|qsort
argument_list|(
name|qty_order
argument_list|,
name|next_qty
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|qty_sugg_compare_1
argument_list|)
expr_stmt|;
block|}
comment|/* Try to put each quantity in a suggested physical register, if it has one.      This may cause registers to be allocated that otherwise wouldn't be, but      this seems acceptable in local allocation (unlike global allocation).  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|next_qty
condition|;
name|i
operator|++
control|)
block|{
name|q
operator|=
name|qty_order
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|qty_phys_num_sugg
index|[
name|q
index|]
operator|!=
literal|0
operator|||
name|qty_phys_num_copy_sugg
index|[
name|q
index|]
operator|!=
literal|0
condition|)
name|qty_phys_reg
index|[
name|q
index|]
operator|=
name|find_free_reg
argument_list|(
name|qty_min_class
index|[
name|q
index|]
argument_list|,
name|qty_mode
index|[
name|q
index|]
argument_list|,
name|q
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|qty_birth
index|[
name|q
index|]
argument_list|,
name|qty_death
index|[
name|q
index|]
argument_list|)
expr_stmt|;
else|else
name|qty_phys_reg
index|[
name|q
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Order the qtys so we assign them registers in order of       decreasing length of life.  Normally call qsort, but if we       have only a very small number of quantities, sort them ourselves.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|next_qty
condition|;
name|i
operator|++
control|)
name|qty_order
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
define|#
directive|define
name|EXCHANGE
parameter_list|(
name|I1
parameter_list|,
name|I2
parameter_list|)
define|\
value|{ i = qty_order[I1]; qty_order[I1] = qty_order[I2]; qty_order[I2] = i; }
switch|switch
condition|(
name|next_qty
condition|)
block|{
case|case
literal|3
case|:
comment|/* Make qty_order[2] be the one to allocate last.  */
if|if
condition|(
name|qty_compare
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
operator|>
literal|0
condition|)
name|EXCHANGE
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|qty_compare
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
operator|>
literal|0
condition|)
name|EXCHANGE
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* ... Fall through ... */
case|case
literal|2
case|:
comment|/* Put the best one to allocate in qty_order[0].  */
if|if
condition|(
name|qty_compare
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
operator|>
literal|0
condition|)
name|EXCHANGE
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* ... Fall through ... */
case|case
literal|1
case|:
case|case
literal|0
case|:
comment|/* Nothing to do here.  */
break|break;
default|default:
name|qsort
argument_list|(
name|qty_order
argument_list|,
name|next_qty
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|qty_compare_1
argument_list|)
expr_stmt|;
block|}
comment|/* Now for each qty that is not a hardware register,      look for a hardware register to put it in.      First try the register class that is cheapest for this qty,      if there is more than one class.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|next_qty
condition|;
name|i
operator|++
control|)
block|{
name|q
operator|=
name|qty_order
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|qty_phys_reg
index|[
name|q
index|]
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|N_REG_CLASSES
operator|>
literal|1
condition|)
block|{
name|qty_phys_reg
index|[
name|q
index|]
operator|=
name|find_free_reg
argument_list|(
name|qty_min_class
index|[
name|q
index|]
argument_list|,
name|qty_mode
index|[
name|q
index|]
argument_list|,
name|q
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|qty_birth
index|[
name|q
index|]
argument_list|,
name|qty_death
index|[
name|q
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|qty_phys_reg
index|[
name|q
index|]
operator|>=
literal|0
condition|)
continue|continue;
block|}
if|if
condition|(
name|qty_alternate_class
index|[
name|q
index|]
operator|!=
name|NO_REGS
condition|)
name|qty_phys_reg
index|[
name|q
index|]
operator|=
name|find_free_reg
argument_list|(
name|qty_alternate_class
index|[
name|q
index|]
argument_list|,
name|qty_mode
index|[
name|q
index|]
argument_list|,
name|q
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|qty_birth
index|[
name|q
index|]
argument_list|,
name|qty_death
index|[
name|q
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now propagate the register assignments      to the pseudo regs belonging to the qtys.  */
for|for
control|(
name|q
operator|=
literal|0
init|;
name|q
operator|<
name|next_qty
condition|;
name|q
operator|++
control|)
if|if
condition|(
name|qty_phys_reg
index|[
name|q
index|]
operator|>=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
name|qty_first_reg
index|[
name|q
index|]
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|=
name|reg_next_in_qty
index|[
name|i
index|]
control|)
name|reg_renumber
index|[
name|i
index|]
operator|=
name|qty_phys_reg
index|[
name|q
index|]
operator|+
name|reg_offset
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|qty_scratch_rtx
index|[
name|q
index|]
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|qty_scratch_rtx
index|[
name|q
index|]
argument_list|)
operator|==
name|REG
condition|)
name|abort
argument_list|()
expr_stmt|;
name|PUT_CODE
argument_list|(
name|qty_scratch_rtx
index|[
name|q
index|]
argument_list|,
name|REG
argument_list|)
expr_stmt|;
name|REGNO
argument_list|(
name|qty_scratch_rtx
index|[
name|q
index|]
argument_list|)
operator|=
name|qty_phys_reg
index|[
name|q
index|]
expr_stmt|;
name|scratch_block
index|[
name|scratch_index
index|]
operator|=
name|b
expr_stmt|;
name|scratch_list
index|[
name|scratch_index
operator|++
index|]
operator|=
name|qty_scratch_rtx
index|[
name|q
index|]
expr_stmt|;
comment|/* Must clear the USED field, because it will have been set by 	       copy_rtx_if_shared, but the leaf_register code expects that 	       it is zero in all REG rtx.  copy_rtx_if_shared does not set the 	       used bit for REGs, but does for SCRATCHes.  */
name|qty_scratch_rtx
index|[
name|q
index|]
operator|->
name|used
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compare two quantities' priority for getting real registers.    We give shorter-lived quantities higher priority.    Quantities with more references are also preferred, as are quantities that    require multiple registers.  This is the identical prioritization as    done by global-alloc.     We used to give preference to registers with *longer* lives, but using    the same algorithm in both local- and global-alloc can speed up execution    of some programs by as much as a factor of three!  */
end_comment

begin_function
specifier|static
name|int
name|qty_compare
parameter_list|(
name|q1
parameter_list|,
name|q2
parameter_list|)
name|int
name|q1
decl_stmt|,
name|q2
decl_stmt|;
block|{
comment|/* Note that the quotient will never be bigger than      the value of floor_log2 times the maximum number of      times a register can occur in one insn (surely less than 100).      Multiplying this by 10000 can't overflow.  */
specifier|register
name|int
name|pri1
init|=
operator|(
operator|(
call|(
name|double
call|)
argument_list|(
name|floor_log2
argument_list|(
name|qty_n_refs
index|[
name|q1
index|]
argument_list|)
operator|*
name|qty_n_refs
index|[
name|q1
index|]
operator|*
name|qty_size
index|[
name|q1
index|]
argument_list|)
operator|/
operator|(
name|qty_death
index|[
name|q1
index|]
operator|-
name|qty_birth
index|[
name|q1
index|]
operator|)
operator|)
operator|*
literal|10000
operator|)
decl_stmt|;
specifier|register
name|int
name|pri2
init|=
operator|(
operator|(
call|(
name|double
call|)
argument_list|(
name|floor_log2
argument_list|(
name|qty_n_refs
index|[
name|q2
index|]
argument_list|)
operator|*
name|qty_n_refs
index|[
name|q2
index|]
operator|*
name|qty_size
index|[
name|q2
index|]
argument_list|)
operator|/
operator|(
name|qty_death
index|[
name|q2
index|]
operator|-
name|qty_birth
index|[
name|q2
index|]
operator|)
operator|)
operator|*
literal|10000
operator|)
decl_stmt|;
return|return
name|pri2
operator|-
name|pri1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|qty_compare_1
parameter_list|(
name|q1
parameter_list|,
name|q2
parameter_list|)
name|int
modifier|*
name|q1
decl_stmt|,
decl|*
name|q2
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|tem
decl_stmt|;
comment|/* Note that the quotient will never be bigger than      the value of floor_log2 times the maximum number of      times a register can occur in one insn (surely less than 100).      Multiplying this by 10000 can't overflow.  */
specifier|register
name|int
name|pri1
init|=
operator|(
operator|(
call|(
name|double
call|)
argument_list|(
name|floor_log2
argument_list|(
name|qty_n_refs
index|[
operator|*
name|q1
index|]
argument_list|)
operator|*
name|qty_n_refs
index|[
operator|*
name|q1
index|]
operator|*
name|qty_size
index|[
operator|*
name|q1
index|]
argument_list|)
operator|/
operator|(
name|qty_death
index|[
operator|*
name|q1
index|]
operator|-
name|qty_birth
index|[
operator|*
name|q1
index|]
operator|)
operator|)
operator|*
literal|10000
operator|)
decl_stmt|;
specifier|register
name|int
name|pri2
init|=
operator|(
operator|(
call|(
name|double
call|)
argument_list|(
name|floor_log2
argument_list|(
name|qty_n_refs
index|[
operator|*
name|q2
index|]
argument_list|)
operator|*
name|qty_n_refs
index|[
operator|*
name|q2
index|]
operator|*
name|qty_size
index|[
operator|*
name|q2
index|]
argument_list|)
operator|/
operator|(
name|qty_death
index|[
operator|*
name|q2
index|]
operator|-
name|qty_birth
index|[
operator|*
name|q2
index|]
operator|)
operator|)
operator|*
literal|10000
operator|)
decl_stmt|;
name|tem
operator|=
name|pri2
operator|-
name|pri1
expr_stmt|;
if|if
condition|(
name|tem
operator|!=
literal|0
condition|)
return|return
name|tem
return|;
comment|/* If qtys are equally good, sort by qty number,      so that the results of qsort leave nothing to chance.  */
return|return
operator|*
name|q1
operator|-
operator|*
name|q2
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Compare two quantities' priority for getting real registers.  This version    is called for quantities that have suggested hard registers.  First priority    goes to quantities that have copy preferences, then to those that have    normal preferences.  Within those groups, quantities with the lower    number of preferenes have the highest priority.  Of those, we use the same    algorithm as above.  */
end_comment

begin_function
specifier|static
name|int
name|qty_sugg_compare
parameter_list|(
name|q1
parameter_list|,
name|q2
parameter_list|)
name|int
name|q1
decl_stmt|,
name|q2
decl_stmt|;
block|{
specifier|register
name|int
name|sugg1
init|=
operator|(
name|qty_phys_num_copy_sugg
index|[
name|q1
index|]
condition|?
name|qty_phys_num_copy_sugg
index|[
name|q1
index|]
else|:
name|qty_phys_num_sugg
index|[
name|q1
index|]
operator|*
name|FIRST_PSEUDO_REGISTER
operator|)
decl_stmt|;
specifier|register
name|int
name|sugg2
init|=
operator|(
name|qty_phys_num_copy_sugg
index|[
name|q2
index|]
condition|?
name|qty_phys_num_copy_sugg
index|[
name|q2
index|]
else|:
name|qty_phys_num_sugg
index|[
name|q2
index|]
operator|*
name|FIRST_PSEUDO_REGISTER
operator|)
decl_stmt|;
comment|/* Note that the quotient will never be bigger than      the value of floor_log2 times the maximum number of      times a register can occur in one insn (surely less than 100).      Multiplying this by 10000 can't overflow.  */
specifier|register
name|int
name|pri1
init|=
operator|(
operator|(
call|(
name|double
call|)
argument_list|(
name|floor_log2
argument_list|(
name|qty_n_refs
index|[
name|q1
index|]
argument_list|)
operator|*
name|qty_n_refs
index|[
name|q1
index|]
operator|*
name|qty_size
index|[
name|q1
index|]
argument_list|)
operator|/
operator|(
name|qty_death
index|[
name|q1
index|]
operator|-
name|qty_birth
index|[
name|q1
index|]
operator|)
operator|)
operator|*
literal|10000
operator|)
decl_stmt|;
specifier|register
name|int
name|pri2
init|=
operator|(
operator|(
call|(
name|double
call|)
argument_list|(
name|floor_log2
argument_list|(
name|qty_n_refs
index|[
name|q2
index|]
argument_list|)
operator|*
name|qty_n_refs
index|[
name|q2
index|]
operator|*
name|qty_size
index|[
name|q2
index|]
argument_list|)
operator|/
operator|(
name|qty_death
index|[
name|q2
index|]
operator|-
name|qty_birth
index|[
name|q2
index|]
operator|)
operator|)
operator|*
literal|10000
operator|)
decl_stmt|;
if|if
condition|(
name|sugg1
operator|!=
name|sugg2
condition|)
return|return
name|sugg1
operator|-
name|sugg2
return|;
return|return
name|pri2
operator|-
name|pri1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|qty_sugg_compare_1
parameter_list|(
name|q1
parameter_list|,
name|q2
parameter_list|)
name|int
modifier|*
name|q1
decl_stmt|,
decl|*
name|q2
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|sugg1
init|=
operator|(
name|qty_phys_num_copy_sugg
index|[
operator|*
name|q1
index|]
condition|?
name|qty_phys_num_copy_sugg
index|[
operator|*
name|q1
index|]
else|:
name|qty_phys_num_sugg
index|[
operator|*
name|q1
index|]
operator|*
name|FIRST_PSEUDO_REGISTER
operator|)
decl_stmt|;
specifier|register
name|int
name|sugg2
init|=
operator|(
name|qty_phys_num_copy_sugg
index|[
operator|*
name|q2
index|]
condition|?
name|qty_phys_num_copy_sugg
index|[
operator|*
name|q2
index|]
else|:
name|qty_phys_num_sugg
index|[
operator|*
name|q2
index|]
operator|*
name|FIRST_PSEUDO_REGISTER
operator|)
decl_stmt|;
comment|/* Note that the quotient will never be bigger than      the value of floor_log2 times the maximum number of      times a register can occur in one insn (surely less than 100).      Multiplying this by 10000 can't overflow.  */
specifier|register
name|int
name|pri1
init|=
operator|(
operator|(
call|(
name|double
call|)
argument_list|(
name|floor_log2
argument_list|(
name|qty_n_refs
index|[
operator|*
name|q1
index|]
argument_list|)
operator|*
name|qty_n_refs
index|[
operator|*
name|q1
index|]
operator|*
name|qty_size
index|[
operator|*
name|q1
index|]
argument_list|)
operator|/
operator|(
name|qty_death
index|[
operator|*
name|q1
index|]
operator|-
name|qty_birth
index|[
operator|*
name|q1
index|]
operator|)
operator|)
operator|*
literal|10000
operator|)
decl_stmt|;
specifier|register
name|int
name|pri2
init|=
operator|(
operator|(
call|(
name|double
call|)
argument_list|(
name|floor_log2
argument_list|(
name|qty_n_refs
index|[
operator|*
name|q2
index|]
argument_list|)
operator|*
name|qty_n_refs
index|[
operator|*
name|q2
index|]
operator|*
name|qty_size
index|[
operator|*
name|q2
index|]
argument_list|)
operator|/
operator|(
name|qty_death
index|[
operator|*
name|q2
index|]
operator|-
name|qty_birth
index|[
operator|*
name|q2
index|]
operator|)
operator|)
operator|*
literal|10000
operator|)
decl_stmt|;
if|if
condition|(
name|sugg1
operator|!=
name|sugg2
condition|)
return|return
name|sugg1
operator|-
name|sugg2
return|;
if|if
condition|(
name|pri1
operator|!=
name|pri2
condition|)
return|return
name|pri2
operator|-
name|pri1
return|;
comment|/* If qtys are equally good, sort by qty number,      so that the results of qsort leave nothing to chance.  */
return|return
operator|*
name|q1
operator|-
operator|*
name|q2
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Attempt to combine the two registers (rtx's) USEDREG and SETREG.    Returns 1 if have done so, or 0 if cannot.     Combining registers means marking them as having the same quantity    and adjusting the offsets within the quantity if either of    them is a SUBREG).     We don't actually combine a hard reg with a pseudo; instead    we just record the hard reg as the suggestion for the pseudo's quantity.    If we really combined them, we could lose if the pseudo lives    across an insn that clobbers the hard reg (eg, movstr).     ALREADY_DEAD is non-zero if USEDREG is known to be dead even though    there is no REG_DEAD note on INSN.  This occurs during the processing    of REG_NO_CONFLICT blocks.     MAY_SAVE_COPYCOPY is non-zero if this insn is simply copying USEDREG to    SETREG or if the input and output must share a register.    In that case, we record a hard reg suggestion in QTY_PHYS_COPY_SUGG.        There are elaborate checks for the validity of combining.  */
end_comment

begin_function
specifier|static
name|int
name|combine_regs
parameter_list|(
name|usedreg
parameter_list|,
name|setreg
parameter_list|,
name|may_save_copy
parameter_list|,
name|insn_number
parameter_list|,
name|insn
parameter_list|,
name|already_dead
parameter_list|)
name|rtx
name|usedreg
decl_stmt|,
name|setreg
decl_stmt|;
name|int
name|may_save_copy
decl_stmt|;
name|int
name|insn_number
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|already_dead
decl_stmt|;
block|{
specifier|register
name|int
name|ureg
decl_stmt|,
name|sreg
decl_stmt|;
specifier|register
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|int
name|usize
decl_stmt|,
name|ssize
decl_stmt|;
specifier|register
name|int
name|sqty
decl_stmt|;
comment|/* Determine the numbers and sizes of registers being used.  If a subreg      is present that does not change the entire register, don't consider      this a copy insn.  */
while|while
condition|(
name|GET_CODE
argument_list|(
name|usedreg
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|usedreg
argument_list|)
argument_list|)
argument_list|)
operator|>
name|UNITS_PER_WORD
condition|)
name|may_save_copy
operator|=
literal|0
expr_stmt|;
name|offset
operator|+=
name|SUBREG_WORD
argument_list|(
name|usedreg
argument_list|)
expr_stmt|;
name|usedreg
operator|=
name|SUBREG_REG
argument_list|(
name|usedreg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|usedreg
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
name|ureg
operator|=
name|REGNO
argument_list|(
name|usedreg
argument_list|)
expr_stmt|;
name|usize
operator|=
name|REG_SIZE
argument_list|(
name|usedreg
argument_list|)
expr_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|setreg
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|setreg
argument_list|)
argument_list|)
argument_list|)
operator|>
name|UNITS_PER_WORD
condition|)
name|may_save_copy
operator|=
literal|0
expr_stmt|;
name|offset
operator|-=
name|SUBREG_WORD
argument_list|(
name|setreg
argument_list|)
expr_stmt|;
name|setreg
operator|=
name|SUBREG_REG
argument_list|(
name|setreg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|setreg
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
name|sreg
operator|=
name|REGNO
argument_list|(
name|setreg
argument_list|)
expr_stmt|;
name|ssize
operator|=
name|REG_SIZE
argument_list|(
name|setreg
argument_list|)
expr_stmt|;
comment|/* If UREG is a pseudo-register that hasn't already been assigned a      quantity number, it means that it is not local to this block or dies      more than once.  In either event, we can't do anything with it.  */
if|if
condition|(
operator|(
name|ureg
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|reg_qty
index|[
name|ureg
index|]
operator|<
literal|0
operator|)
comment|/* Do not combine registers unless one fits within the other.  */
operator|||
operator|(
name|offset
operator|>
literal|0
operator|&&
name|usize
operator|+
name|offset
operator|>
name|ssize
operator|)
operator|||
operator|(
name|offset
operator|<
literal|0
operator|&&
name|usize
operator|+
name|offset
operator|<
name|ssize
operator|)
comment|/* Do not combine with a smaller already-assigned object 	 if that smaller object is already combined with something bigger. */
operator|||
operator|(
name|ssize
operator|>
name|usize
operator|&&
name|ureg
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|usize
operator|<
name|qty_size
index|[
name|reg_qty
index|[
name|ureg
index|]
index|]
operator|)
comment|/* Can't combine if SREG is not a register we can allocate.  */
operator|||
operator|(
name|sreg
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|reg_qty
index|[
name|sreg
index|]
operator|==
operator|-
literal|1
operator|)
comment|/* Don't combine with a pseudo mentioned in a REG_NO_CONFLICT note. 	 These have already been taken care of.  This probably wouldn't 	 combine anyway, but don't take any chances.  */
operator|||
operator|(
name|ureg
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_NO_CONFLICT
argument_list|,
name|usedreg
argument_list|)
operator|)
comment|/* Don't tie something to itself.  In most cases it would make no 	 difference, but it would screw up if the reg being tied to itself 	 also dies in this insn.  */
operator|||
name|ureg
operator|==
name|sreg
comment|/* Don't try to connect two different hardware registers.  */
operator|||
operator|(
name|ureg
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|sreg
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
comment|/* Don't connect two different machine modes if they have different 	 implications as to which registers may be used.  */
operator|||
operator|!
name|MODES_TIEABLE_P
argument_list|(
name|GET_MODE
argument_list|(
name|usedreg
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|setreg
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Now, if UREG is a hard reg and SREG is a pseudo, record the hard reg in      qty_phys_sugg for the pseudo instead of tying them.       Return "failure" so that the lifespan of UREG is terminated here;      that way the two lifespans will be disjoint and nothing will prevent      the pseudo reg from being given this hard reg.  */
if|if
condition|(
name|ureg
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
comment|/* Allocate a quantity number so we have a place to put our 	 suggestions.  */
if|if
condition|(
name|reg_qty
index|[
name|sreg
index|]
operator|==
operator|-
literal|2
condition|)
name|reg_is_born
argument_list|(
name|setreg
argument_list|,
literal|2
operator|*
name|insn_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_qty
index|[
name|sreg
index|]
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|may_save_copy
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|qty_phys_copy_sugg
index|[
name|reg_qty
index|[
name|sreg
index|]
index|]
argument_list|,
name|ureg
argument_list|)
condition|)
block|{
name|SET_HARD_REG_BIT
argument_list|(
name|qty_phys_copy_sugg
index|[
name|reg_qty
index|[
name|sreg
index|]
index|]
argument_list|,
name|ureg
argument_list|)
expr_stmt|;
name|qty_phys_num_copy_sugg
index|[
name|reg_qty
index|[
name|sreg
index|]
index|]
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|qty_phys_sugg
index|[
name|reg_qty
index|[
name|sreg
index|]
index|]
argument_list|,
name|ureg
argument_list|)
condition|)
block|{
name|SET_HARD_REG_BIT
argument_list|(
name|qty_phys_sugg
index|[
name|reg_qty
index|[
name|sreg
index|]
index|]
argument_list|,
name|ureg
argument_list|)
expr_stmt|;
name|qty_phys_num_sugg
index|[
name|reg_qty
index|[
name|sreg
index|]
index|]
operator|++
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
comment|/* Similarly for SREG a hard register and UREG a pseudo register.  */
if|if
condition|(
name|sreg
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
if|if
condition|(
name|may_save_copy
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|qty_phys_copy_sugg
index|[
name|reg_qty
index|[
name|ureg
index|]
index|]
argument_list|,
name|sreg
argument_list|)
condition|)
block|{
name|SET_HARD_REG_BIT
argument_list|(
name|qty_phys_copy_sugg
index|[
name|reg_qty
index|[
name|ureg
index|]
index|]
argument_list|,
name|sreg
argument_list|)
expr_stmt|;
name|qty_phys_num_copy_sugg
index|[
name|reg_qty
index|[
name|ureg
index|]
index|]
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|qty_phys_sugg
index|[
name|reg_qty
index|[
name|ureg
index|]
index|]
argument_list|,
name|sreg
argument_list|)
condition|)
block|{
name|SET_HARD_REG_BIT
argument_list|(
name|qty_phys_sugg
index|[
name|reg_qty
index|[
name|ureg
index|]
index|]
argument_list|,
name|sreg
argument_list|)
expr_stmt|;
name|qty_phys_num_sugg
index|[
name|reg_qty
index|[
name|ureg
index|]
index|]
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
comment|/* At this point we know that SREG and UREG are both pseudos.      Do nothing if SREG already has a quantity or is a register that we      don't allocate.  */
if|if
condition|(
name|reg_qty
index|[
name|sreg
index|]
operator|>=
operator|-
literal|1
comment|/* If we are not going to let any regs live across calls, 	 don't tie a call-crossing reg to a non-call-crossing reg.  */
operator|||
operator|(
name|current_function_has_nonlocal_label
operator|&&
operator|(
operator|(
name|reg_n_calls_crossed
index|[
name|ureg
index|]
operator|>
literal|0
operator|)
operator|!=
operator|(
name|reg_n_calls_crossed
index|[
name|sreg
index|]
operator|>
literal|0
operator|)
operator|)
operator|)
condition|)
return|return
literal|0
return|;
comment|/* We don't already know about SREG, so tie it to UREG      if this is the last use of UREG, provided the classes they want      are compatible.  */
if|if
condition|(
operator|(
name|already_dead
operator|||
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|ureg
argument_list|)
operator|)
operator|&&
name|reg_meets_class_p
argument_list|(
name|sreg
argument_list|,
name|qty_min_class
index|[
name|reg_qty
index|[
name|ureg
index|]
index|]
argument_list|)
condition|)
block|{
comment|/* Add SREG to UREG's quantity.  */
name|sqty
operator|=
name|reg_qty
index|[
name|ureg
index|]
expr_stmt|;
name|reg_qty
index|[
name|sreg
index|]
operator|=
name|sqty
expr_stmt|;
name|reg_offset
index|[
name|sreg
index|]
operator|=
name|reg_offset
index|[
name|ureg
index|]
operator|+
name|offset
expr_stmt|;
name|reg_next_in_qty
index|[
name|sreg
index|]
operator|=
name|qty_first_reg
index|[
name|sqty
index|]
expr_stmt|;
name|qty_first_reg
index|[
name|sqty
index|]
operator|=
name|sreg
expr_stmt|;
comment|/* If SREG's reg class is smaller, set qty_min_class[SQTY].  */
name|update_qty_class
argument_list|(
name|sqty
argument_list|,
name|sreg
argument_list|)
expr_stmt|;
comment|/* Update info about quantity SQTY.  */
name|qty_n_calls_crossed
index|[
name|sqty
index|]
operator|+=
name|reg_n_calls_crossed
index|[
name|sreg
index|]
expr_stmt|;
name|qty_n_refs
index|[
name|sqty
index|]
operator|+=
name|reg_n_refs
index|[
name|sreg
index|]
expr_stmt|;
if|if
condition|(
name|usize
operator|<
name|ssize
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|qty_first_reg
index|[
name|sqty
index|]
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|=
name|reg_next_in_qty
index|[
name|i
index|]
control|)
name|reg_offset
index|[
name|i
index|]
operator|-=
name|offset
expr_stmt|;
name|qty_size
index|[
name|sqty
index|]
operator|=
name|ssize
expr_stmt|;
name|qty_mode
index|[
name|sqty
index|]
operator|=
name|GET_MODE
argument_list|(
name|setreg
argument_list|)
expr_stmt|;
block|}
block|}
else|else
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if the preferred class of REG allows it to be tied    to a quantity or register whose class is CLASS.    True if REG's reg class either contains or is contained in CLASS.  */
end_comment

begin_function
specifier|static
name|int
name|reg_meets_class_p
parameter_list|(
name|reg
parameter_list|,
name|class
parameter_list|)
name|int
name|reg
decl_stmt|;
name|enum
name|reg_class
name|class
decl_stmt|;
block|{
specifier|register
name|enum
name|reg_class
name|rclass
init|=
name|reg_preferred_class
argument_list|(
name|reg
argument_list|)
decl_stmt|;
return|return
operator|(
name|reg_class_subset_p
argument_list|(
name|rclass
argument_list|,
name|class
argument_list|)
operator|||
name|reg_class_subset_p
argument_list|(
name|class
argument_list|,
name|rclass
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the two specified classes have registers in common.    If CALL_SAVED, then consider only call-saved registers.  */
end_comment

begin_function
specifier|static
name|int
name|reg_classes_overlap_p
parameter_list|(
name|c1
parameter_list|,
name|c2
parameter_list|,
name|call_saved
parameter_list|)
specifier|register
name|enum
name|reg_class
name|c1
decl_stmt|;
specifier|register
name|enum
name|reg_class
name|c2
decl_stmt|;
name|int
name|call_saved
decl_stmt|;
block|{
name|HARD_REG_SET
name|c
decl_stmt|;
name|int
name|i
decl_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|c
argument_list|,
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|c1
index|]
argument_list|)
expr_stmt|;
name|AND_HARD_REG_SET
argument_list|(
name|c
argument_list|,
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|c2
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|c
argument_list|,
name|i
argument_list|)
operator|&&
operator|(
operator|!
name|call_saved
operator|||
operator|!
name|call_used_regs
index|[
name|i
index|]
operator|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Update the class of QTY assuming that REG is being tied to it.  */
end_comment

begin_function
specifier|static
name|void
name|update_qty_class
parameter_list|(
name|qty
parameter_list|,
name|reg
parameter_list|)
name|int
name|qty
decl_stmt|;
name|int
name|reg
decl_stmt|;
block|{
name|enum
name|reg_class
name|rclass
init|=
name|reg_preferred_class
argument_list|(
name|reg
argument_list|)
decl_stmt|;
if|if
condition|(
name|reg_class_subset_p
argument_list|(
name|rclass
argument_list|,
name|qty_min_class
index|[
name|qty
index|]
argument_list|)
condition|)
name|qty_min_class
index|[
name|qty
index|]
operator|=
name|rclass
expr_stmt|;
name|rclass
operator|=
name|reg_alternate_class
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_class_subset_p
argument_list|(
name|rclass
argument_list|,
name|qty_alternate_class
index|[
name|qty
index|]
argument_list|)
condition|)
name|qty_alternate_class
index|[
name|qty
index|]
operator|=
name|rclass
expr_stmt|;
if|if
condition|(
name|reg_changes_size
index|[
name|reg
index|]
condition|)
name|qty_changes_size
index|[
name|qty
index|]
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Handle something which alters the value of an rtx REG.     REG is whatever is set or clobbered.  SETTER is the rtx that    is modifying the register.     If it is not really a register, we do nothing.    The file-global variables `this_insn' and `this_insn_number'    carry info from `block_alloc'.  */
end_comment

begin_function
specifier|static
name|void
name|reg_is_set
parameter_list|(
name|reg
parameter_list|,
name|setter
parameter_list|)
name|rtx
name|reg
decl_stmt|;
name|rtx
name|setter
decl_stmt|;
block|{
comment|/* Note that note_stores will only pass us a SUBREG if it is a SUBREG of      a hard register.  These may actually not exist any more.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|!=
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|!=
name|REG
condition|)
return|return;
comment|/* Mark this register as being born.  If it is used in a CLOBBER, mark      it as being born halfway between the previous insn and this insn so that      it conflicts with our inputs but not the outputs of the previous insn.  */
name|reg_is_born
argument_list|(
name|reg
argument_list|,
literal|2
operator|*
name|this_insn_number
operator|-
operator|(
name|GET_CODE
argument_list|(
name|setter
argument_list|)
operator|==
name|CLOBBER
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Handle beginning of the life of register REG.    BIRTH is the index at which this is happening.  */
end_comment

begin_function
specifier|static
name|void
name|reg_is_born
parameter_list|(
name|reg
parameter_list|,
name|birth
parameter_list|)
name|rtx
name|reg
decl_stmt|;
name|int
name|birth
decl_stmt|;
block|{
specifier|register
name|int
name|regno
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
condition|)
name|regno
operator|=
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|+
name|SUBREG_WORD
argument_list|(
name|reg
argument_list|)
expr_stmt|;
else|else
name|regno
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|mark_life
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* If the register was to have been born earlier that the present 	 insn, mark it as live where it is actually born.  */
if|if
condition|(
name|birth
operator|<
literal|2
operator|*
name|this_insn_number
condition|)
name|post_mark_life
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|,
literal|1
argument_list|,
name|birth
argument_list|,
literal|2
operator|*
name|this_insn_number
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|reg_qty
index|[
name|regno
index|]
operator|==
operator|-
literal|2
condition|)
name|alloc_qty
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|PSEUDO_REGNO_SIZE
argument_list|(
name|regno
argument_list|)
argument_list|,
name|birth
argument_list|)
expr_stmt|;
comment|/* If this register has a quantity number, show that it isn't dead.  */
if|if
condition|(
name|reg_qty
index|[
name|regno
index|]
operator|>=
literal|0
condition|)
name|qty_death
index|[
name|reg_qty
index|[
name|regno
index|]
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Record the death of REG in the current insn.  If OUTPUT_P is non-zero,    REG is an output that is dying (i.e., it is never used), otherwise it    is an input (the normal case).    If OUTPUT_P is 1, then we extend the life past the end of this insn.  */
end_comment

begin_function
specifier|static
name|void
name|wipe_dead_reg
parameter_list|(
name|reg
parameter_list|,
name|output_p
parameter_list|)
specifier|register
name|rtx
name|reg
decl_stmt|;
name|int
name|output_p
decl_stmt|;
block|{
specifier|register
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|reg
argument_list|)
decl_stmt|;
comment|/* If this insn has multiple results,      and the dead reg is used in one of the results,      extend its life to after this insn,      so it won't get allocated together with any other result of this insn.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|this_insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
operator|&&
operator|!
name|single_set
argument_list|(
name|this_insn
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|this_insn
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|rtx
name|set
init|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|this_insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|set
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|!=
name|REG
operator|&&
operator|!
name|rtx_equal_p
argument_list|(
name|reg
argument_list|,
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|reg
argument_list|,
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
condition|)
name|output_p
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|mark_life
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If a hard register is dying as an output, mark it as in use at 	 the beginning of this insn (the above statement would cause this 	 not to happen).  */
if|if
condition|(
name|output_p
condition|)
name|post_mark_life
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|2
operator|*
name|this_insn_number
argument_list|,
literal|2
operator|*
name|this_insn_number
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reg_qty
index|[
name|regno
index|]
operator|>=
literal|0
condition|)
name|qty_death
index|[
name|reg_qty
index|[
name|regno
index|]
index|]
operator|=
literal|2
operator|*
name|this_insn_number
operator|+
name|output_p
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find a block of SIZE words of hard regs in reg_class CLASS    that can hold something of machine-mode MODE      (but actually we test only the first of the block for holding MODE)    and still free between insn BORN_INDEX and insn DEAD_INDEX,    and return the number of the first of them.    Return -1 if such a block cannot be found.     If QTY crosses calls, insist on a register preserved by calls,    unless ACCEPT_CALL_CLOBBERED is nonzero.     If JUST_TRY_SUGGESTED is non-zero, only try to see if the suggested    register is available.  If not, return -1.  */
end_comment

begin_function
specifier|static
name|int
name|find_free_reg
parameter_list|(
name|class
parameter_list|,
name|mode
parameter_list|,
name|qty
parameter_list|,
name|accept_call_clobbered
parameter_list|,
name|just_try_suggested
parameter_list|,
name|born_index
parameter_list|,
name|dead_index
parameter_list|)
name|enum
name|reg_class
name|class
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|qty
decl_stmt|;
name|int
name|accept_call_clobbered
decl_stmt|;
name|int
name|just_try_suggested
decl_stmt|;
name|int
name|born_index
decl_stmt|,
name|dead_index
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|ins
decl_stmt|;
ifdef|#
directive|ifdef
name|HARD_REG_SET
specifier|register
comment|/* Declare it register if it's a scalar.  */
endif|#
directive|endif
name|HARD_REG_SET
name|used
decl_stmt|,
name|first_used
decl_stmt|;
ifdef|#
directive|ifdef
name|ELIMINABLE_REGS
specifier|static
struct|struct
block|{
name|int
name|from
decl_stmt|,
name|to
decl_stmt|;
block|}
name|eliminables
index|[]
init|=
name|ELIMINABLE_REGS
struct|;
endif|#
directive|endif
comment|/* Validate our parameters.  */
if|if
condition|(
name|born_index
operator|<
literal|0
operator|||
name|born_index
operator|>
name|dead_index
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Don't let a pseudo live in a reg across a function call      if we might get a nonlocal goto.  */
if|if
condition|(
name|current_function_has_nonlocal_label
operator|&&
name|qty_n_calls_crossed
index|[
name|qty
index|]
operator|>
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|accept_call_clobbered
condition|)
name|COPY_HARD_REG_SET
argument_list|(
name|used
argument_list|,
name|call_fixed_reg_set
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|qty_n_calls_crossed
index|[
name|qty
index|]
operator|==
literal|0
condition|)
name|COPY_HARD_REG_SET
argument_list|(
name|used
argument_list|,
name|fixed_reg_set
argument_list|)
expr_stmt|;
else|else
name|COPY_HARD_REG_SET
argument_list|(
name|used
argument_list|,
name|call_used_reg_set
argument_list|)
expr_stmt|;
for|for
control|(
name|ins
operator|=
name|born_index
init|;
name|ins
operator|<
name|dead_index
condition|;
name|ins
operator|++
control|)
name|IOR_HARD_REG_SET
argument_list|(
name|used
argument_list|,
name|regs_live_at
index|[
name|ins
index|]
argument_list|)
expr_stmt|;
name|IOR_COMPL_HARD_REG_SET
argument_list|(
name|used
argument_list|,
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|class
index|]
argument_list|)
expr_stmt|;
comment|/* Don't use the frame pointer reg in local-alloc even if      we may omit the frame pointer, because if we do that and then we      need a frame pointer, reload won't know how to move the pseudo      to another hard reg.  It can move only regs made by global-alloc.       This is true of any register that can be eliminated.  */
ifdef|#
directive|ifdef
name|ELIMINABLE_REGS
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
name|eliminables
operator|/
sizeof|sizeof
name|eliminables
index|[
literal|0
index|]
condition|;
name|i
operator|++
control|)
name|SET_HARD_REG_BIT
argument_list|(
name|used
argument_list|,
name|eliminables
index|[
name|i
index|]
operator|.
name|from
argument_list|)
expr_stmt|;
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|HARD_FRAME_POINTER_REGNUM
comment|/* If FRAME_POINTER_REGNUM is not a real register, then protect the one      that it might be eliminated into. */
name|SET_HARD_REG_BIT
argument_list|(
name|used
argument_list|,
name|HARD_FRAME_POINTER_REGNUM
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
name|SET_HARD_REG_BIT
argument_list|(
name|used
argument_list|,
name|FRAME_POINTER_REGNUM
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CLASS_CANNOT_CHANGE_SIZE
if|if
condition|(
name|qty_changes_size
index|[
name|qty
index|]
condition|)
name|IOR_HARD_REG_SET
argument_list|(
name|used
argument_list|,
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|CLASS_CANNOT_CHANGE_SIZE
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Normally, the registers that can be used for the first register in      a multi-register quantity are the same as those that can be used for      subsequent registers.  However, if just trying suggested registers,      restrict our consideration to them.  If there are copy-suggested      register, try them.  Otherwise, try the arithmetic-suggested      registers.  */
name|COPY_HARD_REG_SET
argument_list|(
name|first_used
argument_list|,
name|used
argument_list|)
expr_stmt|;
if|if
condition|(
name|just_try_suggested
condition|)
block|{
if|if
condition|(
name|qty_phys_num_copy_sugg
index|[
name|qty
index|]
operator|!=
literal|0
condition|)
name|IOR_COMPL_HARD_REG_SET
argument_list|(
name|first_used
argument_list|,
name|qty_phys_copy_sugg
index|[
name|qty
index|]
argument_list|)
expr_stmt|;
else|else
name|IOR_COMPL_HARD_REG_SET
argument_list|(
name|first_used
argument_list|,
name|qty_phys_sugg
index|[
name|qty
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* If all registers are excluded, we can't do anything.  */
name|GO_IF_HARD_REG_SUBSET
argument_list|(
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|ALL_REGS
index|]
argument_list|,
name|first_used
argument_list|,
name|fail
argument_list|)
expr_stmt|;
comment|/* If at least one would be suitable, test each hard reg.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|REG_ALLOC_ORDER
name|int
name|regno
init|=
name|reg_alloc_order
index|[
name|i
index|]
decl_stmt|;
else|#
directive|else
name|int
name|regno
init|=
name|i
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|first_used
argument_list|,
name|regno
argument_list|)
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|int
name|size1
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|size1
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|used
argument_list|,
name|regno
operator|+
name|j
argument_list|)
condition|;
name|j
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|j
operator|==
name|size1
condition|)
block|{
comment|/* Mark that this register is in use between its birth and death 		 insns.  */
name|post_mark_life
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|,
literal|1
argument_list|,
name|born_index
argument_list|,
name|dead_index
argument_list|)
expr_stmt|;
return|return
name|regno
return|;
block|}
ifndef|#
directive|ifndef
name|REG_ALLOC_ORDER
name|i
operator|+=
name|j
expr_stmt|;
comment|/* Skip starting points we know will lose */
endif|#
directive|endif
block|}
block|}
name|fail
label|:
comment|/* If we are just trying suggested register, we have just tried copy-      suggested registers, and there are arithmetic-suggested registers,      try them.  */
comment|/* If it would be profitable to allocate a call-clobbered register      and save and restore it around calls, do that.  */
if|if
condition|(
name|just_try_suggested
operator|&&
name|qty_phys_num_copy_sugg
index|[
name|qty
index|]
operator|!=
literal|0
operator|&&
name|qty_phys_num_sugg
index|[
name|qty
index|]
operator|!=
literal|0
condition|)
block|{
comment|/* Don't try the copy-suggested regs again.  */
name|qty_phys_num_copy_sugg
index|[
name|qty
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|find_free_reg
argument_list|(
name|class
argument_list|,
name|mode
argument_list|,
name|qty
argument_list|,
name|accept_call_clobbered
argument_list|,
literal|1
argument_list|,
name|born_index
argument_list|,
name|dead_index
argument_list|)
return|;
block|}
comment|/* We need not check to see if the current function has nonlocal      labels because we don't put any pseudos that are live over calls in      registers in that case.  */
if|if
condition|(
operator|!
name|accept_call_clobbered
operator|&&
name|flag_caller_saves
operator|&&
operator|!
name|just_try_suggested
operator|&&
name|qty_n_calls_crossed
index|[
name|qty
index|]
operator|!=
literal|0
operator|&&
name|CALLER_SAVE_PROFITABLE
argument_list|(
name|qty_n_refs
index|[
name|qty
index|]
argument_list|,
name|qty_n_calls_crossed
index|[
name|qty
index|]
argument_list|)
condition|)
block|{
name|i
operator|=
name|find_free_reg
argument_list|(
name|class
argument_list|,
name|mode
argument_list|,
name|qty
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|born_index
argument_list|,
name|dead_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
name|caller_save_needed
operator|=
literal|1
expr_stmt|;
return|return
name|i
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Mark that REGNO with machine-mode MODE is live starting from the current    insn (if LIFE is non-zero) or dead starting at the current insn (if LIFE    is zero).  */
end_comment

begin_function
specifier|static
name|void
name|mark_life
parameter_list|(
name|regno
parameter_list|,
name|mode
parameter_list|,
name|life
parameter_list|)
specifier|register
name|int
name|regno
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|life
decl_stmt|;
block|{
specifier|register
name|int
name|j
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
decl_stmt|;
if|if
condition|(
name|life
condition|)
while|while
condition|(
operator|--
name|j
operator|>=
literal|0
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|regs_live
argument_list|,
name|regno
operator|+
name|j
argument_list|)
expr_stmt|;
else|else
while|while
condition|(
operator|--
name|j
operator|>=
literal|0
condition|)
name|CLEAR_HARD_REG_BIT
argument_list|(
name|regs_live
argument_list|,
name|regno
operator|+
name|j
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Mark register number REGNO (with machine-mode MODE) as live (if LIFE    is non-zero) or dead (if LIFE is zero) from insn number BIRTH (inclusive)    to insn number DEATH (exclusive).  */
end_comment

begin_function
specifier|static
name|void
name|post_mark_life
parameter_list|(
name|regno
parameter_list|,
name|mode
parameter_list|,
name|life
parameter_list|,
name|birth
parameter_list|,
name|death
parameter_list|)
name|int
name|regno
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|life
decl_stmt|,
name|birth
decl_stmt|,
name|death
decl_stmt|;
block|{
specifier|register
name|int
name|j
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|HARD_REG_SET
specifier|register
comment|/* Declare it register if it's a scalar.  */
endif|#
directive|endif
name|HARD_REG_SET
name|this_reg
decl_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|this_reg
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|j
operator|>=
literal|0
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|this_reg
argument_list|,
name|regno
operator|+
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|life
condition|)
while|while
condition|(
name|birth
operator|<
name|death
condition|)
block|{
name|IOR_HARD_REG_SET
argument_list|(
name|regs_live_at
index|[
name|birth
index|]
argument_list|,
name|this_reg
argument_list|)
expr_stmt|;
name|birth
operator|++
expr_stmt|;
block|}
else|else
while|while
condition|(
name|birth
operator|<
name|death
condition|)
block|{
name|AND_COMPL_HARD_REG_SET
argument_list|(
name|regs_live_at
index|[
name|birth
index|]
argument_list|,
name|this_reg
argument_list|)
expr_stmt|;
name|birth
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* INSN is the CLOBBER insn that starts a REG_NO_NOCONFLICT block, R0    is the register being clobbered, and R1 is a register being used in    the equivalent expression.     If R1 dies in the block and has a REG_NO_CONFLICT note on every insn    in which it is used, return 1.     Otherwise, return 0.  */
end_comment

begin_function
specifier|static
name|int
name|no_conflict_p
parameter_list|(
name|insn
parameter_list|,
name|r0
parameter_list|,
name|r1
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|r0
decl_stmt|,
name|r1
decl_stmt|;
block|{
name|int
name|ok
init|=
literal|0
decl_stmt|;
name|rtx
name|note
init|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_LIBCALL
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
name|rtx
name|p
decl_stmt|,
name|last
decl_stmt|;
comment|/* If R1 is a hard register, return 0 since we handle this case      when we scan the insns that actually use it.  */
if|if
condition|(
name|note
operator|==
literal|0
operator|||
operator|(
name|GET_CODE
argument_list|(
name|r1
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|r1
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|r1
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|r1
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|r1
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
condition|)
return|return
literal|0
return|;
name|last
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
init|;
name|p
operator|&&
name|p
operator|!=
name|last
condition|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
control|)
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
block|{
if|if
condition|(
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_DEAD
argument_list|,
name|r1
argument_list|)
condition|)
name|ok
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|r1
argument_list|,
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
operator|&&
operator|!
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_NO_CONFLICT
argument_list|,
name|r1
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
name|ok
return|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|REGISTER_CONSTRAINTS
end_ifdef

begin_comment
comment|/* Return the number of alternatives for which the constraint string P    indicates that the operand must be equal to operand 0 and that no register    is acceptable.  */
end_comment

begin_function
specifier|static
name|int
name|requires_inout
parameter_list|(
name|p
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
block|{
name|char
name|c
decl_stmt|;
name|int
name|found_zero
init|=
literal|0
decl_stmt|;
name|int
name|reg_allowed
init|=
literal|0
decl_stmt|;
name|int
name|num_matching_alts
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|p
operator|++
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'='
case|:
case|case
literal|'+'
case|:
case|case
literal|'?'
case|:
case|case
literal|'#'
case|:
case|case
literal|'&'
case|:
case|case
literal|'!'
case|:
case|case
literal|'*'
case|:
case|case
literal|'%'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'m'
case|:
case|case
literal|'<'
case|:
case|case
literal|'>'
case|:
case|case
literal|'V'
case|:
case|case
literal|'o'
case|:
case|case
literal|'E'
case|:
case|case
literal|'F'
case|:
case|case
literal|'G'
case|:
case|case
literal|'H'
case|:
case|case
literal|'s'
case|:
case|case
literal|'i'
case|:
case|case
literal|'n'
case|:
case|case
literal|'I'
case|:
case|case
literal|'J'
case|:
case|case
literal|'K'
case|:
case|case
literal|'L'
case|:
case|case
literal|'M'
case|:
case|case
literal|'N'
case|:
case|case
literal|'O'
case|:
case|case
literal|'P'
case|:
ifdef|#
directive|ifdef
name|EXTRA_CONSTRAINT
case|case
literal|'Q'
case|:
case|case
literal|'R'
case|:
case|case
literal|'S'
case|:
case|case
literal|'T'
case|:
case|case
literal|'U'
case|:
endif|#
directive|endif
case|case
literal|'X'
case|:
comment|/* These don't say anything we care about.  */
break|break;
case|case
literal|','
case|:
if|if
condition|(
name|found_zero
operator|&&
operator|!
name|reg_allowed
condition|)
name|num_matching_alts
operator|++
expr_stmt|;
name|found_zero
operator|=
name|reg_allowed
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
name|found_zero
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
case|case
literal|'g'
case|:
case|case
literal|'r'
case|:
default|default:
name|reg_allowed
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|found_zero
operator|&&
operator|!
name|reg_allowed
condition|)
name|num_matching_alts
operator|++
expr_stmt|;
return|return
name|num_matching_alts
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* REGISTER_CONSTRAINTS */
end_comment

begin_escape
end_escape

begin_function
name|void
name|dump_local_alloc
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
name|max_regno
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|reg_renumber
index|[
name|i
index|]
operator|!=
operator|-
literal|1
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";; Register %d in %d.\n"
argument_list|,
name|i
argument_list|,
name|reg_renumber
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

