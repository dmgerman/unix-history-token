begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Subroutines for manipulating rtx's in semantically interesting ways.    Copyright (C) 1987, 1991, 1994 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"insn-flags.h"
end_include

begin_include
include|#
directive|include
file|"insn-codes.h"
end_include

begin_comment
comment|/* Return an rtx for the sum of X and the integer C.     This function should be used via the `plus_constant' macro.  */
end_comment

begin_function
name|rtx
name|plus_constant_wide
parameter_list|(
name|x
parameter_list|,
name|c
parameter_list|)
specifier|register
name|rtx
name|x
decl_stmt|;
specifier|register
name|HOST_WIDE_INT
name|c
decl_stmt|;
block|{
specifier|register
name|RTX_CODE
name|code
decl_stmt|;
specifier|register
name|enum
name|machine_mode
name|mode
decl_stmt|;
specifier|register
name|rtx
name|tem
decl_stmt|;
name|int
name|all_constant
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
return|return
name|x
return|;
name|restart
label|:
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONST_INT
case|:
return|return
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|+
name|c
argument_list|)
return|;
case|case
name|CONST_DOUBLE
case|:
block|{
name|HOST_WIDE_INT
name|l1
init|=
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|h1
init|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|l2
init|=
name|c
decl_stmt|;
name|HOST_WIDE_INT
name|h2
init|=
name|c
operator|<
literal|0
condition|?
operator|~
literal|0
else|:
literal|0
decl_stmt|;
name|HOST_WIDE_INT
name|lv
decl_stmt|,
name|hv
decl_stmt|;
name|add_double
argument_list|(
name|l1
argument_list|,
name|h1
argument_list|,
name|l2
argument_list|,
name|h2
argument_list|,
operator|&
name|lv
argument_list|,
operator|&
name|hv
argument_list|)
expr_stmt|;
return|return
name|immed_double_const
argument_list|(
name|lv
argument_list|,
name|hv
argument_list|,
name|VOIDmode
argument_list|)
return|;
block|}
case|case
name|MEM
case|:
comment|/* If this is a reference to the constant pool, try replacing it with 	 a reference to a new constant.  If the resulting address isn't 	 valid, don't return it because we have no way to validize it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|tem
operator|=
name|force_const_mem
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|plus_constant
argument_list|(
name|get_pool_constant
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|c
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|memory_address_p
argument_list|(
name|GET_MODE
argument_list|(
name|tem
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|tem
return|;
block|}
break|break;
case|case
name|CONST
case|:
comment|/* If adding to something entirely constant, set a flag 	 so that we can add a CONST around the result.  */
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|all_constant
operator|=
literal|1
expr_stmt|;
goto|goto
name|restart
goto|;
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
name|all_constant
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|PLUS
case|:
comment|/* The interesting case is adding the integer to a sum. 	 Look for constant term in the sum and combine 	 with C.  For an integer constant term, we make a combined 	 integer.  For a constant term that is not an explicit integer, 	 we cannot really combine, but group them together anyway.  	 Use a recursive call in case the remaining operand is something 	 that we handle specially, such as a SYMBOL_REF.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|c
operator|+
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|mode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|c
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|c
argument_list|)
argument_list|)
return|;
default|default:
break|break;
block|}
if|if
condition|(
name|c
operator|!=
literal|0
condition|)
name|x
operator|=
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|mode
argument_list|,
name|x
argument_list|,
name|GEN_INT
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LABEL_REF
condition|)
return|return
name|x
return|;
elseif|else
if|if
condition|(
name|all_constant
condition|)
return|return
name|gen_rtx
argument_list|(
name|CONST
argument_list|,
name|mode
argument_list|,
name|x
argument_list|)
return|;
else|else
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* This is the same as `plus_constant', except that it handles LO_SUM.     This function should be used via the `plus_constant_for_output' macro.  */
end_comment

begin_function
name|rtx
name|plus_constant_for_output_wide
parameter_list|(
name|x
parameter_list|,
name|c
parameter_list|)
specifier|register
name|rtx
name|x
decl_stmt|;
specifier|register
name|HOST_WIDE_INT
name|c
decl_stmt|;
block|{
specifier|register
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
specifier|register
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|int
name|all_constant
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LO_SUM
condition|)
return|return
name|gen_rtx
argument_list|(
name|LO_SUM
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|plus_constant_for_output
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|c
argument_list|)
argument_list|)
return|;
else|else
return|return
name|plus_constant
argument_list|(
name|x
argument_list|,
name|c
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If X is a sum, return a new sum like X but lacking any constant terms.    Add all the removed constant terms into *CONSTPTR.    X itself is not altered.  The result != X if and only if    it is not isomorphic to X.  */
end_comment

begin_function
name|rtx
name|eliminate_constant_term
parameter_list|(
name|x
parameter_list|,
name|constptr
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
modifier|*
name|constptr
decl_stmt|;
block|{
specifier|register
name|rtx
name|x0
decl_stmt|,
name|x1
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|PLUS
condition|)
return|return
name|x
return|;
comment|/* First handle constants appearing at this level explicitly.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
literal|0
operator|!=
operator|(
name|tem
operator|=
name|simplify_binary_operation
argument_list|(
name|PLUS
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
operator|*
name|constptr
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
operator|*
name|constptr
operator|=
name|tem
expr_stmt|;
return|return
name|eliminate_constant_term
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|constptr
argument_list|)
return|;
block|}
name|tem
operator|=
name|const0_rtx
expr_stmt|;
name|x0
operator|=
name|eliminate_constant_term
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|tem
argument_list|)
expr_stmt|;
name|x1
operator|=
name|eliminate_constant_term
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
operator|&
name|tem
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|x1
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|||
name|x0
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|)
operator|&&
literal|0
operator|!=
operator|(
name|tem
operator|=
name|simplify_binary_operation
argument_list|(
name|PLUS
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
operator|*
name|constptr
argument_list|,
name|tem
argument_list|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
operator|*
name|constptr
operator|=
name|tem
expr_stmt|;
return|return
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|x0
argument_list|,
name|x1
argument_list|)
return|;
block|}
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Returns the insn that next references REG after INSN, or 0    if REG is clobbered before next referenced or we cannot find    an insn that references REG in a straight-line piece of code.  */
end_comment

begin_function
name|rtx
name|find_next_ref
parameter_list|(
name|reg
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|reg
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|next
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
init|;
name|insn
condition|;
name|insn
operator|=
name|next
control|)
block|{
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
continue|continue;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|BARRIER
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
if|if
condition|(
name|reg_set_p
argument_list|(
name|reg
argument_list|,
name|insn
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|reg
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
return|return
name|insn
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
if|if
condition|(
name|simplejump_p
argument_list|(
name|insn
argument_list|)
condition|)
name|next
operator|=
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
expr_stmt|;
else|else
return|return
literal|0
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|&&
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|call_used_regs
index|[
name|REGNO
argument_list|(
name|reg
argument_list|)
index|]
condition|)
return|return
literal|0
return|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return an rtx for the size in bytes of the value of EXP.  */
end_comment

begin_function
name|rtx
name|expr_size
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
name|tree
name|size
init|=
name|size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|size
argument_list|)
operator|!=
name|INTEGER_CST
operator|&&
name|contains_placeholder_p
argument_list|(
name|size
argument_list|)
condition|)
name|size
operator|=
name|build
argument_list|(
name|WITH_RECORD_EXPR
argument_list|,
name|sizetype
argument_list|,
name|size
argument_list|,
name|exp
argument_list|)
expr_stmt|;
return|return
name|expand_expr
argument_list|(
name|size
argument_list|,
name|NULL_RTX
argument_list|,
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a copy of X in which all memory references    and all constants that involve symbol refs    have been replaced with new temporary registers.    Also emit code to load the memory locations and constants    into those registers.     If X contains no such constants or memory references,    X itself (not a copy) is returned.     If a constant is found in the address that is not a legitimate constant    in an insn, it is left alone in the hope that it might be valid in the    address.     X may contain no arithmetic except addition, subtraction and multiplication.    Values returned by expand_expr with 1 for sum_ok fit this constraint.  */
end_comment

begin_function
specifier|static
name|rtx
name|break_out_memory_refs
parameter_list|(
name|x
parameter_list|)
specifier|register
name|rtx
name|x
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
operator|||
operator|(
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
operator|&&
name|CONSTANT_ADDRESS_P
argument_list|(
name|x
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|VOIDmode
operator|)
condition|)
name|x
operator|=
name|force_reg
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|x
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MINUS
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MULT
condition|)
block|{
specifier|register
name|rtx
name|op0
init|=
name|break_out_memory_refs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
specifier|register
name|rtx
name|op1
init|=
name|break_out_memory_refs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|op0
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|||
name|op1
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|)
name|x
operator|=
name|gen_rtx
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Given a memory address or facsimile X, construct a new address,    currently equivalent, that is stable: future stores won't change it.     X must be composed of constants, register and memory references    combined with addition, subtraction and multiplication:    in other words, just what you can get from expand_expr if sum_ok is 1.     Works by making copies of all regs and memory locations used    by X and combining them the same way X does.    You could also stabilize the reference to this address    by copying the address to a register with copy_to_reg;    but then you wouldn't get indexed addressing in the reference.  */
end_comment

begin_function
name|rtx
name|copy_all_regs
parameter_list|(
name|x
parameter_list|)
specifier|register
name|rtx
name|x
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|!=
name|FRAME_POINTER_REGNUM
if|#
directive|if
name|HARD_FRAME_POINTER_REGNUM
operator|!=
name|FRAME_POINTER_REGNUM
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|!=
name|HARD_FRAME_POINTER_REGNUM
endif|#
directive|endif
condition|)
name|x
operator|=
name|copy_to_reg
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
name|x
operator|=
name|copy_to_reg
argument_list|(
name|x
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MINUS
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MULT
condition|)
block|{
specifier|register
name|rtx
name|op0
init|=
name|copy_all_regs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
specifier|register
name|rtx
name|op1
init|=
name|copy_all_regs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|op0
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|||
name|op1
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|)
name|x
operator|=
name|gen_rtx
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
return|return
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return something equivalent to X but valid as a memory address    for something of mode MODE.  When X is not itself valid, this    works by copying X or subexpressions of it into registers.  */
end_comment

begin_function
name|rtx
name|memory_address
parameter_list|(
name|mode
parameter_list|,
name|x
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
specifier|register
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|rtx
name|oldx
init|=
name|x
decl_stmt|;
comment|/* By passing constant addresses thru registers      we get a chance to cse them.  */
if|if
condition|(
operator|!
name|cse_not_expected
operator|&&
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
operator|&&
name|CONSTANT_ADDRESS_P
argument_list|(
name|x
argument_list|)
condition|)
name|x
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* Accept a QUEUED that refers to a REG      even though that isn't a valid address.      On attempting to put this in an insn we will call protect_from_queue      which will turn it into a REG, which is valid.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|QUEUED
operator|&&
name|GET_CODE
argument_list|(
name|QUEUED_VAR
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
empty_stmt|;
comment|/* We get better cse by rejecting indirect addressing at this stage.      Let the combiner create indirect addresses where appropriate.      For now, generate the code so that the subexpressions useful to share      are visible.  But not if cse won't be done!  */
else|else
block|{
if|if
condition|(
operator|!
name|cse_not_expected
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
condition|)
name|x
operator|=
name|break_out_memory_refs
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* At this point, any valid address is accepted.  */
name|GO_IF_LEGITIMATE_ADDRESS
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
name|win
argument_list|)
expr_stmt|;
comment|/* If it was valid before but breaking out memory refs invalidated it, 	 use it the old way.  */
if|if
condition|(
name|memory_address_p
argument_list|(
name|mode
argument_list|,
name|oldx
argument_list|)
condition|)
goto|goto
name|win2
goto|;
comment|/* Perform machine-dependent transformations on X 	 in certain cases.  This is not necessary since the code 	 below can handle all possible cases, but machine-dependent 	 transformations can make better code.  */
name|LEGITIMIZE_ADDRESS
argument_list|(
name|x
argument_list|,
name|oldx
argument_list|,
name|mode
argument_list|,
name|win
argument_list|)
expr_stmt|;
comment|/* PLUS and MULT can appear in special ways 	 as the result of attempts to make an address usable for indexing. 	 Usually they are dealt with by calling force_operand, below. 	 But a sum containing constant terms is special 	 if removing them makes the sum a valid address: 	 then we generate that address in a register 	 and index off of it.  We do this because it often makes 	 shorter code, and because the addresses thus generated 	 in registers often become common subexpressions.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|rtx
name|constant_term
init|=
name|const0_rtx
decl_stmt|;
name|rtx
name|y
init|=
name|eliminate_constant_term
argument_list|(
name|x
argument_list|,
operator|&
name|constant_term
argument_list|)
decl_stmt|;
if|if
condition|(
name|constant_term
operator|==
name|const0_rtx
operator|||
operator|!
name|memory_address_p
argument_list|(
name|mode
argument_list|,
name|y
argument_list|)
condition|)
name|x
operator|=
name|force_operand
argument_list|(
name|x
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
else|else
block|{
name|y
operator|=
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|copy_to_reg
argument_list|(
name|y
argument_list|)
argument_list|,
name|constant_term
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|memory_address_p
argument_list|(
name|mode
argument_list|,
name|y
argument_list|)
condition|)
name|x
operator|=
name|force_operand
argument_list|(
name|x
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
else|else
name|x
operator|=
name|y
expr_stmt|;
block|}
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MULT
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MINUS
condition|)
name|x
operator|=
name|force_operand
argument_list|(
name|x
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
comment|/* If we have a register that's an invalid address, 	 it must be a hard reg of the wrong class.  Copy it to a pseudo.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
name|x
operator|=
name|copy_to_reg
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* Last resort: copy the value to a register, since 	 the register is a valid address.  */
else|else
name|x
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|x
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
name|win2
label|:
name|x
operator|=
name|oldx
expr_stmt|;
name|win
label|:
if|if
condition|(
name|flag_force_addr
operator|&&
operator|!
name|cse_not_expected
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
comment|/* Don't copy an addr via a reg if it is one of our stack slots.  */
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
operator|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|virtual_stack_vars_rtx
operator|||
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|virtual_incoming_args_rtx
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|general_operand
argument_list|(
name|x
argument_list|,
name|Pmode
argument_list|)
condition|)
name|x
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|x
argument_list|)
expr_stmt|;
else|else
name|x
operator|=
name|force_operand
argument_list|(
name|x
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
block|}
name|done
label|:
comment|/* If we didn't change the address, we are done.  Otherwise, mark      a reg as a pointer if we have REG or REG + CONST_INT.  */
if|if
condition|(
name|oldx
operator|==
name|x
condition|)
return|return
name|x
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
name|mark_reg_pointer
argument_list|(
name|x
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
name|mark_reg_pointer
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* OLDX may have been the address on a temporary.  Update the address      to indicate that X is now used.  */
name|update_temp_slot_address
argument_list|(
name|oldx
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Like `memory_address' but pretend `flag_force_addr' is 0.  */
end_comment

begin_function
name|rtx
name|memory_address_noforce
parameter_list|(
name|mode
parameter_list|,
name|x
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
name|int
name|ambient_force_addr
init|=
name|flag_force_addr
decl_stmt|;
name|rtx
name|val
decl_stmt|;
name|flag_force_addr
operator|=
literal|0
expr_stmt|;
name|val
operator|=
name|memory_address
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|flag_force_addr
operator|=
name|ambient_force_addr
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Convert a mem ref into one with a valid memory address.    Pass through anything else unchanged.  */
end_comment

begin_function
name|rtx
name|validize_mem
parameter_list|(
name|ref
parameter_list|)
name|rtx
name|ref
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|ref
argument_list|)
operator|!=
name|MEM
condition|)
return|return
name|ref
return|;
if|if
condition|(
name|memory_address_p
argument_list|(
name|GET_MODE
argument_list|(
name|ref
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|ref
return|;
comment|/* Don't alter REF itself, since that is probably a stack slot.  */
return|return
name|change_address
argument_list|(
name|ref
argument_list|,
name|GET_MODE
argument_list|(
name|ref
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a modified copy of X with its memory address copied    into a temporary register to protect it from side effects.    If X is not a MEM, it is returned unchanged (and not copied).    Perhaps even if it is a MEM, if there is no need to change it.  */
end_comment

begin_function
name|rtx
name|stabilize
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|rtx
name|addr
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
condition|)
return|return
name|x
return|;
name|addr
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtx_unstable_p
argument_list|(
name|addr
argument_list|)
condition|)
block|{
name|rtx
name|temp
init|=
name|copy_all_regs
argument_list|(
name|addr
argument_list|)
decl_stmt|;
name|rtx
name|mem
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|!=
name|REG
condition|)
name|temp
operator|=
name|copy_to_reg
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
comment|/* Mark returned memref with in_struct if it's in an array or 	 structure.  Copy const and volatile from original memref.  */
name|MEM_IN_STRUCT_P
argument_list|(
name|mem
argument_list|)
operator|=
name|MEM_IN_STRUCT_P
argument_list|(
name|x
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|mem
argument_list|)
operator|=
name|RTX_UNCHANGING_P
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|mem
argument_list|)
operator|=
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
name|mem
return|;
block|}
return|return
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Copy the value or contents of X to a new temp reg and return that reg.  */
end_comment

begin_function
name|rtx
name|copy_to_reg
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|rtx
name|temp
init|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
comment|/* If not an operand, must be an address with PLUS and MULT so      do the computation.  */
if|if
condition|(
operator|!
name|general_operand
argument_list|(
name|x
argument_list|,
name|VOIDmode
argument_list|)
condition|)
name|x
operator|=
name|force_operand
argument_list|(
name|x
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|temp
condition|)
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
end_function

begin_comment
comment|/* Like copy_to_reg but always give the new register mode Pmode    in case X is a constant.  */
end_comment

begin_function
name|rtx
name|copy_addr_to_reg
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
return|return
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|x
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Like copy_to_reg but always give the new register mode MODE    in case X is a constant.  */
end_comment

begin_function
name|rtx
name|copy_to_mode_reg
parameter_list|(
name|mode
parameter_list|,
name|x
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|rtx
name|temp
init|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
decl_stmt|;
comment|/* If not an operand, must be an address with PLUS and MULT so      do the computation.  */
if|if
condition|(
operator|!
name|general_operand
argument_list|(
name|x
argument_list|,
name|VOIDmode
argument_list|)
condition|)
name|x
operator|=
name|force_operand
argument_list|(
name|x
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|mode
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|VOIDmode
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|temp
condition|)
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
end_function

begin_comment
comment|/* Load X into a register if it is not already one.    Use mode MODE for the register.    X should be valid for mode MODE, but it may be a constant which    is valid for all integer modes; that's why caller must specify MODE.     The caller must not alter the value in the register we return,    since we mark it as a "constant" register.  */
end_comment

begin_function
name|rtx
name|force_reg
parameter_list|(
name|mode
parameter_list|,
name|x
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|rtx
name|temp
decl_stmt|,
name|insn
decl_stmt|,
name|set
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
return|return
name|x
return|;
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* Let optimizers know that TEMP's value never changes      and that X can be substituted for it.  Don't get confused      if INSN set something else (such as a SUBREG of TEMP).  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
operator|&&
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|==
name|temp
condition|)
block|{
name|rtx
name|note
init|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
if|if
condition|(
name|note
condition|)
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
operator|=
name|x
expr_stmt|;
else|else
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|REG_EQUAL
argument_list|,
name|x
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|temp
return|;
block|}
end_function

begin_comment
comment|/* If X is a memory ref, copy its contents to a new temp reg and return    that reg.  Otherwise, return X.  */
end_comment

begin_function
name|rtx
name|force_not_mem
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|rtx
name|temp
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
operator|||
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|BLKmode
condition|)
return|return
name|x
return|;
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
end_function

begin_comment
comment|/* Copy X to TARGET (if it's nonzero and a reg)    or to a new temp reg and return that reg.    MODE is the mode to use for X in case it is a constant.  */
end_comment

begin_function
name|rtx
name|copy_to_suggested_reg
parameter_list|(
name|x
parameter_list|,
name|target
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|target
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
specifier|register
name|rtx
name|temp
decl_stmt|;
if|if
condition|(
name|target
operator|&&
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|REG
condition|)
name|temp
operator|=
name|target
expr_stmt|;
else|else
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the mode to use to store a scalar of TYPE and MODE.    PUNSIGNEDP points to the signedness of the type and may be adjusted    to show what signedness to use on extension operations.     FOR_CALL is non-zero if this call is promoting args for a call.  */
end_comment

begin_function
name|enum
name|machine_mode
name|promote_mode
parameter_list|(
name|type
parameter_list|,
name|mode
parameter_list|,
name|punsignedp
parameter_list|,
name|for_call
parameter_list|)
name|tree
name|type
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
modifier|*
name|punsignedp
decl_stmt|;
name|int
name|for_call
decl_stmt|;
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|unsignedp
init|=
operator|*
name|punsignedp
decl_stmt|;
ifdef|#
directive|ifdef
name|PROMOTE_FOR_CALL_ONLY
if|if
condition|(
operator|!
name|for_call
condition|)
return|return
name|mode
return|;
endif|#
directive|endif
switch|switch
condition|(
name|code
condition|)
block|{
ifdef|#
directive|ifdef
name|PROMOTE_MODE
case|case
name|INTEGER_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
case|case
name|CHAR_TYPE
case|:
case|case
name|REAL_TYPE
case|:
case|case
name|OFFSET_TYPE
case|:
name|PROMOTE_MODE
argument_list|(
name|mode
argument_list|,
name|unsignedp
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|POINTER_TYPE
case|:
break|break;
default|default:
break|break;
block|}
operator|*
name|punsignedp
operator|=
name|unsignedp
expr_stmt|;
return|return
name|mode
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Adjust the stack pointer by ADJUST (an rtx for a number of bytes).    This pops when ADJUST is positive.  ADJUST need not be constant.  */
end_comment

begin_function
name|void
name|adjust_stack
parameter_list|(
name|adjust
parameter_list|)
name|rtx
name|adjust
decl_stmt|;
block|{
name|rtx
name|temp
decl_stmt|;
name|adjust
operator|=
name|protect_from_queue
argument_list|(
name|adjust
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|adjust
operator|==
name|const0_rtx
condition|)
return|return;
name|temp
operator|=
name|expand_binop
argument_list|(
name|Pmode
argument_list|,
ifdef|#
directive|ifdef
name|STACK_GROWS_DOWNWARD
name|add_optab
argument_list|,
else|#
directive|else
name|sub_optab
argument_list|,
endif|#
directive|endif
name|stack_pointer_rtx
argument_list|,
name|adjust
argument_list|,
name|stack_pointer_rtx
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
name|stack_pointer_rtx
condition|)
name|emit_move_insn
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Adjust the stack pointer by minus ADJUST (an rtx for a number of bytes).    This pushes when ADJUST is positive.  ADJUST need not be constant.  */
end_comment

begin_function
name|void
name|anti_adjust_stack
parameter_list|(
name|adjust
parameter_list|)
name|rtx
name|adjust
decl_stmt|;
block|{
name|rtx
name|temp
decl_stmt|;
name|adjust
operator|=
name|protect_from_queue
argument_list|(
name|adjust
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|adjust
operator|==
name|const0_rtx
condition|)
return|return;
name|temp
operator|=
name|expand_binop
argument_list|(
name|Pmode
argument_list|,
ifdef|#
directive|ifdef
name|STACK_GROWS_DOWNWARD
name|sub_optab
argument_list|,
else|#
directive|else
name|add_optab
argument_list|,
endif|#
directive|endif
name|stack_pointer_rtx
argument_list|,
name|adjust
argument_list|,
name|stack_pointer_rtx
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
name|stack_pointer_rtx
condition|)
name|emit_move_insn
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Round the size of a block to be pushed up to the boundary required    by this machine.  SIZE is the desired size, which need not be constant.  */
end_comment

begin_function
name|rtx
name|round_push
parameter_list|(
name|size
parameter_list|)
name|rtx
name|size
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|STACK_BOUNDARY
name|int
name|align
init|=
name|STACK_BOUNDARY
operator|/
name|BITS_PER_UNIT
decl_stmt|;
if|if
condition|(
name|align
operator|==
literal|1
condition|)
return|return
name|size
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|int
name|new
init|=
operator|(
name|INTVAL
argument_list|(
name|size
argument_list|)
operator|+
name|align
operator|-
literal|1
operator|)
operator|/
name|align
operator|*
name|align
decl_stmt|;
if|if
condition|(
name|INTVAL
argument_list|(
name|size
argument_list|)
operator|!=
name|new
condition|)
name|size
operator|=
name|GEN_INT
argument_list|(
name|new
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* CEIL_DIV_EXPR needs to worry about the addition overflowing, 	 but we know it can't.  So add ourselves and then do TRUNC_DIV_EXPR. */
name|size
operator|=
name|expand_binop
argument_list|(
name|Pmode
argument_list|,
name|add_optab
argument_list|,
name|size
argument_list|,
name|GEN_INT
argument_list|(
name|align
operator|-
literal|1
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
name|size
operator|=
name|expand_divmod
argument_list|(
literal|0
argument_list|,
name|TRUNC_DIV_EXPR
argument_list|,
name|Pmode
argument_list|,
name|size
argument_list|,
name|GEN_INT
argument_list|(
name|align
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|size
operator|=
name|expand_mult
argument_list|(
name|Pmode
argument_list|,
name|size
argument_list|,
name|GEN_INT
argument_list|(
name|align
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* STACK_BOUNDARY */
return|return
name|size
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Save the stack pointer for the purpose in SAVE_LEVEL.  PSAVE is a pointer    to a previously-created save area.  If no save area has been allocated,    this function will allocate one.  If a save area is specified, it    must be of the proper mode.     The insns are emitted after insn AFTER, if nonzero, otherwise the insns    are emitted at the current position.  */
end_comment

begin_function
name|void
name|emit_stack_save
parameter_list|(
name|save_level
parameter_list|,
name|psave
parameter_list|,
name|after
parameter_list|)
name|enum
name|save_level
name|save_level
decl_stmt|;
name|rtx
modifier|*
name|psave
decl_stmt|;
name|rtx
name|after
decl_stmt|;
block|{
name|rtx
name|sa
init|=
operator|*
name|psave
decl_stmt|;
comment|/* The default is that we use a move insn and save in a Pmode object.  */
name|rtx
function_decl|(
modifier|*
name|fcn
function_decl|)
parameter_list|()
init|=
name|gen_move_insn
function_decl|;
name|enum
name|machine_mode
name|mode
init|=
name|Pmode
decl_stmt|;
comment|/* See if this machine has anything special to do for this kind of save.  */
switch|switch
condition|(
name|save_level
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_save_stack_block
case|case
name|SAVE_BLOCK
case|:
if|if
condition|(
name|HAVE_save_stack_block
condition|)
block|{
name|fcn
operator|=
name|gen_save_stack_block
expr_stmt|;
name|mode
operator|=
name|insn_operand_mode
index|[
name|CODE_FOR_save_stack_block
index|]
index|[
literal|0
index|]
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_save_stack_function
case|case
name|SAVE_FUNCTION
case|:
if|if
condition|(
name|HAVE_save_stack_function
condition|)
block|{
name|fcn
operator|=
name|gen_save_stack_function
expr_stmt|;
name|mode
operator|=
name|insn_operand_mode
index|[
name|CODE_FOR_save_stack_function
index|]
index|[
literal|0
index|]
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_save_stack_nonlocal
case|case
name|SAVE_NONLOCAL
case|:
if|if
condition|(
name|HAVE_save_stack_nonlocal
condition|)
block|{
name|fcn
operator|=
name|gen_save_stack_nonlocal
expr_stmt|;
name|mode
operator|=
name|insn_operand_mode
index|[
operator|(
name|int
operator|)
name|CODE_FOR_save_stack_nonlocal
index|]
index|[
literal|0
index|]
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
default|default:
break|break;
block|}
comment|/* If there is no save area and we have to allocate one, do so.  Otherwise      verify the save area is the proper mode.  */
if|if
condition|(
name|sa
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
condition|)
block|{
if|if
condition|(
name|save_level
operator|==
name|SAVE_NONLOCAL
condition|)
operator|*
name|psave
operator|=
name|sa
operator|=
name|assign_stack_local
argument_list|(
name|mode
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
operator|*
name|psave
operator|=
name|sa
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|mode
operator|==
name|VOIDmode
operator|||
name|GET_MODE
argument_list|(
name|sa
argument_list|)
operator|!=
name|mode
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|after
condition|)
block|{
name|rtx
name|seq
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* We must validize inside the sequence, to ensure that any instructions 	 created by the validize call also get moved to the right place.  */
if|if
condition|(
name|sa
operator|!=
literal|0
condition|)
name|sa
operator|=
name|validize_mem
argument_list|(
name|sa
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|fcn
argument_list|(
name|sa
argument_list|,
name|stack_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|seq
operator|=
name|gen_sequence
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insn_after
argument_list|(
name|seq
argument_list|,
name|after
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sa
operator|!=
literal|0
condition|)
name|sa
operator|=
name|validize_mem
argument_list|(
name|sa
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|fcn
argument_list|(
name|sa
argument_list|,
name|stack_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Restore the stack pointer for the purpose in SAVE_LEVEL.  SA is the save    area made by emit_stack_save.  If it is zero, we have nothing to do.     Put any emitted insns after insn AFTER, if nonzero, otherwise at    current position.  */
end_comment

begin_function
name|void
name|emit_stack_restore
parameter_list|(
name|save_level
parameter_list|,
name|sa
parameter_list|,
name|after
parameter_list|)
name|enum
name|save_level
name|save_level
decl_stmt|;
name|rtx
name|after
decl_stmt|;
name|rtx
name|sa
decl_stmt|;
block|{
comment|/* The default is that we use a move insn.  */
name|rtx
function_decl|(
modifier|*
name|fcn
function_decl|)
parameter_list|()
init|=
name|gen_move_insn
function_decl|;
comment|/* See if this machine has anything special to do for this kind of save.  */
switch|switch
condition|(
name|save_level
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_restore_stack_block
case|case
name|SAVE_BLOCK
case|:
if|if
condition|(
name|HAVE_restore_stack_block
condition|)
name|fcn
operator|=
name|gen_restore_stack_block
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_restore_stack_function
case|case
name|SAVE_FUNCTION
case|:
if|if
condition|(
name|HAVE_restore_stack_function
condition|)
name|fcn
operator|=
name|gen_restore_stack_function
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_restore_stack_nonlocal
case|case
name|SAVE_NONLOCAL
case|:
if|if
condition|(
name|HAVE_restore_stack_nonlocal
condition|)
name|fcn
operator|=
name|gen_restore_stack_nonlocal
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
break|break;
block|}
if|if
condition|(
name|sa
operator|!=
literal|0
condition|)
name|sa
operator|=
name|validize_mem
argument_list|(
name|sa
argument_list|)
expr_stmt|;
if|if
condition|(
name|after
condition|)
block|{
name|rtx
name|seq
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|emit_insn
argument_list|(
name|fcn
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|sa
argument_list|)
argument_list|)
expr_stmt|;
name|seq
operator|=
name|gen_sequence
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insn_after
argument_list|(
name|seq
argument_list|,
name|after
argument_list|)
expr_stmt|;
block|}
else|else
name|emit_insn
argument_list|(
name|fcn
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|sa
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return an rtx representing the address of an area of memory dynamically    pushed on the stack.  This region of memory is always aligned to    a multiple of BIGGEST_ALIGNMENT.     Any required stack pointer alignment is preserved.     SIZE is an rtx representing the size of the area.    TARGET is a place in which the address can be placed.     KNOWN_ALIGN is the alignment (in bits) that we know SIZE has.  */
end_comment

begin_function
name|rtx
name|allocate_dynamic_stack_space
parameter_list|(
name|size
parameter_list|,
name|target
parameter_list|,
name|known_align
parameter_list|)
name|rtx
name|size
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|int
name|known_align
decl_stmt|;
block|{
comment|/* If we're asking for zero bytes, it doesn't matter what we point      to since we can't derefference it.  But return a reasonable      address anyway.  */
if|if
condition|(
name|size
operator|==
name|const0_rtx
condition|)
return|return
name|virtual_stack_dynamic_rtx
return|;
comment|/* Otherwise, show we're calling alloca or equivalent.  */
name|current_function_calls_alloca
operator|=
literal|1
expr_stmt|;
comment|/* Ensure the size is in the proper mode.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|size
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|size
argument_list|)
operator|!=
name|Pmode
condition|)
name|size
operator|=
name|convert_to_mode
argument_list|(
name|Pmode
argument_list|,
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* We will need to ensure that the address we return is aligned to      BIGGEST_ALIGNMENT.  If STACK_DYNAMIC_OFFSET is defined, we don't      always know its final value at this point in the compilation (it      might depend on the size of the outgoing parameter lists, for      example), so we must align the value to be returned in that case.      (Note that STACK_DYNAMIC_OFFSET will have a default non-zero value if      STACK_POINTER_OFFSET or ACCUMULATE_OUTGOING_ARGS are defined).      We must also do an alignment operation on the returned value if      the stack pointer alignment is less strict that BIGGEST_ALIGNMENT.       If we have to align, we must leave space in SIZE for the hole      that might result from the alignment operation.  */
if|#
directive|if
name|defined
argument_list|(
name|STACK_DYNAMIC_OFFSET
argument_list|)
operator|||
name|defined
argument_list|(
name|STACK_POINTER_OFFSET
argument_list|)
operator|||
name|defined
argument_list|(
name|ALLOCATE_OUTGOING_ARGS
argument_list|)
define|#
directive|define
name|MUST_ALIGN
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MUST_ALIGN
argument_list|)
operator|&&
operator|(
operator|!
name|defined
argument_list|(
name|STACK_BOUNDARY
argument_list|)
operator|||
name|STACK_BOUNDARY
operator|<
name|BIGGEST_ALIGNMENT
operator|)
define|#
directive|define
name|MUST_ALIGN
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MUST_ALIGN
if|#
directive|if
literal|0
comment|/* It turns out we must always make extra space, if MUST_ALIGN 	 because we must always round the address up at the end, 	 because we don't know whether the dynamic offset 	 will mess up the desired alignment.  */
comment|/* If we have to round the address up regardless of known_align,      make extra space regardless, also.  */
block|if (known_align % BIGGEST_ALIGNMENT != 0)
endif|#
directive|endif
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|CONST_INT
condition|)
name|size
operator|=
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|size
argument_list|)
operator|+
operator|(
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
else|else
name|size
operator|=
name|expand_binop
argument_list|(
name|Pmode
argument_list|,
name|add_optab
argument_list|,
name|size
argument_list|,
name|GEN_INT
argument_list|(
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
operator|-
literal|1
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SETJMP_VIA_SAVE_AREA
comment|/* If setjmp restores regs from a save area in the stack frame,      avoid clobbering the reg save area.  Note that the offset of      virtual_incoming_args_rtx includes the preallocated stack args space.      It would be no problem to clobber that, but it's on the wrong side      of the old save area.  */
block|{
name|rtx
name|dynamic_offset
init|=
name|expand_binop
argument_list|(
name|Pmode
argument_list|,
name|sub_optab
argument_list|,
name|virtual_stack_dynamic_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
decl_stmt|;
name|size
operator|=
name|expand_binop
argument_list|(
name|Pmode
argument_list|,
name|add_optab
argument_list|,
name|size
argument_list|,
name|dynamic_offset
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SETJMP_VIA_SAVE_AREA */
comment|/* Round the size to a multiple of the required stack alignment.      Since the stack if presumed to be rounded before this allocation,      this will maintain the required alignment.       If the stack grows downward, we could save an insn by subtracting      SIZE from the stack pointer and then aligning the stack pointer.      The problem with this is that the stack pointer may be unaligned      between the execution of the subtraction and alignment insns and      some machines do not allow this.  Even on those that do, some      signal handlers malfunction if a signal should occur between those      insns.  Since this is an extremely rare event, we have no reliable      way of knowing which systems have this problem.  So we avoid even      momentarily mis-aligning the stack.  */
ifdef|#
directive|ifdef
name|STACK_BOUNDARY
comment|/* If we added a variable amount to SIZE,      we can no longer assume it is aligned.  */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SETJMP_VIA_SAVE_AREA
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|MUST_ALIGN
argument_list|)
if|if
condition|(
name|known_align
operator|%
name|STACK_BOUNDARY
operator|!=
literal|0
condition|)
endif|#
directive|endif
name|size
operator|=
name|round_push
argument_list|(
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
comment|/* Don't use a TARGET that isn't a pseudo.  */
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|target
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|mark_reg_pointer
argument_list|(
name|target
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|STACK_GROWS_DOWNWARD
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|virtual_stack_dynamic_rtx
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Perform the required allocation from the stack.  Some systems do      this differently than simply incrementing/decrementing from the      stack pointer.  */
ifdef|#
directive|ifdef
name|HAVE_allocate_stack
if|if
condition|(
name|HAVE_allocate_stack
condition|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|insn_operand_mode
index|[
operator|(
name|int
operator|)
name|CODE_FOR_allocate_stack
index|]
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|CODE_FOR_allocate_stack
index|]
index|[
literal|0
index|]
operator|&&
operator|!
operator|(
call|(
modifier|*
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|CODE_FOR_allocate_stack
index|]
index|[
literal|0
index|]
call|)
argument_list|(
name|size
argument_list|,
name|mode
argument_list|)
operator|)
condition|)
name|size
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_allocate_stack
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|anti_adjust_stack
argument_list|(
name|size
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|STACK_GROWS_DOWNWARD
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|virtual_stack_dynamic_rtx
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MUST_ALIGN
if|#
directive|if
literal|0
comment|/* Even if we know the stack pointer has enough alignment, 	  there's no way to tell whether virtual_stack_dynamic_rtx shares that 	  alignment, so we still need to round the address up.  */
block|if (known_align % BIGGEST_ALIGNMENT != 0)
endif|#
directive|endif
block|{
comment|/* CEIL_DIV_EXPR needs to worry about the addition overflowing, 	 but we know it can't.  So add ourselves and then do TRUNC_DIV_EXPR. */
name|target
operator|=
name|expand_binop
argument_list|(
name|Pmode
argument_list|,
name|add_optab
argument_list|,
name|target
argument_list|,
name|GEN_INT
argument_list|(
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
operator|-
literal|1
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
name|target
operator|=
name|expand_divmod
argument_list|(
literal|0
argument_list|,
name|TRUNC_DIV_EXPR
argument_list|,
name|Pmode
argument_list|,
name|target
argument_list|,
name|GEN_INT
argument_list|(
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|target
operator|=
name|expand_mult
argument_list|(
name|Pmode
argument_list|,
name|target
argument_list|,
name|GEN_INT
argument_list|(
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Some systems require a particular insn to refer to the stack      to make the pages exist.  */
ifdef|#
directive|ifdef
name|HAVE_probe
if|if
condition|(
name|HAVE_probe
condition|)
name|emit_insn
argument_list|(
name|gen_probe
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Record the new stack level for nonlocal gotos.  */
if|if
condition|(
name|nonlocal_goto_handler_slot
operator|!=
literal|0
condition|)
name|emit_stack_save
argument_list|(
name|SAVE_NONLOCAL
argument_list|,
operator|&
name|nonlocal_goto_stack_level
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return an rtx representing the register or memory location    in which a scalar value of data type VALTYPE    was returned by a function call to function FUNC.    FUNC is a FUNCTION_DECL node if the precise function is known,    otherwise 0.  */
end_comment

begin_function
name|rtx
name|hard_function_value
parameter_list|(
name|valtype
parameter_list|,
name|func
parameter_list|)
name|tree
name|valtype
decl_stmt|;
name|tree
name|func
decl_stmt|;
block|{
return|return
name|FUNCTION_VALUE
argument_list|(
name|valtype
argument_list|,
name|func
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return an rtx representing the register or memory location    in which a scalar value of mode MODE was returned by a library call.  */
end_comment

begin_function
name|rtx
name|hard_libcall_value
parameter_list|(
name|mode
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
name|LIBCALL_VALUE
argument_list|(
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Look up the tree code for a given rtx code    to provide the arithmetic operation for REAL_ARITHMETIC.    The function returns an int because the caller may not know    what `enum tree_code' means.  */
end_comment

begin_function
name|int
name|rtx_to_tree_code
parameter_list|(
name|code
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
block|{
name|enum
name|tree_code
name|tcode
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PLUS
case|:
name|tcode
operator|=
name|PLUS_EXPR
expr_stmt|;
break|break;
case|case
name|MINUS
case|:
name|tcode
operator|=
name|MINUS_EXPR
expr_stmt|;
break|break;
case|case
name|MULT
case|:
name|tcode
operator|=
name|MULT_EXPR
expr_stmt|;
break|break;
case|case
name|DIV
case|:
name|tcode
operator|=
name|RDIV_EXPR
expr_stmt|;
break|break;
case|case
name|SMIN
case|:
name|tcode
operator|=
name|MIN_EXPR
expr_stmt|;
break|break;
case|case
name|SMAX
case|:
name|tcode
operator|=
name|MAX_EXPR
expr_stmt|;
break|break;
default|default:
name|tcode
operator|=
name|LAST_AND_UNUSED_TREE_CODE
expr_stmt|;
break|break;
block|}
return|return
operator|(
operator|(
name|int
operator|)
name|tcode
operator|)
return|;
block|}
end_function

end_unit

