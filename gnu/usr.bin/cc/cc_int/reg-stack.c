begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Register to Stack convert for GNU compiler.    Copyright (C) 1992, 1993, 1994 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* This pass converts stack-like registers from the "flat register    file" model that gcc uses, to a stack convention that the 387 uses.     * The form of the input:     On input, the function consists of insn that have had their    registers fully allocated to a set of "virtual" registers.  Note that    the word "virtual" is used differently here than elsewhere in gcc: for    each virtual stack reg, there is a hard reg, but the mapping between    them is not known until this pass is run.  On output, hard register    numbers have been substituted, and various pop and exchange insns have    been emitted.  The hard register numbers and the virtual register    numbers completely overlap - before this pass, all stack register    numbers are virtual, and afterward they are all hard.     The virtual registers can be manipulated normally by gcc, and their    semantics are the same as for normal registers.  After the hard    register numbers are substituted, the semantics of an insn containing    stack-like regs are not the same as for an insn with normal regs: for    instance, it is not safe to delete an insn that appears to be a no-op    move.  In general, no insn containing hard regs should be changed    after this pass is done.     * The form of the output:     After this pass, hard register numbers represent the distance from    the current top of stack to the desired register.  A reference to    FIRST_STACK_REG references the top of stack, FIRST_STACK_REG + 1,    represents the register just below that, and so forth.  Also, REG_DEAD    notes indicate whether or not a stack register should be popped.     A "swap" insn looks like a parallel of two patterns, where each    pattern is a SET: one sets A to B, the other B to A.     A "push" or "load" insn is a SET whose SET_DEST is FIRST_STACK_REG    and whose SET_DEST is REG or MEM.  Any other SET_DEST, such as PLUS,    will replace the existing stack top, not push a new value.     A store insn is a SET whose SET_DEST is FIRST_STACK_REG, and whose    SET_SRC is REG or MEM.     The case where the SET_SRC and SET_DEST are both FIRST_STACK_REG    appears ambiguous.  As a special case, the presence of a REG_DEAD note    for FIRST_STACK_REG differentiates between a load insn and a pop.     If a REG_DEAD is present, the insn represents a "pop" that discards    the top of the register stack.  If there is no REG_DEAD note, then the    insn represents a "dup" or a push of the current top of stack onto the    stack.     * Methodology:     Existing REG_DEAD and REG_UNUSED notes for stack registers are    deleted and recreated from scratch.  REG_DEAD is never created for a    SET_DEST, only REG_UNUSED.     Before life analysis, the mode of each insn is set based on whether    or not any stack registers are mentioned within that insn.  VOIDmode    means that no regs are mentioned anyway, and QImode means that at    least one pattern within the insn mentions stack registers.  This    information is valid until after reg_to_stack returns, and is used    from jump_optimize.     * asm_operands:     There are several rules on the usage of stack-like regs in    asm_operands insns.  These rules apply only to the operands that are    stack-like regs:     1. Given a set of input regs that die in an asm_operands, it is       necessary to know which are implicitly popped by the asm, and       which must be explicitly popped by gcc.  	An input reg that is implicitly popped by the asm must be 	explicitly clobbered, unless it is constrained to match an 	output operand.     2. For any input reg that is implicitly popped by an asm, it is       necessary to know how to adjust the stack to compensate for the pop.       If any non-popped input is closer to the top of the reg-stack than       the implicitly popped reg, it would not be possible to know what the       stack looked like - it's not clear how the rest of the stack "slides       up".  	All implicitly popped input regs must be closer to the top of 	the reg-stack than any input that is not implicitly popped.     3. It is possible that if an input dies in an insn, reload might       use the input reg for an output reload.  Consider this example:  		asm ("foo" : "=t" (a) : "f" (b));        This asm says that input B is not popped by the asm, and that       the asm pushes a result onto the reg-stack, ie, the stack is one       deeper after the asm than it was before.  But, it is possible that       reload will think that it can use the same reg for both the input and       the output, if input B dies in this insn.  	If any input operand uses the "f" constraint, all output reg 	constraints must use the "&" earlyclobber.        The asm above would be written as  		asm ("foo" : "=&t" (a) : "f" (b));     4. Some operands need to be in particular places on the stack.  All       output operands fall in this category - there is no other way to       know which regs the outputs appear in unless the user indicates       this in the constraints.  	Output operands must specifically indicate which reg an output 	appears in after an asm.  "=f" is not allowed: the operand 	constraints must select a class with a single reg.     5. Output operands may not be "inserted" between existing stack regs.       Since no 387 opcode uses a read/write operand, all output operands       are dead before the asm_operands, and are pushed by the asm_operands.       It makes no sense to push anywhere but the top of the reg-stack.  	Output operands must start at the top of the reg-stack: output 	operands may not "skip" a reg.     6. Some asm statements may need extra stack space for internal       calculations.  This can be guaranteed by clobbering stack registers       unrelated to the inputs and outputs.     Here are a couple of reasonable asms to want to write.  This asm    takes one input, which is internally popped, and produces two outputs.  	asm ("fsincos" : "=t" (cos), "=u" (sin) : "0" (inp));     This asm takes two inputs, which are popped by the fyl2xp1 opcode,    and replaces them with one output.  The user must code the "st(1)"    clobber for reg-stack.c to know that fyl2xp1 pops both inputs.  	asm ("fyl2xp1" : "=t" (result) : "0" (x), "u" (y) : "st(1)");     */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|STACK_REGS
end_ifdef

begin_define
define|#
directive|define
name|REG_STACK_SIZE
value|(LAST_STACK_REG - FIRST_STACK_REG + 1)
end_define

begin_comment
comment|/* True if the current function returns a real value. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|current_function_returns_real
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the basic stack record.  TOP is an index into REG[] such    that REG[TOP] is the top of stack.  If TOP is -1 the stack is empty.     If TOP is -2, REG[] is not yet initialized.  Stack initialization    consists of placing each live reg in array `reg' and setting `top'    appropriately.     REG_SET indicates which registers are live.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|stack_def
block|{
name|int
name|top
decl_stmt|;
comment|/* index to top stack element */
name|HARD_REG_SET
name|reg_set
decl_stmt|;
comment|/* set of live registers */
name|char
name|reg
index|[
name|REG_STACK_SIZE
index|]
decl_stmt|;
comment|/* register - stack mapping */
block|}
typedef|*
name|stack
typedef|;
end_typedef

begin_comment
comment|/* highest instruction uid */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_uid
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of basic blocks in the current function.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|blocks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Element N is first insn in basic block N.    This info lasts until we finish compiling the function.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|block_begin
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Element N is last insn in basic block N.    This info lasts until we finish compiling the function.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|block_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Element N is nonzero if control can drop into basic block N */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|block_drops_in
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Element N says all about the stack at entry block N */
end_comment

begin_decl_stmt
specifier|static
name|stack
name|block_stack_in
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Element N says all about the stack life at the end of block N */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
modifier|*
name|block_out_reg_set
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is where the BLOCK_NUM values are really stored.  This is set    up by find_blocks and used there and in life_analysis.  It can be used    later, but only to look up an insn that is the head or tail of some    block.  life_analysis and the stack register conversion process can    add insns within a block. */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|block_number
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the register file for all register after conversion */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|FP_mode_reg
index|[
name|FIRST_PSEUDO_REGISTER
index|]
index|[
operator|(
name|int
operator|)
name|MAX_MACHINE_MODE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Get the basic block number of an insn.  See note at block_number    definition are validity of this information. */
end_comment

begin_define
define|#
directive|define
name|BLOCK_NUM
parameter_list|(
name|INSN
parameter_list|)
define|\
value|(((INSN_UID (INSN)> max_uid)	\     ? (int *)(abort() , 0)		\     : block_number)[INSN_UID (INSN)])
end_define

begin_decl_stmt
specifier|extern
name|rtx
name|forced_labels
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|rtx
name|gen_jump
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|rtx
name|gen_movdf
argument_list|()
decl_stmt|,
name|gen_movxf
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|rtx
name|find_regno_note
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|rtx
name|emit_jump_insn_before
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|rtx
name|emit_label_after
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Forward declarations */
end_comment

begin_function_decl
specifier|static
name|void
name|find_blocks
parameter_list|()
function_decl|;
end_function_decl

begin_expr_stmt
specifier|static
name|uses_reg_or_mem
argument_list|()
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|void
name|stack_reg_life_analysis
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|change_stack
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|convert_regs
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_stack_info
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Return non-zero if any stack register is mentioned somewhere within PAT.  */
end_comment

begin_function
name|int
name|stack_regs_mentioned_p
parameter_list|(
name|pat
parameter_list|)
name|rtx
name|pat
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|STACK_REG_P
argument_list|(
name|pat
argument_list|)
condition|)
return|return
literal|1
return|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|pat
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|stack_regs_mentioned_p
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|&&
name|stack_regs_mentioned_p
argument_list|(
name|XEXP
argument_list|(
name|pat
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Convert register usage from "flat" register file usage to a "stack    register file.  FIRST is the first insn in the function, FILE is the    dump file, if used.     First compute the beginning and end of each basic block.  Do a    register life analysis on the stack registers, recording the result    for the head and tail of each basic block.  The convert each insn one    by one.  Run a last jump_optimize() pass, if optimizing, to eliminate    any cross-jumping created when the converter inserts pop insns.*/
end_comment

begin_function
name|void
name|reg_to_stack
parameter_list|(
name|first
parameter_list|,
name|file
parameter_list|)
name|rtx
name|first
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
specifier|register
name|rtx
name|insn
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|stack_reg_seen
init|=
literal|0
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|current_function_returns_real
operator|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REAL_TYPE
expr_stmt|;
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_FLOAT
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
name|FP_mode_reg
index|[
name|i
index|]
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|mode
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Count the basic blocks.  Also find maximum insn uid.  */
block|{
specifier|register
name|RTX_CODE
name|prev_code
init|=
name|BARRIER
decl_stmt|;
specifier|register
name|RTX_CODE
name|code
decl_stmt|;
name|max_uid
operator|=
literal|0
expr_stmt|;
name|blocks
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|first
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
comment|/* Note that this loop must select the same block boundaries 	   as code in find_blocks.  Also note that this code is not the 	   same as that used in flow.c.  */
if|if
condition|(
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|>
name|max_uid
condition|)
name|max_uid
operator|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|CODE_LABEL
operator|||
operator|(
name|prev_code
operator|!=
name|INSN
operator|&&
name|prev_code
operator|!=
name|CALL_INSN
operator|&&
name|prev_code
operator|!=
name|CODE_LABEL
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'i'
operator|)
condition|)
name|blocks
operator|++
expr_stmt|;
comment|/* Remember whether or not this insn mentions an FP regs. 	   Check JUMP_INSNs too, in case someone creates a funny PARALLEL. */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
operator|&&
name|stack_regs_mentioned_p
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
block|{
name|stack_reg_seen
operator|=
literal|1
expr_stmt|;
name|PUT_MODE
argument_list|(
name|insn
argument_list|,
name|QImode
argument_list|)
expr_stmt|;
block|}
else|else
name|PUT_MODE
argument_list|(
name|insn
argument_list|,
name|VOIDmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|CODE_LABEL
condition|)
name|LABEL_REFS
argument_list|(
name|insn
argument_list|)
operator|=
name|insn
expr_stmt|;
comment|/* delete old chain */
if|if
condition|(
name|code
operator|!=
name|NOTE
condition|)
name|prev_code
operator|=
name|code
expr_stmt|;
block|}
block|}
comment|/* If no stack register reference exists in this insn, there isn't      anything to convert.  */
if|if
condition|(
operator|!
name|stack_reg_seen
condition|)
return|return;
comment|/* If there are stack registers, there must be at least one block. */
if|if
condition|(
operator|!
name|blocks
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Allocate some tables that last till end of compiling this function      and some needed only in find_blocks and life_analysis. */
name|block_begin
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|blocks
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|block_end
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|blocks
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|block_drops_in
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|blocks
argument_list|)
expr_stmt|;
name|block_stack_in
operator|=
operator|(
name|stack
operator|)
name|alloca
argument_list|(
name|blocks
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|stack_def
argument_list|)
argument_list|)
expr_stmt|;
name|block_out_reg_set
operator|=
operator|(
name|HARD_REG_SET
operator|*
operator|)
name|alloca
argument_list|(
name|blocks
operator|*
sizeof|sizeof
argument_list|(
name|HARD_REG_SET
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|block_stack_in
argument_list|,
name|blocks
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|stack_def
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|block_out_reg_set
argument_list|,
name|blocks
operator|*
sizeof|sizeof
argument_list|(
name|HARD_REG_SET
argument_list|)
argument_list|)
expr_stmt|;
name|block_number
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|max_uid
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|find_blocks
argument_list|(
name|first
argument_list|)
expr_stmt|;
name|stack_reg_life_analysis
argument_list|(
name|first
argument_list|)
expr_stmt|;
comment|/* Dump the life analysis debug information before jump      optimization, as that will destroy the LABEL_REFS we keep the      information in. */
if|if
condition|(
name|file
condition|)
name|dump_stack_info
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|convert_regs
argument_list|()
expr_stmt|;
if|if
condition|(
name|optimize
condition|)
name|jump_optimize
argument_list|(
name|first
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Check PAT, which is in INSN, for LABEL_REFs.  Add INSN to the    label's chain of references, and note which insn contains each    reference. */
end_comment

begin_function
specifier|static
name|void
name|record_label_references
parameter_list|(
name|insn
parameter_list|,
name|pat
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|pat
decl_stmt|;
block|{
specifier|register
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|pat
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|LABEL_REF
condition|)
block|{
specifier|register
name|rtx
name|label
init|=
name|XEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|register
name|rtx
name|ref
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|label
argument_list|)
operator|!=
name|CODE_LABEL
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Don't make a duplicate in the code_label's chain. */
for|for
control|(
name|ref
operator|=
name|LABEL_REFS
argument_list|(
name|label
argument_list|)
init|;
name|ref
operator|&&
name|ref
operator|!=
name|label
condition|;
name|ref
operator|=
name|LABEL_NEXTREF
argument_list|(
name|ref
argument_list|)
control|)
if|if
condition|(
name|CONTAINING_INSN
argument_list|(
name|ref
argument_list|)
operator|==
name|insn
condition|)
return|return;
name|CONTAINING_INSN
argument_list|(
name|pat
argument_list|)
operator|=
name|insn
expr_stmt|;
name|LABEL_NEXTREF
argument_list|(
name|pat
argument_list|)
operator|=
name|LABEL_REFS
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|LABEL_REFS
argument_list|(
name|label
argument_list|)
operator|=
name|pat
expr_stmt|;
return|return;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|record_label_references
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|pat
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|pat
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|record_label_references
argument_list|(
name|insn
argument_list|,
name|XVECEXP
argument_list|(
name|pat
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a pointer to the REG expression within PAT.  If PAT is not a    REG, possible enclosed by a conversion rtx, return the inner part of    PAT that stopped the search. */
end_comment

begin_function
specifier|static
name|rtx
modifier|*
name|get_true_reg
parameter_list|(
name|pat
parameter_list|)
name|rtx
modifier|*
name|pat
decl_stmt|;
block|{
while|while
condition|(
name|GET_CODE
argument_list|(
operator|*
name|pat
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
operator|*
name|pat
argument_list|)
operator|==
name|FLOAT
operator|||
name|GET_CODE
argument_list|(
operator|*
name|pat
argument_list|)
operator|==
name|FIX
operator|||
name|GET_CODE
argument_list|(
operator|*
name|pat
argument_list|)
operator|==
name|FLOAT_EXTEND
condition|)
name|pat
operator|=
operator|&
name|XEXP
argument_list|(
operator|*
name|pat
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|pat
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Scan the OPERANDS and OPERAND_CONSTRAINTS of an asm_operands.    N_OPERANDS is the total number of operands.  Return which alternative    matched, or -1 is no alternative matches.     OPERAND_MATCHES is an array which indicates which operand this    operand matches due to the constraints, or -1 if no match is required.    If two operands match by coincidence, but are not required to match by    the constraints, -1 is returned.     OPERAND_CLASS is an array which indicates the smallest class    required by the constraints.  If the alternative that matches calls    for some class `class', and the operand matches a subclass of `class',    OPERAND_CLASS is set to `class' as required by the constraints, not to    the subclass. If an alternative allows more than one class,    OPERAND_CLASS is set to the smallest class that is a union of the    allowed classes. */
end_comment

begin_function
specifier|static
name|int
name|constrain_asm_operands
parameter_list|(
name|n_operands
parameter_list|,
name|operands
parameter_list|,
name|operand_constraints
parameter_list|,
name|operand_matches
parameter_list|,
name|operand_class
parameter_list|)
name|int
name|n_operands
decl_stmt|;
name|rtx
modifier|*
name|operands
decl_stmt|;
name|char
modifier|*
modifier|*
name|operand_constraints
decl_stmt|;
name|int
modifier|*
name|operand_matches
decl_stmt|;
name|enum
name|reg_class
modifier|*
name|operand_class
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|constraints
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|alloca
argument_list|(
name|n_operands
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
name|int
name|this_alternative
decl_stmt|,
name|this_operand
decl_stmt|;
name|int
name|n_alternatives
decl_stmt|;
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_operands
condition|;
name|j
operator|++
control|)
name|constraints
index|[
name|j
index|]
operator|=
name|operand_constraints
index|[
name|j
index|]
expr_stmt|;
comment|/* Compute the number of alternatives in the operands.  reload has      already guaranteed that all operands have the same number of      alternatives.  */
name|n_alternatives
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|q
operator|=
name|constraints
index|[
literal|0
index|]
init|;
operator|*
name|q
condition|;
name|q
operator|++
control|)
name|n_alternatives
operator|+=
operator|(
operator|*
name|q
operator|==
literal|','
operator|)
expr_stmt|;
name|this_alternative
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|this_alternative
operator|<
name|n_alternatives
condition|)
block|{
name|int
name|lose
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* No operands match, no narrow class requirements yet.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_operands
condition|;
name|i
operator|++
control|)
block|{
name|operand_matches
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|operand_class
index|[
name|i
index|]
operator|=
name|NO_REGS
expr_stmt|;
block|}
for|for
control|(
name|this_operand
operator|=
literal|0
init|;
name|this_operand
operator|<
name|n_operands
condition|;
name|this_operand
operator|++
control|)
block|{
name|rtx
name|op
init|=
name|operands
index|[
name|this_operand
index|]
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|constraints
index|[
name|this_operand
index|]
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|int
name|win
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|offset
operator|=
name|SUBREG_WORD
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
comment|/* An empty constraint or empty alternative 	     allows anything which matched the pattern.  */
if|if
condition|(
operator|*
name|p
operator|==
literal|0
operator|||
operator|*
name|p
operator|==
literal|','
condition|)
name|win
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|','
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'='
case|:
case|case
literal|'+'
case|:
case|case
literal|'?'
case|:
case|case
literal|'&'
case|:
case|case
literal|'!'
case|:
case|case
literal|'*'
case|:
case|case
literal|'%'
case|:
comment|/* Ignore these. */
break|break;
case|case
literal|'#'
case|:
comment|/* Ignore rest of this alternative. */
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|','
condition|)
name|p
operator|++
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
comment|/* This operand must be the same as a previous one. 		   This kind of constraint is used for instructions such 		   as add when they take only two operands.  		   Note that the lower-numbered operand is passed first. */
if|if
condition|(
name|operands_match_p
argument_list|(
name|operands
index|[
name|c
operator|-
literal|'0'
index|]
argument_list|,
name|operands
index|[
name|this_operand
index|]
argument_list|)
condition|)
block|{
name|operand_matches
index|[
name|this_operand
index|]
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
name|win
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|'p'
case|:
comment|/* p is used for address_operands.  Since this is an asm, 		   just to make sure that the operand is valid for Pmode. */
if|if
condition|(
name|strict_memory_address_p
argument_list|(
name|Pmode
argument_list|,
name|op
argument_list|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
comment|/* Anything goes unless it is a REG and really has a hard reg 		   but the hard reg is not in the class GENERAL_REGS.  */
if|if
condition|(
name|GENERAL_REGS
operator|==
name|ALL_REGS
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|REG
operator|||
name|reg_fits_class_p
argument_list|(
name|op
argument_list|,
name|GENERAL_REGS
argument_list|,
name|offset
argument_list|,
name|mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
condition|)
name|operand_class
index|[
name|this_operand
index|]
operator|=
name|reg_class_subunion
index|[
operator|(
name|int
operator|)
name|operand_class
index|[
name|this_operand
index|]
index|]
index|[
operator|(
name|int
operator|)
name|GENERAL_REGS
index|]
expr_stmt|;
name|win
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|'r'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|GENERAL_REGS
operator|==
name|ALL_REGS
operator|||
name|reg_fits_class_p
argument_list|(
name|op
argument_list|,
name|GENERAL_REGS
argument_list|,
name|offset
argument_list|,
name|mode
argument_list|)
operator|)
condition|)
block|{
name|operand_class
index|[
name|this_operand
index|]
operator|=
name|reg_class_subunion
index|[
operator|(
name|int
operator|)
name|operand_class
index|[
name|this_operand
index|]
index|]
index|[
operator|(
name|int
operator|)
name|GENERAL_REGS
index|]
expr_stmt|;
name|win
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|'X'
case|:
comment|/* This is used for a MATCH_SCRATCH in the cases when we 		   don't actually need anything.  So anything goes any time. */
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_DEC
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|POST_DEC
operator|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_INC
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|POST_INC
operator|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
comment|/* Match any CONST_DOUBLE, but only if 		   we can examine the bits of it reliably.  */
if|if
condition|(
operator|(
name|HOST_FLOAT_FORMAT
operator|!=
name|TARGET_FLOAT_FORMAT
operator|||
name|HOST_BITS_PER_WIDE_INT
operator|!=
name|BITS_PER_WORD
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|VOIDmode
operator|&&
operator|!
name|flag_pretend_float
condition|)
break|break;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
case|case
literal|'H'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|CONST_DOUBLE_OK_FOR_LETTER_P
argument_list|(
name|op
argument_list|,
name|c
argument_list|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
operator|)
condition|)
break|break;
comment|/* Fall through */
case|case
literal|'i'
case|:
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
operator|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
case|case
literal|'J'
case|:
case|case
literal|'K'
case|:
case|case
literal|'L'
case|:
case|case
literal|'M'
case|:
case|case
literal|'N'
case|:
case|case
literal|'O'
case|:
case|case
literal|'P'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
name|c
argument_list|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|EXTRA_CONSTRAINT
case|case
literal|'Q'
case|:
case|case
literal|'R'
case|:
case|case
literal|'S'
case|:
case|case
literal|'T'
case|:
case|case
literal|'U'
case|:
if|if
condition|(
name|EXTRA_CONSTRAINT
argument_list|(
name|op
argument_list|,
name|c
argument_list|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'V'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|offsettable_memref_p
argument_list|(
name|op
argument_list|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
if|if
condition|(
name|offsettable_memref_p
argument_list|(
name|op
argument_list|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
name|reg_fits_class_p
argument_list|(
name|op
argument_list|,
name|REG_CLASS_FROM_LETTER
argument_list|(
name|c
argument_list|)
argument_list|,
name|offset
argument_list|,
name|mode
argument_list|)
condition|)
block|{
name|operand_class
index|[
name|this_operand
index|]
operator|=
name|reg_class_subunion
index|[
operator|(
name|int
operator|)
name|operand_class
index|[
name|this_operand
index|]
index|]
index|[
operator|(
name|int
operator|)
name|REG_CLASS_FROM_LETTER
argument_list|(
name|c
argument_list|)
index|]
expr_stmt|;
name|win
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|constraints
index|[
name|this_operand
index|]
operator|=
name|p
expr_stmt|;
comment|/* If this operand did not win somehow, 	     this alternative loses.  */
if|if
condition|(
operator|!
name|win
condition|)
name|lose
operator|=
literal|1
expr_stmt|;
block|}
comment|/* This alternative won; the operands are ok. 	 Change whichever operands this alternative says to change.  */
if|if
condition|(
operator|!
name|lose
condition|)
break|break;
name|this_alternative
operator|++
expr_stmt|;
block|}
comment|/* For operands constrained to match another operand, copy the other      operand's class to this operand's class. */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_operands
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|operand_matches
index|[
name|j
index|]
operator|>=
literal|0
condition|)
name|operand_class
index|[
name|j
index|]
operator|=
name|operand_class
index|[
name|operand_matches
index|[
name|j
index|]
index|]
expr_stmt|;
return|return
name|this_alternative
operator|==
name|n_alternatives
condition|?
operator|-
literal|1
else|:
name|this_alternative
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Record the life info of each stack reg in INSN, updating REGSTACK.    N_INPUTS is the number of inputs; N_OUTPUTS the outputs.  CONSTRAINTS    is an array of the constraint strings used in the asm statement.    OPERANDS is an array of all operands for the insn, and is assumed to    contain all output operands, then all inputs operands.     There are many rules that an asm statement for stack-like regs must    follow.  Those rules are explained at the top of this file: the rule    numbers below refer to that explanation. */
end_comment

begin_function
specifier|static
name|void
name|record_asm_reg_life
parameter_list|(
name|insn
parameter_list|,
name|regstack
parameter_list|,
name|operands
parameter_list|,
name|constraints
parameter_list|,
name|n_inputs
parameter_list|,
name|n_outputs
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|stack
name|regstack
decl_stmt|;
name|rtx
modifier|*
name|operands
decl_stmt|;
name|char
modifier|*
modifier|*
name|constraints
decl_stmt|;
name|int
name|n_inputs
decl_stmt|,
name|n_outputs
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|n_operands
init|=
name|n_inputs
operator|+
name|n_outputs
decl_stmt|;
name|int
name|first_input
init|=
name|n_outputs
decl_stmt|;
name|int
name|n_clobbers
decl_stmt|;
name|int
name|malformed_asm
init|=
literal|0
decl_stmt|;
name|rtx
name|body
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
modifier|*
name|operand_matches
init|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|n_operands
operator|*
sizeof|sizeof
argument_list|(
name|int
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|enum
name|reg_class
modifier|*
name|operand_class
init|=
operator|(
expr|enum
name|reg_class
operator|*
operator|)
name|alloca
argument_list|(
name|n_operands
operator|*
sizeof|sizeof
argument_list|(
expr|enum
name|reg_class
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|reg_used_as_output
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
name|int
name|implicitly_dies
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
name|rtx
modifier|*
name|clobber_reg
decl_stmt|;
comment|/* Find out what the constraints require.  If no constraint      alternative matches, this asm is malformed.  */
name|i
operator|=
name|constrain_asm_operands
argument_list|(
name|n_operands
argument_list|,
name|operands
argument_list|,
name|constraints
argument_list|,
name|operand_matches
argument_list|,
name|operand_class
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|malformed_asm
operator|=
literal|1
expr_stmt|;
comment|/* Strip SUBREGs here to make the following code simpler. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_operands
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|operands
index|[
name|i
index|]
operator|=
name|SUBREG_REG
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Set up CLOBBER_REG.  */
name|n_clobbers
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|clobber_reg
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|rtx
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
block|{
name|rtx
name|clobber
init|=
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|rtx
name|reg
init|=
name|XEXP
argument_list|(
name|clobber
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|reg
operator|=
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|STACK_REG_P
argument_list|(
name|reg
argument_list|)
condition|)
block|{
name|clobber_reg
index|[
name|n_clobbers
index|]
operator|=
name|reg
expr_stmt|;
name|n_clobbers
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/* Enforce rule #4: Output operands must specifically indicate which      reg an output appears in after an asm.  "=f" is not allowed: the      operand constraints must select a class with a single reg.       Also enforce rule #5: Output operands must start at the top of      the reg-stack: output operands may not "skip" a reg. */
name|bzero
argument_list|(
name|reg_used_as_output
argument_list|,
sizeof|sizeof
argument_list|(
name|reg_used_as_output
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_outputs
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|STACK_REG_P
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|)
condition|)
if|if
condition|(
name|reg_class_size
index|[
operator|(
name|int
operator|)
name|operand_class
index|[
name|i
index|]
index|]
operator|!=
literal|1
condition|)
block|{
name|error_for_asm
argument_list|(
name|insn
argument_list|,
literal|"Output constraint %d must specify a single register"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|malformed_asm
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|reg_used_as_output
index|[
name|REGNO
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|)
index|]
operator|=
literal|1
expr_stmt|;
comment|/* Search for first non-popped reg.  */
for|for
control|(
name|i
operator|=
name|FIRST_STACK_REG
init|;
name|i
operator|<
name|LAST_STACK_REG
operator|+
literal|1
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|reg_used_as_output
index|[
name|i
index|]
condition|)
break|break;
comment|/* If there are any other popped regs, that's an error.  */
for|for
control|(
init|;
name|i
operator|<
name|LAST_STACK_REG
operator|+
literal|1
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|reg_used_as_output
index|[
name|i
index|]
condition|)
break|break;
if|if
condition|(
name|i
operator|!=
name|LAST_STACK_REG
operator|+
literal|1
condition|)
block|{
name|error_for_asm
argument_list|(
name|insn
argument_list|,
literal|"Output regs must be grouped at top of stack"
argument_list|)
expr_stmt|;
name|malformed_asm
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Enforce rule #2: All implicitly popped input regs must be closer      to the top of the reg-stack than any input that is not implicitly      popped. */
name|bzero
argument_list|(
name|implicitly_dies
argument_list|,
sizeof|sizeof
argument_list|(
name|implicitly_dies
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|first_input
init|;
name|i
operator|<
name|first_input
operator|+
name|n_inputs
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|STACK_REG_P
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|)
condition|)
block|{
comment|/* An input reg is implicitly popped if it is tied to an 	   output, or if there is a CLOBBER for it. */
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_clobbers
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|operands_match_p
argument_list|(
name|clobber_reg
index|[
name|j
index|]
argument_list|,
name|operands
index|[
name|i
index|]
argument_list|)
condition|)
break|break;
if|if
condition|(
name|j
operator|<
name|n_clobbers
operator|||
name|operand_matches
index|[
name|i
index|]
operator|>=
literal|0
condition|)
name|implicitly_dies
index|[
name|REGNO
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|)
index|]
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Search for first non-popped reg.  */
for|for
control|(
name|i
operator|=
name|FIRST_STACK_REG
init|;
name|i
operator|<
name|LAST_STACK_REG
operator|+
literal|1
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|implicitly_dies
index|[
name|i
index|]
condition|)
break|break;
comment|/* If there are any other popped regs, that's an error.  */
for|for
control|(
init|;
name|i
operator|<
name|LAST_STACK_REG
operator|+
literal|1
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|implicitly_dies
index|[
name|i
index|]
condition|)
break|break;
if|if
condition|(
name|i
operator|!=
name|LAST_STACK_REG
operator|+
literal|1
condition|)
block|{
name|error_for_asm
argument_list|(
name|insn
argument_list|,
literal|"Implicitly popped regs must be grouped at top of stack"
argument_list|)
expr_stmt|;
name|malformed_asm
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Enfore rule #3: If any input operand uses the "f" constraint, all      output constraints must use the "&" earlyclobber.       ???  Detect this more deterministically by having constraint_asm_operands      record any earlyclobber. */
for|for
control|(
name|i
operator|=
name|first_input
init|;
name|i
operator|<
name|first_input
operator|+
name|n_inputs
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|operand_matches
index|[
name|i
index|]
operator|==
operator|-
literal|1
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_outputs
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|operands_match_p
argument_list|(
name|operands
index|[
name|j
index|]
argument_list|,
name|operands
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|error_for_asm
argument_list|(
name|insn
argument_list|,
literal|"Output operand %d must use `&' constraint"
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|malformed_asm
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|malformed_asm
condition|)
block|{
comment|/* Avoid further trouble with this insn.  */
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|USE
argument_list|,
name|VOIDmode
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|insn
argument_list|,
name|VOIDmode
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Process all outputs */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_outputs
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|op
init|=
name|operands
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|STACK_REG_P
argument_list|(
name|op
argument_list|)
condition|)
if|if
condition|(
name|stack_regs_mentioned_p
argument_list|(
name|op
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
else|else
continue|continue;
comment|/* Each destination is dead before this insn.  If the 	 destination is not used after this insn, record this with 	 REG_UNUSED.  */
if|if
condition|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|REGNO
argument_list|(
name|op
argument_list|)
argument_list|)
condition|)
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|REG_UNUSED
argument_list|,
name|op
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|REGNO
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Process all inputs */
for|for
control|(
name|i
operator|=
name|first_input
init|;
name|i
operator|<
name|first_input
operator|+
name|n_inputs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|STACK_REG_P
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|)
condition|)
if|if
condition|(
name|stack_regs_mentioned_p
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
else|else
continue|continue;
comment|/* If an input is dead after the insn, record a death note. 	 But don't record a death note if there is already a death note, 	 or if the input is also an output.  */
if|if
condition|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|)
argument_list|)
operator|&&
name|operand_matches
index|[
name|i
index|]
operator|==
operator|-
literal|1
operator|&&
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|)
argument_list|)
operator|==
name|NULL_RTX
condition|)
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|REG_DEAD
argument_list|,
name|operands
index|[
name|i
index|]
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Scan PAT, which is part of INSN, and record registers appearing in    a SET_DEST in DEST, and other registers in SRC.     This function does not know about SET_DESTs that are both input and    output (such as ZERO_EXTRACT) - this cannot happen on a 387. */
end_comment

begin_function
name|void
name|record_reg_life_pat
parameter_list|(
name|pat
parameter_list|,
name|src
parameter_list|,
name|dest
parameter_list|)
name|rtx
name|pat
decl_stmt|;
name|HARD_REG_SET
modifier|*
name|src
decl_stmt|,
decl|*
name|dest
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|STACK_REG_P
argument_list|(
name|pat
argument_list|)
condition|)
block|{
if|if
condition|(
name|src
condition|)
name|SET_HARD_REG_BIT
argument_list|(
operator|*
name|src
argument_list|,
name|REGNO
argument_list|(
name|pat
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest
condition|)
name|SET_HARD_REG_BIT
argument_list|(
operator|*
name|dest
argument_list|,
name|REGNO
argument_list|(
name|pat
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SET
condition|)
block|{
name|record_reg_life_pat
argument_list|(
name|XEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_PTR
argument_list|,
name|dest
argument_list|)
expr_stmt|;
name|record_reg_life_pat
argument_list|(
name|XEXP
argument_list|(
name|pat
argument_list|,
literal|1
argument_list|)
argument_list|,
name|src
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* We don't need to consider either of these cases. */
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|CLOBBER
condition|)
return|return;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|pat
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|record_reg_life_pat
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|src
argument_list|,
name|dest
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|record_reg_life_pat
argument_list|(
name|XEXP
argument_list|(
name|pat
argument_list|,
name|i
argument_list|)
argument_list|,
name|src
argument_list|,
name|dest
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Calculate the number of inputs and outputs in BODY, an    asm_operands.  N_OPERANDS is the total number of operands, and    N_INPUTS and N_OUTPUTS are pointers to ints into which the results are    placed. */
end_comment

begin_function
specifier|static
name|void
name|get_asm_operand_lengths
parameter_list|(
name|body
parameter_list|,
name|n_operands
parameter_list|,
name|n_inputs
parameter_list|,
name|n_outputs
parameter_list|)
name|rtx
name|body
decl_stmt|;
name|int
name|n_operands
decl_stmt|;
name|int
modifier|*
name|n_inputs
decl_stmt|,
decl|*
name|n_outputs
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|ASM_OPERANDS
condition|)
operator|*
name|n_inputs
operator|=
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|ASM_OPERANDS
condition|)
operator|*
name|n_inputs
operator|=
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|body
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
operator|*
name|n_inputs
operator|=
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ASM_OPERANDS
condition|)
operator|*
name|n_inputs
operator|=
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
operator|*
name|n_outputs
operator|=
name|n_operands
operator|-
operator|*
name|n_inputs
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Scan INSN, which is in BLOCK, and record the life& death of stack    registers in REGSTACK.  This function is called to process insns from    the last insn in a block to the first.  The actual scanning is done in    record_reg_life_pat.     If a register is live after a CALL_INSN, but is not a value return    register for that CALL_INSN, then code is emitted to initialize that    register.  The block_end[] data is kept accurate.     Existing death and unset notes for stack registers are deleted    before processing the insn. */
end_comment

begin_function
specifier|static
name|void
name|record_reg_life
parameter_list|(
name|insn
parameter_list|,
name|block
parameter_list|,
name|regstack
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|int
name|block
decl_stmt|;
name|stack
name|regstack
decl_stmt|;
block|{
name|rtx
name|note
decl_stmt|,
modifier|*
name|note_link
decl_stmt|;
name|int
name|n_operands
decl_stmt|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|CALL_INSN
operator|)
operator|||
name|INSN_DELETED_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return;
comment|/* Strip death notes for stack regs from this insn */
name|note_link
operator|=
operator|&
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
expr_stmt|;
for|for
control|(
name|note
operator|=
operator|*
name|note_link
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|STACK_REG_P
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_DEAD
operator|||
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_UNUSED
operator|)
condition|)
operator|*
name|note_link
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|note_link
operator|=
operator|&
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Process all patterns in the insn. */
name|n_operands
operator|=
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_operands
operator|>=
literal|0
condition|)
block|{
comment|/* This insn is an `asm' with operands.  Decode the operands, 	 decide how many are inputs, and record the life information. */
name|rtx
name|operands
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|rtx
name|body
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
name|n_inputs
decl_stmt|,
name|n_outputs
decl_stmt|;
name|char
modifier|*
modifier|*
name|constraints
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|alloca
argument_list|(
name|n_operands
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|decode_asm_operands
argument_list|(
name|body
argument_list|,
name|operands
argument_list|,
name|NULL_PTR
argument_list|,
name|constraints
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|get_asm_operand_lengths
argument_list|(
name|body
argument_list|,
name|n_operands
argument_list|,
operator|&
name|n_inputs
argument_list|,
operator|&
name|n_outputs
argument_list|)
expr_stmt|;
name|record_asm_reg_life
argument_list|(
name|insn
argument_list|,
name|regstack
argument_list|,
name|operands
argument_list|,
name|constraints
argument_list|,
name|n_inputs
argument_list|,
name|n_outputs
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* An insn referencing a stack reg has a mode of QImode. */
if|if
condition|(
name|GET_MODE
argument_list|(
name|insn
argument_list|)
operator|==
name|QImode
condition|)
block|{
name|HARD_REG_SET
name|src
decl_stmt|,
name|dest
decl_stmt|;
name|int
name|regno
decl_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|record_reg_life_pat
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
operator|&
name|src
argument_list|,
operator|&
name|dest
argument_list|)
expr_stmt|;
for|for
control|(
name|regno
operator|=
name|FIRST_STACK_REG
init|;
name|regno
operator|<=
name|LAST_STACK_REG
condition|;
name|regno
operator|++
control|)
if|if
condition|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|regno
argument_list|)
condition|)
block|{
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|src
argument_list|,
name|regno
argument_list|)
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|dest
argument_list|,
name|regno
argument_list|)
condition|)
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|REG_DEAD
argument_list|,
name|FP_mode_reg
index|[
name|regno
index|]
index|[
operator|(
name|int
operator|)
name|DFmode
index|]
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|dest
argument_list|,
name|regno
argument_list|)
condition|)
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|REG_UNUSED
argument_list|,
name|FP_mode_reg
index|[
name|regno
index|]
index|[
operator|(
name|int
operator|)
name|DFmode
index|]
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|AND_COMPL_HARD_REG_SET
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|dest
argument_list|)
expr_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|src
argument_list|)
expr_stmt|;
block|}
comment|/* There might be a reg that is live after a function call.      Initialize it to zero so that the program does not crash.  See comment      towards the end of stack_reg_life_analysis(). */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|int
name|reg
init|=
name|FIRST_FLOAT_REG
decl_stmt|;
comment|/* If a stack reg is mentioned in a CALL_INSN, it must be as the 	 return value.  */
if|if
condition|(
name|stack_regs_mentioned_p
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
name|reg
operator|++
expr_stmt|;
for|for
control|(
init|;
name|reg
operator|<=
name|LAST_STACK_REG
condition|;
name|reg
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|reg
argument_list|)
condition|)
block|{
name|rtx
name|init
decl_stmt|,
name|pat
decl_stmt|;
comment|/* The insn will use virtual register numbers, and so 	       convert_regs is expected to process these.  But BLOCK_NUM 	       cannot be used on these insns, because they do not appear in 	       block_number[]. */
name|pat
operator|=
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|FP_mode_reg
index|[
name|reg
index|]
index|[
operator|(
name|int
operator|)
name|DFmode
index|]
argument_list|,
name|CONST0_RTX
argument_list|(
name|DFmode
argument_list|)
argument_list|)
expr_stmt|;
name|init
operator|=
name|emit_insn_after
argument_list|(
name|pat
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|init
argument_list|,
name|QImode
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* If the CALL_INSN was the end of a block, move the 	       block_end to point to the new insn. */
if|if
condition|(
name|block_end
index|[
name|block
index|]
operator|==
name|insn
condition|)
name|block_end
index|[
name|block
index|]
operator|=
name|init
expr_stmt|;
block|}
comment|/* Some regs do not survive a CALL */
name|AND_COMPL_HARD_REG_SET
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|call_used_reg_set
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find all basic blocks of the function, which starts with FIRST.    For each JUMP_INSN, build the chain of LABEL_REFS on each CODE_LABEL. */
end_comment

begin_function
specifier|static
name|void
name|find_blocks
parameter_list|(
name|first
parameter_list|)
name|rtx
name|first
decl_stmt|;
block|{
specifier|register
name|rtx
name|insn
decl_stmt|;
specifier|register
name|int
name|block
decl_stmt|;
specifier|register
name|RTX_CODE
name|prev_code
init|=
name|BARRIER
decl_stmt|;
specifier|register
name|RTX_CODE
name|code
decl_stmt|;
name|rtx
name|label_value_list
init|=
literal|0
decl_stmt|;
comment|/* Record where all the blocks start and end.      Record which basic blocks control can drop in to. */
name|block
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|first
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
comment|/* Note that this loop must select the same block boundaries 	 as code in reg_to_stack, but that these are not the same 	 as those selected in flow.c.  */
name|code
operator|=
name|GET_CODE
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|CODE_LABEL
operator|||
operator|(
name|prev_code
operator|!=
name|INSN
operator|&&
name|prev_code
operator|!=
name|CALL_INSN
operator|&&
name|prev_code
operator|!=
name|CODE_LABEL
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'i'
operator|)
condition|)
block|{
name|block_begin
index|[
operator|++
name|block
index|]
operator|=
name|insn
expr_stmt|;
name|block_end
index|[
name|block
index|]
operator|=
name|insn
expr_stmt|;
name|block_drops_in
index|[
name|block
index|]
operator|=
name|prev_code
operator|!=
name|BARRIER
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'i'
condition|)
name|block_end
index|[
name|block
index|]
operator|=
name|insn
expr_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'i'
condition|)
block|{
name|rtx
name|note
decl_stmt|;
comment|/* Make a list of all labels referred to other than by jumps.  */
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_LABEL
condition|)
name|label_value_list
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|VOIDmode
argument_list|,
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|label_value_list
argument_list|)
expr_stmt|;
block|}
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
operator|=
name|block
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|NOTE
condition|)
name|prev_code
operator|=
name|code
expr_stmt|;
block|}
if|if
condition|(
name|block
operator|+
literal|1
operator|!=
name|blocks
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* generate all label references to the corresponding jump insn */
for|for
control|(
name|block
operator|=
literal|0
init|;
name|block
operator|<
name|blocks
condition|;
name|block
operator|++
control|)
block|{
name|insn
operator|=
name|block_end
index|[
name|block
index|]
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
name|computed_jump
init|=
literal|0
decl_stmt|;
name|rtx
name|x
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|len
init|=
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|has_use_labelref
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|len
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
condition|)
name|has_use_labelref
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|has_use_labelref
condition|)
for|for
control|(
name|i
operator|=
name|len
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|pc_rtx
operator|&&
name|uses_reg_or_mem
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
condition|)
name|computed_jump
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|pat
argument_list|)
operator|==
name|pc_rtx
operator|&&
name|uses_reg_or_mem
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
condition|)
name|computed_jump
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|computed_jump
condition|)
block|{
for|for
control|(
name|x
operator|=
name|label_value_list
init|;
name|x
condition|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
control|)
name|record_label_references
argument_list|(
name|insn
argument_list|,
name|gen_rtx
argument_list|(
name|LABEL_REF
argument_list|,
name|VOIDmode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
name|forced_labels
init|;
name|x
condition|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
control|)
name|record_label_references
argument_list|(
name|insn
argument_list|,
name|gen_rtx
argument_list|(
name|LABEL_REF
argument_list|,
name|VOIDmode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|record_label_references
argument_list|(
name|insn
argument_list|,
name|pat
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Return 1 if X contain a REG or MEM that is not in the constant pool.  */
end_comment

begin_function
specifier|static
name|int
name|uses_reg_or_mem
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|REG
operator|||
operator|(
name|code
operator|==
name|MEM
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
return|return
literal|1
return|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|&&
name|uses_reg_or_mem
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|uses_reg_or_mem
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* If current function returns its result in an fp stack register,    return the register number.  Otherwise return -1.  */
end_comment

begin_function
specifier|static
name|int
name|stack_result_p
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|rtx
name|result
init|=
name|DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|result
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|result
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|FUNCTION_OUTGOING_VALUE
name|result
operator|=
name|FUNCTION_OUTGOING_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|DECL_RESULT
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|#
directive|else
name|result
operator|=
name|FUNCTION_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|DECL_RESULT
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
name|decl
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
name|STACK_REG_P
argument_list|(
name|result
argument_list|)
condition|?
name|REGNO
argument_list|(
name|result
argument_list|)
else|:
operator|-
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Determine the which registers are live at the start of each basic    block of the function whose first insn is FIRST.     First, if the function returns a real_type, mark the function    return type as live at each return point, as the RTL may not give any    hint that the register is live.     Then, start with the last block and work back to the first block.    Similarly, work backwards within each block, insn by insn, recording    which regs are die and which are used (and therefore live) in the    hard reg set of block_stack_in[].     After processing each basic block, if there is a label at the start    of the block, propagate the live registers to all jumps to this block.     As a special case, if there are regs live in this block, that are    not live in a block containing a jump to this label, and the block    containing the jump has already been processed, we must propagate this    block's entry register life back to the block containing the jump, and    restart life analysis from there.     In the worst case, this function may traverse the insns    REG_STACK_SIZE times.  This is necessary, since a jump towards the end    of the insns may not know that a reg is live at a target that is early    in the insns.  So we back up and start over with the new reg live.     If there are registers that are live at the start of the function,    insns are emitted to initialize these registers.  Something similar is    done after CALL_INSNs in record_reg_life. */
end_comment

begin_function
specifier|static
name|void
name|stack_reg_life_analysis
parameter_list|(
name|first
parameter_list|)
name|rtx
name|first
decl_stmt|;
block|{
name|int
name|reg
decl_stmt|,
name|block
decl_stmt|;
name|struct
name|stack_def
name|regstack
decl_stmt|;
if|if
condition|(
name|current_function_returns_real
operator|&&
name|stack_result_p
argument_list|(
name|current_function_decl
argument_list|)
operator|>=
literal|0
condition|)
block|{
comment|/* Find all RETURN insns and mark them. */
name|int
name|value_regno
init|=
name|stack_result_p
argument_list|(
name|current_function_decl
argument_list|)
decl_stmt|;
for|for
control|(
name|block
operator|=
name|blocks
operator|-
literal|1
init|;
name|block
operator|>=
literal|0
condition|;
name|block
operator|--
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|block_end
index|[
name|block
index|]
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|block_end
index|[
name|block
index|]
argument_list|)
argument_list|)
operator|==
name|RETURN
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|block_out_reg_set
index|[
name|block
index|]
argument_list|,
name|value_regno
argument_list|)
expr_stmt|;
comment|/* Mark of the end of last block if we "fall off" the end of the 	 function into the epilogue. */
if|if
condition|(
name|GET_CODE
argument_list|(
name|block_end
index|[
name|blocks
operator|-
literal|1
index|]
argument_list|)
operator|!=
name|JUMP_INSN
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|block_end
index|[
name|blocks
operator|-
literal|1
index|]
argument_list|)
argument_list|)
operator|==
name|RETURN
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|block_out_reg_set
index|[
name|blocks
operator|-
literal|1
index|]
argument_list|,
name|value_regno
argument_list|)
expr_stmt|;
block|}
comment|/* now scan all blocks backward for stack register use */
name|block
operator|=
name|blocks
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|block
operator|>=
literal|0
condition|)
block|{
specifier|register
name|rtx
name|insn
decl_stmt|,
name|prev
decl_stmt|;
comment|/* current register status at last instruction */
name|COPY_HARD_REG_SET
argument_list|(
name|regstack
operator|.
name|reg_set
argument_list|,
name|block_out_reg_set
index|[
name|block
index|]
argument_list|)
expr_stmt|;
name|prev
operator|=
name|block_end
index|[
name|block
index|]
expr_stmt|;
do|do
block|{
name|insn
operator|=
name|prev
expr_stmt|;
name|prev
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* If the insn is a CALL_INSN, we need to ensure that 	     everything dies.  But otherwise don't process unless there 	     are some stack regs present. */
if|if
condition|(
name|GET_MODE
argument_list|(
name|insn
argument_list|)
operator|==
name|QImode
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
name|record_reg_life
argument_list|(
name|insn
argument_list|,
name|block
argument_list|,
operator|&
name|regstack
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|insn
operator|!=
name|block_begin
index|[
name|block
index|]
condition|)
do|;
comment|/* Set the state at the start of the block.  Mark that no 	 register mapping information known yet. */
name|COPY_HARD_REG_SET
argument_list|(
name|block_stack_in
index|[
name|block
index|]
operator|.
name|reg_set
argument_list|,
name|regstack
operator|.
name|reg_set
argument_list|)
expr_stmt|;
name|block_stack_in
index|[
name|block
index|]
operator|.
name|top
operator|=
operator|-
literal|2
expr_stmt|;
comment|/* If there is a label, propagate our register life to all jumps 	 to this label. */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
block|{
specifier|register
name|rtx
name|label
decl_stmt|;
name|int
name|must_restart
init|=
literal|0
decl_stmt|;
for|for
control|(
name|label
operator|=
name|LABEL_REFS
argument_list|(
name|insn
argument_list|)
init|;
name|label
operator|!=
name|insn
condition|;
name|label
operator|=
name|LABEL_NEXTREF
argument_list|(
name|label
argument_list|)
control|)
block|{
name|int
name|jump_block
init|=
name|BLOCK_NUM
argument_list|(
name|CONTAINING_INSN
argument_list|(
name|label
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|jump_block
operator|<
name|block
condition|)
name|IOR_HARD_REG_SET
argument_list|(
name|block_out_reg_set
index|[
name|jump_block
index|]
argument_list|,
name|block_stack_in
index|[
name|block
index|]
operator|.
name|reg_set
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* The block containing the jump has already been 		     processed.  If there are registers that were not known 		     to be live then, but are live now, we must back up 		     and restart life analysis from that point with the new 		     life information. */
name|GO_IF_HARD_REG_SUBSET
argument_list|(
name|block_stack_in
index|[
name|block
index|]
operator|.
name|reg_set
argument_list|,
name|block_out_reg_set
index|[
name|jump_block
index|]
argument_list|,
name|win
argument_list|)
expr_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
name|block_out_reg_set
index|[
name|jump_block
index|]
argument_list|,
name|block_stack_in
index|[
name|block
index|]
operator|.
name|reg_set
argument_list|)
expr_stmt|;
name|block
operator|=
name|jump_block
expr_stmt|;
name|must_restart
operator|=
literal|1
expr_stmt|;
name|win
label|:
empty_stmt|;
block|}
block|}
if|if
condition|(
name|must_restart
condition|)
continue|continue;
block|}
if|if
condition|(
name|block_drops_in
index|[
name|block
index|]
condition|)
name|IOR_HARD_REG_SET
argument_list|(
name|block_out_reg_set
index|[
name|block
operator|-
literal|1
index|]
argument_list|,
name|block_stack_in
index|[
name|block
index|]
operator|.
name|reg_set
argument_list|)
expr_stmt|;
name|block
operator|-=
literal|1
expr_stmt|;
block|}
block|{
comment|/* If any reg is live at the start of the first block of a        function, then we must guarantee that the reg holds some value by        generating our own "load" of that register.  Otherwise a 387 would        fault trying to access an empty register. */
name|HARD_REG_SET
name|empty_regs
decl_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|empty_regs
argument_list|)
expr_stmt|;
name|GO_IF_HARD_REG_SUBSET
argument_list|(
name|block_stack_in
index|[
literal|0
index|]
operator|.
name|reg_set
argument_list|,
name|empty_regs
argument_list|,
name|no_live_regs
argument_list|)
expr_stmt|;
block|}
comment|/* Load zero into each live register.  The fact that a register      appears live at the function start does not necessarily imply an error      in the user program: it merely means that we could not determine that      there wasn't such an error, just as -Wunused sometimes gives      "incorrect" warnings.  In those cases, these initializations will do      no harm.       Note that we are inserting virtual register references here:      these insns must be processed by convert_regs later.  Also, these      insns will not be in block_number, so BLOCK_NUM() will fail for them. */
for|for
control|(
name|reg
operator|=
name|LAST_STACK_REG
init|;
name|reg
operator|>=
name|FIRST_STACK_REG
condition|;
name|reg
operator|--
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|block_stack_in
index|[
literal|0
index|]
operator|.
name|reg_set
argument_list|,
name|reg
argument_list|)
condition|)
block|{
name|rtx
name|init_rtx
decl_stmt|;
name|init_rtx
operator|=
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|FP_mode_reg
index|[
name|reg
index|]
index|[
operator|(
name|int
operator|)
name|DFmode
index|]
argument_list|,
name|CONST0_RTX
argument_list|(
name|DFmode
argument_list|)
argument_list|)
expr_stmt|;
name|block_begin
index|[
literal|0
index|]
operator|=
name|emit_insn_after
argument_list|(
name|init_rtx
argument_list|,
name|first
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|block_begin
index|[
literal|0
index|]
argument_list|,
name|QImode
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_BIT
argument_list|(
name|block_stack_in
index|[
literal|0
index|]
operator|.
name|reg_set
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
name|no_live_regs
label|:
empty_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*****************************************************************************    This section deals with stack register substitution, and forms the second    pass over the RTL.  *****************************************************************************/
end_comment

begin_comment
comment|/* Replace REG, which is a pointer to a stack reg RTX, with an RTX for    the desired hard REGNO. */
end_comment

begin_function
specifier|static
name|void
name|replace_reg
parameter_list|(
name|reg
parameter_list|,
name|regno
parameter_list|)
name|rtx
modifier|*
name|reg
decl_stmt|;
name|int
name|regno
decl_stmt|;
block|{
if|if
condition|(
name|regno
operator|<
name|FIRST_STACK_REG
operator|||
name|regno
operator|>
name|LAST_STACK_REG
operator|||
operator|!
name|STACK_REG_P
argument_list|(
operator|*
name|reg
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
operator|*
name|reg
argument_list|)
argument_list|)
operator|!=
name|MODE_FLOAT
condition|)
name|abort
argument_list|()
expr_stmt|;
operator|*
name|reg
operator|=
name|FP_mode_reg
index|[
name|regno
index|]
index|[
operator|(
name|int
operator|)
name|GET_MODE
argument_list|(
operator|*
name|reg
argument_list|)
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove a note of type NOTE, which must be found, for register    number REGNO from INSN.  Remove only one such note. */
end_comment

begin_function
specifier|static
name|void
name|remove_regno_note
parameter_list|(
name|insn
parameter_list|,
name|note
parameter_list|,
name|regno
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|enum
name|reg_note
name|note
decl_stmt|;
name|int
name|regno
decl_stmt|;
block|{
specifier|register
name|rtx
modifier|*
name|note_link
decl_stmt|,
name|this
decl_stmt|;
name|note_link
operator|=
operator|&
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
expr_stmt|;
for|for
control|(
name|this
operator|=
operator|*
name|note_link
init|;
name|this
condition|;
name|this
operator|=
name|XEXP
argument_list|(
name|this
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|this
argument_list|)
operator|==
name|note
operator|&&
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|this
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|this
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|regno
condition|)
block|{
operator|*
name|note_link
operator|=
name|XEXP
argument_list|(
name|this
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|note_link
operator|=
operator|&
name|XEXP
argument_list|(
name|this
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find the hard register number of virtual register REG in REGSTACK.    The hard register number is relative to the top of the stack.  -1 is    returned if the register is not found. */
end_comment

begin_function
specifier|static
name|int
name|get_hard_regnum
parameter_list|(
name|regstack
parameter_list|,
name|reg
parameter_list|)
name|stack
name|regstack
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|STACK_REG_P
argument_list|(
name|reg
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
name|regstack
operator|->
name|top
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|regstack
operator|->
name|reg
index|[
name|i
index|]
operator|==
name|REGNO
argument_list|(
name|reg
argument_list|)
condition|)
break|break;
return|return
name|i
operator|>=
literal|0
condition|?
operator|(
name|FIRST_STACK_REG
operator|+
name|regstack
operator|->
name|top
operator|-
name|i
operator|)
else|:
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Delete INSN from the RTL.  Mark the insn, but don't remove it from    the chain of insns.  Doing so could confuse block_begin and block_end    if this were the only insn in the block. */
end_comment

begin_function
specifier|static
name|void
name|delete_insn_for_stacker
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|PUT_CODE
argument_list|(
name|insn
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit an insn to pop virtual register REG before or after INSN.    REGSTACK is the stack state after INSN and is updated to reflect this    pop.  WHEN is either emit_insn_before or emit_insn_after.  A pop insn    is represented as a SET whose destination is the register to be popped    and source is the top of stack.  A death note for the top of stack    cases the movdf pattern to pop. */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|emit_pop_insn
argument_list|(
name|insn
argument_list|,
name|regstack
argument_list|,
name|reg
argument_list|,
name|when
argument_list|)
name|rtx
name|insn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|stack
name|regstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|reg
decl_stmt|;
end_decl_stmt

begin_function_decl
name|rtx
function_decl|(
modifier|*
name|when
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
name|rtx
name|pop_insn
decl_stmt|,
name|pop_rtx
decl_stmt|;
name|int
name|hard_regno
decl_stmt|;
name|hard_regno
operator|=
name|get_hard_regnum
argument_list|(
name|regstack
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|hard_regno
operator|<
name|FIRST_STACK_REG
condition|)
name|abort
argument_list|()
expr_stmt|;
name|pop_rtx
operator|=
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|FP_mode_reg
index|[
name|hard_regno
index|]
index|[
operator|(
name|int
operator|)
name|DFmode
index|]
argument_list|,
name|FP_mode_reg
index|[
name|FIRST_STACK_REG
index|]
index|[
operator|(
name|int
operator|)
name|DFmode
index|]
argument_list|)
expr_stmt|;
name|pop_insn
operator|=
call|(
modifier|*
name|when
call|)
argument_list|(
name|pop_rtx
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* ??? This used to be VOIDmode, but that seems wrong. */
name|PUT_MODE
argument_list|(
name|pop_insn
argument_list|,
name|QImode
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|pop_insn
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|REG_DEAD
argument_list|,
name|FP_mode_reg
index|[
name|FIRST_STACK_REG
index|]
index|[
operator|(
name|int
operator|)
name|DFmode
index|]
argument_list|,
name|REG_NOTES
argument_list|(
name|pop_insn
argument_list|)
argument_list|)
expr_stmt|;
name|regstack
operator|->
name|reg
index|[
name|regstack
operator|->
name|top
operator|-
operator|(
name|hard_regno
operator|-
name|FIRST_STACK_REG
operator|)
index|]
operator|=
name|regstack
operator|->
name|reg
index|[
name|regstack
operator|->
name|top
index|]
expr_stmt|;
name|regstack
operator|->
name|top
operator|-=
literal|1
expr_stmt|;
name|CLEAR_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|pop_insn
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Emit an insn before or after INSN to swap virtual register REG with the    top of stack.  WHEN should be `emit_insn_before' or `emit_insn_before'    REGSTACK is the stack state before the swap, and is updated to reflect    the swap.  A swap insn is represented as a PARALLEL of two patterns:    each pattern moves one reg to the other.     If REG is already at the top of the stack, no insn is emitted. */
end_comment

begin_function
specifier|static
name|void
name|emit_swap_insn
parameter_list|(
name|insn
parameter_list|,
name|regstack
parameter_list|,
name|reg
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|stack
name|regstack
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
block|{
name|int
name|hard_regno
decl_stmt|;
name|rtx
name|gen_swapdf
parameter_list|()
function_decl|;
name|rtx
name|swap_rtx
decl_stmt|,
name|swap_insn
decl_stmt|;
name|int
name|tmp
decl_stmt|,
name|other_reg
decl_stmt|;
comment|/* swap regno temps */
name|rtx
name|i1
decl_stmt|;
comment|/* the stack-reg insn prior to INSN */
name|rtx
name|i1set
init|=
name|NULL_RTX
decl_stmt|;
comment|/* the SET rtx within I1 */
name|hard_regno
operator|=
name|get_hard_regnum
argument_list|(
name|regstack
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|hard_regno
operator|<
name|FIRST_STACK_REG
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|hard_regno
operator|==
name|FIRST_STACK_REG
condition|)
return|return;
name|other_reg
operator|=
name|regstack
operator|->
name|top
operator|-
operator|(
name|hard_regno
operator|-
name|FIRST_STACK_REG
operator|)
expr_stmt|;
name|tmp
operator|=
name|regstack
operator|->
name|reg
index|[
name|other_reg
index|]
expr_stmt|;
name|regstack
operator|->
name|reg
index|[
name|other_reg
index|]
operator|=
name|regstack
operator|->
name|reg
index|[
name|regstack
operator|->
name|top
index|]
expr_stmt|;
name|regstack
operator|->
name|reg
index|[
name|regstack
operator|->
name|top
index|]
operator|=
name|tmp
expr_stmt|;
comment|/* Find the previous insn involving stack regs, but don't go past      any labels, calls or jumps.  */
name|i1
operator|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
while|while
condition|(
name|i1
operator|&&
name|GET_CODE
argument_list|(
name|i1
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_MODE
argument_list|(
name|i1
argument_list|)
operator|!=
name|QImode
condition|)
name|i1
operator|=
name|prev_nonnote_insn
argument_list|(
name|i1
argument_list|)
expr_stmt|;
if|if
condition|(
name|i1
condition|)
name|i1set
operator|=
name|single_set
argument_list|(
name|i1
argument_list|)
expr_stmt|;
if|if
condition|(
name|i1set
condition|)
block|{
name|rtx
name|i2
decl_stmt|;
comment|/* the stack-reg insn prior to I1 */
name|rtx
name|i1src
init|=
operator|*
name|get_true_reg
argument_list|(
operator|&
name|SET_SRC
argument_list|(
name|i1set
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|i1dest
init|=
operator|*
name|get_true_reg
argument_list|(
operator|&
name|SET_DEST
argument_list|(
name|i1set
argument_list|)
argument_list|)
decl_stmt|;
comment|/* If the previous register stack push was from the reg we are to 	 swap with, omit the swap. */
if|if
condition|(
name|GET_CODE
argument_list|(
name|i1dest
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|i1dest
argument_list|)
operator|==
name|FIRST_STACK_REG
operator|&&
name|GET_CODE
argument_list|(
name|i1src
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|i1src
argument_list|)
operator|==
name|hard_regno
operator|-
literal|1
operator|&&
name|find_regno_note
argument_list|(
name|i1
argument_list|,
name|REG_DEAD
argument_list|,
name|FIRST_STACK_REG
argument_list|)
operator|==
name|NULL_RTX
condition|)
return|return;
comment|/* If the previous insn wrote to the reg we are to swap with, 	 omit the swap.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|i1dest
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|i1dest
argument_list|)
operator|==
name|hard_regno
operator|&&
name|GET_CODE
argument_list|(
name|i1src
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|i1src
argument_list|)
operator|==
name|FIRST_STACK_REG
operator|&&
name|find_regno_note
argument_list|(
name|i1
argument_list|,
name|REG_DEAD
argument_list|,
name|FIRST_STACK_REG
argument_list|)
operator|==
name|NULL_RTX
condition|)
return|return;
block|}
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|i1
argument_list|)
argument_list|)
operator|==
literal|'i'
operator|&&
name|sets_cc0_p
argument_list|(
name|PATTERN
argument_list|(
name|i1
argument_list|)
argument_list|)
condition|)
block|{
name|i1
operator|=
name|next_nonnote_insn
argument_list|(
name|i1
argument_list|)
expr_stmt|;
if|if
condition|(
name|i1
operator|==
name|insn
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
name|swap_rtx
operator|=
name|gen_swapdf
argument_list|(
name|FP_mode_reg
index|[
name|hard_regno
index|]
index|[
operator|(
name|int
operator|)
name|DFmode
index|]
argument_list|,
name|FP_mode_reg
index|[
name|FIRST_STACK_REG
index|]
index|[
operator|(
name|int
operator|)
name|DFmode
index|]
argument_list|)
expr_stmt|;
name|swap_insn
operator|=
name|emit_insn_after
argument_list|(
name|swap_rtx
argument_list|,
name|i1
argument_list|)
expr_stmt|;
comment|/* ??? This used to be VOIDmode, but that seems wrong. */
name|PUT_MODE
argument_list|(
name|swap_insn
argument_list|,
name|QImode
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Handle a move to or from a stack register in PAT, which is in INSN.    REGSTACK is the current stack. */
end_comment

begin_function
specifier|static
name|void
name|move_for_stack_reg
parameter_list|(
name|insn
parameter_list|,
name|regstack
parameter_list|,
name|pat
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|stack
name|regstack
decl_stmt|;
name|rtx
name|pat
decl_stmt|;
block|{
name|rtx
modifier|*
name|src
init|=
name|get_true_reg
argument_list|(
operator|&
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
modifier|*
name|dest
init|=
name|get_true_reg
argument_list|(
operator|&
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|note
decl_stmt|;
if|if
condition|(
name|STACK_REG_P
argument_list|(
operator|*
name|src
argument_list|)
operator|&&
name|STACK_REG_P
argument_list|(
operator|*
name|dest
argument_list|)
condition|)
block|{
comment|/* Write from one stack reg to another.  If SRC dies here, then 	 just change the register mapping and delete the insn. */
name|note
operator|=
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
operator|*
name|src
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|note
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* If this is a no-op move, there must not be a REG_DEAD note. */
if|if
condition|(
name|REGNO
argument_list|(
operator|*
name|src
argument_list|)
operator|==
name|REGNO
argument_list|(
operator|*
name|dest
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
name|regstack
operator|->
name|top
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|regstack
operator|->
name|reg
index|[
name|i
index|]
operator|==
name|REGNO
argument_list|(
operator|*
name|src
argument_list|)
condition|)
break|break;
comment|/* The source must be live, and the dest must be dead. */
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|get_hard_regnum
argument_list|(
name|regstack
argument_list|,
operator|*
name|dest
argument_list|)
operator|>=
name|FIRST_STACK_REG
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* It is possible that the dest is unused after this insn. 	     If so, just pop the src. */
if|if
condition|(
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_UNUSED
argument_list|,
name|REGNO
argument_list|(
operator|*
name|dest
argument_list|)
argument_list|)
condition|)
block|{
name|emit_pop_insn
argument_list|(
name|insn
argument_list|,
name|regstack
argument_list|,
operator|*
name|src
argument_list|,
name|emit_insn_after
argument_list|)
expr_stmt|;
name|delete_insn_for_stacker
argument_list|(
name|insn
argument_list|)
expr_stmt|;
return|return;
block|}
name|regstack
operator|->
name|reg
index|[
name|i
index|]
operator|=
name|REGNO
argument_list|(
operator|*
name|dest
argument_list|)
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|REGNO
argument_list|(
operator|*
name|dest
argument_list|)
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|REGNO
argument_list|(
operator|*
name|src
argument_list|)
argument_list|)
expr_stmt|;
name|delete_insn_for_stacker
argument_list|(
name|insn
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* The source reg does not die. */
comment|/* If this appears to be a no-op move, delete it, or else it 	 will confuse the machine description output patterns. But if 	 it is REG_UNUSED, we must pop the reg now, as per-insn processing 	 for REG_UNUSED will not work for deleted insns. */
if|if
condition|(
name|REGNO
argument_list|(
operator|*
name|src
argument_list|)
operator|==
name|REGNO
argument_list|(
operator|*
name|dest
argument_list|)
condition|)
block|{
if|if
condition|(
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_UNUSED
argument_list|,
name|REGNO
argument_list|(
operator|*
name|dest
argument_list|)
argument_list|)
condition|)
name|emit_pop_insn
argument_list|(
name|insn
argument_list|,
name|regstack
argument_list|,
operator|*
name|dest
argument_list|,
name|emit_insn_after
argument_list|)
expr_stmt|;
name|delete_insn_for_stacker
argument_list|(
name|insn
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* The destination ought to be dead */
if|if
condition|(
name|get_hard_regnum
argument_list|(
name|regstack
argument_list|,
operator|*
name|dest
argument_list|)
operator|>=
name|FIRST_STACK_REG
condition|)
name|abort
argument_list|()
expr_stmt|;
name|replace_reg
argument_list|(
name|src
argument_list|,
name|get_hard_regnum
argument_list|(
name|regstack
argument_list|,
operator|*
name|src
argument_list|)
argument_list|)
expr_stmt|;
name|regstack
operator|->
name|reg
index|[
operator|++
name|regstack
operator|->
name|top
index|]
operator|=
name|REGNO
argument_list|(
operator|*
name|dest
argument_list|)
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|REGNO
argument_list|(
operator|*
name|dest
argument_list|)
argument_list|)
expr_stmt|;
name|replace_reg
argument_list|(
name|dest
argument_list|,
name|FIRST_STACK_REG
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STACK_REG_P
argument_list|(
operator|*
name|src
argument_list|)
condition|)
block|{
comment|/* Save from a stack reg to MEM, or possibly integer reg.  Since 	 only top of stack may be saved, emit an exchange first if 	 needs be. */
name|emit_swap_insn
argument_list|(
name|insn
argument_list|,
name|regstack
argument_list|,
operator|*
name|src
argument_list|)
expr_stmt|;
name|note
operator|=
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
operator|*
name|src
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|note
condition|)
block|{
name|replace_reg
argument_list|(
operator|&
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|FIRST_STACK_REG
argument_list|)
expr_stmt|;
name|regstack
operator|->
name|top
operator|--
expr_stmt|;
name|CLEAR_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|REGNO
argument_list|(
operator|*
name|src
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
operator|*
name|src
argument_list|)
operator|==
name|XFmode
operator|&&
name|regstack
operator|->
name|top
operator|!=
name|REG_STACK_SIZE
condition|)
block|{
comment|/* A 387 cannot write an XFmode value to a MEM without 	     clobbering the source reg.  The output code can handle 	     this by reading back the value from the MEM. 	     But it is more efficient to use a temp register if one is 	     available.  Push the source value here if the register 	     stack is not full, and then write the value to memory via 	     a pop.  */
name|rtx
name|push_rtx
decl_stmt|,
name|push_insn
decl_stmt|;
name|rtx
name|top_stack_reg
init|=
name|FP_mode_reg
index|[
name|FIRST_STACK_REG
index|]
index|[
operator|(
name|int
operator|)
name|XFmode
index|]
decl_stmt|;
name|push_rtx
operator|=
name|gen_movxf
argument_list|(
name|top_stack_reg
argument_list|,
name|top_stack_reg
argument_list|)
expr_stmt|;
name|push_insn
operator|=
name|emit_insn_before
argument_list|(
name|push_rtx
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|push_insn
argument_list|,
name|QImode
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|REG_DEAD
argument_list|,
name|top_stack_reg
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|replace_reg
argument_list|(
name|src
argument_list|,
name|FIRST_STACK_REG
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STACK_REG_P
argument_list|(
operator|*
name|dest
argument_list|)
condition|)
block|{
comment|/* Load from MEM, or possibly integer REG or constant, into the 	 stack regs.  The actual target is always the top of the 	 stack. The stack mapping is changed to reflect that DEST is 	 now at top of stack.  */
comment|/* The destination ought to be dead */
if|if
condition|(
name|get_hard_regnum
argument_list|(
name|regstack
argument_list|,
operator|*
name|dest
argument_list|)
operator|>=
name|FIRST_STACK_REG
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|regstack
operator|->
name|top
operator|>=
name|REG_STACK_SIZE
condition|)
name|abort
argument_list|()
expr_stmt|;
name|regstack
operator|->
name|reg
index|[
operator|++
name|regstack
operator|->
name|top
index|]
operator|=
name|REGNO
argument_list|(
operator|*
name|dest
argument_list|)
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|REGNO
argument_list|(
operator|*
name|dest
argument_list|)
argument_list|)
expr_stmt|;
name|replace_reg
argument_list|(
name|dest
argument_list|,
name|FIRST_STACK_REG
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|swap_rtx_condition
parameter_list|(
name|pat
parameter_list|)
name|rtx
name|pat
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|==
literal|'<'
condition|)
block|{
name|PUT_CODE
argument_list|(
name|pat
argument_list|,
name|swap_condition
argument_list|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|pat
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|swap_rtx_condition
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|swap_rtx_condition
argument_list|(
name|XEXP
argument_list|(
name|pat
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Handle a comparison.  Special care needs to be taken to avoid    causing comparisons that a 387 cannot do correctly, such as EQ.     Also, a pop insn may need to be emitted.  The 387 does have an    `fcompp' insn that can pop two regs, but it is sometimes too expensive    to do this - a `fcomp' followed by a `fstpl %st(0)' may be easier to    set up. */
end_comment

begin_function
specifier|static
name|void
name|compare_for_stack_reg
parameter_list|(
name|insn
parameter_list|,
name|regstack
parameter_list|,
name|pat
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|stack
name|regstack
decl_stmt|;
name|rtx
name|pat
decl_stmt|;
block|{
name|rtx
modifier|*
name|src1
decl_stmt|,
modifier|*
name|src2
decl_stmt|;
name|rtx
name|src1_note
decl_stmt|,
name|src2_note
decl_stmt|;
name|src1
operator|=
name|get_true_reg
argument_list|(
operator|&
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|src2
operator|=
name|get_true_reg
argument_list|(
operator|&
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ??? If fxch turns out to be cheaper than fstp, give priority to      registers that die in this insn - move those to stack top first. */
if|if
condition|(
operator|!
name|STACK_REG_P
argument_list|(
operator|*
name|src1
argument_list|)
operator|||
operator|(
name|STACK_REG_P
argument_list|(
operator|*
name|src2
argument_list|)
operator|&&
name|get_hard_regnum
argument_list|(
name|regstack
argument_list|,
operator|*
name|src2
argument_list|)
operator|==
name|FIRST_STACK_REG
operator|)
condition|)
block|{
name|rtx
name|temp
decl_stmt|,
name|next
decl_stmt|;
name|temp
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|=
name|temp
expr_stmt|;
name|src1
operator|=
name|get_true_reg
argument_list|(
operator|&
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|src2
operator|=
name|get_true_reg
argument_list|(
operator|&
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|next
operator|=
name|next_cc0_user
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|==
name|NULL_RTX
condition|)
name|abort
argument_list|()
expr_stmt|;
name|swap_rtx_condition
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|)
expr_stmt|;
name|INSN_CODE
argument_list|(
name|next
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* We will fix any death note later. */
name|src1_note
operator|=
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
operator|*
name|src1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|STACK_REG_P
argument_list|(
operator|*
name|src2
argument_list|)
condition|)
name|src2_note
operator|=
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
operator|*
name|src2
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|src2_note
operator|=
name|NULL_RTX
expr_stmt|;
name|emit_swap_insn
argument_list|(
name|insn
argument_list|,
name|regstack
argument_list|,
operator|*
name|src1
argument_list|)
expr_stmt|;
name|replace_reg
argument_list|(
name|src1
argument_list|,
name|FIRST_STACK_REG
argument_list|)
expr_stmt|;
if|if
condition|(
name|STACK_REG_P
argument_list|(
operator|*
name|src2
argument_list|)
condition|)
name|replace_reg
argument_list|(
name|src2
argument_list|,
name|get_hard_regnum
argument_list|(
name|regstack
argument_list|,
operator|*
name|src2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|src1_note
condition|)
block|{
name|CLEAR_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|src1_note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|replace_reg
argument_list|(
operator|&
name|XEXP
argument_list|(
name|src1_note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|FIRST_STACK_REG
argument_list|)
expr_stmt|;
name|regstack
operator|->
name|top
operator|--
expr_stmt|;
block|}
comment|/* If the second operand dies, handle that.  But if the operands are      the same stack register, don't bother, because only one death is      needed, and it was just handled. */
if|if
condition|(
name|src2_note
operator|&&
operator|!
operator|(
name|STACK_REG_P
argument_list|(
operator|*
name|src1
argument_list|)
operator|&&
name|STACK_REG_P
argument_list|(
operator|*
name|src2
argument_list|)
operator|&&
name|REGNO
argument_list|(
operator|*
name|src1
argument_list|)
operator|==
name|REGNO
argument_list|(
operator|*
name|src2
argument_list|)
operator|)
condition|)
block|{
comment|/* As a special case, two regs may die in this insn if src2 is 	 next to top of stack and the top of stack also dies.  Since 	 we have already popped src1, "next to top of stack" is really 	 at top (FIRST_STACK_REG) now. */
if|if
condition|(
name|get_hard_regnum
argument_list|(
name|regstack
argument_list|,
name|XEXP
argument_list|(
name|src2_note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|FIRST_STACK_REG
operator|&&
name|src1_note
condition|)
block|{
name|CLEAR_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|src2_note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|replace_reg
argument_list|(
operator|&
name|XEXP
argument_list|(
name|src2_note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|FIRST_STACK_REG
operator|+
literal|1
argument_list|)
expr_stmt|;
name|regstack
operator|->
name|top
operator|--
expr_stmt|;
block|}
else|else
block|{
comment|/* The 386 can only represent death of the first operand in 	     the case handled above.  In all other cases, emit a separate 	     pop and remove the death note from here. */
name|link_cc0_insns
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|remove_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|src2_note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_pop_insn
argument_list|(
name|insn
argument_list|,
name|regstack
argument_list|,
name|XEXP
argument_list|(
name|src2_note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|emit_insn_after
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Substitute new registers in PAT, which is part of INSN.  REGSTACK    is the current register layout. */
end_comment

begin_function
specifier|static
name|void
name|subst_stack_regs_pat
parameter_list|(
name|insn
parameter_list|,
name|regstack
parameter_list|,
name|pat
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|stack
name|regstack
decl_stmt|;
name|rtx
name|pat
decl_stmt|;
block|{
name|rtx
modifier|*
name|dest
decl_stmt|,
modifier|*
name|src
decl_stmt|;
name|rtx
modifier|*
name|src1
init|=
operator|(
name|rtx
operator|*
operator|)
name|NULL_PTR
decl_stmt|,
modifier|*
name|src2
decl_stmt|;
name|rtx
name|src1_note
decl_stmt|,
name|src2_note
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|!=
name|SET
condition|)
return|return;
name|dest
operator|=
name|get_true_reg
argument_list|(
operator|&
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
expr_stmt|;
name|src
operator|=
name|get_true_reg
argument_list|(
operator|&
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
expr_stmt|;
comment|/* See if this is a `movM' pattern, and handle elsewhere if so. */
if|if
condition|(
operator|*
name|dest
operator|!=
name|cc0_rtx
operator|&&
operator|(
name|STACK_REG_P
argument_list|(
operator|*
name|src
argument_list|)
operator|||
operator|(
name|STACK_REG_P
argument_list|(
operator|*
name|dest
argument_list|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
operator|*
name|src
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
operator|*
name|src
argument_list|)
operator|==
name|MEM
operator|||
name|GET_CODE
argument_list|(
operator|*
name|src
argument_list|)
operator|==
name|CONST_DOUBLE
operator|)
operator|)
operator|)
condition|)
name|move_for_stack_reg
argument_list|(
name|insn
argument_list|,
name|regstack
argument_list|,
name|pat
argument_list|)
expr_stmt|;
else|else
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|COMPARE
case|:
name|compare_for_stack_reg
argument_list|(
name|insn
argument_list|,
name|regstack
argument_list|,
name|pat
argument_list|)
expr_stmt|;
break|break;
case|case
name|CALL
case|:
name|regstack
operator|->
name|reg
index|[
operator|++
name|regstack
operator|->
name|top
index|]
operator|=
name|REGNO
argument_list|(
operator|*
name|dest
argument_list|)
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|REGNO
argument_list|(
operator|*
name|dest
argument_list|)
argument_list|)
expr_stmt|;
name|replace_reg
argument_list|(
name|dest
argument_list|,
name|FIRST_STACK_REG
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG
case|:
comment|/* This is a `tstM2' case. */
if|if
condition|(
operator|*
name|dest
operator|!=
name|cc0_rtx
condition|)
name|abort
argument_list|()
expr_stmt|;
name|src1
operator|=
name|src
expr_stmt|;
comment|/* Fall through. */
case|case
name|FLOAT_TRUNCATE
case|:
case|case
name|SQRT
case|:
case|case
name|ABS
case|:
case|case
name|NEG
case|:
comment|/* These insns only operate on the top of the stack. DEST might 	   be cc0_rtx if we're processing a tstM pattern. Also, it's 	   possible that the tstM case results in a REG_DEAD note on the 	   source.  */
if|if
condition|(
name|src1
operator|==
literal|0
condition|)
name|src1
operator|=
name|get_true_reg
argument_list|(
operator|&
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|emit_swap_insn
argument_list|(
name|insn
argument_list|,
name|regstack
argument_list|,
operator|*
name|src1
argument_list|)
expr_stmt|;
name|src1_note
operator|=
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
operator|*
name|src1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|STACK_REG_P
argument_list|(
operator|*
name|dest
argument_list|)
condition|)
name|replace_reg
argument_list|(
name|dest
argument_list|,
name|FIRST_STACK_REG
argument_list|)
expr_stmt|;
if|if
condition|(
name|src1_note
condition|)
block|{
name|replace_reg
argument_list|(
operator|&
name|XEXP
argument_list|(
name|src1_note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|FIRST_STACK_REG
argument_list|)
expr_stmt|;
name|regstack
operator|->
name|top
operator|--
expr_stmt|;
name|CLEAR_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|REGNO
argument_list|(
operator|*
name|src1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|replace_reg
argument_list|(
name|src1
argument_list|,
name|FIRST_STACK_REG
argument_list|)
expr_stmt|;
break|break;
case|case
name|MINUS
case|:
case|case
name|DIV
case|:
comment|/* On i386, reversed forms of subM3 and divM3 exist for 	   MODE_FLOAT, so the same code that works for addM3 and mulM3 	   can be used. */
case|case
name|MULT
case|:
case|case
name|PLUS
case|:
comment|/* These insns can accept the top of stack as a destination 	   from a stack reg or mem, or can use the top of stack as a 	   source and some other stack register (possibly top of stack) 	   as a destination. */
name|src1
operator|=
name|get_true_reg
argument_list|(
operator|&
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|src2
operator|=
name|get_true_reg
argument_list|(
operator|&
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We will fix any death note later. */
if|if
condition|(
name|STACK_REG_P
argument_list|(
operator|*
name|src1
argument_list|)
condition|)
name|src1_note
operator|=
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
operator|*
name|src1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|src1_note
operator|=
name|NULL_RTX
expr_stmt|;
if|if
condition|(
name|STACK_REG_P
argument_list|(
operator|*
name|src2
argument_list|)
condition|)
name|src2_note
operator|=
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
operator|*
name|src2
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|src2_note
operator|=
name|NULL_RTX
expr_stmt|;
comment|/* If either operand is not a stack register, then the dest 	   must be top of stack. */
if|if
condition|(
operator|!
name|STACK_REG_P
argument_list|(
operator|*
name|src1
argument_list|)
operator|||
operator|!
name|STACK_REG_P
argument_list|(
operator|*
name|src2
argument_list|)
condition|)
name|emit_swap_insn
argument_list|(
name|insn
argument_list|,
name|regstack
argument_list|,
operator|*
name|dest
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Both operands are REG.  If neither operand is already 	       at the top of stack, choose to make the one that is the dest 	       the new top of stack.  */
name|int
name|src1_hard_regnum
decl_stmt|,
name|src2_hard_regnum
decl_stmt|;
name|src1_hard_regnum
operator|=
name|get_hard_regnum
argument_list|(
name|regstack
argument_list|,
operator|*
name|src1
argument_list|)
expr_stmt|;
name|src2_hard_regnum
operator|=
name|get_hard_regnum
argument_list|(
name|regstack
argument_list|,
operator|*
name|src2
argument_list|)
expr_stmt|;
if|if
condition|(
name|src1_hard_regnum
operator|==
operator|-
literal|1
operator|||
name|src2_hard_regnum
operator|==
operator|-
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|src1_hard_regnum
operator|!=
name|FIRST_STACK_REG
operator|&&
name|src2_hard_regnum
operator|!=
name|FIRST_STACK_REG
condition|)
name|emit_swap_insn
argument_list|(
name|insn
argument_list|,
name|regstack
argument_list|,
operator|*
name|dest
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|STACK_REG_P
argument_list|(
operator|*
name|src1
argument_list|)
condition|)
name|replace_reg
argument_list|(
name|src1
argument_list|,
name|get_hard_regnum
argument_list|(
name|regstack
argument_list|,
operator|*
name|src1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|STACK_REG_P
argument_list|(
operator|*
name|src2
argument_list|)
condition|)
name|replace_reg
argument_list|(
name|src2
argument_list|,
name|get_hard_regnum
argument_list|(
name|regstack
argument_list|,
operator|*
name|src2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|src1_note
condition|)
block|{
comment|/* If the register that dies is at the top of stack, then 	       the destination is somewhere else - merely substitute it. 	       But if the reg that dies is not at top of stack, then 	       move the top of stack to the dead reg, as though we had 	       done the insn and then a store-with-pop. */
if|if
condition|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|src1_note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|regstack
operator|->
name|reg
index|[
name|regstack
operator|->
name|top
index|]
condition|)
block|{
name|SET_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|REGNO
argument_list|(
operator|*
name|dest
argument_list|)
argument_list|)
expr_stmt|;
name|replace_reg
argument_list|(
name|dest
argument_list|,
name|get_hard_regnum
argument_list|(
name|regstack
argument_list|,
operator|*
name|dest
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|regno
init|=
name|get_hard_regnum
argument_list|(
name|regstack
argument_list|,
name|XEXP
argument_list|(
name|src1_note
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|REGNO
argument_list|(
operator|*
name|dest
argument_list|)
argument_list|)
expr_stmt|;
name|replace_reg
argument_list|(
name|dest
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|regstack
operator|->
name|reg
index|[
name|regstack
operator|->
name|top
operator|-
operator|(
name|regno
operator|-
name|FIRST_STACK_REG
operator|)
index|]
operator|=
name|regstack
operator|->
name|reg
index|[
name|regstack
operator|->
name|top
index|]
expr_stmt|;
block|}
name|CLEAR_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|src1_note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|replace_reg
argument_list|(
operator|&
name|XEXP
argument_list|(
name|src1_note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|FIRST_STACK_REG
argument_list|)
expr_stmt|;
name|regstack
operator|->
name|top
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|src2_note
condition|)
block|{
if|if
condition|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|src2_note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|regstack
operator|->
name|reg
index|[
name|regstack
operator|->
name|top
index|]
condition|)
block|{
name|SET_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|REGNO
argument_list|(
operator|*
name|dest
argument_list|)
argument_list|)
expr_stmt|;
name|replace_reg
argument_list|(
name|dest
argument_list|,
name|get_hard_regnum
argument_list|(
name|regstack
argument_list|,
operator|*
name|dest
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|regno
init|=
name|get_hard_regnum
argument_list|(
name|regstack
argument_list|,
name|XEXP
argument_list|(
name|src2_note
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|REGNO
argument_list|(
operator|*
name|dest
argument_list|)
argument_list|)
expr_stmt|;
name|replace_reg
argument_list|(
name|dest
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|regstack
operator|->
name|reg
index|[
name|regstack
operator|->
name|top
operator|-
operator|(
name|regno
operator|-
name|FIRST_STACK_REG
operator|)
index|]
operator|=
name|regstack
operator|->
name|reg
index|[
name|regstack
operator|->
name|top
index|]
expr_stmt|;
block|}
name|CLEAR_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|src2_note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|replace_reg
argument_list|(
operator|&
name|XEXP
argument_list|(
name|src2_note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|FIRST_STACK_REG
argument_list|)
expr_stmt|;
name|regstack
operator|->
name|top
operator|--
expr_stmt|;
block|}
else|else
block|{
name|SET_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|REGNO
argument_list|(
operator|*
name|dest
argument_list|)
argument_list|)
expr_stmt|;
name|replace_reg
argument_list|(
name|dest
argument_list|,
name|get_hard_regnum
argument_list|(
name|regstack
argument_list|,
operator|*
name|dest
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|UNSPEC
case|:
switch|switch
condition|(
name|XINT
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
comment|/* sin */
case|case
literal|2
case|:
comment|/* cos */
comment|/* These insns only operate on the top of the stack.  */
name|src1
operator|=
name|get_true_reg
argument_list|(
operator|&
name|XVECEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|emit_swap_insn
argument_list|(
name|insn
argument_list|,
name|regstack
argument_list|,
operator|*
name|src1
argument_list|)
expr_stmt|;
name|src1_note
operator|=
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
operator|*
name|src1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|STACK_REG_P
argument_list|(
operator|*
name|dest
argument_list|)
condition|)
name|replace_reg
argument_list|(
name|dest
argument_list|,
name|FIRST_STACK_REG
argument_list|)
expr_stmt|;
if|if
condition|(
name|src1_note
condition|)
block|{
name|replace_reg
argument_list|(
operator|&
name|XEXP
argument_list|(
name|src1_note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|FIRST_STACK_REG
argument_list|)
expr_stmt|;
name|regstack
operator|->
name|top
operator|--
expr_stmt|;
name|CLEAR_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|REGNO
argument_list|(
operator|*
name|src1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|replace_reg
argument_list|(
name|src1
argument_list|,
name|FIRST_STACK_REG
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Substitute hard regnums for any stack regs in INSN, which has    N_INPUTS inputs and N_OUTPUTS outputs.  REGSTACK is the stack info    before the insn, and is updated with changes made here.  CONSTRAINTS is    an array of the constraint strings used in the asm statement.     OPERANDS is an array of the operands, and OPERANDS_LOC is a    parallel array of where the operands were found.  The output operands    all precede the input operands.     There are several requirements and assumptions about the use of    stack-like regs in asm statements.  These rules are enforced by    record_asm_stack_regs; see comments there for details.  Any    asm_operands left in the RTL at this point may be assume to meet the    requirements, since record_asm_stack_regs removes any problem asm.  */
end_comment

begin_function
specifier|static
name|void
name|subst_asm_stack_regs
parameter_list|(
name|insn
parameter_list|,
name|regstack
parameter_list|,
name|operands
parameter_list|,
name|operands_loc
parameter_list|,
name|constraints
parameter_list|,
name|n_inputs
parameter_list|,
name|n_outputs
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|stack
name|regstack
decl_stmt|;
name|rtx
modifier|*
name|operands
decl_stmt|,
decl|*
modifier|*
name|operands_loc
decl_stmt|;
end_function

begin_decl_stmt
name|char
modifier|*
modifier|*
name|constraints
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n_inputs
decl_stmt|,
name|n_outputs
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|n_operands
init|=
name|n_inputs
operator|+
name|n_outputs
decl_stmt|;
name|int
name|first_input
init|=
name|n_outputs
decl_stmt|;
name|rtx
name|body
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
modifier|*
name|operand_matches
init|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|n_operands
operator|*
sizeof|sizeof
argument_list|(
name|int
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|enum
name|reg_class
modifier|*
name|operand_class
init|=
operator|(
expr|enum
name|reg_class
operator|*
operator|)
name|alloca
argument_list|(
name|n_operands
operator|*
sizeof|sizeof
argument_list|(
expr|enum
name|reg_class
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
modifier|*
name|note_reg
decl_stmt|;
comment|/* Array of note contents */
name|rtx
modifier|*
modifier|*
name|note_loc
decl_stmt|;
comment|/* Address of REG field of each note */
name|enum
name|reg_note
modifier|*
name|note_kind
decl_stmt|;
comment|/* The type of each note */
name|rtx
modifier|*
name|clobber_reg
decl_stmt|;
name|rtx
modifier|*
modifier|*
name|clobber_loc
decl_stmt|;
name|struct
name|stack_def
name|temp_stack
decl_stmt|;
name|int
name|n_notes
decl_stmt|;
name|int
name|n_clobbers
decl_stmt|;
name|rtx
name|note
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Find out what the constraints required.  If no constraint      alternative matches, that is a compiler bug: we should have caught      such an insn during the life analysis pass (and reload should have      caught it regardless). */
name|i
operator|=
name|constrain_asm_operands
argument_list|(
name|n_operands
argument_list|,
name|operands
argument_list|,
name|constraints
argument_list|,
name|operand_matches
argument_list|,
name|operand_class
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Strip SUBREGs here to make the following code simpler. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_operands
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|operands_loc
index|[
name|i
index|]
operator|=
operator|&
name|SUBREG_REG
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|operands
index|[
name|i
index|]
operator|=
name|SUBREG_REG
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Set up NOTE_REG, NOTE_LOC and NOTE_KIND.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|note
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
name|i
operator|++
expr_stmt|;
name|note_reg
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|i
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|note_loc
operator|=
operator|(
name|rtx
operator|*
operator|*
operator|)
name|alloca
argument_list|(
name|i
operator|*
sizeof|sizeof
argument_list|(
name|rtx
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|note_kind
operator|=
operator|(
expr|enum
name|reg_note
operator|*
operator|)
name|alloca
argument_list|(
name|i
operator|*
sizeof|sizeof
argument_list|(
expr|enum
name|reg_note
argument_list|)
argument_list|)
expr_stmt|;
name|n_notes
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|rtx
name|reg
init|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
modifier|*
name|loc
init|=
operator|&
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|loc
operator|=
operator|&
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|STACK_REG_P
argument_list|(
name|reg
argument_list|)
operator|&&
operator|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_DEAD
operator|||
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_UNUSED
operator|)
condition|)
block|{
name|note_reg
index|[
name|n_notes
index|]
operator|=
name|reg
expr_stmt|;
name|note_loc
index|[
name|n_notes
index|]
operator|=
name|loc
expr_stmt|;
name|note_kind
index|[
name|n_notes
index|]
operator|=
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
expr_stmt|;
name|n_notes
operator|++
expr_stmt|;
block|}
block|}
comment|/* Set up CLOBBER_REG and CLOBBER_LOC.  */
name|n_clobbers
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|clobber_reg
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|rtx
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|clobber_loc
operator|=
operator|(
name|rtx
operator|*
operator|*
operator|)
name|alloca
argument_list|(
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|rtx
operator|*
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
block|{
name|rtx
name|clobber
init|=
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|rtx
name|reg
init|=
name|XEXP
argument_list|(
name|clobber
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
modifier|*
name|loc
init|=
operator|&
name|XEXP
argument_list|(
name|clobber
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|loc
operator|=
operator|&
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|STACK_REG_P
argument_list|(
name|reg
argument_list|)
condition|)
block|{
name|clobber_reg
index|[
name|n_clobbers
index|]
operator|=
name|reg
expr_stmt|;
name|clobber_loc
index|[
name|n_clobbers
index|]
operator|=
name|loc
expr_stmt|;
name|n_clobbers
operator|++
expr_stmt|;
block|}
block|}
block|}
name|bcopy
argument_list|(
name|regstack
argument_list|,
operator|&
name|temp_stack
argument_list|,
sizeof|sizeof
argument_list|(
name|temp_stack
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Put the input regs into the desired place in TEMP_STACK.  */
for|for
control|(
name|i
operator|=
name|first_input
init|;
name|i
operator|<
name|first_input
operator|+
name|n_inputs
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|STACK_REG_P
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|)
operator|&&
name|reg_class_subset_p
argument_list|(
name|operand_class
index|[
name|i
index|]
argument_list|,
name|FLOAT_REGS
argument_list|)
operator|&&
name|operand_class
index|[
name|i
index|]
operator|!=
name|FLOAT_REGS
condition|)
block|{
comment|/* If an operand needs to be in a particular reg in 	   FLOAT_REGS, the constraint was either 't' or 'u'.  Since 	   these constraints are for single register classes, and reload 	   guaranteed that operand[i] is already in that class, we can 	   just use REGNO (operands[i]) to know which actual reg this 	   operand needs to be in. */
name|int
name|regno
init|=
name|get_hard_regnum
argument_list|(
operator|&
name|temp_stack
argument_list|,
name|operands
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|regno
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|regno
operator|!=
name|REGNO
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|)
condition|)
block|{
comment|/* operands[i] is not in the right place.  Find it 	       and swap it with whatever is already in I's place. 	       K is where operands[i] is now.  J is where it should 	       be. */
name|int
name|j
decl_stmt|,
name|k
decl_stmt|,
name|temp
decl_stmt|;
name|k
operator|=
name|temp_stack
operator|.
name|top
operator|-
operator|(
name|regno
operator|-
name|FIRST_STACK_REG
operator|)
expr_stmt|;
name|j
operator|=
operator|(
name|temp_stack
operator|.
name|top
operator|-
operator|(
name|REGNO
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|)
operator|-
name|FIRST_STACK_REG
operator|)
operator|)
expr_stmt|;
name|temp
operator|=
name|temp_stack
operator|.
name|reg
index|[
name|k
index|]
expr_stmt|;
name|temp_stack
operator|.
name|reg
index|[
name|k
index|]
operator|=
name|temp_stack
operator|.
name|reg
index|[
name|j
index|]
expr_stmt|;
name|temp_stack
operator|.
name|reg
index|[
name|j
index|]
operator|=
name|temp
expr_stmt|;
block|}
block|}
comment|/* emit insns before INSN to make sure the reg-stack is in the right      order.  */
name|change_stack
argument_list|(
name|insn
argument_list|,
name|regstack
argument_list|,
operator|&
name|temp_stack
argument_list|,
name|emit_insn_before
argument_list|)
expr_stmt|;
comment|/* Make the needed input register substitutions.  Do death notes and      clobbers too, because these are for inputs, not outputs. */
for|for
control|(
name|i
operator|=
name|first_input
init|;
name|i
operator|<
name|first_input
operator|+
name|n_inputs
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|STACK_REG_P
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|int
name|regnum
init|=
name|get_hard_regnum
argument_list|(
name|regstack
argument_list|,
name|operands
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|regnum
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|replace_reg
argument_list|(
name|operands_loc
index|[
name|i
index|]
argument_list|,
name|regnum
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_notes
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|note_kind
index|[
name|i
index|]
operator|==
name|REG_DEAD
condition|)
block|{
name|int
name|regnum
init|=
name|get_hard_regnum
argument_list|(
name|regstack
argument_list|,
name|note_reg
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|regnum
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|replace_reg
argument_list|(
name|note_loc
index|[
name|i
index|]
argument_list|,
name|regnum
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_clobbers
condition|;
name|i
operator|++
control|)
block|{
comment|/* It's OK for a CLOBBER to reference a reg that is not live.          Don't try to replace it in that case.  */
name|int
name|regnum
init|=
name|get_hard_regnum
argument_list|(
name|regstack
argument_list|,
name|clobber_reg
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|regnum
operator|>=
literal|0
condition|)
block|{
comment|/* Sigh - clobbers always have QImode.  But replace_reg knows 	     that these regs can't be MODE_INT and will abort.  Just put 	     the right reg there without calling replace_reg.  */
operator|*
name|clobber_loc
index|[
name|i
index|]
operator|=
name|FP_mode_reg
index|[
name|regnum
index|]
index|[
operator|(
name|int
operator|)
name|DFmode
index|]
expr_stmt|;
block|}
block|}
comment|/* Now remove from REGSTACK any inputs that the asm implicitly popped. */
for|for
control|(
name|i
operator|=
name|first_input
init|;
name|i
operator|<
name|first_input
operator|+
name|n_inputs
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|STACK_REG_P
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|)
condition|)
block|{
comment|/* An input reg is implicitly popped if it is tied to an 	   output, or if there is a CLOBBER for it. */
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_clobbers
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|operands_match_p
argument_list|(
name|clobber_reg
index|[
name|j
index|]
argument_list|,
name|operands
index|[
name|i
index|]
argument_list|)
condition|)
break|break;
if|if
condition|(
name|j
operator|<
name|n_clobbers
operator|||
name|operand_matches
index|[
name|i
index|]
operator|>=
literal|0
condition|)
block|{
comment|/* operands[i] might not be at the top of stack.  But that's OK, 	       because all we need to do is pop the right number of regs 	       off of the top of the reg-stack.  record_asm_stack_regs 	       guaranteed that all implicitly popped regs were grouped 	       at the top of the reg-stack.  */
name|CLEAR_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|regstack
operator|->
name|reg
index|[
name|regstack
operator|->
name|top
index|]
argument_list|)
expr_stmt|;
name|regstack
operator|->
name|top
operator|--
expr_stmt|;
block|}
block|}
comment|/* Now add to REGSTACK any outputs that the asm implicitly pushed.      Note that there isn't any need to substitute register numbers.      ???  Explain why this is true. */
for|for
control|(
name|i
operator|=
name|LAST_STACK_REG
init|;
name|i
operator|>=
name|FIRST_STACK_REG
condition|;
name|i
operator|--
control|)
block|{
comment|/* See if there is an output for this hard reg.  */
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_outputs
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|STACK_REG_P
argument_list|(
name|operands
index|[
name|j
index|]
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|operands
index|[
name|j
index|]
argument_list|)
operator|==
name|i
condition|)
block|{
name|regstack
operator|->
name|reg
index|[
operator|++
name|regstack
operator|->
name|top
index|]
operator|=
name|i
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Now emit a pop insn for any REG_UNUSED output, or any REG_DEAD      input that the asm didn't implicitly pop.  If the asm didn't      implicitly pop an input reg, that reg will still be live.       Note that we can't use find_regno_note here: the register numbers      in the death notes have already been substituted.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_outputs
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|STACK_REG_P
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_notes
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|REGNO
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|)
operator|==
name|REGNO
argument_list|(
name|note_reg
index|[
name|j
index|]
argument_list|)
operator|&&
name|note_kind
index|[
name|j
index|]
operator|==
name|REG_UNUSED
condition|)
block|{
name|insn
operator|=
name|emit_pop_insn
argument_list|(
name|insn
argument_list|,
name|regstack
argument_list|,
name|operands
index|[
name|i
index|]
argument_list|,
name|emit_insn_after
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
for|for
control|(
name|i
operator|=
name|first_input
init|;
name|i
operator|<
name|first_input
operator|+
name|n_inputs
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|STACK_REG_P
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_notes
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|REGNO
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|)
operator|==
name|REGNO
argument_list|(
name|note_reg
index|[
name|j
index|]
argument_list|)
operator|&&
name|note_kind
index|[
name|j
index|]
operator|==
name|REG_DEAD
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|)
argument_list|)
condition|)
block|{
name|insn
operator|=
name|emit_pop_insn
argument_list|(
name|insn
argument_list|,
name|regstack
argument_list|,
name|operands
index|[
name|i
index|]
argument_list|,
name|emit_insn_after
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Substitute stack hard reg numbers for stack virtual registers in    INSN.  Non-stack register numbers are not changed.  REGSTACK is the    current stack content.  Insns may be emitted as needed to arrange the    stack for the 387 based on the contents of the insn. */
end_comment

begin_function
specifier|static
name|void
name|subst_stack_regs
parameter_list|(
name|insn
parameter_list|,
name|regstack
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|stack
name|regstack
decl_stmt|;
block|{
specifier|register
name|rtx
modifier|*
name|note_link
decl_stmt|,
name|note
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|n_operands
decl_stmt|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|CALL_INSN
operator|)
operator|||
name|INSN_DELETED_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return;
comment|/* The stack should be empty at a call. */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
for|for
control|(
name|i
operator|=
name|FIRST_STACK_REG
init|;
name|i
operator|<=
name|LAST_STACK_REG
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|regstack
operator|->
name|reg_set
argument_list|,
name|i
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Do the actual substitution if any stack regs are mentioned.      Since we only record whether entire insn mentions stack regs, and      subst_stack_regs_pat only works for patterns that contain stack regs,      we must check each pattern in a parallel here.  A call_value_pop could      fail otherwise. */
if|if
condition|(
name|GET_MODE
argument_list|(
name|insn
argument_list|)
operator|==
name|QImode
condition|)
block|{
name|n_operands
operator|=
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_operands
operator|>=
literal|0
condition|)
block|{
comment|/* This insn is an `asm' with operands.  Decode the operands, 	     decide how many are inputs, and do register substitution. 	     Any REG_UNUSED notes will be handled by subst_asm_stack_regs. */
name|rtx
name|operands
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|rtx
modifier|*
name|operands_loc
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|rtx
name|body
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
name|n_inputs
decl_stmt|,
name|n_outputs
decl_stmt|;
name|char
modifier|*
modifier|*
name|constraints
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|alloca
argument_list|(
name|n_operands
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|decode_asm_operands
argument_list|(
name|body
argument_list|,
name|operands
argument_list|,
name|operands_loc
argument_list|,
name|constraints
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|get_asm_operand_lengths
argument_list|(
name|body
argument_list|,
name|n_operands
argument_list|,
operator|&
name|n_inputs
argument_list|,
operator|&
name|n_outputs
argument_list|)
expr_stmt|;
name|subst_asm_stack_regs
argument_list|(
name|insn
argument_list|,
name|regstack
argument_list|,
name|operands
argument_list|,
name|operands_loc
argument_list|,
name|constraints
argument_list|,
name|n_inputs
argument_list|,
name|n_outputs
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|stack_regs_mentioned_p
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
name|subst_stack_regs_pat
argument_list|(
name|insn
argument_list|,
name|regstack
argument_list|,
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|subst_stack_regs_pat
argument_list|(
name|insn
argument_list|,
name|regstack
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* subst_stack_regs_pat may have deleted a no-op insn.  If so, any      REG_UNUSED will already have been dealt with, so just return. */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
return|return;
comment|/* If there is a REG_UNUSED note on a stack register on this insn,      the indicated reg must be popped.  The REG_UNUSED note is removed,      since the form of the newly emitted pop insn references the reg,      making it no longer `unset'. */
name|note_link
operator|=
operator|&
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
expr_stmt|;
for|for
control|(
name|note
operator|=
operator|*
name|note_link
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_UNUSED
operator|&&
name|STACK_REG_P
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
operator|*
name|note_link
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_pop_insn
argument_list|(
name|insn
argument_list|,
name|regstack
argument_list|,
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|emit_insn_after
argument_list|)
expr_stmt|;
block|}
else|else
name|note_link
operator|=
operator|&
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Change the organization of the stack so that it fits a new basic    block.  Some registers might have to be popped, but there can never be    a register live in the new block that is not now live.     Insert any needed insns before or after INSN.  WHEN is emit_insn_before    or emit_insn_after. OLD is the original stack layout, and NEW is    the desired form.  OLD is updated to reflect the code emitted, ie, it    will be the same as NEW upon return.     This function will not preserve block_end[].  But that information    is no longer needed once this has executed. */
end_comment

begin_decl_stmt
specifier|static
name|void
name|change_stack
argument_list|(
name|insn
argument_list|,
name|old
argument_list|,
name|new
argument_list|,
name|when
argument_list|)
name|rtx
name|insn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|stack
name|old
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|stack
name|new
decl_stmt|;
end_decl_stmt

begin_function_decl
name|rtx
function_decl|(
modifier|*
name|when
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
name|int
name|reg
decl_stmt|;
comment|/* We will be inserting new insns "backwards", by calling emit_insn_before.      If we are to insert after INSN, find the next insn, and insert before      it.  */
if|if
condition|(
name|when
operator|==
name|emit_insn_after
condition|)
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Pop any registers that are not needed in the new block. */
for|for
control|(
name|reg
operator|=
name|old
operator|->
name|top
init|;
name|reg
operator|>=
literal|0
condition|;
name|reg
operator|--
control|)
if|if
condition|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|new
operator|->
name|reg_set
argument_list|,
name|old
operator|->
name|reg
index|[
name|reg
index|]
argument_list|)
condition|)
name|emit_pop_insn
argument_list|(
name|insn
argument_list|,
name|old
argument_list|,
name|FP_mode_reg
index|[
name|old
operator|->
name|reg
index|[
name|reg
index|]
index|]
index|[
operator|(
name|int
operator|)
name|DFmode
index|]
argument_list|,
name|emit_insn_before
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|->
name|top
operator|==
operator|-
literal|2
condition|)
block|{
comment|/* If the new block has never been processed, then it can inherit 	 the old stack order. */
name|new
operator|->
name|top
operator|=
name|old
operator|->
name|top
expr_stmt|;
name|bcopy
argument_list|(
name|old
operator|->
name|reg
argument_list|,
name|new
operator|->
name|reg
argument_list|,
sizeof|sizeof
argument_list|(
name|new
operator|->
name|reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This block has been entered before, and we must match the 	 previously selected stack order. */
comment|/* By now, the only difference should be the order of the stack, 	 not their depth or liveliness. */
name|GO_IF_HARD_REG_EQUAL
argument_list|(
name|old
operator|->
name|reg_set
argument_list|,
name|new
operator|->
name|reg_set
argument_list|,
name|win
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
name|win
label|:
if|if
condition|(
name|old
operator|->
name|top
operator|!=
name|new
operator|->
name|top
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Loop here emitting swaps until the stack is correct.  The 	 worst case number of swaps emitted is N + 2, where N is the 	 depth of the stack.  In some cases, the reg at the top of 	 stack may be correct, but swapped anyway in order to fix 	 other regs.  But since we never swap any other reg away from 	 its correct slot, this algorithm will converge. */
do|do
block|{
comment|/* Swap the reg at top of stack into the position it is 	     supposed to be in, until the correct top of stack appears. */
while|while
condition|(
name|old
operator|->
name|reg
index|[
name|old
operator|->
name|top
index|]
operator|!=
name|new
operator|->
name|reg
index|[
name|new
operator|->
name|top
index|]
condition|)
block|{
for|for
control|(
name|reg
operator|=
name|new
operator|->
name|top
init|;
name|reg
operator|>=
literal|0
condition|;
name|reg
operator|--
control|)
if|if
condition|(
name|new
operator|->
name|reg
index|[
name|reg
index|]
operator|==
name|old
operator|->
name|reg
index|[
name|old
operator|->
name|top
index|]
condition|)
break|break;
if|if
condition|(
name|reg
operator|==
operator|-
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
name|emit_swap_insn
argument_list|(
name|insn
argument_list|,
name|old
argument_list|,
name|FP_mode_reg
index|[
name|old
operator|->
name|reg
index|[
name|reg
index|]
index|]
index|[
operator|(
name|int
operator|)
name|DFmode
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* See if any regs remain incorrect.  If so, bring an 	     incorrect reg to the top of stack, and let the while loop 	     above fix it. */
for|for
control|(
name|reg
operator|=
name|new
operator|->
name|top
init|;
name|reg
operator|>=
literal|0
condition|;
name|reg
operator|--
control|)
if|if
condition|(
name|new
operator|->
name|reg
index|[
name|reg
index|]
operator|!=
name|old
operator|->
name|reg
index|[
name|reg
index|]
condition|)
block|{
name|emit_swap_insn
argument_list|(
name|insn
argument_list|,
name|old
argument_list|,
name|FP_mode_reg
index|[
name|old
operator|->
name|reg
index|[
name|reg
index|]
index|]
index|[
operator|(
name|int
operator|)
name|DFmode
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|reg
operator|>=
literal|0
condition|)
do|;
comment|/* At this point there must be no differences. */
for|for
control|(
name|reg
operator|=
name|old
operator|->
name|top
init|;
name|reg
operator|>=
literal|0
condition|;
name|reg
operator|--
control|)
if|if
condition|(
name|old
operator|->
name|reg
index|[
name|reg
index|]
operator|!=
name|new
operator|->
name|reg
index|[
name|reg
index|]
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Check PAT, which points to RTL in INSN, for a LABEL_REF.  If it is    found, ensure that a jump from INSN to the code_label to which the    label_ref points ends up with the same stack as that at the    code_label.  Do this by inserting insns just before the code_label to    pop and rotate the stack until it is in the correct order.  REGSTACK    is the order of the register stack in INSN.     Any code that is emitted here must not be later processed as part    of any block, as it will already contain hard register numbers. */
end_comment

begin_function
specifier|static
name|void
name|goto_block_pat
parameter_list|(
name|insn
parameter_list|,
name|regstack
parameter_list|,
name|pat
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|stack
name|regstack
decl_stmt|;
name|rtx
name|pat
decl_stmt|;
block|{
name|rtx
name|label
decl_stmt|;
name|rtx
name|new_jump
decl_stmt|,
name|new_label
decl_stmt|,
name|new_barrier
decl_stmt|;
name|rtx
modifier|*
name|ref
decl_stmt|;
name|stack
name|label_stack
decl_stmt|;
name|struct
name|stack_def
name|temp_stack
decl_stmt|;
name|int
name|reg
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|!=
name|LABEL_REF
condition|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
modifier|*
name|fmt
init|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|goto_block_pat
argument_list|(
name|insn
argument_list|,
name|regstack
argument_list|,
name|XEXP
argument_list|(
name|pat
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|pat
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|goto_block_pat
argument_list|(
name|insn
argument_list|,
name|regstack
argument_list|,
name|XVECEXP
argument_list|(
name|pat
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|label
operator|=
name|XEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|label
argument_list|)
operator|!=
name|CODE_LABEL
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* First, see if in fact anything needs to be done to the stack at all. */
if|if
condition|(
name|INSN_UID
argument_list|(
name|label
argument_list|)
operator|<=
literal|0
condition|)
return|return;
name|label_stack
operator|=
operator|&
name|block_stack_in
index|[
name|BLOCK_NUM
argument_list|(
name|label
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|label_stack
operator|->
name|top
operator|==
operator|-
literal|2
condition|)
block|{
comment|/* If the target block hasn't had a stack order selected, then 	 we need merely ensure that no pops are needed. */
for|for
control|(
name|reg
operator|=
name|regstack
operator|->
name|top
init|;
name|reg
operator|>=
literal|0
condition|;
name|reg
operator|--
control|)
if|if
condition|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|label_stack
operator|->
name|reg_set
argument_list|,
name|regstack
operator|->
name|reg
index|[
name|reg
index|]
argument_list|)
condition|)
break|break;
if|if
condition|(
name|reg
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* change_stack will not emit any code in this case. */
name|change_stack
argument_list|(
name|label
argument_list|,
name|regstack
argument_list|,
name|label_stack
argument_list|,
name|emit_insn_after
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|label_stack
operator|->
name|top
operator|==
name|regstack
operator|->
name|top
condition|)
block|{
for|for
control|(
name|reg
operator|=
name|label_stack
operator|->
name|top
init|;
name|reg
operator|>=
literal|0
condition|;
name|reg
operator|--
control|)
if|if
condition|(
name|label_stack
operator|->
name|reg
index|[
name|reg
index|]
operator|!=
name|regstack
operator|->
name|reg
index|[
name|reg
index|]
condition|)
break|break;
if|if
condition|(
name|reg
operator|==
operator|-
literal|1
condition|)
return|return;
block|}
comment|/* At least one insn will need to be inserted before label.  Insert      a jump around the code we are about to emit.  Emit a label for the new      code, and point the original insn at this new label. We can't use      redirect_jump here, because we're using fld[4] of the code labels as      LABEL_REF chains, no NUSES counters. */
name|new_jump
operator|=
name|emit_jump_insn_before
argument_list|(
name|gen_jump
argument_list|(
name|label
argument_list|)
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|record_label_references
argument_list|(
name|new_jump
argument_list|,
name|PATTERN
argument_list|(
name|new_jump
argument_list|)
argument_list|)
expr_stmt|;
name|JUMP_LABEL
argument_list|(
name|new_jump
argument_list|)
operator|=
name|label
expr_stmt|;
name|new_barrier
operator|=
name|emit_barrier_after
argument_list|(
name|new_jump
argument_list|)
expr_stmt|;
name|new_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_label_after
argument_list|(
name|new_label
argument_list|,
name|new_barrier
argument_list|)
expr_stmt|;
name|LABEL_REFS
argument_list|(
name|new_label
argument_list|)
operator|=
name|new_label
expr_stmt|;
comment|/* The old label_ref will no longer point to the code_label if now uses,      so strip the label_ref from the code_label's chain of references. */
for|for
control|(
name|ref
operator|=
operator|&
name|LABEL_REFS
argument_list|(
name|label
argument_list|)
init|;
operator|*
name|ref
operator|!=
name|label
condition|;
name|ref
operator|=
operator|&
name|LABEL_NEXTREF
argument_list|(
operator|*
name|ref
argument_list|)
control|)
if|if
condition|(
operator|*
name|ref
operator|==
name|pat
condition|)
break|break;
if|if
condition|(
operator|*
name|ref
operator|==
name|label
condition|)
name|abort
argument_list|()
expr_stmt|;
operator|*
name|ref
operator|=
name|LABEL_NEXTREF
argument_list|(
operator|*
name|ref
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
operator|=
name|new_label
expr_stmt|;
name|record_label_references
argument_list|(
name|insn
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|==
name|label
condition|)
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|=
name|new_label
expr_stmt|;
comment|/* Now emit the needed code. */
name|temp_stack
operator|=
operator|*
name|regstack
expr_stmt|;
name|change_stack
argument_list|(
name|new_label
argument_list|,
operator|&
name|temp_stack
argument_list|,
name|label_stack
argument_list|,
name|emit_insn_after
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Traverse all basic blocks in a function, converting the register    references in each insn from the "flat" register file that gcc uses, to    the stack-like registers the 387 uses. */
end_comment

begin_function
specifier|static
name|void
name|convert_regs
parameter_list|()
block|{
specifier|register
name|int
name|block
decl_stmt|,
name|reg
decl_stmt|;
specifier|register
name|rtx
name|insn
decl_stmt|,
name|next
decl_stmt|;
name|struct
name|stack_def
name|regstack
decl_stmt|;
for|for
control|(
name|block
operator|=
literal|0
init|;
name|block
operator|<
name|blocks
condition|;
name|block
operator|++
control|)
block|{
if|if
condition|(
name|block_stack_in
index|[
name|block
index|]
operator|.
name|top
operator|==
operator|-
literal|2
condition|)
block|{
comment|/* This block has not been previously encountered.  Choose a 	     default mapping for any stack regs live on entry */
name|block_stack_in
index|[
name|block
index|]
operator|.
name|top
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|reg
operator|=
name|LAST_STACK_REG
init|;
name|reg
operator|>=
name|FIRST_STACK_REG
condition|;
name|reg
operator|--
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|block_stack_in
index|[
name|block
index|]
operator|.
name|reg_set
argument_list|,
name|reg
argument_list|)
condition|)
name|block_stack_in
index|[
name|block
index|]
operator|.
name|reg
index|[
operator|++
name|block_stack_in
index|[
name|block
index|]
operator|.
name|top
index|]
operator|=
name|reg
expr_stmt|;
block|}
comment|/* Process all insns in this block.  Keep track of `next' here, 	 so that we don't process any insns emitted while making 	 substitutions in INSN. */
name|next
operator|=
name|block_begin
index|[
name|block
index|]
expr_stmt|;
name|regstack
operator|=
name|block_stack_in
index|[
name|block
index|]
expr_stmt|;
do|do
block|{
name|insn
operator|=
name|next
expr_stmt|;
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Don't bother processing unless there is a stack reg 	     mentioned.  	     ??? For now, process CALL_INSNs too to make sure that the 	     stack regs are dead after a call.  Remove this eventually. */
if|if
condition|(
name|GET_MODE
argument_list|(
name|insn
argument_list|)
operator|==
name|QImode
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
name|subst_stack_regs
argument_list|(
name|insn
argument_list|,
operator|&
name|regstack
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|insn
operator|!=
name|block_end
index|[
name|block
index|]
condition|)
do|;
comment|/* Something failed if the stack life doesn't match. */
name|GO_IF_HARD_REG_EQUAL
argument_list|(
name|regstack
operator|.
name|reg_set
argument_list|,
name|block_out_reg_set
index|[
name|block
index|]
argument_list|,
name|win
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
name|win
label|:
comment|/* Adjust the stack of this block on exit to match the stack of 	 the target block, or copy stack information into stack of 	 jump target if the target block's stack order hasn't been set 	 yet. */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
name|goto_block_pat
argument_list|(
name|insn
argument_list|,
operator|&
name|regstack
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Likewise handle the case where we fall into the next block. */
if|if
condition|(
operator|(
name|block
operator|<
name|blocks
operator|-
literal|1
operator|)
operator|&&
name|block_drops_in
index|[
name|block
operator|+
literal|1
index|]
condition|)
name|change_stack
argument_list|(
name|insn
argument_list|,
operator|&
name|regstack
argument_list|,
operator|&
name|block_stack_in
index|[
name|block
operator|+
literal|1
index|]
argument_list|,
name|emit_insn_after
argument_list|)
expr_stmt|;
block|}
comment|/* If the last basic block is the end of a loop, and that loop has      regs live at its start, then the last basic block will have regs live      at its end that need to be popped before the function returns. */
for|for
control|(
name|reg
operator|=
name|regstack
operator|.
name|top
init|;
name|reg
operator|>=
literal|0
condition|;
name|reg
operator|--
control|)
if|if
condition|(
operator|!
name|current_function_returns_real
operator|||
name|regstack
operator|.
name|reg
index|[
name|reg
index|]
operator|!=
name|FIRST_STACK_REG
condition|)
name|insn
operator|=
name|emit_pop_insn
argument_list|(
name|insn
argument_list|,
operator|&
name|regstack
argument_list|,
name|FP_mode_reg
index|[
name|regstack
operator|.
name|reg
index|[
name|reg
index|]
index|]
index|[
operator|(
name|int
operator|)
name|DFmode
index|]
argument_list|,
name|emit_insn_after
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Check expression PAT, which is in INSN, for label references.  if    one is found, print the block number of destination to FILE. */
end_comment

begin_function
specifier|static
name|void
name|print_blocks
parameter_list|(
name|file
parameter_list|,
name|insn
parameter_list|,
name|pat
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|rtx
name|insn
decl_stmt|,
name|pat
decl_stmt|;
block|{
specifier|register
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|pat
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|LABEL_REF
condition|)
block|{
specifier|register
name|rtx
name|label
init|=
name|XEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|label
argument_list|)
operator|!=
name|CODE_LABEL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %d"
argument_list|,
name|BLOCK_NUM
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|print_blocks
argument_list|(
name|file
argument_list|,
name|insn
argument_list|,
name|XEXP
argument_list|(
name|pat
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|pat
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|print_blocks
argument_list|(
name|file
argument_list|,
name|insn
argument_list|,
name|XVECEXP
argument_list|(
name|pat
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Write information about stack registers and stack blocks into FILE.    This is part of making a debugging dump.  */
end_comment

begin_function
specifier|static
name|void
name|dump_stack_info
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
specifier|register
name|int
name|block
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n%d stack blocks.\n"
argument_list|,
name|blocks
argument_list|)
expr_stmt|;
for|for
control|(
name|block
operator|=
literal|0
init|;
name|block
operator|<
name|blocks
condition|;
name|block
operator|++
control|)
block|{
specifier|register
name|rtx
name|head
decl_stmt|,
name|jump
decl_stmt|,
name|end
decl_stmt|;
specifier|register
name|int
name|regno
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\nStack block %d: first insn %d, last %d.\n"
argument_list|,
name|block
argument_list|,
name|INSN_UID
argument_list|(
name|block_begin
index|[
name|block
index|]
argument_list|)
argument_list|,
name|INSN_UID
argument_list|(
name|block_end
index|[
name|block
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|head
operator|=
name|block_begin
index|[
name|block
index|]
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"Reached from blocks: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|head
argument_list|)
operator|==
name|CODE_LABEL
condition|)
for|for
control|(
name|jump
operator|=
name|LABEL_REFS
argument_list|(
name|head
argument_list|)
init|;
name|jump
operator|!=
name|head
condition|;
name|jump
operator|=
name|LABEL_NEXTREF
argument_list|(
name|jump
argument_list|)
control|)
block|{
specifier|register
name|int
name|from_block
init|=
name|BLOCK_NUM
argument_list|(
name|CONTAINING_INSN
argument_list|(
name|jump
argument_list|)
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %d"
argument_list|,
name|from_block
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|block_drops_in
index|[
name|block
index|]
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" previous"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\nlive stack registers on block entry: "
argument_list|)
expr_stmt|;
for|for
control|(
name|regno
operator|=
name|FIRST_STACK_REG
init|;
name|regno
operator|<=
name|LAST_STACK_REG
condition|;
name|regno
operator|++
control|)
block|{
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|block_stack_in
index|[
name|block
index|]
operator|.
name|reg_set
argument_list|,
name|regno
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d "
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\nlive stack registers on block exit: "
argument_list|)
expr_stmt|;
for|for
control|(
name|regno
operator|=
name|FIRST_STACK_REG
init|;
name|regno
operator|<=
name|LAST_STACK_REG
condition|;
name|regno
operator|++
control|)
block|{
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|block_out_reg_set
index|[
name|block
index|]
argument_list|,
name|regno
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d "
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
name|end
operator|=
name|block_end
index|[
name|block
index|]
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\nJumps to blocks: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|end
argument_list|)
operator|==
name|JUMP_INSN
condition|)
name|print_blocks
argument_list|(
name|file
argument_list|,
name|end
argument_list|,
name|PATTERN
argument_list|(
name|end
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|block
operator|+
literal|1
operator|<
name|blocks
operator|&&
name|block_drops_in
index|[
name|block
operator|+
literal|1
index|]
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" next"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|block
operator|+
literal|1
operator|==
name|blocks
operator|||
operator|(
name|GET_CODE
argument_list|(
name|end
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|end
argument_list|)
argument_list|)
operator|==
name|RETURN
operator|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" return"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* STACK_REGS */
end_comment

end_unit

