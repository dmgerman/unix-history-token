begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Output bytecodes for GNU C-compiler.    Copyright (C) 1993, 1994 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"machmode.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"bytecode.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_include
include|#
directive|include
file|"bytetypes.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"bc-emit.h"
end_include

begin_include
include|#
directive|include
file|"bc-opcode.h"
end_include

begin_include
include|#
directive|include
file|"bc-typecd.h"
end_include

begin_include
include|#
directive|include
file|"bi-run.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|xmalloc
argument_list|()
decl_stmt|,
modifier|*
name|xrealloc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|__FreeBSD__
end_ifndef

begin_function_decl
specifier|extern
name|void
name|free
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|struct
name|obstack
modifier|*
name|rtl_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by mode class, gives the narrowest mode for each class.  */
end_comment

begin_decl_stmt
specifier|extern
name|enum
name|machine_mode
name|class_narrowest_mode
index|[
operator|(
name|int
operator|)
name|MAX_MODE_CLASS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Commonly used modes.  */
end_comment

begin_comment
comment|/* Mode whose width is BITS_PER_UNIT */
end_comment

begin_decl_stmt
specifier|extern
name|enum
name|machine_mode
name|byte_mode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Mode whose width is BITS_PER_WORD */
end_comment

begin_decl_stmt
specifier|extern
name|enum
name|machine_mode
name|word_mode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Vector indexed by opcode giving info about the args for each opcode. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|arityvec
name|arityvec
index|[]
init|=
block|{
include|#
directive|include
file|"bc-arity.h"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* How to print a symbol name for the assembler.  */
end_comment

begin_function
specifier|static
name|void
name|prsym
parameter_list|(
name|file
parameter_list|,
name|s
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'*'
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|s
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
ifdef|#
directive|ifdef
name|NAMES_HAVE_UNDERSCORES
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"_%s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Maintain a bucket hash table for symbol names. */
end_comment

begin_define
define|#
directive|define
name|HASH_BITS
value|32
end_define

begin_define
define|#
directive|define
name|HASH_SIZE
value|509
end_define

begin_decl_stmt
specifier|static
name|struct
name|bc_sym
modifier|*
name|hashtab
index|[
name|HASH_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|unsigned
name|int
name|hash
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|unsigned
name|int
name|hash
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|name
condition|)
block|{
name|hash
operator|=
name|hash
operator|<<
literal|3
operator||
name|hash
operator|>>
name|HASH_BITS
operator|-
literal|3
expr_stmt|;
name|hash
operator|+=
operator|*
name|name
operator|++
expr_stmt|;
block|}
return|return
name|hash
operator|%
name|HASH_SIZE
return|;
block|}
end_function

begin_comment
comment|/* Look up the named symbol, creating it if it doesn't exist. */
end_comment

begin_function
name|struct
name|bc_sym
modifier|*
name|sym_lookup
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|struct
name|bc_sym
modifier|*
name|s
decl_stmt|;
name|i
operator|=
name|hash
argument_list|(
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|hashtab
index|[
name|i
index|]
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|s
operator|->
name|name
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|s
return|;
name|s
operator|=
operator|(
expr|struct
name|bc_sym
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|bc_sym
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|name
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|s
operator|->
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|s
operator|->
name|defined
operator|=
name|s
operator|->
name|global
operator|=
name|s
operator|->
name|common
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|val
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|next
operator|=
name|hashtab
index|[
name|i
index|]
expr_stmt|;
name|hashtab
index|[
name|i
index|]
operator|=
name|s
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* Write out .globl and common symbols to the named file.  */
end_comment

begin_function
specifier|static
name|void
name|bc_sym_write
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|struct
name|bc_sym
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HASH_SIZE
condition|;
operator|++
name|i
control|)
for|for
control|(
name|s
operator|=
name|hashtab
index|[
name|i
index|]
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
if|if
condition|(
name|s
operator|->
name|global
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n\t.globl "
argument_list|)
expr_stmt|;
name|prsym
argument_list|(
name|file
argument_list|,
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|common
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n\t.comm "
argument_list|)
expr_stmt|;
name|prsym
argument_list|(
name|file
argument_list|,
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|", %lu\n"
argument_list|,
name|s
operator|->
name|val
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|s
operator|->
name|common
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n\t.lcomm "
argument_list|)
expr_stmt|;
name|prsym
argument_list|(
name|file
argument_list|,
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|", %lu\n"
argument_list|,
name|s
operator|->
name|val
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create and initialize a new segment. */
end_comment

begin_function
specifier|static
name|struct
name|bc_seg
modifier|*
name|seg_create
parameter_list|()
block|{
name|struct
name|bc_seg
modifier|*
name|result
decl_stmt|;
name|result
operator|=
operator|(
expr|struct
name|bc_seg
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|bc_seg
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|->
name|alloc
operator|=
literal|256
expr_stmt|;
name|result
operator|->
name|data
operator|=
name|xmalloc
argument_list|(
name|result
operator|->
name|alloc
argument_list|)
expr_stmt|;
name|result
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|result
operator|->
name|syms
operator|=
literal|0
expr_stmt|;
name|result
operator|->
name|relocs
operator|=
literal|0
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Advance the segment index to the next alignment boundary. */
end_comment

begin_function
specifier|static
name|void
name|seg_align
parameter_list|(
name|seg
parameter_list|,
name|log
parameter_list|)
name|struct
name|bc_seg
modifier|*
name|seg
decl_stmt|;
name|int
name|log
decl_stmt|;
block|{
name|unsigned
name|int
name|oldsize
init|=
name|seg
operator|->
name|size
decl_stmt|;
name|seg
operator|->
name|size
operator|=
name|seg
operator|->
name|size
operator|+
operator|(
literal|1
operator|<<
name|log
operator|)
operator|-
literal|1
operator|&
operator|~
operator|(
operator|(
literal|1
operator|<<
name|log
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|seg
operator|->
name|size
operator|>
name|seg
operator|->
name|alloc
condition|)
block|{
while|while
condition|(
name|seg
operator|->
name|size
operator|>
name|seg
operator|->
name|alloc
condition|)
name|seg
operator|->
name|alloc
operator|*=
literal|2
expr_stmt|;
name|seg
operator|->
name|data
operator|=
name|xrealloc
argument_list|(
name|seg
operator|->
name|data
argument_list|,
name|seg
operator|->
name|alloc
argument_list|)
expr_stmt|;
block|}
name|bzero
argument_list|(
name|seg
operator|->
name|data
operator|+
name|oldsize
argument_list|,
name|seg
operator|->
name|size
operator|-
name|oldsize
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Append the given data to the given segment. */
end_comment

begin_function
specifier|static
name|void
name|seg_data
parameter_list|(
name|seg
parameter_list|,
name|data
parameter_list|,
name|size
parameter_list|)
name|struct
name|bc_seg
modifier|*
name|seg
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
block|{
if|if
condition|(
name|seg
operator|->
name|size
operator|+
name|size
operator|>
name|seg
operator|->
name|alloc
condition|)
block|{
while|while
condition|(
name|seg
operator|->
name|size
operator|+
name|size
operator|>
name|seg
operator|->
name|alloc
condition|)
name|seg
operator|->
name|alloc
operator|*=
literal|2
expr_stmt|;
name|seg
operator|->
name|data
operator|=
name|xrealloc
argument_list|(
name|seg
operator|->
name|data
argument_list|,
name|seg
operator|->
name|alloc
argument_list|)
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|data
argument_list|,
name|seg
operator|->
name|data
operator|+
name|seg
operator|->
name|size
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|seg
operator|->
name|size
operator|+=
name|size
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Append a zero-filled skip to the given segment.  */
end_comment

begin_function
specifier|static
name|void
name|seg_skip
parameter_list|(
name|seg
parameter_list|,
name|size
parameter_list|)
name|struct
name|bc_seg
modifier|*
name|seg
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
block|{
if|if
condition|(
name|seg
operator|->
name|size
operator|+
name|size
operator|>
name|seg
operator|->
name|alloc
condition|)
block|{
while|while
condition|(
name|seg
operator|->
name|size
operator|+
name|size
operator|>
name|seg
operator|->
name|alloc
condition|)
name|seg
operator|->
name|alloc
operator|*=
literal|2
expr_stmt|;
name|seg
operator|->
name|data
operator|=
name|xrealloc
argument_list|(
name|seg
operator|->
name|data
argument_list|,
name|seg
operator|->
name|alloc
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
name|seg
operator|->
name|data
operator|+
name|seg
operator|->
name|size
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|seg
operator|->
name|size
operator|+=
name|size
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Define the given name as the current offset in the given segment.  It    is an error if the name is already defined.  Return 0 or 1 indicating    failure or success respectively. */
end_comment

begin_function
specifier|static
name|int
name|seg_defsym
parameter_list|(
name|seg
parameter_list|,
name|name
parameter_list|)
name|struct
name|bc_seg
modifier|*
name|seg
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|bc_sym
modifier|*
name|sym
decl_stmt|;
name|struct
name|bc_segsym
modifier|*
name|segsym
decl_stmt|;
name|sym
operator|=
name|sym_lookup
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|->
name|defined
condition|)
return|return
literal|0
return|;
name|sym
operator|->
name|defined
operator|=
literal|1
expr_stmt|;
name|sym
operator|->
name|val
operator|=
name|seg
operator|->
name|size
expr_stmt|;
name|segsym
operator|=
operator|(
expr|struct
name|bc_segsym
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|bc_segsym
argument_list|)
argument_list|)
expr_stmt|;
name|segsym
operator|->
name|sym
operator|=
name|sym
expr_stmt|;
name|segsym
operator|->
name|next
operator|=
name|seg
operator|->
name|syms
expr_stmt|;
name|seg
operator|->
name|syms
operator|=
name|segsym
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Generate in seg's data a reference to the given sym, adjusted by    the given offset. */
end_comment

begin_function
specifier|static
name|void
name|seg_refsym
parameter_list|(
name|seg
parameter_list|,
name|name
parameter_list|,
name|offset
parameter_list|)
name|struct
name|bc_seg
modifier|*
name|seg
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|offset
decl_stmt|;
block|{
name|struct
name|bc_sym
modifier|*
name|sym
decl_stmt|;
name|struct
name|bc_segreloc
modifier|*
name|segreloc
decl_stmt|;
name|sym
operator|=
name|sym_lookup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|segreloc
operator|=
operator|(
expr|struct
name|bc_segreloc
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|bc_segreloc
argument_list|)
argument_list|)
expr_stmt|;
name|segreloc
operator|->
name|offset
operator|=
name|seg
operator|->
name|size
expr_stmt|;
name|segreloc
operator|->
name|sym
operator|=
name|sym
expr_stmt|;
name|segreloc
operator|->
name|next
operator|=
name|seg
operator|->
name|relocs
expr_stmt|;
name|seg
operator|->
name|relocs
operator|=
name|segreloc
expr_stmt|;
name|seg_data
argument_list|(
name|seg
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|offset
argument_list|,
sizeof|sizeof
name|offset
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Concatenate the contents of given segments into the first argument. */
end_comment

begin_function
specifier|static
name|void
name|seg_concat
parameter_list|(
name|result
parameter_list|,
name|seg
parameter_list|)
name|struct
name|bc_seg
modifier|*
name|result
decl_stmt|,
decl|*
name|seg
decl_stmt|;
end_function

begin_block
block|{
name|unsigned
name|int
name|fix
decl_stmt|;
name|struct
name|bc_segsym
modifier|*
name|segsym
decl_stmt|;
name|struct
name|bc_segreloc
modifier|*
name|segreloc
decl_stmt|;
name|seg_align
argument_list|(
name|result
argument_list|,
name|MACHINE_SEG_ALIGN
argument_list|)
expr_stmt|;
name|fix
operator|=
name|result
operator|->
name|size
expr_stmt|;
name|seg_data
argument_list|(
name|result
argument_list|,
name|seg
operator|->
name|data
argument_list|,
name|seg
operator|->
name|size
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|seg
operator|->
name|data
argument_list|)
expr_stmt|;
comment|/* Go through the symbols and relocs of SEG, adjusting their offsets      for their new location in RESULT. */
if|if
condition|(
name|seg
operator|->
name|syms
condition|)
block|{
name|segsym
operator|=
name|seg
operator|->
name|syms
expr_stmt|;
do|do
name|segsym
operator|->
name|sym
operator|->
name|val
operator|+=
name|fix
expr_stmt|;
do|while
condition|(
name|segsym
operator|->
name|next
operator|&&
operator|(
name|segsym
operator|=
name|segsym
operator|->
name|next
operator|)
condition|)
do|;
name|segsym
operator|->
name|next
operator|=
name|result
operator|->
name|syms
expr_stmt|;
name|result
operator|->
name|syms
operator|=
name|seg
operator|->
name|syms
expr_stmt|;
block|}
if|if
condition|(
name|seg
operator|->
name|relocs
condition|)
block|{
name|segreloc
operator|=
name|seg
operator|->
name|relocs
expr_stmt|;
do|do
name|segreloc
operator|->
name|offset
operator|+=
name|fix
expr_stmt|;
do|while
condition|(
name|segreloc
operator|->
name|next
operator|&&
operator|(
name|segreloc
operator|=
name|segreloc
operator|->
name|next
operator|)
condition|)
do|;
name|segreloc
operator|->
name|next
operator|=
name|result
operator|->
name|relocs
expr_stmt|;
name|result
operator|->
name|relocs
operator|=
name|seg
operator|->
name|relocs
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|seg
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Write a segment to a file.  */
end_comment

begin_function
specifier|static
name|void
name|bc_seg_write
parameter_list|(
name|seg
parameter_list|,
name|file
parameter_list|)
name|struct
name|bc_seg
modifier|*
name|seg
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|struct
name|bc_segsym
modifier|*
name|segsym
decl_stmt|,
modifier|*
name|nsegsym
decl_stmt|,
modifier|*
name|psegsym
decl_stmt|;
name|struct
name|bc_segreloc
modifier|*
name|segreloc
decl_stmt|,
modifier|*
name|nsegreloc
decl_stmt|,
modifier|*
name|psegreloc
decl_stmt|;
name|int
name|i
decl_stmt|,
name|offset
decl_stmt|,
name|flag
decl_stmt|;
comment|/* Reverse the list of symbols.  */
for|for
control|(
name|psegsym
operator|=
literal|0
operator|,
name|segsym
operator|=
name|seg
operator|->
name|syms
init|;
name|segsym
condition|;
name|segsym
operator|=
name|nsegsym
control|)
block|{
name|nsegsym
operator|=
name|segsym
operator|->
name|next
expr_stmt|;
name|segsym
operator|->
name|next
operator|=
name|psegsym
expr_stmt|;
name|psegsym
operator|=
name|segsym
expr_stmt|;
block|}
name|seg
operator|->
name|syms
operator|=
name|psegsym
expr_stmt|;
comment|/* Reverse the list of relocs.  */
for|for
control|(
name|psegreloc
operator|=
literal|0
operator|,
name|segreloc
operator|=
name|seg
operator|->
name|relocs
init|;
name|segreloc
condition|;
name|segreloc
operator|=
name|nsegreloc
control|)
block|{
name|nsegreloc
operator|=
name|segreloc
operator|->
name|next
expr_stmt|;
name|segreloc
operator|->
name|next
operator|=
name|psegreloc
expr_stmt|;
name|psegreloc
operator|=
name|segreloc
expr_stmt|;
block|}
name|seg
operator|->
name|relocs
operator|=
name|psegreloc
expr_stmt|;
comment|/* Output each byte of the segment.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|segsym
operator|=
name|seg
operator|->
name|syms
operator|,
name|segreloc
operator|=
name|seg
operator|->
name|relocs
init|;
name|i
operator|<
name|seg
operator|->
name|size
condition|;
operator|++
name|i
control|)
block|{
while|while
condition|(
name|segsym
operator|&&
name|segsym
operator|->
name|sym
operator|->
name|val
operator|==
name|i
condition|)
block|{
if|if
condition|(
name|i
operator|%
literal|8
operator|!=
literal|0
condition|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|BC_WRITE_SEGSYM
argument_list|(
name|segsym
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|segsym
operator|=
name|segsym
operator|->
name|next
expr_stmt|;
name|flag
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|segreloc
operator|&&
name|segreloc
operator|->
name|offset
operator|==
name|i
condition|)
block|{
if|if
condition|(
name|i
operator|%
literal|8
operator|!=
literal|0
condition|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|seg
operator|->
name|data
operator|+
name|i
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
expr_stmt|;
name|BC_WRITE_RELOC_ENTRY
argument_list|(
name|segreloc
argument_list|,
name|file
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|segreloc
operator|=
name|segreloc
operator|->
name|next
expr_stmt|;
name|flag
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|i
operator|%
literal|8
operator|==
literal|0
operator|||
name|flag
condition|)
name|BC_START_BYTECODE_LINE
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|BC_WRITE_BYTECODE
argument_list|(
name|i
operator|%
literal|8
operator|==
literal|0
operator|||
name|flag
condition|?
literal|' '
else|:
literal|','
argument_list|,
name|seg
operator|->
name|data
index|[
name|i
index|]
operator|&
literal|0xFF
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|flag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|%
literal|8
operator|==
literal|7
condition|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Paranoia check--we should have visited all syms and relocs during      the output pass.  */
if|if
condition|(
name|segsym
operator|||
name|segreloc
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Text and data segments of the object file in making. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|bc_seg
modifier|*
name|bc_text_seg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bc_seg
modifier|*
name|bc_data_seg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Called before anything else in this module. */
end_comment

begin_function
name|void
name|bc_initialize
parameter_list|()
block|{
name|int
name|min_class_size
index|[
operator|(
name|int
operator|)
name|MAX_MODE_CLASS
index|]
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|i
decl_stmt|;
name|bc_init_mode_to_code_map
argument_list|()
expr_stmt|;
name|bc_text_seg
operator|=
name|seg_create
argument_list|()
expr_stmt|;
name|bc_data_seg
operator|=
name|seg_create
argument_list|()
expr_stmt|;
name|dconst0
operator|=
name|REAL_VALUE_ATOF
argument_list|(
literal|"0"
argument_list|,
name|DFmode
argument_list|)
expr_stmt|;
name|dconst1
operator|=
name|REAL_VALUE_ATOF
argument_list|(
literal|"1"
argument_list|,
name|DFmode
argument_list|)
expr_stmt|;
name|dconst2
operator|=
name|REAL_VALUE_ATOF
argument_list|(
literal|"2"
argument_list|,
name|DFmode
argument_list|)
expr_stmt|;
name|dconstm1
operator|=
name|REAL_VALUE_ATOF
argument_list|(
literal|"-1"
argument_list|,
name|DFmode
argument_list|)
expr_stmt|;
comment|/* Find the narrowest mode for each class and compute the word and byte      modes.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|MAX_MODE_CLASS
condition|;
name|i
operator|++
control|)
name|min_class_size
index|[
name|i
index|]
operator|=
literal|1000
expr_stmt|;
for|for
control|(
name|mode
operator|=
name|VOIDmode
init|;
operator|(
name|int
operator|)
name|mode
operator|<
operator|(
name|int
operator|)
name|MAX_MACHINE_MODE
condition|;
name|mode
operator|=
operator|(
expr|enum
name|machine_mode
operator|)
operator|(
operator|(
name|int
operator|)
name|mode
operator|+
literal|1
operator|)
control|)
block|{
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<
name|min_class_size
index|[
operator|(
name|int
operator|)
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
index|]
condition|)
block|{
name|class_narrowest_mode
index|[
operator|(
name|int
operator|)
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
index|]
operator|=
name|mode
expr_stmt|;
name|min_class_size
index|[
operator|(
name|int
operator|)
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
index|]
operator|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|==
name|BITS_PER_UNIT
condition|)
name|byte_mode
operator|=
name|mode
expr_stmt|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|==
name|BITS_PER_WORD
condition|)
name|word_mode
operator|=
name|mode
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* External addresses referenced in a function.  Rather than trying to    work relocatable address directly into bytecoded functions (which would    require us to provide hairy location info and possibly obey alignment    rules imposed by the architecture) we build an auxilary table of    pointer constants, and encode just offsets into this table into the    actual bytecode. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|bc_seg
modifier|*
name|ptrconsts
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Trampoline code for the function entry.  */
end_comment

begin_decl_stmt
name|struct
name|bc_seg
modifier|*
name|trampoline
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Actual byte code of the function. */
end_comment

begin_decl_stmt
name|struct
name|bc_seg
modifier|*
name|bytecode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of labels defined in the function. */
end_comment

begin_decl_stmt
name|struct
name|bc_label
modifier|*
name|labels
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of label references in the function. */
end_comment

begin_decl_stmt
name|struct
name|bc_labelref
modifier|*
name|labelrefs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Add symbol to pointer table.  Return offset into table where    pointer was stored.  The offset usually goes into the bytecode    stream as a constP literal. */
end_comment

begin_function
name|int
name|bc_define_pointer
parameter_list|(
name|p
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|offset
init|=
name|ptrconsts
operator|->
name|size
decl_stmt|;
name|seg_refsym
argument_list|(
name|ptrconsts
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|offset
return|;
block|}
end_function

begin_comment
comment|/* Begin a bytecoded function.  */
end_comment

begin_function
name|int
name|bc_begin_function
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|ptrconsts
operator|=
name|seg_create
argument_list|()
expr_stmt|;
name|trampoline
operator|=
name|seg_create
argument_list|()
expr_stmt|;
name|bytecode
operator|=
name|seg_create
argument_list|()
expr_stmt|;
return|return
name|seg_defsym
argument_list|(
name|trampoline
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Force alignment in inline bytecode.  */
end_comment

begin_function
name|void
name|bc_align_bytecode
parameter_list|(
name|align
parameter_list|)
name|int
name|align
decl_stmt|;
block|{
name|seg_align
argument_list|(
name|bytecode
argument_list|,
name|align
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit data inline into bytecode.  */
end_comment

begin_function
name|void
name|bc_emit_bytecode_const
parameter_list|(
name|data
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|data
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
block|{
if|if
condition|(
name|bytecode
condition|)
name|seg_data
argument_list|(
name|bytecode
argument_list|,
name|data
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create a new "bytecode label", to have its value defined later.    Bytecode labels have nothing to do with the object file symbol table,    and are purely local to a given bytecoded function. */
end_comment

begin_function
name|struct
name|bc_label
modifier|*
name|bc_get_bytecode_label
parameter_list|()
block|{
name|struct
name|bc_label
modifier|*
name|result
decl_stmt|;
name|result
operator|=
operator|(
expr|struct
name|bc_label
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|bc_label
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|->
name|defined
operator|=
literal|0
expr_stmt|;
name|result
operator|->
name|next
operator|=
name|labels
expr_stmt|;
name|result
operator|->
name|uid
operator|=
literal|0
expr_stmt|;
name|labels
operator|=
name|result
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Define the given label with the current location counter. */
end_comment

begin_function
name|int
name|bc_emit_bytecode_labeldef
parameter_list|(
name|label
parameter_list|)
name|struct
name|bc_label
modifier|*
name|label
decl_stmt|;
block|{
specifier|extern
name|int
name|bc_new_uid
parameter_list|()
function_decl|;
if|if
condition|(
operator|!
name|label
operator|||
name|label
operator|->
name|defined
condition|)
return|return
literal|0
return|;
name|label
operator|->
name|offset
operator|=
name|bytecode
operator|->
name|size
expr_stmt|;
name|label
operator|->
name|defined
operator|=
literal|1
expr_stmt|;
name|label
operator|->
name|uid
operator|=
name|bc_new_uid
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_PRINT_CODE
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"$%lx:\n"
argument_list|,
name|label
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Generate a location-relative reference to the given bytecode label.    It need not be defined yet; label references will be backpatched later. */
end_comment

begin_function
name|void
name|bc_emit_bytecode_labelref
parameter_list|(
name|label
parameter_list|)
name|struct
name|bc_label
modifier|*
name|label
decl_stmt|;
block|{
name|struct
name|bc_labelref
modifier|*
name|labelref
decl_stmt|;
specifier|static
name|int
name|zero
decl_stmt|;
name|labelref
operator|=
operator|(
expr|struct
name|bc_labelref
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|bc_labelref
argument_list|)
argument_list|)
expr_stmt|;
name|labelref
operator|->
name|label
operator|=
name|label
expr_stmt|;
name|labelref
operator|->
name|offset
operator|=
name|bytecode
operator|->
name|size
expr_stmt|;
name|labelref
operator|->
name|next
operator|=
name|labelrefs
expr_stmt|;
name|labelrefs
operator|=
name|labelref
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_PRINT_CODE
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" $%lx"
argument_list|,
name|label
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|seg_data
argument_list|(
name|bytecode
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|zero
argument_list|,
sizeof|sizeof
name|zero
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit a reference to an external address; generate the reference in the    ptrconst area, and emit an offset in the bytecode. */
end_comment

begin_function
name|void
name|bc_emit_code_labelref
parameter_list|(
name|name
parameter_list|,
name|offset
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|offset
decl_stmt|;
block|{
name|int
name|ptroff
decl_stmt|;
name|ptroff
operator|=
name|ptrconsts
operator|->
name|size
operator|/
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
expr_stmt|;
name|seg_data
argument_list|(
name|bytecode
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ptroff
argument_list|,
sizeof|sizeof
name|ptroff
argument_list|)
expr_stmt|;
name|seg_refsym
argument_list|(
name|ptrconsts
argument_list|,
name|name
argument_list|,
name|offset
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_PRINT_CODE
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" [external<%x> %s]"
argument_list|,
name|ptroff
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Backpatch label references in the byte code, and concatenate the bytecode    and pointer constant segments to the cumulative text for the object file.    Return a label name for the pointer constants region.  */
end_comment

begin_function
name|char
modifier|*
name|bc_end_function
parameter_list|()
block|{
name|int
name|addr
decl_stmt|;
name|struct
name|bc_label
modifier|*
name|label
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|struct
name|bc_labelref
modifier|*
name|ref
decl_stmt|,
modifier|*
name|nextref
decl_stmt|;
name|char
name|ptrconsts_label
index|[
literal|20
index|]
decl_stmt|;
specifier|static
name|int
name|nlab
decl_stmt|;
comment|/* Backpatch bytecode label references. */
for|for
control|(
name|ref
operator|=
name|labelrefs
init|;
name|ref
condition|;
name|ref
operator|=
name|ref
operator|->
name|next
control|)
if|if
condition|(
name|ref
operator|->
name|label
operator|->
name|defined
condition|)
block|{
name|addr
operator|=
name|ref
operator|->
name|label
operator|->
name|offset
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|addr
argument_list|,
name|bytecode
operator|->
name|data
operator|+
name|ref
operator|->
name|offset
argument_list|,
sizeof|sizeof
name|addr
argument_list|)
expr_stmt|;
block|}
comment|/* Free the chains of labelrefs and labeldefs. */
for|for
control|(
name|ref
operator|=
name|labelrefs
init|;
name|ref
condition|;
name|ref
operator|=
name|nextref
control|)
block|{
name|nextref
operator|=
name|ref
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ref
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|label
operator|=
name|labels
init|;
name|label
condition|;
name|label
operator|=
name|next
control|)
block|{
name|next
operator|=
name|label
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|label
argument_list|)
expr_stmt|;
block|}
name|seg_concat
argument_list|(
name|trampoline
argument_list|,
name|bytecode
argument_list|)
expr_stmt|;
name|seg_align
argument_list|(
name|trampoline
argument_list|,
name|MACHINE_SEG_ALIGN
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ptrconsts_label
argument_list|,
literal|"*LP%d"
argument_list|,
name|nlab
operator|++
argument_list|)
expr_stmt|;
name|seg_defsym
argument_list|(
name|trampoline
argument_list|,
name|ptrconsts_label
argument_list|)
expr_stmt|;
name|seg_concat
argument_list|(
name|trampoline
argument_list|,
name|ptrconsts
argument_list|)
expr_stmt|;
name|seg_concat
argument_list|(
name|bc_text_seg
argument_list|,
name|trampoline
argument_list|)
expr_stmt|;
name|labels
operator|=
literal|0
expr_stmt|;
name|labelrefs
operator|=
literal|0
expr_stmt|;
name|trampoline
operator|=
literal|0
expr_stmt|;
name|bytecode
operator|=
literal|0
expr_stmt|;
name|ptrconsts
operator|=
literal|0
expr_stmt|;
return|return
name|sym_lookup
argument_list|(
name|ptrconsts_label
argument_list|)
operator|->
name|name
return|;
block|}
end_function

begin_comment
comment|/* Force alignment in const data. */
end_comment

begin_function
name|void
name|bc_align_const
parameter_list|(
name|align
parameter_list|)
name|int
name|align
decl_stmt|;
block|{
name|seg_align
argument_list|(
name|bc_text_seg
argument_list|,
name|align
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit const data. */
end_comment

begin_function
name|void
name|bc_emit_const
parameter_list|(
name|data
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|data
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
block|{
name|seg_data
argument_list|(
name|bc_text_seg
argument_list|,
name|data
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit a zero-filled constant skip. */
end_comment

begin_function
name|void
name|bc_emit_const_skip
parameter_list|(
name|size
parameter_list|)
name|unsigned
name|int
name|size
decl_stmt|;
block|{
name|seg_skip
argument_list|(
name|bc_text_seg
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit a label definition in const data. */
end_comment

begin_function
name|int
name|bc_emit_const_labeldef
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
return|return
name|seg_defsym
argument_list|(
name|bc_text_seg
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Emit a label reference in const data. */
end_comment

begin_function
name|void
name|bc_emit_const_labelref
parameter_list|(
name|name
parameter_list|,
name|offset
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|offset
decl_stmt|;
block|{
name|seg_refsym
argument_list|(
name|bc_text_seg
argument_list|,
name|name
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Force alignment in data. */
end_comment

begin_function
name|void
name|bc_align_data
parameter_list|(
name|align
parameter_list|)
name|int
name|align
decl_stmt|;
block|{
name|seg_align
argument_list|(
name|bc_data_seg
argument_list|,
name|align
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit data. */
end_comment

begin_function
name|void
name|bc_emit_data
parameter_list|(
name|data
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|data
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
block|{
name|seg_data
argument_list|(
name|bc_data_seg
argument_list|,
name|data
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit a zero-filled data skip.  */
end_comment

begin_function
name|void
name|bc_emit_data_skip
parameter_list|(
name|size
parameter_list|)
name|unsigned
name|int
name|size
decl_stmt|;
block|{
name|seg_skip
argument_list|(
name|bc_data_seg
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit label definition in data. */
end_comment

begin_function
name|int
name|bc_emit_data_labeldef
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
return|return
name|seg_defsym
argument_list|(
name|bc_data_seg
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Emit label reference in data. */
end_comment

begin_function
name|void
name|bc_emit_data_labelref
parameter_list|(
name|name
parameter_list|,
name|offset
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|offset
decl_stmt|;
block|{
name|seg_refsym
argument_list|(
name|bc_data_seg
argument_list|,
name|name
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit a common block of the given name and size.  Note that    when the .o file is actually written non-global "common"    blocks will have to be turned into space in the data section.  */
end_comment

begin_function
name|int
name|bc_emit_common
parameter_list|(
name|name
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
block|{
name|struct
name|bc_sym
modifier|*
name|sym
decl_stmt|;
name|sym
operator|=
name|sym_lookup
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|->
name|defined
condition|)
return|return
literal|0
return|;
name|sym
operator|->
name|defined
operator|=
literal|1
expr_stmt|;
name|sym
operator|->
name|common
operator|=
literal|1
expr_stmt|;
name|sym
operator|->
name|val
operator|=
name|size
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Globalize the given label. */
end_comment

begin_function
name|void
name|bc_globalize_label
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|bc_sym
modifier|*
name|sym
decl_stmt|;
name|sym
operator|=
name|sym_lookup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|sym
operator|->
name|global
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_enum
specifier|static
enum|enum
block|{
name|in_text
block|,
name|in_data
block|}
name|section
init|=
name|in_text
enum|;
end_enum

begin_function
name|void
name|bc_text
parameter_list|()
block|{
name|section
operator|=
name|in_text
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bc_data
parameter_list|()
block|{
name|section
operator|=
name|in_data
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bc_align
parameter_list|(
name|align
parameter_list|)
name|int
name|align
decl_stmt|;
block|{
if|if
condition|(
name|section
operator|==
name|in_text
condition|)
name|bc_align_const
argument_list|(
name|align
argument_list|)
expr_stmt|;
else|else
name|bc_align_data
argument_list|(
name|align
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bc_emit
parameter_list|(
name|data
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|data
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
block|{
if|if
condition|(
name|section
operator|==
name|in_text
condition|)
name|bc_emit_const
argument_list|(
name|data
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
name|bc_emit_data
argument_list|(
name|data
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bc_emit_skip
parameter_list|(
name|size
parameter_list|)
name|unsigned
name|int
name|size
decl_stmt|;
block|{
if|if
condition|(
name|section
operator|==
name|in_text
condition|)
name|bc_emit_const_skip
argument_list|(
name|size
argument_list|)
expr_stmt|;
else|else
name|bc_emit_data_skip
argument_list|(
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|bc_emit_labeldef
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
if|if
condition|(
name|section
operator|==
name|in_text
condition|)
return|return
name|bc_emit_const_labeldef
argument_list|(
name|name
argument_list|)
return|;
else|else
return|return
name|bc_emit_data_labeldef
argument_list|(
name|name
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|bc_emit_labelref
parameter_list|(
name|name
parameter_list|,
name|offset
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|offset
decl_stmt|;
block|{
if|if
condition|(
name|section
operator|==
name|in_text
condition|)
name|bc_emit_const_labelref
argument_list|(
name|name
argument_list|,
name|offset
argument_list|)
expr_stmt|;
else|else
name|bc_emit_data_labelref
argument_list|(
name|name
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bc_write_file
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|BC_WRITE_FILE
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Allocate a new bytecode rtx.    If you supply a null BC_LABEL, we generate one.  */
end_comment

begin_function
name|rtx
name|bc_gen_rtx
parameter_list|(
name|label
parameter_list|,
name|offset
parameter_list|,
name|bc_label
parameter_list|)
name|char
modifier|*
name|label
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|struct
name|bc_label
modifier|*
name|bc_label
decl_stmt|;
block|{
name|rtx
name|r
decl_stmt|;
if|if
condition|(
name|bc_label
operator|==
literal|0
condition|)
name|bc_label
operator|=
operator|(
expr|struct
name|bc_label
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|bc_label
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|=
name|gen_rtx
argument_list|(
name|CODE_LABEL
argument_list|,
name|VOIDmode
argument_list|,
name|label
argument_list|,
name|bc_label
argument_list|)
expr_stmt|;
name|bc_label
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Print bytecode rtx */
end_comment

begin_function
name|void
name|bc_print_rtl
parameter_list|(
name|fp
parameter_list|,
name|r
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
name|rtx
name|r
decl_stmt|;
block|{
if|#
directive|if
literal|0
comment|/* This needs to get fixed to really work again.  */
comment|/* BC_WRITE_RTL has a definition      that doesn't even make sense for this use.  */
block|BC_WRITE_RTL (r, fp);
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Emit a bytecode, keeping a running tally of the stack depth.  */
end_comment

begin_function
name|void
name|bc_emit_bytecode
parameter_list|(
name|bytecode
parameter_list|)
name|enum
name|bytecode_opcode
name|bytecode
decl_stmt|;
block|{
name|char
name|byte
decl_stmt|;
specifier|static
name|int
name|prev_lineno
init|=
operator|-
literal|1
decl_stmt|;
name|byte
operator|=
operator|(
name|char
operator|)
name|bytecode
expr_stmt|;
ifdef|#
directive|ifdef
name|BCDEBUG_PRINT_CODE
if|if
condition|(
name|lineno
operator|!=
name|prev_lineno
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"<line %d>\n"
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|prev_lineno
operator|=
name|lineno
expr_stmt|;
block|}
name|fputs
argument_list|(
name|opcode_name
index|[
operator|(
name|unsigned
name|int
operator|)
name|bytecode
index|]
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Due to errors we are often requested to output bytecodes that      will cause an interpreter stack undeflow when executed.  Instead of      dumping core on such occasions, we omit the bytecode.  Erroneous code      should not be executed, regardless.  This makes life much easier, since      we don't have to deceive ourselves about the known stack depth. */
name|bc_emit_bytecode_const
argument_list|(
operator|&
name|byte
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stack_depth
operator|-=
name|arityvec
index|[
operator|(
name|int
operator|)
name|bytecode
index|]
operator|.
name|ninputs
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|stack_depth
operator|+=
name|arityvec
index|[
operator|(
name|int
operator|)
name|bytecode
index|]
operator|.
name|noutputs
operator|)
operator|>
name|max_stack_depth
condition|)
name|max_stack_depth
operator|=
name|stack_depth
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|VALIDATE_STACK_FOR_BC
name|VALIDATE_STACK_FOR_BC
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|BCDEBUG_PRINT_CODE
end_ifdef

begin_define
define|#
directive|define
name|PRLIT
parameter_list|(
name|TYPE
parameter_list|,
name|PTR
parameter_list|)
value|fprintf (stderr, " [%x]", *(TYPE *) PTR)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PRLIT
parameter_list|(
name|X
parameter_list|,
name|Y
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Emit a complete bytecode instruction, expecting the correct number    of literal values in the call.  First argument is the instruction, the    remaining arguments are literals of size HOST_WIDE_INT or smaller. */
end_comment

begin_decl_stmt
name|void
name|bc_emit_instruction
name|VPROTO
argument_list|(
operator|(
expr|enum
name|bytecode_opcode
name|opcode
operator|,
operator|...
operator|)
argument_list|)
block|{
ifndef|#
directive|ifndef
name|__STDC__
name|enum
name|bytecode_opcode
name|opcode
decl_stmt|;
endif|#
directive|endif
name|va_list
name|arguments
decl_stmt|;
name|int
name|nliteral
decl_stmt|,
name|instruction
decl_stmt|;
name|VA_START
argument_list|(
name|arguments
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|__STDC__
name|opcode
operator|=
name|va_arg
argument_list|(
name|arguments
argument_list|,
expr|enum
name|bytecode_opcode
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Emit instruction bytecode */
name|bc_emit_bytecode
argument_list|(
name|opcode
argument_list|)
expr_stmt|;
name|instruction
operator|=
operator|(
name|int
operator|)
name|opcode
expr_stmt|;
comment|/* Loop literals and emit as bytecode constants */
for|for
control|(
name|nliteral
operator|=
literal|0
init|;
name|nliteral
operator|<
name|arityvec
index|[
name|instruction
index|]
operator|.
name|nliterals
condition|;
name|nliteral
operator|++
control|)
block|{
switch|switch
condition|(
name|arityvec
index|[
name|instruction
index|]
operator|.
name|literals
index|[
name|nliteral
index|]
condition|)
block|{
comment|/* This conditional is a kludge, but it's necessary    because TYPE might be long long.  */
ifdef|#
directive|ifdef
name|__GNUC__
comment|/* Expand definitions into case statements */
define|#
directive|define
name|DEFTYPECODE
parameter_list|(
name|CODE
parameter_list|,
name|NAME
parameter_list|,
name|MODE
parameter_list|,
name|TYPE
parameter_list|)
define|\
value|case CODE:							\ 	  {								\ 	    TYPE temp = va_arg (arguments, TYPE); 			\ 	    bc_emit_bytecode_const ((void *)&temp, sizeof temp); 	\ 	    PRLIT (TYPE,&temp); }					\ 	  break;
include|#
directive|include
file|"bc-typecd.def"
undef|#
directive|undef
name|DEFTYPECODE
endif|#
directive|endif
comment|/* __GNUC__ */
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|BCDEBUG_PRINT_CODE
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Emit the machine-code interface trampoline at the beginning of a byte    coded function.  The argument is a label name of the interpreter    bytecode callinfo structure; the return value is a label name for    the beginning of the actual bytecode.  */
end_comment

begin_function
name|char
modifier|*
name|bc_emit_trampoline
parameter_list|(
name|callinfo
parameter_list|)
name|char
modifier|*
name|callinfo
decl_stmt|;
block|{
name|char
name|mylab
index|[
literal|20
index|]
decl_stmt|;
specifier|static
name|int
name|n
decl_stmt|;
name|sprintf
argument_list|(
name|mylab
argument_list|,
literal|"*LB%d"
argument_list|,
name|n
operator|++
argument_list|)
expr_stmt|;
name|BC_EMIT_TRAMPOLINE
argument_list|(
name|trampoline
argument_list|,
name|callinfo
argument_list|)
expr_stmt|;
name|seg_defsym
argument_list|(
name|bytecode
argument_list|,
name|mylab
argument_list|)
expr_stmt|;
return|return
name|sym_lookup
argument_list|(
name|mylab
argument_list|)
operator|->
name|name
return|;
block|}
end_function

begin_comment
comment|/* Simple strdup */
end_comment

begin_function
name|char
modifier|*
name|bc_xstrdup
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|char
modifier|*
name|tmp
init|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|tmp
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
name|tmp
return|;
block|}
end_function

end_unit

