begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Data flow analysis for GNU compiler.    Copyright (C) 1987, 1988, 1992, 1993, 1994 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* This file contains the data flow analysis pass of the compiler.    It computes data flow information    which tells combine_instructions which insns to consider combining    and controls register allocation.     Additional data flow information that is too bulky to record    is generated during the analysis, and is used at that time to    create autoincrement and autodecrement addressing.     The first step is dividing the function into basic blocks.    find_basic_blocks does this.  Then life_analysis determines    where each register is live and where it is dead.     ** find_basic_blocks **     find_basic_blocks divides the current function's rtl    into basic blocks.  It records the beginnings and ends of the    basic blocks in the vectors basic_block_head and basic_block_end,    and the number of blocks in n_basic_blocks.     find_basic_blocks also finds any unreachable loops    and deletes them.     ** life_analysis **     life_analysis is called immediately after find_basic_blocks.    It uses the basic block information to determine where each    hard or pseudo register is live.     ** live-register info **     The information about where each register is live is in two parts:    the REG_NOTES of insns, and the vector basic_block_live_at_start.     basic_block_live_at_start has an element for each basic block,    and the element is a bit-vector with a bit for each hard or pseudo    register.  The bit is 1 if the register is live at the beginning    of the basic block.     Two types of elements can be added to an insn's REG_NOTES.    A REG_DEAD note is added to an insn's REG_NOTES for any register    that meets both of two conditions:  The value in the register is not    needed in subsequent insns and the insn does not replace the value in    the register (in the case of multi-word hard registers, the value in    each register must be replaced by the insn to avoid a REG_DEAD note).     In the vast majority of cases, an object in a REG_DEAD note will be    used somewhere in the insn.  The (rare) exception to this is if an    insn uses a multi-word hard register and only some of the registers are    needed in subsequent insns.  In that case, REG_DEAD notes will be    provided for those hard registers that are not subsequently needed.    Partial REG_DEAD notes of this type do not occur when an insn sets    only some of the hard registers used in such a multi-word operand;    omitting REG_DEAD notes for objects stored in an insn is optional and    the desire to do so does not justify the complexity of the partial    REG_DEAD notes.     REG_UNUSED notes are added for each register that is set by the insn    but is unused subsequently (if every register set by the insn is unused    and the insn does not reference memory or have some other side-effect,    the insn is deleted instead).  If only part of a multi-word hard    register is used in a subsequent insn, REG_UNUSED notes are made for    the parts that will not be used.     To determine which registers are live after any insn, one can    start from the beginning of the basic block and scan insns, noting    which registers are set by each insn and which die there.     ** Other actions of life_analysis **     life_analysis sets up the LOG_LINKS fields of insns because the    information needed to do so is readily available.     life_analysis deletes insns whose only effect is to store a value    that is never used.     life_analysis notices cases where a reference to a register as    a memory address can be combined with a preceding or following    incrementation or decrementation of the register.  The separate    instruction to increment or decrement is deleted and the address    is changed to a POST_INC or similar rtx.     Each time an incrementing or decrementing address is created,    a REG_INC element is added to the insn's REG_NOTES list.     life_analysis fills in certain vectors containing information about    register usage: reg_n_refs, reg_n_deaths, reg_n_sets, reg_live_length,    reg_n_calls_crosses and reg_basic_block.  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_comment
comment|/* List of labels that must never be deleted.  */
end_comment

begin_decl_stmt
specifier|extern
name|rtx
name|forced_labels
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Get the basic block number of an insn.    This info should not be expected to remain available    after the end of life_analysis.  */
end_comment

begin_comment
comment|/* This is the limit of the allocated space in the following two arrays.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_uid_for_flow
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|BLOCK_NUM
parameter_list|(
name|INSN
parameter_list|)
value|uid_block_number[INSN_UID (INSN)]
end_define

begin_comment
comment|/* This is where the BLOCK_NUM values are really stored.    This is set up by find_basic_blocks and used there and in life_analysis,    and then freed.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|uid_block_number
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* INSN_VOLATILE (insn) is 1 if the insn refers to anything volatile.  */
end_comment

begin_define
define|#
directive|define
name|INSN_VOLATILE
parameter_list|(
name|INSN
parameter_list|)
value|uid_volatile[INSN_UID (INSN)]
end_define

begin_decl_stmt
specifier|static
name|char
modifier|*
name|uid_volatile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of basic blocks in the current function.  */
end_comment

begin_decl_stmt
name|int
name|n_basic_blocks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Maximum register number used in this function, plus one.  */
end_comment

begin_decl_stmt
name|int
name|max_regno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Maximum number of SCRATCH rtx's used in any basic block of this function. */
end_comment

begin_decl_stmt
name|int
name|max_scratch
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of SCRATCH rtx's in the current block.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|num_scratch
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by n, gives number of basic block that  (REG n) is used in.    If the value is REG_BLOCK_GLOBAL (-2),    it means (REG n) is used in more than one basic block.    REG_BLOCK_UNKNOWN (-1) means it hasn't been seen yet so we don't know.    This information remains valid for the rest of the compilation    of the current function; it is used to control register allocation.  */
end_comment

begin_decl_stmt
name|int
modifier|*
name|reg_basic_block
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by n, gives number of times (REG n) is used or set, each    weighted by its loop-depth.    This information remains valid for the rest of the compilation    of the current function; it is used to control register allocation.  */
end_comment

begin_decl_stmt
name|int
modifier|*
name|reg_n_refs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by N; says whether a psuedo register N was ever used    within a SUBREG that changes the size of the reg.  Some machines prohibit    such objects to be in certain (usually floating-point) registers.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|reg_changes_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by N, gives number of places register N dies.    This information remains valid for the rest of the compilation    of the current function; it is used to control register allocation.  */
end_comment

begin_decl_stmt
name|short
modifier|*
name|reg_n_deaths
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by N, gives 1 if that reg is live across any CALL_INSNs.    This information remains valid for the rest of the compilation    of the current function; it is used to control register allocation.  */
end_comment

begin_decl_stmt
name|int
modifier|*
name|reg_n_calls_crossed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Total number of instructions at which (REG n) is live.    The larger this is, the less priority (REG n) gets for    allocation in a real register.    This information remains valid for the rest of the compilation    of the current function; it is used to control register allocation.     local-alloc.c may alter this number to change the priority.     Negative values are special.    -1 is used to mark a pseudo reg which has a constant or memory equivalent    and is used infrequently enough that it should not get a hard register.    -2 is used to mark a pseudo reg for a parameter, when a frame pointer    is not required.  global.c makes an allocno for this but does    not try to assign a hard register to it.  */
end_comment

begin_decl_stmt
name|int
modifier|*
name|reg_live_length
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Element N is the next insn that uses (hard or pseudo) register number N    within the current basic block; or zero, if there is no such insn.    This is valid only during the final backward scan in propagate_block.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|reg_next_use
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size of a regset for the current function,    in (1) bytes and (2) elements.  */
end_comment

begin_decl_stmt
name|int
name|regset_bytes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|regset_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Element N is first insn in basic block N.    This info lasts until we finish compiling the function.  */
end_comment

begin_decl_stmt
name|rtx
modifier|*
name|basic_block_head
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Element N is last insn in basic block N.    This info lasts until we finish compiling the function.  */
end_comment

begin_decl_stmt
name|rtx
modifier|*
name|basic_block_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Element N is a regset describing the registers live    at the start of basic block N.    This info lasts until we finish compiling the function.  */
end_comment

begin_decl_stmt
name|regset
modifier|*
name|basic_block_live_at_start
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Regset of regs live when calls to `setjmp'-like functions happen.  */
end_comment

begin_decl_stmt
name|regset
name|regs_live_at_setjmp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List made of EXPR_LIST rtx's which gives pairs of pseudo registers    that have to go in the same hard reg.    The first two regs in the list are a pair, and the next two    are another pair, etc.  */
end_comment

begin_decl_stmt
name|rtx
name|regs_may_share
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Element N is nonzero if control can drop into basic block N    from the preceding basic block.  Freed after life_analysis.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|basic_block_drops_in
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Element N is depth within loops of the last insn in basic block number N.    Freed after life_analysis.  */
end_comment

begin_decl_stmt
specifier|static
name|short
modifier|*
name|basic_block_loop_depth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Element N nonzero if basic block N can actually be reached.    Vector exists only during find_basic_blocks.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|block_live_static
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Depth within loops of basic block being scanned for lifetime analysis,    plus one.  This is the weight attached to references to registers.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|loop_depth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* During propagate_block, this is non-zero if the value of CC0 is live.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cc0_live
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* During propagate_block, this contains the last MEM stored into.  It    is used to eliminate consecutive stores to the same location.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|last_mem_set
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set of registers that may be eliminable.  These are handled specially    in updating regs_ever_live.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|elim_reg_set
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward declarations */
end_comment

begin_decl_stmt
specifier|static
name|void
name|find_basic_blocks
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|uses_reg_or_mem
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_label_ref
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|life_analysis
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|allocate_for_life_analysis
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_regset_vector
name|PROTO
argument_list|(
operator|(
name|regset
operator|*
operator|,
name|regset
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|propagate_block
name|PROTO
argument_list|(
operator|(
name|regset
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|,
name|regset
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|insn_dead_p
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|regset
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|libcall_dead_p
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|regset
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_set_regs
name|PROTO
argument_list|(
operator|(
name|regset
operator|,
name|regset
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|regset
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_set_1
name|PROTO
argument_list|(
operator|(
name|regset
operator|,
name|regset
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|regset
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|find_auto_inc
name|PROTO
argument_list|(
operator|(
name|regset
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_used_regs
name|PROTO
argument_list|(
operator|(
name|regset
operator|,
name|regset
operator|,
name|rtx
operator|,
name|int
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|try_pre_increment_1
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|try_pre_increment
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|HOST_WIDE_INT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|find_use_as_address
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|HOST_WIDE_INT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|dump_flow_info
name|PROTO
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Find basic blocks of the current function and perform data flow analysis.    F is the first insn of the function and NREGS the number of register numbers    in use.  */
end_comment

begin_function
name|void
name|flow_analysis
parameter_list|(
name|f
parameter_list|,
name|nregs
parameter_list|,
name|file
parameter_list|)
name|rtx
name|f
decl_stmt|;
name|int
name|nregs
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
specifier|register
name|rtx
name|insn
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|rtx
name|nonlocal_label_list
init|=
name|nonlocal_label_rtx_list
argument_list|()
decl_stmt|;
ifdef|#
directive|ifdef
name|ELIMINABLE_REGS
specifier|static
struct|struct
block|{
name|int
name|from
decl_stmt|,
name|to
decl_stmt|;
block|}
name|eliminables
index|[]
init|=
name|ELIMINABLE_REGS
struct|;
endif|#
directive|endif
comment|/* Record which registers will be eliminated.  We use this in      mark_used_regs. */
name|CLEAR_HARD_REG_SET
argument_list|(
name|elim_reg_set
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ELIMINABLE_REGS
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
name|eliminables
operator|/
sizeof|sizeof
name|eliminables
index|[
literal|0
index|]
condition|;
name|i
operator|++
control|)
name|SET_HARD_REG_BIT
argument_list|(
name|elim_reg_set
argument_list|,
name|eliminables
index|[
name|i
index|]
operator|.
name|from
argument_list|)
expr_stmt|;
else|#
directive|else
name|SET_HARD_REG_BIT
argument_list|(
name|elim_reg_set
argument_list|,
name|FRAME_POINTER_REGNUM
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Count the basic blocks.  Also find maximum insn uid value used.  */
block|{
specifier|register
name|RTX_CODE
name|prev_code
init|=
name|JUMP_INSN
decl_stmt|;
specifier|register
name|RTX_CODE
name|code
decl_stmt|;
name|max_uid_for_flow
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|f
operator|,
name|i
operator|=
literal|0
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|code
operator|=
name|GET_CODE
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|>
name|max_uid_for_flow
condition|)
name|max_uid_for_flow
operator|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|CODE_LABEL
operator|||
operator|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'i'
operator|&&
operator|(
name|prev_code
operator|==
name|JUMP_INSN
operator|||
operator|(
name|prev_code
operator|==
name|CALL_INSN
operator|&&
name|nonlocal_label_list
operator|!=
literal|0
operator|)
operator|||
name|prev_code
operator|==
name|BARRIER
operator|)
operator|)
condition|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|NOTE
condition|)
name|prev_code
operator|=
name|code
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
comment|/* Leave space for insns we make in some cases for auto-inc.  These cases      are rare, so we don't need too much space.  */
name|max_uid_for_flow
operator|+=
name|max_uid_for_flow
operator|/
literal|10
expr_stmt|;
endif|#
directive|endif
comment|/* Allocate some tables that last till end of compiling this function      and some needed only in find_basic_blocks and life_analysis.  */
name|n_basic_blocks
operator|=
name|i
expr_stmt|;
name|basic_block_head
operator|=
operator|(
name|rtx
operator|*
operator|)
name|oballoc
argument_list|(
name|n_basic_blocks
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|basic_block_end
operator|=
operator|(
name|rtx
operator|*
operator|)
name|oballoc
argument_list|(
name|n_basic_blocks
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|basic_block_drops_in
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|basic_block_loop_depth
operator|=
operator|(
name|short
operator|*
operator|)
name|alloca
argument_list|(
name|n_basic_blocks
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|uid_block_number
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|max_uid_for_flow
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|uid_volatile
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|max_uid_for_flow
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|uid_volatile
argument_list|,
name|max_uid_for_flow
operator|+
literal|1
argument_list|)
expr_stmt|;
name|find_basic_blocks
argument_list|(
name|f
argument_list|,
name|nonlocal_label_list
argument_list|)
expr_stmt|;
name|life_analysis
argument_list|(
name|f
argument_list|,
name|nregs
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
condition|)
name|dump_flow_info
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|basic_block_drops_in
operator|=
literal|0
expr_stmt|;
name|uid_block_number
operator|=
literal|0
expr_stmt|;
name|basic_block_loop_depth
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find all basic blocks of the function whose first insn is F.    Store the correct data in the tables that describe the basic blocks,    set up the chains of references for each CODE_LABEL, and    delete any entire basic blocks that cannot be reached.     NONLOCAL_LABEL_LIST is the same local variable from flow_analysis.  */
end_comment

begin_function
specifier|static
name|void
name|find_basic_blocks
parameter_list|(
name|f
parameter_list|,
name|nonlocal_label_list
parameter_list|)
name|rtx
name|f
decl_stmt|,
name|nonlocal_label_list
decl_stmt|;
block|{
specifier|register
name|rtx
name|insn
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|block_live
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|n_basic_blocks
argument_list|)
decl_stmt|;
specifier|register
name|char
modifier|*
name|block_marked
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|n_basic_blocks
argument_list|)
decl_stmt|;
comment|/* List of label_refs to all labels whose addresses are taken      and used as data.  */
name|rtx
name|label_value_list
init|=
literal|0
decl_stmt|;
name|rtx
name|x
decl_stmt|,
name|note
decl_stmt|;
name|enum
name|rtx_code
name|prev_code
decl_stmt|,
name|code
decl_stmt|;
name|int
name|depth
decl_stmt|;
name|block_live_static
operator|=
name|block_live
expr_stmt|;
name|bzero
argument_list|(
name|block_live
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|block_marked
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
comment|/* Initialize with just block 0 reachable and no blocks marked.  */
if|if
condition|(
name|n_basic_blocks
operator|>
literal|0
condition|)
name|block_live
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
comment|/* Initialize the ref chain of each label to 0.  Record where all the      blocks start and end and their depth in loops.  For each insn, record      the block it is in.   Also mark as reachable any blocks headed by labels      that must not be deleted.  */
for|for
control|(
name|insn
operator|=
name|f
operator|,
name|i
operator|=
operator|-
literal|1
operator|,
name|prev_code
operator|=
name|JUMP_INSN
operator|,
name|depth
operator|=
literal|1
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|code
operator|=
name|GET_CODE
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|NOTE
condition|)
block|{
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
condition|)
name|depth
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_END
condition|)
name|depth
operator|--
expr_stmt|;
block|}
comment|/* A basic block starts at label, or after something that can jump.  */
elseif|else
if|if
condition|(
name|code
operator|==
name|CODE_LABEL
operator|||
operator|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'i'
operator|&&
operator|(
name|prev_code
operator|==
name|JUMP_INSN
operator|||
operator|(
name|prev_code
operator|==
name|CALL_INSN
operator|&&
name|nonlocal_label_list
operator|!=
literal|0
operator|)
operator|||
name|prev_code
operator|==
name|BARRIER
operator|)
operator|)
condition|)
block|{
name|basic_block_head
index|[
operator|++
name|i
index|]
operator|=
name|insn
expr_stmt|;
name|basic_block_end
index|[
name|i
index|]
operator|=
name|insn
expr_stmt|;
name|basic_block_loop_depth
index|[
name|i
index|]
operator|=
name|depth
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|CODE_LABEL
condition|)
block|{
name|LABEL_REFS
argument_list|(
name|insn
argument_list|)
operator|=
name|insn
expr_stmt|;
comment|/* Any label that cannot be deleted 		   is considered to start a reachable block.  */
if|if
condition|(
name|LABEL_PRESERVE_P
argument_list|(
name|insn
argument_list|)
condition|)
name|block_live
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'i'
condition|)
block|{
name|basic_block_end
index|[
name|i
index|]
operator|=
name|insn
expr_stmt|;
name|basic_block_loop_depth
index|[
name|i
index|]
operator|=
name|depth
expr_stmt|;
block|}
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'i'
condition|)
block|{
comment|/* Make a list of all labels referred to other than by jumps.  */
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_LABEL
condition|)
name|label_value_list
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|VOIDmode
argument_list|,
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|label_value_list
argument_list|)
expr_stmt|;
block|}
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|NOTE
condition|)
name|prev_code
operator|=
name|code
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|+
literal|1
operator|!=
name|n_basic_blocks
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Don't delete the labels (in this function)      that are referenced by non-jump instructions.  */
for|for
control|(
name|x
operator|=
name|label_value_list
init|;
name|x
condition|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
operator|!
name|LABEL_REF_NONLOCAL_P
argument_list|(
name|x
argument_list|)
condition|)
name|block_live
index|[
name|BLOCK_NUM
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|x
operator|=
name|forced_labels
init|;
name|x
condition|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
operator|!
name|LABEL_REF_NONLOCAL_P
argument_list|(
name|x
argument_list|)
condition|)
name|block_live
index|[
name|BLOCK_NUM
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
operator|=
literal|1
expr_stmt|;
comment|/* Record which basic blocks control can drop in to.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|basic_block_head
index|[
name|i
index|]
argument_list|)
init|;
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
empty_stmt|;
name|basic_block_drops_in
index|[
name|i
index|]
operator|=
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|BARRIER
expr_stmt|;
block|}
comment|/* Now find which basic blocks can actually be reached      and put all jump insns' LABEL_REFS onto the ref-chains      of their target labels.  */
if|if
condition|(
name|n_basic_blocks
operator|>
literal|0
condition|)
block|{
name|int
name|something_marked
init|=
literal|1
decl_stmt|;
comment|/* Find all indirect jump insns and mark them as possibly jumping to all 	 the labels whose addresses are explicitly used.  This is because, 	 when there are computed gotos, we can't tell which labels they jump 	 to, of all the possibilities.  	 Tablejumps and casesi insns are OK and we can recognize them by 	 a (use (label_ref)).  */
for|for
control|(
name|insn
operator|=
name|f
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
name|computed_jump
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|len
init|=
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|has_use_labelref
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
name|len
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|USE
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|)
condition|)
name|has_use_labelref
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|has_use_labelref
condition|)
for|for
control|(
name|i
operator|=
name|len
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|pc_rtx
operator|&&
name|uses_reg_or_mem
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
condition|)
name|computed_jump
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|pat
argument_list|)
operator|==
name|pc_rtx
operator|&&
name|uses_reg_or_mem
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
condition|)
name|computed_jump
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|computed_jump
condition|)
block|{
for|for
control|(
name|x
operator|=
name|label_value_list
init|;
name|x
condition|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
control|)
name|mark_label_ref
argument_list|(
name|gen_rtx
argument_list|(
name|LABEL_REF
argument_list|,
name|VOIDmode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
name|forced_labels
init|;
name|x
condition|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
control|)
name|mark_label_ref
argument_list|(
name|gen_rtx
argument_list|(
name|LABEL_REF
argument_list|,
name|VOIDmode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Find all call insns and mark them as possibly jumping 	 to all the nonlocal goto handler labels.  */
for|for
control|(
name|insn
operator|=
name|f
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
for|for
control|(
name|x
operator|=
name|nonlocal_label_list
init|;
name|x
condition|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
control|)
comment|/* Don't try marking labels that 		 were deleted as unreferenced.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|mark_label_ref
argument_list|(
name|gen_rtx
argument_list|(
name|LABEL_REF
argument_list|,
name|VOIDmode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* ??? This could be made smarter: 	       in some cases it's possible to tell that certain 	       calls will not do a nonlocal goto.  	       For example, if the nested functions that do the 	       nonlocal gotos do not have their addresses taken, then 	       only calls to those functions or to other nested 	       functions that use them could possibly do nonlocal 	       gotos.  */
block|}
comment|/* Pass over all blocks, marking each block that is reachable 	 and has not yet been marked. 	 Keep doing this until, in one pass, no blocks have been marked. 	 Then blocks_live and blocks_marked are identical and correct. 	 In addition, all jumps actually reachable have been marked.  */
while|while
condition|(
name|something_marked
condition|)
block|{
name|something_marked
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|block_live
index|[
name|i
index|]
operator|&&
operator|!
name|block_marked
index|[
name|i
index|]
condition|)
block|{
name|block_marked
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|something_marked
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|<
name|n_basic_blocks
operator|&&
name|basic_block_drops_in
index|[
name|i
operator|+
literal|1
index|]
condition|)
name|block_live
index|[
name|i
operator|+
literal|1
index|]
operator|=
literal|1
expr_stmt|;
name|insn
operator|=
name|basic_block_end
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
name|mark_label_ref
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* ??? See if we have a "live" basic block that is not reachable. 	 This can happen if it is headed by a label that is preserved or 	 in one of the label lists, but no call or computed jump is in 	 the loop.  It's not clear if we can delete the block or not, 	 but don't for now.  However, we will mess up register status if 	 it remains unreachable, so add a fake reachability from the 	 previous block.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|block_live
index|[
name|i
index|]
operator|&&
operator|!
name|basic_block_drops_in
index|[
name|i
index|]
operator|&&
name|GET_CODE
argument_list|(
name|basic_block_head
index|[
name|i
index|]
argument_list|)
operator|==
name|CODE_LABEL
operator|&&
name|LABEL_REFS
argument_list|(
name|basic_block_head
index|[
name|i
index|]
argument_list|)
operator|==
name|basic_block_head
index|[
name|i
index|]
condition|)
name|basic_block_drops_in
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
comment|/* Now delete the code for any basic blocks that can't be reached. 	 They can occur because jump_optimize does not recognize 	 unreachable loops as unreachable.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|block_live
index|[
name|i
index|]
condition|)
block|{
name|insn
operator|=
name|basic_block_head
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|BARRIER
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
condition|)
block|{
name|PUT_CODE
argument_list|(
name|insn
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|insn
operator|==
name|basic_block_end
index|[
name|i
index|]
condition|)
block|{
comment|/* BARRIERs are between basic blocks, not part of one. 		       Delete a BARRIER if the preceding jump is deleted. 		       We cannot alter a BARRIER into a NOTE 		       because it is too short; but we can really delete 		       it because it is not part of a basic block.  */
if|if
condition|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|BARRIER
condition|)
name|delete_insn
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* Each time we delete some basic blocks, 	       see if there is a jump around them that is 	       being turned into a no-op.  If so, delete it.  */
if|if
condition|(
name|block_live
index|[
name|i
operator|-
literal|1
index|]
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
name|n_basic_blocks
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|block_live
index|[
name|j
index|]
condition|)
block|{
name|rtx
name|label
decl_stmt|;
name|insn
operator|=
name|basic_block_end
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
comment|/* An unconditional jump is the only possibility 			     we must check for, since a conditional one 			     would make these blocks live.  */
operator|&&
name|simplejump_p
argument_list|(
name|insn
argument_list|)
operator|&&
operator|(
name|label
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|,
literal|1
operator|)
operator|&&
name|INSN_UID
argument_list|(
name|label
argument_list|)
operator|!=
literal|0
operator|&&
name|BLOCK_NUM
argument_list|(
name|label
argument_list|)
operator|==
name|j
condition|)
block|{
name|PUT_CODE
argument_list|(
name|insn
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|BARRIER
condition|)
name|abort
argument_list|()
expr_stmt|;
name|delete_insn
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if X contain a REG or MEM that is not in the constant pool.  */
end_comment

begin_function
specifier|static
name|int
name|uses_reg_or_mem
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|REG
operator|||
operator|(
name|code
operator|==
name|MEM
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
return|return
literal|1
return|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|&&
name|uses_reg_or_mem
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|uses_reg_or_mem
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Check expression X for label references;    if one is found, add INSN to the label's chain of references.     CHECKDUP means check for and avoid creating duplicate references    from the same insn.  Such duplicates do no serious harm but    can slow life analysis.  CHECKDUP is set only when duplicates    are likely.  */
end_comment

begin_function
specifier|static
name|void
name|mark_label_ref
parameter_list|(
name|x
parameter_list|,
name|insn
parameter_list|,
name|checkdup
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|insn
decl_stmt|;
name|int
name|checkdup
decl_stmt|;
block|{
specifier|register
name|RTX_CODE
name|code
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
comment|/* We can be called with NULL when scanning label_value_list.  */
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|LABEL_REF
condition|)
block|{
specifier|register
name|rtx
name|label
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|register
name|rtx
name|y
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|label
argument_list|)
operator|!=
name|CODE_LABEL
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If the label was never emitted, this insn is junk, 	 but avoid a crash trying to refer to BLOCK_NUM (label). 	 This can happen as a result of a syntax error 	 and a diagnostic has already been printed.  */
if|if
condition|(
name|INSN_UID
argument_list|(
name|label
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|CONTAINING_INSN
argument_list|(
name|x
argument_list|)
operator|=
name|insn
expr_stmt|;
comment|/* if CHECKDUP is set, check for duplicate ref from same insn 	 and don't insert.  */
if|if
condition|(
name|checkdup
condition|)
for|for
control|(
name|y
operator|=
name|LABEL_REFS
argument_list|(
name|label
argument_list|)
init|;
name|y
operator|!=
name|label
condition|;
name|y
operator|=
name|LABEL_NEXTREF
argument_list|(
name|y
argument_list|)
control|)
if|if
condition|(
name|CONTAINING_INSN
argument_list|(
name|y
argument_list|)
operator|==
name|insn
condition|)
return|return;
name|LABEL_NEXTREF
argument_list|(
name|x
argument_list|)
operator|=
name|LABEL_REFS
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|LABEL_REFS
argument_list|(
name|label
argument_list|)
operator|=
name|x
expr_stmt|;
name|block_live_static
index|[
name|BLOCK_NUM
argument_list|(
name|label
argument_list|)
index|]
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|mark_label_ref
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|mark_label_ref
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Determine which registers are live at the start of each    basic block of the function whose first insn is F.    NREGS is the number of registers used in F.    We allocate the vector basic_block_live_at_start    and the regsets that it points to, and fill them with the data.    regset_size and regset_bytes are also set here.  */
end_comment

begin_function
specifier|static
name|void
name|life_analysis
parameter_list|(
name|f
parameter_list|,
name|nregs
parameter_list|)
name|rtx
name|f
decl_stmt|;
name|int
name|nregs
decl_stmt|;
block|{
specifier|register
name|regset
name|tem
decl_stmt|;
name|int
name|first_pass
decl_stmt|;
name|int
name|changed
decl_stmt|;
comment|/* For each basic block, a bitmask of regs      live on exit from the block.  */
name|regset
modifier|*
name|basic_block_live_at_end
decl_stmt|;
comment|/* For each basic block, a bitmask of regs      live on entry to a successor-block of this block.      If this does not match basic_block_live_at_end,      that must be updated, and the block must be rescanned.  */
name|regset
modifier|*
name|basic_block_new_live_at_end
decl_stmt|;
comment|/* For each basic block, a bitmask of regs      whose liveness at the end of the basic block      can make a difference in which regs are live on entry to the block.      These are the regs that are set within the basic block,      possibly excluding those that are used after they are set.  */
name|regset
modifier|*
name|basic_block_significant
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|struct
name|obstack
name|flow_obstack
decl_stmt|;
name|gcc_obstack_init
argument_list|(
operator|&
name|flow_obstack
argument_list|)
expr_stmt|;
name|max_regno
operator|=
name|nregs
expr_stmt|;
name|bzero
argument_list|(
name|regs_ever_live
argument_list|,
sizeof|sizeof
name|regs_ever_live
argument_list|)
expr_stmt|;
comment|/* Allocate and zero out many data structures      that will record the data from lifetime analysis.  */
name|allocate_for_life_analysis
argument_list|()
expr_stmt|;
name|reg_next_use
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reg_next_use
argument_list|,
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set up several regset-vectors used internally within this function.      Their meanings are documented above, with their declarations.  */
name|basic_block_live_at_end
operator|=
operator|(
name|regset
operator|*
operator|)
name|alloca
argument_list|(
name|n_basic_blocks
operator|*
sizeof|sizeof
argument_list|(
name|regset
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Don't use alloca since that leads to a crash rather than an error message      if there isn't enough space.      Don't use oballoc since we may need to allocate other things during      this function on the temporary obstack.  */
name|tem
operator|=
operator|(
name|regset
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|flow_obstack
argument_list|,
name|n_basic_blocks
operator|*
name|regset_bytes
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tem
argument_list|,
name|n_basic_blocks
operator|*
name|regset_bytes
argument_list|)
expr_stmt|;
name|init_regset_vector
argument_list|(
name|basic_block_live_at_end
argument_list|,
name|tem
argument_list|,
name|n_basic_blocks
argument_list|,
name|regset_bytes
argument_list|)
expr_stmt|;
name|basic_block_new_live_at_end
operator|=
operator|(
name|regset
operator|*
operator|)
name|alloca
argument_list|(
name|n_basic_blocks
operator|*
sizeof|sizeof
argument_list|(
name|regset
argument_list|)
argument_list|)
expr_stmt|;
name|tem
operator|=
operator|(
name|regset
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|flow_obstack
argument_list|,
name|n_basic_blocks
operator|*
name|regset_bytes
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tem
argument_list|,
name|n_basic_blocks
operator|*
name|regset_bytes
argument_list|)
expr_stmt|;
name|init_regset_vector
argument_list|(
name|basic_block_new_live_at_end
argument_list|,
name|tem
argument_list|,
name|n_basic_blocks
argument_list|,
name|regset_bytes
argument_list|)
expr_stmt|;
name|basic_block_significant
operator|=
operator|(
name|regset
operator|*
operator|)
name|alloca
argument_list|(
name|n_basic_blocks
operator|*
sizeof|sizeof
argument_list|(
name|regset
argument_list|)
argument_list|)
expr_stmt|;
name|tem
operator|=
operator|(
name|regset
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|flow_obstack
argument_list|,
name|n_basic_blocks
operator|*
name|regset_bytes
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tem
argument_list|,
name|n_basic_blocks
operator|*
name|regset_bytes
argument_list|)
expr_stmt|;
name|init_regset_vector
argument_list|(
name|basic_block_significant
argument_list|,
name|tem
argument_list|,
name|n_basic_blocks
argument_list|,
name|regset_bytes
argument_list|)
expr_stmt|;
comment|/* Record which insns refer to any volatile memory      or for any reason can't be deleted just because they are dead stores.      Also, delete any insns that copy a register to itself. */
for|for
control|(
name|insn
operator|=
name|f
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|enum
name|rtx_code
name|code1
init|=
name|GET_CODE
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|code1
operator|==
name|CALL_INSN
condition|)
name|INSN_VOLATILE
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|code1
operator|==
name|INSN
operator|||
name|code1
operator|==
name|JUMP_INSN
condition|)
block|{
comment|/* Delete (in effect) any obvious no-op moves.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
comment|/* Insns carrying these notes are useful later on.  */
operator|&&
operator|!
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
block|{
name|PUT_CODE
argument_list|(
name|insn
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
comment|/* If nothing but SETs of registers to themselves, 		 this insn can also be deleted.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|tem
init|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|CLOBBER
condition|)
continue|continue;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|!=
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|tem
argument_list|)
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
comment|/* Insns carrying these notes are useful later on.  */
operator|&&
operator|!
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
block|{
name|PUT_CODE
argument_list|(
name|insn
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|INSN_VOLATILE
argument_list|(
name|insn
argument_list|)
operator|=
name|volatile_refs_p
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|USE
condition|)
name|INSN_VOLATILE
argument_list|(
name|insn
argument_list|)
operator|=
name|volatile_refs_p
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* A SET that makes space on the stack cannot be dead. 	     (Such SETs occur only for allocating variable-size data, 	     so they will always have a PLUS or MINUS according to the 	     direction of stack growth.) 	     Even if this function never uses this stack pointer value, 	     signal handlers do!  */
elseif|else
if|if
condition|(
name|code1
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|stack_pointer_rtx
ifdef|#
directive|ifdef
name|STACK_GROWS_DOWNWARD
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|MINUS
else|#
directive|else
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|PLUS
endif|#
directive|endif
operator|&&
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|stack_pointer_rtx
condition|)
name|INSN_VOLATILE
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|n_basic_blocks
operator|>
literal|0
condition|)
ifdef|#
directive|ifdef
name|EXIT_IGNORE_STACK
if|if
condition|(
operator|!
name|EXIT_IGNORE_STACK
operator|||
operator|(
operator|!
name|FRAME_POINTER_REQUIRED
operator|&&
name|flag_omit_frame_pointer
operator|)
condition|)
endif|#
directive|endif
block|{
comment|/* If exiting needs the right stack value, 	   consider the stack pointer live at the end of the function.  */
name|basic_block_live_at_end
index|[
name|n_basic_blocks
operator|-
literal|1
index|]
index|[
name|STACK_POINTER_REGNUM
operator|/
name|REGSET_ELT_BITS
index|]
operator||=
operator|(
name|REGSET_ELT_TYPE
operator|)
literal|1
operator|<<
operator|(
name|STACK_POINTER_REGNUM
operator|%
name|REGSET_ELT_BITS
operator|)
expr_stmt|;
name|basic_block_new_live_at_end
index|[
name|n_basic_blocks
operator|-
literal|1
index|]
index|[
name|STACK_POINTER_REGNUM
operator|/
name|REGSET_ELT_BITS
index|]
operator||=
operator|(
name|REGSET_ELT_TYPE
operator|)
literal|1
operator|<<
operator|(
name|STACK_POINTER_REGNUM
operator|%
name|REGSET_ELT_BITS
operator|)
expr_stmt|;
block|}
comment|/* Mark the frame pointer is needed at the end of the function.  If      we end up eliminating it, it will be removed from the live list      of each basic block by reload.  */
if|if
condition|(
name|n_basic_blocks
operator|>
literal|0
condition|)
block|{
name|basic_block_live_at_end
index|[
name|n_basic_blocks
operator|-
literal|1
index|]
index|[
name|FRAME_POINTER_REGNUM
operator|/
name|REGSET_ELT_BITS
index|]
operator||=
operator|(
name|REGSET_ELT_TYPE
operator|)
literal|1
operator|<<
operator|(
name|FRAME_POINTER_REGNUM
operator|%
name|REGSET_ELT_BITS
operator|)
expr_stmt|;
name|basic_block_new_live_at_end
index|[
name|n_basic_blocks
operator|-
literal|1
index|]
index|[
name|FRAME_POINTER_REGNUM
operator|/
name|REGSET_ELT_BITS
index|]
operator||=
operator|(
name|REGSET_ELT_TYPE
operator|)
literal|1
operator|<<
operator|(
name|FRAME_POINTER_REGNUM
operator|%
name|REGSET_ELT_BITS
operator|)
expr_stmt|;
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|HARD_FRAME_POINTER_REGNUM
comment|/* If they are different, also mark the hard frame pointer as live */
name|basic_block_live_at_end
index|[
name|n_basic_blocks
operator|-
literal|1
index|]
index|[
name|HARD_FRAME_POINTER_REGNUM
operator|/
name|REGSET_ELT_BITS
index|]
operator||=
operator|(
name|REGSET_ELT_TYPE
operator|)
literal|1
operator|<<
operator|(
name|HARD_FRAME_POINTER_REGNUM
operator|%
name|REGSET_ELT_BITS
operator|)
expr_stmt|;
name|basic_block_new_live_at_end
index|[
name|n_basic_blocks
operator|-
literal|1
index|]
index|[
name|HARD_FRAME_POINTER_REGNUM
operator|/
name|REGSET_ELT_BITS
index|]
operator||=
operator|(
name|REGSET_ELT_TYPE
operator|)
literal|1
operator|<<
operator|(
name|HARD_FRAME_POINTER_REGNUM
operator|%
name|REGSET_ELT_BITS
operator|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Mark all global registers as being live at the end of the function      since they may be referenced by our caller.  */
if|if
condition|(
name|n_basic_blocks
operator|>
literal|0
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|global_regs
index|[
name|i
index|]
condition|)
block|{
name|basic_block_live_at_end
index|[
name|n_basic_blocks
operator|-
literal|1
index|]
index|[
name|i
operator|/
name|REGSET_ELT_BITS
index|]
operator||=
operator|(
name|REGSET_ELT_TYPE
operator|)
literal|1
operator|<<
operator|(
name|i
operator|%
name|REGSET_ELT_BITS
operator|)
expr_stmt|;
name|basic_block_new_live_at_end
index|[
name|n_basic_blocks
operator|-
literal|1
index|]
index|[
name|i
operator|/
name|REGSET_ELT_BITS
index|]
operator||=
operator|(
name|REGSET_ELT_TYPE
operator|)
literal|1
operator|<<
operator|(
name|i
operator|%
name|REGSET_ELT_BITS
operator|)
expr_stmt|;
block|}
comment|/* Propagate life info through the basic blocks      around the graph of basic blocks.       This is a relaxation process: each time a new register      is live at the end of the basic block, we must scan the block      to determine which registers are, as a consequence, live at the beginning      of that block.  These registers must then be marked live at the ends      of all the blocks that can transfer control to that block.      The process continues until it reaches a fixed point.  */
name|first_pass
operator|=
literal|1
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|changed
condition|)
block|{
name|changed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|n_basic_blocks
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|int
name|consider
init|=
name|first_pass
decl_stmt|;
name|int
name|must_rescan
init|=
name|first_pass
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
if|if
condition|(
operator|!
name|first_pass
condition|)
block|{
comment|/* Set CONSIDER if this block needs thinking about at all 		 (that is, if the regs live now at the end of it 		 are not the same as were live at the end of it when 		 we last thought about it). 		 Set must_rescan if it needs to be thought about 		 instruction by instruction (that is, if any additional 		 reg that is live at the end now but was not live there before 		 is one of the significant regs of this basic block).  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|regset_size
condition|;
name|j
operator|++
control|)
block|{
specifier|register
name|REGSET_ELT_TYPE
name|x
init|=
operator|(
name|basic_block_new_live_at_end
index|[
name|i
index|]
index|[
name|j
index|]
operator|&
operator|~
name|basic_block_live_at_end
index|[
name|i
index|]
index|[
name|j
index|]
operator|)
decl_stmt|;
if|if
condition|(
name|x
condition|)
name|consider
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|x
operator|&
name|basic_block_significant
index|[
name|i
index|]
index|[
name|j
index|]
condition|)
block|{
name|must_rescan
operator|=
literal|1
expr_stmt|;
name|consider
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|consider
condition|)
continue|continue;
block|}
comment|/* The live_at_start of this block may be changing, 	     so another pass will be required after this one.  */
name|changed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|must_rescan
condition|)
block|{
comment|/* No complete rescan needed; 		 just record those variables newly known live at end 		 as live at start as well.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|regset_size
condition|;
name|j
operator|++
control|)
block|{
specifier|register
name|REGSET_ELT_TYPE
name|x
init|=
operator|(
name|basic_block_new_live_at_end
index|[
name|i
index|]
index|[
name|j
index|]
operator|&
operator|~
name|basic_block_live_at_end
index|[
name|i
index|]
index|[
name|j
index|]
operator|)
decl_stmt|;
name|basic_block_live_at_start
index|[
name|i
index|]
index|[
name|j
index|]
operator||=
name|x
expr_stmt|;
name|basic_block_live_at_end
index|[
name|i
index|]
index|[
name|j
index|]
operator||=
name|x
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Update the basic_block_live_at_start 		 by propagation backwards through the block.  */
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|basic_block_new_live_at_end
index|[
name|i
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|basic_block_live_at_end
index|[
name|i
index|]
argument_list|,
name|regset_bytes
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|basic_block_live_at_end
index|[
name|i
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|basic_block_live_at_start
index|[
name|i
index|]
argument_list|,
name|regset_bytes
argument_list|)
expr_stmt|;
name|propagate_block
argument_list|(
name|basic_block_live_at_start
index|[
name|i
index|]
argument_list|,
name|basic_block_head
index|[
name|i
index|]
argument_list|,
name|basic_block_end
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
name|first_pass
condition|?
name|basic_block_significant
index|[
name|i
index|]
else|:
operator|(
name|regset
operator|)
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|{
specifier|register
name|rtx
name|jump
decl_stmt|,
name|head
decl_stmt|;
comment|/* Update the basic_block_new_live_at_end's of the block 	       that falls through into this one (if any).  */
name|head
operator|=
name|basic_block_head
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|basic_block_drops_in
index|[
name|i
index|]
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|regset_size
condition|;
name|j
operator|++
control|)
name|basic_block_new_live_at_end
index|[
name|i
operator|-
literal|1
index|]
index|[
name|j
index|]
operator||=
name|basic_block_live_at_start
index|[
name|i
index|]
index|[
name|j
index|]
expr_stmt|;
block|}
comment|/* Update the basic_block_new_live_at_end's of 	       all the blocks that jump to this one.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|head
argument_list|)
operator|==
name|CODE_LABEL
condition|)
for|for
control|(
name|jump
operator|=
name|LABEL_REFS
argument_list|(
name|head
argument_list|)
init|;
name|jump
operator|!=
name|head
condition|;
name|jump
operator|=
name|LABEL_NEXTREF
argument_list|(
name|jump
argument_list|)
control|)
block|{
specifier|register
name|int
name|from_block
init|=
name|BLOCK_NUM
argument_list|(
name|CONTAINING_INSN
argument_list|(
name|jump
argument_list|)
argument_list|)
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|regset_size
condition|;
name|j
operator|++
control|)
name|basic_block_new_live_at_end
index|[
name|from_block
index|]
index|[
name|j
index|]
operator||=
name|basic_block_live_at_start
index|[
name|i
index|]
index|[
name|j
index|]
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|USE_C_ALLOCA
name|alloca
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|first_pass
operator|=
literal|0
expr_stmt|;
block|}
comment|/* The only pseudos that are live at the beginning of the function are      those that were not set anywhere in the function.  local-alloc doesn't      know how to handle these correctly, so mark them as not local to any      one basic block.  */
if|if
condition|(
name|n_basic_blocks
operator|>
literal|0
condition|)
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
name|max_regno
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|basic_block_live_at_start
index|[
literal|0
index|]
index|[
name|i
operator|/
name|REGSET_ELT_BITS
index|]
operator|&
operator|(
operator|(
name|REGSET_ELT_TYPE
operator|)
literal|1
operator|<<
operator|(
name|i
operator|%
name|REGSET_ELT_BITS
operator|)
operator|)
condition|)
name|reg_basic_block
index|[
name|i
index|]
operator|=
name|REG_BLOCK_GLOBAL
expr_stmt|;
comment|/* Now the life information is accurate.      Make one more pass over each basic block      to delete dead stores, create autoincrement addressing      and record how many times each register is used, is set, or dies.       To save time, we operate directly in basic_block_live_at_end[i],      thus destroying it (in fact, converting it into a copy of      basic_block_live_at_start[i]).  This is ok now because      basic_block_live_at_end[i] is no longer used past this point.  */
name|max_scratch
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
block|{
name|propagate_block
argument_list|(
name|basic_block_live_at_end
index|[
name|i
index|]
argument_list|,
name|basic_block_head
index|[
name|i
index|]
argument_list|,
name|basic_block_end
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|,
operator|(
name|regset
operator|)
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_C_ALLOCA
name|alloca
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|#
directive|if
literal|0
comment|/* Something live during a setjmp should not be put in a register      on certain machines which restore regs from stack frames      rather than from the jmpbuf.      But we don't need to do this for the user's variables, since      ANSI says only volatile variables need this.  */
ifdef|#
directive|ifdef
name|LONGJMP_RESTORE_FROM_STACK
block|for (i = FIRST_PSEUDO_REGISTER; i< nregs; i++)     if (regs_live_at_setjmp[i / REGSET_ELT_BITS]& ((REGSET_ELT_TYPE) 1<< (i % REGSET_ELT_BITS))&& regno_reg_rtx[i] != 0&& ! REG_USERVAR_P (regno_reg_rtx[i]))       { 	reg_live_length[i] = -1; 	reg_basic_block[i] = -1;       }
endif|#
directive|endif
endif|#
directive|endif
comment|/* We have a problem with any pseudoreg that      lives across the setjmp.  ANSI says that if a      user variable does not change in value      between the setjmp and the longjmp, then the longjmp preserves it.      This includes longjmp from a place where the pseudo appears dead.      (In principle, the value still exists if it is in scope.)      If the pseudo goes in a hard reg, some other value may occupy      that hard reg where this pseudo is dead, thus clobbering the pseudo.      Conclusion: such a pseudo must not go in a hard reg.  */
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
name|nregs
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|regs_live_at_setjmp
index|[
name|i
operator|/
name|REGSET_ELT_BITS
index|]
operator|&
operator|(
operator|(
name|REGSET_ELT_TYPE
operator|)
literal|1
operator|<<
operator|(
name|i
operator|%
name|REGSET_ELT_BITS
operator|)
operator|)
operator|)
operator|&&
name|regno_reg_rtx
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|reg_live_length
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|reg_basic_block
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|obstack_free
argument_list|(
operator|&
name|flow_obstack
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutines of life analysis.  */
end_comment

begin_comment
comment|/* Allocate the permanent data structures that represent the results    of life analysis.  Not static since used also for stupid life analysis.  */
end_comment

begin_function
name|void
name|allocate_for_life_analysis
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|regset
name|tem
decl_stmt|;
name|regset_size
operator|=
operator|(
operator|(
name|max_regno
operator|+
name|REGSET_ELT_BITS
operator|-
literal|1
operator|)
operator|/
name|REGSET_ELT_BITS
operator|)
expr_stmt|;
name|regset_bytes
operator|=
name|regset_size
operator|*
sizeof|sizeof
argument_list|(
operator|*
operator|(
name|regset
operator|)
literal|0
argument_list|)
expr_stmt|;
name|reg_n_refs
operator|=
operator|(
name|int
operator|*
operator|)
name|oballoc
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reg_n_refs
argument_list|,
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|reg_n_sets
operator|=
operator|(
name|short
operator|*
operator|)
name|oballoc
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reg_n_sets
argument_list|,
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|reg_n_deaths
operator|=
operator|(
name|short
operator|*
operator|)
name|oballoc
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reg_n_deaths
argument_list|,
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|reg_changes_size
operator|=
operator|(
name|char
operator|*
operator|)
name|oballoc
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|reg_changes_size
argument_list|,
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
empty_stmt|;
name|reg_live_length
operator|=
operator|(
name|int
operator|*
operator|)
name|oballoc
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reg_live_length
argument_list|,
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|reg_n_calls_crossed
operator|=
operator|(
name|int
operator|*
operator|)
name|oballoc
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reg_n_calls_crossed
argument_list|,
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|reg_basic_block
operator|=
operator|(
name|int
operator|*
operator|)
name|oballoc
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_regno
condition|;
name|i
operator|++
control|)
name|reg_basic_block
index|[
name|i
index|]
operator|=
name|REG_BLOCK_UNKNOWN
expr_stmt|;
name|basic_block_live_at_start
operator|=
operator|(
name|regset
operator|*
operator|)
name|oballoc
argument_list|(
name|n_basic_blocks
operator|*
sizeof|sizeof
argument_list|(
name|regset
argument_list|)
argument_list|)
expr_stmt|;
name|tem
operator|=
operator|(
name|regset
operator|)
name|oballoc
argument_list|(
name|n_basic_blocks
operator|*
name|regset_bytes
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tem
argument_list|,
name|n_basic_blocks
operator|*
name|regset_bytes
argument_list|)
expr_stmt|;
name|init_regset_vector
argument_list|(
name|basic_block_live_at_start
argument_list|,
name|tem
argument_list|,
name|n_basic_blocks
argument_list|,
name|regset_bytes
argument_list|)
expr_stmt|;
name|regs_live_at_setjmp
operator|=
operator|(
name|regset
operator|)
name|oballoc
argument_list|(
name|regset_bytes
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|regs_live_at_setjmp
argument_list|,
name|regset_bytes
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make each element of VECTOR point at a regset,    taking the space for all those regsets from SPACE.    SPACE is of type regset, but it is really as long as NELTS regsets.    BYTES_PER_ELT is the number of bytes in one regset.  */
end_comment

begin_function
specifier|static
name|void
name|init_regset_vector
parameter_list|(
name|vector
parameter_list|,
name|space
parameter_list|,
name|nelts
parameter_list|,
name|bytes_per_elt
parameter_list|)
name|regset
modifier|*
name|vector
decl_stmt|;
name|regset
name|space
decl_stmt|;
name|int
name|nelts
decl_stmt|;
name|int
name|bytes_per_elt
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|regset
name|p
init|=
name|space
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|vector
index|[
name|i
index|]
operator|=
name|p
expr_stmt|;
name|p
operator|+=
name|bytes_per_elt
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Compute the registers live at the beginning of a basic block    from those live at the end.     When called, OLD contains those live at the end.    On return, it contains those live at the beginning.    FIRST and LAST are the first and last insns of the basic block.     FINAL is nonzero if we are doing the final pass which is not    for computing the life info (since that has already been done)    but for acting on it.  On this pass, we delete dead stores,    set up the logical links and dead-variables lists of instructions,    and merge instructions for autoincrement and autodecrement addresses.     SIGNIFICANT is nonzero only the first time for each basic block.    If it is nonzero, it points to a regset in which we store    a 1 for each register that is set within the block.     BNUM is the number of the basic block.  */
end_comment

begin_function
specifier|static
name|void
name|propagate_block
parameter_list|(
name|old
parameter_list|,
name|first
parameter_list|,
name|last
parameter_list|,
name|final
parameter_list|,
name|significant
parameter_list|,
name|bnum
parameter_list|)
specifier|register
name|regset
name|old
decl_stmt|;
name|rtx
name|first
decl_stmt|;
name|rtx
name|last
decl_stmt|;
name|int
name|final
decl_stmt|;
name|regset
name|significant
decl_stmt|;
name|int
name|bnum
decl_stmt|;
block|{
specifier|register
name|rtx
name|insn
decl_stmt|;
name|rtx
name|prev
decl_stmt|;
name|regset
name|live
decl_stmt|;
name|regset
name|dead
decl_stmt|;
comment|/* The following variables are used only if FINAL is nonzero.  */
comment|/* This vector gets one element for each reg that has been live      at any point in the basic block that has been scanned so far.      SOMETIMES_MAX says how many elements are in use so far.      In each element, OFFSET is the byte-number within a regset      for the register described by the element, and BIT is a mask      for that register's bit within the byte.  */
specifier|register
struct|struct
name|sometimes
block|{
name|short
name|offset
decl_stmt|;
name|short
name|bit
decl_stmt|;
block|}
modifier|*
name|regs_sometimes_live
struct|;
name|int
name|sometimes_max
init|=
literal|0
decl_stmt|;
comment|/* This regset has 1 for each reg that we have seen live so far.      It and REGS_SOMETIMES_LIVE are updated together.  */
name|regset
name|maxlive
decl_stmt|;
comment|/* The loop depth may change in the middle of a basic block.  Since we      scan from end to beginning, we start with the depth at the end of the      current basic block, and adjust as we pass ends and starts of loops.  */
name|loop_depth
operator|=
name|basic_block_loop_depth
index|[
name|bnum
index|]
expr_stmt|;
name|dead
operator|=
operator|(
name|regset
operator|)
name|alloca
argument_list|(
name|regset_bytes
argument_list|)
expr_stmt|;
name|live
operator|=
operator|(
name|regset
operator|)
name|alloca
argument_list|(
name|regset_bytes
argument_list|)
expr_stmt|;
name|cc0_live
operator|=
literal|0
expr_stmt|;
name|last_mem_set
operator|=
literal|0
expr_stmt|;
comment|/* Include any notes at the end of the block in the scan.      This is in case the block ends with a call to setjmp.  */
while|while
condition|(
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
argument_list|)
operator|==
name|NOTE
condition|)
block|{
comment|/* Look for loop boundaries, we are going forward here.  */
name|last
operator|=
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
expr_stmt|;
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|last
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
condition|)
name|loop_depth
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|last
argument_list|)
operator|==
name|NOTE_INSN_LOOP_END
condition|)
name|loop_depth
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|final
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|offset
decl_stmt|;
name|REGSET_ELT_TYPE
name|bit
decl_stmt|;
name|num_scratch
operator|=
literal|0
expr_stmt|;
name|maxlive
operator|=
operator|(
name|regset
operator|)
name|alloca
argument_list|(
name|regset_bytes
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|old
argument_list|,
operator|(
name|char
operator|*
operator|)
name|maxlive
argument_list|,
name|regset_bytes
argument_list|)
expr_stmt|;
name|regs_sometimes_live
operator|=
operator|(
expr|struct
name|sometimes
operator|*
operator|)
name|alloca
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sometimes
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Process the regs live at the end of the block. 	 Enter them in MAXLIVE and REGS_SOMETIMES_LIVE. 	 Also mark them as not local to any one basic block.  */
for|for
control|(
name|offset
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|offset
operator|<
name|regset_size
condition|;
name|offset
operator|++
control|)
for|for
control|(
name|bit
operator|=
literal|1
init|;
name|bit
condition|;
name|bit
operator|<<=
literal|1
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|max_regno
condition|)
break|break;
if|if
condition|(
name|old
index|[
name|offset
index|]
operator|&
name|bit
condition|)
block|{
name|reg_basic_block
index|[
name|i
index|]
operator|=
name|REG_BLOCK_GLOBAL
expr_stmt|;
name|regs_sometimes_live
index|[
name|sometimes_max
index|]
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
name|regs_sometimes_live
index|[
name|sometimes_max
index|]
operator|.
name|bit
operator|=
name|i
operator|%
name|REGSET_ELT_BITS
expr_stmt|;
name|sometimes_max
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/* Scan the block an insn at a time from end to beginning.  */
for|for
control|(
name|insn
operator|=
name|last
init|;
condition|;
name|insn
operator|=
name|prev
control|)
block|{
name|prev
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Look for loop boundaries, remembering that we are going backwards.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_END
condition|)
name|loop_depth
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
condition|)
name|loop_depth
operator|--
expr_stmt|;
comment|/* If we have LOOP_DEPTH == 0, there has been a bookkeeping error. 	 Abort now rather than setting register status incorrectly.  */
if|if
condition|(
name|loop_depth
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If this is a call to `setjmp' et al, 	 warn if any non-volatile datum is live.  */
if|if
condition|(
name|final
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_SETJMP
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|regset_size
condition|;
name|i
operator|++
control|)
name|regs_live_at_setjmp
index|[
name|i
index|]
operator||=
name|old
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* Update the life-status of regs for this insn. 	 First DEAD gets which regs are set in this insn 	 then LIVE gets which regs are used in this insn. 	 Then the regs live before the insn 	 are those live after, with DEAD regs turned off, 	 and then LIVE regs turned on.  */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|rtx
name|note
init|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
name|int
name|insn_is_dead
init|=
operator|(
name|insn_dead_p
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|old
argument_list|,
literal|0
argument_list|)
comment|/* Don't delete something that refers to volatile storage!  */
operator|&&
operator|!
name|INSN_VOLATILE
argument_list|(
name|insn
argument_list|)
operator|)
decl_stmt|;
name|int
name|libcall_is_dead
init|=
operator|(
name|insn_is_dead
operator|&&
name|note
operator|!=
literal|0
operator|&&
name|libcall_dead_p
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|old
argument_list|,
name|note
argument_list|,
name|insn
argument_list|)
operator|)
decl_stmt|;
comment|/* If an instruction consists of just dead store(s) on final pass, 	     "delete" it by turning it into a NOTE of type NOTE_INSN_DELETED. 	     We could really delete it with delete_insn, but that 	     can cause trouble for first or last insn in a basic block.  */
if|if
condition|(
name|final
operator|&&
name|insn_is_dead
condition|)
block|{
name|PUT_CODE
argument_list|(
name|insn
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* CC0 is now known to be dead.  Either this insn used it, 		 in which case it doesn't anymore, or clobbered it, 		 so the next insn can't use it.  */
name|cc0_live
operator|=
literal|0
expr_stmt|;
comment|/* If this insn is copying the return value from a library call, 		 delete the entire library call.  */
if|if
condition|(
name|libcall_is_dead
condition|)
block|{
name|rtx
name|first
init|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|p
init|=
name|insn
decl_stmt|;
while|while
condition|(
name|INSN_DELETED_P
argument_list|(
name|first
argument_list|)
condition|)
name|first
operator|=
name|NEXT_INSN
argument_list|(
name|first
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|first
condition|)
block|{
name|p
operator|=
name|PREV_INSN
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|PUT_CODE
argument_list|(
name|p
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|p
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|p
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
goto|goto
name|flushed
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|regset_size
condition|;
name|i
operator|++
control|)
block|{
name|dead
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Faster than bzero here */
name|live
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/* since regset_size is usually small */
block|}
comment|/* See if this is an increment or decrement that can be 	     merged into a following memory address.  */
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
block|{
specifier|register
name|rtx
name|x
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* Does this instruction increment or decrement a register?  */
if|if
condition|(
name|final
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MINUS
operator|)
operator|&&
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
comment|/* Ok, look for a following memory ref we can combine with. 		   If one is found, change the memory ref to a PRE_INC 		   or PRE_DEC, cancel this insn, and return 1. 		   Return 0 if nothing has been done.  */
operator|&&
name|try_pre_increment_1
argument_list|(
name|insn
argument_list|)
condition|)
goto|goto
name|flushed
goto|;
block|}
endif|#
directive|endif
comment|/* AUTO_INC_DEC */
comment|/* If this is not the final pass, and this insn is copying the 	     value of a library call and it's dead, don't scan the 	     insns that perform the library call, so that the call's 	     arguments are not marked live.  */
if|if
condition|(
name|libcall_is_dead
condition|)
block|{
comment|/* Mark the dest reg as `significant'.  */
name|mark_set_regs
argument_list|(
name|old
argument_list|,
name|dead
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|significant
argument_list|)
expr_stmt|;
name|insn
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|prev
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|stack_pointer_rtx
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|stack_pointer_rtx
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
comment|/* We have an insn to pop a constant amount off the stack. 	       (Such insns use PLUS regardless of the direction of the stack, 	       and any insn to adjust the stack by a constant is always a pop.) 	       These insns, if not dead stores, have no effect on life.  */
empty_stmt|;
else|else
block|{
comment|/* LIVE gets the regs used in INSN; 		 DEAD gets those set by it.  Dead insns don't make anything 		 live.  */
name|mark_set_regs
argument_list|(
name|old
argument_list|,
name|dead
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|final
condition|?
name|insn
else|:
name|NULL_RTX
argument_list|,
name|significant
argument_list|)
expr_stmt|;
comment|/* If an insn doesn't use CC0, it becomes dead since we 		 assume that every insn clobbers it.  So show it dead here; 		 mark_used_regs will set it live if it is referenced.  */
name|cc0_live
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|insn_is_dead
condition|)
name|mark_used_regs
argument_list|(
name|old
argument_list|,
name|live
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|final
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* Sometimes we may have inserted something before INSN (such as 		 a move) when we make an auto-inc.  So ensure we will scan 		 those insns.  */
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
name|prev
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|insn_is_dead
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|rtx
name|note
decl_stmt|;
for|for
control|(
name|note
operator|=
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|USE
condition|)
name|mark_used_regs
argument_list|(
name|old
argument_list|,
name|live
argument_list|,
name|SET_DEST
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|final
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* Each call clobbers all call-clobbered regs that are not 		     global.  Note that the function-value reg is a 		     call-clobbered reg, and mark_set_regs has already had 		     a chance to handle it.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|call_used_regs
index|[
name|i
index|]
operator|&&
operator|!
name|global_regs
index|[
name|i
index|]
condition|)
name|dead
index|[
name|i
operator|/
name|REGSET_ELT_BITS
index|]
operator||=
operator|(
operator|(
name|REGSET_ELT_TYPE
operator|)
literal|1
operator|<<
operator|(
name|i
operator|%
name|REGSET_ELT_BITS
operator|)
operator|)
expr_stmt|;
comment|/* The stack ptr is used (honorarily) by a CALL insn.  */
name|live
index|[
name|STACK_POINTER_REGNUM
operator|/
name|REGSET_ELT_BITS
index|]
operator||=
operator|(
operator|(
name|REGSET_ELT_TYPE
operator|)
literal|1
operator|<<
operator|(
name|STACK_POINTER_REGNUM
operator|%
name|REGSET_ELT_BITS
operator|)
operator|)
expr_stmt|;
comment|/* Calls may also reference any of the global registers, 		     so they are made live.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|global_regs
index|[
name|i
index|]
condition|)
name|mark_used_regs
argument_list|(
name|old
argument_list|,
name|live
argument_list|,
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|reg_raw_mode
index|[
name|i
index|]
argument_list|,
name|i
argument_list|)
argument_list|,
name|final
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* Calls also clobber memory.  */
name|last_mem_set
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Update OLD for the registers used or set.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|regset_size
condition|;
name|i
operator|++
control|)
block|{
name|old
index|[
name|i
index|]
operator|&=
operator|~
name|dead
index|[
name|i
index|]
expr_stmt|;
name|old
index|[
name|i
index|]
operator||=
name|live
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|&&
name|final
condition|)
block|{
comment|/* Any regs live at the time of a call instruction 		     must not go in a register clobbered by calls. 		     Find all regs now live and record this for them.  */
specifier|register
name|struct
name|sometimes
modifier|*
name|p
init|=
name|regs_sometimes_live
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sometimes_max
condition|;
name|i
operator|++
operator|,
name|p
operator|++
control|)
if|if
condition|(
name|old
index|[
name|p
operator|->
name|offset
index|]
operator|&
operator|(
operator|(
name|REGSET_ELT_TYPE
operator|)
literal|1
operator|<<
name|p
operator|->
name|bit
operator|)
condition|)
name|reg_n_calls_crossed
index|[
name|p
operator|->
name|offset
operator|*
name|REGSET_ELT_BITS
operator|+
name|p
operator|->
name|bit
index|]
operator|+=
literal|1
expr_stmt|;
block|}
block|}
comment|/* On final pass, add any additional sometimes-live regs 	     into MAXLIVE and REGS_SOMETIMES_LIVE. 	     Also update counts of how many insns each reg is live at.  */
if|if
condition|(
name|final
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|regset_size
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|REGSET_ELT_TYPE
name|diff
init|=
name|live
index|[
name|i
index|]
operator|&
operator|~
name|maxlive
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|diff
condition|)
block|{
specifier|register
name|int
name|regno
decl_stmt|;
name|maxlive
index|[
name|i
index|]
operator||=
name|diff
expr_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|diff
operator|&&
name|regno
operator|<
name|REGSET_ELT_BITS
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|diff
operator|&
operator|(
operator|(
name|REGSET_ELT_TYPE
operator|)
literal|1
operator|<<
name|regno
operator|)
condition|)
block|{
name|regs_sometimes_live
index|[
name|sometimes_max
index|]
operator|.
name|offset
operator|=
name|i
expr_stmt|;
name|regs_sometimes_live
index|[
name|sometimes_max
index|]
operator|.
name|bit
operator|=
name|regno
expr_stmt|;
name|diff
operator|&=
operator|~
operator|(
operator|(
name|REGSET_ELT_TYPE
operator|)
literal|1
operator|<<
name|regno
operator|)
expr_stmt|;
name|sometimes_max
operator|++
expr_stmt|;
block|}
block|}
block|}
block|{
specifier|register
name|struct
name|sometimes
modifier|*
name|p
init|=
name|regs_sometimes_live
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sometimes_max
condition|;
name|i
operator|++
operator|,
name|p
operator|++
control|)
block|{
if|if
condition|(
name|old
index|[
name|p
operator|->
name|offset
index|]
operator|&
operator|(
operator|(
name|REGSET_ELT_TYPE
operator|)
literal|1
operator|<<
name|p
operator|->
name|bit
operator|)
condition|)
name|reg_live_length
index|[
name|p
operator|->
name|offset
operator|*
name|REGSET_ELT_BITS
operator|+
name|p
operator|->
name|bit
index|]
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
name|flushed
label|:
empty_stmt|;
if|if
condition|(
name|insn
operator|==
name|first
condition|)
break|break;
block|}
if|if
condition|(
name|num_scratch
operator|>
name|max_scratch
condition|)
name|max_scratch
operator|=
name|num_scratch
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if X (the body of an insn, or part of it) is just dead stores    (SET expressions whose destinations are registers dead after the insn).    NEEDED is the regset that says which regs are alive after the insn.     Unless CALL_OK is non-zero, an insn is needed if it contains a CALL.  */
end_comment

begin_function
specifier|static
name|int
name|insn_dead_p
parameter_list|(
name|x
parameter_list|,
name|needed
parameter_list|,
name|call_ok
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|regset
name|needed
decl_stmt|;
name|int
name|call_ok
decl_stmt|;
block|{
specifier|register
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
comment|/* If setting something that's a reg or part of one,      see if that register's altered value will be live.  */
if|if
condition|(
name|code
operator|==
name|SET
condition|)
block|{
specifier|register
name|rtx
name|r
init|=
name|SET_DEST
argument_list|(
name|x
argument_list|)
decl_stmt|;
comment|/* A SET that is a subroutine call cannot be dead.  */
if|if
condition|(
operator|!
name|call_ok
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|CALL
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|HAVE_cc0
if|if
condition|(
name|GET_CODE
argument_list|(
name|r
argument_list|)
operator|==
name|CC0
condition|)
return|return
operator|!
name|cc0_live
return|;
endif|#
directive|endif
if|if
condition|(
name|GET_CODE
argument_list|(
name|r
argument_list|)
operator|==
name|MEM
operator|&&
name|last_mem_set
operator|&&
operator|!
name|MEM_VOLATILE_P
argument_list|(
name|r
argument_list|)
operator|&&
name|rtx_equal_p
argument_list|(
name|r
argument_list|,
name|last_mem_set
argument_list|)
condition|)
return|return
literal|1
return|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|r
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|r
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|r
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|r
argument_list|)
operator|==
name|SIGN_EXTRACT
condition|)
name|r
operator|=
name|SUBREG_REG
argument_list|(
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|r
argument_list|)
operator|==
name|REG
condition|)
block|{
specifier|register
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|r
argument_list|)
decl_stmt|;
specifier|register
name|int
name|offset
init|=
name|regno
operator|/
name|REGSET_ELT_BITS
decl_stmt|;
specifier|register
name|REGSET_ELT_TYPE
name|bit
init|=
operator|(
name|REGSET_ELT_TYPE
operator|)
literal|1
operator|<<
operator|(
name|regno
operator|%
name|REGSET_ELT_BITS
operator|)
decl_stmt|;
comment|/* Don't delete insns to set global regs.  */
if|if
condition|(
operator|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|global_regs
index|[
name|regno
index|]
operator|)
comment|/* Make sure insns to set frame pointer aren't deleted.  */
operator|||
name|regno
operator|==
name|FRAME_POINTER_REGNUM
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|HARD_FRAME_POINTER_REGNUM
operator|||
name|regno
operator|==
name|HARD_FRAME_POINTER_REGNUM
endif|#
directive|endif
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|ARG_POINTER_REGNUM
comment|/* Make sure insns to set arg pointer are never deleted 		 (if the arg pointer isn't fixed, there will be a USE for 		 it, so we can treat it normally). */
operator|||
operator|(
name|regno
operator|==
name|ARG_POINTER_REGNUM
operator|&&
name|fixed_regs
index|[
name|regno
index|]
operator|)
endif|#
directive|endif
operator|||
operator|(
name|needed
index|[
name|offset
index|]
operator|&
name|bit
operator|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* If this is a hard register, verify that subsequent words are 	     not needed.  */
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|int
name|n
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|r
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
operator|--
name|n
operator|>
literal|0
condition|)
if|if
condition|(
operator|(
name|needed
index|[
operator|(
name|regno
operator|+
name|n
operator|)
operator|/
name|REGSET_ELT_BITS
index|]
operator|&
operator|(
operator|(
name|REGSET_ELT_TYPE
operator|)
literal|1
operator|<<
operator|(
operator|(
name|regno
operator|+
name|n
operator|)
operator|%
name|REGSET_ELT_BITS
operator|)
operator|)
operator|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
block|}
comment|/* If performing several activities,      insn is dead if each activity is individually dead.      Also, CLOBBERs and USEs can be ignored; a CLOBBER or USE      that's inside a PARALLEL doesn't make the insn worth keeping.  */
elseif|else
if|if
condition|(
name|code
operator|==
name|PARALLEL
condition|)
block|{
specifier|register
name|int
name|i
init|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|--
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|rtx
name|elt
init|=
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|insn_dead_p
argument_list|(
name|elt
argument_list|,
name|needed
argument_list|,
name|call_ok
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|elt
argument_list|)
operator|!=
name|CLOBBER
operator|&&
name|GET_CODE
argument_list|(
name|elt
argument_list|)
operator|!=
name|USE
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
comment|/* We do not check CLOBBER or USE here.      An insn consisting of just a CLOBBER or just a USE      should not be deleted.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* If X is the pattern of the last insn in a libcall, and assuming X is dead,    return 1 if the entire library call is dead.    This is true if X copies a register (hard or pseudo)    and if the hard return  reg of the call insn is dead.    (The caller should have tested the destination of X already for death.)     If this insn doesn't just copy a register, then we don't    have an ordinary libcall.  In that case, cse could not have    managed to substitute the source for the dest later on,    so we can assume the libcall is dead.     NEEDED is the bit vector of pseudoregs live before this insn.    NOTE is the REG_RETVAL note of the insn.  INSN is the insn itself.  */
end_comment

begin_function
specifier|static
name|int
name|libcall_dead_p
parameter_list|(
name|x
parameter_list|,
name|needed
parameter_list|,
name|note
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|regset
name|needed
decl_stmt|;
name|rtx
name|note
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
specifier|register
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|SET
condition|)
block|{
specifier|register
name|rtx
name|r
init|=
name|SET_SRC
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|r
argument_list|)
operator|==
name|REG
condition|)
block|{
name|rtx
name|call
init|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Find the call insn.  */
while|while
condition|(
name|call
operator|!=
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|call
argument_list|)
operator|!=
name|CALL_INSN
condition|)
name|call
operator|=
name|NEXT_INSN
argument_list|(
name|call
argument_list|)
expr_stmt|;
comment|/* If there is none, do nothing special, 	     since ordinary death handling can understand these insns.  */
if|if
condition|(
name|call
operator|==
name|insn
condition|)
return|return
literal|0
return|;
comment|/* See if the hard reg holding the value is dead. 	     If this is a PARALLEL, find the call within it.  */
name|call
operator|=
name|PATTERN
argument_list|(
name|call
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|call
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|call
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|call
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|call
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
operator|==
name|CALL
condition|)
break|break;
comment|/* This may be a library call that is returning a value 		 via invisible pointer.  Do nothing special, since 		 ordinary death handling can understand these insns.  */
if|if
condition|(
name|i
operator|<
literal|0
condition|)
return|return
literal|0
return|;
name|call
operator|=
name|XVECEXP
argument_list|(
name|call
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
return|return
name|insn_dead_p
argument_list|(
name|call
argument_list|,
name|needed
argument_list|,
literal|1
argument_list|)
return|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if register REGNO was used before it was set.    In other words, if it is live at function entry.    Don't count global regster variables, though.  */
end_comment

begin_function
name|int
name|regno_uninitialized
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
if|if
condition|(
name|n_basic_blocks
operator|==
literal|0
operator|||
operator|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|global_regs
index|[
name|regno
index|]
operator|)
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|basic_block_live_at_start
index|[
literal|0
index|]
index|[
name|regno
operator|/
name|REGSET_ELT_BITS
index|]
operator|&
operator|(
operator|(
name|REGSET_ELT_TYPE
operator|)
literal|1
operator|<<
operator|(
name|regno
operator|%
name|REGSET_ELT_BITS
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* 1 if register REGNO was alive at a place where `setjmp' was called    and was set more than once or is an argument.    Such regs may be clobbered by `longjmp'.  */
end_comment

begin_function
name|int
name|regno_clobbered_at_setjmp
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
if|if
condition|(
name|n_basic_blocks
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
operator|(
operator|(
name|reg_n_sets
index|[
name|regno
index|]
operator|>
literal|1
operator|||
operator|(
name|basic_block_live_at_start
index|[
literal|0
index|]
index|[
name|regno
operator|/
name|REGSET_ELT_BITS
index|]
operator|&
operator|(
operator|(
name|REGSET_ELT_TYPE
operator|)
literal|1
operator|<<
operator|(
name|regno
operator|%
name|REGSET_ELT_BITS
operator|)
operator|)
operator|)
operator|)
operator|&&
operator|(
name|regs_live_at_setjmp
index|[
name|regno
operator|/
name|REGSET_ELT_BITS
index|]
operator|&
operator|(
operator|(
name|REGSET_ELT_TYPE
operator|)
literal|1
operator|<<
operator|(
name|regno
operator|%
name|REGSET_ELT_BITS
operator|)
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Process the registers that are set within X.    Their bits are set to 1 in the regset DEAD,    because they are dead prior to this insn.     If INSN is nonzero, it is the insn being processed    and the fact that it is nonzero implies this is the FINAL pass    in propagate_block.  In this case, various info about register    usage is stored, LOG_LINKS fields of insns are set up.  */
end_comment

begin_function
specifier|static
name|void
name|mark_set_regs
parameter_list|(
name|needed
parameter_list|,
name|dead
parameter_list|,
name|x
parameter_list|,
name|insn
parameter_list|,
name|significant
parameter_list|)
name|regset
name|needed
decl_stmt|;
name|regset
name|dead
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|regset
name|significant
decl_stmt|;
block|{
specifier|register
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|SET
operator|||
name|code
operator|==
name|CLOBBER
condition|)
name|mark_set_1
argument_list|(
name|needed
argument_list|,
name|dead
argument_list|,
name|x
argument_list|,
name|insn
argument_list|,
name|significant
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|PARALLEL
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|code
operator|=
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|SET
operator|||
name|code
operator|==
name|CLOBBER
condition|)
name|mark_set_1
argument_list|(
name|needed
argument_list|,
name|dead
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|,
name|significant
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Process a single SET rtx, X.  */
end_comment

begin_function
specifier|static
name|void
name|mark_set_1
parameter_list|(
name|needed
parameter_list|,
name|dead
parameter_list|,
name|x
parameter_list|,
name|insn
parameter_list|,
name|significant
parameter_list|)
name|regset
name|needed
decl_stmt|;
name|regset
name|dead
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|regset
name|significant
decl_stmt|;
block|{
specifier|register
name|int
name|regno
decl_stmt|;
specifier|register
name|rtx
name|reg
init|=
name|SET_DEST
argument_list|(
name|x
argument_list|)
decl_stmt|;
comment|/* Modifying just one hardware register of a multi-reg value      or just a byte field of a register      does not mean the value from before this insn is now dead.      But it does mean liveness of that register at the end of the block      is significant.       Within mark_set_1, however, we treat it as if the register is      indeed modified.  mark_used_regs will, however, also treat this      register as being used.  Thus, we treat these insns as setting a      new value for the register as a function of its old value.  This      cases LOG_LINKS to be made appropriately and this will help combine.  */
while|while
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|reg
operator|=
name|XEXP
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If we are writing into memory or into a register mentioned in the      address of the last thing stored into memory, show we don't know      what the last store was.  If we are writing memory, save the address      unless it is volatile.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|MEM
operator|||
operator|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|REG
operator|&&
name|last_mem_set
operator|!=
literal|0
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|reg
argument_list|,
name|last_mem_set
argument_list|)
operator|)
condition|)
name|last_mem_set
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|reg
argument_list|)
comment|/* There are no REG_INC notes for SP, so we can't assume we'll see 	 everything that invalidates it.  To be safe, don't eliminate any 	 stores though SP; none of them should be redundant anyway.  */
operator|&&
operator|!
name|reg_mentioned_p
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|reg
argument_list|)
condition|)
name|last_mem_set
operator|=
name|reg
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|regno
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|,
name|regno
operator|!=
name|FRAME_POINTER_REGNUM
operator|)
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|HARD_FRAME_POINTER_REGNUM
operator|&&
name|regno
operator|!=
name|HARD_FRAME_POINTER_REGNUM
endif|#
directive|endif
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|ARG_POINTER_REGNUM
operator|&&
operator|!
operator|(
name|regno
operator|==
name|ARG_POINTER_REGNUM
operator|&&
name|fixed_regs
index|[
name|regno
index|]
operator|)
endif|#
directive|endif
operator|&&
operator|!
operator|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|global_regs
index|[
name|regno
index|]
operator|)
condition|)
comment|/*&& regno != STACK_POINTER_REGNUM) -- let's try without this.  */
block|{
specifier|register
name|int
name|offset
init|=
name|regno
operator|/
name|REGSET_ELT_BITS
decl_stmt|;
specifier|register
name|REGSET_ELT_TYPE
name|bit
init|=
operator|(
name|REGSET_ELT_TYPE
operator|)
literal|1
operator|<<
operator|(
name|regno
operator|%
name|REGSET_ELT_BITS
operator|)
decl_stmt|;
name|REGSET_ELT_TYPE
name|all_needed
init|=
operator|(
name|needed
index|[
name|offset
index|]
operator|&
name|bit
operator|)
decl_stmt|;
name|REGSET_ELT_TYPE
name|some_needed
init|=
operator|(
name|needed
index|[
name|offset
index|]
operator|&
name|bit
operator|)
decl_stmt|;
comment|/* Mark it as a significant register for this basic block.  */
if|if
condition|(
name|significant
condition|)
name|significant
index|[
name|offset
index|]
operator||=
name|bit
expr_stmt|;
comment|/* Mark it as as dead before this insn.  */
name|dead
index|[
name|offset
index|]
operator||=
name|bit
expr_stmt|;
comment|/* A hard reg in a wide mode may really be multiple registers. 	 If so, mark all of them just like the first.  */
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|int
name|n
decl_stmt|;
comment|/* Nothing below is needed for the stack pointer; get out asap. 	     Eg, log links aren't needed, since combine won't use them.  */
if|if
condition|(
name|regno
operator|==
name|STACK_POINTER_REGNUM
condition|)
return|return;
name|n
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|n
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|significant
condition|)
name|significant
index|[
operator|(
name|regno
operator|+
name|n
operator|)
operator|/
name|REGSET_ELT_BITS
index|]
operator||=
operator|(
name|REGSET_ELT_TYPE
operator|)
literal|1
operator|<<
operator|(
operator|(
name|regno
operator|+
name|n
operator|)
operator|%
name|REGSET_ELT_BITS
operator|)
expr_stmt|;
name|dead
index|[
operator|(
name|regno
operator|+
name|n
operator|)
operator|/
name|REGSET_ELT_BITS
index|]
operator||=
operator|(
name|REGSET_ELT_TYPE
operator|)
literal|1
operator|<<
operator|(
operator|(
name|regno
operator|+
name|n
operator|)
operator|%
name|REGSET_ELT_BITS
operator|)
expr_stmt|;
name|some_needed
operator||=
operator|(
name|needed
index|[
operator|(
name|regno
operator|+
name|n
operator|)
operator|/
name|REGSET_ELT_BITS
index|]
operator|&
operator|(
name|REGSET_ELT_TYPE
operator|)
literal|1
operator|<<
operator|(
operator|(
name|regno
operator|+
name|n
operator|)
operator|%
name|REGSET_ELT_BITS
operator|)
operator|)
expr_stmt|;
name|all_needed
operator|&=
operator|(
name|needed
index|[
operator|(
name|regno
operator|+
name|n
operator|)
operator|/
name|REGSET_ELT_BITS
index|]
operator|&
operator|(
name|REGSET_ELT_TYPE
operator|)
literal|1
operator|<<
operator|(
operator|(
name|regno
operator|+
name|n
operator|)
operator|%
name|REGSET_ELT_BITS
operator|)
operator|)
expr_stmt|;
block|}
block|}
comment|/* Additional data to record if this is the final pass.  */
if|if
condition|(
name|insn
condition|)
block|{
specifier|register
name|rtx
name|y
init|=
name|reg_next_use
index|[
name|regno
index|]
decl_stmt|;
specifier|register
name|int
name|blocknum
init|=
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* The next use is no longer "next", since a store intervenes.  */
name|reg_next_use
index|[
name|regno
index|]
operator|=
literal|0
expr_stmt|;
comment|/* If this is a hard reg, record this function uses the reg.  */
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|endregno
init|=
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
name|regno
init|;
name|i
operator|<
name|endregno
condition|;
name|i
operator|++
control|)
block|{
name|regs_ever_live
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|reg_n_sets
index|[
name|i
index|]
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Keep track of which basic blocks each reg appears in.  */
if|if
condition|(
name|reg_basic_block
index|[
name|regno
index|]
operator|==
name|REG_BLOCK_UNKNOWN
condition|)
name|reg_basic_block
index|[
name|regno
index|]
operator|=
name|blocknum
expr_stmt|;
elseif|else
if|if
condition|(
name|reg_basic_block
index|[
name|regno
index|]
operator|!=
name|blocknum
condition|)
name|reg_basic_block
index|[
name|regno
index|]
operator|=
name|REG_BLOCK_GLOBAL
expr_stmt|;
comment|/* Count (weighted) references, stores, etc.  This counts a 		 register twice if it is modified, but that is correct.  */
name|reg_n_sets
index|[
name|regno
index|]
operator|++
expr_stmt|;
name|reg_n_refs
index|[
name|regno
index|]
operator|+=
name|loop_depth
expr_stmt|;
comment|/* The insns where a reg is live are normally counted 		 elsewhere, but we want the count to include the insn 		 where the reg is set, and the normal counting mechanism 		 would not count it.  */
name|reg_live_length
index|[
name|regno
index|]
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|all_needed
condition|)
block|{
comment|/* Make a logical link from the next following insn 		 that uses this register, back to this insn. 		 The following insns have already been processed.  		 We don't build a LOG_LINK for hard registers containing 		 in ASM_OPERANDs.  If these registers get replaced, 		 we might wind up changing the semantics of the insn, 		 even if reload can make what appear to be valid assignments 		 later.  */
if|if
condition|(
name|y
operator|&&
operator|(
name|BLOCK_NUM
argument_list|(
name|y
argument_list|)
operator|==
name|blocknum
operator|)
operator|&&
operator|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|y
argument_list|)
argument_list|)
operator|<
literal|0
operator|)
condition|)
name|LOG_LINKS
argument_list|(
name|y
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|INSN_LIST
argument_list|,
name|VOIDmode
argument_list|,
name|insn
argument_list|,
name|LOG_LINKS
argument_list|(
name|y
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|some_needed
condition|)
block|{
comment|/* Note that dead stores have already been deleted when possible 		 If we get here, we have found a dead store that cannot 		 be eliminated (because the same insn does something useful). 		 Indicate this by marking the reg being set as dying here.  */
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|REG_UNUSED
argument_list|,
name|reg
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|reg_n_deaths
index|[
name|REGNO
argument_list|(
name|reg
argument_list|)
index|]
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* This is a case where we have a multi-word hard register 		 and some, but not all, of the words of the register are 		 needed in subsequent insns.  Write REG_UNUSED notes 		 for those parts that were not needed.  This case should 		 be rare.  */
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
operator|(
name|needed
index|[
operator|(
name|regno
operator|+
name|i
operator|)
operator|/
name|REGSET_ELT_BITS
index|]
operator|&
operator|(
operator|(
name|REGSET_ELT_TYPE
operator|)
literal|1
operator|<<
operator|(
operator|(
name|regno
operator|+
name|i
operator|)
operator|%
name|REGSET_ELT_BITS
operator|)
operator|)
operator|)
operator|==
literal|0
condition|)
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|REG_UNUSED
argument_list|,
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|reg_raw_mode
index|[
name|regno
operator|+
name|i
index|]
argument_list|,
name|regno
operator|+
name|i
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|REG
condition|)
name|reg_next_use
index|[
name|regno
index|]
operator|=
literal|0
expr_stmt|;
comment|/* If this is the last pass and this is a SCRATCH, show it will be dying      here and count it.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SCRATCH
operator|&&
name|insn
operator|!=
literal|0
condition|)
block|{
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|REG_UNUSED
argument_list|,
name|reg
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|num_scratch
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
end_ifdef

begin_comment
comment|/* X is a MEM found in INSN.  See if we can convert it into an auto-increment    reference.  */
end_comment

begin_function
specifier|static
name|void
name|find_auto_inc
parameter_list|(
name|needed
parameter_list|,
name|x
parameter_list|,
name|insn
parameter_list|)
name|regset
name|needed
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|addr
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|offset
init|=
literal|0
decl_stmt|;
name|rtx
name|set
decl_stmt|;
comment|/* Here we detect use of an index register which might be good for      postincrement, postdecrement, preincrement, or predecrement.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
name|offset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|,
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|REG
condition|)
block|{
specifier|register
name|rtx
name|y
decl_stmt|;
specifier|register
name|int
name|size
init|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|use
decl_stmt|;
name|rtx
name|incr
decl_stmt|;
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|addr
argument_list|)
decl_stmt|;
comment|/* Is the next use an increment that might make auto-increment? */
if|if
condition|(
operator|(
name|incr
operator|=
name|reg_next_use
index|[
name|regno
index|]
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|incr
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|set
argument_list|)
operator|==
name|SET
operator|&&
name|BLOCK_NUM
argument_list|(
name|incr
argument_list|)
operator|==
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
comment|/* Can't add side effects to jumps; if reg is spilled and 	     reloaded, there's no way to store back the altered value.  */
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|JUMP_INSN
operator|&&
operator|(
name|y
operator|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
operator|,
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|PLUS
operator|)
operator|&&
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
operator|==
name|addr
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
literal|0
ifdef|#
directive|ifdef
name|HAVE_POST_INCREMENT
operator|||
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|size
operator|&&
name|offset
operator|==
literal|0
operator|)
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_POST_DECREMENT
operator|||
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
operator|-
name|size
operator|&&
name|offset
operator|==
literal|0
operator|)
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_PRE_INCREMENT
operator|||
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|size
operator|&&
name|offset
operator|==
name|size
operator|)
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_PRE_DECREMENT
operator|||
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
operator|-
name|size
operator|&&
name|offset
operator|==
operator|-
name|size
operator|)
endif|#
directive|endif
operator|)
comment|/* Make sure this reg appears only once in this insn.  */
operator|&&
operator|(
name|use
operator|=
name|find_use_as_address
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|addr
argument_list|,
name|offset
argument_list|)
operator|,
name|use
operator|!=
literal|0
operator|&&
name|use
operator|!=
operator|(
name|rtx
operator|)
literal|1
operator|)
condition|)
block|{
name|rtx
name|q
init|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
decl_stmt|;
name|enum
name|rtx_code
name|inc_code
init|=
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|size
condition|?
operator|(
name|offset
condition|?
name|PRE_INC
else|:
name|POST_INC
operator|)
else|:
operator|(
name|offset
condition|?
name|PRE_DEC
else|:
name|POST_DEC
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|dead_or_set_p
argument_list|(
name|incr
argument_list|,
name|addr
argument_list|)
condition|)
block|{
comment|/* This is the simple case.  Try to make the auto-inc.  If 		 we can't, we are done.  Otherwise, we will do any 		 needed updates below.  */
if|if
condition|(
operator|!
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|gen_rtx
argument_list|(
name|inc_code
argument_list|,
name|Pmode
argument_list|,
name|addr
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|q
argument_list|)
operator|==
name|REG
comment|/* PREV_INSN used here to check the semi-open interval 		      [insn,incr).  */
operator|&&
operator|!
name|reg_used_between_p
argument_list|(
name|q
argument_list|,
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|incr
argument_list|)
condition|)
block|{
comment|/* We have *p followed sometime later by q = p+size. 		 Both p and q must be live afterward, 		 and q is not used between INSN and it's assignment. 		 Change it to q = p, ...*q..., q = q+size. 		 Then fall into the usual case.  */
name|rtx
name|insns
decl_stmt|,
name|temp
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|emit_move_insn
argument_list|(
name|q
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
comment|/* If anything in INSNS have UID's that don't fit within the 		 extra space we allocate earlier, we can't make this auto-inc. 		 This should never happen.  */
for|for
control|(
name|temp
operator|=
name|insns
init|;
name|temp
condition|;
name|temp
operator|=
name|NEXT_INSN
argument_list|(
name|temp
argument_list|)
control|)
block|{
if|if
condition|(
name|INSN_UID
argument_list|(
name|temp
argument_list|)
operator|>
name|max_uid_for_flow
condition|)
return|return;
name|BLOCK_NUM
argument_list|(
name|temp
argument_list|)
operator|=
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* If we can't make the auto-inc, or can't make the 		 replacement into Y, exit.  There's no point in making 		 the change below if we can't do the auto-inc and doing 		 so is not correct in the pre-inc case.  */
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|gen_rtx
argument_list|(
name|inc_code
argument_list|,
name|Pmode
argument_list|,
name|q
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|validate_change
argument_list|(
name|incr
argument_list|,
operator|&
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|,
name|q
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|apply_change_group
argument_list|()
condition|)
return|return;
comment|/* We now know we'll be doing this change, so emit the 		 new insn(s) and do the updates.  */
name|emit_insns_before
argument_list|(
name|insns
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|basic_block_head
index|[
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
index|]
operator|==
name|insn
condition|)
name|basic_block_head
index|[
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
index|]
operator|=
name|insns
expr_stmt|;
comment|/* INCR will become a NOTE and INSN won't contain a 		 use of ADDR.  If a use of ADDR was just placed in 		 the insn before INSN, make that the next use. 		 Otherwise, invalidate it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|addr
condition|)
name|reg_next_use
index|[
name|regno
index|]
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
else|else
name|reg_next_use
index|[
name|regno
index|]
operator|=
literal|0
expr_stmt|;
name|addr
operator|=
name|q
expr_stmt|;
name|regno
operator|=
name|REGNO
argument_list|(
name|q
argument_list|)
expr_stmt|;
comment|/* REGNO is now used in INCR which is below INSN, but 		 it previously wasn't live here.  If we don't mark 		 it as needed, we'll put a REG_DEAD note for it 		 on this insn, which is incorrect.  */
name|needed
index|[
name|regno
operator|/
name|REGSET_ELT_BITS
index|]
operator||=
operator|(
name|REGSET_ELT_TYPE
operator|)
literal|1
operator|<<
operator|(
name|regno
operator|%
name|REGSET_ELT_BITS
operator|)
expr_stmt|;
comment|/* If there are any calls between INSN and INCR, show 		 that REGNO now crosses them.  */
for|for
control|(
name|temp
operator|=
name|insn
init|;
name|temp
operator|!=
name|incr
condition|;
name|temp
operator|=
name|NEXT_INSN
argument_list|(
name|temp
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|CALL_INSN
condition|)
name|reg_n_calls_crossed
index|[
name|regno
index|]
operator|++
expr_stmt|;
block|}
else|else
return|return;
comment|/* If we haven't returned, it means we were able to make the 	     auto-inc, so update the status.  First, record that this insn 	     has an implicit side effect.  */
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|REG_INC
argument_list|,
name|addr
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Modify the old increment-insn to simply copy 	     the already-incremented value of our register.  */
if|if
condition|(
operator|!
name|validate_change
argument_list|(
name|incr
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If that makes it a no-op (copying the register into itself) delete 	     it so it won't appear to be a "use" and a "set" of this 	     register.  */
if|if
condition|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|==
name|addr
condition|)
block|{
name|PUT_CODE
argument_list|(
name|incr
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|incr
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|incr
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
comment|/* Count an extra reference to the reg.  When a reg is 		 incremented, spilling it is worse, so we want to make 		 that less likely.  */
name|reg_n_refs
index|[
name|regno
index|]
operator|+=
name|loop_depth
expr_stmt|;
comment|/* Count the increment as a setting of the register, 		 even though it isn't a SET in rtl.  */
name|reg_n_sets
index|[
name|regno
index|]
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AUTO_INC_DEC */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Scan expression X and store a 1-bit in LIVE for each reg it uses.    This is done assuming the registers needed from X    are those that have 1-bits in NEEDED.     On the final pass, FINAL is 1.  This means try for autoincrement    and count the uses and deaths of each pseudo-reg.     INSN is the containing instruction.  If INSN is dead, this function is not    called.  */
end_comment

begin_function
specifier|static
name|void
name|mark_used_regs
parameter_list|(
name|needed
parameter_list|,
name|live
parameter_list|,
name|x
parameter_list|,
name|final
parameter_list|,
name|insn
parameter_list|)
name|regset
name|needed
decl_stmt|;
name|regset
name|live
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|int
name|final
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
specifier|register
name|RTX_CODE
name|code
decl_stmt|;
specifier|register
name|int
name|regno
decl_stmt|;
name|int
name|i
decl_stmt|;
name|retry
label|:
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LABEL_REF
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|PC
case|:
case|case
name|ADDR_VEC
case|:
case|case
name|ADDR_DIFF_VEC
case|:
case|case
name|ASM_INPUT
case|:
return|return;
ifdef|#
directive|ifdef
name|HAVE_cc0
case|case
name|CC0
case|:
name|cc0_live
operator|=
literal|1
expr_stmt|;
return|return;
endif|#
directive|endif
case|case
name|CLOBBER
case|:
comment|/* If we are clobbering a MEM, mark any registers inside the address 	 as being used.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
name|mark_used_regs
argument_list|(
name|needed
argument_list|,
name|live
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|final
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return;
case|case
name|MEM
case|:
comment|/* Invalidate the data for the last MEM stored.  We could do this only 	 if the addresses conflict, but this doesn't seem worthwhile.  */
name|last_mem_set
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
if|if
condition|(
name|final
condition|)
name|find_auto_inc
argument_list|(
name|needed
argument_list|,
name|x
argument_list|,
name|insn
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|SUBREG
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|INTEGRAL_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|||
name|INTEGRAL_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
name|reg_changes_size
index|[
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
index|]
operator|=
literal|1
expr_stmt|;
comment|/* While we're here, optimize this case.  */
name|x
operator|=
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* ... fall through ... */
case|case
name|REG
case|:
comment|/* See a register other than being set 	 => mark it as needed.  */
name|regno
operator|=
name|REGNO
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|{
specifier|register
name|int
name|offset
init|=
name|regno
operator|/
name|REGSET_ELT_BITS
decl_stmt|;
specifier|register
name|REGSET_ELT_TYPE
name|bit
init|=
operator|(
name|REGSET_ELT_TYPE
operator|)
literal|1
operator|<<
operator|(
name|regno
operator|%
name|REGSET_ELT_BITS
operator|)
decl_stmt|;
name|REGSET_ELT_TYPE
name|all_needed
init|=
name|needed
index|[
name|offset
index|]
operator|&
name|bit
decl_stmt|;
name|REGSET_ELT_TYPE
name|some_needed
init|=
name|needed
index|[
name|offset
index|]
operator|&
name|bit
decl_stmt|;
name|live
index|[
name|offset
index|]
operator||=
name|bit
expr_stmt|;
comment|/* A hard reg in a wide mode may really be multiple registers. 	   If so, mark all of them just like the first.  */
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|int
name|n
decl_stmt|;
comment|/* For stack ptr or fixed arg pointer, 	       nothing below can be necessary, so waste no more time.  */
if|if
condition|(
name|regno
operator|==
name|STACK_POINTER_REGNUM
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|HARD_FRAME_POINTER_REGNUM
operator|||
name|regno
operator|==
name|HARD_FRAME_POINTER_REGNUM
endif|#
directive|endif
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|ARG_POINTER_REGNUM
operator|||
operator|(
name|regno
operator|==
name|ARG_POINTER_REGNUM
operator|&&
name|fixed_regs
index|[
name|regno
index|]
operator|)
endif|#
directive|endif
operator|||
name|regno
operator|==
name|FRAME_POINTER_REGNUM
condition|)
block|{
comment|/* If this is a register we are going to try to eliminate, 		   don't mark it live here.  If we are successful in 		   eliminating it, it need not be live unless it is used for 		   pseudos, in which case it will have been set live when 		   it was allocated to the pseudos.  If the register will not 		   be eliminated, reload will set it live at that point.  */
if|if
condition|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|elim_reg_set
argument_list|,
name|regno
argument_list|)
condition|)
name|regs_ever_live
index|[
name|regno
index|]
operator|=
literal|1
expr_stmt|;
return|return;
block|}
comment|/* No death notes for global register variables; 	       their values are live after this function exits.  */
if|if
condition|(
name|global_regs
index|[
name|regno
index|]
condition|)
block|{
if|if
condition|(
name|final
condition|)
name|reg_next_use
index|[
name|regno
index|]
operator|=
name|insn
expr_stmt|;
return|return;
block|}
name|n
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|n
operator|>
literal|0
condition|)
block|{
name|live
index|[
operator|(
name|regno
operator|+
name|n
operator|)
operator|/
name|REGSET_ELT_BITS
index|]
operator||=
operator|(
name|REGSET_ELT_TYPE
operator|)
literal|1
operator|<<
operator|(
operator|(
name|regno
operator|+
name|n
operator|)
operator|%
name|REGSET_ELT_BITS
operator|)
expr_stmt|;
name|some_needed
operator||=
operator|(
name|needed
index|[
operator|(
name|regno
operator|+
name|n
operator|)
operator|/
name|REGSET_ELT_BITS
index|]
operator|&
operator|(
name|REGSET_ELT_TYPE
operator|)
literal|1
operator|<<
operator|(
operator|(
name|regno
operator|+
name|n
operator|)
operator|%
name|REGSET_ELT_BITS
operator|)
operator|)
expr_stmt|;
name|all_needed
operator|&=
operator|(
name|needed
index|[
operator|(
name|regno
operator|+
name|n
operator|)
operator|/
name|REGSET_ELT_BITS
index|]
operator|&
operator|(
name|REGSET_ELT_TYPE
operator|)
literal|1
operator|<<
operator|(
operator|(
name|regno
operator|+
name|n
operator|)
operator|%
name|REGSET_ELT_BITS
operator|)
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|final
condition|)
block|{
comment|/* Record where each reg is used, so when the reg 	       is set we know the next insn that uses it.  */
name|reg_next_use
index|[
name|regno
index|]
operator|=
name|insn
expr_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
comment|/* If a hard reg is being used, 		   record that this function does use it.  */
name|i
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|i
operator|=
literal|1
expr_stmt|;
do|do
name|regs_ever_live
index|[
name|regno
operator|+
operator|--
name|i
index|]
operator|=
literal|1
expr_stmt|;
do|while
condition|(
name|i
operator|>
literal|0
condition|)
do|;
block|}
else|else
block|{
comment|/* Keep track of which basic block each reg appears in.  */
specifier|register
name|int
name|blocknum
init|=
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|reg_basic_block
index|[
name|regno
index|]
operator|==
name|REG_BLOCK_UNKNOWN
condition|)
name|reg_basic_block
index|[
name|regno
index|]
operator|=
name|blocknum
expr_stmt|;
elseif|else
if|if
condition|(
name|reg_basic_block
index|[
name|regno
index|]
operator|!=
name|blocknum
condition|)
name|reg_basic_block
index|[
name|regno
index|]
operator|=
name|REG_BLOCK_GLOBAL
expr_stmt|;
comment|/* Count (weighted) number of uses of each reg.  */
name|reg_n_refs
index|[
name|regno
index|]
operator|+=
name|loop_depth
expr_stmt|;
block|}
comment|/* Record and count the insns in which a reg dies. 	       If it is used in this insn and was dead below the insn 	       then it dies in this insn.  If it was set in this insn, 	       we do not make a REG_DEAD note; likewise if we already 	       made such a note.  */
if|if
condition|(
operator|!
name|all_needed
operator|&&
operator|!
name|dead_or_set_p
argument_list|(
name|insn
argument_list|,
name|x
argument_list|)
if|#
directive|if
literal|0
condition|&& (regno>= FIRST_PSEUDO_REGISTER || ! fixed_regs[regno])
endif|#
directive|endif
condition|)
block|{
comment|/* Check for the case where the register dying partially 		   overlaps the register set by this insn.  */
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|>
literal|1
condition|)
block|{
name|int
name|n
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
name|some_needed
operator||=
name|dead_or_set_regno_p
argument_list|(
name|insn
argument_list|,
name|regno
operator|+
name|n
argument_list|)
expr_stmt|;
block|}
comment|/* If none of the words in X is needed, make a REG_DEAD 		   note.  Otherwise, we must make partial REG_DEAD notes.  */
if|if
condition|(
operator|!
name|some_needed
condition|)
block|{
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|REG_DEAD
argument_list|,
name|x
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|reg_n_deaths
index|[
name|regno
index|]
operator|++
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
comment|/* Don't make a REG_DEAD note for a part of a register 		       that is set in the insn.  */
for|for
control|(
name|i
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
operator|(
name|needed
index|[
operator|(
name|regno
operator|+
name|i
operator|)
operator|/
name|REGSET_ELT_BITS
index|]
operator|&
operator|(
operator|(
name|REGSET_ELT_TYPE
operator|)
literal|1
operator|<<
operator|(
operator|(
name|regno
operator|+
name|i
operator|)
operator|%
name|REGSET_ELT_BITS
operator|)
operator|)
operator|)
operator|==
literal|0
operator|&&
operator|!
name|dead_or_set_regno_p
argument_list|(
name|insn
argument_list|,
name|regno
operator|+
name|i
argument_list|)
condition|)
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|REG_DEAD
argument_list|,
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|reg_raw_mode
index|[
name|regno
operator|+
name|i
index|]
argument_list|,
name|regno
operator|+
name|i
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return;
case|case
name|SET
case|:
block|{
specifier|register
name|rtx
name|testreg
init|=
name|SET_DEST
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|int
name|mark_dest
init|=
literal|0
decl_stmt|;
comment|/* If storing into MEM, don't show it as being used.  But do 	   show the address as being used.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|testreg
argument_list|)
operator|==
name|MEM
condition|)
block|{
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
if|if
condition|(
name|final
condition|)
name|find_auto_inc
argument_list|(
name|needed
argument_list|,
name|testreg
argument_list|,
name|insn
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mark_used_regs
argument_list|(
name|needed
argument_list|,
name|live
argument_list|,
name|XEXP
argument_list|(
name|testreg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|final
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|mark_used_regs
argument_list|(
name|needed
argument_list|,
name|live
argument_list|,
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|final
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Storing in STRICT_LOW_PART is like storing in a reg 	   in that this SET might be dead, so ignore it in TESTREG. 	   but in some other ways it is like using the reg.  	   Storing in a SUBREG or a bit field is like storing the entire 	   register in that if the register's value is not used 	   then this SET is not needed.  */
while|while
condition|(
name|GET_CODE
argument_list|(
name|testreg
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|testreg
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|testreg
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|testreg
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
comment|/* Modifying a single register in an alternate mode 	       does not use any of the old value.  But these other 	       ways of storing in a register do use the old value.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|testreg
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|!
operator|(
name|REG_SIZE
argument_list|(
name|SUBREG_REG
argument_list|(
name|testreg
argument_list|)
argument_list|)
operator|>
name|REG_SIZE
argument_list|(
name|testreg
argument_list|)
operator|)
condition|)
empty_stmt|;
else|else
name|mark_dest
operator|=
literal|1
expr_stmt|;
name|testreg
operator|=
name|XEXP
argument_list|(
name|testreg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* If this is a store into a register, 	   recursively scan the value being stored.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|testreg
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|regno
operator|=
name|REGNO
argument_list|(
name|testreg
argument_list|)
operator|,
name|regno
operator|!=
name|FRAME_POINTER_REGNUM
operator|)
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|HARD_FRAME_POINTER_REGNUM
operator|&&
name|regno
operator|!=
name|HARD_FRAME_POINTER_REGNUM
endif|#
directive|endif
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|ARG_POINTER_REGNUM
operator|&&
operator|!
operator|(
name|regno
operator|==
name|ARG_POINTER_REGNUM
operator|&&
name|fixed_regs
index|[
name|regno
index|]
operator|)
endif|#
directive|endif
condition|)
comment|/* We used to exclude global_regs here, but that seems wrong. 	     Storing in them is like storing in mem.  */
block|{
name|mark_used_regs
argument_list|(
name|needed
argument_list|,
name|live
argument_list|,
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|final
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|mark_dest
condition|)
name|mark_used_regs
argument_list|(
name|needed
argument_list|,
name|live
argument_list|,
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|final
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
break|break;
case|case
name|RETURN
case|:
comment|/* If exiting needs the right stack value, consider this insn as 	 using the stack pointer.  In any event, consider it as using 	 all global registers.  */
ifdef|#
directive|ifdef
name|EXIT_IGNORE_STACK
if|if
condition|(
operator|!
name|EXIT_IGNORE_STACK
operator|||
operator|(
operator|!
name|FRAME_POINTER_REQUIRED
operator|&&
name|flag_omit_frame_pointer
operator|)
condition|)
endif|#
directive|endif
name|live
index|[
name|STACK_POINTER_REGNUM
operator|/
name|REGSET_ELT_BITS
index|]
operator||=
operator|(
name|REGSET_ELT_TYPE
operator|)
literal|1
operator|<<
operator|(
name|STACK_POINTER_REGNUM
operator|%
name|REGSET_ELT_BITS
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|global_regs
index|[
name|i
index|]
condition|)
name|live
index|[
name|i
operator|/
name|REGSET_ELT_BITS
index|]
operator||=
operator|(
name|REGSET_ELT_TYPE
operator|)
literal|1
operator|<<
operator|(
name|i
operator|%
name|REGSET_ELT_BITS
operator|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* Recursively scan the operands of this expression.  */
block|{
specifier|register
name|char
modifier|*
name|fmt
init|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
comment|/* Tail recursive case: save a function call level.  */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|mark_used_regs
argument_list|(
name|needed
argument_list|,
name|live
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|final
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|mark_used_regs
argument_list|(
name|needed
argument_list|,
name|live
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|final
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
end_ifdef

begin_function
specifier|static
name|int
name|try_pre_increment_1
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
comment|/* Find the next use of this reg.  If in same basic block,      make it do pre-increment or pre-decrement if appropriate.  */
name|rtx
name|x
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|amount
init|=
operator|(
operator|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|?
literal|1
else|:
operator|-
literal|1
operator|)
operator|*
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
decl_stmt|;
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|y
init|=
name|reg_next_use
index|[
name|regno
index|]
decl_stmt|;
if|if
condition|(
name|y
operator|!=
literal|0
operator|&&
name|BLOCK_NUM
argument_list|(
name|y
argument_list|)
operator|==
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
comment|/* Don't do this if the reg dies, or gets set in y; a standard addressing 	 mode would be better. */
operator|&&
operator|!
name|dead_or_set_p
argument_list|(
name|y
argument_list|,
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|&&
name|try_pre_increment
argument_list|(
name|y
argument_list|,
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
name|amount
argument_list|)
condition|)
block|{
comment|/* We have found a suitable auto-increment 	 and already changed insn Y to do it. 	 So flush this increment-instruction.  */
name|PUT_CODE
argument_list|(
name|insn
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Count a reference to this reg for the increment 	 insn we are deleting.  When a reg is incremented. 	 spilling it is worse, so we want to make that 	 less likely.  */
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|reg_n_refs
index|[
name|regno
index|]
operator|+=
name|loop_depth
expr_stmt|;
name|reg_n_sets
index|[
name|regno
index|]
operator|++
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Try to change INSN so that it does pre-increment or pre-decrement    addressing on register REG in order to add AMOUNT to REG.    AMOUNT is negative for pre-decrement.    Returns 1 if the change could be made.    This checks all about the validity of the result of modifying INSN.  */
end_comment

begin_function
specifier|static
name|int
name|try_pre_increment
parameter_list|(
name|insn
parameter_list|,
name|reg
parameter_list|,
name|amount
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|reg
decl_stmt|;
name|HOST_WIDE_INT
name|amount
decl_stmt|;
block|{
specifier|register
name|rtx
name|use
decl_stmt|;
comment|/* Nonzero if we can try to make a pre-increment or pre-decrement.      For example, addl $4,r1; movl (r1),... can become movl +(r1),...  */
name|int
name|pre_ok
init|=
literal|0
decl_stmt|;
comment|/* Nonzero if we can try to make a post-increment or post-decrement.      For example, addl $4,r1; movl -4(r1),... can become movl (r1)+,...      It is possible for both PRE_OK and POST_OK to be nonzero if the machine      supports both pre-inc and post-inc, or both pre-dec and post-dec.  */
name|int
name|post_ok
init|=
literal|0
decl_stmt|;
comment|/* Nonzero if the opportunity actually requires post-inc or post-dec.  */
name|int
name|do_post
init|=
literal|0
decl_stmt|;
comment|/* From the sign of increment, see which possibilities are conceivable      on this target machine.  */
ifdef|#
directive|ifdef
name|HAVE_PRE_INCREMENT
if|if
condition|(
name|amount
operator|>
literal|0
condition|)
name|pre_ok
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_POST_INCREMENT
if|if
condition|(
name|amount
operator|>
literal|0
condition|)
name|post_ok
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_PRE_DECREMENT
if|if
condition|(
name|amount
operator|<
literal|0
condition|)
name|pre_ok
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_POST_DECREMENT
if|if
condition|(
name|amount
operator|<
literal|0
condition|)
name|post_ok
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|pre_ok
operator|||
name|post_ok
operator|)
condition|)
return|return
literal|0
return|;
comment|/* It is not safe to add a side effect to a jump insn      because if the incremented register is spilled and must be reloaded      there would be no way to store the incremented value back in memory.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
return|return
literal|0
return|;
name|use
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pre_ok
condition|)
name|use
operator|=
name|find_use_as_address
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|post_ok
operator|&&
operator|(
name|use
operator|==
literal|0
operator|||
name|use
operator|==
operator|(
name|rtx
operator|)
literal|1
operator|)
condition|)
block|{
name|use
operator|=
name|find_use_as_address
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|reg
argument_list|,
operator|-
name|amount
argument_list|)
expr_stmt|;
name|do_post
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|use
operator|==
literal|0
operator|||
name|use
operator|==
operator|(
name|rtx
operator|)
literal|1
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|use
argument_list|)
argument_list|)
operator|!=
operator|(
name|amount
operator|>
literal|0
condition|?
name|amount
else|:
operator|-
name|amount
operator|)
condition|)
return|return
literal|0
return|;
comment|/* See if this combination of instruction and addressing mode exists.  */
if|if
condition|(
operator|!
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|use
argument_list|,
literal|0
argument_list|)
argument_list|,
name|gen_rtx
argument_list|(
name|amount
operator|>
literal|0
condition|?
operator|(
name|do_post
condition|?
name|POST_INC
else|:
name|PRE_INC
operator|)
else|:
operator|(
name|do_post
condition|?
name|POST_DEC
else|:
name|PRE_DEC
operator|)
argument_list|,
name|Pmode
argument_list|,
name|reg
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Record that this insn now has an implicit side effect on X.  */
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|REG_INC
argument_list|,
name|reg
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AUTO_INC_DEC */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Find the place in the rtx X where REG is used as a memory address.    Return the MEM rtx that so uses it.    If PLUSCONST is nonzero, search instead for a memory address equivalent to    (plus REG (const_int PLUSCONST)).     If such an address does not appear, return 0.    If REG appears more than once, or is used other than in such an address,    return (rtx)1.  */
end_comment

begin_function
specifier|static
name|rtx
name|find_use_as_address
parameter_list|(
name|x
parameter_list|,
name|reg
parameter_list|,
name|plusconst
parameter_list|)
specifier|register
name|rtx
name|x
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
name|HOST_WIDE_INT
name|plusconst
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|char
modifier|*
name|fmt
init|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|rtx
name|value
init|=
literal|0
decl_stmt|;
specifier|register
name|rtx
name|tem
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|MEM
operator|&&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|reg
operator|&&
name|plusconst
operator|==
literal|0
condition|)
return|return
name|x
return|;
if|if
condition|(
name|code
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|reg
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|plusconst
condition|)
return|return
name|x
return|;
if|if
condition|(
name|code
operator|==
name|SIGN_EXTRACT
operator|||
name|code
operator|==
name|ZERO_EXTRACT
condition|)
block|{
comment|/* If REG occurs inside a MEM used in a bit-field reference, 	 that is unacceptable.  */
if|if
condition|(
name|find_use_as_address
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|reg
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
return|return
call|(
name|rtx
call|)
argument_list|(
name|HOST_WIDE_INT
argument_list|)
literal|1
return|;
block|}
if|if
condition|(
name|x
operator|==
name|reg
condition|)
return|return
call|(
name|rtx
call|)
argument_list|(
name|HOST_WIDE_INT
argument_list|)
literal|1
return|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
name|tem
operator|=
name|find_use_as_address
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|reg
argument_list|,
name|plusconst
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
literal|0
condition|)
name|value
operator|=
name|tem
expr_stmt|;
elseif|else
if|if
condition|(
name|tem
operator|!=
literal|0
condition|)
return|return
call|(
name|rtx
call|)
argument_list|(
name|HOST_WIDE_INT
argument_list|)
literal|1
return|;
block|}
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|tem
operator|=
name|find_use_as_address
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|reg
argument_list|,
name|plusconst
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
literal|0
condition|)
name|value
operator|=
name|tem
expr_stmt|;
elseif|else
if|if
condition|(
name|tem
operator|!=
literal|0
condition|)
return|return
call|(
name|rtx
call|)
argument_list|(
name|HOST_WIDE_INT
argument_list|)
literal|1
return|;
block|}
block|}
block|}
return|return
name|value
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Write information about registers and basic blocks into FILE.    This is part of making a debugging dump.  */
end_comment

begin_function
name|void
name|dump_flow_info
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|static
name|char
modifier|*
name|reg_class_names
index|[]
init|=
name|REG_CLASS_NAMES
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d registers.\n"
argument_list|,
name|max_regno
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
name|max_regno
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|reg_n_refs
index|[
name|i
index|]
condition|)
block|{
name|enum
name|reg_class
name|class
decl_stmt|,
name|altclass
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\nRegister %d used %d times across %d insns"
argument_list|,
name|i
argument_list|,
name|reg_n_refs
index|[
name|i
index|]
argument_list|,
name|reg_live_length
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_basic_block
index|[
name|i
index|]
operator|>=
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" in block %d"
argument_list|,
name|reg_basic_block
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_n_deaths
index|[
name|i
index|]
operator|!=
literal|1
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"; dies in %d places"
argument_list|,
name|reg_n_deaths
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_n_calls_crossed
index|[
name|i
index|]
operator|==
literal|1
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"; crosses 1 call"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|reg_n_calls_crossed
index|[
name|i
index|]
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"; crosses %d calls"
argument_list|,
name|reg_n_calls_crossed
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|PSEUDO_REGNO_BYTES
argument_list|(
name|i
argument_list|)
operator|!=
name|UNITS_PER_WORD
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"; %d bytes"
argument_list|,
name|PSEUDO_REGNO_BYTES
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|class
operator|=
name|reg_preferred_class
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|altclass
operator|=
name|reg_alternate_class
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
operator|!=
name|GENERAL_REGS
operator|||
name|altclass
operator|!=
name|ALL_REGS
condition|)
block|{
if|if
condition|(
name|altclass
operator|==
name|ALL_REGS
operator|||
name|class
operator|==
name|ALL_REGS
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"; pref %s"
argument_list|,
name|reg_class_names
index|[
operator|(
name|int
operator|)
name|class
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|altclass
operator|==
name|NO_REGS
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"; %s or none"
argument_list|,
name|reg_class_names
index|[
operator|(
name|int
operator|)
name|class
index|]
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"; pref %s, else %s"
argument_list|,
name|reg_class_names
index|[
operator|(
name|int
operator|)
name|class
index|]
argument_list|,
name|reg_class_names
index|[
operator|(
name|int
operator|)
name|altclass
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|REGNO_POINTER_FLAG
argument_list|(
name|i
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"; pointer"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|".\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n%d basic blocks.\n"
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|rtx
name|head
decl_stmt|,
name|jump
decl_stmt|;
specifier|register
name|int
name|regno
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\nBasic block %d: first insn %d, last %d.\n"
argument_list|,
name|i
argument_list|,
name|INSN_UID
argument_list|(
name|basic_block_head
index|[
name|i
index|]
argument_list|)
argument_list|,
name|INSN_UID
argument_list|(
name|basic_block_end
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The control flow graph's storage is freed 	 now when flow_analysis returns. 	 Don't try to print it if it is gone.  */
if|if
condition|(
name|basic_block_drops_in
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"Reached from blocks: "
argument_list|)
expr_stmt|;
name|head
operator|=
name|basic_block_head
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|head
argument_list|)
operator|==
name|CODE_LABEL
condition|)
for|for
control|(
name|jump
operator|=
name|LABEL_REFS
argument_list|(
name|head
argument_list|)
init|;
name|jump
operator|!=
name|head
condition|;
name|jump
operator|=
name|LABEL_NEXTREF
argument_list|(
name|jump
argument_list|)
control|)
block|{
specifier|register
name|int
name|from_block
init|=
name|BLOCK_NUM
argument_list|(
name|CONTAINING_INSN
argument_list|(
name|jump
argument_list|)
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %d"
argument_list|,
name|from_block
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|basic_block_drops_in
index|[
name|i
index|]
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" previous"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\nRegisters live at start:"
argument_list|)
expr_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|max_regno
condition|;
name|regno
operator|++
control|)
block|{
specifier|register
name|int
name|offset
init|=
name|regno
operator|/
name|REGSET_ELT_BITS
decl_stmt|;
specifier|register
name|REGSET_ELT_TYPE
name|bit
init|=
operator|(
name|REGSET_ELT_TYPE
operator|)
literal|1
operator|<<
operator|(
name|regno
operator|%
name|REGSET_ELT_BITS
operator|)
decl_stmt|;
if|if
condition|(
name|basic_block_live_at_start
index|[
name|i
index|]
index|[
name|offset
index|]
operator|&
name|bit
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %d"
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

