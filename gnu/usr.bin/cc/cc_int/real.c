begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* real.c - implementation of REAL_ARITHMETIC, REAL_VALUE_ATOF,    and support for XFmode IEEE extended real floating point arithmetic.    Copyright (C) 1993, 1994 Free Software Foundation, Inc.    Contributed by Stephen L. Moshier (moshier@world.std.com).  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|errno
end_ifndef

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* To enable support of XFmode extended real floating point, define LONG_DOUBLE_TYPE_SIZE 96 in the tm.h file (m68k.h or i386.h).  To support cross compilation between IEEE, VAX and IBM floating point formats, define REAL_ARITHMETIC in the tm.h file.  In either case the machine files (tm.h) must not contain any code that tries to use host floating point arithmetic to convert REAL_VALUE_TYPEs from `double' to `float', pass them to fprintf, etc.  In cross-compile situations a REAL_VALUE_TYPE may not be intelligible to the host computer's native arithmetic.  The emulator defaults to the host's floating point format so that its decimal conversion functions can be used if desired (see real.h).  The first part of this file interfaces gcc to ieee.c, which is a floating point arithmetic suite that was not written with gcc in mind.  The interface is followed by ieee.c itself and related items. Avoid changing ieee.c unless you have suitable test programs available.  A special version of the PARANOIA floating point arithmetic tester, modified for this purpose, can be found on usc.edu : /pub/C-numanal/ieeetest.zoo.  Some tutorial information on ieee.c is given in my book: S. L. Moshier, _Methods and Programs for Mathematical Functions_, Prentice-Hall or Simon& Schuster Int'l, 1989.  A library of XFmode elementary transcendental functions can be obtained by ftp from research.att.com: netlib/cephes/ldouble.shar.Z  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Type of computer arithmetic.    Only one of DEC, IBM, MIEEE, IBMPC, or UNK should get defined.     `MIEEE' refers generically to big-endian IEEE floating-point data    structure.  This definition should work in SFmode `float' type and    DFmode `double' type on virtually all big-endian IEEE machines.    If LONG_DOUBLE_TYPE_SIZE has been defined to be 96, then MIEEE    also invokes the particular XFmode (`long double' type) data    structure used by the Motorola 680x0 series processors.     `IBMPC' refers generally to little-endian IEEE machines. In this    case, if LONG_DOUBLE_TYPE_SIZE has been defined to be 96, then    IBMPC also invokes the particular XFmode `long double' data    structure used by the Intel 80x86 series processors.     `DEC' refers specifically to the Digital Equipment Corp PDP-11    and VAX floating point data structure.  This model currently    supports no type wider than DFmode.     `IBM' refers specifically to the IBM System/370 and compatible    floating point data structure.  This model currently supports    no type wider than DFmode.  The IBM conversions were contributed by    frank@atom.ansto.gov.au (Frank Crawford).     If LONG_DOUBLE_TYPE_SIZE = 64 (the default, unless tm.h defines it)    then `long double' and `double' are both implemented, but they    both mean DFmode.  In this case, the software floating-point    support available here is activated by writing       #define REAL_ARITHMETIC    in tm.h.      The case LONG_DOUBLE_TYPE_SIZE = 128 activates TFmode support    and may deactivate XFmode since `long double' is used to refer    to both modes.     The macros FLOAT_WORDS_BIG_ENDIAN, HOST_FLOAT_WORDS_BIG_ENDIAN,    contributed by Richard Earnshaw<Richard.Earnshaw@cl.cam.ac.uk>,    separate the floating point unit's endian-ness from that of    the integer addressing.  This permits one to define a big-endian    FPU on a little-endian machine (e.g., ARM).  An extension to    BYTES_BIG_ENDIAN may be required for some machines in the future.    These optional macros may be defined in tm.h.  In real.h, they    default to WORDS_BIG_ENDIAN, etc., so there is no need to define    them for any normal host or target machine on which the floats    and the integers have the same endian-ness.   */
end_comment

begin_comment
comment|/* The following converts gcc macros into the ones used by this file.  */
end_comment

begin_comment
comment|/* REAL_ARITHMETIC defined means that macros in real.h are    defined to call emulator functions.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|REAL_ARITHMETIC
end_ifdef

begin_if
if|#
directive|if
name|TARGET_FLOAT_FORMAT
operator|==
name|VAX_FLOAT_FORMAT
end_if

begin_comment
comment|/* PDP-11, Pro350, VAX: */
end_comment

begin_define
define|#
directive|define
name|DEC
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* it's not VAX */
end_comment

begin_if
if|#
directive|if
name|TARGET_FLOAT_FORMAT
operator|==
name|IBM_FLOAT_FORMAT
end_if

begin_comment
comment|/* IBM System/370 style */
end_comment

begin_define
define|#
directive|define
name|IBM
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* it's also not an IBM */
end_comment

begin_if
if|#
directive|if
name|TARGET_FLOAT_FORMAT
operator|==
name|IEEE_FLOAT_FORMAT
end_if

begin_if
if|#
directive|if
name|FLOAT_WORDS_BIG_ENDIAN
end_if

begin_comment
comment|/* Motorola IEEE, high order words come first (Sun workstation): */
end_comment

begin_define
define|#
directive|define
name|MIEEE
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not big-endian */
end_comment

begin_comment
comment|/* Intel IEEE, low order words come first:  */
end_comment

begin_define
define|#
directive|define
name|IBMPC
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  big-endian */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* it's not IEEE either */
end_comment

begin_comment
comment|/* UNKnown arithmetic.  We don't support this and can't go on. */
end_comment

begin_decl_stmt
name|unknown
name|arithmetic
name|type
define|#
directive|define
name|UNK
value|1
endif|#
directive|endif
comment|/* not IEEE */
endif|#
directive|endif
comment|/* not IBM */
endif|#
directive|endif
comment|/* not VAX */
else|#
directive|else
comment|/* REAL_ARITHMETIC not defined means that the *host's* data    structure will be used.  It may differ by endian-ness from the    target machine's structure and will get its ends swapped    accordingly (but not here).  Probably only the decimal<-> binary    functions in this file will actually be used in this case.  */
if|#
directive|if
name|HOST_FLOAT_FORMAT
operator|==
name|VAX_FLOAT_FORMAT
define|#
directive|define
name|DEC
value|1
else|#
directive|else
comment|/* it's not VAX */
if|#
directive|if
name|HOST_FLOAT_FORMAT
operator|==
name|IBM_FLOAT_FORMAT
comment|/* IBM System/370 style */
define|#
directive|define
name|IBM
value|1
else|#
directive|else
comment|/* it's also not an IBM */
if|#
directive|if
name|HOST_FLOAT_FORMAT
operator|==
name|IEEE_FLOAT_FORMAT
if|#
directive|if
name|HOST_FLOAT_WORDS_BIG_ENDIAN
define|#
directive|define
name|MIEEE
value|1
else|#
directive|else
comment|/* not big-endian */
define|#
directive|define
name|IBMPC
value|1
endif|#
directive|endif
comment|/*  big-endian */
else|#
directive|else
comment|/* it's not IEEE either */
name|unknown
name|arithmetic
name|type
define|#
directive|define
name|UNK
value|1
endif|#
directive|endif
comment|/* not IEEE */
endif|#
directive|endif
comment|/* not IBM */
endif|#
directive|endif
comment|/* not VAX */
endif|#
directive|endif
comment|/* REAL_ARITHMETIC not defined */
comment|/* Define INFINITY for support of infinity.    Define NANS for support of Not-a-Number's (NaN's).  */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DEC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|IBM
argument_list|)
define|#
directive|define
name|INFINITY
define|#
directive|define
name|NANS
endif|#
directive|endif
comment|/* Support of NaNs requires support of infinity. */
ifdef|#
directive|ifdef
name|NANS
ifndef|#
directive|ifndef
name|INFINITY
define|#
directive|define
name|INFINITY
endif|#
directive|endif
endif|#
directive|endif
comment|/* Find a host integer type that is at least 16 bits wide,    and another type at least twice whatever that size is. */
if|#
directive|if
name|HOST_BITS_PER_CHAR
operator|>=
literal|16
define|#
directive|define
name|EMUSHORT
value|char
define|#
directive|define
name|EMUSHORT_SIZE
value|HOST_BITS_PER_CHAR
define|#
directive|define
name|EMULONG_SIZE
value|(2 * HOST_BITS_PER_CHAR)
else|#
directive|else
if|#
directive|if
name|HOST_BITS_PER_SHORT
operator|>=
literal|16
define|#
directive|define
name|EMUSHORT
value|short
define|#
directive|define
name|EMUSHORT_SIZE
value|HOST_BITS_PER_SHORT
define|#
directive|define
name|EMULONG_SIZE
value|(2 * HOST_BITS_PER_SHORT)
else|#
directive|else
if|#
directive|if
name|HOST_BITS_PER_INT
operator|>=
literal|16
define|#
directive|define
name|EMUSHORT
value|int
define|#
directive|define
name|EMUSHORT_SIZE
value|HOST_BITS_PER_INT
define|#
directive|define
name|EMULONG_SIZE
value|(2 * HOST_BITS_PER_INT)
else|#
directive|else
if|#
directive|if
name|HOST_BITS_PER_LONG
operator|>=
literal|16
define|#
directive|define
name|EMUSHORT
value|long
define|#
directive|define
name|EMUSHORT_SIZE
value|HOST_BITS_PER_LONG
define|#
directive|define
name|EMULONG_SIZE
value|(2 * HOST_BITS_PER_LONG)
else|#
directive|else
comment|/*  You will have to modify this program to have a smaller unit size. */
define|#
directive|define
name|EMU_NON_COMPILE
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
if|#
directive|if
name|HOST_BITS_PER_SHORT
operator|>=
name|EMULONG_SIZE
define|#
directive|define
name|EMULONG
value|short
else|#
directive|else
if|#
directive|if
name|HOST_BITS_PER_INT
operator|>=
name|EMULONG_SIZE
define|#
directive|define
name|EMULONG
value|int
else|#
directive|else
if|#
directive|if
name|HOST_BITS_PER_LONG
operator|>=
name|EMULONG_SIZE
define|#
directive|define
name|EMULONG
value|long
else|#
directive|else
if|#
directive|if
name|HOST_BITS_PER_LONG_LONG
operator|>=
name|EMULONG_SIZE
define|#
directive|define
name|EMULONG
value|long long int
else|#
directive|else
comment|/*  You will have to modify this program to have a smaller unit size. */
define|#
directive|define
name|EMU_NON_COMPILE
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
comment|/* The host interface doesn't work if no 16-bit size exists. */
if|#
directive|if
name|EMUSHORT_SIZE
operator|!=
literal|16
define|#
directive|define
name|EMU_NON_COMPILE
endif|#
directive|endif
comment|/* OK to continue compilation. */
ifndef|#
directive|ifndef
name|EMU_NON_COMPILE
comment|/* Construct macros to translate between REAL_VALUE_TYPE and e type.    In GET_REAL and PUT_REAL, r and e are pointers.    A REAL_VALUE_TYPE is guaranteed to occupy contiguous locations    in memory, with no holes.  */
if|#
directive|if
name|LONG_DOUBLE_TYPE_SIZE
operator|==
literal|96
comment|/* Number of 16 bit words in external e type format */
define|#
directive|define
name|NE
value|6
define|#
directive|define
name|MAXDECEXP
value|4932
define|#
directive|define
name|MINDECEXP
value|-4956
define|#
directive|define
name|GET_REAL
parameter_list|(
name|r
parameter_list|,
name|e
parameter_list|)
value|bcopy ((char *) r, (char *) e, 2*NE)
define|#
directive|define
name|PUT_REAL
parameter_list|(
name|e
parameter_list|,
name|r
parameter_list|)
value|bcopy ((char *) e, (char *) r, 2*NE)
else|#
directive|else
comment|/* no XFmode */
if|#
directive|if
name|LONG_DOUBLE_TYPE_SIZE
operator|==
literal|128
define|#
directive|define
name|NE
value|10
define|#
directive|define
name|MAXDECEXP
value|4932
define|#
directive|define
name|MINDECEXP
value|-4977
define|#
directive|define
name|GET_REAL
parameter_list|(
name|r
parameter_list|,
name|e
parameter_list|)
value|bcopy ((char *) r, (char *) e, 2*NE)
define|#
directive|define
name|PUT_REAL
parameter_list|(
name|e
parameter_list|,
name|r
parameter_list|)
value|bcopy ((char *) e, (char *) r, 2*NE)
else|#
directive|else
define|#
directive|define
name|NE
value|6
define|#
directive|define
name|MAXDECEXP
value|4932
define|#
directive|define
name|MINDECEXP
value|-4956
ifdef|#
directive|ifdef
name|REAL_ARITHMETIC
comment|/* Emulator uses target format internally    but host stores it in host endian-ness. */
if|#
directive|if
name|HOST_FLOAT_WORDS_BIG_ENDIAN
operator|==
name|FLOAT_WORDS_BIG_ENDIAN
define|#
directive|define
name|GET_REAL
parameter_list|(
name|r
parameter_list|,
name|e
parameter_list|)
value|e53toe ((unsigned EMUSHORT*) (r), (e))
define|#
directive|define
name|PUT_REAL
parameter_list|(
name|e
parameter_list|,
name|r
parameter_list|)
value|etoe53 ((e), (unsigned EMUSHORT *) (r))
else|#
directive|else
comment|/* endian-ness differs */
comment|/* emulator uses target endian-ness internally */
define|#
directive|define
name|GET_REAL
parameter_list|(
name|r
parameter_list|,
name|e
parameter_list|)
define|\
value|do { unsigned EMUSHORT w[4];	\  w[3] = ((EMUSHORT *) r)[0];	\  w[2] = ((EMUSHORT *) r)[1];	\  w[1] = ((EMUSHORT *) r)[2];	\  w[0] = ((EMUSHORT *) r)[3];	\  e53toe (w, (e)); } while (0)
define|#
directive|define
name|PUT_REAL
parameter_list|(
name|e
parameter_list|,
name|r
parameter_list|)
define|\
value|do { unsigned EMUSHORT w[4];	\  etoe53 ((e), w);		\  *((EMUSHORT *) r) = w[3];	\  *((EMUSHORT *) r + 1) = w[2];	\  *((EMUSHORT *) r + 2) = w[1];	\  *((EMUSHORT *) r + 3) = w[0]; } while (0)
endif|#
directive|endif
comment|/* endian-ness differs */
else|#
directive|else
comment|/* not REAL_ARITHMETIC */
comment|/* emulator uses host format */
define|#
directive|define
name|GET_REAL
parameter_list|(
name|r
parameter_list|,
name|e
parameter_list|)
value|e53toe ((unsigned EMUSHORT *) (r), (e))
define|#
directive|define
name|PUT_REAL
parameter_list|(
name|e
parameter_list|,
name|r
parameter_list|)
value|etoe53 ((e), (unsigned EMUSHORT *) (r))
endif|#
directive|endif
comment|/* not REAL_ARITHMETIC */
endif|#
directive|endif
comment|/* not TFmode */
endif|#
directive|endif
comment|/* no XFmode */
comment|/* Number of 16 bit words in internal format */
define|#
directive|define
name|NI
value|(NE+3)
comment|/* Array offset to exponent */
define|#
directive|define
name|E
value|1
comment|/* Array offset to high guard word */
define|#
directive|define
name|M
value|2
comment|/* Number of bits of precision */
define|#
directive|define
name|NBITS
value|((NI-4)*16)
comment|/* Maximum number of decimal digits in ASCII conversion  * = NBITS*log10(2)  */
define|#
directive|define
name|NDEC
value|(NBITS*8/27)
comment|/* The exponent of 1.0 */
define|#
directive|define
name|EXONE
value|(0x3fff)
specifier|extern
name|int
name|extra_warnings
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
name|EMUSHORT
name|ezero
index|[]
decl_stmt|,
name|ehalf
index|[]
decl_stmt|,
name|eone
index|[]
decl_stmt|,
name|etwo
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
name|EMUSHORT
name|elog2
index|[]
decl_stmt|,
name|esqrt2
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|endian
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|long
operator|*
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|eclear
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|emov
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|eabs
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|eneg
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|eisneg
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|eisinf
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|eisnan
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|einfin
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|enan
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|emovi
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|emovo
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ecleaz
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ecleazs
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|emovz
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|einan
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|eiisnan
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|eiisneg
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|eiinfin
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|eiisinf
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ecmpm
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|eshdn1
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|eshup1
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|eshdn8
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|eshup8
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|eshup6
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|eshdn6
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|eaddm
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|void
name|esubm
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|m16m
name|PROTO
argument_list|(
operator|(
name|unsigned
name|int
operator|,
name|unsigned
name|short
operator|*
operator|,
name|unsigned
name|short
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|edivm
name|PROTO
argument_list|(
operator|(
name|unsigned
name|short
operator|*
operator|,
name|unsigned
name|short
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|emulm
name|PROTO
argument_list|(
operator|(
name|unsigned
name|short
operator|*
operator|,
name|unsigned
name|short
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|emdnorm
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|EMULONG
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|esub
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|eadd
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|eadd1
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ediv
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|emul
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|e53toe
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|e64toe
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|e113toe
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|e24toe
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|etoe113
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|toe113
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|etoe64
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|toe64
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|etoe53
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|toe53
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|etoe24
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|toe24
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ecmp
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|eround
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ltoe
name|PROTO
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ultoe
name|PROTO
argument_list|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|eifrac
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|HOST_WIDE_INT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|euifrac
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|HOST_WIDE_INT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|eshift
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|enormlz
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|e24toasc
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|e53toasc
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|e64toasc
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|e113toasc
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|etoasc
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|asctoe24
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|asctoe53
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|asctoe64
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|asctoe113
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|asctoe
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|asctoeg
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|efloor
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|efrexp
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|int
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|eldexp
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|int
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|eremain
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|eiremain
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mtherr
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dectoe
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|etodec
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|todec
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ibmtoe
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|etoibm
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|toibm
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|make_nan
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|int
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|uditoe
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ditoe
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|etoudi
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|etodi
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|esqrt
name|PROTO
argument_list|(
operator|(
name|unsigned
name|EMUSHORT
operator|*
operator|,
name|unsigned
name|EMUSHORT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Copy 32-bit numbers obtained from array containing 16-bit numbers,    swapping ends if required, into output array of longs.  The    result is normally passed to fprintf by the ASM_OUTPUT_ macros.   */
end_comment

begin_function
specifier|static
name|void
name|endian
parameter_list|(
name|e
parameter_list|,
name|x
parameter_list|,
name|mode
parameter_list|)
name|unsigned
name|EMUSHORT
name|e
index|[]
decl_stmt|;
name|long
name|x
index|[]
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|unsigned
name|long
name|th
decl_stmt|,
name|t
decl_stmt|;
if|#
directive|if
name|FLOAT_WORDS_BIG_ENDIAN
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|TFmode
case|:
comment|/* Swap halfwords in the fourth long. */
name|th
operator|=
operator|(
name|unsigned
name|long
operator|)
name|e
index|[
literal|6
index|]
operator|&
literal|0xffff
expr_stmt|;
name|t
operator|=
operator|(
name|unsigned
name|long
operator|)
name|e
index|[
literal|7
index|]
operator|&
literal|0xffff
expr_stmt|;
name|t
operator||=
name|th
operator|<<
literal|16
expr_stmt|;
name|x
index|[
literal|3
index|]
operator|=
operator|(
name|long
operator|)
name|t
expr_stmt|;
case|case
name|XFmode
case|:
comment|/* Swap halfwords in the third long. */
name|th
operator|=
operator|(
name|unsigned
name|long
operator|)
name|e
index|[
literal|4
index|]
operator|&
literal|0xffff
expr_stmt|;
name|t
operator|=
operator|(
name|unsigned
name|long
operator|)
name|e
index|[
literal|5
index|]
operator|&
literal|0xffff
expr_stmt|;
name|t
operator||=
name|th
operator|<<
literal|16
expr_stmt|;
name|x
index|[
literal|2
index|]
operator|=
operator|(
name|long
operator|)
name|t
expr_stmt|;
comment|/* fall into the double case */
case|case
name|DFmode
case|:
comment|/* swap halfwords in the second word */
name|th
operator|=
operator|(
name|unsigned
name|long
operator|)
name|e
index|[
literal|2
index|]
operator|&
literal|0xffff
expr_stmt|;
name|t
operator|=
operator|(
name|unsigned
name|long
operator|)
name|e
index|[
literal|3
index|]
operator|&
literal|0xffff
expr_stmt|;
name|t
operator||=
name|th
operator|<<
literal|16
expr_stmt|;
name|x
index|[
literal|1
index|]
operator|=
operator|(
name|long
operator|)
name|t
expr_stmt|;
comment|/* fall into the float case */
case|case
name|HFmode
case|:
case|case
name|SFmode
case|:
comment|/* swap halfwords in the first word */
name|th
operator|=
operator|(
name|unsigned
name|long
operator|)
name|e
index|[
literal|0
index|]
operator|&
literal|0xffff
expr_stmt|;
name|t
operator|=
operator|(
name|unsigned
name|long
operator|)
name|e
index|[
literal|1
index|]
operator|&
literal|0xffff
expr_stmt|;
name|t
operator||=
name|th
operator|<<
literal|16
expr_stmt|;
name|x
index|[
literal|0
index|]
operator|=
name|t
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
else|#
directive|else
comment|/* Pack the output array without swapping. */
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|TFmode
case|:
comment|/* Pack the fourth long. */
name|th
operator|=
operator|(
name|unsigned
name|long
operator|)
name|e
index|[
literal|7
index|]
operator|&
literal|0xffff
expr_stmt|;
name|t
operator|=
operator|(
name|unsigned
name|long
operator|)
name|e
index|[
literal|6
index|]
operator|&
literal|0xffff
expr_stmt|;
name|t
operator||=
name|th
operator|<<
literal|16
expr_stmt|;
name|x
index|[
literal|3
index|]
operator|=
operator|(
name|long
operator|)
name|t
expr_stmt|;
case|case
name|XFmode
case|:
comment|/* Pack the third long. 	 Each element of the input REAL_VALUE_TYPE array has 16 useful bits 	 in it.  */
name|th
operator|=
operator|(
name|unsigned
name|long
operator|)
name|e
index|[
literal|5
index|]
operator|&
literal|0xffff
expr_stmt|;
name|t
operator|=
operator|(
name|unsigned
name|long
operator|)
name|e
index|[
literal|4
index|]
operator|&
literal|0xffff
expr_stmt|;
name|t
operator||=
name|th
operator|<<
literal|16
expr_stmt|;
name|x
index|[
literal|2
index|]
operator|=
operator|(
name|long
operator|)
name|t
expr_stmt|;
comment|/* fall into the double case */
case|case
name|DFmode
case|:
comment|/* pack the second long */
name|th
operator|=
operator|(
name|unsigned
name|long
operator|)
name|e
index|[
literal|3
index|]
operator|&
literal|0xffff
expr_stmt|;
name|t
operator|=
operator|(
name|unsigned
name|long
operator|)
name|e
index|[
literal|2
index|]
operator|&
literal|0xffff
expr_stmt|;
name|t
operator||=
name|th
operator|<<
literal|16
expr_stmt|;
name|x
index|[
literal|1
index|]
operator|=
operator|(
name|long
operator|)
name|t
expr_stmt|;
comment|/* fall into the float case */
case|case
name|HFmode
case|:
case|case
name|SFmode
case|:
comment|/* pack the first long */
name|th
operator|=
operator|(
name|unsigned
name|long
operator|)
name|e
index|[
literal|1
index|]
operator|&
literal|0xffff
expr_stmt|;
name|t
operator|=
operator|(
name|unsigned
name|long
operator|)
name|e
index|[
literal|0
index|]
operator|&
literal|0xffff
expr_stmt|;
name|t
operator||=
name|th
operator|<<
literal|16
expr_stmt|;
name|x
index|[
literal|0
index|]
operator|=
name|t
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* This is the implementation of the REAL_ARITHMETIC macro.  */
end_comment

begin_function
name|void
name|earith
parameter_list|(
name|value
parameter_list|,
name|icode
parameter_list|,
name|r1
parameter_list|,
name|r2
parameter_list|)
name|REAL_VALUE_TYPE
modifier|*
name|value
decl_stmt|;
name|int
name|icode
decl_stmt|;
name|REAL_VALUE_TYPE
modifier|*
name|r1
decl_stmt|;
name|REAL_VALUE_TYPE
modifier|*
name|r2
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|d1
index|[
name|NE
index|]
decl_stmt|,
name|d2
index|[
name|NE
index|]
decl_stmt|,
name|v
index|[
name|NE
index|]
decl_stmt|;
name|enum
name|tree_code
name|code
decl_stmt|;
name|GET_REAL
argument_list|(
name|r1
argument_list|,
name|d1
argument_list|)
expr_stmt|;
name|GET_REAL
argument_list|(
name|r2
argument_list|,
name|d2
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NANS
comment|/*  Return NaN input back to the caller. */
if|if
condition|(
name|eisnan
argument_list|(
name|d1
argument_list|)
condition|)
block|{
name|PUT_REAL
argument_list|(
name|d1
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|eisnan
argument_list|(
name|d2
argument_list|)
condition|)
block|{
name|PUT_REAL
argument_list|(
name|d2
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|code
operator|=
operator|(
expr|enum
name|tree_code
operator|)
name|icode
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PLUS_EXPR
case|:
name|eadd
argument_list|(
name|d2
argument_list|,
name|d1
argument_list|,
name|v
argument_list|)
expr_stmt|;
break|break;
case|case
name|MINUS_EXPR
case|:
name|esub
argument_list|(
name|d2
argument_list|,
name|d1
argument_list|,
name|v
argument_list|)
expr_stmt|;
comment|/* d1 - d2 */
break|break;
case|case
name|MULT_EXPR
case|:
name|emul
argument_list|(
name|d2
argument_list|,
name|d1
argument_list|,
name|v
argument_list|)
expr_stmt|;
break|break;
case|case
name|RDIV_EXPR
case|:
ifndef|#
directive|ifndef
name|REAL_INFINITY
if|if
condition|(
name|ecmp
argument_list|(
name|d2
argument_list|,
name|ezero
argument_list|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|NANS
name|enan
argument_list|(
name|v
argument_list|,
name|eisneg
argument_list|(
name|d1
argument_list|)
operator|^
name|eisneg
argument_list|(
name|d2
argument_list|)
argument_list|)
expr_stmt|;
break|break;
else|#
directive|else
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
name|ediv
argument_list|(
name|d2
argument_list|,
name|d1
argument_list|,
name|v
argument_list|)
expr_stmt|;
comment|/* d1/d2 */
break|break;
case|case
name|MIN_EXPR
case|:
comment|/* min (d1,d2) */
if|if
condition|(
name|ecmp
argument_list|(
name|d1
argument_list|,
name|d2
argument_list|)
operator|<
literal|0
condition|)
name|emov
argument_list|(
name|d1
argument_list|,
name|v
argument_list|)
expr_stmt|;
else|else
name|emov
argument_list|(
name|d2
argument_list|,
name|v
argument_list|)
expr_stmt|;
break|break;
case|case
name|MAX_EXPR
case|:
comment|/* max (d1,d2) */
if|if
condition|(
name|ecmp
argument_list|(
name|d1
argument_list|,
name|d2
argument_list|)
operator|>
literal|0
condition|)
name|emov
argument_list|(
name|d1
argument_list|,
name|v
argument_list|)
expr_stmt|;
else|else
name|emov
argument_list|(
name|d2
argument_list|,
name|v
argument_list|)
expr_stmt|;
break|break;
default|default:
name|emov
argument_list|(
name|ezero
argument_list|,
name|v
argument_list|)
expr_stmt|;
break|break;
block|}
name|PUT_REAL
argument_list|(
name|v
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Truncate REAL_VALUE_TYPE toward zero to signed HOST_WIDE_INT.    implements REAL_VALUE_RNDZINT (x) (etrunci (x)).  */
end_comment

begin_function
name|REAL_VALUE_TYPE
name|etrunci
parameter_list|(
name|x
parameter_list|)
name|REAL_VALUE_TYPE
name|x
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|f
index|[
name|NE
index|]
decl_stmt|,
name|g
index|[
name|NE
index|]
decl_stmt|;
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|HOST_WIDE_INT
name|l
decl_stmt|;
name|GET_REAL
argument_list|(
operator|&
name|x
argument_list|,
name|g
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NANS
if|if
condition|(
name|eisnan
argument_list|(
name|g
argument_list|)
condition|)
return|return
operator|(
name|x
operator|)
return|;
endif|#
directive|endif
name|eifrac
argument_list|(
name|g
argument_list|,
operator|&
name|l
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|ltoe
argument_list|(
operator|&
name|l
argument_list|,
name|g
argument_list|)
expr_stmt|;
name|PUT_REAL
argument_list|(
name|g
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Truncate REAL_VALUE_TYPE toward zero to unsigned HOST_WIDE_INT;    implements REAL_VALUE_UNSIGNED_RNDZINT (x) (etruncui (x)).  */
end_comment

begin_function
name|REAL_VALUE_TYPE
name|etruncui
parameter_list|(
name|x
parameter_list|)
name|REAL_VALUE_TYPE
name|x
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|f
index|[
name|NE
index|]
decl_stmt|,
name|g
index|[
name|NE
index|]
decl_stmt|;
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|l
decl_stmt|;
name|GET_REAL
argument_list|(
operator|&
name|x
argument_list|,
name|g
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NANS
if|if
condition|(
name|eisnan
argument_list|(
name|g
argument_list|)
condition|)
return|return
operator|(
name|x
operator|)
return|;
endif|#
directive|endif
name|euifrac
argument_list|(
name|g
argument_list|,
operator|&
name|l
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|ultoe
argument_list|(
operator|&
name|l
argument_list|,
name|g
argument_list|)
expr_stmt|;
name|PUT_REAL
argument_list|(
name|g
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_comment
comment|/* This is the REAL_VALUE_ATOF function.  It converts a decimal string to    binary, rounding off as indicated by the machine_mode argument.  Then it    promotes the rounded value to REAL_VALUE_TYPE.  */
end_comment

begin_function
name|REAL_VALUE_TYPE
name|ereal_atof
parameter_list|(
name|s
parameter_list|,
name|t
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|enum
name|machine_mode
name|t
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|tem
index|[
name|NE
index|]
decl_stmt|,
name|e
index|[
name|NE
index|]
decl_stmt|;
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
switch|switch
condition|(
name|t
condition|)
block|{
case|case
name|HFmode
case|:
case|case
name|SFmode
case|:
name|asctoe24
argument_list|(
name|s
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|e24toe
argument_list|(
name|tem
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|DFmode
case|:
name|asctoe53
argument_list|(
name|s
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|e53toe
argument_list|(
name|tem
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|XFmode
case|:
name|asctoe64
argument_list|(
name|s
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|e64toe
argument_list|(
name|tem
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|TFmode
case|:
name|asctoe113
argument_list|(
name|s
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|e113toe
argument_list|(
name|tem
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
default|default:
name|asctoe
argument_list|(
name|s
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|PUT_REAL
argument_list|(
name|e
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Expansion of REAL_NEGATE.  */
end_comment

begin_function
name|REAL_VALUE_TYPE
name|ereal_negate
parameter_list|(
name|x
parameter_list|)
name|REAL_VALUE_TYPE
name|x
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|e
index|[
name|NE
index|]
decl_stmt|;
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|GET_REAL
argument_list|(
operator|&
name|x
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|eneg
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|PUT_REAL
argument_list|(
name|e
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Round real toward zero to HOST_WIDE_INT;    implements REAL_VALUE_FIX (x).  */
end_comment

begin_function
name|HOST_WIDE_INT
name|efixi
parameter_list|(
name|x
parameter_list|)
name|REAL_VALUE_TYPE
name|x
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|f
index|[
name|NE
index|]
decl_stmt|,
name|g
index|[
name|NE
index|]
decl_stmt|;
name|HOST_WIDE_INT
name|l
decl_stmt|;
name|GET_REAL
argument_list|(
operator|&
name|x
argument_list|,
name|f
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NANS
if|if
condition|(
name|eisnan
argument_list|(
name|f
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"conversion from NaN to int"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
name|eifrac
argument_list|(
name|f
argument_list|,
operator|&
name|l
argument_list|,
name|g
argument_list|)
expr_stmt|;
return|return
name|l
return|;
block|}
end_function

begin_comment
comment|/* Round real toward zero to unsigned HOST_WIDE_INT    implements  REAL_VALUE_UNSIGNED_FIX (x).    Negative input returns zero.  */
end_comment

begin_function
name|unsigned
name|HOST_WIDE_INT
name|efixui
parameter_list|(
name|x
parameter_list|)
name|REAL_VALUE_TYPE
name|x
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|f
index|[
name|NE
index|]
decl_stmt|,
name|g
index|[
name|NE
index|]
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|l
decl_stmt|;
name|GET_REAL
argument_list|(
operator|&
name|x
argument_list|,
name|f
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NANS
if|if
condition|(
name|eisnan
argument_list|(
name|f
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"conversion from NaN to unsigned int"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
name|euifrac
argument_list|(
name|f
argument_list|,
operator|&
name|l
argument_list|,
name|g
argument_list|)
expr_stmt|;
return|return
name|l
return|;
block|}
end_function

begin_comment
comment|/* REAL_VALUE_FROM_INT macro.  */
end_comment

begin_function
name|void
name|ereal_from_int
parameter_list|(
name|d
parameter_list|,
name|i
parameter_list|,
name|j
parameter_list|)
name|REAL_VALUE_TYPE
modifier|*
name|d
decl_stmt|;
name|HOST_WIDE_INT
name|i
decl_stmt|,
name|j
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|df
index|[
name|NE
index|]
decl_stmt|,
name|dg
index|[
name|NE
index|]
decl_stmt|;
name|HOST_WIDE_INT
name|low
decl_stmt|,
name|high
decl_stmt|;
name|int
name|sign
decl_stmt|;
name|sign
operator|=
literal|0
expr_stmt|;
name|low
operator|=
name|i
expr_stmt|;
if|if
condition|(
operator|(
name|high
operator|=
name|j
operator|)
operator|<
literal|0
condition|)
block|{
name|sign
operator|=
literal|1
expr_stmt|;
comment|/* complement and add 1 */
name|high
operator|=
operator|~
name|high
expr_stmt|;
if|if
condition|(
name|low
condition|)
name|low
operator|=
operator|-
name|low
expr_stmt|;
else|else
name|high
operator|+=
literal|1
expr_stmt|;
block|}
name|eldexp
argument_list|(
name|eone
argument_list|,
name|HOST_BITS_PER_WIDE_INT
argument_list|,
name|df
argument_list|)
expr_stmt|;
name|ultoe
argument_list|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|*
operator|)
operator|&
name|high
argument_list|,
name|dg
argument_list|)
expr_stmt|;
name|emul
argument_list|(
name|dg
argument_list|,
name|df
argument_list|,
name|dg
argument_list|)
expr_stmt|;
name|ultoe
argument_list|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|*
operator|)
operator|&
name|low
argument_list|,
name|df
argument_list|)
expr_stmt|;
name|eadd
argument_list|(
name|df
argument_list|,
name|dg
argument_list|,
name|dg
argument_list|)
expr_stmt|;
if|if
condition|(
name|sign
condition|)
name|eneg
argument_list|(
name|dg
argument_list|)
expr_stmt|;
name|PUT_REAL
argument_list|(
name|dg
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* REAL_VALUE_FROM_UNSIGNED_INT macro.   */
end_comment

begin_function
name|void
name|ereal_from_uint
parameter_list|(
name|d
parameter_list|,
name|i
parameter_list|,
name|j
parameter_list|)
name|REAL_VALUE_TYPE
modifier|*
name|d
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|i
decl_stmt|,
name|j
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|df
index|[
name|NE
index|]
decl_stmt|,
name|dg
index|[
name|NE
index|]
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|low
decl_stmt|,
name|high
decl_stmt|;
name|low
operator|=
name|i
expr_stmt|;
name|high
operator|=
name|j
expr_stmt|;
name|eldexp
argument_list|(
name|eone
argument_list|,
name|HOST_BITS_PER_WIDE_INT
argument_list|,
name|df
argument_list|)
expr_stmt|;
name|ultoe
argument_list|(
operator|&
name|high
argument_list|,
name|dg
argument_list|)
expr_stmt|;
name|emul
argument_list|(
name|dg
argument_list|,
name|df
argument_list|,
name|dg
argument_list|)
expr_stmt|;
name|ultoe
argument_list|(
operator|&
name|low
argument_list|,
name|df
argument_list|)
expr_stmt|;
name|eadd
argument_list|(
name|df
argument_list|,
name|dg
argument_list|,
name|dg
argument_list|)
expr_stmt|;
name|PUT_REAL
argument_list|(
name|dg
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* REAL_VALUE_TO_INT macro.  */
end_comment

begin_function
name|void
name|ereal_to_int
parameter_list|(
name|low
parameter_list|,
name|high
parameter_list|,
name|rr
parameter_list|)
name|HOST_WIDE_INT
modifier|*
name|low
decl_stmt|,
decl|*
name|high
decl_stmt|;
end_function

begin_decl_stmt
name|REAL_VALUE_TYPE
name|rr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|unsigned
name|EMUSHORT
name|d
index|[
name|NE
index|]
decl_stmt|,
name|df
index|[
name|NE
index|]
decl_stmt|,
name|dg
index|[
name|NE
index|]
decl_stmt|,
name|dh
index|[
name|NE
index|]
decl_stmt|;
name|int
name|s
decl_stmt|;
name|GET_REAL
argument_list|(
operator|&
name|rr
argument_list|,
name|d
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NANS
if|if
condition|(
name|eisnan
argument_list|(
name|d
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"conversion from NaN to int"
argument_list|)
expr_stmt|;
operator|*
name|low
operator|=
operator|-
literal|1
expr_stmt|;
operator|*
name|high
operator|=
operator|-
literal|1
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* convert positive value */
name|s
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|eisneg
argument_list|(
name|d
argument_list|)
condition|)
block|{
name|eneg
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|s
operator|=
literal|1
expr_stmt|;
block|}
name|eldexp
argument_list|(
name|eone
argument_list|,
name|HOST_BITS_PER_WIDE_INT
argument_list|,
name|df
argument_list|)
expr_stmt|;
name|ediv
argument_list|(
name|df
argument_list|,
name|d
argument_list|,
name|dg
argument_list|)
expr_stmt|;
comment|/* dg = d / 2^32 is the high word */
name|euifrac
argument_list|(
name|dg
argument_list|,
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|*
operator|)
name|high
argument_list|,
name|dh
argument_list|)
expr_stmt|;
name|emul
argument_list|(
name|df
argument_list|,
name|dh
argument_list|,
name|dg
argument_list|)
expr_stmt|;
comment|/* fractional part is the low word */
name|euifrac
argument_list|(
name|dg
argument_list|,
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|*
operator|)
name|low
argument_list|,
name|dh
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
condition|)
block|{
comment|/* complement and add 1 */
operator|*
name|high
operator|=
operator|~
operator|(
operator|*
name|high
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|low
condition|)
operator|*
name|low
operator|=
operator|-
operator|(
operator|*
name|low
operator|)
expr_stmt|;
else|else
operator|*
name|high
operator|+=
literal|1
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* REAL_VALUE_LDEXP macro.  */
end_comment

begin_function
name|REAL_VALUE_TYPE
name|ereal_ldexp
parameter_list|(
name|x
parameter_list|,
name|n
parameter_list|)
name|REAL_VALUE_TYPE
name|x
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|e
index|[
name|NE
index|]
decl_stmt|,
name|y
index|[
name|NE
index|]
decl_stmt|;
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|GET_REAL
argument_list|(
operator|&
name|x
argument_list|,
name|e
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NANS
if|if
condition|(
name|eisnan
argument_list|(
name|e
argument_list|)
condition|)
return|return
operator|(
name|x
operator|)
return|;
endif|#
directive|endif
name|eldexp
argument_list|(
name|e
argument_list|,
name|n
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|PUT_REAL
argument_list|(
name|y
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_comment
comment|/* These routines are conditionally compiled because functions    of the same names may be defined in fold-const.c.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|REAL_ARITHMETIC
end_ifdef

begin_comment
comment|/* Check for infinity in a REAL_VALUE_TYPE. */
end_comment

begin_function
name|int
name|target_isinf
parameter_list|(
name|x
parameter_list|)
name|REAL_VALUE_TYPE
name|x
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|e
index|[
name|NE
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|INFINITY
name|GET_REAL
argument_list|(
operator|&
name|x
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
operator|(
name|eisinf
argument_list|(
name|e
argument_list|)
operator|)
return|;
else|#
directive|else
return|return
literal|0
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Check whether a REAL_VALUE_TYPE item is a NaN. */
end_comment

begin_function
name|int
name|target_isnan
parameter_list|(
name|x
parameter_list|)
name|REAL_VALUE_TYPE
name|x
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|e
index|[
name|NE
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|NANS
name|GET_REAL
argument_list|(
operator|&
name|x
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
operator|(
name|eisnan
argument_list|(
name|e
argument_list|)
operator|)
return|;
else|#
directive|else
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Check for a negative REAL_VALUE_TYPE number.    This just checks the sign bit, so that -0 counts as negative. */
end_comment

begin_function
name|int
name|target_negative
parameter_list|(
name|x
parameter_list|)
name|REAL_VALUE_TYPE
name|x
decl_stmt|;
block|{
return|return
name|ereal_isneg
argument_list|(
name|x
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Expansion of REAL_VALUE_TRUNCATE.    The result is in floating point, rounded to nearest or even.  */
end_comment

begin_function
name|REAL_VALUE_TYPE
name|real_value_truncate
parameter_list|(
name|mode
parameter_list|,
name|arg
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|REAL_VALUE_TYPE
name|arg
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|e
index|[
name|NE
index|]
decl_stmt|,
name|t
index|[
name|NE
index|]
decl_stmt|;
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|GET_REAL
argument_list|(
operator|&
name|arg
argument_list|,
name|e
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NANS
if|if
condition|(
name|eisnan
argument_list|(
name|e
argument_list|)
condition|)
return|return
operator|(
name|arg
operator|)
return|;
endif|#
directive|endif
name|eclear
argument_list|(
name|t
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|TFmode
case|:
name|etoe113
argument_list|(
name|e
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|e113toe
argument_list|(
name|t
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|XFmode
case|:
name|etoe64
argument_list|(
name|e
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|e64toe
argument_list|(
name|t
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|DFmode
case|:
name|etoe53
argument_list|(
name|e
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|e53toe
argument_list|(
name|t
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|HFmode
case|:
case|case
name|SFmode
case|:
name|etoe24
argument_list|(
name|e
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|e24toe
argument_list|(
name|t
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|SImode
case|:
name|r
operator|=
name|etrunci
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
comment|/* If an unsupported type was requested, presume that        the machine files know something useful to do with        the unmodified value.  */
default|default:
return|return
operator|(
name|arg
operator|)
return|;
block|}
name|PUT_REAL
argument_list|(
name|t
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* REAL_ARITHMETIC defined */
end_comment

begin_comment
comment|/* Used for debugging--print the value of R in human-readable format    on stderr.  */
end_comment

begin_function
name|void
name|debug_real
parameter_list|(
name|r
parameter_list|)
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
block|{
name|char
name|dstr
index|[
literal|30
index|]
decl_stmt|;
name|REAL_VALUE_TO_DECIMAL
argument_list|(
name|r
argument_list|,
literal|"%.20g"
argument_list|,
name|dstr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s"
argument_list|,
name|dstr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Target values are arrays of host longs. A long is guaranteed    to be at least 32 bits wide. */
end_comment

begin_comment
comment|/* 128-bit long double */
end_comment

begin_function
name|void
name|etartdouble
parameter_list|(
name|r
parameter_list|,
name|l
parameter_list|)
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|long
name|l
index|[]
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|e
index|[
name|NE
index|]
decl_stmt|;
name|GET_REAL
argument_list|(
operator|&
name|r
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|etoe113
argument_list|(
name|e
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|endian
argument_list|(
name|e
argument_list|,
name|l
argument_list|,
name|TFmode
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* 80-bit long double */
end_comment

begin_function
name|void
name|etarldouble
parameter_list|(
name|r
parameter_list|,
name|l
parameter_list|)
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|long
name|l
index|[]
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|e
index|[
name|NE
index|]
decl_stmt|;
name|GET_REAL
argument_list|(
operator|&
name|r
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|etoe64
argument_list|(
name|e
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|endian
argument_list|(
name|e
argument_list|,
name|l
argument_list|,
name|XFmode
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|etardouble
parameter_list|(
name|r
parameter_list|,
name|l
parameter_list|)
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|long
name|l
index|[]
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|e
index|[
name|NE
index|]
decl_stmt|;
name|GET_REAL
argument_list|(
operator|&
name|r
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|etoe53
argument_list|(
name|e
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|endian
argument_list|(
name|e
argument_list|,
name|l
argument_list|,
name|DFmode
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|long
name|etarsingle
parameter_list|(
name|r
parameter_list|)
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|e
index|[
name|NE
index|]
decl_stmt|;
name|long
name|l
decl_stmt|;
name|GET_REAL
argument_list|(
operator|&
name|r
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|etoe24
argument_list|(
name|e
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|endian
argument_list|(
name|e
argument_list|,
operator|&
name|l
argument_list|,
name|SFmode
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|long
operator|)
name|l
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ereal_to_decimal
parameter_list|(
name|x
parameter_list|,
name|s
parameter_list|)
name|REAL_VALUE_TYPE
name|x
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|e
index|[
name|NE
index|]
decl_stmt|;
name|GET_REAL
argument_list|(
operator|&
name|x
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|etoasc
argument_list|(
name|e
argument_list|,
name|s
argument_list|,
literal|20
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ereal_cmp
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|REAL_VALUE_TYPE
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|ex
index|[
name|NE
index|]
decl_stmt|,
name|ey
index|[
name|NE
index|]
decl_stmt|;
name|GET_REAL
argument_list|(
operator|&
name|x
argument_list|,
name|ex
argument_list|)
expr_stmt|;
name|GET_REAL
argument_list|(
operator|&
name|y
argument_list|,
name|ey
argument_list|)
expr_stmt|;
return|return
operator|(
name|ecmp
argument_list|(
name|ex
argument_list|,
name|ey
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ereal_isneg
parameter_list|(
name|x
parameter_list|)
name|REAL_VALUE_TYPE
name|x
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|ex
index|[
name|NE
index|]
decl_stmt|;
name|GET_REAL
argument_list|(
operator|&
name|x
argument_list|,
name|ex
argument_list|)
expr_stmt|;
return|return
operator|(
name|eisneg
argument_list|(
name|ex
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* End of REAL_ARITHMETIC interface */
end_comment

begin_escape
end_escape

begin_comment
comment|/*   Extended precision IEEE binary floating point arithmetic routines    Numbers are stored in C language as arrays of 16-bit unsigned   short integers.  The arguments of the routines are pointers to   the arrays.    External e type data structure, simulates Intel 8087 chip   temporary real format but possibly with a larger significand:  	NE-1 significand words	(least significant word first, 				 most significant bit is normally set) 	exponent		(value = EXONE for 1.0, 				top bit is the sign)     Internal data structure of a number (a "word" is 16 bits):    ei[0]	sign word	(0 for positive, 0xffff for negative)   ei[1]	biased exponent	(value = EXONE for the number 1.0)   ei[2]	high guard word	(always zero after normalization)   ei[3]   to ei[NI-2]	significand	(NI-4 significand words,  				 most significant word first,  				 most significant bit is set)   ei[NI-1]	low guard word	(0x8000 bit is rounding place)        		Routines for external format numbers    	asctoe (string, e)	ASCII string to extended double e type  	asctoe64 (string,&d)	ASCII string to long double  	asctoe53 (string,&d)	ASCII string to double  	asctoe24 (string,&f)	ASCII string to single  	asctoeg (string, e, prec) ASCII string to specified precision  	e24toe (&f, e)		IEEE single precision to e type  	e53toe (&d, e)		IEEE double precision to e type  	e64toe (&d, e)		IEEE long double precision to e type  	e113toe (&d, e)		128-bit long double precision to e type  	eabs (e)			absolute value  	eadd (a, b, c)		c = b + a  	eclear (e)		e = 0  	ecmp (a, b)		Returns 1 if a> b, 0 if a == b,  				-1 if a< b, -2 if either a or b is a NaN.  	ediv (a, b, c)		c = b / a  	efloor (a, b)		truncate to integer, toward -infinity  	efrexp (a, exp, s)	extract exponent and significand  	eifrac (e,&l, frac)    e to HOST_WIDE_INT and e type fraction  	euifrac (e,&l, frac)   e to unsigned HOST_WIDE_INT and e type fraction  	einfin (e)		set e to infinity, leaving its sign alone  	eldexp (a, n, b)	multiply by 2**n  	emov (a, b)		b = a  	emul (a, b, c)		c = b * a  	eneg (e)			e = -e  	eround (a, b)		b = nearest integer value to a  	esub (a, b, c)		c = b - a  	e24toasc (&f, str, n)	single to ASCII string, n digits after decimal  	e53toasc (&d, str, n)	double to ASCII string, n digits after decimal  	e64toasc (&d, str, n)	80-bit long double to ASCII string  	e113toasc (&d, str, n)	128-bit long double to ASCII string  	etoasc (e, str, n)	e to ASCII string, n digits after decimal  	etoe24 (e,&f)		convert e type to IEEE single precision  	etoe53 (e,&d)		convert e type to IEEE double precision  	etoe64 (e,&d)		convert e type to IEEE long double precision  	ltoe (&l, e)		HOST_WIDE_INT to e type  	ultoe (&l, e)		unsigned HOST_WIDE_INT to e type 	eisneg (e)              1 if sign bit of e != 0, else 0 	eisinf (e)              1 if e has maximum exponent (non-IEEE)  				or is infinite (IEEE)         eisnan (e)              1 if e is a NaN     		Routines for internal format numbers    	eaddm (ai, bi)		add significands, bi = bi + ai  	ecleaz (ei)		ei = 0  	ecleazs (ei)		set ei = 0 but leave its sign alone  	ecmpm (ai, bi)		compare significands, return 1, 0, or -1  	edivm (ai, bi)		divide  significands, bi = bi / ai  	emdnorm (ai,l,s,exp)	normalize and round off  	emovi (a, ai)		convert external a to internal ai  	emovo (ai, a)		convert internal ai to external a  	emovz (ai, bi)		bi = ai, low guard word of bi = 0  	emulm (ai, bi)		multiply significands, bi = bi * ai  	enormlz (ei)		left-justify the significand  	eshdn1 (ai)		shift significand and guards down 1 bit  	eshdn8 (ai)		shift down 8 bits  	eshdn6 (ai)		shift down 16 bits  	eshift (ai, n)		shift ai n bits up (or down if n< 0)  	eshup1 (ai)		shift significand and guards up 1 bit  	eshup8 (ai)		shift up 8 bits  	eshup6 (ai)		shift up 16 bits  	esubm (ai, bi)		subtract significands, bi = bi - ai         eiisinf (ai)            1 if infinite         eiisnan (ai)            1 if a NaN  	eiisneg (ai)		1 if sign bit of ai != 0, else 0         einan (ai)              set ai = NaN         eiinfin (ai)            set ai = infinity    The result is always normalized and rounded to NI-4 word precision   after each arithmetic operation.    Exception flags are NOT fully supported.     Signaling NaN's are NOT supported; they are treated the same   as quiet NaN's.     Define INFINITY for support of infinity; otherwise a   saturation arithmetic is implemented.     Define NANS for support of Not-a-Number items; otherwise the   arithmetic will never produce a NaN output, and might be confused   by a NaN input.   If NaN's are supported, the output of `ecmp (a,b)' is -2 if   either a or b is a NaN. This means asking `if (ecmp (a,b)< 0)'   may not be legitimate. Use `if (ecmp (a,b) == -1)' for `less than'   if in doubt.     Denormals are always supported here where appropriate (e.g., not   for conversion to DEC numbers).  */
end_comment

begin_comment
comment|/* Definitions for error codes that are passed to the common error handling    routine mtherr.     For Digital Equipment PDP-11 and VAX computers, certain   IBM systems, and others that use numbers with a 56-bit   significand, the symbol DEC should be defined.  In this   mode, most floating point constants are given as arrays   of octal integers to eliminate decimal to binary conversion   errors that might be introduced by the compiler.     For computers, such as IBM PC, that follow the IEEE   Standard for Binary Floating Point Arithmetic (ANSI/IEEE   Std 754-1985), the symbol IBMPC or MIEEE should be defined.   These numbers have 53-bit significands.  In this mode, constants   are provided as arrays of hexadecimal 16 bit integers.     To accommodate other types of computer arithmetic, all   constants are also provided in a normal decimal radix   which one can hope are correctly converted to a suitable   format by the available C language compiler.  To invoke   this mode, the symbol UNK is defined.     An important difference among these modes is a predefined   set of machine arithmetic constants for each.  The numbers   MACHEP (the machine roundoff error), MAXNUM (largest number   represented), and several other parameters are preset by   the configuration symbol.  Check the file const.c to   ensure that these values are correct for your computer.     For ANSI C compatibility, define ANSIC equal to 1.  Currently   this affects only the atan2 function and others that use it. */
end_comment

begin_comment
comment|/* Constant definitions for math error conditions.  */
end_comment

begin_define
define|#
directive|define
name|DOMAIN
value|1
end_define

begin_comment
comment|/* argument domain error */
end_comment

begin_define
define|#
directive|define
name|SING
value|2
end_define

begin_comment
comment|/* argument singularity */
end_comment

begin_define
define|#
directive|define
name|OVERFLOW
value|3
end_define

begin_comment
comment|/* overflow range error */
end_comment

begin_define
define|#
directive|define
name|UNDERFLOW
value|4
end_define

begin_comment
comment|/* underflow range error */
end_comment

begin_define
define|#
directive|define
name|TLOSS
value|5
end_define

begin_comment
comment|/* total loss of precision */
end_comment

begin_define
define|#
directive|define
name|PLOSS
value|6
end_define

begin_comment
comment|/* partial loss of precision */
end_comment

begin_define
define|#
directive|define
name|INVALID
value|7
end_define

begin_comment
comment|/* NaN-producing operation */
end_comment

begin_comment
comment|/*  e type constants used by high precision check routines */
end_comment

begin_if
if|#
directive|if
name|LONG_DOUBLE_TYPE_SIZE
operator|==
literal|128
end_if

begin_comment
comment|/* 0.0 */
end_comment

begin_decl_stmt
name|unsigned
name|EMUSHORT
name|ezero
index|[
name|NE
index|]
init|=
block|{
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
name|EMUSHORT
name|ezero
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 5.0E-1 */
end_comment

begin_decl_stmt
name|unsigned
name|EMUSHORT
name|ehalf
index|[
name|NE
index|]
init|=
block|{
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x8000
block|,
literal|0x3ffe
block|,}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
name|EMUSHORT
name|ehalf
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1.0E0 */
end_comment

begin_decl_stmt
name|unsigned
name|EMUSHORT
name|eone
index|[
name|NE
index|]
init|=
block|{
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x8000
block|,
literal|0x3fff
block|,}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
name|EMUSHORT
name|eone
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 2.0E0 */
end_comment

begin_decl_stmt
name|unsigned
name|EMUSHORT
name|etwo
index|[
name|NE
index|]
init|=
block|{
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x8000
block|,
literal|0x4000
block|,}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
name|EMUSHORT
name|etwo
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 3.2E1 */
end_comment

begin_decl_stmt
name|unsigned
name|EMUSHORT
name|e32
index|[
name|NE
index|]
init|=
block|{
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x8000
block|,
literal|0x4004
block|,}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
name|EMUSHORT
name|e32
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 6.93147180559945309417232121458176568075500134360255E-1 */
end_comment

begin_decl_stmt
name|unsigned
name|EMUSHORT
name|elog2
index|[
name|NE
index|]
init|=
block|{
literal|0x40f3
block|,
literal|0xf6af
block|,
literal|0x03f2
block|,
literal|0xb398
block|,
literal|0xc9e3
block|,
literal|0x79ab
block|,
literal|0150717
block|,
literal|0013767
block|,
literal|0130562
block|,
literal|0x3ffe
block|,}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
name|EMUSHORT
name|elog2
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1.41421356237309504880168872420969807856967187537695E0 */
end_comment

begin_decl_stmt
name|unsigned
name|EMUSHORT
name|esqrt2
index|[
name|NE
index|]
init|=
block|{
literal|0x1d6f
block|,
literal|0xbe9f
block|,
literal|0x754a
block|,
literal|0x89b3
block|,
literal|0x597d
block|,
literal|0x6484
block|,
literal|0174736
block|,
literal|0171463
block|,
literal|0132404
block|,
literal|0x3fff
block|,}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
name|EMUSHORT
name|esqrt2
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 3.14159265358979323846264338327950288419716939937511E0 */
end_comment

begin_decl_stmt
name|unsigned
name|EMUSHORT
name|epi
index|[
name|NE
index|]
init|=
block|{
literal|0x2902
block|,
literal|0x1cd1
block|,
literal|0x80dc
block|,
literal|0x628b
block|,
literal|0xc4c6
block|,
literal|0xc234
block|,
literal|0020550
block|,
literal|0155242
block|,
literal|0144417
block|,
literal|0040000
block|,}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
name|EMUSHORT
name|epi
index|[]
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* LONG_DOUBLE_TYPE_SIZE is other than 128 */
end_comment

begin_decl_stmt
name|unsigned
name|EMUSHORT
name|ezero
index|[
name|NE
index|]
init|=
block|{
literal|0
block|,
literal|0000000
block|,
literal|0000000
block|,
literal|0000000
block|,
literal|0000000
block|,
literal|0000000
block|,}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|EMUSHORT
name|ehalf
index|[
name|NE
index|]
init|=
block|{
literal|0
block|,
literal|0000000
block|,
literal|0000000
block|,
literal|0000000
block|,
literal|0100000
block|,
literal|0x3ffe
block|,}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|EMUSHORT
name|eone
index|[
name|NE
index|]
init|=
block|{
literal|0
block|,
literal|0000000
block|,
literal|0000000
block|,
literal|0000000
block|,
literal|0100000
block|,
literal|0x3fff
block|,}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|EMUSHORT
name|etwo
index|[
name|NE
index|]
init|=
block|{
literal|0
block|,
literal|0000000
block|,
literal|0000000
block|,
literal|0000000
block|,
literal|0100000
block|,
literal|0040000
block|,}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|EMUSHORT
name|e32
index|[
name|NE
index|]
init|=
block|{
literal|0
block|,
literal|0000000
block|,
literal|0000000
block|,
literal|0000000
block|,
literal|0100000
block|,
literal|0040004
block|,}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|EMUSHORT
name|elog2
index|[
name|NE
index|]
init|=
block|{
literal|0xc9e4
block|,
literal|0x79ab
block|,
literal|0150717
block|,
literal|0013767
block|,
literal|0130562
block|,
literal|0x3ffe
block|,}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|EMUSHORT
name|esqrt2
index|[
name|NE
index|]
init|=
block|{
literal|0x597e
block|,
literal|0x6484
block|,
literal|0174736
block|,
literal|0171463
block|,
literal|0132404
block|,
literal|0x3fff
block|,}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|EMUSHORT
name|epi
index|[
name|NE
index|]
init|=
block|{
literal|0xc4c6
block|,
literal|0xc234
block|,
literal|0020550
block|,
literal|0155242
block|,
literal|0144417
block|,
literal|0040000
block|,}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Control register for rounding precision.    This can be set to 113 (if NE=10), 80 (if NE=6), 64, 56, 53, or 24 bits.  */
end_comment

begin_decl_stmt
name|int
name|rndprc
init|=
name|NBITS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|rndprc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  Clear out entire external format number.  */
end_comment

begin_function
specifier|static
name|void
name|eclear
parameter_list|(
name|x
parameter_list|)
specifier|register
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NE
condition|;
name|i
operator|++
control|)
operator|*
name|x
operator|++
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Move external format number from a to b.  */
end_comment

begin_function
specifier|static
name|void
name|emov
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
specifier|register
name|unsigned
name|EMUSHORT
modifier|*
name|a
decl_stmt|,
decl|*
name|b
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NE
condition|;
name|i
operator|++
control|)
operator|*
name|b
operator|++
operator|=
operator|*
name|a
operator|++
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Absolute value of external format number.  */
end_comment

begin_function
specifier|static
name|void
name|eabs
parameter_list|(
name|x
parameter_list|)
name|unsigned
name|EMUSHORT
name|x
index|[]
decl_stmt|;
block|{
comment|/* sign is top bit of last word of external format */
name|x
index|[
name|NE
operator|-
literal|1
index|]
operator|&=
literal|0x7fff
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Negate external format number.  */
end_comment

begin_function
specifier|static
name|void
name|eneg
parameter_list|(
name|x
parameter_list|)
name|unsigned
name|EMUSHORT
name|x
index|[]
decl_stmt|;
block|{
name|x
index|[
name|NE
operator|-
literal|1
index|]
operator|^=
literal|0x8000
expr_stmt|;
comment|/* Toggle the sign bit */
block|}
end_function

begin_comment
comment|/* Return 1 if sign bit of external format number is nonzero, else zero.  */
end_comment

begin_function
specifier|static
name|int
name|eisneg
parameter_list|(
name|x
parameter_list|)
name|unsigned
name|EMUSHORT
name|x
index|[]
decl_stmt|;
block|{
if|if
condition|(
name|x
index|[
name|NE
operator|-
literal|1
index|]
operator|&
literal|0x8000
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if external format number is infinity, else return zero.  */
end_comment

begin_function
specifier|static
name|int
name|eisinf
parameter_list|(
name|x
parameter_list|)
name|unsigned
name|EMUSHORT
name|x
index|[]
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|NANS
if|if
condition|(
name|eisnan
argument_list|(
name|x
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|x
index|[
name|NE
operator|-
literal|1
index|]
operator|&
literal|0x7fff
operator|)
operator|==
literal|0x7fff
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Check if e-type number is not a number.  The bit pattern is one that we    defined, so we know for sure how to detect it.  */
end_comment

begin_function
specifier|static
name|int
name|eisnan
parameter_list|(
name|x
parameter_list|)
name|unsigned
name|EMUSHORT
name|x
index|[]
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|NANS
name|int
name|i
decl_stmt|;
comment|/* NaN has maximum exponent */
if|if
condition|(
operator|(
name|x
index|[
name|NE
operator|-
literal|1
index|]
operator|&
literal|0x7fff
operator|)
operator|!=
literal|0x7fff
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* ... and non-zero significand field. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NE
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|x
operator|++
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  Fill external format number with infinity pattern (IEEE)     or largest possible number (non-IEEE). */
end_comment

begin_function
specifier|static
name|void
name|einfin
parameter_list|(
name|x
parameter_list|)
specifier|register
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|INFINITY
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NE
operator|-
literal|1
condition|;
name|i
operator|++
control|)
operator|*
name|x
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|x
operator||=
literal|32767
expr_stmt|;
else|#
directive|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NE
operator|-
literal|1
condition|;
name|i
operator|++
control|)
operator|*
name|x
operator|++
operator|=
literal|0xffff
expr_stmt|;
operator|*
name|x
operator||=
literal|32766
expr_stmt|;
if|if
condition|(
name|rndprc
operator|<
name|NBITS
condition|)
block|{
if|if
condition|(
name|rndprc
operator|==
literal|113
condition|)
block|{
operator|*
operator|(
name|x
operator|-
literal|9
operator|)
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
name|x
operator|-
literal|8
operator|)
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|rndprc
operator|==
literal|64
condition|)
block|{
operator|*
operator|(
name|x
operator|-
literal|5
operator|)
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|rndprc
operator|==
literal|53
condition|)
block|{
operator|*
operator|(
name|x
operator|-
literal|4
operator|)
operator|=
literal|0xf800
expr_stmt|;
block|}
else|else
block|{
operator|*
operator|(
name|x
operator|-
literal|4
operator|)
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
name|x
operator|-
literal|3
operator|)
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
name|x
operator|-
literal|2
operator|)
operator|=
literal|0xff00
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Output an e-type NaN.    This generates Intel's quiet NaN pattern for extended real.    The exponent is 7fff, the leading mantissa word is c000.  */
end_comment

begin_function
specifier|static
name|void
name|enan
parameter_list|(
name|x
parameter_list|,
name|sign
parameter_list|)
specifier|register
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|;
name|int
name|sign
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NE
operator|-
literal|2
condition|;
name|i
operator|++
control|)
operator|*
name|x
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|x
operator|++
operator|=
literal|0xc000
expr_stmt|;
operator|*
name|x
operator|=
operator|(
name|sign
operator|<<
literal|15
operator|)
operator||
literal|0x7fff
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Move in external format number, converting it to internal format.  */
end_comment

begin_function
specifier|static
name|void
name|emovi
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|a
decl_stmt|,
decl|*
name|b
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|unsigned
name|EMUSHORT
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|int
name|i
decl_stmt|;
name|q
operator|=
name|b
expr_stmt|;
name|p
operator|=
name|a
operator|+
operator|(
name|NE
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* point to last word of external number */
comment|/* get the sign bit */
if|if
condition|(
operator|*
name|p
operator|&
literal|0x8000
condition|)
operator|*
name|q
operator|++
operator|=
literal|0xffff
expr_stmt|;
else|else
operator|*
name|q
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* get the exponent */
operator|*
name|q
operator|=
operator|*
name|p
operator|--
expr_stmt|;
operator|*
name|q
operator|++
operator|&=
literal|0x7fff
expr_stmt|;
comment|/* delete the sign bit */
ifdef|#
directive|ifdef
name|INFINITY
if|if
condition|(
operator|(
operator|*
operator|(
name|q
operator|-
literal|1
operator|)
operator|&
literal|0x7fff
operator|)
operator|==
literal|0x7fff
condition|)
block|{
ifdef|#
directive|ifdef
name|NANS
if|if
condition|(
name|eisnan
argument_list|(
name|a
argument_list|)
condition|)
block|{
operator|*
name|q
operator|++
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|3
init|;
name|i
operator|<
name|NI
condition|;
name|i
operator|++
control|)
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|--
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|NI
condition|;
name|i
operator|++
control|)
operator|*
name|q
operator|++
operator|=
literal|0
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* clear high guard word */
operator|*
name|q
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* move in the significand */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NE
operator|-
literal|1
condition|;
name|i
operator|++
control|)
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|--
expr_stmt|;
comment|/* clear low guard word */
operator|*
name|q
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Move internal format number out, converting it to external format.  */
end_comment

begin_function
specifier|static
name|void
name|emovo
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|a
decl_stmt|,
decl|*
name|b
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|unsigned
name|EMUSHORT
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|unsigned
name|EMUSHORT
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
name|p
operator|=
name|a
expr_stmt|;
name|q
operator|=
name|b
operator|+
operator|(
name|NE
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* point to output exponent */
comment|/* combine sign and exponent */
name|i
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|i
condition|)
operator|*
name|q
operator|--
operator|=
operator|*
name|p
operator|++
operator||
literal|0x8000
expr_stmt|;
else|else
operator|*
name|q
operator|--
operator|=
operator|*
name|p
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|INFINITY
if|if
condition|(
operator|*
operator|(
name|p
operator|-
literal|1
operator|)
operator|==
literal|0x7fff
condition|)
block|{
ifdef|#
directive|ifdef
name|NANS
if|if
condition|(
name|eiisnan
argument_list|(
name|a
argument_list|)
condition|)
block|{
name|enan
argument_list|(
name|b
argument_list|,
name|eiisneg
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|einfin
argument_list|(
name|b
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* skip over guard word */
operator|++
name|p
expr_stmt|;
comment|/* move the significand */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NE
operator|-
literal|1
condition|;
name|j
operator|++
control|)
operator|*
name|q
operator|--
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Clear out internal format number.  */
end_comment

begin_function
specifier|static
name|void
name|ecleaz
parameter_list|(
name|xi
parameter_list|)
specifier|register
name|unsigned
name|EMUSHORT
modifier|*
name|xi
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NI
condition|;
name|i
operator|++
control|)
operator|*
name|xi
operator|++
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Same, but don't touch the sign. */
end_comment

begin_function
specifier|static
name|void
name|ecleazs
parameter_list|(
name|xi
parameter_list|)
specifier|register
name|unsigned
name|EMUSHORT
modifier|*
name|xi
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
operator|++
name|xi
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NI
operator|-
literal|1
condition|;
name|i
operator|++
control|)
operator|*
name|xi
operator|++
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Move internal format number from a to b.  */
end_comment

begin_function
specifier|static
name|void
name|emovz
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
specifier|register
name|unsigned
name|EMUSHORT
modifier|*
name|a
decl_stmt|,
decl|*
name|b
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NI
operator|-
literal|1
condition|;
name|i
operator|++
control|)
operator|*
name|b
operator|++
operator|=
operator|*
name|a
operator|++
expr_stmt|;
comment|/* clear low guard word */
operator|*
name|b
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Generate internal format NaN.    The explicit pattern for this is maximum exponent and    top two significant bits set.  */
end_comment

begin_function
specifier|static
name|void
name|einan
parameter_list|(
name|x
parameter_list|)
name|unsigned
name|EMUSHORT
name|x
index|[]
decl_stmt|;
block|{
name|ecleaz
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|x
index|[
name|E
index|]
operator|=
literal|0x7fff
expr_stmt|;
name|x
index|[
name|M
operator|+
literal|1
index|]
operator|=
literal|0xc000
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return nonzero if internal format number is a NaN. */
end_comment

begin_function
specifier|static
name|int
name|eiisnan
parameter_list|(
name|x
parameter_list|)
name|unsigned
name|EMUSHORT
name|x
index|[]
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|x
index|[
name|E
index|]
operator|&
literal|0x7fff
operator|)
operator|==
literal|0x7fff
condition|)
block|{
for|for
control|(
name|i
operator|=
name|M
operator|+
literal|1
init|;
name|i
operator|<
name|NI
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|x
index|[
name|i
index|]
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if sign of internal format number is nonzero.  */
end_comment

begin_function
specifier|static
name|int
name|eiisneg
parameter_list|(
name|x
parameter_list|)
name|unsigned
name|EMUSHORT
name|x
index|[]
decl_stmt|;
block|{
return|return
name|x
index|[
literal|0
index|]
operator|!=
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Fill internal format number with infinity pattern.    This has maximum exponent and significand all zeros.  */
end_comment

begin_function
specifier|static
name|void
name|eiinfin
parameter_list|(
name|x
parameter_list|)
name|unsigned
name|EMUSHORT
name|x
index|[]
decl_stmt|;
block|{
name|ecleaz
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|x
index|[
name|E
index|]
operator|=
literal|0x7fff
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return nonzero if internal format number is infinite. */
end_comment

begin_function
specifier|static
name|int
name|eiisinf
parameter_list|(
name|x
parameter_list|)
name|unsigned
name|EMUSHORT
name|x
index|[]
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|NANS
if|if
condition|(
name|eiisnan
argument_list|(
name|x
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|x
index|[
name|E
index|]
operator|&
literal|0x7fff
operator|)
operator|==
literal|0x7fff
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Compare significands of numbers in internal format.    Guard words are included in the comparison.     Returns	+1 if a> b 		 0 if a == b 		-1 if a< b   */
end_comment

begin_function
specifier|static
name|int
name|ecmpm
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
specifier|register
name|unsigned
name|EMUSHORT
modifier|*
name|a
decl_stmt|,
decl|*
name|b
decl_stmt|;
end_function

begin_block
block|{
name|int
name|i
decl_stmt|;
name|a
operator|+=
name|M
expr_stmt|;
comment|/* skip up to significand area */
name|b
operator|+=
name|M
expr_stmt|;
for|for
control|(
name|i
operator|=
name|M
init|;
name|i
operator|<
name|NI
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|a
operator|++
operator|!=
operator|*
name|b
operator|++
condition|)
goto|goto
name|difrnt
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|difrnt
label|:
if|if
condition|(
operator|*
operator|(
operator|--
name|a
operator|)
operator|>
operator|*
operator|(
operator|--
name|b
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Shift significand down by 1 bit.  */
end_comment

begin_function
specifier|static
name|void
name|eshdn1
parameter_list|(
name|x
parameter_list|)
specifier|register
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|;
block|{
specifier|register
name|unsigned
name|EMUSHORT
name|bits
decl_stmt|;
name|int
name|i
decl_stmt|;
name|x
operator|+=
name|M
expr_stmt|;
comment|/* point to significand area */
name|bits
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|M
init|;
name|i
operator|<
name|NI
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|x
operator|&
literal|1
condition|)
name|bits
operator||=
literal|1
expr_stmt|;
operator|*
name|x
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|bits
operator|&
literal|2
condition|)
operator|*
name|x
operator||=
literal|0x8000
expr_stmt|;
name|bits
operator|<<=
literal|1
expr_stmt|;
operator|++
name|x
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Shift significand up by 1 bit.  */
end_comment

begin_function
specifier|static
name|void
name|eshup1
parameter_list|(
name|x
parameter_list|)
specifier|register
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|;
block|{
specifier|register
name|unsigned
name|EMUSHORT
name|bits
decl_stmt|;
name|int
name|i
decl_stmt|;
name|x
operator|+=
name|NI
operator|-
literal|1
expr_stmt|;
name|bits
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|M
init|;
name|i
operator|<
name|NI
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|x
operator|&
literal|0x8000
condition|)
name|bits
operator||=
literal|1
expr_stmt|;
operator|*
name|x
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|bits
operator|&
literal|2
condition|)
operator|*
name|x
operator||=
literal|1
expr_stmt|;
name|bits
operator|<<=
literal|1
expr_stmt|;
operator|--
name|x
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Shift significand down by 8 bits.  */
end_comment

begin_function
specifier|static
name|void
name|eshdn8
parameter_list|(
name|x
parameter_list|)
specifier|register
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|;
block|{
specifier|register
name|unsigned
name|EMUSHORT
name|newbyt
decl_stmt|,
name|oldbyt
decl_stmt|;
name|int
name|i
decl_stmt|;
name|x
operator|+=
name|M
expr_stmt|;
name|oldbyt
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|M
init|;
name|i
operator|<
name|NI
condition|;
name|i
operator|++
control|)
block|{
name|newbyt
operator|=
operator|*
name|x
operator|<<
literal|8
expr_stmt|;
operator|*
name|x
operator|>>=
literal|8
expr_stmt|;
operator|*
name|x
operator||=
name|oldbyt
expr_stmt|;
name|oldbyt
operator|=
name|newbyt
expr_stmt|;
operator|++
name|x
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Shift significand up by 8 bits.  */
end_comment

begin_function
specifier|static
name|void
name|eshup8
parameter_list|(
name|x
parameter_list|)
specifier|register
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
specifier|register
name|unsigned
name|EMUSHORT
name|newbyt
decl_stmt|,
name|oldbyt
decl_stmt|;
name|x
operator|+=
name|NI
operator|-
literal|1
expr_stmt|;
name|oldbyt
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|M
init|;
name|i
operator|<
name|NI
condition|;
name|i
operator|++
control|)
block|{
name|newbyt
operator|=
operator|*
name|x
operator|>>
literal|8
expr_stmt|;
operator|*
name|x
operator|<<=
literal|8
expr_stmt|;
operator|*
name|x
operator||=
name|oldbyt
expr_stmt|;
name|oldbyt
operator|=
name|newbyt
expr_stmt|;
operator|--
name|x
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Shift significand up by 16 bits.  */
end_comment

begin_function
specifier|static
name|void
name|eshup6
parameter_list|(
name|x
parameter_list|)
specifier|register
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
specifier|register
name|unsigned
name|EMUSHORT
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|x
operator|+
name|M
expr_stmt|;
name|x
operator|+=
name|M
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|M
init|;
name|i
operator|<
name|NI
operator|-
literal|1
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
operator|*
name|x
operator|++
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Shift significand down by 16 bits.  */
end_comment

begin_function
specifier|static
name|void
name|eshdn6
parameter_list|(
name|x
parameter_list|)
specifier|register
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
specifier|register
name|unsigned
name|EMUSHORT
modifier|*
name|p
decl_stmt|;
name|x
operator|+=
name|NI
operator|-
literal|1
expr_stmt|;
name|p
operator|=
name|x
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|M
init|;
name|i
operator|<
name|NI
operator|-
literal|1
condition|;
name|i
operator|++
control|)
operator|*
operator|(
operator|--
name|p
operator|)
operator|=
operator|*
operator|(
operator|--
name|x
operator|)
expr_stmt|;
operator|*
operator|(
operator|--
name|p
operator|)
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add significands.  x + y replaces y.  */
end_comment

begin_function
specifier|static
name|void
name|eaddm
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|,
decl|*
name|y
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|unsigned
name|EMULONG
name|a
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|carry
decl_stmt|;
name|x
operator|+=
name|NI
operator|-
literal|1
expr_stmt|;
name|y
operator|+=
name|NI
operator|-
literal|1
expr_stmt|;
name|carry
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|M
init|;
name|i
operator|<
name|NI
condition|;
name|i
operator|++
control|)
block|{
name|a
operator|=
call|(
name|unsigned
name|EMULONG
call|)
argument_list|(
operator|*
name|x
argument_list|)
operator|+
call|(
name|unsigned
name|EMULONG
call|)
argument_list|(
operator|*
name|y
argument_list|)
operator|+
name|carry
expr_stmt|;
if|if
condition|(
name|a
operator|&
literal|0x10000
condition|)
name|carry
operator|=
literal|1
expr_stmt|;
else|else
name|carry
operator|=
literal|0
expr_stmt|;
operator|*
name|y
operator|=
operator|(
name|unsigned
name|EMUSHORT
operator|)
name|a
expr_stmt|;
operator|--
name|x
expr_stmt|;
operator|--
name|y
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Subtract significands.  y - x replaces y.  */
end_comment

begin_function
specifier|static
name|void
name|esubm
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|,
decl|*
name|y
decl_stmt|;
end_function

begin_block
block|{
name|unsigned
name|EMULONG
name|a
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|carry
decl_stmt|;
name|x
operator|+=
name|NI
operator|-
literal|1
expr_stmt|;
name|y
operator|+=
name|NI
operator|-
literal|1
expr_stmt|;
name|carry
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|M
init|;
name|i
operator|<
name|NI
condition|;
name|i
operator|++
control|)
block|{
name|a
operator|=
call|(
name|unsigned
name|EMULONG
call|)
argument_list|(
operator|*
name|y
argument_list|)
operator|-
call|(
name|unsigned
name|EMULONG
call|)
argument_list|(
operator|*
name|x
argument_list|)
operator|-
name|carry
expr_stmt|;
if|if
condition|(
name|a
operator|&
literal|0x10000
condition|)
name|carry
operator|=
literal|1
expr_stmt|;
else|else
name|carry
operator|=
literal|0
expr_stmt|;
operator|*
name|y
operator|=
operator|(
name|unsigned
name|EMUSHORT
operator|)
name|a
expr_stmt|;
operator|--
name|x
expr_stmt|;
operator|--
name|y
expr_stmt|;
block|}
block|}
end_block

begin_decl_stmt
specifier|static
name|unsigned
name|EMUSHORT
name|equot
index|[
name|NI
index|]
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Radix 2 shift-and-add versions of multiply and divide  */
end_comment

begin_comment
comment|/* Divide significands */
end_comment

begin_comment
unit|int  edivm (den, num)      unsigned EMUSHORT den[], num[]; {   int i;   register unsigned EMUSHORT *p, *q;   unsigned EMUSHORT j;    p =&equot[0];   *p++ = num[0];   *p++ = num[1];    for (i = M; i< NI; i++)     {       *p++ = 0;     }
comment|/* Use faster compare and subtraction if denominator has only 15 bits of      significance.  */
end_comment

begin_comment
unit|p =&den[M + 2];   if (*p++ == 0)     {       for (i = M + 3; i< NI; i++) 	{ 	  if (*p++ != 0) 	    goto fulldiv; 	}       if ((den[M + 1]& 1) != 0) 	goto fulldiv;       eshdn1 (num);       eshdn1 (den);        p =&den[M + 1];       q =&num[M + 1];        for (i = 0; i< NBITS + 2; i++) 	{ 	  if (*p<= *q) 	    { 	      *q -= *p; 	      j = 1; 	    } 	  else 	    { 	      j = 0; 	    } 	  eshup1 (equot); 	  equot[NI - 2] |= j; 	  eshup1 (num); 	}       goto divdon;     }
comment|/* The number of quotient bits to calculate is NBITS + 1 scaling guard      bit + 1 roundoff bit.  */
end_comment

begin_comment
unit|fulldiv:    p =&equot[NI - 2];   for (i = 0; i< NBITS + 2; i++)     {       if (ecmpm (den, num)<= 0) 	{ 	  esubm (den, num); 	  j = 1;
comment|/* quotient bit = 1 */
end_comment

begin_comment
unit|}       else 	j = 0;       eshup1 (equot);       *p |= j;       eshup1 (num);     }   divdon:    eshdn1 (equot);   eshdn1 (equot);
comment|/* test for nonzero remainder after roundoff bit */
end_comment

begin_comment
unit|p =&num[M];   j = 0;   for (i = M; i< NI; i++)     {       j |= *p++;     }   if (j)     j = 1;     for (i = 0; i< NI; i++)     num[i] = equot[i];   return ((int) j); }
comment|/* Multiply significands */
end_comment

begin_comment
unit|int  emulm (a, b)      unsigned EMUSHORT a[], b[]; {   unsigned EMUSHORT *p, *q;   int i, j, k;    equot[0] = b[0];   equot[1] = b[1];   for (i = M; i< NI; i++)     equot[i] = 0;    p =&a[NI - 2];   k = NBITS;   while (*p == 0)
comment|/* significand is not supposed to be zero */
end_comment

begin_comment
unit|{       eshdn6 (a);       k -= 16;     }   if ((*p& 0xff) == 0)     {       eshdn8 (a);       k -= 8;     }    q =&equot[NI - 1];   j = 0;   for (i = 0; i< k; i++)     {       if (*p& 1) 	eaddm (b, equot);
comment|/* remember if there were any nonzero bits shifted out */
end_comment

begin_comment
unit|if (*q& 1) 	j |= 1;       eshdn1 (a);       eshdn1 (equot);     }    for (i = 0; i< NI; i++)     b[i] = equot[i];
comment|/* return flag for lost nonzero bits */
end_comment

begin_else
unit|return (j); }
else|#
directive|else
end_else

begin_comment
comment|/* Radix 65536 versions of multiply and divide  */
end_comment

begin_comment
comment|/* Multiply significand of e-type number b    by 16-bit quantity a, e-type result to c. */
end_comment

begin_decl_stmt
specifier|static
name|void
name|m16m
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|)
name|unsigned
name|int
name|a
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|short
name|b
index|[]
decl_stmt|,
name|c
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|unsigned
name|short
modifier|*
name|pp
decl_stmt|;
specifier|register
name|unsigned
name|long
name|carry
decl_stmt|;
name|unsigned
name|short
modifier|*
name|ps
decl_stmt|;
name|unsigned
name|short
name|p
index|[
name|NI
index|]
decl_stmt|;
name|unsigned
name|long
name|aa
decl_stmt|,
name|m
decl_stmt|;
name|int
name|i
decl_stmt|;
name|aa
operator|=
name|a
expr_stmt|;
name|pp
operator|=
operator|&
name|p
index|[
name|NI
operator|-
literal|2
index|]
expr_stmt|;
operator|*
name|pp
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|pp
operator|=
literal|0
expr_stmt|;
name|ps
operator|=
operator|&
name|b
index|[
name|NI
operator|-
literal|1
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|M
operator|+
literal|1
init|;
name|i
operator|<
name|NI
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|ps
operator|==
literal|0
condition|)
block|{
operator|--
name|ps
expr_stmt|;
operator|--
name|pp
expr_stmt|;
operator|*
operator|(
name|pp
operator|-
literal|1
operator|)
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|m
operator|=
operator|(
name|unsigned
name|long
operator|)
name|aa
operator|*
operator|*
name|ps
operator|--
expr_stmt|;
name|carry
operator|=
operator|(
name|m
operator|&
literal|0xffff
operator|)
operator|+
operator|*
name|pp
expr_stmt|;
operator|*
name|pp
operator|--
operator|=
operator|(
name|unsigned
name|short
operator|)
name|carry
expr_stmt|;
name|carry
operator|=
operator|(
name|carry
operator|>>
literal|16
operator|)
operator|+
operator|(
name|m
operator|>>
literal|16
operator|)
operator|+
operator|*
name|pp
expr_stmt|;
operator|*
name|pp
operator|=
operator|(
name|unsigned
name|short
operator|)
name|carry
expr_stmt|;
operator|*
operator|(
name|pp
operator|-
literal|1
operator|)
operator|=
name|carry
operator|>>
literal|16
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
name|M
init|;
name|i
operator|<
name|NI
condition|;
name|i
operator|++
control|)
name|c
index|[
name|i
index|]
operator|=
name|p
index|[
name|i
index|]
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Divide significands. Neither the numerator nor the denominator    is permitted to have its high guard word nonzero.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|edivm
argument_list|(
name|den
argument_list|,
name|num
argument_list|)
name|unsigned
name|short
name|den
index|[]
decl_stmt|,
name|num
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
specifier|register
name|unsigned
name|short
modifier|*
name|p
decl_stmt|;
name|unsigned
name|long
name|tnum
decl_stmt|;
name|unsigned
name|short
name|j
decl_stmt|,
name|tdenm
decl_stmt|,
name|tquot
decl_stmt|;
name|unsigned
name|short
name|tprod
index|[
name|NI
operator|+
literal|1
index|]
decl_stmt|;
name|p
operator|=
operator|&
name|equot
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|num
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|num
index|[
literal|1
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|M
init|;
name|i
operator|<
name|NI
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
block|}
name|eshdn1
argument_list|(
name|num
argument_list|)
expr_stmt|;
name|tdenm
operator|=
name|den
index|[
name|M
operator|+
literal|1
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|M
init|;
name|i
operator|<
name|NI
condition|;
name|i
operator|++
control|)
block|{
comment|/* Find trial quotient digit (the radix is 65536). */
name|tnum
operator|=
operator|(
operator|(
operator|(
name|unsigned
name|long
operator|)
name|num
index|[
name|M
index|]
operator|)
operator|<<
literal|16
operator|)
operator|+
name|num
index|[
name|M
operator|+
literal|1
index|]
expr_stmt|;
comment|/* Do not execute the divide instruction if it will overflow. */
if|if
condition|(
operator|(
name|tdenm
operator|*
literal|0xffffL
operator|)
operator|<
name|tnum
condition|)
name|tquot
operator|=
literal|0xffff
expr_stmt|;
else|else
name|tquot
operator|=
name|tnum
operator|/
name|tdenm
expr_stmt|;
comment|/* Multiply denominator by trial quotient digit. */
name|m16m
argument_list|(
operator|(
name|unsigned
name|int
operator|)
name|tquot
argument_list|,
name|den
argument_list|,
name|tprod
argument_list|)
expr_stmt|;
comment|/* The quotient digit may have been overestimated. */
if|if
condition|(
name|ecmpm
argument_list|(
name|tprod
argument_list|,
name|num
argument_list|)
operator|>
literal|0
condition|)
block|{
name|tquot
operator|-=
literal|1
expr_stmt|;
name|esubm
argument_list|(
name|den
argument_list|,
name|tprod
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecmpm
argument_list|(
name|tprod
argument_list|,
name|num
argument_list|)
operator|>
literal|0
condition|)
block|{
name|tquot
operator|-=
literal|1
expr_stmt|;
name|esubm
argument_list|(
name|den
argument_list|,
name|tprod
argument_list|)
expr_stmt|;
block|}
block|}
name|esubm
argument_list|(
name|tprod
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|equot
index|[
name|i
index|]
operator|=
name|tquot
expr_stmt|;
name|eshup6
argument_list|(
name|num
argument_list|)
expr_stmt|;
block|}
comment|/* test for nonzero remainder after roundoff bit */
name|p
operator|=
operator|&
name|num
index|[
name|M
index|]
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|M
init|;
name|i
operator|<
name|NI
condition|;
name|i
operator|++
control|)
block|{
name|j
operator||=
operator|*
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|j
condition|)
name|j
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NI
condition|;
name|i
operator|++
control|)
name|num
index|[
name|i
index|]
operator|=
name|equot
index|[
name|i
index|]
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|j
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Multiply significands */
end_comment

begin_decl_stmt
specifier|static
name|int
name|emulm
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
name|unsigned
name|short
name|a
index|[]
decl_stmt|,
name|b
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|unsigned
name|short
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|unsigned
name|short
name|pprod
index|[
name|NI
index|]
decl_stmt|;
name|unsigned
name|short
name|j
decl_stmt|;
name|int
name|i
decl_stmt|;
name|equot
index|[
literal|0
index|]
operator|=
name|b
index|[
literal|0
index|]
expr_stmt|;
name|equot
index|[
literal|1
index|]
operator|=
name|b
index|[
literal|1
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|M
init|;
name|i
operator|<
name|NI
condition|;
name|i
operator|++
control|)
name|equot
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
name|p
operator|=
operator|&
name|a
index|[
name|NI
operator|-
literal|1
index|]
expr_stmt|;
name|q
operator|=
operator|&
name|equot
index|[
name|NI
operator|-
literal|1
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|M
operator|+
literal|1
init|;
name|i
operator|<
name|NI
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
block|{
operator|--
name|p
expr_stmt|;
block|}
else|else
block|{
name|m16m
argument_list|(
operator|(
name|unsigned
name|int
operator|)
operator|*
name|p
operator|--
argument_list|,
name|b
argument_list|,
name|pprod
argument_list|)
expr_stmt|;
name|eaddm
argument_list|(
name|pprod
argument_list|,
name|equot
argument_list|)
expr_stmt|;
block|}
name|j
operator||=
operator|*
name|q
expr_stmt|;
name|eshdn6
argument_list|(
name|equot
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NI
condition|;
name|i
operator|++
control|)
name|b
index|[
name|i
index|]
operator|=
name|equot
index|[
name|i
index|]
expr_stmt|;
comment|/* return flag for lost nonzero bits */
return|return
operator|(
operator|(
name|int
operator|)
name|j
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Normalize and round off.    The internal format number to be rounded is "s".   Input "lost" indicates whether or not the number is exact.   This is the so-called sticky bit.     Input "subflg" indicates whether the number was obtained   by a subtraction operation.  In that case if lost is nonzero   then the number is slightly smaller than indicated.     Input "exp" is the biased exponent, which may be negative.   the exponent field of "s" is ignored but is replaced by   "exp" as adjusted by normalization and rounding.     Input "rcntrl" is the rounding control.    For future reference:  In order for emdnorm to round off denormal    significands at the right point, the input exponent must be    adjusted to be the actual value it would have after conversion to    the final floating point type.  This adjustment has been    implemented for all type conversions (etoe53, etc.) and decimal    conversions, but not for the arithmetic functions (eadd, etc.).     Data types having standard 15-bit exponents are not affected by    this, but SFmode and DFmode are affected. For example, ediv with    rndprc = 24 will not round correctly to 24-bit precision if the    result is denormal.   */
end_comment

begin_decl_stmt
specifier|static
name|int
name|rlast
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rw
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|EMUSHORT
name|rmsk
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|EMUSHORT
name|rmbit
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|EMUSHORT
name|rebit
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|re
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|EMUSHORT
name|rbit
index|[
name|NI
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|emdnorm
parameter_list|(
name|s
parameter_list|,
name|lost
parameter_list|,
name|subflg
parameter_list|,
name|exp
parameter_list|,
name|rcntrl
parameter_list|)
name|unsigned
name|EMUSHORT
name|s
index|[]
decl_stmt|;
name|int
name|lost
decl_stmt|;
name|int
name|subflg
decl_stmt|;
name|EMULONG
name|exp
decl_stmt|;
name|int
name|rcntrl
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|unsigned
name|EMUSHORT
name|r
decl_stmt|;
comment|/* Normalize */
name|j
operator|=
name|enormlz
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* a blank significand could mean either zero or infinity. */
ifndef|#
directive|ifndef
name|INFINITY
if|if
condition|(
name|j
operator|>
name|NBITS
condition|)
block|{
name|ecleazs
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|exp
operator|-=
name|j
expr_stmt|;
ifndef|#
directive|ifndef
name|INFINITY
if|if
condition|(
name|exp
operator|>=
literal|32767L
condition|)
goto|goto
name|overf
goto|;
else|#
directive|else
if|if
condition|(
operator|(
name|j
operator|>
name|NBITS
operator|)
operator|&&
operator|(
name|exp
operator|<
literal|32767
operator|)
condition|)
block|{
name|ecleazs
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
if|if
condition|(
name|exp
operator|<
literal|0L
condition|)
block|{
if|if
condition|(
name|exp
operator|>
call|(
name|EMULONG
call|)
argument_list|(
operator|-
name|NBITS
operator|-
literal|1
argument_list|)
condition|)
block|{
name|j
operator|=
operator|(
name|int
operator|)
name|exp
expr_stmt|;
name|i
operator|=
name|eshift
argument_list|(
name|s
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
name|lost
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ecleazs
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Round off, unless told not to by rcntrl. */
if|if
condition|(
name|rcntrl
operator|==
literal|0
condition|)
goto|goto
name|mdfin
goto|;
comment|/* Set up rounding parameters if the control register changed. */
if|if
condition|(
name|rndprc
operator|!=
name|rlast
condition|)
block|{
name|ecleaz
argument_list|(
name|rbit
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rndprc
condition|)
block|{
default|default:
case|case
name|NBITS
case|:
name|rw
operator|=
name|NI
operator|-
literal|1
expr_stmt|;
comment|/* low guard word */
name|rmsk
operator|=
literal|0xffff
expr_stmt|;
name|rmbit
operator|=
literal|0x8000
expr_stmt|;
name|re
operator|=
name|rw
operator|-
literal|1
expr_stmt|;
name|rebit
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|113
case|:
name|rw
operator|=
literal|10
expr_stmt|;
name|rmsk
operator|=
literal|0x7fff
expr_stmt|;
name|rmbit
operator|=
literal|0x4000
expr_stmt|;
name|rebit
operator|=
literal|0x8000
expr_stmt|;
name|re
operator|=
name|rw
expr_stmt|;
break|break;
case|case
literal|64
case|:
name|rw
operator|=
literal|7
expr_stmt|;
name|rmsk
operator|=
literal|0xffff
expr_stmt|;
name|rmbit
operator|=
literal|0x8000
expr_stmt|;
name|re
operator|=
name|rw
operator|-
literal|1
expr_stmt|;
name|rebit
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* For DEC or IBM arithmetic */
case|case
literal|56
case|:
name|rw
operator|=
literal|6
expr_stmt|;
name|rmsk
operator|=
literal|0xff
expr_stmt|;
name|rmbit
operator|=
literal|0x80
expr_stmt|;
name|rebit
operator|=
literal|0x100
expr_stmt|;
name|re
operator|=
name|rw
expr_stmt|;
break|break;
case|case
literal|53
case|:
name|rw
operator|=
literal|6
expr_stmt|;
name|rmsk
operator|=
literal|0x7ff
expr_stmt|;
name|rmbit
operator|=
literal|0x0400
expr_stmt|;
name|rebit
operator|=
literal|0x800
expr_stmt|;
name|re
operator|=
name|rw
expr_stmt|;
break|break;
case|case
literal|24
case|:
name|rw
operator|=
literal|4
expr_stmt|;
name|rmsk
operator|=
literal|0xff
expr_stmt|;
name|rmbit
operator|=
literal|0x80
expr_stmt|;
name|rebit
operator|=
literal|0x100
expr_stmt|;
name|re
operator|=
name|rw
expr_stmt|;
break|break;
block|}
name|rbit
index|[
name|re
index|]
operator|=
name|rebit
expr_stmt|;
name|rlast
operator|=
name|rndprc
expr_stmt|;
block|}
comment|/* Shift down 1 temporarily if the data structure has an implied      most significant bit and the number is denormal.  */
if|if
condition|(
operator|(
name|exp
operator|<=
literal|0
operator|)
operator|&&
operator|(
name|rndprc
operator|!=
literal|64
operator|)
operator|&&
operator|(
name|rndprc
operator|!=
name|NBITS
operator|)
condition|)
block|{
name|lost
operator||=
name|s
index|[
name|NI
operator|-
literal|1
index|]
operator|&
literal|1
expr_stmt|;
name|eshdn1
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
comment|/* Clear out all bits below the rounding bit,      remembering in r if any were nonzero.  */
name|r
operator|=
name|s
index|[
name|rw
index|]
operator|&
name|rmsk
expr_stmt|;
if|if
condition|(
name|rndprc
operator|<
name|NBITS
condition|)
block|{
name|i
operator|=
name|rw
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|NI
condition|)
block|{
if|if
condition|(
name|s
index|[
name|i
index|]
condition|)
name|r
operator||=
literal|1
expr_stmt|;
name|s
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
block|}
name|s
index|[
name|rw
index|]
operator|&=
operator|~
name|rmsk
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|&
name|rmbit
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|r
operator|==
name|rmbit
condition|)
block|{
if|if
condition|(
name|lost
operator|==
literal|0
condition|)
block|{
comment|/* round to even */
if|if
condition|(
operator|(
name|s
index|[
name|re
index|]
operator|&
name|rebit
operator|)
operator|==
literal|0
condition|)
goto|goto
name|mddone
goto|;
block|}
else|else
block|{
if|if
condition|(
name|subflg
operator|!=
literal|0
condition|)
goto|goto
name|mddone
goto|;
block|}
block|}
name|eaddm
argument_list|(
name|rbit
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
name|mddone
label|:
if|if
condition|(
operator|(
name|exp
operator|<=
literal|0
operator|)
operator|&&
operator|(
name|rndprc
operator|!=
literal|64
operator|)
operator|&&
operator|(
name|rndprc
operator|!=
name|NBITS
operator|)
condition|)
block|{
name|eshup1
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s
index|[
literal|2
index|]
operator|!=
literal|0
condition|)
block|{
comment|/* overflow on roundoff */
name|eshdn1
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|exp
operator|+=
literal|1
expr_stmt|;
block|}
name|mdfin
label|:
name|s
index|[
name|NI
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|exp
operator|>=
literal|32767L
condition|)
block|{
ifndef|#
directive|ifndef
name|INFINITY
name|overf
label|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INFINITY
name|s
index|[
literal|1
index|]
operator|=
literal|32767
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|NI
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|s
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|extra_warnings
condition|)
name|warning
argument_list|(
literal|"floating point overflow"
argument_list|)
expr_stmt|;
else|#
directive|else
name|s
index|[
literal|1
index|]
operator|=
literal|32766
expr_stmt|;
name|s
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|M
operator|+
literal|1
init|;
name|i
operator|<
name|NI
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|s
index|[
name|i
index|]
operator|=
literal|0xffff
expr_stmt|;
name|s
index|[
name|NI
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|rndprc
operator|<
literal|64
operator|)
operator|||
operator|(
name|rndprc
operator|==
literal|113
operator|)
condition|)
block|{
name|s
index|[
name|rw
index|]
operator|&=
operator|~
name|rmsk
expr_stmt|;
if|if
condition|(
name|rndprc
operator|==
literal|24
condition|)
block|{
name|s
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
name|s
index|[
literal|6
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
endif|#
directive|endif
return|return;
block|}
if|if
condition|(
name|exp
operator|<
literal|0
condition|)
name|s
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
else|else
name|s
index|[
literal|1
index|]
operator|=
operator|(
name|unsigned
name|EMUSHORT
operator|)
name|exp
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  Subtract external format numbers.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|subflg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|esub
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|a
decl_stmt|,
decl|*
name|b
decl_stmt|,
modifier|*
name|c
decl_stmt|;
end_function

begin_block
block|{
ifdef|#
directive|ifdef
name|NANS
if|if
condition|(
name|eisnan
argument_list|(
name|a
argument_list|)
condition|)
block|{
name|emov
argument_list|(
name|a
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|eisnan
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|emov
argument_list|(
name|b
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Infinity minus infinity is a NaN.    Test for subtracting infinities of the same sign. */
if|if
condition|(
name|eisinf
argument_list|(
name|a
argument_list|)
operator|&&
name|eisinf
argument_list|(
name|b
argument_list|)
operator|&&
operator|(
operator|(
name|eisneg
argument_list|(
name|a
argument_list|)
operator|^
name|eisneg
argument_list|(
name|b
argument_list|)
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|mtherr
argument_list|(
literal|"esub"
argument_list|,
name|INVALID
argument_list|)
expr_stmt|;
name|enan
argument_list|(
name|c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|subflg
operator|=
literal|1
expr_stmt|;
name|eadd1
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Add.  */
end_comment

begin_function
specifier|static
name|void
name|eadd
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|a
decl_stmt|,
decl|*
name|b
decl_stmt|,
modifier|*
name|c
decl_stmt|;
end_function

begin_block
block|{
ifdef|#
directive|ifdef
name|NANS
comment|/* NaN plus anything is a NaN. */
if|if
condition|(
name|eisnan
argument_list|(
name|a
argument_list|)
condition|)
block|{
name|emov
argument_list|(
name|a
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|eisnan
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|emov
argument_list|(
name|b
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Infinity minus infinity is a NaN.    Test for adding infinities of opposite signs. */
if|if
condition|(
name|eisinf
argument_list|(
name|a
argument_list|)
operator|&&
name|eisinf
argument_list|(
name|b
argument_list|)
operator|&&
operator|(
operator|(
name|eisneg
argument_list|(
name|a
argument_list|)
operator|^
name|eisneg
argument_list|(
name|b
argument_list|)
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|mtherr
argument_list|(
literal|"esub"
argument_list|,
name|INVALID
argument_list|)
expr_stmt|;
name|enan
argument_list|(
name|c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|subflg
operator|=
literal|0
expr_stmt|;
name|eadd1
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|void
name|eadd1
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|a
decl_stmt|,
decl|*
name|b
decl_stmt|,
modifier|*
name|c
decl_stmt|;
end_function

begin_block
block|{
name|unsigned
name|EMUSHORT
name|ai
index|[
name|NI
index|]
decl_stmt|,
name|bi
index|[
name|NI
index|]
decl_stmt|,
name|ci
index|[
name|NI
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|lost
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|EMULONG
name|lt
decl_stmt|,
name|lta
decl_stmt|,
name|ltb
decl_stmt|;
ifdef|#
directive|ifdef
name|INFINITY
if|if
condition|(
name|eisinf
argument_list|(
name|a
argument_list|)
condition|)
block|{
name|emov
argument_list|(
name|a
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|subflg
condition|)
name|eneg
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|eisinf
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|emov
argument_list|(
name|b
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|emovi
argument_list|(
name|a
argument_list|,
name|ai
argument_list|)
expr_stmt|;
name|emovi
argument_list|(
name|b
argument_list|,
name|bi
argument_list|)
expr_stmt|;
if|if
condition|(
name|subflg
condition|)
name|ai
index|[
literal|0
index|]
operator|=
operator|~
name|ai
index|[
literal|0
index|]
expr_stmt|;
comment|/* compare exponents */
name|lta
operator|=
name|ai
index|[
name|E
index|]
expr_stmt|;
name|ltb
operator|=
name|bi
index|[
name|E
index|]
expr_stmt|;
name|lt
operator|=
name|lta
operator|-
name|ltb
expr_stmt|;
if|if
condition|(
name|lt
operator|>
literal|0L
condition|)
block|{
comment|/* put the larger number in bi */
name|emovz
argument_list|(
name|bi
argument_list|,
name|ci
argument_list|)
expr_stmt|;
name|emovz
argument_list|(
name|ai
argument_list|,
name|bi
argument_list|)
expr_stmt|;
name|emovz
argument_list|(
name|ci
argument_list|,
name|ai
argument_list|)
expr_stmt|;
name|ltb
operator|=
name|bi
index|[
name|E
index|]
expr_stmt|;
name|lt
operator|=
operator|-
name|lt
expr_stmt|;
block|}
name|lost
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|lt
operator|!=
literal|0L
condition|)
block|{
if|if
condition|(
name|lt
operator|<
call|(
name|EMULONG
call|)
argument_list|(
operator|-
name|NBITS
operator|-
literal|1
argument_list|)
condition|)
goto|goto
name|done
goto|;
comment|/* answer same as larger addend */
name|k
operator|=
operator|(
name|int
operator|)
name|lt
expr_stmt|;
name|lost
operator|=
name|eshift
argument_list|(
name|ai
argument_list|,
name|k
argument_list|)
expr_stmt|;
comment|/* shift the smaller number down */
block|}
else|else
block|{
comment|/* exponents were the same, so must compare significands */
name|i
operator|=
name|ecmpm
argument_list|(
name|ai
argument_list|,
name|bi
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
comment|/* the numbers are identical in magnitude */
comment|/* if different signs, result is zero */
if|if
condition|(
name|ai
index|[
literal|0
index|]
operator|!=
name|bi
index|[
literal|0
index|]
condition|)
block|{
name|eclear
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* if same sign, result is double */
comment|/* double denomalized tiny number */
if|if
condition|(
operator|(
name|bi
index|[
name|E
index|]
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|bi
index|[
literal|3
index|]
operator|&
literal|0x8000
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|eshup1
argument_list|(
name|bi
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* add 1 to exponent unless both are zero! */
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|NI
operator|-
literal|1
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|bi
index|[
name|j
index|]
operator|!=
literal|0
condition|)
block|{
comment|/* This could overflow, but let emovo take care of that. */
name|ltb
operator|+=
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|bi
index|[
name|E
index|]
operator|=
operator|(
name|unsigned
name|EMUSHORT
operator|)
name|ltb
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
comment|/* put the larger number in bi */
name|emovz
argument_list|(
name|bi
argument_list|,
name|ci
argument_list|)
expr_stmt|;
name|emovz
argument_list|(
name|ai
argument_list|,
name|bi
argument_list|)
expr_stmt|;
name|emovz
argument_list|(
name|ci
argument_list|,
name|ai
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ai
index|[
literal|0
index|]
operator|==
name|bi
index|[
literal|0
index|]
condition|)
block|{
name|eaddm
argument_list|(
name|ai
argument_list|,
name|bi
argument_list|)
expr_stmt|;
name|subflg
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|esubm
argument_list|(
name|ai
argument_list|,
name|bi
argument_list|)
expr_stmt|;
name|subflg
operator|=
literal|1
expr_stmt|;
block|}
name|emdnorm
argument_list|(
name|bi
argument_list|,
name|lost
argument_list|,
name|subflg
argument_list|,
name|ltb
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|done
label|:
name|emovo
argument_list|(
name|bi
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Divide.  */
end_comment

begin_function
specifier|static
name|void
name|ediv
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|a
decl_stmt|,
decl|*
name|b
decl_stmt|,
modifier|*
name|c
decl_stmt|;
end_function

begin_block
block|{
name|unsigned
name|EMUSHORT
name|ai
index|[
name|NI
index|]
decl_stmt|,
name|bi
index|[
name|NI
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|EMULONG
name|lt
decl_stmt|,
name|lta
decl_stmt|,
name|ltb
decl_stmt|;
ifdef|#
directive|ifdef
name|NANS
comment|/* Return any NaN input. */
if|if
condition|(
name|eisnan
argument_list|(
name|a
argument_list|)
condition|)
block|{
name|emov
argument_list|(
name|a
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|eisnan
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|emov
argument_list|(
name|b
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Zero over zero, or infinity over infinity, is a NaN. */
if|if
condition|(
operator|(
operator|(
name|ecmp
argument_list|(
name|a
argument_list|,
name|ezero
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|ecmp
argument_list|(
name|b
argument_list|,
name|ezero
argument_list|)
operator|==
literal|0
operator|)
operator|)
operator|||
operator|(
name|eisinf
argument_list|(
name|a
argument_list|)
operator|&&
name|eisinf
argument_list|(
name|b
argument_list|)
operator|)
condition|)
block|{
name|mtherr
argument_list|(
literal|"ediv"
argument_list|,
name|INVALID
argument_list|)
expr_stmt|;
name|enan
argument_list|(
name|c
argument_list|,
name|eisneg
argument_list|(
name|a
argument_list|)
operator|^
name|eisneg
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* Infinity over anything else is infinity. */
ifdef|#
directive|ifdef
name|INFINITY
if|if
condition|(
name|eisinf
argument_list|(
name|b
argument_list|)
condition|)
block|{
if|if
condition|(
name|eisneg
argument_list|(
name|a
argument_list|)
operator|^
name|eisneg
argument_list|(
name|b
argument_list|)
condition|)
operator|*
operator|(
name|c
operator|+
operator|(
name|NE
operator|-
literal|1
operator|)
operator|)
operator|=
literal|0x8000
expr_stmt|;
else|else
operator|*
operator|(
name|c
operator|+
operator|(
name|NE
operator|-
literal|1
operator|)
operator|)
operator|=
literal|0
expr_stmt|;
name|einfin
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Anything else over infinity is zero. */
if|if
condition|(
name|eisinf
argument_list|(
name|a
argument_list|)
condition|)
block|{
name|eclear
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|emovi
argument_list|(
name|a
argument_list|,
name|ai
argument_list|)
expr_stmt|;
name|emovi
argument_list|(
name|b
argument_list|,
name|bi
argument_list|)
expr_stmt|;
name|lta
operator|=
name|ai
index|[
name|E
index|]
expr_stmt|;
name|ltb
operator|=
name|bi
index|[
name|E
index|]
expr_stmt|;
if|if
condition|(
name|bi
index|[
name|E
index|]
operator|==
literal|0
condition|)
block|{
comment|/* See if numerator is zero. */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NI
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bi
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|ltb
operator|-=
name|enormlz
argument_list|(
name|bi
argument_list|)
expr_stmt|;
goto|goto
name|dnzro1
goto|;
block|}
block|}
name|eclear
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
name|dnzro1
label|:
if|if
condition|(
name|ai
index|[
name|E
index|]
operator|==
literal|0
condition|)
block|{
comment|/* possible divide by zero */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NI
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ai
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|lta
operator|-=
name|enormlz
argument_list|(
name|ai
argument_list|)
expr_stmt|;
goto|goto
name|dnzro2
goto|;
block|}
block|}
if|if
condition|(
name|ai
index|[
literal|0
index|]
operator|==
name|bi
index|[
literal|0
index|]
condition|)
operator|*
operator|(
name|c
operator|+
operator|(
name|NE
operator|-
literal|1
operator|)
operator|)
operator|=
literal|0
expr_stmt|;
else|else
operator|*
operator|(
name|c
operator|+
operator|(
name|NE
operator|-
literal|1
operator|)
operator|)
operator|=
literal|0x8000
expr_stmt|;
comment|/* Divide by zero is not an invalid operation.    It is a divide-by-zero operation!   */
name|einfin
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|mtherr
argument_list|(
literal|"ediv"
argument_list|,
name|SING
argument_list|)
expr_stmt|;
return|return;
block|}
name|dnzro2
label|:
name|i
operator|=
name|edivm
argument_list|(
name|ai
argument_list|,
name|bi
argument_list|)
expr_stmt|;
comment|/* calculate exponent */
name|lt
operator|=
name|ltb
operator|-
name|lta
operator|+
name|EXONE
expr_stmt|;
name|emdnorm
argument_list|(
name|bi
argument_list|,
name|i
argument_list|,
literal|0
argument_list|,
name|lt
argument_list|,
literal|64
argument_list|)
expr_stmt|;
comment|/* set the sign */
if|if
condition|(
name|ai
index|[
literal|0
index|]
operator|==
name|bi
index|[
literal|0
index|]
condition|)
name|bi
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
else|else
name|bi
index|[
literal|0
index|]
operator|=
literal|0Xffff
expr_stmt|;
name|emovo
argument_list|(
name|bi
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Multiply.  */
end_comment

begin_function
specifier|static
name|void
name|emul
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|a
decl_stmt|,
decl|*
name|b
decl_stmt|,
modifier|*
name|c
decl_stmt|;
end_function

begin_block
block|{
name|unsigned
name|EMUSHORT
name|ai
index|[
name|NI
index|]
decl_stmt|,
name|bi
index|[
name|NI
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|EMULONG
name|lt
decl_stmt|,
name|lta
decl_stmt|,
name|ltb
decl_stmt|;
ifdef|#
directive|ifdef
name|NANS
comment|/* NaN times anything is the same NaN. */
if|if
condition|(
name|eisnan
argument_list|(
name|a
argument_list|)
condition|)
block|{
name|emov
argument_list|(
name|a
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|eisnan
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|emov
argument_list|(
name|b
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Zero times infinity is a NaN. */
if|if
condition|(
operator|(
name|eisinf
argument_list|(
name|a
argument_list|)
operator|&&
operator|(
name|ecmp
argument_list|(
name|b
argument_list|,
name|ezero
argument_list|)
operator|==
literal|0
operator|)
operator|)
operator|||
operator|(
name|eisinf
argument_list|(
name|b
argument_list|)
operator|&&
operator|(
name|ecmp
argument_list|(
name|a
argument_list|,
name|ezero
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|mtherr
argument_list|(
literal|"emul"
argument_list|,
name|INVALID
argument_list|)
expr_stmt|;
name|enan
argument_list|(
name|c
argument_list|,
name|eisneg
argument_list|(
name|a
argument_list|)
operator|^
name|eisneg
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* Infinity times anything else is infinity. */
ifdef|#
directive|ifdef
name|INFINITY
if|if
condition|(
name|eisinf
argument_list|(
name|a
argument_list|)
operator|||
name|eisinf
argument_list|(
name|b
argument_list|)
condition|)
block|{
if|if
condition|(
name|eisneg
argument_list|(
name|a
argument_list|)
operator|^
name|eisneg
argument_list|(
name|b
argument_list|)
condition|)
operator|*
operator|(
name|c
operator|+
operator|(
name|NE
operator|-
literal|1
operator|)
operator|)
operator|=
literal|0x8000
expr_stmt|;
else|else
operator|*
operator|(
name|c
operator|+
operator|(
name|NE
operator|-
literal|1
operator|)
operator|)
operator|=
literal|0
expr_stmt|;
name|einfin
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|emovi
argument_list|(
name|a
argument_list|,
name|ai
argument_list|)
expr_stmt|;
name|emovi
argument_list|(
name|b
argument_list|,
name|bi
argument_list|)
expr_stmt|;
name|lta
operator|=
name|ai
index|[
name|E
index|]
expr_stmt|;
name|ltb
operator|=
name|bi
index|[
name|E
index|]
expr_stmt|;
if|if
condition|(
name|ai
index|[
name|E
index|]
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NI
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ai
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|lta
operator|-=
name|enormlz
argument_list|(
name|ai
argument_list|)
expr_stmt|;
goto|goto
name|mnzer1
goto|;
block|}
block|}
name|eclear
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
name|mnzer1
label|:
if|if
condition|(
name|bi
index|[
name|E
index|]
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NI
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bi
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|ltb
operator|-=
name|enormlz
argument_list|(
name|bi
argument_list|)
expr_stmt|;
goto|goto
name|mnzer2
goto|;
block|}
block|}
name|eclear
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
name|mnzer2
label|:
comment|/* Multiply significands */
name|j
operator|=
name|emulm
argument_list|(
name|ai
argument_list|,
name|bi
argument_list|)
expr_stmt|;
comment|/* calculate exponent */
name|lt
operator|=
name|lta
operator|+
name|ltb
operator|-
operator|(
name|EXONE
operator|-
literal|1
operator|)
expr_stmt|;
name|emdnorm
argument_list|(
name|bi
argument_list|,
name|j
argument_list|,
literal|0
argument_list|,
name|lt
argument_list|,
literal|64
argument_list|)
expr_stmt|;
comment|/* calculate sign of product */
if|if
condition|(
name|ai
index|[
literal|0
index|]
operator|==
name|bi
index|[
literal|0
index|]
condition|)
name|bi
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
else|else
name|bi
index|[
literal|0
index|]
operator|=
literal|0xffff
expr_stmt|;
name|emovo
argument_list|(
name|bi
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Convert IEEE double precision to e type.  */
end_comment

begin_function
specifier|static
name|void
name|e53toe
parameter_list|(
name|pe
parameter_list|,
name|y
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|pe
decl_stmt|,
decl|*
name|y
decl_stmt|;
end_function

begin_block
block|{
ifdef|#
directive|ifdef
name|DEC
name|dectoe
argument_list|(
name|pe
argument_list|,
name|y
argument_list|)
expr_stmt|;
comment|/* see etodec.c */
else|#
directive|else
ifdef|#
directive|ifdef
name|IBM
name|ibmtoe
argument_list|(
name|pe
argument_list|,
name|y
argument_list|,
name|DFmode
argument_list|)
expr_stmt|;
else|#
directive|else
specifier|register
name|unsigned
name|EMUSHORT
name|r
decl_stmt|;
specifier|register
name|unsigned
name|EMUSHORT
modifier|*
name|e
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|unsigned
name|EMUSHORT
name|yy
index|[
name|NI
index|]
decl_stmt|;
name|int
name|denorm
decl_stmt|,
name|k
decl_stmt|;
name|e
operator|=
name|pe
expr_stmt|;
name|denorm
operator|=
literal|0
expr_stmt|;
comment|/* flag if denormalized number */
name|ecleaz
argument_list|(
name|yy
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IBMPC
name|e
operator|+=
literal|3
expr_stmt|;
endif|#
directive|endif
name|r
operator|=
operator|*
name|e
expr_stmt|;
name|yy
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|r
operator|&
literal|0x8000
condition|)
name|yy
index|[
literal|0
index|]
operator|=
literal|0xffff
expr_stmt|;
name|yy
index|[
name|M
index|]
operator|=
operator|(
name|r
operator|&
literal|0x0f
operator|)
operator||
literal|0x10
expr_stmt|;
name|r
operator|&=
operator|~
literal|0x800f
expr_stmt|;
comment|/* strip sign and 4 significand bits */
ifdef|#
directive|ifdef
name|INFINITY
if|if
condition|(
name|r
operator|==
literal|0x7ff0
condition|)
block|{
ifdef|#
directive|ifdef
name|NANS
ifdef|#
directive|ifdef
name|IBMPC
if|if
condition|(
operator|(
operator|(
name|pe
index|[
literal|3
index|]
operator|&
literal|0xf
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|pe
index|[
literal|2
index|]
operator|!=
literal|0
operator|)
operator|||
operator|(
name|pe
index|[
literal|1
index|]
operator|!=
literal|0
operator|)
operator|||
operator|(
name|pe
index|[
literal|0
index|]
operator|!=
literal|0
operator|)
condition|)
block|{
name|enan
argument_list|(
name|y
argument_list|,
name|yy
index|[
literal|0
index|]
operator|!=
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
else|#
directive|else
if|if
condition|(
operator|(
operator|(
name|pe
index|[
literal|0
index|]
operator|&
literal|0xf
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|pe
index|[
literal|1
index|]
operator|!=
literal|0
operator|)
operator|||
operator|(
name|pe
index|[
literal|2
index|]
operator|!=
literal|0
operator|)
operator|||
operator|(
name|pe
index|[
literal|3
index|]
operator|!=
literal|0
operator|)
condition|)
block|{
name|enan
argument_list|(
name|y
argument_list|,
name|yy
index|[
literal|0
index|]
operator|!=
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
endif|#
directive|endif
comment|/* NANS */
name|eclear
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|einfin
argument_list|(
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|yy
index|[
literal|0
index|]
condition|)
name|eneg
argument_list|(
name|y
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* INFINITY */
name|r
operator|>>=
literal|4
expr_stmt|;
comment|/* If zero exponent, then the significand is denormalized.      So take back the understood high significand bit. */
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
name|denorm
operator|=
literal|1
expr_stmt|;
name|yy
index|[
name|M
index|]
operator|&=
operator|~
literal|0x10
expr_stmt|;
block|}
name|r
operator|+=
name|EXONE
operator|-
literal|01777
expr_stmt|;
name|yy
index|[
name|E
index|]
operator|=
name|r
expr_stmt|;
name|p
operator|=
operator|&
name|yy
index|[
name|M
operator|+
literal|1
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|IBMPC
operator|*
name|p
operator|++
operator|=
operator|*
operator|(
operator|--
name|e
operator|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|*
operator|(
operator|--
name|e
operator|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|*
operator|(
operator|--
name|e
operator|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MIEEE
operator|++
name|e
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|*
name|e
operator|++
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|*
name|e
operator|++
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|*
name|e
operator|++
expr_stmt|;
endif|#
directive|endif
name|eshift
argument_list|(
name|yy
argument_list|,
operator|-
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|denorm
condition|)
block|{
comment|/* if zero exponent, then normalize the significand */
if|if
condition|(
operator|(
name|k
operator|=
name|enormlz
argument_list|(
name|yy
argument_list|)
operator|)
operator|>
name|NBITS
condition|)
name|ecleazs
argument_list|(
name|yy
argument_list|)
expr_stmt|;
else|else
name|yy
index|[
name|E
index|]
operator|-=
call|(
name|unsigned
name|EMUSHORT
call|)
argument_list|(
name|k
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|emovo
argument_list|(
name|yy
argument_list|,
name|y
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not IBM */
endif|#
directive|endif
comment|/* not DEC */
block|}
end_block

begin_function
specifier|static
name|void
name|e64toe
parameter_list|(
name|pe
parameter_list|,
name|y
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|pe
decl_stmt|,
decl|*
name|y
decl_stmt|;
end_function

begin_block
block|{
name|unsigned
name|EMUSHORT
name|yy
index|[
name|NI
index|]
decl_stmt|;
name|unsigned
name|EMUSHORT
modifier|*
name|e
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|int
name|i
decl_stmt|;
name|e
operator|=
name|pe
expr_stmt|;
name|p
operator|=
name|yy
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NE
operator|-
literal|5
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|IBMPC
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
operator|*
name|e
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* This precision is not ordinarily supported on DEC or IBM. */
ifdef|#
directive|ifdef
name|DEC
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
operator|*
name|e
operator|++
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IBM
name|p
operator|=
operator|&
name|yy
index|[
literal|0
index|]
operator|+
operator|(
name|NE
operator|-
literal|1
operator|)
expr_stmt|;
operator|*
name|p
operator|--
operator|=
operator|*
name|e
operator|++
expr_stmt|;
operator|++
name|e
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|--
operator|=
operator|*
name|e
operator|++
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MIEEE
name|p
operator|=
operator|&
name|yy
index|[
literal|0
index|]
operator|+
operator|(
name|NE
operator|-
literal|1
operator|)
expr_stmt|;
operator|*
name|p
operator|--
operator|=
operator|*
name|e
operator|++
expr_stmt|;
operator|++
name|e
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|--
operator|=
operator|*
name|e
operator|++
expr_stmt|;
endif|#
directive|endif
name|p
operator|=
name|yy
expr_stmt|;
name|q
operator|=
name|y
expr_stmt|;
ifdef|#
directive|ifdef
name|INFINITY
if|if
condition|(
operator|*
name|p
operator|==
literal|0x7fff
condition|)
block|{
ifdef|#
directive|ifdef
name|NANS
ifdef|#
directive|ifdef
name|IBMPC
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pe
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|enan
argument_list|(
name|y
argument_list|,
operator|(
operator|*
name|p
operator|&
literal|0x8000
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|#
directive|else
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
literal|4
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pe
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|enan
argument_list|(
name|y
argument_list|,
operator|(
operator|*
name|p
operator|&
literal|0x8000
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
endif|#
directive|endif
endif|#
directive|endif
comment|/* NANS */
name|eclear
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|einfin
argument_list|(
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|&
literal|0x8000
condition|)
name|eneg
argument_list|(
name|y
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* INFINITY */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NE
condition|;
name|i
operator|++
control|)
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|void
name|e113toe
parameter_list|(
name|pe
parameter_list|,
name|y
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|pe
decl_stmt|,
decl|*
name|y
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|unsigned
name|EMUSHORT
name|r
decl_stmt|;
name|unsigned
name|EMUSHORT
modifier|*
name|e
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|unsigned
name|EMUSHORT
name|yy
index|[
name|NI
index|]
decl_stmt|;
name|int
name|denorm
decl_stmt|,
name|i
decl_stmt|;
name|e
operator|=
name|pe
expr_stmt|;
name|denorm
operator|=
literal|0
expr_stmt|;
name|ecleaz
argument_list|(
name|yy
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IBMPC
name|e
operator|+=
literal|7
expr_stmt|;
endif|#
directive|endif
name|r
operator|=
operator|*
name|e
expr_stmt|;
name|yy
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|r
operator|&
literal|0x8000
condition|)
name|yy
index|[
literal|0
index|]
operator|=
literal|0xffff
expr_stmt|;
name|r
operator|&=
literal|0x7fff
expr_stmt|;
ifdef|#
directive|ifdef
name|INFINITY
if|if
condition|(
name|r
operator|==
literal|0x7fff
condition|)
block|{
ifdef|#
directive|ifdef
name|NANS
ifdef|#
directive|ifdef
name|IBMPC
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pe
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|enan
argument_list|(
name|y
argument_list|,
name|yy
index|[
literal|0
index|]
operator|!=
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|#
directive|else
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pe
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|enan
argument_list|(
name|y
argument_list|,
name|yy
index|[
literal|0
index|]
operator|!=
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
endif|#
directive|endif
endif|#
directive|endif
comment|/* NANS */
name|eclear
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|einfin
argument_list|(
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|yy
index|[
literal|0
index|]
condition|)
name|eneg
argument_list|(
name|y
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* INFINITY */
name|yy
index|[
name|E
index|]
operator|=
name|r
expr_stmt|;
name|p
operator|=
operator|&
name|yy
index|[
name|M
operator|+
literal|1
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|IBMPC
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
operator|*
operator|(
operator|--
name|e
operator|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MIEEE
operator|++
name|e
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
operator|*
name|e
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* If denormal, remove the implied bit; else shift down 1. */
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
name|yy
index|[
name|M
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|yy
index|[
name|M
index|]
operator|=
literal|1
expr_stmt|;
name|eshift
argument_list|(
name|yy
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|emovo
argument_list|(
name|yy
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Convert IEEE single precision to e type.  */
end_comment

begin_function
specifier|static
name|void
name|e24toe
parameter_list|(
name|pe
parameter_list|,
name|y
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|pe
decl_stmt|,
decl|*
name|y
decl_stmt|;
end_function

begin_block
block|{
ifdef|#
directive|ifdef
name|IBM
name|ibmtoe
argument_list|(
name|pe
argument_list|,
name|y
argument_list|,
name|SFmode
argument_list|)
expr_stmt|;
else|#
directive|else
specifier|register
name|unsigned
name|EMUSHORT
name|r
decl_stmt|;
specifier|register
name|unsigned
name|EMUSHORT
modifier|*
name|e
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|unsigned
name|EMUSHORT
name|yy
index|[
name|NI
index|]
decl_stmt|;
name|int
name|denorm
decl_stmt|,
name|k
decl_stmt|;
name|e
operator|=
name|pe
expr_stmt|;
name|denorm
operator|=
literal|0
expr_stmt|;
comment|/* flag if denormalized number */
name|ecleaz
argument_list|(
name|yy
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IBMPC
name|e
operator|+=
literal|1
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEC
name|e
operator|+=
literal|1
expr_stmt|;
endif|#
directive|endif
name|r
operator|=
operator|*
name|e
expr_stmt|;
name|yy
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|r
operator|&
literal|0x8000
condition|)
name|yy
index|[
literal|0
index|]
operator|=
literal|0xffff
expr_stmt|;
name|yy
index|[
name|M
index|]
operator|=
operator|(
name|r
operator|&
literal|0x7f
operator|)
operator||
literal|0200
expr_stmt|;
name|r
operator|&=
operator|~
literal|0x807f
expr_stmt|;
comment|/* strip sign and 7 significand bits */
ifdef|#
directive|ifdef
name|INFINITY
if|if
condition|(
name|r
operator|==
literal|0x7f80
condition|)
block|{
ifdef|#
directive|ifdef
name|NANS
ifdef|#
directive|ifdef
name|MIEEE
if|if
condition|(
operator|(
operator|(
name|pe
index|[
literal|0
index|]
operator|&
literal|0x7f
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|pe
index|[
literal|1
index|]
operator|!=
literal|0
operator|)
condition|)
block|{
name|enan
argument_list|(
name|y
argument_list|,
name|yy
index|[
literal|0
index|]
operator|!=
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
else|#
directive|else
if|if
condition|(
operator|(
operator|(
name|pe
index|[
literal|1
index|]
operator|&
literal|0x7f
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|pe
index|[
literal|0
index|]
operator|!=
literal|0
operator|)
condition|)
block|{
name|enan
argument_list|(
name|y
argument_list|,
name|yy
index|[
literal|0
index|]
operator|!=
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
endif|#
directive|endif
comment|/* NANS */
name|eclear
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|einfin
argument_list|(
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|yy
index|[
literal|0
index|]
condition|)
name|eneg
argument_list|(
name|y
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* INFINITY */
name|r
operator|>>=
literal|7
expr_stmt|;
comment|/* If zero exponent, then the significand is denormalized.      So take back the understood high significand bit. */
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
name|denorm
operator|=
literal|1
expr_stmt|;
name|yy
index|[
name|M
index|]
operator|&=
operator|~
literal|0200
expr_stmt|;
block|}
name|r
operator|+=
name|EXONE
operator|-
literal|0177
expr_stmt|;
name|yy
index|[
name|E
index|]
operator|=
name|r
expr_stmt|;
name|p
operator|=
operator|&
name|yy
index|[
name|M
operator|+
literal|1
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|IBMPC
operator|*
name|p
operator|++
operator|=
operator|*
operator|(
operator|--
name|e
operator|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEC
operator|*
name|p
operator|++
operator|=
operator|*
operator|(
operator|--
name|e
operator|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MIEEE
operator|++
name|e
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|*
name|e
operator|++
expr_stmt|;
endif|#
directive|endif
name|eshift
argument_list|(
name|yy
argument_list|,
operator|-
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|denorm
condition|)
block|{
comment|/* if zero exponent, then normalize the significand */
if|if
condition|(
operator|(
name|k
operator|=
name|enormlz
argument_list|(
name|yy
argument_list|)
operator|)
operator|>
name|NBITS
condition|)
name|ecleazs
argument_list|(
name|yy
argument_list|)
expr_stmt|;
else|else
name|yy
index|[
name|E
index|]
operator|-=
call|(
name|unsigned
name|EMUSHORT
call|)
argument_list|(
name|k
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|emovo
argument_list|(
name|yy
argument_list|,
name|y
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not IBM */
block|}
end_block

begin_function
specifier|static
name|void
name|etoe113
parameter_list|(
name|x
parameter_list|,
name|e
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|,
decl|*
name|e
decl_stmt|;
end_function

begin_block
block|{
name|unsigned
name|EMUSHORT
name|xi
index|[
name|NI
index|]
decl_stmt|;
name|EMULONG
name|exp
decl_stmt|;
name|int
name|rndsav
decl_stmt|;
ifdef|#
directive|ifdef
name|NANS
if|if
condition|(
name|eisnan
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|make_nan
argument_list|(
name|e
argument_list|,
name|eisneg
argument_list|(
name|x
argument_list|)
argument_list|,
name|TFmode
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|emovi
argument_list|(
name|x
argument_list|,
name|xi
argument_list|)
expr_stmt|;
name|exp
operator|=
operator|(
name|EMULONG
operator|)
name|xi
index|[
name|E
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|INFINITY
if|if
condition|(
name|eisinf
argument_list|(
name|x
argument_list|)
condition|)
goto|goto
name|nonorm
goto|;
endif|#
directive|endif
comment|/* round off to nearest or even */
name|rndsav
operator|=
name|rndprc
expr_stmt|;
name|rndprc
operator|=
literal|113
expr_stmt|;
name|emdnorm
argument_list|(
name|xi
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|exp
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|rndprc
operator|=
name|rndsav
expr_stmt|;
name|nonorm
label|:
name|toe113
argument_list|(
name|xi
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Move out internal format to ieee long double */
end_comment

begin_function
specifier|static
name|void
name|toe113
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|a
decl_stmt|,
decl|*
name|b
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|unsigned
name|EMUSHORT
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|unsigned
name|EMUSHORT
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|NANS
if|if
condition|(
name|eiisnan
argument_list|(
name|a
argument_list|)
condition|)
block|{
name|make_nan
argument_list|(
name|b
argument_list|,
name|eiisneg
argument_list|(
name|a
argument_list|)
argument_list|,
name|TFmode
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|p
operator|=
name|a
expr_stmt|;
ifdef|#
directive|ifdef
name|MIEEE
name|q
operator|=
name|b
expr_stmt|;
else|#
directive|else
name|q
operator|=
name|b
operator|+
literal|7
expr_stmt|;
comment|/* point to output exponent */
endif|#
directive|endif
comment|/* If not denormal, delete the implied bit. */
if|if
condition|(
name|a
index|[
name|E
index|]
operator|!=
literal|0
condition|)
block|{
name|eshup1
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
comment|/* combine sign and exponent */
name|i
operator|=
operator|*
name|p
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|MIEEE
if|if
condition|(
name|i
condition|)
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
operator||
literal|0x8000
expr_stmt|;
else|else
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|i
condition|)
operator|*
name|q
operator|--
operator|=
operator|*
name|p
operator|++
operator||
literal|0x8000
expr_stmt|;
else|else
operator|*
name|q
operator|--
operator|=
operator|*
name|p
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* skip over guard word */
operator|++
name|p
expr_stmt|;
comment|/* move the significand */
ifdef|#
directive|ifdef
name|MIEEE
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
else|#
directive|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
operator|*
name|q
operator|--
operator|=
operator|*
name|p
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_function
specifier|static
name|void
name|etoe64
parameter_list|(
name|x
parameter_list|,
name|e
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|,
decl|*
name|e
decl_stmt|;
end_function

begin_block
block|{
name|unsigned
name|EMUSHORT
name|xi
index|[
name|NI
index|]
decl_stmt|;
name|EMULONG
name|exp
decl_stmt|;
name|int
name|rndsav
decl_stmt|;
ifdef|#
directive|ifdef
name|NANS
if|if
condition|(
name|eisnan
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|make_nan
argument_list|(
name|e
argument_list|,
name|eisneg
argument_list|(
name|x
argument_list|)
argument_list|,
name|XFmode
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|emovi
argument_list|(
name|x
argument_list|,
name|xi
argument_list|)
expr_stmt|;
comment|/* adjust exponent for offset */
name|exp
operator|=
operator|(
name|EMULONG
operator|)
name|xi
index|[
name|E
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|INFINITY
if|if
condition|(
name|eisinf
argument_list|(
name|x
argument_list|)
condition|)
goto|goto
name|nonorm
goto|;
endif|#
directive|endif
comment|/* round off to nearest or even */
name|rndsav
operator|=
name|rndprc
expr_stmt|;
name|rndprc
operator|=
literal|64
expr_stmt|;
name|emdnorm
argument_list|(
name|xi
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|exp
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|rndprc
operator|=
name|rndsav
expr_stmt|;
name|nonorm
label|:
name|toe64
argument_list|(
name|xi
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Move out internal format to ieee long double. */
end_comment

begin_function
specifier|static
name|void
name|toe64
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|a
decl_stmt|,
decl|*
name|b
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|unsigned
name|EMUSHORT
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|unsigned
name|EMUSHORT
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|NANS
if|if
condition|(
name|eiisnan
argument_list|(
name|a
argument_list|)
condition|)
block|{
name|make_nan
argument_list|(
name|b
argument_list|,
name|eiisneg
argument_list|(
name|a
argument_list|)
argument_list|,
name|XFmode
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|p
operator|=
name|a
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|MIEEE
argument_list|)
operator|||
name|defined
argument_list|(
name|IBM
argument_list|)
name|q
operator|=
name|b
expr_stmt|;
else|#
directive|else
name|q
operator|=
name|b
operator|+
literal|4
expr_stmt|;
comment|/* point to output exponent */
if|#
directive|if
name|LONG_DOUBLE_TYPE_SIZE
operator|==
literal|96
comment|/* Clear the last two bytes of 12-byte Intel format */
operator|*
operator|(
name|q
operator|+
literal|1
operator|)
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* combine sign and exponent */
name|i
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|MIEEE
argument_list|)
operator|||
name|defined
argument_list|(
name|IBM
argument_list|)
if|if
condition|(
name|i
condition|)
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
operator||
literal|0x8000
expr_stmt|;
else|else
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|q
operator|++
operator|=
literal|0
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|i
condition|)
operator|*
name|q
operator|--
operator|=
operator|*
name|p
operator|++
operator||
literal|0x8000
expr_stmt|;
else|else
operator|*
name|q
operator|--
operator|=
operator|*
name|p
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* skip over guard word */
operator|++
name|p
expr_stmt|;
comment|/* move the significand */
if|#
directive|if
name|defined
argument_list|(
name|MIEEE
argument_list|)
operator|||
name|defined
argument_list|(
name|IBM
argument_list|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
else|#
directive|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
operator|*
name|q
operator|--
operator|=
operator|*
name|p
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/* e type to IEEE double precision.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEC
end_ifdef

begin_function
specifier|static
name|void
name|etoe53
parameter_list|(
name|x
parameter_list|,
name|e
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|,
decl|*
name|e
decl_stmt|;
end_function

begin_block
block|{
name|etodec
argument_list|(
name|x
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|/* see etodec.c */
block|}
end_block

begin_function
specifier|static
name|void
name|toe53
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|,
decl|*
name|y
decl_stmt|;
end_function

begin_block
block|{
name|todec
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|IBM
end_ifdef

begin_function
specifier|static
name|void
name|etoe53
parameter_list|(
name|x
parameter_list|,
name|e
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|,
decl|*
name|e
decl_stmt|;
end_function

begin_block
block|{
name|etoibm
argument_list|(
name|x
argument_list|,
name|e
argument_list|,
name|DFmode
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|void
name|toe53
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|,
decl|*
name|y
decl_stmt|;
end_function

begin_block
block|{
name|toibm
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|DFmode
argument_list|)
expr_stmt|;
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* it's neither DEC nor IBM */
end_comment

begin_function
specifier|static
name|void
name|etoe53
parameter_list|(
name|x
parameter_list|,
name|e
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|,
decl|*
name|e
decl_stmt|;
end_function

begin_block
block|{
name|unsigned
name|EMUSHORT
name|xi
index|[
name|NI
index|]
decl_stmt|;
name|EMULONG
name|exp
decl_stmt|;
name|int
name|rndsav
decl_stmt|;
ifdef|#
directive|ifdef
name|NANS
if|if
condition|(
name|eisnan
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|make_nan
argument_list|(
name|e
argument_list|,
name|eisneg
argument_list|(
name|x
argument_list|)
argument_list|,
name|DFmode
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|emovi
argument_list|(
name|x
argument_list|,
name|xi
argument_list|)
expr_stmt|;
comment|/* adjust exponent for offsets */
name|exp
operator|=
operator|(
name|EMULONG
operator|)
name|xi
index|[
name|E
index|]
operator|-
operator|(
name|EXONE
operator|-
literal|0x3ff
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INFINITY
if|if
condition|(
name|eisinf
argument_list|(
name|x
argument_list|)
condition|)
goto|goto
name|nonorm
goto|;
endif|#
directive|endif
comment|/* round off to nearest or even */
name|rndsav
operator|=
name|rndprc
expr_stmt|;
name|rndprc
operator|=
literal|53
expr_stmt|;
name|emdnorm
argument_list|(
name|xi
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|exp
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|rndprc
operator|=
name|rndsav
expr_stmt|;
name|nonorm
label|:
name|toe53
argument_list|(
name|xi
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|void
name|toe53
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|,
decl|*
name|y
decl_stmt|;
end_function

begin_block
block|{
name|unsigned
name|EMUSHORT
name|i
decl_stmt|;
name|unsigned
name|EMUSHORT
modifier|*
name|p
decl_stmt|;
ifdef|#
directive|ifdef
name|NANS
if|if
condition|(
name|eiisnan
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|make_nan
argument_list|(
name|y
argument_list|,
name|eiisneg
argument_list|(
name|x
argument_list|)
argument_list|,
name|DFmode
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|p
operator|=
operator|&
name|x
index|[
literal|0
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|IBMPC
name|y
operator|+=
literal|3
expr_stmt|;
endif|#
directive|endif
operator|*
name|y
operator|=
literal|0
expr_stmt|;
comment|/* output high order */
if|if
condition|(
operator|*
name|p
operator|++
condition|)
operator|*
name|y
operator|=
literal|0x8000
expr_stmt|;
comment|/* output sign bit */
name|i
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>=
operator|(
name|unsigned
name|int
operator|)
literal|2047
condition|)
block|{
comment|/* Saturate at largest number less than infinity. */
ifdef|#
directive|ifdef
name|INFINITY
operator|*
name|y
operator||=
literal|0x7ff0
expr_stmt|;
ifdef|#
directive|ifdef
name|IBMPC
operator|*
operator|(
operator|--
name|y
operator|)
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
operator|--
name|y
operator|)
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
operator|--
name|y
operator|)
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MIEEE
operator|++
name|y
expr_stmt|;
operator|*
name|y
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|y
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|y
operator|++
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
operator|*
name|y
operator||=
operator|(
name|unsigned
name|EMUSHORT
operator|)
literal|0x7fef
expr_stmt|;
ifdef|#
directive|ifdef
name|IBMPC
operator|*
operator|(
operator|--
name|y
operator|)
operator|=
literal|0xffff
expr_stmt|;
operator|*
operator|(
operator|--
name|y
operator|)
operator|=
literal|0xffff
expr_stmt|;
operator|*
operator|(
operator|--
name|y
operator|)
operator|=
literal|0xffff
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MIEEE
operator|++
name|y
expr_stmt|;
operator|*
name|y
operator|++
operator|=
literal|0xffff
expr_stmt|;
operator|*
name|y
operator|++
operator|=
literal|0xffff
expr_stmt|;
operator|*
name|y
operator|++
operator|=
literal|0xffff
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
return|return;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|eshift
argument_list|(
name|x
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|i
operator|<<=
literal|4
expr_stmt|;
name|eshift
argument_list|(
name|x
argument_list|,
literal|5
argument_list|)
expr_stmt|;
block|}
name|i
operator||=
operator|*
name|p
operator|++
operator|&
operator|(
name|unsigned
name|EMUSHORT
operator|)
literal|0x0f
expr_stmt|;
comment|/* *p = xi[M] */
operator|*
name|y
operator||=
operator|(
name|unsigned
name|EMUSHORT
operator|)
name|i
expr_stmt|;
comment|/* high order output already has sign bit set */
ifdef|#
directive|ifdef
name|IBMPC
operator|*
operator|(
operator|--
name|y
operator|)
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
operator|(
operator|--
name|y
operator|)
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
operator|(
operator|--
name|y
operator|)
operator|=
operator|*
name|p
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MIEEE
operator|++
name|y
expr_stmt|;
operator|*
name|y
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|y
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|y
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not IBM */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not DEC */
end_comment

begin_comment
comment|/* e type to IEEE single precision.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|IBM
end_ifdef

begin_function
specifier|static
name|void
name|etoe24
parameter_list|(
name|x
parameter_list|,
name|e
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|,
decl|*
name|e
decl_stmt|;
end_function

begin_block
block|{
name|etoibm
argument_list|(
name|x
argument_list|,
name|e
argument_list|,
name|SFmode
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|void
name|toe24
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|,
decl|*
name|y
decl_stmt|;
end_function

begin_block
block|{
name|toibm
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|SFmode
argument_list|)
expr_stmt|;
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|void
name|etoe24
parameter_list|(
name|x
parameter_list|,
name|e
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|,
decl|*
name|e
decl_stmt|;
end_function

begin_block
block|{
name|EMULONG
name|exp
decl_stmt|;
name|unsigned
name|EMUSHORT
name|xi
index|[
name|NI
index|]
decl_stmt|;
name|int
name|rndsav
decl_stmt|;
ifdef|#
directive|ifdef
name|NANS
if|if
condition|(
name|eisnan
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|make_nan
argument_list|(
name|e
argument_list|,
name|eisneg
argument_list|(
name|x
argument_list|)
argument_list|,
name|SFmode
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|emovi
argument_list|(
name|x
argument_list|,
name|xi
argument_list|)
expr_stmt|;
comment|/* adjust exponent for offsets */
name|exp
operator|=
operator|(
name|EMULONG
operator|)
name|xi
index|[
name|E
index|]
operator|-
operator|(
name|EXONE
operator|-
literal|0177
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INFINITY
if|if
condition|(
name|eisinf
argument_list|(
name|x
argument_list|)
condition|)
goto|goto
name|nonorm
goto|;
endif|#
directive|endif
comment|/* round off to nearest or even */
name|rndsav
operator|=
name|rndprc
expr_stmt|;
name|rndprc
operator|=
literal|24
expr_stmt|;
name|emdnorm
argument_list|(
name|xi
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|exp
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|rndprc
operator|=
name|rndsav
expr_stmt|;
name|nonorm
label|:
name|toe24
argument_list|(
name|xi
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|void
name|toe24
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|,
decl|*
name|y
decl_stmt|;
end_function

begin_block
block|{
name|unsigned
name|EMUSHORT
name|i
decl_stmt|;
name|unsigned
name|EMUSHORT
modifier|*
name|p
decl_stmt|;
ifdef|#
directive|ifdef
name|NANS
if|if
condition|(
name|eiisnan
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|make_nan
argument_list|(
name|y
argument_list|,
name|eiisneg
argument_list|(
name|x
argument_list|)
argument_list|,
name|SFmode
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|p
operator|=
operator|&
name|x
index|[
literal|0
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|IBMPC
name|y
operator|+=
literal|1
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEC
name|y
operator|+=
literal|1
expr_stmt|;
endif|#
directive|endif
operator|*
name|y
operator|=
literal|0
expr_stmt|;
comment|/* output high order */
if|if
condition|(
operator|*
name|p
operator|++
condition|)
operator|*
name|y
operator|=
literal|0x8000
expr_stmt|;
comment|/* output sign bit */
name|i
operator|=
operator|*
name|p
operator|++
expr_stmt|;
comment|/* Handle overflow cases. */
if|if
condition|(
name|i
operator|>=
literal|255
condition|)
block|{
ifdef|#
directive|ifdef
name|INFINITY
operator|*
name|y
operator||=
operator|(
name|unsigned
name|EMUSHORT
operator|)
literal|0x7f80
expr_stmt|;
ifdef|#
directive|ifdef
name|IBMPC
operator|*
operator|(
operator|--
name|y
operator|)
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEC
operator|*
operator|(
operator|--
name|y
operator|)
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MIEEE
operator|++
name|y
expr_stmt|;
operator|*
name|y
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
comment|/* no INFINITY */
operator|*
name|y
operator||=
operator|(
name|unsigned
name|EMUSHORT
operator|)
literal|0x7f7f
expr_stmt|;
ifdef|#
directive|ifdef
name|IBMPC
operator|*
operator|(
operator|--
name|y
operator|)
operator|=
literal|0xffff
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEC
operator|*
operator|(
operator|--
name|y
operator|)
operator|=
literal|0xffff
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MIEEE
operator|++
name|y
expr_stmt|;
operator|*
name|y
operator|=
literal|0xffff
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ERANGE
name|errno
operator|=
name|ERANGE
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* no INFINITY */
return|return;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|eshift
argument_list|(
name|x
argument_list|,
literal|7
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|i
operator|<<=
literal|7
expr_stmt|;
name|eshift
argument_list|(
name|x
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
name|i
operator||=
operator|*
name|p
operator|++
operator|&
operator|(
name|unsigned
name|EMUSHORT
operator|)
literal|0x7f
expr_stmt|;
comment|/* *p = xi[M] */
operator|*
name|y
operator||=
name|i
expr_stmt|;
comment|/* high order output already has sign bit set */
ifdef|#
directive|ifdef
name|IBMPC
operator|*
operator|(
operator|--
name|y
operator|)
operator|=
operator|*
name|p
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEC
operator|*
operator|(
operator|--
name|y
operator|)
operator|=
operator|*
name|p
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MIEEE
operator|++
name|y
expr_stmt|;
operator|*
name|y
operator|=
operator|*
name|p
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not IBM */
end_comment

begin_comment
comment|/* Compare two e type numbers.     Return +1 if a> b            0 if a == b           -1 if a< b           -2 if either a or b is a NaN.  */
end_comment

begin_function
specifier|static
name|int
name|ecmp
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|a
decl_stmt|,
decl|*
name|b
decl_stmt|;
end_function

begin_block
block|{
name|unsigned
name|EMUSHORT
name|ai
index|[
name|NI
index|]
decl_stmt|,
name|bi
index|[
name|NI
index|]
decl_stmt|;
specifier|register
name|unsigned
name|EMUSHORT
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|msign
decl_stmt|;
ifdef|#
directive|ifdef
name|NANS
if|if
condition|(
name|eisnan
argument_list|(
name|a
argument_list|)
operator|||
name|eisnan
argument_list|(
name|b
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|2
operator|)
return|;
endif|#
directive|endif
name|emovi
argument_list|(
name|a
argument_list|,
name|ai
argument_list|)
expr_stmt|;
name|p
operator|=
name|ai
expr_stmt|;
name|emovi
argument_list|(
name|b
argument_list|,
name|bi
argument_list|)
expr_stmt|;
name|q
operator|=
name|bi
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
operator|*
name|q
condition|)
block|{
comment|/* the signs are different */
comment|/* -0 equals + 0 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NI
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ai
index|[
name|i
index|]
operator|!=
literal|0
condition|)
goto|goto
name|nzro
goto|;
if|if
condition|(
name|bi
index|[
name|i
index|]
operator|!=
literal|0
condition|)
goto|goto
name|nzro
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|nzro
label|:
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* both are the same sign */
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
name|msign
operator|=
literal|1
expr_stmt|;
else|else
name|msign
operator|=
operator|-
literal|1
expr_stmt|;
name|i
operator|=
name|NI
operator|-
literal|1
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
operator|*
name|q
operator|++
condition|)
block|{
goto|goto
name|diff
goto|;
block|}
block|}
do|while
condition|(
operator|--
name|i
operator|>
literal|0
condition|)
do|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* equality */
name|diff
label|:
if|if
condition|(
operator|*
operator|(
operator|--
name|p
operator|)
operator|>
operator|*
operator|(
operator|--
name|q
operator|)
condition|)
return|return
operator|(
name|msign
operator|)
return|;
comment|/* p is bigger */
else|else
return|return
operator|(
operator|-
name|msign
operator|)
return|;
comment|/* p is littler */
block|}
end_block

begin_comment
comment|/* Find nearest integer to x = floor (x + 0.5).  */
end_comment

begin_function
specifier|static
name|void
name|eround
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|,
decl|*
name|y
decl_stmt|;
end_function

begin_block
block|{
name|eadd
argument_list|(
name|ehalf
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|efloor
argument_list|(
name|y
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Convert HOST_WIDE_INT to e type.  */
end_comment

begin_function
specifier|static
name|void
name|ltoe
parameter_list|(
name|lp
parameter_list|,
name|y
parameter_list|)
name|HOST_WIDE_INT
modifier|*
name|lp
decl_stmt|;
name|unsigned
name|EMUSHORT
modifier|*
name|y
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|yi
index|[
name|NI
index|]
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|ll
decl_stmt|;
name|int
name|k
decl_stmt|;
name|ecleaz
argument_list|(
name|yi
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|lp
operator|<
literal|0
condition|)
block|{
comment|/* make it positive */
name|ll
operator|=
call|(
name|unsigned
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
operator|(
operator|*
name|lp
operator|)
argument_list|)
expr_stmt|;
name|yi
index|[
literal|0
index|]
operator|=
literal|0xffff
expr_stmt|;
comment|/* put correct sign in the e type number */
block|}
else|else
block|{
name|ll
operator|=
call|(
name|unsigned
name|HOST_WIDE_INT
call|)
argument_list|(
operator|*
name|lp
argument_list|)
expr_stmt|;
block|}
comment|/* move the long integer to yi significand area */
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|64
name|yi
index|[
name|M
index|]
operator|=
call|(
name|unsigned
name|EMUSHORT
call|)
argument_list|(
name|ll
operator|>>
literal|48
argument_list|)
expr_stmt|;
name|yi
index|[
name|M
operator|+
literal|1
index|]
operator|=
call|(
name|unsigned
name|EMUSHORT
call|)
argument_list|(
name|ll
operator|>>
literal|32
argument_list|)
expr_stmt|;
name|yi
index|[
name|M
operator|+
literal|2
index|]
operator|=
call|(
name|unsigned
name|EMUSHORT
call|)
argument_list|(
name|ll
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|yi
index|[
name|M
operator|+
literal|3
index|]
operator|=
operator|(
name|unsigned
name|EMUSHORT
operator|)
name|ll
expr_stmt|;
name|yi
index|[
name|E
index|]
operator|=
name|EXONE
operator|+
literal|47
expr_stmt|;
comment|/* exponent if normalize shift count were 0 */
else|#
directive|else
name|yi
index|[
name|M
index|]
operator|=
call|(
name|unsigned
name|EMUSHORT
call|)
argument_list|(
name|ll
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|yi
index|[
name|M
operator|+
literal|1
index|]
operator|=
operator|(
name|unsigned
name|EMUSHORT
operator|)
name|ll
expr_stmt|;
name|yi
index|[
name|E
index|]
operator|=
name|EXONE
operator|+
literal|15
expr_stmt|;
comment|/* exponent if normalize shift count were 0 */
endif|#
directive|endif
if|if
condition|(
operator|(
name|k
operator|=
name|enormlz
argument_list|(
name|yi
argument_list|)
operator|)
operator|>
name|NBITS
condition|)
comment|/* normalize the significand */
name|ecleaz
argument_list|(
name|yi
argument_list|)
expr_stmt|;
comment|/* it was zero */
else|else
name|yi
index|[
name|E
index|]
operator|-=
operator|(
name|unsigned
name|EMUSHORT
operator|)
name|k
expr_stmt|;
comment|/* subtract shift count from exponent */
name|emovo
argument_list|(
name|yi
argument_list|,
name|y
argument_list|)
expr_stmt|;
comment|/* output the answer */
block|}
end_function

begin_comment
comment|/* Convert unsigned HOST_WIDE_INT to e type.  */
end_comment

begin_function
specifier|static
name|void
name|ultoe
parameter_list|(
name|lp
parameter_list|,
name|y
parameter_list|)
name|unsigned
name|HOST_WIDE_INT
modifier|*
name|lp
decl_stmt|;
name|unsigned
name|EMUSHORT
modifier|*
name|y
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|yi
index|[
name|NI
index|]
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|ll
decl_stmt|;
name|int
name|k
decl_stmt|;
name|ecleaz
argument_list|(
name|yi
argument_list|)
expr_stmt|;
name|ll
operator|=
operator|*
name|lp
expr_stmt|;
comment|/* move the long integer to ayi significand area */
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|64
name|yi
index|[
name|M
index|]
operator|=
call|(
name|unsigned
name|EMUSHORT
call|)
argument_list|(
name|ll
operator|>>
literal|48
argument_list|)
expr_stmt|;
name|yi
index|[
name|M
operator|+
literal|1
index|]
operator|=
call|(
name|unsigned
name|EMUSHORT
call|)
argument_list|(
name|ll
operator|>>
literal|32
argument_list|)
expr_stmt|;
name|yi
index|[
name|M
operator|+
literal|2
index|]
operator|=
call|(
name|unsigned
name|EMUSHORT
call|)
argument_list|(
name|ll
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|yi
index|[
name|M
operator|+
literal|3
index|]
operator|=
operator|(
name|unsigned
name|EMUSHORT
operator|)
name|ll
expr_stmt|;
name|yi
index|[
name|E
index|]
operator|=
name|EXONE
operator|+
literal|47
expr_stmt|;
comment|/* exponent if normalize shift count were 0 */
else|#
directive|else
name|yi
index|[
name|M
index|]
operator|=
call|(
name|unsigned
name|EMUSHORT
call|)
argument_list|(
name|ll
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|yi
index|[
name|M
operator|+
literal|1
index|]
operator|=
operator|(
name|unsigned
name|EMUSHORT
operator|)
name|ll
expr_stmt|;
name|yi
index|[
name|E
index|]
operator|=
name|EXONE
operator|+
literal|15
expr_stmt|;
comment|/* exponent if normalize shift count were 0 */
endif|#
directive|endif
if|if
condition|(
operator|(
name|k
operator|=
name|enormlz
argument_list|(
name|yi
argument_list|)
operator|)
operator|>
name|NBITS
condition|)
comment|/* normalize the significand */
name|ecleaz
argument_list|(
name|yi
argument_list|)
expr_stmt|;
comment|/* it was zero */
else|else
name|yi
index|[
name|E
index|]
operator|-=
operator|(
name|unsigned
name|EMUSHORT
operator|)
name|k
expr_stmt|;
comment|/* subtract shift count from exponent */
name|emovo
argument_list|(
name|yi
argument_list|,
name|y
argument_list|)
expr_stmt|;
comment|/* output the answer */
block|}
end_function

begin_comment
comment|/* Find signed HOST_WIDE_INT integer and floating point fractional    parts of e-type (packed internal format) floating point input X.    The integer output I has the sign of the input, except that    positive overflow is permitted if FIXUNS_TRUNC_LIKE_FIX_TRUNC.    The output e-type fraction FRAC is the positive fractional    part of abs (X).  */
end_comment

begin_function
specifier|static
name|void
name|eifrac
parameter_list|(
name|x
parameter_list|,
name|i
parameter_list|,
name|frac
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|;
name|HOST_WIDE_INT
modifier|*
name|i
decl_stmt|;
name|unsigned
name|EMUSHORT
modifier|*
name|frac
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|xi
index|[
name|NI
index|]
decl_stmt|;
name|int
name|j
decl_stmt|,
name|k
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|ll
decl_stmt|;
name|emovi
argument_list|(
name|x
argument_list|,
name|xi
argument_list|)
expr_stmt|;
name|k
operator|=
operator|(
name|int
operator|)
name|xi
index|[
name|E
index|]
operator|-
operator|(
name|EXONE
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|k
operator|<=
literal|0
condition|)
block|{
comment|/* if exponent<= 0, integer = 0 and real output is fraction */
operator|*
name|i
operator|=
literal|0L
expr_stmt|;
name|emovo
argument_list|(
name|xi
argument_list|,
name|frac
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|k
operator|>
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|1
operator|)
condition|)
block|{
comment|/* long integer overflow: output large integer 	 and correct fraction  */
if|if
condition|(
name|xi
index|[
literal|0
index|]
condition|)
operator|*
name|i
operator|=
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|)
operator|<<
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|1
operator|)
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|FIXUNS_TRUNC_LIKE_FIX_TRUNC
comment|/* In this case, let it overflow and convert as if unsigned.  */
name|euifrac
argument_list|(
name|x
argument_list|,
operator|&
name|ll
argument_list|,
name|frac
argument_list|)
expr_stmt|;
operator|*
name|i
operator|=
operator|(
name|HOST_WIDE_INT
operator|)
name|ll
expr_stmt|;
return|return;
else|#
directive|else
comment|/* In other cases, return the largest positive integer.  */
operator|*
name|i
operator|=
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|)
operator|<<
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
name|eshift
argument_list|(
name|xi
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|extra_warnings
condition|)
name|warning
argument_list|(
literal|"overflow on truncation to integer"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|k
operator|>
literal|16
condition|)
block|{
comment|/* Shift more than 16 bits: first shift up k-16 mod 16, 	 then shift up by 16's.  */
name|j
operator|=
name|k
operator|-
operator|(
operator|(
name|k
operator|>>
literal|4
operator|)
operator|<<
literal|4
operator|)
expr_stmt|;
name|eshift
argument_list|(
name|xi
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|ll
operator|=
name|xi
index|[
name|M
index|]
expr_stmt|;
name|k
operator|-=
name|j
expr_stmt|;
do|do
block|{
name|eshup6
argument_list|(
name|xi
argument_list|)
expr_stmt|;
name|ll
operator|=
operator|(
name|ll
operator|<<
literal|16
operator|)
operator||
name|xi
index|[
name|M
index|]
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|k
operator|-=
literal|16
operator|)
operator|>
literal|0
condition|)
do|;
operator|*
name|i
operator|=
name|ll
expr_stmt|;
if|if
condition|(
name|xi
index|[
literal|0
index|]
condition|)
operator|*
name|i
operator|=
operator|-
operator|(
operator|*
name|i
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* shift not more than 16 bits */
name|eshift
argument_list|(
name|xi
argument_list|,
name|k
argument_list|)
expr_stmt|;
operator|*
name|i
operator|=
operator|(
name|HOST_WIDE_INT
operator|)
name|xi
index|[
name|M
index|]
operator|&
literal|0xffff
expr_stmt|;
if|if
condition|(
name|xi
index|[
literal|0
index|]
condition|)
operator|*
name|i
operator|=
operator|-
operator|(
operator|*
name|i
operator|)
expr_stmt|;
block|}
name|xi
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|xi
index|[
name|E
index|]
operator|=
name|EXONE
operator|-
literal|1
expr_stmt|;
name|xi
index|[
name|M
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|k
operator|=
name|enormlz
argument_list|(
name|xi
argument_list|)
operator|)
operator|>
name|NBITS
condition|)
name|ecleaz
argument_list|(
name|xi
argument_list|)
expr_stmt|;
else|else
name|xi
index|[
name|E
index|]
operator|-=
operator|(
name|unsigned
name|EMUSHORT
operator|)
name|k
expr_stmt|;
name|emovo
argument_list|(
name|xi
argument_list|,
name|frac
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find unsigned HOST_WIDE_INT integer and floating point fractional parts.    A negative e type input yields integer output = 0    but correct fraction.  */
end_comment

begin_function
specifier|static
name|void
name|euifrac
parameter_list|(
name|x
parameter_list|,
name|i
parameter_list|,
name|frac
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
modifier|*
name|i
decl_stmt|;
name|unsigned
name|EMUSHORT
modifier|*
name|frac
decl_stmt|;
block|{
name|unsigned
name|HOST_WIDE_INT
name|ll
decl_stmt|;
name|unsigned
name|EMUSHORT
name|xi
index|[
name|NI
index|]
decl_stmt|;
name|int
name|j
decl_stmt|,
name|k
decl_stmt|;
name|emovi
argument_list|(
name|x
argument_list|,
name|xi
argument_list|)
expr_stmt|;
name|k
operator|=
operator|(
name|int
operator|)
name|xi
index|[
name|E
index|]
operator|-
operator|(
name|EXONE
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|k
operator|<=
literal|0
condition|)
block|{
comment|/* if exponent<= 0, integer = 0 and argument is fraction */
operator|*
name|i
operator|=
literal|0L
expr_stmt|;
name|emovo
argument_list|(
name|xi
argument_list|,
name|frac
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|k
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
comment|/* Long integer overflow: output large integer 	 and correct fraction. 	 Note, the BSD microvax compiler says that ~(0UL) 	 is a syntax error.  */
operator|*
name|i
operator|=
operator|~
operator|(
literal|0L
operator|)
expr_stmt|;
name|eshift
argument_list|(
name|xi
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|extra_warnings
condition|)
name|warning
argument_list|(
literal|"overflow on truncation to unsigned integer"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|k
operator|>
literal|16
condition|)
block|{
comment|/* Shift more than 16 bits: first shift up k-16 mod 16, 	 then shift up by 16's.  */
name|j
operator|=
name|k
operator|-
operator|(
operator|(
name|k
operator|>>
literal|4
operator|)
operator|<<
literal|4
operator|)
expr_stmt|;
name|eshift
argument_list|(
name|xi
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|ll
operator|=
name|xi
index|[
name|M
index|]
expr_stmt|;
name|k
operator|-=
name|j
expr_stmt|;
do|do
block|{
name|eshup6
argument_list|(
name|xi
argument_list|)
expr_stmt|;
name|ll
operator|=
operator|(
name|ll
operator|<<
literal|16
operator|)
operator||
name|xi
index|[
name|M
index|]
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|k
operator|-=
literal|16
operator|)
operator|>
literal|0
condition|)
do|;
operator|*
name|i
operator|=
name|ll
expr_stmt|;
block|}
else|else
block|{
comment|/* shift not more than 16 bits */
name|eshift
argument_list|(
name|xi
argument_list|,
name|k
argument_list|)
expr_stmt|;
operator|*
name|i
operator|=
operator|(
name|HOST_WIDE_INT
operator|)
name|xi
index|[
name|M
index|]
operator|&
literal|0xffff
expr_stmt|;
block|}
if|if
condition|(
name|xi
index|[
literal|0
index|]
condition|)
comment|/* A negative value yields unsigned integer 0. */
operator|*
name|i
operator|=
literal|0L
expr_stmt|;
name|xi
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|xi
index|[
name|E
index|]
operator|=
name|EXONE
operator|-
literal|1
expr_stmt|;
name|xi
index|[
name|M
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|k
operator|=
name|enormlz
argument_list|(
name|xi
argument_list|)
operator|)
operator|>
name|NBITS
condition|)
name|ecleaz
argument_list|(
name|xi
argument_list|)
expr_stmt|;
else|else
name|xi
index|[
name|E
index|]
operator|-=
operator|(
name|unsigned
name|EMUSHORT
operator|)
name|k
expr_stmt|;
name|emovo
argument_list|(
name|xi
argument_list|,
name|frac
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Shift significand area up or down by the number of bits given by SC.  */
end_comment

begin_function
specifier|static
name|int
name|eshift
parameter_list|(
name|x
parameter_list|,
name|sc
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|;
name|int
name|sc
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|lost
decl_stmt|;
name|unsigned
name|EMUSHORT
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|sc
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|lost
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|x
operator|+
name|NI
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|sc
operator|<
literal|0
condition|)
block|{
name|sc
operator|=
operator|-
name|sc
expr_stmt|;
while|while
condition|(
name|sc
operator|>=
literal|16
condition|)
block|{
name|lost
operator||=
operator|*
name|p
expr_stmt|;
comment|/* remember lost bits */
name|eshdn6
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|sc
operator|-=
literal|16
expr_stmt|;
block|}
while|while
condition|(
name|sc
operator|>=
literal|8
condition|)
block|{
name|lost
operator||=
operator|*
name|p
operator|&
literal|0xff
expr_stmt|;
name|eshdn8
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|sc
operator|-=
literal|8
expr_stmt|;
block|}
while|while
condition|(
name|sc
operator|>
literal|0
condition|)
block|{
name|lost
operator||=
operator|*
name|p
operator|&
literal|1
expr_stmt|;
name|eshdn1
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|sc
operator|-=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|sc
operator|>=
literal|16
condition|)
block|{
name|eshup6
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|sc
operator|-=
literal|16
expr_stmt|;
block|}
while|while
condition|(
name|sc
operator|>=
literal|8
condition|)
block|{
name|eshup8
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|sc
operator|-=
literal|8
expr_stmt|;
block|}
while|while
condition|(
name|sc
operator|>
literal|0
condition|)
block|{
name|eshup1
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|sc
operator|-=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|lost
condition|)
name|lost
operator|=
literal|1
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|lost
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Shift normalize the significand area pointed to by argument.    Shift count (up = positive) is returned.  */
end_comment

begin_function
specifier|static
name|int
name|enormlz
parameter_list|(
name|x
parameter_list|)
name|unsigned
name|EMUSHORT
name|x
index|[]
decl_stmt|;
block|{
specifier|register
name|unsigned
name|EMUSHORT
modifier|*
name|p
decl_stmt|;
name|int
name|sc
decl_stmt|;
name|sc
operator|=
literal|0
expr_stmt|;
name|p
operator|=
operator|&
name|x
index|[
name|M
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|0
condition|)
goto|goto
name|normdn
goto|;
operator|++
name|p
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|&
literal|0x8000
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* already normalized */
while|while
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
block|{
name|eshup6
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|sc
operator|+=
literal|16
expr_stmt|;
comment|/* With guard word, there are NBITS+16 bits available.        Return true if all are zero.  */
if|if
condition|(
name|sc
operator|>
name|NBITS
condition|)
return|return
operator|(
name|sc
operator|)
return|;
block|}
comment|/* see if high byte is zero */
while|while
condition|(
operator|(
operator|*
name|p
operator|&
literal|0xff00
operator|)
operator|==
literal|0
condition|)
block|{
name|eshup8
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|sc
operator|+=
literal|8
expr_stmt|;
block|}
comment|/* now shift 1 bit at a time */
while|while
condition|(
operator|(
operator|*
name|p
operator|&
literal|0x8000
operator|)
operator|==
literal|0
condition|)
block|{
name|eshup1
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|sc
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|sc
operator|>
name|NBITS
condition|)
block|{
name|mtherr
argument_list|(
literal|"enormlz"
argument_list|,
name|UNDERFLOW
argument_list|)
expr_stmt|;
return|return
operator|(
name|sc
operator|)
return|;
block|}
block|}
return|return
operator|(
name|sc
operator|)
return|;
comment|/* Normalize by shifting down out of the high guard word      of the significand */
name|normdn
label|:
if|if
condition|(
operator|*
name|p
operator|&
literal|0xff00
condition|)
block|{
name|eshdn8
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|sc
operator|-=
literal|8
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|p
operator|!=
literal|0
condition|)
block|{
name|eshdn1
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|sc
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|sc
operator|<
operator|-
name|NBITS
condition|)
block|{
name|mtherr
argument_list|(
literal|"enormlz"
argument_list|,
name|OVERFLOW
argument_list|)
expr_stmt|;
return|return
operator|(
name|sc
operator|)
return|;
block|}
block|}
return|return
operator|(
name|sc
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Convert e type number to decimal format ASCII string.    The constants are for 64 bit precision.  */
end_comment

begin_define
define|#
directive|define
name|NTEN
value|12
end_define

begin_define
define|#
directive|define
name|MAXP
value|4096
end_define

begin_if
if|#
directive|if
name|LONG_DOUBLE_TYPE_SIZE
operator|==
literal|128
end_if

begin_decl_stmt
specifier|static
name|unsigned
name|EMUSHORT
name|etens
index|[
name|NTEN
operator|+
literal|1
index|]
index|[
name|NE
index|]
init|=
block|{
block|{
literal|0x6576
block|,
literal|0x4a92
block|,
literal|0x804a
block|,
literal|0x153f
block|,
literal|0xc94c
block|,
literal|0x979a
block|,
literal|0x8a20
block|,
literal|0x5202
block|,
literal|0xc460
block|,
literal|0x7525
block|,}
block|,
comment|/* 10**4096 */
block|{
literal|0x6a32
block|,
literal|0xce52
block|,
literal|0x329a
block|,
literal|0x28ce
block|,
literal|0xa74d
block|,
literal|0x5de4
block|,
literal|0xc53d
block|,
literal|0x3b5d
block|,
literal|0x9e8b
block|,
literal|0x5a92
block|,}
block|,
comment|/* 10**2048 */
block|{
literal|0x526c
block|,
literal|0x50ce
block|,
literal|0xf18b
block|,
literal|0x3d28
block|,
literal|0x650d
block|,
literal|0x0c17
block|,
literal|0x8175
block|,
literal|0x7586
block|,
literal|0xc976
block|,
literal|0x4d48
block|,}
block|,
block|{
literal|0x9c66
block|,
literal|0x58f8
block|,
literal|0xbc50
block|,
literal|0x5c54
block|,
literal|0xcc65
block|,
literal|0x91c6
block|,
literal|0xa60e
block|,
literal|0xa0ae
block|,
literal|0xe319
block|,
literal|0x46a3
block|,}
block|,
block|{
literal|0x851e
block|,
literal|0xeab7
block|,
literal|0x98fe
block|,
literal|0x901b
block|,
literal|0xddbb
block|,
literal|0xde8d
block|,
literal|0x9df9
block|,
literal|0xebfb
block|,
literal|0xaa7e
block|,
literal|0x4351
block|,}
block|,
block|{
literal|0x0235
block|,
literal|0x0137
block|,
literal|0x36b1
block|,
literal|0x336c
block|,
literal|0xc66f
block|,
literal|0x8cdf
block|,
literal|0x80e9
block|,
literal|0x47c9
block|,
literal|0x93ba
block|,
literal|0x41a8
block|,}
block|,
block|{
literal|0x50f8
block|,
literal|0x25fb
block|,
literal|0xc76b
block|,
literal|0x6b71
block|,
literal|0x3cbf
block|,
literal|0xa6d5
block|,
literal|0xffcf
block|,
literal|0x1f49
block|,
literal|0xc278
block|,
literal|0x40d3
block|,}
block|,
block|{
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0xf020
block|,
literal|0xb59d
block|,
literal|0x2b70
block|,
literal|0xada8
block|,
literal|0x9dc5
block|,
literal|0x4069
block|,}
block|,
block|{
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0400
block|,
literal|0xc9bf
block|,
literal|0x8e1b
block|,
literal|0x4034
block|,}
block|,
block|{
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x2000
block|,
literal|0xbebc
block|,
literal|0x4019
block|,}
block|,
block|{
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x9c40
block|,
literal|0x400c
block|,}
block|,
block|{
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0xc800
block|,
literal|0x4005
block|,}
block|,
block|{
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0xa000
block|,
literal|0x4002
block|,}
block|,
comment|/* 10**1 */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|EMUSHORT
name|emtens
index|[
name|NTEN
operator|+
literal|1
index|]
index|[
name|NE
index|]
init|=
block|{
block|{
literal|0x2030
block|,
literal|0xcffc
block|,
literal|0xa1c3
block|,
literal|0x8123
block|,
literal|0x2de3
block|,
literal|0x9fde
block|,
literal|0xd2ce
block|,
literal|0x04c8
block|,
literal|0xa6dd
block|,
literal|0x0ad8
block|,}
block|,
comment|/* 10**-4096 */
block|{
literal|0x8264
block|,
literal|0xd2cb
block|,
literal|0xf2ea
block|,
literal|0x12d4
block|,
literal|0x4925
block|,
literal|0x2de4
block|,
literal|0x3436
block|,
literal|0x534f
block|,
literal|0xceae
block|,
literal|0x256b
block|,}
block|,
comment|/* 10**-2048 */
block|{
literal|0xf53f
block|,
literal|0xf698
block|,
literal|0x6bd3
block|,
literal|0x0158
block|,
literal|0x87a6
block|,
literal|0xc0bd
block|,
literal|0xda57
block|,
literal|0x82a5
block|,
literal|0xa2a6
block|,
literal|0x32b5
block|,}
block|,
block|{
literal|0xe731
block|,
literal|0x04d4
block|,
literal|0xe3f2
block|,
literal|0xd332
block|,
literal|0x7132
block|,
literal|0xd21c
block|,
literal|0xdb23
block|,
literal|0xee32
block|,
literal|0x9049
block|,
literal|0x395a
block|,}
block|,
block|{
literal|0xa23e
block|,
literal|0x5308
block|,
literal|0xfefb
block|,
literal|0x1155
block|,
literal|0xfa91
block|,
literal|0x1939
block|,
literal|0x637a
block|,
literal|0x4325
block|,
literal|0xc031
block|,
literal|0x3cac
block|,}
block|,
block|{
literal|0xe26d
block|,
literal|0xdbde
block|,
literal|0xd05d
block|,
literal|0xb3f6
block|,
literal|0xac7c
block|,
literal|0xe4a0
block|,
literal|0x64bc
block|,
literal|0x467c
block|,
literal|0xddd0
block|,
literal|0x3e55
block|,}
block|,
block|{
literal|0x2a20
block|,
literal|0x6224
block|,
literal|0x47b3
block|,
literal|0x98d7
block|,
literal|0x3f23
block|,
literal|0xe9a5
block|,
literal|0xa539
block|,
literal|0xea27
block|,
literal|0xa87f
block|,
literal|0x3f2a
block|,}
block|,
block|{
literal|0x0b5b
block|,
literal|0x4af2
block|,
literal|0xa581
block|,
literal|0x18ed
block|,
literal|0x67de
block|,
literal|0x94ba
block|,
literal|0x4539
block|,
literal|0x1ead
block|,
literal|0xcfb1
block|,
literal|0x3f94
block|,}
block|,
block|{
literal|0xbf71
block|,
literal|0xa9b3
block|,
literal|0x7989
block|,
literal|0xbe68
block|,
literal|0x4c2e
block|,
literal|0xe15b
block|,
literal|0xc44d
block|,
literal|0x94be
block|,
literal|0xe695
block|,
literal|0x3fc9
block|,}
block|,
block|{
literal|0x3d4d
block|,
literal|0x7c3d
block|,
literal|0x36ba
block|,
literal|0x0d2b
block|,
literal|0xfdc2
block|,
literal|0xcefc
block|,
literal|0x8461
block|,
literal|0x7711
block|,
literal|0xabcc
block|,
literal|0x3fe4
block|,}
block|,
block|{
literal|0xc155
block|,
literal|0xa4a8
block|,
literal|0x404e
block|,
literal|0x6113
block|,
literal|0xd3c3
block|,
literal|0x652b
block|,
literal|0xe219
block|,
literal|0x1758
block|,
literal|0xd1b7
block|,
literal|0x3ff1
block|,}
block|,
block|{
literal|0xd70a
block|,
literal|0x70a3
block|,
literal|0x0a3d
block|,
literal|0xa3d7
block|,
literal|0x3d70
block|,
literal|0xd70a
block|,
literal|0x70a3
block|,
literal|0x0a3d
block|,
literal|0xa3d7
block|,
literal|0x3ff8
block|,}
block|,
block|{
literal|0xcccd
block|,
literal|0xcccc
block|,
literal|0xcccc
block|,
literal|0xcccc
block|,
literal|0xcccc
block|,
literal|0xcccc
block|,
literal|0xcccc
block|,
literal|0xcccc
block|,
literal|0xcccc
block|,
literal|0x3ffb
block|,}
block|,
comment|/* 10**-1 */
block|}
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* LONG_DOUBLE_TYPE_SIZE is other than 128 */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|EMUSHORT
name|etens
index|[
name|NTEN
operator|+
literal|1
index|]
index|[
name|NE
index|]
init|=
block|{
block|{
literal|0xc94c
block|,
literal|0x979a
block|,
literal|0x8a20
block|,
literal|0x5202
block|,
literal|0xc460
block|,
literal|0x7525
block|,}
block|,
comment|/* 10**4096 */
block|{
literal|0xa74d
block|,
literal|0x5de4
block|,
literal|0xc53d
block|,
literal|0x3b5d
block|,
literal|0x9e8b
block|,
literal|0x5a92
block|,}
block|,
comment|/* 10**2048 */
block|{
literal|0x650d
block|,
literal|0x0c17
block|,
literal|0x8175
block|,
literal|0x7586
block|,
literal|0xc976
block|,
literal|0x4d48
block|,}
block|,
block|{
literal|0xcc65
block|,
literal|0x91c6
block|,
literal|0xa60e
block|,
literal|0xa0ae
block|,
literal|0xe319
block|,
literal|0x46a3
block|,}
block|,
block|{
literal|0xddbc
block|,
literal|0xde8d
block|,
literal|0x9df9
block|,
literal|0xebfb
block|,
literal|0xaa7e
block|,
literal|0x4351
block|,}
block|,
block|{
literal|0xc66f
block|,
literal|0x8cdf
block|,
literal|0x80e9
block|,
literal|0x47c9
block|,
literal|0x93ba
block|,
literal|0x41a8
block|,}
block|,
block|{
literal|0x3cbf
block|,
literal|0xa6d5
block|,
literal|0xffcf
block|,
literal|0x1f49
block|,
literal|0xc278
block|,
literal|0x40d3
block|,}
block|,
block|{
literal|0xf020
block|,
literal|0xb59d
block|,
literal|0x2b70
block|,
literal|0xada8
block|,
literal|0x9dc5
block|,
literal|0x4069
block|,}
block|,
block|{
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0400
block|,
literal|0xc9bf
block|,
literal|0x8e1b
block|,
literal|0x4034
block|,}
block|,
block|{
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x2000
block|,
literal|0xbebc
block|,
literal|0x4019
block|,}
block|,
block|{
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x9c40
block|,
literal|0x400c
block|,}
block|,
block|{
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0xc800
block|,
literal|0x4005
block|,}
block|,
block|{
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0xa000
block|,
literal|0x4002
block|,}
block|,
comment|/* 10**1 */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|EMUSHORT
name|emtens
index|[
name|NTEN
operator|+
literal|1
index|]
index|[
name|NE
index|]
init|=
block|{
block|{
literal|0x2de4
block|,
literal|0x9fde
block|,
literal|0xd2ce
block|,
literal|0x04c8
block|,
literal|0xa6dd
block|,
literal|0x0ad8
block|,}
block|,
comment|/* 10**-4096 */
block|{
literal|0x4925
block|,
literal|0x2de4
block|,
literal|0x3436
block|,
literal|0x534f
block|,
literal|0xceae
block|,
literal|0x256b
block|,}
block|,
comment|/* 10**-2048 */
block|{
literal|0x87a6
block|,
literal|0xc0bd
block|,
literal|0xda57
block|,
literal|0x82a5
block|,
literal|0xa2a6
block|,
literal|0x32b5
block|,}
block|,
block|{
literal|0x7133
block|,
literal|0xd21c
block|,
literal|0xdb23
block|,
literal|0xee32
block|,
literal|0x9049
block|,
literal|0x395a
block|,}
block|,
block|{
literal|0xfa91
block|,
literal|0x1939
block|,
literal|0x637a
block|,
literal|0x4325
block|,
literal|0xc031
block|,
literal|0x3cac
block|,}
block|,
block|{
literal|0xac7d
block|,
literal|0xe4a0
block|,
literal|0x64bc
block|,
literal|0x467c
block|,
literal|0xddd0
block|,
literal|0x3e55
block|,}
block|,
block|{
literal|0x3f24
block|,
literal|0xe9a5
block|,
literal|0xa539
block|,
literal|0xea27
block|,
literal|0xa87f
block|,
literal|0x3f2a
block|,}
block|,
block|{
literal|0x67de
block|,
literal|0x94ba
block|,
literal|0x4539
block|,
literal|0x1ead
block|,
literal|0xcfb1
block|,
literal|0x3f94
block|,}
block|,
block|{
literal|0x4c2f
block|,
literal|0xe15b
block|,
literal|0xc44d
block|,
literal|0x94be
block|,
literal|0xe695
block|,
literal|0x3fc9
block|,}
block|,
block|{
literal|0xfdc2
block|,
literal|0xcefc
block|,
literal|0x8461
block|,
literal|0x7711
block|,
literal|0xabcc
block|,
literal|0x3fe4
block|,}
block|,
block|{
literal|0xd3c3
block|,
literal|0x652b
block|,
literal|0xe219
block|,
literal|0x1758
block|,
literal|0xd1b7
block|,
literal|0x3ff1
block|,}
block|,
block|{
literal|0x3d71
block|,
literal|0xd70a
block|,
literal|0x70a3
block|,
literal|0x0a3d
block|,
literal|0xa3d7
block|,
literal|0x3ff8
block|,}
block|,
block|{
literal|0xcccd
block|,
literal|0xcccc
block|,
literal|0xcccc
block|,
literal|0xcccc
block|,
literal|0xcccc
block|,
literal|0x3ffb
block|,}
block|,
comment|/* 10**-1 */
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|e24toasc
parameter_list|(
name|x
parameter_list|,
name|string
parameter_list|,
name|ndigs
parameter_list|)
name|unsigned
name|EMUSHORT
name|x
index|[]
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|ndigs
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|w
index|[
name|NI
index|]
decl_stmt|;
name|e24toe
argument_list|(
name|x
argument_list|,
name|w
argument_list|)
expr_stmt|;
name|etoasc
argument_list|(
name|w
argument_list|,
name|string
argument_list|,
name|ndigs
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|e53toasc
parameter_list|(
name|x
parameter_list|,
name|string
parameter_list|,
name|ndigs
parameter_list|)
name|unsigned
name|EMUSHORT
name|x
index|[]
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|ndigs
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|w
index|[
name|NI
index|]
decl_stmt|;
name|e53toe
argument_list|(
name|x
argument_list|,
name|w
argument_list|)
expr_stmt|;
name|etoasc
argument_list|(
name|w
argument_list|,
name|string
argument_list|,
name|ndigs
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|e64toasc
parameter_list|(
name|x
parameter_list|,
name|string
parameter_list|,
name|ndigs
parameter_list|)
name|unsigned
name|EMUSHORT
name|x
index|[]
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|ndigs
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|w
index|[
name|NI
index|]
decl_stmt|;
name|e64toe
argument_list|(
name|x
argument_list|,
name|w
argument_list|)
expr_stmt|;
name|etoasc
argument_list|(
name|w
argument_list|,
name|string
argument_list|,
name|ndigs
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|e113toasc
parameter_list|(
name|x
parameter_list|,
name|string
parameter_list|,
name|ndigs
parameter_list|)
name|unsigned
name|EMUSHORT
name|x
index|[]
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|ndigs
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|w
index|[
name|NI
index|]
decl_stmt|;
name|e113toe
argument_list|(
name|x
argument_list|,
name|w
argument_list|)
expr_stmt|;
name|etoasc
argument_list|(
name|w
argument_list|,
name|string
argument_list|,
name|ndigs
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
name|wstring
index|[
literal|80
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* working storage for ASCII output */
end_comment

begin_function
specifier|static
name|void
name|etoasc
parameter_list|(
name|x
parameter_list|,
name|string
parameter_list|,
name|ndigs
parameter_list|)
name|unsigned
name|EMUSHORT
name|x
index|[]
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|ndigs
decl_stmt|;
block|{
name|EMUSHORT
name|digit
decl_stmt|;
name|unsigned
name|EMUSHORT
name|y
index|[
name|NI
index|]
decl_stmt|,
name|t
index|[
name|NI
index|]
decl_stmt|,
name|u
index|[
name|NI
index|]
decl_stmt|,
name|w
index|[
name|NI
index|]
decl_stmt|;
name|unsigned
name|EMUSHORT
modifier|*
name|p
decl_stmt|,
modifier|*
name|r
decl_stmt|,
modifier|*
name|ten
decl_stmt|;
name|unsigned
name|EMUSHORT
name|sign
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|expon
decl_stmt|,
name|rndsav
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|ss
decl_stmt|;
name|unsigned
name|EMUSHORT
name|m
decl_stmt|;
name|rndsav
operator|=
name|rndprc
expr_stmt|;
name|ss
operator|=
name|string
expr_stmt|;
name|s
operator|=
name|wstring
expr_stmt|;
operator|*
name|ss
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
ifdef|#
directive|ifdef
name|NANS
if|if
condition|(
name|eisnan
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|sprintf
argument_list|(
name|wstring
argument_list|,
literal|" NaN "
argument_list|)
expr_stmt|;
goto|goto
name|bxit
goto|;
block|}
endif|#
directive|endif
name|rndprc
operator|=
name|NBITS
expr_stmt|;
comment|/* set to full precision */
name|emov
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
comment|/* retain external format */
if|if
condition|(
name|y
index|[
name|NE
operator|-
literal|1
index|]
operator|&
literal|0x8000
condition|)
block|{
name|sign
operator|=
literal|0xffff
expr_stmt|;
name|y
index|[
name|NE
operator|-
literal|1
index|]
operator|&=
literal|0x7fff
expr_stmt|;
block|}
else|else
block|{
name|sign
operator|=
literal|0
expr_stmt|;
block|}
name|expon
operator|=
literal|0
expr_stmt|;
name|ten
operator|=
operator|&
name|etens
index|[
name|NTEN
index|]
index|[
literal|0
index|]
expr_stmt|;
name|emov
argument_list|(
name|eone
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* Test for zero exponent */
if|if
condition|(
name|y
index|[
name|NE
operator|-
literal|1
index|]
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|NE
operator|-
literal|1
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|y
index|[
name|k
index|]
operator|!=
literal|0
condition|)
goto|goto
name|tnzro
goto|;
comment|/* denormalized number */
block|}
goto|goto
name|isone
goto|;
comment|/* legal all zeros */
block|}
name|tnzro
label|:
comment|/* Test for infinity. */
if|if
condition|(
name|y
index|[
name|NE
operator|-
literal|1
index|]
operator|==
literal|0x7fff
condition|)
block|{
if|if
condition|(
name|sign
condition|)
name|sprintf
argument_list|(
name|wstring
argument_list|,
literal|" -Infinity "
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|wstring
argument_list|,
literal|" Infinity "
argument_list|)
expr_stmt|;
goto|goto
name|bxit
goto|;
block|}
comment|/* Test for exponent nonzero but significand denormalized.    * This is an error condition.    */
if|if
condition|(
operator|(
name|y
index|[
name|NE
operator|-
literal|1
index|]
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|y
index|[
name|NE
operator|-
literal|2
index|]
operator|&
literal|0x8000
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|mtherr
argument_list|(
literal|"etoasc"
argument_list|,
name|DOMAIN
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|wstring
argument_list|,
literal|"NaN"
argument_list|)
expr_stmt|;
goto|goto
name|bxit
goto|;
block|}
comment|/* Compare to 1.0 */
name|i
operator|=
name|ecmp
argument_list|(
name|eone
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
goto|goto
name|isone
goto|;
if|if
condition|(
name|i
operator|==
operator|-
literal|2
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
comment|/* Number is greater than 1 */
comment|/* Convert significand to an integer and strip trailing decimal zeros. */
name|emov
argument_list|(
name|y
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|u
index|[
name|NE
operator|-
literal|1
index|]
operator|=
name|EXONE
operator|+
name|NBITS
operator|-
literal|1
expr_stmt|;
name|p
operator|=
operator|&
name|etens
index|[
name|NTEN
operator|-
literal|4
index|]
index|[
literal|0
index|]
expr_stmt|;
name|m
operator|=
literal|16
expr_stmt|;
do|do
block|{
name|ediv
argument_list|(
name|p
argument_list|,
name|u
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|efloor
argument_list|(
name|t
argument_list|,
name|w
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NE
operator|-
literal|1
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|t
index|[
name|j
index|]
operator|!=
name|w
index|[
name|j
index|]
condition|)
goto|goto
name|noint
goto|;
block|}
name|emov
argument_list|(
name|t
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|expon
operator|+=
operator|(
name|int
operator|)
name|m
expr_stmt|;
name|noint
label|:
name|p
operator|+=
name|NE
expr_stmt|;
name|m
operator|>>=
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|m
operator|!=
literal|0
condition|)
do|;
comment|/* Rescale from integer significand */
name|u
index|[
name|NE
operator|-
literal|1
index|]
operator|+=
name|y
index|[
name|NE
operator|-
literal|1
index|]
operator|-
call|(
name|unsigned
name|int
call|)
argument_list|(
name|EXONE
operator|+
name|NBITS
operator|-
literal|1
argument_list|)
expr_stmt|;
name|emov
argument_list|(
name|u
argument_list|,
name|y
argument_list|)
expr_stmt|;
comment|/* Find power of 10 */
name|emov
argument_list|(
name|eone
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|m
operator|=
name|MAXP
expr_stmt|;
name|p
operator|=
operator|&
name|etens
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
comment|/* An unordered compare result shouldn't happen here. */
while|while
condition|(
name|ecmp
argument_list|(
name|ten
argument_list|,
name|u
argument_list|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|ecmp
argument_list|(
name|p
argument_list|,
name|u
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|ediv
argument_list|(
name|p
argument_list|,
name|u
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|emul
argument_list|(
name|p
argument_list|,
name|t
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|expon
operator|+=
operator|(
name|int
operator|)
name|m
expr_stmt|;
block|}
name|m
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
break|break;
name|p
operator|+=
name|NE
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Number is less than 1.0 */
comment|/* Pad significand with trailing decimal zeros. */
if|if
condition|(
name|y
index|[
name|NE
operator|-
literal|1
index|]
operator|==
literal|0
condition|)
block|{
while|while
condition|(
operator|(
name|y
index|[
name|NE
operator|-
literal|2
index|]
operator|&
literal|0x8000
operator|)
operator|==
literal|0
condition|)
block|{
name|emul
argument_list|(
name|ten
argument_list|,
name|y
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|expon
operator|-=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|emovi
argument_list|(
name|y
argument_list|,
name|w
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NDEC
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|w
index|[
name|NI
operator|-
literal|1
index|]
operator|&
literal|0x7
operator|)
operator|!=
literal|0
condition|)
break|break;
comment|/* multiply by 10 */
name|emovz
argument_list|(
name|w
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|eshdn1
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|eshdn1
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|eaddm
argument_list|(
name|w
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|u
index|[
literal|1
index|]
operator|+=
literal|3
expr_stmt|;
while|while
condition|(
name|u
index|[
literal|2
index|]
operator|!=
literal|0
condition|)
block|{
name|eshdn1
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|u
index|[
literal|1
index|]
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|u
index|[
name|NI
operator|-
literal|1
index|]
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|eone
index|[
name|NE
operator|-
literal|1
index|]
operator|<=
name|u
index|[
literal|1
index|]
condition|)
break|break;
name|emovz
argument_list|(
name|u
argument_list|,
name|w
argument_list|)
expr_stmt|;
name|expon
operator|-=
literal|1
expr_stmt|;
block|}
name|emovo
argument_list|(
name|w
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
name|k
operator|=
operator|-
name|MAXP
expr_stmt|;
name|p
operator|=
operator|&
name|emtens
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
name|r
operator|=
operator|&
name|etens
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
name|emov
argument_list|(
name|y
argument_list|,
name|w
argument_list|)
expr_stmt|;
name|emov
argument_list|(
name|eone
argument_list|,
name|t
argument_list|)
expr_stmt|;
while|while
condition|(
name|ecmp
argument_list|(
name|eone
argument_list|,
name|w
argument_list|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|ecmp
argument_list|(
name|p
argument_list|,
name|w
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|emul
argument_list|(
name|r
argument_list|,
name|w
argument_list|,
name|w
argument_list|)
expr_stmt|;
name|emul
argument_list|(
name|r
argument_list|,
name|t
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|expon
operator|+=
name|k
expr_stmt|;
block|}
name|k
operator|/=
literal|2
expr_stmt|;
if|if
condition|(
name|k
operator|==
literal|0
condition|)
break|break;
name|p
operator|+=
name|NE
expr_stmt|;
name|r
operator|+=
name|NE
expr_stmt|;
block|}
name|ediv
argument_list|(
name|t
argument_list|,
name|eone
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
name|isone
label|:
comment|/* Find the first (leading) digit. */
name|emovi
argument_list|(
name|t
argument_list|,
name|w
argument_list|)
expr_stmt|;
name|emovz
argument_list|(
name|w
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|emovi
argument_list|(
name|y
argument_list|,
name|w
argument_list|)
expr_stmt|;
name|emovz
argument_list|(
name|w
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|eiremain
argument_list|(
name|t
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|digit
operator|=
name|equot
index|[
name|NI
operator|-
literal|1
index|]
expr_stmt|;
while|while
condition|(
operator|(
name|digit
operator|==
literal|0
operator|)
operator|&&
operator|(
name|ecmp
argument_list|(
name|y
argument_list|,
name|ezero
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|eshup1
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|emovz
argument_list|(
name|y
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|eshup1
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|eshup1
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|eaddm
argument_list|(
name|u
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|eiremain
argument_list|(
name|t
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|digit
operator|=
name|equot
index|[
name|NI
operator|-
literal|1
index|]
expr_stmt|;
name|expon
operator|-=
literal|1
expr_stmt|;
block|}
name|s
operator|=
name|wstring
expr_stmt|;
if|if
condition|(
name|sign
condition|)
operator|*
name|s
operator|++
operator|=
literal|'-'
expr_stmt|;
else|else
operator|*
name|s
operator|++
operator|=
literal|' '
expr_stmt|;
comment|/* Examine number of digits requested by caller. */
if|if
condition|(
name|ndigs
operator|<
literal|0
condition|)
name|ndigs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ndigs
operator|>
name|NDEC
condition|)
name|ndigs
operator|=
name|NDEC
expr_stmt|;
if|if
condition|(
name|digit
operator|==
literal|10
condition|)
block|{
operator|*
name|s
operator|++
operator|=
literal|'1'
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|'.'
expr_stmt|;
if|if
condition|(
name|ndigs
operator|>
literal|0
condition|)
block|{
operator|*
name|s
operator|++
operator|=
literal|'0'
expr_stmt|;
name|ndigs
operator|-=
literal|1
expr_stmt|;
block|}
name|expon
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
operator|*
name|s
operator|++
operator|=
operator|(
name|char
operator|)
name|digit
operator|+
literal|'0'
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|'.'
expr_stmt|;
block|}
comment|/* Generate digits after the decimal point. */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<=
name|ndigs
condition|;
name|k
operator|++
control|)
block|{
comment|/* multiply current number by 10, without normalizing */
name|eshup1
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|emovz
argument_list|(
name|y
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|eshup1
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|eshup1
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|eaddm
argument_list|(
name|u
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|eiremain
argument_list|(
name|t
argument_list|,
name|y
argument_list|)
expr_stmt|;
operator|*
name|s
operator|++
operator|=
operator|(
name|char
operator|)
name|equot
index|[
name|NI
operator|-
literal|1
index|]
operator|+
literal|'0'
expr_stmt|;
block|}
name|digit
operator|=
name|equot
index|[
name|NI
operator|-
literal|1
index|]
expr_stmt|;
operator|--
name|s
expr_stmt|;
name|ss
operator|=
name|s
expr_stmt|;
comment|/* round off the ASCII string */
if|if
condition|(
name|digit
operator|>
literal|4
condition|)
block|{
comment|/* Test for critical rounding case in ASCII output. */
if|if
condition|(
name|digit
operator|==
literal|5
condition|)
block|{
name|emovo
argument_list|(
name|y
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecmp
argument_list|(
name|t
argument_list|,
name|ezero
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|roun
goto|;
comment|/* round to nearest */
if|if
condition|(
operator|(
operator|*
operator|(
name|s
operator|-
literal|1
operator|)
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
goto|goto
name|doexp
goto|;
comment|/* round to even */
block|}
comment|/* Round up and propagate carry-outs */
name|roun
label|:
operator|--
name|s
expr_stmt|;
name|k
operator|=
operator|*
name|s
operator|&
literal|0x7f
expr_stmt|;
comment|/* Carry out to most significant digit? */
if|if
condition|(
name|k
operator|==
literal|'.'
condition|)
block|{
operator|--
name|s
expr_stmt|;
name|k
operator|=
operator|*
name|s
expr_stmt|;
name|k
operator|+=
literal|1
expr_stmt|;
operator|*
name|s
operator|=
operator|(
name|char
operator|)
name|k
expr_stmt|;
comment|/* Most significant digit carries to 10? */
if|if
condition|(
name|k
operator|>
literal|'9'
condition|)
block|{
name|expon
operator|+=
literal|1
expr_stmt|;
operator|*
name|s
operator|=
literal|'1'
expr_stmt|;
block|}
goto|goto
name|doexp
goto|;
block|}
comment|/* Round up and carry out from less significant digits */
name|k
operator|+=
literal|1
expr_stmt|;
operator|*
name|s
operator|=
operator|(
name|char
operator|)
name|k
expr_stmt|;
if|if
condition|(
name|k
operator|>
literal|'9'
condition|)
block|{
operator|*
name|s
operator|=
literal|'0'
expr_stmt|;
goto|goto
name|roun
goto|;
block|}
block|}
name|doexp
label|:
comment|/*      if (expon>= 0)      sprintf (ss, "e+%d", expon);      else      sprintf (ss, "e%d", expon);      */
name|sprintf
argument_list|(
name|ss
argument_list|,
literal|"e%d"
argument_list|,
name|expon
argument_list|)
expr_stmt|;
name|bxit
label|:
name|rndprc
operator|=
name|rndsav
expr_stmt|;
comment|/* copy out the working string */
name|s
operator|=
name|string
expr_stmt|;
name|ss
operator|=
name|wstring
expr_stmt|;
while|while
condition|(
operator|*
name|ss
operator|==
literal|' '
condition|)
comment|/* strip possible leading space */
operator|++
name|ss
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|s
operator|++
operator|=
operator|*
name|ss
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
empty_stmt|;
block|}
end_function

begin_comment
comment|/* Convert ASCII string to quadruple precision floating point     Numeric input is free field decimal number with max of 15 digits with or    without decimal point entered as ASCII from teletype.  Entering E after    the number followed by a second number causes the second number to be    interpreted as a power of 10 to be multiplied by the first number    (i.e., "scientific" notation).  */
end_comment

begin_comment
comment|/* ASCII to single */
end_comment

begin_function
specifier|static
name|void
name|asctoe24
parameter_list|(
name|s
parameter_list|,
name|y
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|unsigned
name|EMUSHORT
modifier|*
name|y
decl_stmt|;
block|{
name|asctoeg
argument_list|(
name|s
argument_list|,
name|y
argument_list|,
literal|24
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ASCII to double */
end_comment

begin_function
specifier|static
name|void
name|asctoe53
parameter_list|(
name|s
parameter_list|,
name|y
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|unsigned
name|EMUSHORT
modifier|*
name|y
decl_stmt|;
block|{
if|#
directive|if
name|defined
argument_list|(
name|DEC
argument_list|)
operator|||
name|defined
argument_list|(
name|IBM
argument_list|)
name|asctoeg
argument_list|(
name|s
argument_list|,
name|y
argument_list|,
literal|56
argument_list|)
expr_stmt|;
else|#
directive|else
name|asctoeg
argument_list|(
name|s
argument_list|,
name|y
argument_list|,
literal|53
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ASCII to long double */
end_comment

begin_function
specifier|static
name|void
name|asctoe64
parameter_list|(
name|s
parameter_list|,
name|y
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|unsigned
name|EMUSHORT
modifier|*
name|y
decl_stmt|;
block|{
name|asctoeg
argument_list|(
name|s
argument_list|,
name|y
argument_list|,
literal|64
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ASCII to 128-bit long double */
end_comment

begin_function
specifier|static
name|void
name|asctoe113
parameter_list|(
name|s
parameter_list|,
name|y
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|unsigned
name|EMUSHORT
modifier|*
name|y
decl_stmt|;
block|{
name|asctoeg
argument_list|(
name|s
argument_list|,
name|y
argument_list|,
literal|113
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ASCII to super double */
end_comment

begin_function
specifier|static
name|void
name|asctoe
parameter_list|(
name|s
parameter_list|,
name|y
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|unsigned
name|EMUSHORT
modifier|*
name|y
decl_stmt|;
block|{
name|asctoeg
argument_list|(
name|s
argument_list|,
name|y
argument_list|,
name|NBITS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ASCII to e type, with specified rounding precision = oprec. */
end_comment

begin_function
specifier|static
name|void
name|asctoeg
parameter_list|(
name|ss
parameter_list|,
name|y
parameter_list|,
name|oprec
parameter_list|)
name|char
modifier|*
name|ss
decl_stmt|;
name|unsigned
name|EMUSHORT
modifier|*
name|y
decl_stmt|;
name|int
name|oprec
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|yy
index|[
name|NI
index|]
decl_stmt|,
name|xt
index|[
name|NI
index|]
decl_stmt|,
name|tt
index|[
name|NI
index|]
decl_stmt|;
name|int
name|esign
decl_stmt|,
name|decflg
decl_stmt|,
name|sgnflg
decl_stmt|,
name|nexp
decl_stmt|,
name|exp
decl_stmt|,
name|prec
decl_stmt|,
name|lost
decl_stmt|;
name|int
name|k
decl_stmt|,
name|trail
decl_stmt|,
name|c
decl_stmt|,
name|rndsav
decl_stmt|;
name|EMULONG
name|lexp
decl_stmt|;
name|unsigned
name|EMUSHORT
name|nsign
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|sp
decl_stmt|,
modifier|*
name|s
decl_stmt|,
modifier|*
name|lstr
decl_stmt|;
comment|/* Copy the input string. */
name|lstr
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|ss
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|s
operator|=
name|ss
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|==
literal|' '
condition|)
comment|/* skip leading spaces */
operator|++
name|s
expr_stmt|;
name|sp
operator|=
name|lstr
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|sp
operator|++
operator|=
operator|*
name|s
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
empty_stmt|;
name|s
operator|=
name|lstr
expr_stmt|;
name|rndsav
operator|=
name|rndprc
expr_stmt|;
name|rndprc
operator|=
name|NBITS
expr_stmt|;
comment|/* Set to full precision */
name|lost
operator|=
literal|0
expr_stmt|;
name|nsign
operator|=
literal|0
expr_stmt|;
name|decflg
operator|=
literal|0
expr_stmt|;
name|sgnflg
operator|=
literal|0
expr_stmt|;
name|nexp
operator|=
literal|0
expr_stmt|;
name|exp
operator|=
literal|0
expr_stmt|;
name|prec
operator|=
literal|0
expr_stmt|;
name|ecleaz
argument_list|(
name|yy
argument_list|)
expr_stmt|;
name|trail
operator|=
literal|0
expr_stmt|;
name|nxtcom
label|:
name|k
operator|=
operator|*
name|s
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
operator|(
name|k
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|k
operator|<=
literal|9
operator|)
condition|)
block|{
comment|/* Ignore leading zeros */
if|if
condition|(
operator|(
name|prec
operator|==
literal|0
operator|)
operator|&&
operator|(
name|decflg
operator|==
literal|0
operator|)
operator|&&
operator|(
name|k
operator|==
literal|0
operator|)
condition|)
goto|goto
name|donchr
goto|;
comment|/* Identify and strip trailing zeros after the decimal point. */
if|if
condition|(
operator|(
name|trail
operator|==
literal|0
operator|)
operator|&&
operator|(
name|decflg
operator|!=
literal|0
operator|)
condition|)
block|{
name|sp
operator|=
name|s
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|sp
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
operator|*
name|sp
operator|<=
literal|'9'
operator|)
condition|)
operator|++
name|sp
expr_stmt|;
comment|/* Check for syntax error */
name|c
operator|=
operator|*
name|sp
operator|&
literal|0x7f
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|!=
literal|'e'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'E'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'\0'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'\n'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'\r'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|' '
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|','
operator|)
condition|)
goto|goto
name|error
goto|;
operator|--
name|sp
expr_stmt|;
while|while
condition|(
operator|*
name|sp
operator|==
literal|'0'
condition|)
operator|*
name|sp
operator|--
operator|=
literal|'z'
expr_stmt|;
name|trail
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'z'
condition|)
goto|goto
name|donchr
goto|;
block|}
comment|/* If enough digits were given to more than fill up the yy register, 	 continuing until overflow into the high guard word yy[2] 	 guarantees that there will be a roundoff bit at the top 	 of the low guard word after normalization.  */
if|if
condition|(
name|yy
index|[
literal|2
index|]
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|decflg
condition|)
name|nexp
operator|+=
literal|1
expr_stmt|;
comment|/* count digits after decimal point */
name|eshup1
argument_list|(
name|yy
argument_list|)
expr_stmt|;
comment|/* multiply current number by 10 */
name|emovz
argument_list|(
name|yy
argument_list|,
name|xt
argument_list|)
expr_stmt|;
name|eshup1
argument_list|(
name|xt
argument_list|)
expr_stmt|;
name|eshup1
argument_list|(
name|xt
argument_list|)
expr_stmt|;
name|eaddm
argument_list|(
name|xt
argument_list|,
name|yy
argument_list|)
expr_stmt|;
name|ecleaz
argument_list|(
name|xt
argument_list|)
expr_stmt|;
name|xt
index|[
name|NI
operator|-
literal|2
index|]
operator|=
operator|(
name|unsigned
name|EMUSHORT
operator|)
name|k
expr_stmt|;
name|eaddm
argument_list|(
name|xt
argument_list|,
name|yy
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Mark any lost non-zero digit.  */
name|lost
operator||=
name|k
expr_stmt|;
comment|/* Count lost digits before the decimal point.  */
if|if
condition|(
name|decflg
operator|==
literal|0
condition|)
name|nexp
operator|-=
literal|1
expr_stmt|;
block|}
name|prec
operator|+=
literal|1
expr_stmt|;
goto|goto
name|donchr
goto|;
block|}
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'z'
case|:
break|break;
case|case
literal|'E'
case|:
case|case
literal|'e'
case|:
goto|goto
name|expnt
goto|;
case|case
literal|'.'
case|:
comment|/* decimal point */
if|if
condition|(
name|decflg
condition|)
goto|goto
name|error
goto|;
operator|++
name|decflg
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
name|nsign
operator|=
literal|0xffff
expr_stmt|;
if|if
condition|(
name|sgnflg
condition|)
goto|goto
name|error
goto|;
operator|++
name|sgnflg
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
if|if
condition|(
name|sgnflg
condition|)
goto|goto
name|error
goto|;
operator|++
name|sgnflg
expr_stmt|;
break|break;
case|case
literal|','
case|:
case|case
literal|' '
case|:
case|case
literal|'\0'
case|:
case|case
literal|'\n'
case|:
case|case
literal|'\r'
case|:
goto|goto
name|daldone
goto|;
case|case
literal|'i'
case|:
case|case
literal|'I'
case|:
goto|goto
name|infinite
goto|;
default|default:
name|error
label|:
ifdef|#
directive|ifdef
name|NANS
name|einan
argument_list|(
name|yy
argument_list|)
expr_stmt|;
else|#
directive|else
name|mtherr
argument_list|(
literal|"asctoe"
argument_list|,
name|DOMAIN
argument_list|)
expr_stmt|;
name|eclear
argument_list|(
name|yy
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|aexit
goto|;
block|}
name|donchr
label|:
operator|++
name|s
expr_stmt|;
goto|goto
name|nxtcom
goto|;
comment|/* Exponent interpretation */
name|expnt
label|:
name|esign
operator|=
literal|1
expr_stmt|;
name|exp
operator|=
literal|0
expr_stmt|;
operator|++
name|s
expr_stmt|;
comment|/* check for + or - */
if|if
condition|(
operator|*
name|s
operator|==
literal|'-'
condition|)
block|{
name|esign
operator|=
operator|-
literal|1
expr_stmt|;
operator|++
name|s
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|'+'
condition|)
operator|++
name|s
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|s
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
operator|*
name|s
operator|<=
literal|'9'
operator|)
condition|)
block|{
name|exp
operator|*=
literal|10
expr_stmt|;
name|exp
operator|+=
operator|*
name|s
operator|++
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|exp
operator|>
operator|-
operator|(
name|MINDECEXP
operator|)
condition|)
block|{
if|if
condition|(
name|esign
operator|<
literal|0
condition|)
goto|goto
name|zero
goto|;
else|else
goto|goto
name|infinite
goto|;
block|}
block|}
if|if
condition|(
name|esign
operator|<
literal|0
condition|)
name|exp
operator|=
operator|-
name|exp
expr_stmt|;
if|if
condition|(
name|exp
operator|>
name|MAXDECEXP
condition|)
block|{
name|infinite
label|:
name|ecleaz
argument_list|(
name|yy
argument_list|)
expr_stmt|;
name|yy
index|[
name|E
index|]
operator|=
literal|0x7fff
expr_stmt|;
comment|/* infinity */
goto|goto
name|aexit
goto|;
block|}
if|if
condition|(
name|exp
operator|<
name|MINDECEXP
condition|)
block|{
name|zero
label|:
name|ecleaz
argument_list|(
name|yy
argument_list|)
expr_stmt|;
goto|goto
name|aexit
goto|;
block|}
name|daldone
label|:
name|nexp
operator|=
name|exp
operator|-
name|nexp
expr_stmt|;
comment|/* Pad trailing zeros to minimize power of 10, per IEEE spec. */
while|while
condition|(
operator|(
name|nexp
operator|>
literal|0
operator|)
operator|&&
operator|(
name|yy
index|[
literal|2
index|]
operator|==
literal|0
operator|)
condition|)
block|{
name|emovz
argument_list|(
name|yy
argument_list|,
name|xt
argument_list|)
expr_stmt|;
name|eshup1
argument_list|(
name|xt
argument_list|)
expr_stmt|;
name|eshup1
argument_list|(
name|xt
argument_list|)
expr_stmt|;
name|eaddm
argument_list|(
name|yy
argument_list|,
name|xt
argument_list|)
expr_stmt|;
name|eshup1
argument_list|(
name|xt
argument_list|)
expr_stmt|;
if|if
condition|(
name|xt
index|[
literal|2
index|]
operator|!=
literal|0
condition|)
break|break;
name|nexp
operator|-=
literal|1
expr_stmt|;
name|emovz
argument_list|(
name|xt
argument_list|,
name|yy
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|k
operator|=
name|enormlz
argument_list|(
name|yy
argument_list|)
operator|)
operator|>
name|NBITS
condition|)
block|{
name|ecleaz
argument_list|(
name|yy
argument_list|)
expr_stmt|;
goto|goto
name|aexit
goto|;
block|}
name|lexp
operator|=
operator|(
name|EXONE
operator|-
literal|1
operator|+
name|NBITS
operator|)
operator|-
name|k
expr_stmt|;
name|emdnorm
argument_list|(
name|yy
argument_list|,
name|lost
argument_list|,
literal|0
argument_list|,
name|lexp
argument_list|,
literal|64
argument_list|)
expr_stmt|;
comment|/* Convert to external format:       Multiply by 10**nexp.  If precision is 64 bits,      the maximum relative error incurred in forming 10**n      for 0<= n<= 324 is 8.2e-20, at 10**180.      For 0<= n<= 999, the peak relative error is 1.4e-19 at 10**947.      For 0>= n>= -999, it is -1.55e-19 at 10**-435.  */
name|lexp
operator|=
name|yy
index|[
name|E
index|]
expr_stmt|;
if|if
condition|(
name|nexp
operator|==
literal|0
condition|)
block|{
name|k
operator|=
literal|0
expr_stmt|;
goto|goto
name|expdon
goto|;
block|}
name|esign
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|nexp
operator|<
literal|0
condition|)
block|{
name|nexp
operator|=
operator|-
name|nexp
expr_stmt|;
name|esign
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|nexp
operator|>
literal|4096
condition|)
block|{
comment|/* Punt.  Can't handle this without 2 divides. */
name|emovi
argument_list|(
name|etens
index|[
literal|0
index|]
argument_list|,
name|tt
argument_list|)
expr_stmt|;
name|lexp
operator|-=
name|tt
index|[
name|E
index|]
expr_stmt|;
name|k
operator|=
name|edivm
argument_list|(
name|tt
argument_list|,
name|yy
argument_list|)
expr_stmt|;
name|lexp
operator|+=
name|EXONE
expr_stmt|;
name|nexp
operator|-=
literal|4096
expr_stmt|;
block|}
block|}
name|p
operator|=
operator|&
name|etens
index|[
name|NTEN
index|]
index|[
literal|0
index|]
expr_stmt|;
name|emov
argument_list|(
name|eone
argument_list|,
name|xt
argument_list|)
expr_stmt|;
name|exp
operator|=
literal|1
expr_stmt|;
do|do
block|{
if|if
condition|(
name|exp
operator|&
name|nexp
condition|)
name|emul
argument_list|(
name|p
argument_list|,
name|xt
argument_list|,
name|xt
argument_list|)
expr_stmt|;
name|p
operator|-=
name|NE
expr_stmt|;
name|exp
operator|=
name|exp
operator|+
name|exp
expr_stmt|;
block|}
do|while
condition|(
name|exp
operator|<=
name|MAXP
condition|)
do|;
name|emovi
argument_list|(
name|xt
argument_list|,
name|tt
argument_list|)
expr_stmt|;
if|if
condition|(
name|esign
operator|<
literal|0
condition|)
block|{
name|lexp
operator|-=
name|tt
index|[
name|E
index|]
expr_stmt|;
name|k
operator|=
name|edivm
argument_list|(
name|tt
argument_list|,
name|yy
argument_list|)
expr_stmt|;
name|lexp
operator|+=
name|EXONE
expr_stmt|;
block|}
else|else
block|{
name|lexp
operator|+=
name|tt
index|[
name|E
index|]
expr_stmt|;
name|k
operator|=
name|emulm
argument_list|(
name|tt
argument_list|,
name|yy
argument_list|)
expr_stmt|;
name|lexp
operator|-=
name|EXONE
operator|-
literal|1
expr_stmt|;
block|}
name|expdon
label|:
comment|/* Round and convert directly to the destination type */
if|if
condition|(
name|oprec
operator|==
literal|53
condition|)
name|lexp
operator|-=
name|EXONE
operator|-
literal|0x3ff
expr_stmt|;
ifdef|#
directive|ifdef
name|IBM
elseif|else
if|if
condition|(
name|oprec
operator|==
literal|24
operator|||
name|oprec
operator|==
literal|56
condition|)
name|lexp
operator|-=
name|EXONE
operator|-
operator|(
literal|0x41
operator|<<
literal|2
operator|)
expr_stmt|;
else|#
directive|else
elseif|else
if|if
condition|(
name|oprec
operator|==
literal|24
condition|)
name|lexp
operator|-=
name|EXONE
operator|-
literal|0177
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEC
elseif|else
if|if
condition|(
name|oprec
operator|==
literal|56
condition|)
name|lexp
operator|-=
name|EXONE
operator|-
literal|0201
expr_stmt|;
endif|#
directive|endif
name|rndprc
operator|=
name|oprec
expr_stmt|;
name|emdnorm
argument_list|(
name|yy
argument_list|,
name|k
argument_list|,
literal|0
argument_list|,
name|lexp
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|aexit
label|:
name|rndprc
operator|=
name|rndsav
expr_stmt|;
name|yy
index|[
literal|0
index|]
operator|=
name|nsign
expr_stmt|;
switch|switch
condition|(
name|oprec
condition|)
block|{
ifdef|#
directive|ifdef
name|DEC
case|case
literal|56
case|:
name|todec
argument_list|(
name|yy
argument_list|,
name|y
argument_list|)
expr_stmt|;
comment|/* see etodec.c */
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IBM
case|case
literal|56
case|:
name|toibm
argument_list|(
name|yy
argument_list|,
name|y
argument_list|,
name|DFmode
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|53
case|:
name|toe53
argument_list|(
name|yy
argument_list|,
name|y
argument_list|)
expr_stmt|;
break|break;
case|case
literal|24
case|:
name|toe24
argument_list|(
name|yy
argument_list|,
name|y
argument_list|)
expr_stmt|;
break|break;
case|case
literal|64
case|:
name|toe64
argument_list|(
name|yy
argument_list|,
name|y
argument_list|)
expr_stmt|;
break|break;
case|case
literal|113
case|:
name|toe113
argument_list|(
name|yy
argument_list|,
name|y
argument_list|)
expr_stmt|;
break|break;
case|case
name|NBITS
case|:
name|emovo
argument_list|(
name|yy
argument_list|,
name|y
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* y = largest integer not greater than x (truncated toward minus infinity)  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|EMUSHORT
name|bmask
index|[]
init|=
block|{
literal|0xffff
block|,
literal|0xfffe
block|,
literal|0xfffc
block|,
literal|0xfff8
block|,
literal|0xfff0
block|,
literal|0xffe0
block|,
literal|0xffc0
block|,
literal|0xff80
block|,
literal|0xff00
block|,
literal|0xfe00
block|,
literal|0xfc00
block|,
literal|0xf800
block|,
literal|0xf000
block|,
literal|0xe000
block|,
literal|0xc000
block|,
literal|0x8000
block|,
literal|0x0000
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|efloor
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
name|unsigned
name|EMUSHORT
name|x
index|[]
decl_stmt|,
name|y
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|unsigned
name|EMUSHORT
modifier|*
name|p
decl_stmt|;
name|int
name|e
decl_stmt|,
name|expon
decl_stmt|,
name|i
decl_stmt|;
name|unsigned
name|EMUSHORT
name|f
index|[
name|NE
index|]
decl_stmt|;
name|emov
argument_list|(
name|x
argument_list|,
name|f
argument_list|)
expr_stmt|;
comment|/* leave in external format */
name|expon
operator|=
operator|(
name|int
operator|)
name|f
index|[
name|NE
operator|-
literal|1
index|]
expr_stmt|;
name|e
operator|=
operator|(
name|expon
operator|&
literal|0x7fff
operator|)
operator|-
operator|(
name|EXONE
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|e
operator|<=
literal|0
condition|)
block|{
name|eclear
argument_list|(
name|y
argument_list|)
expr_stmt|;
goto|goto
name|isitneg
goto|;
block|}
comment|/* number of bits to clear out */
name|e
operator|=
name|NBITS
operator|-
name|e
expr_stmt|;
name|emov
argument_list|(
name|f
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|<=
literal|0
condition|)
return|return;
name|p
operator|=
operator|&
name|y
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
name|e
operator|>=
literal|16
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
name|e
operator|-=
literal|16
expr_stmt|;
block|}
comment|/* clear the remaining bits */
operator|*
name|p
operator|&=
name|bmask
index|[
name|e
index|]
expr_stmt|;
comment|/* truncate negatives toward minus infinity */
name|isitneg
label|:
if|if
condition|(
operator|(
name|unsigned
name|EMUSHORT
operator|)
name|expon
operator|&
operator|(
name|unsigned
name|EMUSHORT
operator|)
literal|0x8000
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NE
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|f
index|[
name|i
index|]
operator|!=
name|y
index|[
name|i
index|]
condition|)
block|{
name|esub
argument_list|(
name|eone
argument_list|,
name|y
argument_list|,
name|y
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_block

begin_comment
comment|/* Returns s and exp such that  s * 2**exp = x and .5<= s< 1.    For example, 1.1 = 0.55 * 2**1    Handles denormalized numbers properly using long integer exp.  */
end_comment

begin_function
specifier|static
name|void
name|efrexp
parameter_list|(
name|x
parameter_list|,
name|exp
parameter_list|,
name|s
parameter_list|)
name|unsigned
name|EMUSHORT
name|x
index|[]
decl_stmt|;
name|int
modifier|*
name|exp
decl_stmt|;
name|unsigned
name|EMUSHORT
name|s
index|[]
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|xi
index|[
name|NI
index|]
decl_stmt|;
name|EMULONG
name|li
decl_stmt|;
name|emovi
argument_list|(
name|x
argument_list|,
name|xi
argument_list|)
expr_stmt|;
name|li
operator|=
call|(
name|EMULONG
call|)
argument_list|(
operator|(
name|EMUSHORT
operator|)
name|xi
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|li
operator|==
literal|0
condition|)
block|{
name|li
operator|-=
name|enormlz
argument_list|(
name|xi
argument_list|)
expr_stmt|;
block|}
name|xi
index|[
literal|1
index|]
operator|=
literal|0x3ffe
expr_stmt|;
name|emovo
argument_list|(
name|xi
argument_list|,
name|s
argument_list|)
expr_stmt|;
operator|*
name|exp
operator|=
call|(
name|int
call|)
argument_list|(
name|li
operator|-
literal|0x3ffe
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return y = x * 2**pwr2.  */
end_comment

begin_function
specifier|static
name|void
name|eldexp
parameter_list|(
name|x
parameter_list|,
name|pwr2
parameter_list|,
name|y
parameter_list|)
name|unsigned
name|EMUSHORT
name|x
index|[]
decl_stmt|;
name|int
name|pwr2
decl_stmt|;
name|unsigned
name|EMUSHORT
name|y
index|[]
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|xi
index|[
name|NI
index|]
decl_stmt|;
name|EMULONG
name|li
decl_stmt|;
name|int
name|i
decl_stmt|;
name|emovi
argument_list|(
name|x
argument_list|,
name|xi
argument_list|)
expr_stmt|;
name|li
operator|=
name|xi
index|[
literal|1
index|]
expr_stmt|;
name|li
operator|+=
name|pwr2
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|emdnorm
argument_list|(
name|xi
argument_list|,
name|i
argument_list|,
name|i
argument_list|,
name|li
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|emovo
argument_list|(
name|xi
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* c = remainder after dividing b by a    Least significant integer quotient bits left in equot[].  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|eremain
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|)
name|unsigned
name|EMUSHORT
name|a
index|[]
decl_stmt|,
name|b
index|[]
decl_stmt|,
name|c
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|unsigned
name|EMUSHORT
name|den
index|[
name|NI
index|]
decl_stmt|,
name|num
index|[
name|NI
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|NANS
if|if
condition|(
name|eisinf
argument_list|(
name|b
argument_list|)
operator|||
operator|(
name|ecmp
argument_list|(
name|a
argument_list|,
name|ezero
argument_list|)
operator|==
literal|0
operator|)
operator|||
name|eisnan
argument_list|(
name|a
argument_list|)
operator|||
name|eisnan
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|enan
argument_list|(
name|c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
if|if
condition|(
name|ecmp
argument_list|(
name|a
argument_list|,
name|ezero
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mtherr
argument_list|(
literal|"eremain"
argument_list|,
name|SING
argument_list|)
expr_stmt|;
name|eclear
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
name|emovi
argument_list|(
name|a
argument_list|,
name|den
argument_list|)
expr_stmt|;
name|emovi
argument_list|(
name|b
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|eiremain
argument_list|(
name|den
argument_list|,
name|num
argument_list|)
expr_stmt|;
comment|/* Sign of remainder = sign of quotient */
if|if
condition|(
name|a
index|[
literal|0
index|]
operator|==
name|b
index|[
literal|0
index|]
condition|)
name|num
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
else|else
name|num
index|[
literal|0
index|]
operator|=
literal|0xffff
expr_stmt|;
name|emovo
argument_list|(
name|num
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
specifier|static
name|void
name|eiremain
argument_list|(
name|den
argument_list|,
name|num
argument_list|)
name|unsigned
name|EMUSHORT
name|den
index|[]
decl_stmt|,
name|num
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|EMULONG
name|ld
decl_stmt|,
name|ln
decl_stmt|;
name|unsigned
name|EMUSHORT
name|j
decl_stmt|;
name|ld
operator|=
name|den
index|[
name|E
index|]
expr_stmt|;
name|ld
operator|-=
name|enormlz
argument_list|(
name|den
argument_list|)
expr_stmt|;
name|ln
operator|=
name|num
index|[
name|E
index|]
expr_stmt|;
name|ln
operator|-=
name|enormlz
argument_list|(
name|num
argument_list|)
expr_stmt|;
name|ecleaz
argument_list|(
name|equot
argument_list|)
expr_stmt|;
while|while
condition|(
name|ln
operator|>=
name|ld
condition|)
block|{
if|if
condition|(
name|ecmpm
argument_list|(
name|den
argument_list|,
name|num
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|esubm
argument_list|(
name|den
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|j
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|j
operator|=
literal|0
expr_stmt|;
block|}
name|eshup1
argument_list|(
name|equot
argument_list|)
expr_stmt|;
name|equot
index|[
name|NI
operator|-
literal|1
index|]
operator||=
name|j
expr_stmt|;
name|eshup1
argument_list|(
name|num
argument_list|)
expr_stmt|;
name|ln
operator|-=
literal|1
expr_stmt|;
block|}
name|emdnorm
argument_list|(
name|num
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|ln
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* This routine may be called to report one of the following    error conditions (in the include file mconf.h).      Mnemonic        Value          Significance        DOMAIN            1       argument domain error      SING              2       function singularity      OVERFLOW          3       overflow range error      UNDERFLOW         4       underflow range error      TLOSS             5       total loss of precision      PLOSS             6       partial loss of precision      INVALID           7       NaN - producing operation      EDOM             33       Unix domain error code      ERANGE           34       Unix range error code     The default version of the file prints the function name,   passed to it by the pointer fctnam, followed by the   error condition.  The display is directed to the standard   output device.  The routine then returns to the calling   program.  Users may wish to modify the program to abort by   calling exit under severe error conditions such as domain   errors.     Since all error conditions pass control to this function,   the display may be easily changed, eliminated, or directed   to an error logging device. */
end_comment

begin_comment
comment|/* Note: the order of appearance of the following messages is bound to the    error codes defined above.  */
end_comment

begin_define
define|#
directive|define
name|NMSGS
value|8
end_define

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ermsg
index|[
name|NMSGS
index|]
init|=
block|{
literal|"unknown"
block|,
comment|/* error code 0 */
literal|"domain"
block|,
comment|/* error code 1 */
literal|"singularity"
block|,
comment|/* et seq.      */
literal|"overflow"
block|,
literal|"underflow"
block|,
literal|"total loss of precision"
block|,
literal|"partial loss of precision"
block|,
literal|"invalid operation"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|merror
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|merror
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|mtherr
parameter_list|(
name|name
parameter_list|,
name|code
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|code
decl_stmt|;
block|{
name|char
name|errstr
index|[
literal|80
index|]
decl_stmt|;
comment|/* Display string passed by calling program, which is supposed to be the      name of the function in which the error occurred.       Display error message defined by the code argument.  */
if|if
condition|(
operator|(
name|code
operator|<=
literal|0
operator|)
operator|||
operator|(
name|code
operator|>=
name|NMSGS
operator|)
condition|)
name|code
operator|=
literal|0
expr_stmt|;
name|sprintf
argument_list|(
name|errstr
argument_list|,
literal|" %s %s error"
argument_list|,
name|name
argument_list|,
name|ermsg
index|[
name|code
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|extra_warnings
condition|)
name|warning
argument_list|(
name|errstr
argument_list|)
expr_stmt|;
comment|/* Set global error message word */
name|merror
operator|=
name|code
operator|+
literal|1
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEC
end_ifdef

begin_comment
comment|/* Convert DEC double precision to e type.  */
end_comment

begin_function
specifier|static
name|void
name|dectoe
parameter_list|(
name|d
parameter_list|,
name|e
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|d
decl_stmt|;
name|unsigned
name|EMUSHORT
modifier|*
name|e
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|y
index|[
name|NI
index|]
decl_stmt|;
specifier|register
name|unsigned
name|EMUSHORT
name|r
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|ecleaz
argument_list|(
name|y
argument_list|)
expr_stmt|;
comment|/* start with a zero */
name|p
operator|=
name|y
expr_stmt|;
comment|/* point to our number */
name|r
operator|=
operator|*
name|d
expr_stmt|;
comment|/* get DEC exponent word */
if|if
condition|(
operator|*
name|d
operator|&
operator|(
name|unsigned
name|int
operator|)
literal|0x8000
condition|)
operator|*
name|p
operator|=
literal|0xffff
expr_stmt|;
comment|/* fill in our sign */
operator|++
name|p
expr_stmt|;
comment|/* bump pointer to our exponent word */
name|r
operator|&=
literal|0x7fff
expr_stmt|;
comment|/* strip the sign bit */
if|if
condition|(
name|r
operator|==
literal|0
condition|)
comment|/* answer = 0 if high order DEC word = 0 */
goto|goto
name|done
goto|;
name|r
operator|>>=
literal|7
expr_stmt|;
comment|/* shift exponent word down 7 bits */
name|r
operator|+=
name|EXONE
operator|-
literal|0201
expr_stmt|;
comment|/* subtract DEC exponent offset */
comment|/* add our e type exponent offset */
operator|*
name|p
operator|++
operator|=
name|r
expr_stmt|;
comment|/* to form our exponent */
name|r
operator|=
operator|*
name|d
operator|++
expr_stmt|;
comment|/* now do the high order mantissa */
name|r
operator|&=
literal|0177
expr_stmt|;
comment|/* strip off the DEC exponent and sign bits */
name|r
operator||=
literal|0200
expr_stmt|;
comment|/* the DEC understood high order mantissa bit */
operator|*
name|p
operator|++
operator|=
name|r
expr_stmt|;
comment|/* put result in our high guard word */
operator|*
name|p
operator|++
operator|=
operator|*
name|d
operator|++
expr_stmt|;
comment|/* fill in the rest of our mantissa */
operator|*
name|p
operator|++
operator|=
operator|*
name|d
operator|++
expr_stmt|;
operator|*
name|p
operator|=
operator|*
name|d
expr_stmt|;
name|eshdn8
argument_list|(
name|y
argument_list|)
expr_stmt|;
comment|/* shift our mantissa down 8 bits */
name|done
label|:
name|emovo
argument_list|(
name|y
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ;	convert e type to DEC double precision ;	double d; ;	EMUSHORT e[NE]; ;	etodec (e,&d); */
end_comment

begin_function
specifier|static
name|void
name|etodec
parameter_list|(
name|x
parameter_list|,
name|d
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|,
decl|*
name|d
decl_stmt|;
end_function

begin_block
block|{
name|unsigned
name|EMUSHORT
name|xi
index|[
name|NI
index|]
decl_stmt|;
name|EMULONG
name|exp
decl_stmt|;
name|int
name|rndsav
decl_stmt|;
name|emovi
argument_list|(
name|x
argument_list|,
name|xi
argument_list|)
expr_stmt|;
name|exp
operator|=
operator|(
name|EMULONG
operator|)
name|xi
index|[
name|E
index|]
operator|-
operator|(
name|EXONE
operator|-
literal|0201
operator|)
expr_stmt|;
comment|/* adjust exponent for offsets */
comment|/* round off to nearest or even */
name|rndsav
operator|=
name|rndprc
expr_stmt|;
name|rndprc
operator|=
literal|56
expr_stmt|;
name|emdnorm
argument_list|(
name|xi
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|exp
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|rndprc
operator|=
name|rndsav
expr_stmt|;
name|todec
argument_list|(
name|xi
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|void
name|todec
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|,
decl|*
name|y
decl_stmt|;
end_function

begin_block
block|{
name|unsigned
name|EMUSHORT
name|i
decl_stmt|;
name|unsigned
name|EMUSHORT
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|x
expr_stmt|;
operator|*
name|y
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
condition|)
operator|*
name|y
operator|=
literal|0100000
expr_stmt|;
name|i
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
operator|*
name|y
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|y
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|y
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|y
operator|++
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|i
operator|>
literal|0377
condition|)
block|{
operator|*
name|y
operator|++
operator||=
literal|077777
expr_stmt|;
operator|*
name|y
operator|++
operator|=
literal|0xffff
expr_stmt|;
operator|*
name|y
operator|++
operator|=
literal|0xffff
expr_stmt|;
operator|*
name|y
operator|++
operator|=
literal|0xffff
expr_stmt|;
ifdef|#
directive|ifdef
name|ERANGE
name|errno
operator|=
name|ERANGE
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
name|i
operator|&=
literal|0377
expr_stmt|;
name|i
operator|<<=
literal|7
expr_stmt|;
name|eshup8
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|x
index|[
name|M
index|]
operator|&=
literal|0177
expr_stmt|;
name|i
operator||=
name|x
index|[
name|M
index|]
expr_stmt|;
operator|*
name|y
operator|++
operator||=
name|i
expr_stmt|;
operator|*
name|y
operator|++
operator|=
name|x
index|[
name|M
operator|+
literal|1
index|]
expr_stmt|;
operator|*
name|y
operator|++
operator|=
name|x
index|[
name|M
operator|+
literal|2
index|]
expr_stmt|;
operator|*
name|y
operator|++
operator|=
name|x
index|[
name|M
operator|+
literal|3
index|]
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEC */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|IBM
end_ifdef

begin_comment
comment|/* Convert IBM single/double precision to e type.  */
end_comment

begin_function
specifier|static
name|void
name|ibmtoe
parameter_list|(
name|d
parameter_list|,
name|e
parameter_list|,
name|mode
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|d
decl_stmt|;
name|unsigned
name|EMUSHORT
modifier|*
name|e
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|y
index|[
name|NI
index|]
decl_stmt|;
specifier|register
name|unsigned
name|EMUSHORT
name|r
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|rndsav
decl_stmt|;
name|ecleaz
argument_list|(
name|y
argument_list|)
expr_stmt|;
comment|/* start with a zero */
name|p
operator|=
name|y
expr_stmt|;
comment|/* point to our number */
name|r
operator|=
operator|*
name|d
expr_stmt|;
comment|/* get IBM exponent word */
if|if
condition|(
operator|*
name|d
operator|&
operator|(
name|unsigned
name|int
operator|)
literal|0x8000
condition|)
operator|*
name|p
operator|=
literal|0xffff
expr_stmt|;
comment|/* fill in our sign */
operator|++
name|p
expr_stmt|;
comment|/* bump pointer to our exponent word */
name|r
operator|&=
literal|0x7f00
expr_stmt|;
comment|/* strip the sign bit */
name|r
operator|>>=
literal|6
expr_stmt|;
comment|/* shift exponent word down 6 bits */
comment|/* in fact shift by 8 right and 2 left */
name|r
operator|+=
name|EXONE
operator|-
operator|(
literal|0x41
operator|<<
literal|2
operator|)
expr_stmt|;
comment|/* subtract IBM exponent offset */
comment|/* add our e type exponent offset */
operator|*
name|p
operator|++
operator|=
name|r
expr_stmt|;
comment|/* to form our exponent */
operator|*
name|p
operator|++
operator|=
operator|*
name|d
operator|++
operator|&
literal|0xff
expr_stmt|;
comment|/* now do the high order mantissa */
comment|/* strip off the IBM exponent and sign bits */
if|if
condition|(
name|mode
operator|!=
name|SFmode
condition|)
comment|/* there are only 2 words in SFmode */
block|{
operator|*
name|p
operator|++
operator|=
operator|*
name|d
operator|++
expr_stmt|;
comment|/* fill in the rest of our mantissa */
operator|*
name|p
operator|++
operator|=
operator|*
name|d
operator|++
expr_stmt|;
block|}
operator|*
name|p
operator|=
operator|*
name|d
expr_stmt|;
if|if
condition|(
name|y
index|[
name|M
index|]
operator|==
literal|0
operator|&&
name|y
index|[
name|M
operator|+
literal|1
index|]
operator|==
literal|0
operator|&&
name|y
index|[
name|M
operator|+
literal|2
index|]
operator|==
literal|0
operator|&&
name|y
index|[
name|M
operator|+
literal|3
index|]
operator|==
literal|0
condition|)
name|y
index|[
literal|0
index|]
operator|=
name|y
index|[
name|E
index|]
operator|=
literal|0
expr_stmt|;
else|else
name|y
index|[
name|E
index|]
operator|-=
literal|5
operator|+
name|enormlz
argument_list|(
name|y
argument_list|)
expr_stmt|;
comment|/* now normalise the mantissa */
comment|/* handle change in RADIX */
name|emovo
argument_list|(
name|y
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Convert e type to IBM single/double precision.  */
end_comment

begin_function
specifier|static
name|void
name|etoibm
parameter_list|(
name|x
parameter_list|,
name|d
parameter_list|,
name|mode
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|,
decl|*
name|d
decl_stmt|;
end_function

begin_decl_stmt
name|enum
name|machine_mode
name|mode
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|unsigned
name|EMUSHORT
name|xi
index|[
name|NI
index|]
decl_stmt|;
name|EMULONG
name|exp
decl_stmt|;
name|int
name|rndsav
decl_stmt|;
name|emovi
argument_list|(
name|x
argument_list|,
name|xi
argument_list|)
expr_stmt|;
name|exp
operator|=
operator|(
name|EMULONG
operator|)
name|xi
index|[
name|E
index|]
operator|-
operator|(
name|EXONE
operator|-
operator|(
literal|0x41
operator|<<
literal|2
operator|)
operator|)
expr_stmt|;
comment|/* adjust exponent for offsets */
comment|/* round off to nearest or even */
name|rndsav
operator|=
name|rndprc
expr_stmt|;
name|rndprc
operator|=
literal|56
expr_stmt|;
name|emdnorm
argument_list|(
name|xi
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|exp
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|rndprc
operator|=
name|rndsav
expr_stmt|;
name|toibm
argument_list|(
name|xi
argument_list|,
name|d
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|void
name|toibm
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|mode
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|,
decl|*
name|y
decl_stmt|;
end_function

begin_decl_stmt
name|enum
name|machine_mode
name|mode
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|unsigned
name|EMUSHORT
name|i
decl_stmt|;
name|unsigned
name|EMUSHORT
modifier|*
name|p
decl_stmt|;
name|int
name|r
decl_stmt|;
name|p
operator|=
name|x
expr_stmt|;
operator|*
name|y
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
condition|)
operator|*
name|y
operator|=
literal|0x8000
expr_stmt|;
name|i
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
operator|*
name|y
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|y
operator|++
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|SFmode
condition|)
block|{
operator|*
name|y
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|y
operator|++
operator|=
literal|0
expr_stmt|;
block|}
return|return;
block|}
name|r
operator|=
name|i
operator|&
literal|0x3
expr_stmt|;
name|i
operator|>>=
literal|2
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0x7f
condition|)
block|{
operator|*
name|y
operator|++
operator||=
literal|0x7fff
expr_stmt|;
operator|*
name|y
operator|++
operator|=
literal|0xffff
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|SFmode
condition|)
block|{
operator|*
name|y
operator|++
operator|=
literal|0xffff
expr_stmt|;
operator|*
name|y
operator|++
operator|=
literal|0xffff
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ERANGE
name|errno
operator|=
name|ERANGE
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
name|i
operator|&=
literal|0x7f
expr_stmt|;
operator|*
name|y
operator||=
operator|(
name|i
operator|<<
literal|8
operator|)
expr_stmt|;
name|eshift
argument_list|(
name|x
argument_list|,
name|r
operator|+
literal|5
argument_list|)
expr_stmt|;
operator|*
name|y
operator|++
operator||=
name|x
index|[
name|M
index|]
expr_stmt|;
operator|*
name|y
operator|++
operator|=
name|x
index|[
name|M
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|SFmode
condition|)
block|{
operator|*
name|y
operator|++
operator|=
name|x
index|[
name|M
operator|+
literal|2
index|]
expr_stmt|;
operator|*
name|y
operator|++
operator|=
name|x
index|[
name|M
operator|+
literal|3
index|]
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IBM */
end_comment

begin_comment
comment|/* Output a binary NaN bit pattern in the target machine's format.  */
end_comment

begin_comment
comment|/* If special NaN bit patterns are required, define them in tm.h    as arrays of unsigned 16-bit shorts.  Otherwise, use the default    patterns here. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TFMODE_NAN
end_ifdef

begin_expr_stmt
name|TFMODE_NAN
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|MIEEE
end_ifdef

begin_decl_stmt
name|unsigned
name|EMUSHORT
name|TFnan
index|[
literal|8
index|]
init|=
block|{
literal|0x7fff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|IBMPC
end_ifdef

begin_decl_stmt
name|unsigned
name|EMUSHORT
name|TFnan
index|[
literal|8
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0x8000
block|,
literal|0xffff
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|XFMODE_NAN
end_ifdef

begin_expr_stmt
name|XFMODE_NAN
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|MIEEE
end_ifdef

begin_decl_stmt
name|unsigned
name|EMUSHORT
name|XFnan
index|[
literal|6
index|]
init|=
block|{
literal|0x7fff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|IBMPC
end_ifdef

begin_decl_stmt
name|unsigned
name|EMUSHORT
name|XFnan
index|[
literal|6
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0xc000
block|,
literal|0xffff
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DFMODE_NAN
end_ifdef

begin_expr_stmt
name|DFMODE_NAN
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|MIEEE
end_ifdef

begin_decl_stmt
name|unsigned
name|EMUSHORT
name|DFnan
index|[
literal|4
index|]
init|=
block|{
literal|0x7fff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|IBMPC
end_ifdef

begin_decl_stmt
name|unsigned
name|EMUSHORT
name|DFnan
index|[
literal|4
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0xfff8
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SFMODE_NAN
end_ifdef

begin_expr_stmt
name|SFMODE_NAN
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|MIEEE
end_ifdef

begin_decl_stmt
name|unsigned
name|EMUSHORT
name|SFnan
index|[
literal|2
index|]
init|=
block|{
literal|0x7fff
block|,
literal|0xffff
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|IBMPC
end_ifdef

begin_decl_stmt
name|unsigned
name|EMUSHORT
name|SFnan
index|[
literal|2
index|]
init|=
block|{
literal|0
block|,
literal|0xffc0
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|make_nan
parameter_list|(
name|nan
parameter_list|,
name|sign
parameter_list|,
name|mode
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|nan
decl_stmt|;
name|int
name|sign
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
name|unsigned
name|EMUSHORT
modifier|*
name|p
decl_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
comment|/* Possibly the `reserved operand' patterns on a VAX can be    used like NaN's, but probably not in the same way as IEEE. */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DEC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|IBM
argument_list|)
case|case
name|TFmode
case|:
name|n
operator|=
literal|8
expr_stmt|;
name|p
operator|=
name|TFnan
expr_stmt|;
break|break;
case|case
name|XFmode
case|:
name|n
operator|=
literal|6
expr_stmt|;
name|p
operator|=
name|XFnan
expr_stmt|;
break|break;
case|case
name|DFmode
case|:
name|n
operator|=
literal|4
expr_stmt|;
name|p
operator|=
name|DFnan
expr_stmt|;
break|break;
case|case
name|HFmode
case|:
case|case
name|SFmode
case|:
name|n
operator|=
literal|2
expr_stmt|;
name|p
operator|=
name|SFnan
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|MIEEE
operator|*
name|nan
operator|++
operator|=
operator|(
name|sign
operator|<<
literal|15
operator|)
operator||
operator|*
name|p
operator|++
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
operator|--
name|n
operator|!=
literal|0
condition|)
operator|*
name|nan
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
ifndef|#
directive|ifndef
name|MIEEE
operator|*
name|nan
operator|=
operator|(
name|sign
operator|<<
literal|15
operator|)
operator||
operator|*
name|p
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Convert an SFmode target `float' value to a REAL_VALUE_TYPE.    This is the inverse of the function `etarsingle' invoked by    REAL_VALUE_TO_TARGET_SINGLE.  */
end_comment

begin_function
name|REAL_VALUE_TYPE
name|ereal_from_float
parameter_list|(
name|f
parameter_list|)
name|HOST_WIDE_INT
name|f
decl_stmt|;
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|unsigned
name|EMUSHORT
name|s
index|[
literal|2
index|]
decl_stmt|;
name|unsigned
name|EMUSHORT
name|e
index|[
name|NE
index|]
decl_stmt|;
comment|/* Convert 32 bit integer to array of 16 bit pieces in target machine order.    This is the inverse operation to what the function `endian' does.  */
if|#
directive|if
name|FLOAT_WORDS_BIG_ENDIAN
name|s
index|[
literal|0
index|]
operator|=
call|(
name|unsigned
name|EMUSHORT
call|)
argument_list|(
name|f
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|s
index|[
literal|1
index|]
operator|=
operator|(
name|unsigned
name|EMUSHORT
operator|)
name|f
expr_stmt|;
else|#
directive|else
name|s
index|[
literal|0
index|]
operator|=
operator|(
name|unsigned
name|EMUSHORT
operator|)
name|f
expr_stmt|;
name|s
index|[
literal|1
index|]
operator|=
call|(
name|unsigned
name|EMUSHORT
call|)
argument_list|(
name|f
operator|>>
literal|16
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Convert and promote the target float to E-type. */
name|e24toe
argument_list|(
name|s
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|/* Output E-type to REAL_VALUE_TYPE. */
name|PUT_REAL
argument_list|(
name|e
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Convert a DFmode target `double' value to a REAL_VALUE_TYPE.    This is the inverse of the function `etardouble' invoked by    REAL_VALUE_TO_TARGET_DOUBLE.     The DFmode is stored as an array of HOST_WIDE_INT in the target's    data format, with no holes in the bit packing.  The first element    of the input array holds the bits that would come first in the    target computer's memory.  */
end_comment

begin_function
name|REAL_VALUE_TYPE
name|ereal_from_double
parameter_list|(
name|d
parameter_list|)
name|HOST_WIDE_INT
name|d
index|[]
decl_stmt|;
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|unsigned
name|EMUSHORT
name|s
index|[
literal|4
index|]
decl_stmt|;
name|unsigned
name|EMUSHORT
name|e
index|[
name|NE
index|]
decl_stmt|;
comment|/* Convert array of HOST_WIDE_INT to equivalent array of 16-bit pieces.  */
if|#
directive|if
name|FLOAT_WORDS_BIG_ENDIAN
name|s
index|[
literal|0
index|]
operator|=
call|(
name|unsigned
name|EMUSHORT
call|)
argument_list|(
name|d
index|[
literal|0
index|]
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|s
index|[
literal|1
index|]
operator|=
operator|(
name|unsigned
name|EMUSHORT
operator|)
name|d
index|[
literal|0
index|]
expr_stmt|;
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|32
name|s
index|[
literal|2
index|]
operator|=
call|(
name|unsigned
name|EMUSHORT
call|)
argument_list|(
name|d
index|[
literal|1
index|]
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|s
index|[
literal|3
index|]
operator|=
operator|(
name|unsigned
name|EMUSHORT
operator|)
name|d
index|[
literal|1
index|]
expr_stmt|;
else|#
directive|else
comment|/* In this case the entire target double is contained in the      first array element.  The second element of the input is ignored.  */
name|s
index|[
literal|2
index|]
operator|=
call|(
name|unsigned
name|EMUSHORT
call|)
argument_list|(
name|d
index|[
literal|0
index|]
operator|>>
literal|48
argument_list|)
expr_stmt|;
name|s
index|[
literal|3
index|]
operator|=
call|(
name|unsigned
name|EMUSHORT
call|)
argument_list|(
name|d
index|[
literal|0
index|]
operator|>>
literal|32
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
comment|/* Target float words are little-endian.  */
name|s
index|[
literal|0
index|]
operator|=
operator|(
name|unsigned
name|EMUSHORT
operator|)
name|d
index|[
literal|0
index|]
expr_stmt|;
name|s
index|[
literal|1
index|]
operator|=
call|(
name|unsigned
name|EMUSHORT
call|)
argument_list|(
name|d
index|[
literal|0
index|]
operator|>>
literal|16
argument_list|)
expr_stmt|;
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|32
name|s
index|[
literal|2
index|]
operator|=
operator|(
name|unsigned
name|EMUSHORT
operator|)
name|d
index|[
literal|1
index|]
expr_stmt|;
name|s
index|[
literal|3
index|]
operator|=
call|(
name|unsigned
name|EMUSHORT
call|)
argument_list|(
name|d
index|[
literal|1
index|]
operator|>>
literal|16
argument_list|)
expr_stmt|;
else|#
directive|else
name|s
index|[
literal|2
index|]
operator|=
call|(
name|unsigned
name|EMUSHORT
call|)
argument_list|(
name|d
index|[
literal|0
index|]
operator|>>
literal|32
argument_list|)
expr_stmt|;
name|s
index|[
literal|3
index|]
operator|=
call|(
name|unsigned
name|EMUSHORT
call|)
argument_list|(
name|d
index|[
literal|0
index|]
operator|>>
literal|48
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* Convert target double to E-type. */
name|e53toe
argument_list|(
name|s
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|/* Output E-type to REAL_VALUE_TYPE. */
name|PUT_REAL
argument_list|(
name|e
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Convert target computer unsigned 64-bit integer to e-type.    The endian-ness of DImode follows the convention for integers,    so we use WORDS_BIG_ENDIAN here, not FLOAT_WORDS_BIG_ENDIAN.  */
end_comment

begin_function
specifier|static
name|void
name|uditoe
parameter_list|(
name|di
parameter_list|,
name|e
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|di
decl_stmt|;
comment|/* Address of the 64-bit int. */
name|unsigned
name|EMUSHORT
modifier|*
name|e
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|yi
index|[
name|NI
index|]
decl_stmt|;
name|int
name|k
decl_stmt|;
name|ecleaz
argument_list|(
name|yi
argument_list|)
expr_stmt|;
if|#
directive|if
name|WORDS_BIG_ENDIAN
for|for
control|(
name|k
operator|=
name|M
init|;
name|k
operator|<
name|M
operator|+
literal|4
condition|;
name|k
operator|++
control|)
name|yi
index|[
name|k
index|]
operator|=
operator|*
name|di
operator|++
expr_stmt|;
else|#
directive|else
for|for
control|(
name|k
operator|=
name|M
operator|+
literal|3
init|;
name|k
operator|>=
name|M
condition|;
name|k
operator|--
control|)
name|yi
index|[
name|k
index|]
operator|=
operator|*
name|di
operator|++
expr_stmt|;
endif|#
directive|endif
name|yi
index|[
name|E
index|]
operator|=
name|EXONE
operator|+
literal|47
expr_stmt|;
comment|/* exponent if normalize shift count were 0 */
if|if
condition|(
operator|(
name|k
operator|=
name|enormlz
argument_list|(
name|yi
argument_list|)
operator|)
operator|>
name|NBITS
condition|)
comment|/* normalize the significand */
name|ecleaz
argument_list|(
name|yi
argument_list|)
expr_stmt|;
comment|/* it was zero */
else|else
name|yi
index|[
name|E
index|]
operator|-=
operator|(
name|unsigned
name|EMUSHORT
operator|)
name|k
expr_stmt|;
comment|/* subtract shift count from exponent */
name|emovo
argument_list|(
name|yi
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Convert target computer signed 64-bit integer to e-type. */
end_comment

begin_function
specifier|static
name|void
name|ditoe
parameter_list|(
name|di
parameter_list|,
name|e
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|di
decl_stmt|;
comment|/* Address of the 64-bit int. */
name|unsigned
name|EMUSHORT
modifier|*
name|e
decl_stmt|;
block|{
name|unsigned
name|EMULONG
name|acc
decl_stmt|;
name|unsigned
name|EMUSHORT
name|yi
index|[
name|NI
index|]
decl_stmt|;
name|unsigned
name|EMUSHORT
name|carry
decl_stmt|;
name|int
name|k
decl_stmt|,
name|sign
decl_stmt|;
name|ecleaz
argument_list|(
name|yi
argument_list|)
expr_stmt|;
if|#
directive|if
name|WORDS_BIG_ENDIAN
for|for
control|(
name|k
operator|=
name|M
init|;
name|k
operator|<
name|M
operator|+
literal|4
condition|;
name|k
operator|++
control|)
name|yi
index|[
name|k
index|]
operator|=
operator|*
name|di
operator|++
expr_stmt|;
else|#
directive|else
for|for
control|(
name|k
operator|=
name|M
operator|+
literal|3
init|;
name|k
operator|>=
name|M
condition|;
name|k
operator|--
control|)
name|yi
index|[
name|k
index|]
operator|=
operator|*
name|di
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* Take absolute value */
name|sign
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|yi
index|[
name|M
index|]
operator|&
literal|0x8000
condition|)
block|{
name|sign
operator|=
literal|1
expr_stmt|;
name|carry
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|k
operator|=
name|M
operator|+
literal|3
init|;
name|k
operator|>=
name|M
condition|;
name|k
operator|--
control|)
block|{
name|acc
operator|=
call|(
name|unsigned
name|EMULONG
call|)
argument_list|(
operator|~
name|yi
index|[
name|k
index|]
operator|&
literal|0xffff
argument_list|)
operator|+
name|carry
expr_stmt|;
name|yi
index|[
name|k
index|]
operator|=
name|acc
expr_stmt|;
name|carry
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|acc
operator|&
literal|0x10000
condition|)
name|carry
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|yi
index|[
name|E
index|]
operator|=
name|EXONE
operator|+
literal|47
expr_stmt|;
comment|/* exponent if normalize shift count were 0 */
if|if
condition|(
operator|(
name|k
operator|=
name|enormlz
argument_list|(
name|yi
argument_list|)
operator|)
operator|>
name|NBITS
condition|)
comment|/* normalize the significand */
name|ecleaz
argument_list|(
name|yi
argument_list|)
expr_stmt|;
comment|/* it was zero */
else|else
name|yi
index|[
name|E
index|]
operator|-=
operator|(
name|unsigned
name|EMUSHORT
operator|)
name|k
expr_stmt|;
comment|/* subtract shift count from exponent */
name|emovo
argument_list|(
name|yi
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|sign
condition|)
name|eneg
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Convert e-type to unsigned 64-bit int. */
end_comment

begin_function
specifier|static
name|void
name|etoudi
parameter_list|(
name|x
parameter_list|,
name|i
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|;
name|unsigned
name|EMUSHORT
modifier|*
name|i
decl_stmt|;
block|{
name|unsigned
name|EMUSHORT
name|xi
index|[
name|NI
index|]
decl_stmt|;
name|int
name|j
decl_stmt|,
name|k
decl_stmt|;
name|emovi
argument_list|(
name|x
argument_list|,
name|xi
argument_list|)
expr_stmt|;
if|if
condition|(
name|xi
index|[
literal|0
index|]
condition|)
block|{
name|xi
index|[
name|M
index|]
operator|=
literal|0
expr_stmt|;
goto|goto
name|noshift
goto|;
block|}
name|k
operator|=
operator|(
name|int
operator|)
name|xi
index|[
name|E
index|]
operator|-
operator|(
name|EXONE
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|k
operator|<=
literal|0
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|4
condition|;
name|j
operator|++
control|)
operator|*
name|i
operator|++
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|k
operator|>
literal|64
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|4
condition|;
name|j
operator|++
control|)
operator|*
name|i
operator|++
operator|=
literal|0xffff
expr_stmt|;
if|if
condition|(
name|extra_warnings
condition|)
name|warning
argument_list|(
literal|"overflow on truncation to integer"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|k
operator|>
literal|16
condition|)
block|{
comment|/* Shift more than 16 bits: first shift up k-16 mod 16, 	 then shift up by 16's.  */
name|j
operator|=
name|k
operator|-
operator|(
operator|(
name|k
operator|>>
literal|4
operator|)
operator|<<
literal|4
operator|)
expr_stmt|;
if|if
condition|(
name|j
operator|==
literal|0
condition|)
name|j
operator|=
literal|16
expr_stmt|;
name|eshift
argument_list|(
name|xi
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|#
directive|if
name|WORDS_BIG_ENDIAN
operator|*
name|i
operator|++
operator|=
name|xi
index|[
name|M
index|]
expr_stmt|;
else|#
directive|else
name|i
operator|+=
literal|3
expr_stmt|;
operator|*
name|i
operator|--
operator|=
name|xi
index|[
name|M
index|]
expr_stmt|;
endif|#
directive|endif
name|k
operator|-=
name|j
expr_stmt|;
do|do
block|{
name|eshup6
argument_list|(
name|xi
argument_list|)
expr_stmt|;
if|#
directive|if
name|WORDS_BIG_ENDIAN
operator|*
name|i
operator|++
operator|=
name|xi
index|[
name|M
index|]
expr_stmt|;
else|#
directive|else
operator|*
name|i
operator|--
operator|=
name|xi
index|[
name|M
index|]
expr_stmt|;
endif|#
directive|endif
block|}
do|while
condition|(
operator|(
name|k
operator|-=
literal|16
operator|)
operator|>
literal|0
condition|)
do|;
block|}
else|else
block|{
comment|/* shift not more than 16 bits */
name|eshift
argument_list|(
name|xi
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|noshift
label|:
if|#
directive|if
name|WORDS_BIG_ENDIAN
name|i
operator|+=
literal|3
expr_stmt|;
operator|*
name|i
operator|--
operator|=
name|xi
index|[
name|M
index|]
expr_stmt|;
operator|*
name|i
operator|--
operator|=
literal|0
expr_stmt|;
operator|*
name|i
operator|--
operator|=
literal|0
expr_stmt|;
operator|*
name|i
operator|=
literal|0
expr_stmt|;
else|#
directive|else
operator|*
name|i
operator|++
operator|=
name|xi
index|[
name|M
index|]
expr_stmt|;
operator|*
name|i
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|i
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|i
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/* Convert e-type to signed 64-bit int. */
end_comment

begin_function
specifier|static
name|void
name|etodi
parameter_list|(
name|x
parameter_list|,
name|i
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|;
name|unsigned
name|EMUSHORT
modifier|*
name|i
decl_stmt|;
block|{
name|unsigned
name|EMULONG
name|acc
decl_stmt|;
name|unsigned
name|EMUSHORT
name|xi
index|[
name|NI
index|]
decl_stmt|;
name|unsigned
name|EMUSHORT
name|carry
decl_stmt|;
name|unsigned
name|EMUSHORT
modifier|*
name|isave
decl_stmt|;
name|int
name|j
decl_stmt|,
name|k
decl_stmt|;
name|emovi
argument_list|(
name|x
argument_list|,
name|xi
argument_list|)
expr_stmt|;
name|k
operator|=
operator|(
name|int
operator|)
name|xi
index|[
name|E
index|]
operator|-
operator|(
name|EXONE
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|k
operator|<=
literal|0
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|4
condition|;
name|j
operator|++
control|)
operator|*
name|i
operator|++
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|k
operator|>
literal|64
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|4
condition|;
name|j
operator|++
control|)
operator|*
name|i
operator|++
operator|=
literal|0xffff
expr_stmt|;
if|if
condition|(
name|extra_warnings
condition|)
name|warning
argument_list|(
literal|"overflow on truncation to integer"
argument_list|)
expr_stmt|;
return|return;
block|}
name|isave
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|k
operator|>
literal|16
condition|)
block|{
comment|/* Shift more than 16 bits: first shift up k-16 mod 16, 	 then shift up by 16's.  */
name|j
operator|=
name|k
operator|-
operator|(
operator|(
name|k
operator|>>
literal|4
operator|)
operator|<<
literal|4
operator|)
expr_stmt|;
if|if
condition|(
name|j
operator|==
literal|0
condition|)
name|j
operator|=
literal|16
expr_stmt|;
name|eshift
argument_list|(
name|xi
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|#
directive|if
name|WORDS_BIG_ENDIAN
operator|*
name|i
operator|++
operator|=
name|xi
index|[
name|M
index|]
expr_stmt|;
else|#
directive|else
name|i
operator|+=
literal|3
expr_stmt|;
operator|*
name|i
operator|--
operator|=
name|xi
index|[
name|M
index|]
expr_stmt|;
endif|#
directive|endif
name|k
operator|-=
name|j
expr_stmt|;
do|do
block|{
name|eshup6
argument_list|(
name|xi
argument_list|)
expr_stmt|;
if|#
directive|if
name|WORDS_BIG_ENDIAN
operator|*
name|i
operator|++
operator|=
name|xi
index|[
name|M
index|]
expr_stmt|;
else|#
directive|else
operator|*
name|i
operator|--
operator|=
name|xi
index|[
name|M
index|]
expr_stmt|;
endif|#
directive|endif
block|}
do|while
condition|(
operator|(
name|k
operator|-=
literal|16
operator|)
operator|>
literal|0
condition|)
do|;
block|}
else|else
block|{
comment|/* shift not more than 16 bits */
name|eshift
argument_list|(
name|xi
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|#
directive|if
name|WORDS_BIG_ENDIAN
name|i
operator|+=
literal|3
expr_stmt|;
operator|*
name|i
operator|=
name|xi
index|[
name|M
index|]
expr_stmt|;
operator|*
name|i
operator|--
operator|=
literal|0
expr_stmt|;
operator|*
name|i
operator|--
operator|=
literal|0
expr_stmt|;
operator|*
name|i
operator|=
literal|0
expr_stmt|;
else|#
directive|else
operator|*
name|i
operator|++
operator|=
name|xi
index|[
name|M
index|]
expr_stmt|;
operator|*
name|i
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|i
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|i
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Negate if negative */
if|if
condition|(
name|xi
index|[
literal|0
index|]
condition|)
block|{
name|carry
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|WORDS_BIG_ENDIAN
name|isave
operator|+=
literal|3
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
literal|4
condition|;
name|k
operator|++
control|)
block|{
name|acc
operator|=
call|(
name|unsigned
name|EMULONG
call|)
argument_list|(
operator|~
operator|(
operator|*
name|isave
operator|)
operator|&
literal|0xffff
argument_list|)
operator|+
name|carry
expr_stmt|;
if|#
directive|if
name|WORDS_BIG_ENDIAN
operator|*
name|isave
operator|--
operator|=
name|acc
expr_stmt|;
else|#
directive|else
operator|*
name|isave
operator|++
operator|=
name|acc
expr_stmt|;
endif|#
directive|endif
name|carry
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|acc
operator|&
literal|0x10000
condition|)
name|carry
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Longhand square root routine. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|esqinited
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|short
name|sqrndbit
index|[
name|NI
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|esqrt
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|unsigned
name|EMUSHORT
modifier|*
name|x
decl_stmt|,
decl|*
name|y
decl_stmt|;
end_function

begin_block
block|{
name|unsigned
name|EMUSHORT
name|temp
index|[
name|NI
index|]
decl_stmt|,
name|num
index|[
name|NI
index|]
decl_stmt|,
name|sq
index|[
name|NI
index|]
decl_stmt|,
name|xx
index|[
name|NI
index|]
decl_stmt|;
name|EMULONG
name|m
decl_stmt|,
name|exp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|n
decl_stmt|,
name|nlups
decl_stmt|;
if|if
condition|(
name|esqinited
operator|==
literal|0
condition|)
block|{
name|ecleaz
argument_list|(
name|sqrndbit
argument_list|)
expr_stmt|;
name|sqrndbit
index|[
name|NI
operator|-
literal|2
index|]
operator|=
literal|1
expr_stmt|;
name|esqinited
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Check for arg<= 0 */
name|i
operator|=
name|ecmp
argument_list|(
name|x
argument_list|,
name|ezero
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
block|{
name|mtherr
argument_list|(
literal|"esqrt"
argument_list|,
name|DOMAIN
argument_list|)
expr_stmt|;
name|eclear
argument_list|(
name|y
argument_list|)
expr_stmt|;
block|}
else|else
name|emov
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|INFINITY
if|if
condition|(
name|eisinf
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|eclear
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|einfin
argument_list|(
name|y
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* Bring in the arg and renormalize if it is denormal. */
name|emovi
argument_list|(
name|x
argument_list|,
name|xx
argument_list|)
expr_stmt|;
name|m
operator|=
operator|(
name|EMULONG
operator|)
name|xx
index|[
literal|1
index|]
expr_stmt|;
comment|/* local long word exponent */
if|if
condition|(
name|m
operator|==
literal|0
condition|)
name|m
operator|-=
name|enormlz
argument_list|(
name|xx
argument_list|)
expr_stmt|;
comment|/* Divide exponent by 2 */
name|m
operator|-=
literal|0x3ffe
expr_stmt|;
name|exp
operator|=
call|(
name|unsigned
name|short
call|)
argument_list|(
operator|(
name|m
operator|/
literal|2
operator|)
operator|+
literal|0x3ffe
argument_list|)
expr_stmt|;
comment|/* Adjust if exponent odd */
if|if
condition|(
operator|(
name|m
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|m
operator|>
literal|0
condition|)
name|exp
operator|+=
literal|1
expr_stmt|;
name|eshdn1
argument_list|(
name|xx
argument_list|)
expr_stmt|;
block|}
name|ecleaz
argument_list|(
name|sq
argument_list|)
expr_stmt|;
name|ecleaz
argument_list|(
name|num
argument_list|)
expr_stmt|;
name|n
operator|=
literal|8
expr_stmt|;
comment|/* get 8 bits of result per inner loop */
name|nlups
operator|=
name|rndprc
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|nlups
operator|>
literal|0
condition|)
block|{
comment|/* bring in next word of arg */
if|if
condition|(
name|j
operator|<
name|NE
condition|)
name|num
index|[
name|NI
operator|-
literal|1
index|]
operator|=
name|xx
index|[
name|j
operator|+
literal|3
index|]
expr_stmt|;
comment|/* Do additional bit on last outer loop, for roundoff. */
if|if
condition|(
name|nlups
operator|<=
literal|8
condition|)
name|n
operator|=
name|nlups
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
comment|/* Next 2 bits of arg */
name|eshup1
argument_list|(
name|num
argument_list|)
expr_stmt|;
name|eshup1
argument_list|(
name|num
argument_list|)
expr_stmt|;
comment|/* Shift up answer */
name|eshup1
argument_list|(
name|sq
argument_list|)
expr_stmt|;
comment|/* Make trial divisor */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|NI
condition|;
name|k
operator|++
control|)
name|temp
index|[
name|k
index|]
operator|=
name|sq
index|[
name|k
index|]
expr_stmt|;
name|eshup1
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|eaddm
argument_list|(
name|sqrndbit
argument_list|,
name|temp
argument_list|)
expr_stmt|;
comment|/* Subtract and insert answer bit if it goes in */
if|if
condition|(
name|ecmpm
argument_list|(
name|temp
argument_list|,
name|num
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|esubm
argument_list|(
name|temp
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|sq
index|[
name|NI
operator|-
literal|2
index|]
operator||=
literal|1
expr_stmt|;
block|}
block|}
name|nlups
operator|-=
name|n
expr_stmt|;
name|j
operator|+=
literal|1
expr_stmt|;
block|}
comment|/* Adjust for extra, roundoff loop done. */
name|exp
operator|+=
operator|(
name|NBITS
operator|-
literal|1
operator|)
operator|-
name|rndprc
expr_stmt|;
comment|/* Sticky bit = 1 if the remainder is nonzero. */
name|k
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|3
init|;
name|i
operator|<
name|NI
condition|;
name|i
operator|++
control|)
name|k
operator||=
operator|(
name|int
operator|)
name|num
index|[
name|i
index|]
expr_stmt|;
comment|/* Renormalize and round off. */
name|emdnorm
argument_list|(
name|sq
argument_list|,
name|k
argument_list|,
literal|0
argument_list|,
name|exp
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|emovo
argument_list|(
name|sq
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EMU_NON_COMPILE not defined */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Return the binary precision of the significand for a given    floating point mode.  The mode can hold an integer value    that many bits wide, without losing any bits.  */
end_comment

begin_function
name|int
name|significand_size
parameter_list|(
name|mode
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|SFmode
case|:
return|return
literal|24
return|;
case|case
name|DFmode
case|:
if|#
directive|if
name|TARGET_FLOAT_FORMAT
operator|==
name|IEEE_FLOAT_FORMAT
return|return
literal|53
return|;
else|#
directive|else
if|#
directive|if
name|TARGET_FLOAT_FORMAT
operator|==
name|IBM_FLOAT_FORMAT
return|return
literal|56
return|;
else|#
directive|else
if|#
directive|if
name|TARGET_FLOAT_FORMAT
operator|==
name|VAX_FLOAT_FORMAT
return|return
literal|56
return|;
else|#
directive|else
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
case|case
name|XFmode
case|:
return|return
literal|64
return|;
case|case
name|TFmode
case|:
return|return
literal|113
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

end_unit

