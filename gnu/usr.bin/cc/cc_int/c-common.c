begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Subroutines shared by all languages that are variants of C.    Copyright (C) 1992, 1993, 1994 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"c-lex.h"
end_include

begin_include
include|#
directive|include
file|"c-tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_decl_stmt
specifier|extern
name|struct
name|obstack
name|permanent_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|declare_hidden_char_array
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Make bindings for __FUNCTION__ and __PRETTY_FUNCTION__.  */
end_comment

begin_function
name|void
name|declare_function_name
parameter_list|()
block|{
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|printable_name
decl_stmt|;
if|if
condition|(
name|current_function_decl
operator|==
name|NULL
condition|)
block|{
name|name
operator|=
literal|""
expr_stmt|;
name|printable_name
operator|=
literal|"top level"
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|kind
init|=
literal|"function"
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|kind
operator|=
literal|"method"
expr_stmt|;
comment|/* Allow functions to be nameless (such as artificial ones).  */
if|if
condition|(
name|DECL_NAME
argument_list|(
name|current_function_decl
argument_list|)
condition|)
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|name
operator|=
literal|""
expr_stmt|;
name|printable_name
operator|=
call|(
modifier|*
name|decl_printable_name
call|)
argument_list|(
name|current_function_decl
argument_list|,
operator|&
name|kind
argument_list|)
expr_stmt|;
block|}
name|declare_hidden_char_array
argument_list|(
literal|"__FUNCTION__"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|declare_hidden_char_array
argument_list|(
literal|"__PRETTY_FUNCTION__"
argument_list|,
name|printable_name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|declare_hidden_char_array
parameter_list|(
name|name
parameter_list|,
name|value
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|,
decl|*
name|value
decl_stmt|;
end_function

begin_block
block|{
name|tree
name|decl
decl_stmt|,
name|type
decl_stmt|,
name|init
decl_stmt|;
name|int
name|vlen
decl_stmt|;
comment|/* If the default size of char arrays isn't big enough for the name,      or if we want to give warnings for large objects, make a bigger one.  */
name|vlen
operator|=
name|strlen
argument_list|(
name|value
argument_list|)
operator|+
literal|1
expr_stmt|;
name|type
operator|=
name|char_array_type_node
expr_stmt|;
if|if
condition|(
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
operator|<
name|vlen
operator|||
name|warn_larger_than
condition|)
name|type
operator|=
name|build_array_type
argument_list|(
name|char_type_node
argument_list|,
name|build_index_type
argument_list|(
name|build_int_2
argument_list|(
name|vlen
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|get_identifier
argument_list|(
name|name
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_IGNORED_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|init
operator|=
name|build_string
argument_list|(
name|vlen
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
operator|=
name|type
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|init
expr_stmt|;
name|finish_decl
argument_list|(
name|pushdecl
argument_list|(
name|decl
argument_list|)
argument_list|,
name|init
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Given a chain of STRING_CST nodes,    concatenate them into one STRING_CST    and give it a suitable array-of-chars data type.  */
end_comment

begin_function
name|tree
name|combine_strings
parameter_list|(
name|strings
parameter_list|)
name|tree
name|strings
decl_stmt|;
block|{
specifier|register
name|tree
name|value
decl_stmt|,
name|t
decl_stmt|;
specifier|register
name|int
name|length
init|=
literal|1
decl_stmt|;
name|int
name|wide_length
init|=
literal|0
decl_stmt|;
name|int
name|wide_flag
init|=
literal|0
decl_stmt|;
name|int
name|wchar_bytes
init|=
name|TYPE_PRECISION
argument_list|(
name|wchar_type_node
argument_list|)
operator|/
name|BITS_PER_UNIT
decl_stmt|;
name|int
name|nchars
decl_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|strings
argument_list|)
condition|)
block|{
comment|/* More than one in the chain, so concatenate.  */
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
comment|/* Don't include the \0 at the end of each substring, 	 except for the last one. 	 Count wide strings and ordinary strings separately.  */
for|for
control|(
name|t
operator|=
name|strings
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|==
name|wchar_array_type_node
condition|)
block|{
name|wide_length
operator|+=
operator|(
name|TREE_STRING_LENGTH
argument_list|(
name|t
argument_list|)
operator|-
name|wchar_bytes
operator|)
expr_stmt|;
name|wide_flag
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|length
operator|+=
operator|(
name|TREE_STRING_LENGTH
argument_list|(
name|t
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
block|}
comment|/* If anything is wide, the non-wides will be converted, 	 which makes them take more space.  */
if|if
condition|(
name|wide_flag
condition|)
name|length
operator|=
name|length
operator|*
name|wchar_bytes
operator|+
name|wide_length
expr_stmt|;
name|p
operator|=
name|savealloc
argument_list|(
name|length
argument_list|)
expr_stmt|;
comment|/* Copy the individual strings into the new combined string. 	 If the combined string is wide, convert the chars to ints 	 for any individual strings that are not wide.  */
name|q
operator|=
name|p
expr_stmt|;
for|for
control|(
name|t
operator|=
name|strings
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|int
name|len
init|=
operator|(
name|TREE_STRING_LENGTH
argument_list|(
name|t
argument_list|)
operator|-
operator|(
operator|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|==
name|wchar_array_type_node
operator|)
condition|?
name|wchar_bytes
else|:
literal|1
operator|)
operator|)
decl_stmt|;
if|if
condition|(
operator|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|==
name|wchar_array_type_node
operator|)
operator|==
name|wide_flag
condition|)
block|{
name|bcopy
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|t
argument_list|)
argument_list|,
name|q
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|q
operator|+=
name|len
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
operator|(
operator|(
name|int
operator|*
operator|)
name|q
operator|)
index|[
name|i
index|]
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|t
argument_list|)
index|[
name|i
index|]
expr_stmt|;
name|q
operator|+=
name|len
operator|*
name|wchar_bytes
expr_stmt|;
block|}
block|}
if|if
condition|(
name|wide_flag
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|wchar_bytes
condition|;
name|i
operator|++
control|)
operator|*
name|q
operator|++
operator|=
literal|0
expr_stmt|;
block|}
else|else
operator|*
name|q
operator|=
literal|0
expr_stmt|;
name|value
operator|=
name|make_node
argument_list|(
name|STRING_CST
argument_list|)
expr_stmt|;
name|TREE_STRING_POINTER
argument_list|(
name|value
argument_list|)
operator|=
name|p
expr_stmt|;
name|TREE_STRING_LENGTH
argument_list|(
name|value
argument_list|)
operator|=
name|length
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|value
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|value
operator|=
name|strings
expr_stmt|;
name|length
operator|=
name|TREE_STRING_LENGTH
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
operator|==
name|wchar_array_type_node
condition|)
name|wide_flag
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Compute the number of elements, for the array type.  */
name|nchars
operator|=
name|wide_flag
condition|?
name|length
operator|/
name|wchar_bytes
else|:
name|length
expr_stmt|;
comment|/* Create the array type for the string constant.      -Wwrite-strings says make the string constant an array of const char      so that copying it to a non-const pointer will get a warning.  */
if|if
condition|(
name|warn_write_strings
operator|&&
operator|(
operator|!
name|flag_traditional
operator|&&
operator|!
name|flag_writable_strings
operator|)
condition|)
block|{
name|tree
name|elements
init|=
name|build_type_variant
argument_list|(
name|wide_flag
condition|?
name|wchar_type_node
else|:
name|char_type_node
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
operator|=
name|build_array_type
argument_list|(
name|elements
argument_list|,
name|build_index_type
argument_list|(
name|build_int_2
argument_list|(
name|nchars
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
operator|=
name|build_array_type
argument_list|(
name|wide_flag
condition|?
name|wchar_type_node
else|:
name|char_type_node
argument_list|,
name|build_index_type
argument_list|(
name|build_int_2
argument_list|(
name|nchars
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|value
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|value
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Process the attributes listed in ATTRIBUTES    and install them in DECL.  */
end_comment

begin_function
name|void
name|decl_attributes
parameter_list|(
name|decl
parameter_list|,
name|attributes
parameter_list|)
name|tree
name|decl
decl_stmt|,
name|attributes
decl_stmt|;
block|{
name|tree
name|a
decl_stmt|,
name|name
decl_stmt|,
name|args
decl_stmt|,
name|type
decl_stmt|,
name|new_attr
decl_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|new_attr
operator|=
name|TYPE_ATTRIBUTES
argument_list|(
name|type
argument_list|)
expr_stmt|;
for|for
control|(
name|a
operator|=
name|attributes
init|;
name|a
condition|;
name|a
operator|=
name|TREE_CHAIN
argument_list|(
name|a
argument_list|)
control|)
if|if
condition|(
operator|!
operator|(
name|name
operator|=
name|TREE_VALUE
argument_list|(
name|a
argument_list|)
operator|)
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|name
operator|==
name|get_identifier
argument_list|(
literal|"packed"
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FIELD_DECL
condition|)
name|DECL_PACKED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* We can't set DECL_PACKED for a VAR_DECL, because the bit is 	   used for DECL_REGISTER.  It wouldn't mean anything anyway.  */
else|else
name|warning_with_decl
argument_list|(
name|decl
argument_list|,
literal|"`packed' attribute ignore"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|a
argument_list|)
operator|==
name|get_identifier
argument_list|(
literal|"noreturn"
argument_list|)
operator|||
name|TREE_VALUE
argument_list|(
name|a
argument_list|)
operator|==
name|get_identifier
argument_list|(
literal|"volatile"
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|TREE_THIS_VOLATILE
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|type
operator|=
name|build_pointer_type
argument_list|(
name|build_type_variant
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TREE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|warning_with_decl
argument_list|(
name|decl
argument_list|,
literal|"`%s' attribute ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|a
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|a
argument_list|)
operator|==
name|get_identifier
argument_list|(
literal|"const"
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|type
operator|=
name|build_pointer_type
argument_list|(
name|build_type_variant
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|,
name|TREE_THIS_VOLATILE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|warning_with_decl
argument_list|(
name|decl
argument_list|,
literal|"`const' attribute ignored"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|a
argument_list|)
operator|==
name|get_identifier
argument_list|(
literal|"transparent_union"
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|PARM_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
operator|&&
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|DECL_MODE
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|DECL_TRANSPARENT_UNION
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
operator|&&
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|DECL_MODE
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|TYPE_TRANSPARENT_UNION
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
name|warning_with_decl
argument_list|(
name|decl
argument_list|,
literal|"`transparent_union' attribute ignored"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|!=
name|TREE_LIST
condition|)
block|{
ifdef|#
directive|ifdef
name|VALID_MACHINE_ATTRIBUTE
if|if
condition|(
name|VALID_MACHINE_ATTRIBUTE
argument_list|(
name|type
argument_list|,
name|new_attr
argument_list|,
name|name
argument_list|)
condition|)
block|{
specifier|register
name|tree
name|atlist
decl_stmt|;
for|for
control|(
name|atlist
operator|=
name|new_attr
init|;
name|atlist
condition|;
name|atlist
operator|=
name|TREE_CHAIN
argument_list|(
name|atlist
argument_list|)
control|)
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|atlist
argument_list|)
operator|==
name|name
condition|)
goto|goto
name|found_attr
goto|;
name|new_attr
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|name
argument_list|,
name|new_attr
argument_list|)
expr_stmt|;
name|found_attr
label|:
empty_stmt|;
block|}
else|else
endif|#
directive|endif
name|warning
argument_list|(
literal|"`%s' attribute directive ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|args
operator|=
name|TREE_CHAIN
argument_list|(
name|name
argument_list|)
operator|,
operator|!
name|strcmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|name
operator|=
name|TREE_PURPOSE
argument_list|(
name|name
argument_list|)
argument_list|)
argument_list|,
literal|"mode"
argument_list|)
operator|&&
name|list_length
argument_list|(
name|args
argument_list|)
operator|==
literal|1
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|specified_name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Give this decl a type with the specified mode.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_MACHINE_MODES
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|specified_name
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|typefm
init|=
name|type_for_mode
argument_list|(
name|i
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|typefm
operator|!=
literal|0
condition|)
block|{
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|type
operator|=
name|typefm
expr_stmt|;
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|layout_decl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"no data type for mode `%s'"
argument_list|,
name|specified_name
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|NUM_MACHINE_MODES
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"unknown machine mode `%s'"
argument_list|,
name|specified_name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"section"
argument_list|)
operator|&&
name|list_length
argument_list|(
name|args
argument_list|)
operator|==
literal|1
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
argument_list|)
operator|==
name|STRING_CST
condition|)
block|{
ifdef|#
directive|ifdef
name|ASM_OUTPUT_SECTION_NAME
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|current_function_decl
operator|!=
name|NULL_TREE
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"section attribute cannot be specified for local variables"
argument_list|)
expr_stmt|;
comment|/* The decl may have already been given a section attribute from 	       a previous declaration.  Ensure they match.  */
elseif|else
if|if
condition|(
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|strcmp
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"section of `%s' conflicts with previous declaration"
argument_list|)
expr_stmt|;
else|else
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
else|else
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"section attribute not allowed for `%s'"
argument_list|)
expr_stmt|;
else|#
directive|else
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"section attributes are not supported for this target"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"aligned"
argument_list|)
operator|&&
name|list_length
argument_list|(
name|args
argument_list|)
operator|==
literal|1
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|tree
name|align_expr
init|=
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
decl_stmt|;
name|int
name|align
decl_stmt|;
comment|/* Strip any NOPs of any kind.  */
while|while
condition|(
name|TREE_CODE
argument_list|(
name|align_expr
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|align_expr
argument_list|)
operator|==
name|CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|align_expr
argument_list|)
operator|==
name|NON_LVALUE_EXPR
condition|)
name|align_expr
operator|=
name|TREE_OPERAND
argument_list|(
name|align_expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|align_expr
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"requested alignment of `%s' is not a constant"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|align
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|align_expr
argument_list|)
operator|*
name|BITS_PER_UNIT
expr_stmt|;
if|if
condition|(
name|exact_log2
argument_list|(
name|align
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"requested alignment of `%s' is not a power of 2"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"alignment specified for `%s'"
argument_list|)
expr_stmt|;
else|else
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|=
name|align
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"format"
argument_list|)
operator|&&
name|list_length
argument_list|(
name|args
argument_list|)
operator|==
literal|3
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|tree
name|format_type
init|=
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
decl_stmt|;
name|tree
name|format_num_expr
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|first_arg_num_expr
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|format_num
decl_stmt|;
name|int
name|first_arg_num
decl_stmt|;
name|int
name|is_scan
decl_stmt|;
name|tree
name|argument
decl_stmt|;
name|int
name|arg_num
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
block|{
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"argument format specified for non-function `%s'"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|format_type
argument_list|)
argument_list|,
literal|"printf"
argument_list|)
condition|)
name|is_scan
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|format_type
argument_list|)
argument_list|,
literal|"scanf"
argument_list|)
condition|)
name|is_scan
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"unrecognized format specifier for `%s'"
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Strip any conversions from the string index and first arg number 	   and verify they are constants.  */
while|while
condition|(
name|TREE_CODE
argument_list|(
name|format_num_expr
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|format_num_expr
argument_list|)
operator|==
name|CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|format_num_expr
argument_list|)
operator|==
name|NON_LVALUE_EXPR
condition|)
name|format_num_expr
operator|=
name|TREE_OPERAND
argument_list|(
name|format_num_expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|first_arg_num_expr
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|first_arg_num_expr
argument_list|)
operator|==
name|CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|first_arg_num_expr
argument_list|)
operator|==
name|NON_LVALUE_EXPR
condition|)
name|first_arg_num_expr
operator|=
name|TREE_OPERAND
argument_list|(
name|first_arg_num_expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|format_num_expr
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|first_arg_num_expr
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"format string for `%s' has non-constant operand number"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|format_num
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|format_num_expr
argument_list|)
expr_stmt|;
name|first_arg_num
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|first_arg_num_expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_arg_num
operator|!=
literal|0
operator|&&
name|first_arg_num
operator|<=
name|format_num
condition|)
block|{
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"format string arg follows the args to be formatted, for `%s'"
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* If a parameter list is specified, verify that the format_num 	   argument is actually a string, in case the format attribute 	   is in error.  */
name|argument
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|argument
condition|)
block|{
for|for
control|(
name|arg_num
operator|=
literal|1
init|;
condition|;
operator|++
name|arg_num
control|)
block|{
if|if
condition|(
name|argument
operator|==
literal|0
operator|||
name|arg_num
operator|==
name|format_num
condition|)
break|break;
name|argument
operator|=
name|TREE_CHAIN
argument_list|(
name|argument
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|argument
operator|||
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|argument
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
operator|||
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|argument
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|char_type_node
operator|)
condition|)
block|{
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"format string arg not a string type, for `%s'"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|first_arg_num
operator|!=
literal|0
condition|)
block|{
comment|/* Verify that first_arg_num points to the last arg, the ... */
while|while
condition|(
name|argument
condition|)
name|arg_num
operator|++
operator|,
name|argument
operator|=
name|TREE_CHAIN
argument_list|(
name|argument
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg_num
operator|!=
name|first_arg_num
condition|)
block|{
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"args to be formatted is not ..., for `%s'"
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
block|}
name|record_function_format
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
name|is_scan
argument_list|,
name|format_num
argument_list|,
name|first_arg_num
argument_list|)
expr_stmt|;
block|}
else|else
name|warning
argument_list|(
literal|"`%s' attribute directive ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|build_type_attribute_variant
argument_list|(
name|type
argument_list|,
name|new_attr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Check a printf/fprintf/sprintf/scanf/fscanf/sscanf format against    a parameter list.  */
end_comment

begin_define
define|#
directive|define
name|T_I
value|&integer_type_node
end_define

begin_define
define|#
directive|define
name|T_L
value|&long_integer_type_node
end_define

begin_define
define|#
directive|define
name|T_LL
value|&long_long_integer_type_node
end_define

begin_define
define|#
directive|define
name|T_S
value|&short_integer_type_node
end_define

begin_define
define|#
directive|define
name|T_UI
value|&unsigned_type_node
end_define

begin_define
define|#
directive|define
name|T_UL
value|&long_unsigned_type_node
end_define

begin_define
define|#
directive|define
name|T_ULL
value|&long_long_unsigned_type_node
end_define

begin_define
define|#
directive|define
name|T_US
value|&short_unsigned_type_node
end_define

begin_define
define|#
directive|define
name|T_F
value|&float_type_node
end_define

begin_define
define|#
directive|define
name|T_D
value|&double_type_node
end_define

begin_define
define|#
directive|define
name|T_LD
value|&long_double_type_node
end_define

begin_define
define|#
directive|define
name|T_C
value|&char_type_node
end_define

begin_define
define|#
directive|define
name|T_V
value|&void_type_node
end_define

begin_define
define|#
directive|define
name|T_W
value|&wchar_type_node
end_define

begin_define
define|#
directive|define
name|T_ST
value|&sizetype
end_define

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|format_chars
decl_stmt|;
name|int
name|pointer_count
decl_stmt|;
comment|/* Type of argument if no length modifier is used.  */
name|tree
modifier|*
name|nolen
decl_stmt|;
comment|/* Type of argument if length modifier for shortening is used.      If NULL, then this modifier is not allowed.  */
name|tree
modifier|*
name|hlen
decl_stmt|;
comment|/* Type of argument if length modifier `l' is used.      If NULL, then this modifier is not allowed.  */
name|tree
modifier|*
name|llen
decl_stmt|;
comment|/* Type of argument if length modifier `q' is used.      If NULL, then this modifier is not allowed.  */
name|tree
modifier|*
name|qlen
decl_stmt|;
comment|/* Type of argument if length modifier `L' is used.      If NULL, then this modifier is not allowed.  */
name|tree
modifier|*
name|bigllen
decl_stmt|;
comment|/* List of other modifier characters allowed with these options.  */
name|char
modifier|*
name|flag_chars
decl_stmt|;
block|}
name|format_char_info
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|format_char_info
name|print_char_table
index|[]
init|=
block|{
block|{
literal|"di"
block|,
literal|0
block|,
name|T_I
block|,
name|T_I
block|,
name|T_L
block|,
name|T_LL
block|,
name|NULL
block|,
literal|"-wp0 +"
block|}
block|,
block|{
literal|"oxX"
block|,
literal|0
block|,
name|T_UI
block|,
name|T_UI
block|,
name|T_UL
block|,
name|T_ULL
block|,
name|NULL
block|,
literal|"-wp0#"
block|}
block|,
block|{
literal|"u"
block|,
literal|0
block|,
name|T_UI
block|,
name|T_UI
block|,
name|T_UL
block|,
name|T_ULL
block|,
name|NULL
block|,
literal|"-wp0"
block|}
block|,
comment|/* Two GNU extensions.  */
block|{
literal|"Z"
block|,
literal|0
block|,
name|T_ST
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|"-wp0"
block|}
block|,
block|{
literal|"m"
block|,
literal|0
block|,
name|T_UI
block|,
name|T_UI
block|,
name|T_UL
block|,
name|NULL
block|,
name|NULL
block|,
literal|"-wp"
block|}
block|,
block|{
literal|"feEgG"
block|,
literal|0
block|,
name|T_D
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|T_LD
block|,
literal|"-wp0 +#"
block|}
block|,
block|{
literal|"c"
block|,
literal|0
block|,
name|T_I
block|,
name|NULL
block|,
name|T_W
block|,
name|NULL
block|,
name|NULL
block|,
literal|"-w"
block|}
block|,
block|{
literal|"C"
block|,
literal|0
block|,
name|T_W
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|"-w"
block|}
block|,
block|{
literal|"s"
block|,
literal|1
block|,
name|T_C
block|,
name|NULL
block|,
name|T_W
block|,
name|NULL
block|,
name|NULL
block|,
literal|"-wp"
block|}
block|,
block|{
literal|"S"
block|,
literal|1
block|,
name|T_W
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|"-wp"
block|}
block|,
block|{
literal|"p"
block|,
literal|1
block|,
name|T_V
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|"-w"
block|}
block|,
block|{
literal|"n"
block|,
literal|1
block|,
name|T_I
block|,
name|T_S
block|,
name|T_L
block|,
name|T_LL
block|,
name|NULL
block|,
literal|""
block|}
block|,
block|{
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|format_char_info
name|scan_char_table
index|[]
init|=
block|{
block|{
literal|"di"
block|,
literal|1
block|,
name|T_I
block|,
name|T_S
block|,
name|T_L
block|,
name|T_LL
block|,
name|NULL
block|,
literal|"*"
block|}
block|,
block|{
literal|"ouxX"
block|,
literal|1
block|,
name|T_UI
block|,
name|T_US
block|,
name|T_UL
block|,
name|T_ULL
block|,
name|NULL
block|,
literal|"*"
block|}
block|,
block|{
literal|"efgEG"
block|,
literal|1
block|,
name|T_F
block|,
name|NULL
block|,
name|T_D
block|,
name|NULL
block|,
name|T_LD
block|,
literal|"*"
block|}
block|,
block|{
literal|"sc"
block|,
literal|1
block|,
name|T_C
block|,
name|NULL
block|,
name|T_W
block|,
name|NULL
block|,
name|NULL
block|,
literal|"*a"
block|}
block|,
block|{
literal|"["
block|,
literal|1
block|,
name|T_C
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|"*a"
block|}
block|,
block|{
literal|"C"
block|,
literal|1
block|,
name|T_W
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|"*"
block|}
block|,
block|{
literal|"S"
block|,
literal|1
block|,
name|T_W
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|"*"
block|}
block|,
block|{
literal|"p"
block|,
literal|2
block|,
name|T_V
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|"*"
block|}
block|,
block|{
literal|"n"
block|,
literal|1
block|,
name|T_I
block|,
name|T_S
block|,
name|T_L
block|,
name|T_LL
block|,
name|NULL
block|,
literal|""
block|}
block|,
block|{
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|function_format_info
block|{
name|struct
name|function_format_info
modifier|*
name|next
decl_stmt|;
comment|/* next structure on the list */
name|tree
name|name
decl_stmt|;
comment|/* identifier such as "printf" */
name|tree
name|assembler_name
decl_stmt|;
comment|/* optional mangled identifier (for C++) */
name|int
name|is_scan
decl_stmt|;
comment|/* TRUE if *scanf */
name|int
name|format_num
decl_stmt|;
comment|/* number of format argument */
name|int
name|first_arg_num
decl_stmt|;
comment|/* number of first arg (zero for varargs) */
block|}
name|function_format_info
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|function_format_info
modifier|*
name|function_format_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|check_format_info
name|PROTO
argument_list|(
operator|(
name|function_format_info
operator|*
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize the table of functions to perform format checking on.    The ANSI functions are always checked (whether<stdio.h> is    included or not), since it is common to call printf without    including<stdio.h>.  There shouldn't be a problem with this,    since ANSI reserves these function names whether you include the    header file or not.  In any case, the checking is harmless.  */
end_comment

begin_function
name|void
name|init_function_format_info
parameter_list|()
block|{
name|record_function_format
argument_list|(
name|get_identifier
argument_list|(
literal|"printf"
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|record_function_format
argument_list|(
name|get_identifier
argument_list|(
literal|"fprintf"
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|record_function_format
argument_list|(
name|get_identifier
argument_list|(
literal|"sprintf"
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|record_function_format
argument_list|(
name|get_identifier
argument_list|(
literal|"scanf"
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|record_function_format
argument_list|(
name|get_identifier
argument_list|(
literal|"fscanf"
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|record_function_format
argument_list|(
name|get_identifier
argument_list|(
literal|"sscanf"
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|record_function_format
argument_list|(
name|get_identifier
argument_list|(
literal|"vprintf"
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|record_function_format
argument_list|(
name|get_identifier
argument_list|(
literal|"vfprintf"
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|record_function_format
argument_list|(
name|get_identifier
argument_list|(
literal|"vsprintf"
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record information for argument format checking.  FUNCTION_IDENT is    the identifier node for the name of the function to check (its decl    need not exist yet).  IS_SCAN is true for scanf-type format checking;    false indicates printf-style format checking.  FORMAT_NUM is the number    of the argument which is the format control string (starting from 1).    FIRST_ARG_NUM is the number of the first actual argument to check    against teh format string, or zero if no checking is not be done    (e.g. for varargs such as vfprintf).  */
end_comment

begin_function
name|void
name|record_function_format
parameter_list|(
name|name
parameter_list|,
name|assembler_name
parameter_list|,
name|is_scan
parameter_list|,
name|format_num
parameter_list|,
name|first_arg_num
parameter_list|)
name|tree
name|name
decl_stmt|;
name|tree
name|assembler_name
decl_stmt|;
name|int
name|is_scan
decl_stmt|;
name|int
name|format_num
decl_stmt|;
name|int
name|first_arg_num
decl_stmt|;
block|{
name|function_format_info
modifier|*
name|info
decl_stmt|;
comment|/* Re-use existing structure if it's there.  */
for|for
control|(
name|info
operator|=
name|function_format_list
init|;
name|info
condition|;
name|info
operator|=
name|info
operator|->
name|next
control|)
block|{
if|if
condition|(
name|info
operator|->
name|name
operator|==
name|name
operator|&&
name|info
operator|->
name|assembler_name
operator|==
name|assembler_name
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|info
condition|)
block|{
name|info
operator|=
operator|(
name|function_format_info
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|function_format_info
argument_list|)
argument_list|)
expr_stmt|;
name|info
operator|->
name|next
operator|=
name|function_format_list
expr_stmt|;
name|function_format_list
operator|=
name|info
expr_stmt|;
name|info
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|info
operator|->
name|assembler_name
operator|=
name|assembler_name
expr_stmt|;
block|}
name|info
operator|->
name|is_scan
operator|=
name|is_scan
expr_stmt|;
name|info
operator|->
name|format_num
operator|=
name|format_num
expr_stmt|;
name|info
operator|->
name|first_arg_num
operator|=
name|first_arg_num
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
name|tfaff
index|[]
init|=
literal|"too few arguments for format"
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Check the argument list of a call to printf, scanf, etc.    NAME is the function identifier.    ASSEMBLER_NAME is the function's assembler identifier.    (Either NAME or ASSEMBLER_NAME, but not both, may be NULL_TREE.)    PARAMS is the list of argument values.  */
end_comment

begin_function
name|void
name|check_function_format
parameter_list|(
name|name
parameter_list|,
name|assembler_name
parameter_list|,
name|params
parameter_list|)
name|tree
name|name
decl_stmt|;
name|tree
name|assembler_name
decl_stmt|;
name|tree
name|params
decl_stmt|;
block|{
name|function_format_info
modifier|*
name|info
decl_stmt|;
comment|/* See if this function is a format function.  */
for|for
control|(
name|info
operator|=
name|function_format_list
init|;
name|info
condition|;
name|info
operator|=
name|info
operator|->
name|next
control|)
block|{
if|if
condition|(
name|info
operator|->
name|assembler_name
condition|?
operator|(
name|info
operator|->
name|assembler_name
operator|==
name|assembler_name
operator|)
else|:
operator|(
name|info
operator|->
name|name
operator|==
name|name
operator|)
condition|)
block|{
comment|/* Yup; check it.  */
name|check_format_info
argument_list|(
name|info
argument_list|,
name|params
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Check the argument list of a call to printf, scanf, etc.    INFO points to the function_format_info structure.    PARAMS is the list of argument values.  */
end_comment

begin_function
specifier|static
name|void
name|check_format_info
parameter_list|(
name|info
parameter_list|,
name|params
parameter_list|)
name|function_format_info
modifier|*
name|info
decl_stmt|;
name|tree
name|params
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|arg_num
decl_stmt|;
name|int
name|suppressed
decl_stmt|,
name|wide
decl_stmt|,
name|precise
decl_stmt|;
name|int
name|length_char
decl_stmt|;
name|int
name|format_char
decl_stmt|;
name|int
name|format_length
decl_stmt|;
name|tree
name|format_tree
decl_stmt|;
name|tree
name|cur_param
decl_stmt|;
name|tree
name|cur_type
decl_stmt|;
name|tree
name|wanted_type
decl_stmt|;
name|tree
name|first_fillin_param
decl_stmt|;
name|char
modifier|*
name|format_chars
decl_stmt|;
name|format_char_info
modifier|*
name|fci
decl_stmt|;
specifier|static
name|char
name|message
index|[
literal|132
index|]
decl_stmt|;
name|char
name|flag_chars
index|[
literal|8
index|]
decl_stmt|;
name|int
name|has_operand_number
init|=
literal|0
decl_stmt|;
comment|/* Skip to format argument.  If the argument isn't available, there's      no work for us to do; prototype checking will catch the problem.  */
for|for
control|(
name|arg_num
operator|=
literal|1
init|;
condition|;
operator|++
name|arg_num
control|)
block|{
if|if
condition|(
name|params
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|arg_num
operator|==
name|info
operator|->
name|format_num
condition|)
break|break;
name|params
operator|=
name|TREE_CHAIN
argument_list|(
name|params
argument_list|)
expr_stmt|;
block|}
name|format_tree
operator|=
name|TREE_VALUE
argument_list|(
name|params
argument_list|)
expr_stmt|;
name|params
operator|=
name|TREE_CHAIN
argument_list|(
name|params
argument_list|)
expr_stmt|;
if|if
condition|(
name|format_tree
operator|==
literal|0
condition|)
return|return;
comment|/* We can only check the format if it's a string constant.  */
while|while
condition|(
name|TREE_CODE
argument_list|(
name|format_tree
argument_list|)
operator|==
name|NOP_EXPR
condition|)
name|format_tree
operator|=
name|TREE_OPERAND
argument_list|(
name|format_tree
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* strip coercion */
if|if
condition|(
name|format_tree
operator|==
name|null_pointer_node
condition|)
block|{
name|warning
argument_list|(
literal|"null format string"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|format_tree
argument_list|)
operator|!=
name|ADDR_EXPR
condition|)
return|return;
name|format_tree
operator|=
name|TREE_OPERAND
argument_list|(
name|format_tree
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|format_tree
argument_list|)
operator|!=
name|STRING_CST
condition|)
return|return;
name|format_chars
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|format_tree
argument_list|)
expr_stmt|;
name|format_length
operator|=
name|TREE_STRING_LENGTH
argument_list|(
name|format_tree
argument_list|)
expr_stmt|;
if|if
condition|(
name|format_length
operator|<=
literal|1
condition|)
name|warning
argument_list|(
literal|"zero-length format string"
argument_list|)
expr_stmt|;
if|if
condition|(
name|format_chars
index|[
operator|--
name|format_length
index|]
operator|!=
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"unterminated format string"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Skip to first argument to check.  */
while|while
condition|(
name|arg_num
operator|+
literal|1
operator|<
name|info
operator|->
name|first_arg_num
condition|)
block|{
if|if
condition|(
name|params
operator|==
literal|0
condition|)
return|return;
name|params
operator|=
name|TREE_CHAIN
argument_list|(
name|params
argument_list|)
expr_stmt|;
operator|++
name|arg_num
expr_stmt|;
block|}
name|first_fillin_param
operator|=
name|params
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|aflag
decl_stmt|;
if|if
condition|(
operator|*
name|format_chars
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|format_chars
operator|-
name|TREE_STRING_POINTER
argument_list|(
name|format_tree
argument_list|)
operator|!=
name|format_length
condition|)
name|warning
argument_list|(
literal|"embedded `\\0' in format"
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|first_arg_num
operator|!=
literal|0
operator|&&
name|params
operator|!=
literal|0
operator|&&
operator|!
name|has_operand_number
condition|)
name|warning
argument_list|(
literal|"too many arguments for format"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|format_chars
operator|++
operator|!=
literal|'%'
condition|)
continue|continue;
if|if
condition|(
operator|*
name|format_chars
operator|==
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"spurious trailing `%%' in format"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
name|format_chars
operator|==
literal|'%'
condition|)
block|{
operator|++
name|format_chars
expr_stmt|;
continue|continue;
block|}
name|flag_chars
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|suppressed
operator|=
name|wide
operator|=
name|precise
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|is_scan
condition|)
block|{
name|suppressed
operator|=
operator|*
name|format_chars
operator|==
literal|'*'
expr_stmt|;
if|if
condition|(
name|suppressed
condition|)
operator|++
name|format_chars
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|format_chars
argument_list|)
condition|)
operator|++
name|format_chars
expr_stmt|;
block|}
else|else
block|{
comment|/* See if we have a number followed by a dollar sign.  If we do, 	     it is an operand number, so set PARAMS to that operand.  */
if|if
condition|(
operator|*
name|format_chars
operator|>=
literal|'0'
operator|&&
operator|*
name|format_chars
operator|<=
literal|'9'
condition|)
block|{
name|char
modifier|*
name|p
init|=
name|format_chars
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|>=
literal|'0'
operator|&&
operator|*
name|p
operator|++
operator|<=
literal|'9'
condition|)
empty_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'$'
condition|)
block|{
name|int
name|opnum
init|=
name|atoi
argument_list|(
name|format_chars
argument_list|)
decl_stmt|;
name|params
operator|=
name|first_fillin_param
expr_stmt|;
name|format_chars
operator|=
name|p
operator|+
literal|1
expr_stmt|;
name|has_operand_number
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|opnum
operator|&&
name|params
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
name|params
operator|=
name|TREE_CHAIN
argument_list|(
name|params
argument_list|)
expr_stmt|;
if|if
condition|(
name|opnum
operator|==
literal|0
operator|||
name|params
operator|==
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"operand number out of range in format"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
while|while
condition|(
operator|*
name|format_chars
operator|!=
literal|0
operator|&&
name|index
argument_list|(
literal|" +#0-"
argument_list|,
operator|*
name|format_chars
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|index
argument_list|(
name|flag_chars
argument_list|,
operator|*
name|format_chars
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"repeated `%c' flag in format"
argument_list|,
operator|*
name|format_chars
argument_list|)
expr_stmt|;
name|warning
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
name|strlen
argument_list|(
name|flag_chars
argument_list|)
expr_stmt|;
name|flag_chars
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|format_chars
operator|++
expr_stmt|;
name|flag_chars
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* "If the space and + flags both appear,  	     the space flag will be ignored."  */
if|if
condition|(
name|index
argument_list|(
name|flag_chars
argument_list|,
literal|' '
argument_list|)
operator|!=
literal|0
operator|&&
name|index
argument_list|(
name|flag_chars
argument_list|,
literal|'+'
argument_list|)
operator|!=
literal|0
condition|)
name|warning
argument_list|(
literal|"use of both ` ' and `+' flags in format"
argument_list|)
expr_stmt|;
comment|/* "If the 0 and - flags both appear, 	     the 0 flag will be ignored."  */
if|if
condition|(
name|index
argument_list|(
name|flag_chars
argument_list|,
literal|'0'
argument_list|)
operator|!=
literal|0
operator|&&
name|index
argument_list|(
name|flag_chars
argument_list|,
literal|'-'
argument_list|)
operator|!=
literal|0
condition|)
name|warning
argument_list|(
literal|"use of both `0' and `-' flags in format"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|format_chars
operator|==
literal|'*'
condition|)
block|{
name|wide
operator|=
name|TRUE
expr_stmt|;
comment|/* "...a field width...may be indicated by an asterisk. 		 In this case, an int argument supplies the field width..."  */
operator|++
name|format_chars
expr_stmt|;
if|if
condition|(
name|params
operator|==
literal|0
condition|)
block|{
name|warning
argument_list|(
name|tfaff
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|info
operator|->
name|first_arg_num
operator|!=
literal|0
condition|)
block|{
name|cur_param
operator|=
name|TREE_VALUE
argument_list|(
name|params
argument_list|)
expr_stmt|;
name|params
operator|=
name|TREE_CHAIN
argument_list|(
name|params
argument_list|)
expr_stmt|;
operator|++
name|arg_num
expr_stmt|;
comment|/* size_t is generally not valid here. 		     It will work on most machines, because size_t and int 		     have the same mode.  But might as well warn anyway, 		     since it will fail on other machines.  */
if|if
condition|(
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|cur_param
argument_list|)
argument_list|)
operator|!=
name|integer_type_node
operator|)
operator|&&
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|cur_param
argument_list|)
argument_list|)
operator|!=
name|unsigned_type_node
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"field width is not type int (arg %d)"
argument_list|,
name|arg_num
argument_list|)
expr_stmt|;
name|warning
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|format_chars
argument_list|)
condition|)
block|{
name|wide
operator|=
name|TRUE
expr_stmt|;
operator|++
name|format_chars
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|format_chars
operator|==
literal|'.'
condition|)
block|{
name|precise
operator|=
name|TRUE
expr_stmt|;
operator|++
name|format_chars
expr_stmt|;
if|if
condition|(
operator|*
name|format_chars
operator|!=
literal|'*'
operator|&&
operator|!
name|isdigit
argument_list|(
operator|*
name|format_chars
argument_list|)
condition|)
name|warning
argument_list|(
literal|"`.' not followed by `*' or digit in format"
argument_list|)
expr_stmt|;
comment|/* "...a...precision...may be indicated by an asterisk. 		 In this case, an int argument supplies the...precision."  */
if|if
condition|(
operator|*
name|format_chars
operator|==
literal|'*'
condition|)
block|{
if|if
condition|(
name|info
operator|->
name|first_arg_num
operator|!=
literal|0
condition|)
block|{
operator|++
name|format_chars
expr_stmt|;
if|if
condition|(
name|params
operator|==
literal|0
condition|)
block|{
name|warning
argument_list|(
name|tfaff
argument_list|)
expr_stmt|;
return|return;
block|}
name|cur_param
operator|=
name|TREE_VALUE
argument_list|(
name|params
argument_list|)
expr_stmt|;
name|params
operator|=
name|TREE_CHAIN
argument_list|(
name|params
argument_list|)
expr_stmt|;
operator|++
name|arg_num
expr_stmt|;
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|cur_param
argument_list|)
argument_list|)
operator|!=
name|integer_type_node
condition|)
block|{
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"field width is not type int (arg %d)"
argument_list|,
name|arg_num
argument_list|)
expr_stmt|;
name|warning
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|format_chars
argument_list|)
condition|)
operator|++
name|format_chars
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|*
name|format_chars
operator|==
literal|'h'
operator|||
operator|*
name|format_chars
operator|==
literal|'l'
operator|||
operator|*
name|format_chars
operator|==
literal|'q'
operator|||
operator|*
name|format_chars
operator|==
literal|'L'
condition|)
name|length_char
operator|=
operator|*
name|format_chars
operator|++
expr_stmt|;
else|else
name|length_char
operator|=
literal|0
expr_stmt|;
name|aflag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|format_chars
operator|==
literal|'a'
condition|)
block|{
name|aflag
operator|=
literal|1
expr_stmt|;
name|format_chars
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|suppressed
operator|&&
name|length_char
operator|!=
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"use of `*' and `%c' together in format"
argument_list|,
name|length_char
argument_list|)
expr_stmt|;
name|warning
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
name|format_char
operator|=
operator|*
name|format_chars
expr_stmt|;
if|if
condition|(
name|format_char
operator|==
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"conversion lacks type at end of format"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|format_chars
operator|++
expr_stmt|;
name|fci
operator|=
name|info
operator|->
name|is_scan
condition|?
name|scan_char_table
else|:
name|print_char_table
expr_stmt|;
while|while
condition|(
name|fci
operator|->
name|format_chars
operator|!=
literal|0
operator|&&
name|index
argument_list|(
name|fci
operator|->
name|format_chars
argument_list|,
name|format_char
argument_list|)
operator|==
literal|0
condition|)
operator|++
name|fci
expr_stmt|;
if|if
condition|(
name|fci
operator|->
name|format_chars
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|format_char
operator|>=
literal|040
operator|&&
name|format_char
operator|<
literal|0177
condition|)
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"unknown conversion type character `%c' in format"
argument_list|,
name|format_char
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"unknown conversion type character 0x%x in format"
argument_list|,
name|format_char
argument_list|)
expr_stmt|;
name|warning
argument_list|(
name|message
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|wide
operator|&&
name|index
argument_list|(
name|fci
operator|->
name|flag_chars
argument_list|,
literal|'w'
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"width used with `%c' format"
argument_list|,
name|format_char
argument_list|)
expr_stmt|;
name|warning
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|precise
operator|&&
name|index
argument_list|(
name|fci
operator|->
name|flag_chars
argument_list|,
literal|'p'
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"precision used with `%c' format"
argument_list|,
name|format_char
argument_list|)
expr_stmt|;
name|warning
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|aflag
operator|&&
name|index
argument_list|(
name|fci
operator|->
name|flag_chars
argument_list|,
literal|'a'
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"`a' flag used with `%c' format"
argument_list|,
name|format_char
argument_list|)
expr_stmt|;
name|warning
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|->
name|is_scan
operator|&&
name|format_char
operator|==
literal|'['
condition|)
block|{
comment|/* Skip over scan set, in case it happens to have '%' in it.  */
if|if
condition|(
operator|*
name|format_chars
operator|==
literal|'^'
condition|)
operator|++
name|format_chars
expr_stmt|;
comment|/* Find closing bracket; if one is hit immediately, then 	     it's part of the scan set rather than a terminator.  */
if|if
condition|(
operator|*
name|format_chars
operator|==
literal|']'
condition|)
operator|++
name|format_chars
expr_stmt|;
while|while
condition|(
operator|*
name|format_chars
operator|&&
operator|*
name|format_chars
operator|!=
literal|']'
condition|)
operator|++
name|format_chars
expr_stmt|;
if|if
condition|(
operator|*
name|format_chars
operator|!=
literal|']'
condition|)
comment|/* The end of the format string was reached.  */
name|warning
argument_list|(
literal|"no closing `]' for `%%[' format"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|suppressed
condition|)
block|{
if|if
condition|(
name|index
argument_list|(
name|fci
operator|->
name|flag_chars
argument_list|,
literal|'*'
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"suppression of `%c' conversion in format"
argument_list|,
name|format_char
argument_list|)
expr_stmt|;
name|warning
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|flag_chars
index|[
name|i
index|]
operator|!=
literal|0
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|index
argument_list|(
name|fci
operator|->
name|flag_chars
argument_list|,
name|flag_chars
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"flag `%c' used with type `%c'"
argument_list|,
name|flag_chars
index|[
name|i
index|]
argument_list|,
name|format_char
argument_list|)
expr_stmt|;
name|warning
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|precise
operator|&&
name|index
argument_list|(
name|flag_chars
argument_list|,
literal|'0'
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|format_char
operator|==
literal|'d'
operator|||
name|format_char
operator|==
literal|'i'
operator|||
name|format_char
operator|==
literal|'o'
operator|||
name|format_char
operator|==
literal|'u'
operator|||
name|format_char
operator|==
literal|'x'
operator|||
name|format_char
operator|==
literal|'x'
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"precision and `0' flag not both allowed with `%c' format"
argument_list|,
name|format_char
argument_list|)
expr_stmt|;
name|warning
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|length_char
condition|)
block|{
default|default:
name|wanted_type
operator|=
name|fci
operator|->
name|nolen
condition|?
operator|*
operator|(
name|fci
operator|->
name|nolen
operator|)
else|:
literal|0
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|wanted_type
operator|=
name|fci
operator|->
name|hlen
condition|?
operator|*
operator|(
name|fci
operator|->
name|hlen
operator|)
else|:
literal|0
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|wanted_type
operator|=
name|fci
operator|->
name|llen
condition|?
operator|*
operator|(
name|fci
operator|->
name|llen
operator|)
else|:
literal|0
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|wanted_type
operator|=
name|fci
operator|->
name|qlen
condition|?
operator|*
operator|(
name|fci
operator|->
name|qlen
operator|)
else|:
literal|0
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|wanted_type
operator|=
name|fci
operator|->
name|bigllen
condition|?
operator|*
operator|(
name|fci
operator|->
name|bigllen
operator|)
else|:
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|wanted_type
operator|==
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"use of `%c' length character with `%c' type character"
argument_list|,
name|length_char
argument_list|,
name|format_char
argument_list|)
expr_stmt|;
name|warning
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
comment|/*        ** XXX -- should kvetch about stuff such as        **	{        **		const int	i;        **        **		scanf ("%d",&i);        **	}        */
comment|/* Finally. . .check type of argument against desired type!  */
if|if
condition|(
name|info
operator|->
name|first_arg_num
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|params
operator|==
literal|0
condition|)
block|{
name|warning
argument_list|(
name|tfaff
argument_list|)
expr_stmt|;
return|return;
block|}
name|cur_param
operator|=
name|TREE_VALUE
argument_list|(
name|params
argument_list|)
expr_stmt|;
name|params
operator|=
name|TREE_CHAIN
argument_list|(
name|params
argument_list|)
expr_stmt|;
operator|++
name|arg_num
expr_stmt|;
name|cur_type
operator|=
name|TREE_TYPE
argument_list|(
name|cur_param
argument_list|)
expr_stmt|;
comment|/* Check the types of any additional pointer arguments 	 that precede the "real" argument.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fci
operator|->
name|pointer_count
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cur_type
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
name|cur_type
operator|=
name|TREE_TYPE
argument_list|(
name|cur_type
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"format argument is not a %s (arg %d)"
argument_list|,
operator|(
operator|(
name|fci
operator|->
name|pointer_count
operator|==
literal|1
operator|)
condition|?
literal|"pointer"
else|:
literal|"pointer to a pointer"
operator|)
argument_list|,
name|arg_num
argument_list|)
expr_stmt|;
name|warning
argument_list|(
name|message
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Check the type of the "real" argument, if there's a type we want.  */
if|if
condition|(
name|i
operator|==
name|fci
operator|->
name|pointer_count
operator|&&
name|wanted_type
operator|!=
literal|0
operator|&&
name|wanted_type
operator|!=
name|TYPE_MAIN_VARIANT
argument_list|(
name|cur_type
argument_list|)
comment|/* If we want `void *', allow any pointer type. 	     (Anything else would already have got a warning.)  */
operator|&&
operator|!
operator|(
name|wanted_type
operator|==
name|void_type_node
operator|&&
name|fci
operator|->
name|pointer_count
operator|>
literal|0
operator|)
comment|/* Don't warn about differences merely in signedness.  */
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|wanted_type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|cur_type
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
operator|(
name|TREE_UNSIGNED
argument_list|(
name|wanted_type
argument_list|)
condition|?
name|wanted_type
operator|==
operator|(
name|cur_type
operator|=
name|unsigned_type
argument_list|(
name|cur_type
argument_list|)
operator|)
else|:
name|wanted_type
operator|==
operator|(
name|cur_type
operator|=
name|signed_type
argument_list|(
name|cur_type
argument_list|)
operator|)
operator|)
operator|)
comment|/* Likewise, "signed char", "unsigned char" and "char" are 	     equivalent but the above test won't consider them equivalent.  */
operator|&&
operator|!
operator|(
name|wanted_type
operator|==
name|char_type_node
operator|&&
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|cur_type
argument_list|)
operator|==
name|signed_char_type_node
operator|||
name|TYPE_MAIN_VARIANT
argument_list|(
name|cur_type
argument_list|)
operator|==
name|unsigned_char_type_node
operator|)
operator|)
condition|)
block|{
specifier|register
name|char
modifier|*
name|this
decl_stmt|;
specifier|register
name|char
modifier|*
name|that
decl_stmt|;
name|this
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|wanted_type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|that
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cur_type
argument_list|)
operator|!=
name|ERROR_MARK
operator|&&
name|TYPE_NAME
argument_list|(
name|cur_type
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|cur_type
argument_list|)
operator|!=
name|INTEGER_TYPE
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|cur_type
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|cur_type
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|cur_type
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|cur_type
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|that
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|cur_type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|that
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|TYPE_NAME
argument_list|(
name|cur_type
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* A nameless type can't possibly match what the format wants. 	     So there will be a warning for it. 	     Make up a string to describe vaguely what it is.  */
if|if
condition|(
name|that
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cur_type
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
name|that
operator|=
literal|"pointer"
expr_stmt|;
else|else
name|that
operator|=
literal|"different type"
expr_stmt|;
block|}
comment|/* Make the warning better in case of mismatch of int vs long.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cur_type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|wanted_type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_PRECISION
argument_list|(
name|cur_type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|wanted_type
argument_list|)
operator|&&
name|TYPE_NAME
argument_list|(
name|cur_type
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|cur_type
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|that
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|cur_type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|this
argument_list|,
name|that
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"%s format, %s arg (arg %d)"
argument_list|,
name|this
argument_list|,
name|that
argument_list|,
name|arg_num
argument_list|)
expr_stmt|;
name|warning
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print a warning if a constant expression had overflow in folding.    Invoke this function on every expression that the language    requires to be a constant expression.    Note the ANSI C standard says it is erroneous for a    constant expression to overflow.  */
end_comment

begin_function
name|void
name|constant_expression_warning
parameter_list|(
name|value
parameter_list|)
name|tree
name|value
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|REAL_CST
operator|||
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|COMPLEX_CST
operator|)
operator|&&
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|value
argument_list|)
operator|&&
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"overflow in constant expression"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print a warning if an expression had overflow in folding.    Invoke this function on every expression that    (1) appears in the source code, and    (2) might be a constant expression that overflowed, and    (3) is not already checked by convert_and_check;    however, do not invoke this function on operands of explicit casts.  */
end_comment

begin_function
name|void
name|overflow_warning
parameter_list|(
name|value
parameter_list|)
name|tree
name|value
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|INTEGER_CST
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|COMPLEX_CST
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_REALPART
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|)
operator|)
operator|&&
name|TREE_OVERFLOW
argument_list|(
name|value
argument_list|)
condition|)
block|{
name|TREE_OVERFLOW
argument_list|(
name|value
argument_list|)
operator|=
literal|0
expr_stmt|;
name|warning
argument_list|(
literal|"integer overflow in expression"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|REAL_CST
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|COMPLEX_CST
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_REALPART
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|REAL_CST
operator|)
operator|)
operator|&&
name|TREE_OVERFLOW
argument_list|(
name|value
argument_list|)
condition|)
block|{
name|TREE_OVERFLOW
argument_list|(
name|value
argument_list|)
operator|=
literal|0
expr_stmt|;
name|warning
argument_list|(
literal|"floating-pointer overflow in expression"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print a warning if a large constant is truncated to unsigned,    or if -Wconversion is used and a constant< 0 is converted to unsigned.    Invoke this function on every expression that might be implicitly    converted to an unsigned type.  */
end_comment

begin_function
name|void
name|unsigned_conversion_warning
parameter_list|(
name|result
parameter_list|,
name|operand
parameter_list|)
name|tree
name|result
decl_stmt|,
name|operand
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
argument_list|)
operator|&&
operator|!
name|int_fits_type_p
argument_list|(
name|operand
argument_list|,
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|int_fits_type_p
argument_list|(
name|operand
argument_list|,
name|signed_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
argument_list|)
argument_list|)
condition|)
comment|/* This detects cases like converting -129 or 256 to unsigned char.  */
name|warning
argument_list|(
literal|"large integer implicitly truncated to unsigned type"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|warn_conversion
condition|)
name|warning
argument_list|(
literal|"negative integer implicitly converted to unsigned type"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Convert EXPR to TYPE, warning about conversion problems with constants.    Invoke this function on every expression that is converted implicitly,    i.e. because of language rules and not because of an explicit cast.  */
end_comment

begin_function
name|tree
name|convert_and_check
parameter_list|(
name|type
parameter_list|,
name|expr
parameter_list|)
name|tree
name|type
decl_stmt|,
name|expr
decl_stmt|;
block|{
name|tree
name|t
init|=
name|convert
argument_list|(
name|type
argument_list|,
name|expr
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
if|if
condition|(
name|TREE_OVERFLOW
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|TREE_OVERFLOW
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* No warning for converting 0x80000000 to int.  */
if|if
condition|(
operator|!
operator|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|<
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|)
condition|)
comment|/* If EXPR fits in the unsigned version of TYPE, 	       don't warn unless pedantic.  */
if|if
condition|(
name|pedantic
operator|||
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|||
operator|!
name|int_fits_type_p
argument_list|(
name|expr
argument_list|,
name|unsigned_type
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|warning
argument_list|(
literal|"overflow in implicit constant conversion"
argument_list|)
expr_stmt|;
block|}
else|else
name|unsigned_conversion_warning
argument_list|(
name|t
argument_list|,
name|expr
argument_list|)
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|c_expand_expr_stmt
parameter_list|(
name|expr
parameter_list|)
name|tree
name|expr
decl_stmt|;
block|{
comment|/* Do default conversion if safe and possibly important,      in case within ({...}).  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|lvalue_p
argument_list|(
name|expr
argument_list|)
operator|)
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|expr
operator|=
name|default_conversion
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|!=
name|error_mark_node
operator|&&
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|!=
name|ARRAY_TYPE
condition|)
name|error
argument_list|(
literal|"expression statement has incomplete type"
argument_list|)
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Validate the expression after `case' and apply default promotions.  */
end_comment

begin_function
name|tree
name|check_case_value
parameter_list|(
name|value
parameter_list|)
name|tree
name|value
decl_stmt|;
block|{
if|if
condition|(
name|value
operator|==
name|NULL_TREE
condition|)
return|return
name|value
return|;
comment|/* Strip NON_LVALUE_EXPRs since we aren't using as an lvalue.  */
name|STRIP_TYPE_NOPS
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|!=
name|INTEGER_CST
operator|&&
name|value
operator|!=
name|error_mark_node
condition|)
block|{
name|error
argument_list|(
literal|"case label does not reduce to an integer constant"
argument_list|)
expr_stmt|;
name|value
operator|=
name|error_mark_node
expr_stmt|;
block|}
else|else
comment|/* Promote char or short to int.  */
name|value
operator|=
name|default_conversion
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|constant_expression_warning
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return an integer type with BITS bits of precision,    that is unsigned if UNSIGNEDP is nonzero, otherwise signed.  */
end_comment

begin_function
name|tree
name|type_for_size
parameter_list|(
name|bits
parameter_list|,
name|unsignedp
parameter_list|)
name|unsigned
name|bits
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
if|if
condition|(
name|bits
operator|==
name|TYPE_PRECISION
argument_list|(
name|signed_char_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_char_type_node
else|:
name|signed_char_type_node
return|;
if|if
condition|(
name|bits
operator|==
name|TYPE_PRECISION
argument_list|(
name|short_integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|short_unsigned_type_node
else|:
name|short_integer_type_node
return|;
if|if
condition|(
name|bits
operator|==
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_type_node
else|:
name|integer_type_node
return|;
if|if
condition|(
name|bits
operator|==
name|TYPE_PRECISION
argument_list|(
name|long_integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|long_unsigned_type_node
else|:
name|long_integer_type_node
return|;
if|if
condition|(
name|bits
operator|==
name|TYPE_PRECISION
argument_list|(
name|long_long_integer_type_node
argument_list|)
condition|)
return|return
operator|(
name|unsignedp
condition|?
name|long_long_unsigned_type_node
else|:
name|long_long_integer_type_node
operator|)
return|;
if|if
condition|(
name|bits
operator|<=
name|TYPE_PRECISION
argument_list|(
name|intQI_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_intQI_type_node
else|:
name|intQI_type_node
return|;
if|if
condition|(
name|bits
operator|<=
name|TYPE_PRECISION
argument_list|(
name|intHI_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_intHI_type_node
else|:
name|intHI_type_node
return|;
if|if
condition|(
name|bits
operator|<=
name|TYPE_PRECISION
argument_list|(
name|intSI_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_intSI_type_node
else|:
name|intSI_type_node
return|;
if|if
condition|(
name|bits
operator|<=
name|TYPE_PRECISION
argument_list|(
name|intDI_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_intDI_type_node
else|:
name|intDI_type_node
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return a data type that has machine mode MODE.    If the mode is an integer,    then UNSIGNEDP selects between signed and unsigned types.  */
end_comment

begin_function
name|tree
name|type_for_mode
parameter_list|(
name|mode
parameter_list|,
name|unsignedp
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|signed_char_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_char_type_node
else|:
name|signed_char_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|short_integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|short_unsigned_type_node
else|:
name|short_integer_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_type_node
else|:
name|integer_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|long_integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|long_unsigned_type_node
else|:
name|long_integer_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|long_long_integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|long_long_unsigned_type_node
else|:
name|long_long_integer_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|intQI_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_intQI_type_node
else|:
name|intQI_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|intHI_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_intHI_type_node
else|:
name|intHI_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|intSI_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_intSI_type_node
else|:
name|intSI_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|intDI_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_intDI_type_node
else|:
name|intDI_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|float_type_node
argument_list|)
condition|)
return|return
name|float_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|double_type_node
argument_list|)
condition|)
return|return
name|double_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|long_double_type_node
argument_list|)
condition|)
return|return
name|long_double_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|build_pointer_type
argument_list|(
name|char_type_node
argument_list|)
argument_list|)
condition|)
return|return
name|build_pointer_type
argument_list|(
name|char_type_node
argument_list|)
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|build_pointer_type
argument_list|(
name|integer_type_node
argument_list|)
argument_list|)
condition|)
return|return
name|build_pointer_type
argument_list|(
name|integer_type_node
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the minimum number of bits needed to represent VALUE in a    signed or unsigned type, UNSIGNEDP says which.  */
end_comment

begin_function
name|int
name|min_precision
parameter_list|(
name|value
parameter_list|,
name|unsignedp
parameter_list|)
name|tree
name|value
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
name|int
name|log
decl_stmt|;
comment|/* If the value is negative, compute its negative minus 1.  The latter      adjustment is because the absolute value of the largest negative value      is one larger than the largest positive value.  This is equivalent to      a bit-wise negation, so use that operation instead.  */
if|if
condition|(
name|tree_int_cst_sgn
argument_list|(
name|value
argument_list|)
operator|<
literal|0
condition|)
name|value
operator|=
name|fold
argument_list|(
name|build1
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Return the number of bits needed, taking into account the fact      that we need one more bit for a signed than unsigned type.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|value
argument_list|)
condition|)
name|log
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_INT_CST_HIGH
argument_list|(
name|value
argument_list|)
operator|!=
literal|0
condition|)
name|log
operator|=
name|HOST_BITS_PER_WIDE_INT
operator|+
name|floor_log2
argument_list|(
name|TREE_INT_CST_HIGH
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|log
operator|=
name|floor_log2
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|log
operator|+
literal|1
operator|+
operator|!
name|unsignedp
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print an error message for invalid operands to arith operation CODE.    NOP_EXPR is used as a special case (see truthvalue_conversion).  */
end_comment

begin_function
name|void
name|binary_op_error
parameter_list|(
name|code
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|opname
init|=
literal|"unknown"
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|NOP_EXPR
case|:
name|error
argument_list|(
literal|"invalid truth-value expression"
argument_list|)
expr_stmt|;
return|return;
case|case
name|PLUS_EXPR
case|:
name|opname
operator|=
literal|"+"
expr_stmt|;
break|break;
case|case
name|MINUS_EXPR
case|:
name|opname
operator|=
literal|"-"
expr_stmt|;
break|break;
case|case
name|MULT_EXPR
case|:
name|opname
operator|=
literal|"*"
expr_stmt|;
break|break;
case|case
name|MAX_EXPR
case|:
name|opname
operator|=
literal|"max"
expr_stmt|;
break|break;
case|case
name|MIN_EXPR
case|:
name|opname
operator|=
literal|"min"
expr_stmt|;
break|break;
case|case
name|EQ_EXPR
case|:
name|opname
operator|=
literal|"=="
expr_stmt|;
break|break;
case|case
name|NE_EXPR
case|:
name|opname
operator|=
literal|"!="
expr_stmt|;
break|break;
case|case
name|LE_EXPR
case|:
name|opname
operator|=
literal|"<="
expr_stmt|;
break|break;
case|case
name|GE_EXPR
case|:
name|opname
operator|=
literal|">="
expr_stmt|;
break|break;
case|case
name|LT_EXPR
case|:
name|opname
operator|=
literal|"<"
expr_stmt|;
break|break;
case|case
name|GT_EXPR
case|:
name|opname
operator|=
literal|">"
expr_stmt|;
break|break;
case|case
name|LSHIFT_EXPR
case|:
name|opname
operator|=
literal|"<<"
expr_stmt|;
break|break;
case|case
name|RSHIFT_EXPR
case|:
name|opname
operator|=
literal|">>"
expr_stmt|;
break|break;
case|case
name|TRUNC_MOD_EXPR
case|:
case|case
name|FLOOR_MOD_EXPR
case|:
name|opname
operator|=
literal|"%"
expr_stmt|;
break|break;
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|FLOOR_DIV_EXPR
case|:
name|opname
operator|=
literal|"/"
expr_stmt|;
break|break;
case|case
name|BIT_AND_EXPR
case|:
name|opname
operator|=
literal|"&"
expr_stmt|;
break|break;
case|case
name|BIT_IOR_EXPR
case|:
name|opname
operator|=
literal|"|"
expr_stmt|;
break|break;
case|case
name|TRUTH_ANDIF_EXPR
case|:
name|opname
operator|=
literal|"&&"
expr_stmt|;
break|break;
case|case
name|TRUTH_ORIF_EXPR
case|:
name|opname
operator|=
literal|"||"
expr_stmt|;
break|break;
case|case
name|BIT_XOR_EXPR
case|:
name|opname
operator|=
literal|"^"
expr_stmt|;
break|break;
case|case
name|LROTATE_EXPR
case|:
case|case
name|RROTATE_EXPR
case|:
name|opname
operator|=
literal|"rotate"
expr_stmt|;
break|break;
block|}
name|error
argument_list|(
literal|"invalid operands to binary %s"
argument_list|,
name|opname
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutine of build_binary_op, used for comparison operations.    See if the operands have both been converted from subword integer types    and, if so, perhaps change them both back to their original type.    This function is also responsible for converting the two operands    to the proper common type for comparison.     The arguments of this function are all pointers to local variables    of build_binary_op: OP0_PTR is&OP0, OP1_PTR is&OP1,    RESTYPE_PTR is&RESULT_TYPE and RESCODE_PTR is&RESULTCODE.     If this function returns nonzero, it means that the comparison has    a constant value.  What this function returns is an expression for    that value.  */
end_comment

begin_function
name|tree
name|shorten_compare
parameter_list|(
name|op0_ptr
parameter_list|,
name|op1_ptr
parameter_list|,
name|restype_ptr
parameter_list|,
name|rescode_ptr
parameter_list|)
name|tree
modifier|*
name|op0_ptr
decl_stmt|,
decl|*
name|op1_ptr
decl_stmt|;
end_function

begin_decl_stmt
name|tree
modifier|*
name|restype_ptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|tree_code
modifier|*
name|rescode_ptr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|tree
name|type
decl_stmt|;
name|tree
name|op0
init|=
operator|*
name|op0_ptr
decl_stmt|;
name|tree
name|op1
init|=
operator|*
name|op1_ptr
decl_stmt|;
name|int
name|unsignedp0
decl_stmt|,
name|unsignedp1
decl_stmt|;
name|int
name|real1
decl_stmt|,
name|real2
decl_stmt|;
name|tree
name|primop0
decl_stmt|,
name|primop1
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
operator|*
name|rescode_ptr
decl_stmt|;
comment|/* Throw away any conversions to wider types      already present in the operands.  */
name|primop0
operator|=
name|get_narrower
argument_list|(
name|op0
argument_list|,
operator|&
name|unsignedp0
argument_list|)
expr_stmt|;
name|primop1
operator|=
name|get_narrower
argument_list|(
name|op1
argument_list|,
operator|&
name|unsignedp1
argument_list|)
expr_stmt|;
comment|/* Handle the case that OP0 does not *contain* a conversion      but it *requires* conversion to FINAL_TYPE.  */
if|if
condition|(
name|op0
operator|==
name|primop0
operator|&&
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
operator|!=
operator|*
name|restype_ptr
condition|)
name|unsignedp0
operator|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|==
name|primop1
operator|&&
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
operator|!=
operator|*
name|restype_ptr
condition|)
name|unsignedp1
operator|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If one of the operands must be floated, we cannot optimize.  */
name|real1
operator|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop0
argument_list|)
argument_list|)
operator|==
name|REAL_TYPE
expr_stmt|;
name|real2
operator|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop1
argument_list|)
argument_list|)
operator|==
name|REAL_TYPE
expr_stmt|;
comment|/* If first arg is constant, swap the args (changing operation      so value is preserved), for canonicalization.  Don't do this if      the second arg is 0.  */
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|primop0
argument_list|)
operator|&&
operator|!
name|integer_zerop
argument_list|(
name|primop1
argument_list|)
operator|&&
operator|!
name|real_zerop
argument_list|(
name|primop1
argument_list|)
condition|)
block|{
specifier|register
name|tree
name|tem
init|=
name|primop0
decl_stmt|;
specifier|register
name|int
name|temi
init|=
name|unsignedp0
decl_stmt|;
name|primop0
operator|=
name|primop1
expr_stmt|;
name|primop1
operator|=
name|tem
expr_stmt|;
name|tem
operator|=
name|op0
expr_stmt|;
name|op0
operator|=
name|op1
expr_stmt|;
name|op1
operator|=
name|tem
expr_stmt|;
operator|*
name|op0_ptr
operator|=
name|op0
expr_stmt|;
operator|*
name|op1_ptr
operator|=
name|op1
expr_stmt|;
name|unsignedp0
operator|=
name|unsignedp1
expr_stmt|;
name|unsignedp1
operator|=
name|temi
expr_stmt|;
name|temi
operator|=
name|real1
expr_stmt|;
name|real1
operator|=
name|real2
expr_stmt|;
name|real2
operator|=
name|temi
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LT_EXPR
case|:
name|code
operator|=
name|GT_EXPR
expr_stmt|;
break|break;
case|case
name|GT_EXPR
case|:
name|code
operator|=
name|LT_EXPR
expr_stmt|;
break|break;
case|case
name|LE_EXPR
case|:
name|code
operator|=
name|GE_EXPR
expr_stmt|;
break|break;
case|case
name|GE_EXPR
case|:
name|code
operator|=
name|LE_EXPR
expr_stmt|;
break|break;
block|}
operator|*
name|rescode_ptr
operator|=
name|code
expr_stmt|;
block|}
comment|/* If comparing an integer against a constant more bits wide,      maybe we can deduce a value of 1 or 0 independent of the data.      Or else truncate the constant now      rather than extend the variable at run time.       This is only interesting if the constant is the wider arg.      Also, it is not safe if the constant is unsigned and the      variable arg is signed, since in this case the variable      would be sign-extended and then regarded as unsigned.      Our technique fails in this case because the lowest/highest      possible unsigned results don't follow naturally from the      lowest/highest possible values of the variable operand.      For just EQ_EXPR and NE_EXPR there is another technique that      could be used: see if the constant can be faithfully represented      in the other operand's type, by truncating it and reextending it      and see if that preserves the constant's value.  */
if|if
condition|(
operator|!
name|real1
operator|&&
operator|!
name|real2
operator|&&
name|TREE_CODE
argument_list|(
name|primop1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop0
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
operator|*
name|restype_ptr
argument_list|)
condition|)
block|{
name|int
name|min_gt
decl_stmt|,
name|max_gt
decl_stmt|,
name|min_lt
decl_stmt|,
name|max_lt
decl_stmt|;
name|tree
name|maxval
decl_stmt|,
name|minval
decl_stmt|;
comment|/* 1 if comparison is nominally unsigned.  */
name|int
name|unsignedp
init|=
name|TREE_UNSIGNED
argument_list|(
operator|*
name|restype_ptr
argument_list|)
decl_stmt|;
name|tree
name|val
decl_stmt|;
name|type
operator|=
name|signed_or_unsigned_type
argument_list|(
name|unsignedp0
argument_list|,
name|TREE_TYPE
argument_list|(
name|primop0
argument_list|)
argument_list|)
expr_stmt|;
name|maxval
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|minval
operator|=
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|unsignedp
operator|&&
operator|!
name|unsignedp0
condition|)
operator|*
name|restype_ptr
operator|=
name|signed_type
argument_list|(
operator|*
name|restype_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|primop1
argument_list|)
operator|!=
operator|*
name|restype_ptr
condition|)
name|primop1
operator|=
name|convert
argument_list|(
operator|*
name|restype_ptr
argument_list|,
name|primop1
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
operator|*
name|restype_ptr
condition|)
block|{
name|minval
operator|=
name|convert
argument_list|(
operator|*
name|restype_ptr
argument_list|,
name|minval
argument_list|)
expr_stmt|;
name|maxval
operator|=
name|convert
argument_list|(
operator|*
name|restype_ptr
argument_list|,
name|maxval
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|unsignedp
operator|&&
name|unsignedp0
condition|)
block|{
name|min_gt
operator|=
name|INT_CST_LT_UNSIGNED
argument_list|(
name|primop1
argument_list|,
name|minval
argument_list|)
expr_stmt|;
name|max_gt
operator|=
name|INT_CST_LT_UNSIGNED
argument_list|(
name|primop1
argument_list|,
name|maxval
argument_list|)
expr_stmt|;
name|min_lt
operator|=
name|INT_CST_LT_UNSIGNED
argument_list|(
name|minval
argument_list|,
name|primop1
argument_list|)
expr_stmt|;
name|max_lt
operator|=
name|INT_CST_LT_UNSIGNED
argument_list|(
name|maxval
argument_list|,
name|primop1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|min_gt
operator|=
name|INT_CST_LT
argument_list|(
name|primop1
argument_list|,
name|minval
argument_list|)
expr_stmt|;
name|max_gt
operator|=
name|INT_CST_LT
argument_list|(
name|primop1
argument_list|,
name|maxval
argument_list|)
expr_stmt|;
name|min_lt
operator|=
name|INT_CST_LT
argument_list|(
name|minval
argument_list|,
name|primop1
argument_list|)
expr_stmt|;
name|max_lt
operator|=
name|INT_CST_LT
argument_list|(
name|maxval
argument_list|,
name|primop1
argument_list|)
expr_stmt|;
block|}
name|val
operator|=
literal|0
expr_stmt|;
comment|/* This used to be a switch, but Genix compiler can't handle that.  */
if|if
condition|(
name|code
operator|==
name|NE_EXPR
condition|)
block|{
if|if
condition|(
name|max_lt
operator|||
name|min_gt
condition|)
name|val
operator|=
name|integer_one_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|EQ_EXPR
condition|)
block|{
if|if
condition|(
name|max_lt
operator|||
name|min_gt
condition|)
name|val
operator|=
name|integer_zero_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|LT_EXPR
condition|)
block|{
if|if
condition|(
name|max_lt
condition|)
name|val
operator|=
name|integer_one_node
expr_stmt|;
if|if
condition|(
operator|!
name|min_lt
condition|)
name|val
operator|=
name|integer_zero_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|GT_EXPR
condition|)
block|{
if|if
condition|(
name|min_gt
condition|)
name|val
operator|=
name|integer_one_node
expr_stmt|;
if|if
condition|(
operator|!
name|max_gt
condition|)
name|val
operator|=
name|integer_zero_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|LE_EXPR
condition|)
block|{
if|if
condition|(
operator|!
name|max_gt
condition|)
name|val
operator|=
name|integer_one_node
expr_stmt|;
if|if
condition|(
name|min_gt
condition|)
name|val
operator|=
name|integer_zero_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|GE_EXPR
condition|)
block|{
if|if
condition|(
operator|!
name|min_lt
condition|)
name|val
operator|=
name|integer_one_node
expr_stmt|;
if|if
condition|(
name|max_lt
condition|)
name|val
operator|=
name|integer_zero_node
expr_stmt|;
block|}
comment|/* If primop0 was sign-extended and unsigned comparison specd, 	 we did a signed comparison above using the signed type bounds. 	 But the comparison we output must be unsigned.  	 Also, for inequalities, VAL is no good; but if the signed 	 comparison had *any* fixed result, it follows that the 	 unsigned comparison just tests the sign in reverse 	 (positive values are LE, negative ones GE). 	 So we can generate an unsigned comparison 	 against an extreme value of the signed type.  */
if|if
condition|(
name|unsignedp
operator|&&
operator|!
name|unsignedp0
condition|)
block|{
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LT_EXPR
case|:
case|case
name|GE_EXPR
case|:
name|primop1
operator|=
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|LE_EXPR
case|:
case|case
name|GT_EXPR
case|:
name|primop1
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|type
operator|=
name|unsigned_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|max_gt
operator|&&
operator|!
name|unsignedp0
operator|&&
name|TREE_CODE
argument_list|(
name|primop0
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
comment|/* This is the case of (char)x>?< 0x80, which people used to use 	     expecting old C compilers to change the 0x80 into -0x80.  */
if|if
condition|(
name|val
operator|==
name|integer_zero_node
condition|)
name|warning
argument_list|(
literal|"comparison is always 0 due to limited range of data type"
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|integer_one_node
condition|)
name|warning
argument_list|(
literal|"comparison is always 1 due to limited range of data type"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|min_lt
operator|&&
name|unsignedp0
operator|&&
name|TREE_CODE
argument_list|(
name|primop0
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
comment|/* This is the case of (unsigned char)x>?< -1 or< 0.  */
if|if
condition|(
name|val
operator|==
name|integer_zero_node
condition|)
name|warning
argument_list|(
literal|"comparison is always 0 due to limited range of data type"
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|integer_one_node
condition|)
name|warning
argument_list|(
literal|"comparison is always 1 due to limited range of data type"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
block|{
comment|/* Don't forget to evaluate PRIMOP0 if it has side effects.  */
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|primop0
argument_list|)
condition|)
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|,
name|primop0
argument_list|,
name|val
argument_list|)
return|;
return|return
name|val
return|;
block|}
comment|/* Value is not predetermined, but do the comparison 	 in the type of the operand that is not constant. 	 TYPE is already properly set.  */
block|}
elseif|else
if|if
condition|(
name|real1
operator|&&
name|real2
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop0
argument_list|)
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop1
argument_list|)
argument_list|)
operator|)
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|primop0
argument_list|)
expr_stmt|;
comment|/* If args' natural types are both narrower than nominal type      and both extend in the same manner, compare them      in the type of the wider arg.      Otherwise must actually extend both to the nominal      common type lest different ways of extending      alter the result.      (eg, (short)-1 == (unsigned short)-1  should be 0.)  */
elseif|else
if|if
condition|(
name|unsignedp0
operator|==
name|unsignedp1
operator|&&
name|real1
operator|==
name|real2
operator|&&
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop0
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
operator|*
name|restype_ptr
argument_list|)
operator|&&
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop1
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
operator|*
name|restype_ptr
argument_list|)
condition|)
block|{
name|type
operator|=
name|common_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop0
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|primop1
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|signed_or_unsigned_type
argument_list|(
name|unsignedp0
operator|||
name|TREE_UNSIGNED
argument_list|(
operator|*
name|restype_ptr
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* Make sure shorter operand is extended the right way 	 to match the longer operand.  */
name|primop0
operator|=
name|convert
argument_list|(
name|signed_or_unsigned_type
argument_list|(
name|unsignedp0
argument_list|,
name|TREE_TYPE
argument_list|(
name|primop0
argument_list|)
argument_list|)
argument_list|,
name|primop0
argument_list|)
expr_stmt|;
name|primop1
operator|=
name|convert
argument_list|(
name|signed_or_unsigned_type
argument_list|(
name|unsignedp1
argument_list|,
name|TREE_TYPE
argument_list|(
name|primop1
argument_list|)
argument_list|)
argument_list|,
name|primop1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Here we must do the comparison on the nominal type 	 using the args exactly as we received them.  */
name|type
operator|=
operator|*
name|restype_ptr
expr_stmt|;
name|primop0
operator|=
name|op0
expr_stmt|;
name|primop1
operator|=
name|op1
expr_stmt|;
if|if
condition|(
operator|!
name|real1
operator|&&
operator|!
name|real2
operator|&&
name|integer_zerop
argument_list|(
name|primop1
argument_list|)
operator|&&
name|TREE_UNSIGNED
argument_list|(
operator|*
name|restype_ptr
argument_list|)
condition|)
block|{
name|tree
name|value
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|GE_EXPR
case|:
comment|/* All unsigned values are>= 0, so we warn if extra warnings 		 are requested.  However, if OP0 is a constant that is>= 0, the signedness of the comparison isn't an issue, 		 so suppress the warning.  */
if|if
condition|(
name|extra_warnings
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|primop0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
name|TREE_OVERFLOW
argument_list|(
name|convert
argument_list|(
name|signed_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|primop0
argument_list|)
argument_list|)
operator|)
condition|)
name|warning
argument_list|(
literal|"unsigned value>= 0 is always 1"
argument_list|)
expr_stmt|;
name|value
operator|=
name|integer_one_node
expr_stmt|;
break|break;
case|case
name|LT_EXPR
case|:
if|if
condition|(
name|extra_warnings
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|primop0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
name|TREE_OVERFLOW
argument_list|(
name|convert
argument_list|(
name|signed_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|primop0
argument_list|)
argument_list|)
operator|)
condition|)
name|warning
argument_list|(
literal|"unsigned value< 0 is always 0"
argument_list|)
expr_stmt|;
name|value
operator|=
name|integer_zero_node
expr_stmt|;
block|}
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
block|{
comment|/* Don't forget to evaluate PRIMOP0 if it has side effects.  */
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|primop0
argument_list|)
condition|)
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|,
name|primop0
argument_list|,
name|value
argument_list|)
return|;
return|return
name|value
return|;
block|}
block|}
block|}
operator|*
name|op0_ptr
operator|=
name|convert
argument_list|(
name|type
argument_list|,
name|primop0
argument_list|)
expr_stmt|;
operator|*
name|op1_ptr
operator|=
name|convert
argument_list|(
name|type
argument_list|,
name|primop1
argument_list|)
expr_stmt|;
operator|*
name|restype_ptr
operator|=
name|integer_type_node
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Prepare expr to be an argument of a TRUTH_NOT_EXPR,    or validate its data type for an `if' or `while' statement or ?..: exp.     This preparation consists of taking the ordinary    representation of an expression expr and producing a valid tree    boolean expression describing whether expr is nonzero.  We could    simply always do build_binary_op (NE_EXPR, expr, integer_zero_node, 1),    but we optimize comparisons,&&, ||, and !.     The resulting type should always be `integer_type_node'.  */
end_comment

begin_function
name|tree
name|truthvalue_conversion
parameter_list|(
name|expr
parameter_list|)
name|tree
name|expr
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|expr
return|;
if|#
directive|if
literal|0
comment|/* This appears to be wrong for C++.  */
comment|/* These really should return error_mark_node after 2.4 is stable.      But not all callers handle ERROR_MARK properly.  */
block|switch (TREE_CODE (TREE_TYPE (expr)))     {     case RECORD_TYPE:       error ("struct type value used where scalar is required");       return integer_zero_node;      case UNION_TYPE:       error ("union type value used where scalar is required");       return integer_zero_node;      case ARRAY_TYPE:       error ("array type value used where scalar is required");       return integer_zero_node;      default:       break;     }
endif|#
directive|endif
comment|/* 0 */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
condition|)
block|{
comment|/* It is simpler and generates better code to have only TRUTH_*_EXPR 	 or comparison expressions as truth values at this level.  */
if|#
directive|if
literal|0
block|case COMPONENT_REF:
comment|/* A one-bit unsigned bit-field is already acceptable.  */
block|if (1 == TREE_INT_CST_LOW (DECL_SIZE (TREE_OPERAND (expr, 1)))&& TREE_UNSIGNED (TREE_OPERAND (expr, 1))) 	return expr;       break;
endif|#
directive|endif
case|case
name|EQ_EXPR
case|:
comment|/* It is simpler and generates better code to have only TRUTH_*_EXPR 	 or comparison expressions as truth values at this level.  */
if|#
directive|if
literal|0
block|if (integer_zerop (TREE_OPERAND (expr, 1))) 	return build_unary_op (TRUTH_NOT_EXPR, TREE_OPERAND (expr, 0), 0);
endif|#
directive|endif
case|case
name|NE_EXPR
case|:
case|case
name|LE_EXPR
case|:
case|case
name|GE_EXPR
case|:
case|case
name|LT_EXPR
case|:
case|case
name|GT_EXPR
case|:
case|case
name|TRUTH_ANDIF_EXPR
case|:
case|case
name|TRUTH_ORIF_EXPR
case|:
case|case
name|TRUTH_AND_EXPR
case|:
case|case
name|TRUTH_OR_EXPR
case|:
case|case
name|TRUTH_XOR_EXPR
case|:
return|return
name|convert
argument_list|(
name|integer_type_node
argument_list|,
name|expr
argument_list|)
return|;
case|case
name|ERROR_MARK
case|:
return|return
name|expr
return|;
case|case
name|INTEGER_CST
case|:
return|return
name|integer_zerop
argument_list|(
name|expr
argument_list|)
condition|?
name|integer_zero_node
else|:
name|integer_one_node
return|;
case|case
name|REAL_CST
case|:
return|return
name|real_zerop
argument_list|(
name|expr
argument_list|)
condition|?
name|integer_zero_node
else|:
name|integer_one_node
return|;
case|case
name|ADDR_EXPR
case|:
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|integer_one_node
argument_list|)
return|;
else|else
return|return
name|integer_one_node
return|;
case|case
name|COMPLEX_EXPR
case|:
return|return
name|build_binary_op
argument_list|(
operator|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|?
name|TRUTH_OR_EXPR
else|:
name|TRUTH_ORIF_EXPR
operator|)
argument_list|,
name|truthvalue_conversion
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|truthvalue_conversion
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|NEGATE_EXPR
case|:
case|case
name|ABS_EXPR
case|:
case|case
name|FLOAT_EXPR
case|:
case|case
name|FFS_EXPR
case|:
comment|/* These don't change whether an object is non-zero or zero.  */
return|return
name|truthvalue_conversion
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|LROTATE_EXPR
case|:
case|case
name|RROTATE_EXPR
case|:
comment|/* These don't change whether an object is zero or non-zero, but 	 we can't ignore them if their second arg has side-effects.  */
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|,
name|truthvalue_conversion
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
else|else
return|return
name|truthvalue_conversion
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|COND_EXPR
case|:
comment|/* Distribute the conversion into the arms of a COND_EXPR.  */
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|truthvalue_conversion
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|truthvalue_conversion
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|2
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|CONVERT_EXPR
case|:
comment|/* Don't cancel the effect of a CONVERT_EXPR from a REFERENCE_TYPE, 	 since that affects how `default_conversion' will behave.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
break|break;
comment|/* fall through... */
case|case
name|NOP_EXPR
case|:
comment|/* If this is widening the argument, we can ignore it.  */
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|>=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|truthvalue_conversion
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
break|break;
case|case
name|MINUS_EXPR
case|:
comment|/* With IEEE arithmetic, x - x may not equal 0, so we can't optimize 	 this case.  */
if|if
condition|(
name|TARGET_FLOAT_FORMAT
operator|==
name|IEEE_FLOAT_FORMAT
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|REAL_TYPE
condition|)
break|break;
comment|/* fall through... */
case|case
name|BIT_XOR_EXPR
case|:
comment|/* This and MINUS_EXPR can be changed into a comparison of the 	 two objects.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|build_binary_op
argument_list|(
name|NE_EXPR
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
return|;
return|return
name|build_binary_op
argument_list|(
name|NE_EXPR
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
return|;
case|case
name|BIT_AND_EXPR
case|:
if|if
condition|(
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|expr
return|;
case|case
name|MODIFY_EXPR
case|:
if|if
condition|(
name|warn_parentheses
operator|&&
name|C_EXP_ORIGINAL_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|MODIFY_EXPR
condition|)
name|warning
argument_list|(
literal|"suggest parentheses around assignment used as truth value"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|COMPLEX_TYPE
condition|)
return|return
operator|(
name|build_binary_op
argument_list|(
operator|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|expr
argument_list|)
condition|?
name|TRUTH_OR_EXPR
else|:
name|TRUTH_ORIF_EXPR
operator|)
argument_list|,
name|truthvalue_conversion
argument_list|(
name|build_unary_op
argument_list|(
name|REALPART_EXPR
argument_list|,
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|truthvalue_conversion
argument_list|(
name|build_unary_op
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
return|;
return|return
name|build_binary_op
argument_list|(
name|NE_EXPR
argument_list|,
name|expr
argument_list|,
name|integer_zero_node
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read the rest of a #-directive from input stream FINPUT.    In normal use, the directive name and the white space after it    have already been read, so they won't be included in the result.    We allow for the fact that the directive line may contain    a newline embedded within a character or string literal which forms    a part of the directive.     The value is a string in a reusable buffer.  It remains valid    only until the next time this function is called.  */
end_comment

begin_function
name|char
modifier|*
name|get_directive_line
parameter_list|(
name|finput
parameter_list|)
specifier|register
name|FILE
modifier|*
name|finput
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|directive_buffer
init|=
name|NULL
decl_stmt|;
specifier|static
name|unsigned
name|buffer_length
init|=
literal|0
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|buffer_limit
decl_stmt|;
specifier|register
name|int
name|looking_for
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|char_escaped
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|buffer_length
operator|==
literal|0
condition|)
block|{
name|directive_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|128
argument_list|)
expr_stmt|;
name|buffer_length
operator|=
literal|128
expr_stmt|;
block|}
name|buffer_limit
operator|=
operator|&
name|directive_buffer
index|[
name|buffer_length
index|]
expr_stmt|;
for|for
control|(
name|p
operator|=
name|directive_buffer
init|;
condition|;
control|)
block|{
name|int
name|c
decl_stmt|;
comment|/* Make buffer bigger if it is full.  */
if|if
condition|(
name|p
operator|>=
name|buffer_limit
condition|)
block|{
specifier|register
name|unsigned
name|bytes_used
init|=
operator|(
name|p
operator|-
name|directive_buffer
operator|)
decl_stmt|;
name|buffer_length
operator|*=
literal|2
expr_stmt|;
name|directive_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|directive_buffer
argument_list|,
name|buffer_length
argument_list|)
expr_stmt|;
name|p
operator|=
operator|&
name|directive_buffer
index|[
name|bytes_used
index|]
expr_stmt|;
name|buffer_limit
operator|=
operator|&
name|directive_buffer
index|[
name|buffer_length
index|]
expr_stmt|;
block|}
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
comment|/* Discard initial whitespace.  */
if|if
condition|(
operator|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|)
operator|&&
name|p
operator|==
name|directive_buffer
condition|)
continue|continue;
comment|/* Detect the end of the directive.  */
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|&&
name|looking_for
operator|==
literal|0
condition|)
block|{
name|ungetc
argument_list|(
name|c
argument_list|,
name|finput
argument_list|)
expr_stmt|;
name|c
operator|=
literal|'\0'
expr_stmt|;
block|}
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
return|return
name|directive_buffer
return|;
comment|/* Handle string and character constant syntax.  */
if|if
condition|(
name|looking_for
condition|)
block|{
if|if
condition|(
name|looking_for
operator|==
name|c
operator|&&
operator|!
name|char_escaped
condition|)
name|looking_for
operator|=
literal|0
expr_stmt|;
comment|/* Found terminator... stop looking.  */
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\''
operator|||
name|c
operator|==
literal|'"'
condition|)
name|looking_for
operator|=
name|c
expr_stmt|;
comment|/* Don't stop buffering until we see another 				   another one of these (or an EOF).  */
comment|/* Handle backslash.  */
name|char_escaped
operator|=
operator|(
name|c
operator|==
literal|'\\'
operator|&&
operator|!
name|char_escaped
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make a variant type in the proper way for C/C++, propagating qualifiers    down to the element type of an array.  */
end_comment

begin_function
name|tree
name|c_build_type_variant
parameter_list|(
name|type
parameter_list|,
name|constp
parameter_list|,
name|volatilep
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
name|constp
decl_stmt|,
name|volatilep
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|tree
name|real_main_variant
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|push_obstacks
argument_list|(
name|TYPE_OBSTACK
argument_list|(
name|real_main_variant
argument_list|)
argument_list|,
name|TYPE_OBSTACK
argument_list|(
name|real_main_variant
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_array_type
argument_list|(
name|c_build_type_variant
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|)
argument_list|,
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* TYPE must be on same obstack as REAL_MAIN_VARIANT.  If not, 	 make a copy.  (TYPE might have come from the hash table and 	 REAL_MAIN_VARIANT might be in some function's obstack.)  */
if|if
condition|(
name|TYPE_OBSTACK
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_OBSTACK
argument_list|(
name|real_main_variant
argument_list|)
condition|)
block|{
name|type
operator|=
name|copy_node
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_POINTER_TO
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_REFERENCE_TO
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|=
name|real_main_variant
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
return|return
name|build_type_variant
argument_list|(
name|type
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|)
return|;
block|}
end_function

end_unit

