begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Output variables, constants and external declarations, for GNU compiler.    Copyright (C) 1987, 88, 89, 92, 93, 1994 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* This file handles generation of all the assembler code    *except* the instructions of a function.    This includes declarations of variables and their initial values.     We also output the assembler code for constants stored in memory    and are responsible for combining constants with the same value.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_comment
comment|/* #include<stab.h> */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"defaults.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"bytecode.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|XCOFF_DEBUGGING_INFO
end_ifdef

begin_include
include|#
directive|include
file|"xcoffout.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_STABS_OP
end_ifndef

begin_define
define|#
directive|define
name|ASM_STABS_OP
value|".stabs"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This macro gets just the user-specified name    out of the string in a SYMBOL_REF.  On most machines,    we discard the * if any and that's all.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|STRIP_NAME_ENCODING
end_ifndef

begin_define
define|#
directive|define
name|STRIP_NAME_ENCODING
parameter_list|(
name|VAR
parameter_list|,
name|SYMBOL_NAME
parameter_list|)
define|\
value|(VAR) = ((SYMBOL_NAME) + ((SYMBOL_NAME)[0] == '*'))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* File in which assembler code is being written.  */
end_comment

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|asm_out_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The (assembler) name of the first globally-visible object output.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|first_global_object_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|obstack
modifier|*
name|current_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|obstack
modifier|*
name|saveable_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|obstack
modifier|*
name|rtl_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|obstack
name|permanent_obstack
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_comment
comment|/* Number for making the label on the next    constant that is stored in memory.  */
end_comment

begin_decl_stmt
name|int
name|const_labelno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number for making the label on the next    static variable internal to a function.  */
end_comment

begin_decl_stmt
name|int
name|var_labelno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Carry information from ASM_DECLARE_OBJECT_NAME    to ASM_FINISH_DECLARE_OBJECT.  */
end_comment

begin_decl_stmt
name|int
name|size_directive_output
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The last decl for which assemble_variable was called,    if it did ASM_DECLARE_OBJECT_NAME.    If the last call to assemble_variable didn't do that,    this holds 0.  */
end_comment

begin_decl_stmt
name|tree
name|last_assemble_variable_decl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if at least one function definition has been seen.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|function_defined
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|asm_out_file
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|char
modifier|*
name|compare_constant_1
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|record_constant_1
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|output_constant_def_contents
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|contains_pointers_p
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bc_output_ascii
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|output_constant_pool
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|assemble_name
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|output_addressed_constants
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|output_constant
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|output_constructor
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|output_byte_asm
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|text_section
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|readonly_data_section
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|data_section
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|named_section
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bc_assemble_integer
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|EXTRA_SECTIONS
end_ifdef

begin_enum
specifier|static
enum|enum
name|in_section
block|{
name|no_section
block|,
name|in_text
block|,
name|in_data
block|,
name|in_named
block|,
name|EXTRA_SECTIONS
block|}
name|in_section
init|=
name|no_section
enum|;
end_enum

begin_else
else|#
directive|else
end_else

begin_enum
specifier|static
enum|enum
name|in_section
block|{
name|no_section
block|,
name|in_text
block|,
name|in_data
block|,
name|in_named
block|}
name|in_section
init|=
name|no_section
enum|;
end_enum

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Return a non-zero value if DECL has a section attribute.  */
end_comment

begin_define
define|#
directive|define
name|IN_NAMED_SECTION
parameter_list|(
name|DECL
parameter_list|)
define|\
value|((TREE_CODE (DECL) == FUNCTION_DECL || TREE_CODE (DECL) == VAR_DECL) \&& DECL_SECTION_NAME (DECL) != NULL_TREE)
end_define

begin_comment
comment|/* Text of section name when in_section == in_named.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|in_named_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Define functions like text_section for any extra sections.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|EXTRA_SECTION_FUNCTIONS
end_ifdef

begin_function
name|EXTRA_SECTION_FUNCTIONS
endif|#
directive|endif
comment|/* Tell assembler to switch to text section.  */
name|void
name|text_section
parameter_list|()
block|{
if|if
condition|(
name|in_section
operator|!=
name|in_text
condition|)
block|{
if|if
condition|(
name|output_bytecode
condition|)
name|bc_text
argument_list|()
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"%s\n"
argument_list|,
name|TEXT_SECTION_ASM_OP
argument_list|)
expr_stmt|;
name|in_section
operator|=
name|in_text
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Tell assembler to switch to data section.  */
end_comment

begin_function
name|void
name|data_section
parameter_list|()
block|{
if|if
condition|(
name|in_section
operator|!=
name|in_data
condition|)
block|{
if|if
condition|(
name|output_bytecode
condition|)
name|bc_data
argument_list|()
expr_stmt|;
else|else
block|{
if|if
condition|(
name|flag_shared_data
condition|)
block|{
ifdef|#
directive|ifdef
name|SHARED_SECTION_ASM_OP
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"%s\n"
argument_list|,
name|SHARED_SECTION_ASM_OP
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"%s\n"
argument_list|,
name|DATA_SECTION_ASM_OP
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"%s\n"
argument_list|,
name|DATA_SECTION_ASM_OP
argument_list|)
expr_stmt|;
block|}
name|in_section
operator|=
name|in_data
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Tell assembler to switch to read-only data section.  This is normally    the text section.  */
end_comment

begin_function
name|void
name|readonly_data_section
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|READONLY_DATA_SECTION
name|READONLY_DATA_SECTION
argument_list|()
expr_stmt|;
comment|/* Note this can call data_section.  */
else|#
directive|else
name|text_section
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Determine if we're in the text section. */
end_comment

begin_function
name|int
name|in_text_section
parameter_list|()
block|{
return|return
name|in_section
operator|==
name|in_text
return|;
block|}
end_function

begin_comment
comment|/* Tell assembler to change to named section.  */
end_comment

begin_function
name|void
name|named_section
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
if|if
condition|(
name|in_section
operator|!=
name|in_named
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
name|in_named_name
argument_list|)
condition|)
block|{
name|in_named_name
operator|=
name|name
expr_stmt|;
name|in_section
operator|=
name|in_named
expr_stmt|;
ifdef|#
directive|ifdef
name|ASM_OUTPUT_SECTION_NAME
name|ASM_OUTPUT_SECTION_NAME
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Section attributes are not supported if this macro isn't provided - 	 some host formats don't support them at all.  The front-end should 	 already have flagged this as an error.  */
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create the rtl to represent a function, for a function definition.    DECL is a FUNCTION_DECL node which describes which function.    The rtl is stored into DECL.  */
end_comment

begin_function
name|void
name|make_function_rtl
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|char
modifier|*
name|name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|output_bytecode
condition|)
block|{
if|if
condition|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|=
name|bc_gen_rtx
argument_list|(
name|name
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|bc_label
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* Record that at least one function has been defined.  */
name|function_defined
operator|=
literal|1
expr_stmt|;
return|return;
block|}
comment|/* Rename a nested function to avoid conflicts.  */
if|if
condition|(
name|decl_function_context
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|&&
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|label
decl_stmt|;
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_FORMAT_PRIVATE_NAME
argument_list|(
name|label
argument_list|,
name|name
argument_list|,
name|var_labelno
argument_list|)
expr_stmt|;
name|name
operator|=
name|obstack_copy0
argument_list|(
name|saveable_obstack
argument_list|,
name|label
argument_list|,
name|strlen
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|var_labelno
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
block|{
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
name|name
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Optionally set flags or add text to the name to record information 	 such as that it is a function name.  If the name is changed, the macro 	 ASM_OUTPUT_LABELREF will have to know how to strip this information.  */
ifdef|#
directive|ifdef
name|ENCODE_SECTION_INFO
name|ENCODE_SECTION_INFO
argument_list|(
name|decl
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Record at least one function has been defined.  */
name|function_defined
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create the DECL_RTL for a declaration for a static or external    variable or static or external function.    ASMSPEC, if not 0, is the string which the user specified    as the assembler symbol name.    TOP_LEVEL is nonzero if this is a file-scope variable.    This is never called for PARM_DECLs.  */
end_comment

begin_function
name|void
name|bc_make_decl_rtl
parameter_list|(
name|decl
parameter_list|,
name|asmspec
parameter_list|,
name|top_level
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|char
modifier|*
name|asmspec
decl_stmt|;
name|int
name|top_level
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|name
init|=
name|TREE_STRING_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Print an error message for register variables.  */
if|if
condition|(
name|DECL_REGISTER
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|error
argument_list|(
literal|"function declared `register'"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_REGISTER
argument_list|(
name|decl
argument_list|)
condition|)
name|error
argument_list|(
literal|"global register variables not supported in the interpreter"
argument_list|)
expr_stmt|;
comment|/* Handle ordinary static variables and functions.  */
if|if
condition|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Can't use just the variable's own name for a variable 	     whose scope is less than the whole file. 	     Concatenate a distinguishing number.  */
if|if
condition|(
operator|!
name|top_level
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|asmspec
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|label
decl_stmt|;
name|ASM_FORMAT_PRIVATE_NAME
argument_list|(
name|label
argument_list|,
name|name
argument_list|,
name|var_labelno
argument_list|)
expr_stmt|;
name|name
operator|=
name|obstack_copy0
argument_list|(
name|saveable_obstack
argument_list|,
name|label
argument_list|,
name|strlen
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|var_labelno
operator|++
expr_stmt|;
block|}
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|=
name|bc_gen_rtx
argument_list|(
name|name
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|bc_label
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Given NAME, a putative register name, discard any customary prefixes.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|strip_reg_name
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|REGISTER_PREFIX
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
name|REGISTER_PREFIX
argument_list|,
name|strlen
argument_list|(
name|REGISTER_PREFIX
argument_list|)
argument_list|)
condition|)
name|name
operator|+=
name|strlen
argument_list|(
name|REGISTER_PREFIX
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'%'
operator|||
name|name
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
name|name
operator|++
expr_stmt|;
return|return
name|name
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Decode an `asm' spec for a declaration as a register name.    Return the register number, or -1 if nothing specified,    or -2 if the ASMSPEC is not `cc' or `memory' and is not recognized,    or -3 if ASMSPEC is `cc' and is not recognized,    or -4 if ASMSPEC is `memory' and is not recognized.    Accept an exact spelling or a decimal number.    Prefixes such as % are optional.  */
end_comment

begin_function
name|int
name|decode_reg_name
parameter_list|(
name|asmspec
parameter_list|)
name|char
modifier|*
name|asmspec
decl_stmt|;
block|{
if|if
condition|(
name|asmspec
operator|!=
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Get rid of confusing prefixes.  */
name|asmspec
operator|=
name|strip_reg_name
argument_list|(
name|asmspec
argument_list|)
expr_stmt|;
comment|/* Allow a decimal number as a "register name".  */
for|for
control|(
name|i
operator|=
name|strlen
argument_list|(
name|asmspec
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
operator|!
operator|(
name|asmspec
index|[
name|i
index|]
operator|>=
literal|'0'
operator|&&
name|asmspec
index|[
name|i
index|]
operator|<=
literal|'9'
operator|)
condition|)
break|break;
if|if
condition|(
name|asmspec
index|[
literal|0
index|]
operator|!=
literal|0
operator|&&
name|i
operator|<
literal|0
condition|)
block|{
name|i
operator|=
name|atoi
argument_list|(
name|asmspec
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|i
operator|>=
literal|0
condition|)
return|return
name|i
return|;
else|else
return|return
operator|-
literal|2
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|reg_names
index|[
name|i
index|]
index|[
literal|0
index|]
operator|&&
operator|!
name|strcmp
argument_list|(
name|asmspec
argument_list|,
name|strip_reg_name
argument_list|(
name|reg_names
index|[
name|i
index|]
argument_list|)
argument_list|)
condition|)
return|return
name|i
return|;
ifdef|#
directive|ifdef
name|ADDITIONAL_REGISTER_NAMES
block|{
specifier|static
struct|struct
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|number
decl_stmt|;
block|}
name|table
index|[]
init|=
name|ADDITIONAL_REGISTER_NAMES
struct|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|table
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|asmspec
argument_list|,
name|table
index|[
name|i
index|]
operator|.
name|name
argument_list|)
condition|)
return|return
name|table
index|[
name|i
index|]
operator|.
name|number
return|;
block|}
endif|#
directive|endif
comment|/* ADDITIONAL_REGISTER_NAMES */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|asmspec
argument_list|,
literal|"memory"
argument_list|)
condition|)
return|return
operator|-
literal|4
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|asmspec
argument_list|,
literal|"cc"
argument_list|)
condition|)
return|return
operator|-
literal|3
return|;
return|return
operator|-
literal|2
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create the DECL_RTL for a declaration for a static or external variable    or static or external function.    ASMSPEC, if not 0, is the string which the user specified    as the assembler symbol name.    TOP_LEVEL is nonzero if this is a file-scope variable.     This is never called for PARM_DECL nodes.  */
end_comment

begin_function
name|void
name|make_decl_rtl
parameter_list|(
name|decl
parameter_list|,
name|asmspec
parameter_list|,
name|top_level
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|char
modifier|*
name|asmspec
decl_stmt|;
name|int
name|top_level
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|name
init|=
literal|0
decl_stmt|;
name|int
name|reg_number
decl_stmt|;
if|if
condition|(
name|output_bytecode
condition|)
block|{
name|bc_make_decl_rtl
argument_list|(
name|decl
argument_list|,
name|asmspec
argument_list|,
name|top_level
argument_list|)
expr_stmt|;
return|return;
block|}
name|reg_number
operator|=
name|decode_reg_name
argument_list|(
name|asmspec
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_number
operator|==
operator|-
literal|2
condition|)
block|{
comment|/* ASMSPEC is given, and not the name of a register.  */
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|saveable_obstack
argument_list|,
name|strlen
argument_list|(
name|asmspec
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|name
index|[
literal|0
index|]
operator|=
literal|'*'
expr_stmt|;
name|strcpy
argument_list|(
operator|&
name|name
index|[
literal|1
index|]
argument_list|,
name|asmspec
argument_list|)
expr_stmt|;
block|}
comment|/* For a duplicate declaration, we can be called twice on the      same DECL node.  Don't discard the RTL already made.  */
if|if
condition|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
block|{
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* First detect errors in declaring global registers.  */
if|if
condition|(
name|DECL_REGISTER
argument_list|(
name|decl
argument_list|)
operator|&&
name|reg_number
operator|==
operator|-
literal|1
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"register name not specified for `%s'"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_REGISTER
argument_list|(
name|decl
argument_list|)
operator|&&
name|reg_number
operator|<
literal|0
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"invalid register name for `%s'"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|reg_number
operator|>=
literal|0
operator|||
name|reg_number
operator|==
operator|-
literal|3
operator|)
operator|&&
operator|!
name|DECL_REGISTER
argument_list|(
name|decl
argument_list|)
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"register name given for non-register variable `%s'"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_REGISTER
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|error
argument_list|(
literal|"function declared `register'"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_REGISTER
argument_list|(
name|decl
argument_list|)
operator|&&
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|BLKmode
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"data type of `%s' isn't suitable for a register"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_REGISTER
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|HARD_REGNO_MODE_OK
argument_list|(
name|reg_number
argument_list|,
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"register number for `%s' isn't suitable for the data type"
argument_list|)
expr_stmt|;
comment|/* Now handle properly declared static register variables.  */
elseif|else
if|if
condition|(
name|DECL_REGISTER
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|int
name|nregs
decl_stmt|;
if|#
directive|if
literal|0
comment|/* yylex should print the warning for this */
block|if (pedantic) 	    pedwarn ("ANSI C forbids global register variables");
endif|#
directive|endif
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|&&
name|top_level
condition|)
block|{
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|error
argument_list|(
literal|"global register variable has initial value"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fixed_regs
index|[
name|reg_number
index|]
operator|==
literal|0
operator|&&
name|function_defined
operator|&&
name|top_level
condition|)
name|error
argument_list|(
literal|"global register variable follows a function definition"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|decl
argument_list|)
condition|)
name|warning
argument_list|(
literal|"volatile register variables don't work as you might wish"
argument_list|)
expr_stmt|;
comment|/* If the user specified one of the eliminables registers here, 	     e.g., FRAME_POINTER_REGNUM, we don't want to get this variable 	     confused with that register and be eliminated.  Although this 	     usage is somewhat suspect, we nevertheless use the following 	     kludge to avoid setting DECL_RTL to frame_pointer_rtx.  */
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|FIRST_PSEUDO_REGISTER
argument_list|)
expr_stmt|;
name|REGNO
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
name|reg_number
expr_stmt|;
name|REG_USERVAR_P
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|top_level
condition|)
block|{
comment|/* Make this register global, so not usable for anything 		 else.  */
name|nregs
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|reg_number
argument_list|,
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|nregs
operator|>
literal|0
condition|)
name|globalize_reg
argument_list|(
name|reg_number
operator|+
operator|--
name|nregs
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Specifying a section attribute on an uninitialized variable does not 	 (and cannot) cause it to be put in the given section.  The linker 	 can only put initialized objects in specific sections, everything 	 else goes in bss for the linker to sort out later (otherwise the 	 linker would give a duplicate definition error for each compilation 	 unit that behaved thusly).  So warn the user.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|warning_with_decl
argument_list|(
name|decl
argument_list|,
literal|"section attribute ignored for uninitialized variable `%s'"
argument_list|)
expr_stmt|;
comment|/* Remove the section name so subsequent declarations won't see it. 	     We are ignoring it, remember.  */
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
comment|/* Now handle ordinary static variables and functions (in memory). 	 Also handle vars declared register invalidly.  */
if|if
condition|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Can't use just the variable's own name for a variable 	     whose scope is less than the whole file. 	     Concatenate a distinguishing number.  */
if|if
condition|(
operator|!
name|top_level
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|asmspec
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|label
decl_stmt|;
name|ASM_FORMAT_PRIVATE_NAME
argument_list|(
name|label
argument_list|,
name|name
argument_list|,
name|var_labelno
argument_list|)
expr_stmt|;
name|name
operator|=
name|obstack_copy0
argument_list|(
name|saveable_obstack
argument_list|,
name|label
argument_list|,
name|strlen
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|var_labelno
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|name
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
name|name
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this variable is to be treated as volatile, show its 	     tree node has side effects.  If it has side effects, either 	     because of this test or from TREE_THIS_VOLATILE also 	     being set, show the MEM is volatile.  */
if|if
condition|(
name|flag_volatile_global
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
name|TREE_SIDE_EFFECTS
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|decl
argument_list|)
condition|)
name|MEM_VOLATILE_P
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
condition|)
name|RTX_UNCHANGING_P
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
name|AGGREGATE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Optionally set flags or add text to the name to record information 	     such as that it is a function name. 	     If the name is changed, the macro ASM_OUTPUT_LABELREF 	     will have to know how to strip this information.  */
ifdef|#
directive|ifdef
name|ENCODE_SECTION_INFO
name|ENCODE_SECTION_INFO
argument_list|(
name|decl
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
comment|/* If the old RTL had the wrong mode, fix the mode.  */
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|rtx
name|rtl
init|=
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|PUT_MODE
argument_list|(
name|rtl
argument_list|,
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Make the rtl for variable VAR be volatile.    Use this only for static variables.  */
end_comment

begin_function
name|void
name|make_var_volatile
parameter_list|(
name|var
parameter_list|)
name|tree
name|var
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|var
argument_list|)
argument_list|)
operator|!=
name|MEM
condition|)
name|abort
argument_list|()
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|DECL_RTL
argument_list|(
name|var
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output alignment directive to align for constant expression EXP.  */
end_comment

begin_function
name|void
name|assemble_constant_align
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
name|int
name|align
decl_stmt|;
comment|/* Align the location counter as required by EXP's data type.  */
name|align
operator|=
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CONSTANT_ALIGNMENT
name|align
operator|=
name|CONSTANT_ALIGNMENT
argument_list|(
name|exp
argument_list|,
name|align
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|align
operator|>
name|BITS_PER_UNIT
condition|)
name|ASM_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
name|floor_log2
argument_list|(
name|align
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output a string of literal assembler code    for an `asm' keyword used between functions.  */
end_comment

begin_function
name|void
name|assemble_asm
parameter_list|(
name|string
parameter_list|)
name|tree
name|string
decl_stmt|;
block|{
if|if
condition|(
name|output_bytecode
condition|)
block|{
name|error
argument_list|(
literal|"asm statements not allowed in interpreter"
argument_list|)
expr_stmt|;
return|return;
block|}
name|app_enable
argument_list|()
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|string
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
name|string
operator|=
name|TREE_OPERAND
argument_list|(
name|string
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s\n"
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|string
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* This should no longer be needed, because 	 flag_gnu_linker should be 0 on these systems, 	 which should prevent any output 	 if ASM_OUTPUT_CONSTRUCTOR and ASM_OUTPUT_DESTRUCTOR are absent.  */
end_comment

begin_if
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|DBX_DEBUGGING_INFO
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|FASCIST_ASSEMBLER
argument_list|)
operator|)
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_OUTPUT_CONSTRUCTOR
end_ifndef

begin_define
define|#
directive|define
name|ASM_OUTPUT_CONSTRUCTOR
parameter_list|(
name|file
parameter_list|,
name|name
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_OUTPUT_DESTRUCTOR
end_ifndef

begin_define
define|#
directive|define
name|ASM_OUTPUT_DESTRUCTOR
parameter_list|(
name|file
parameter_list|,
name|name
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_comment
comment|/* Record an element in the table of global destructors.    How this is done depends on what sort of assembler and linker    are in use.     NAME should be the name of a global function to be called    at exit time.  This name is output using assemble_name.  */
end_comment

begin_function
name|void
name|assemble_destructor
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|ASM_OUTPUT_DESTRUCTOR
name|ASM_OUTPUT_DESTRUCTOR
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|flag_gnu_linker
condition|)
block|{
comment|/* Now tell GNU LD that this is part of the static destructor set.  */
comment|/* This code works for any machine provided you use GNU as/ld.  */
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"%s \"___DTOR_LIST__\",22,0,0,"
argument_list|,
name|ASM_STABS_OP
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Likewise for global constructors.  */
end_comment

begin_function
name|void
name|assemble_constructor
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|ASM_OUTPUT_CONSTRUCTOR
name|ASM_OUTPUT_CONSTRUCTOR
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|flag_gnu_linker
condition|)
block|{
comment|/* Now tell GNU LD that this is part of the static constructor set.  */
comment|/* This code works for any machine provided you use GNU as/ld.  */
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"%s \"___CTOR_LIST__\",22,0,0,"
argument_list|,
name|ASM_STABS_OP
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Likewise for entries we want to record for garbage collection.    Garbage collection is still under development.  */
end_comment

begin_function
name|void
name|assemble_gc_entry
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|ASM_OUTPUT_GC_ENTRY
name|ASM_OUTPUT_GC_ENTRY
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|flag_gnu_linker
condition|)
block|{
comment|/* Now tell GNU LD that this is part of the static constructor set.  */
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"%s \"___PTR_LIST__\",22,0,0,"
argument_list|,
name|ASM_STABS_OP
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output assembler code for the constant pool of a function and associated    with defining the name of the function.  DECL describes the function.    NAME is the function's name.  For the constant pool, we use the current    constant pool data.  */
end_comment

begin_function
name|void
name|assemble_start_function
parameter_list|(
name|decl
parameter_list|,
name|fnname
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|char
modifier|*
name|fnname
decl_stmt|;
block|{
name|int
name|align
decl_stmt|;
comment|/* The following code does not need preprocessing in the assembler.  */
name|app_disable
argument_list|()
expr_stmt|;
name|output_constant_pool
argument_list|(
name|fnname
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN_NAMED_SECTION
argument_list|(
name|decl
argument_list|)
condition|)
name|named_section
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|text_section
argument_list|()
expr_stmt|;
comment|/* Tell assembler to move to target machine's alignment for functions.  */
name|align
operator|=
name|floor_log2
argument_list|(
name|FUNCTION_BOUNDARY
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|align
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|output_bytecode
condition|)
name|BC_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
name|align
argument_list|)
expr_stmt|;
else|else
name|ASM_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
name|align
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ASM_OUTPUT_FUNCTION_PREFIX
name|ASM_OUTPUT_FUNCTION_PREFIX
argument_list|(
name|asm_out_file
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SDB_DEBUGGING_INFO
comment|/* Output SDB definition of the function.  */
if|if
condition|(
name|write_symbols
operator|==
name|SDB_DEBUG
condition|)
name|sdbout_mark_begin_function
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DBX_DEBUGGING_INFO
comment|/* Output DBX definition of the function.  */
if|if
condition|(
name|write_symbols
operator|==
name|DBX_DEBUG
condition|)
name|dbxout_begin_function
argument_list|(
name|decl
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Make function name accessible from other files, if appropriate.  */
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|first_global_object_name
condition|)
name|STRIP_NAME_ENCODING
argument_list|(
name|first_global_object_name
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_bytecode
condition|)
name|BC_GLOBALIZE_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
else|else
name|ASM_GLOBALIZE_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
block|}
comment|/* Do any machine/system dependent processing of the function name */
ifdef|#
directive|ifdef
name|ASM_DECLARE_FUNCTION_NAME
name|ASM_DECLARE_FUNCTION_NAME
argument_list|(
name|asm_out_file
argument_list|,
name|fnname
argument_list|,
name|current_function_decl
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Standard thing is just output label for the function.  */
if|if
condition|(
name|output_bytecode
condition|)
name|BC_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
else|else
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ASM_DECLARE_FUNCTION_NAME */
block|}
end_function

begin_comment
comment|/* Output assembler code associated with defining the size of the    function.  DECL describes the function.  NAME is the function's name.  */
end_comment

begin_function
name|void
name|assemble_end_function
parameter_list|(
name|decl
parameter_list|,
name|fnname
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|char
modifier|*
name|fnname
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|ASM_DECLARE_FUNCTION_SIZE
name|ASM_DECLARE_FUNCTION_SIZE
argument_list|(
name|asm_out_file
argument_list|,
name|fnname
argument_list|,
name|decl
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Assemble code to leave SIZE bytes of zeros.  */
end_comment

begin_function
name|void
name|assemble_zeros
parameter_list|(
name|size
parameter_list|)
name|int
name|size
decl_stmt|;
block|{
if|if
condition|(
name|output_bytecode
condition|)
block|{
name|bc_emit_const_skip
argument_list|(
name|size
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|ASM_NO_SKIP_IN_TEXT
comment|/* The `space' pseudo in the text section outputs nop insns rather than 0s,      so we must output 0s explicitly in the text section.  */
if|if
condition|(
name|ASM_NO_SKIP_IN_TEXT
operator|&&
name|in_text_section
argument_list|()
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
operator|-
literal|20
condition|;
name|i
operator|+=
literal|20
control|)
block|{
ifdef|#
directive|ifdef
name|ASM_BYTE_OP
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"%s 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n"
argument_list|,
name|ASM_BYTE_OP
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\tbyte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|i
operator|<
name|size
condition|)
block|{
ifdef|#
directive|ifdef
name|ASM_BYTE_OP
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"%s 0"
argument_list|,
name|ASM_BYTE_OP
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\tbyte 0"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|i
operator|++
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|",0"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
name|size
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|output_bytecode
condition|)
name|BC_OUTPUT_SKIP
argument_list|(
name|asm_out_file
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
name|ASM_OUTPUT_SKIP
argument_list|(
name|asm_out_file
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Assemble an alignment pseudo op for an ALIGN-bit boundary.  */
end_comment

begin_function
name|void
name|assemble_align
parameter_list|(
name|align
parameter_list|)
name|int
name|align
decl_stmt|;
block|{
if|if
condition|(
name|align
operator|>
name|BITS_PER_UNIT
condition|)
name|ASM_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
name|floor_log2
argument_list|(
name|align
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Assemble a string constant with the specified C string as contents.  */
end_comment

begin_function
name|void
name|assemble_string
parameter_list|(
name|p
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|pos
init|=
literal|0
decl_stmt|;
name|int
name|maximum
init|=
literal|2000
decl_stmt|;
if|if
condition|(
name|output_bytecode
condition|)
block|{
name|bc_emit
argument_list|(
name|p
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If the string is very long, split it up.  */
while|while
condition|(
name|pos
operator|<
name|size
condition|)
block|{
name|int
name|thissize
init|=
name|size
operator|-
name|pos
decl_stmt|;
if|if
condition|(
name|thissize
operator|>
name|maximum
condition|)
name|thissize
operator|=
name|maximum
expr_stmt|;
if|if
condition|(
name|output_bytecode
condition|)
name|bc_output_ascii
argument_list|(
name|asm_out_file
argument_list|,
name|p
argument_list|,
name|thissize
argument_list|)
expr_stmt|;
else|else
block|{
name|ASM_OUTPUT_ASCII
argument_list|(
name|asm_out_file
argument_list|,
name|p
argument_list|,
name|thissize
argument_list|)
expr_stmt|;
block|}
name|pos
operator|+=
name|thissize
expr_stmt|;
name|p
operator|+=
name|thissize
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bc_output_ascii
parameter_list|(
name|file
parameter_list|,
name|p
parameter_list|,
name|size
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|BC_OUTPUT_ASCII
argument_list|(
name|file
argument_list|,
name|p
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Assemble everything that is needed for a variable or function declaration.    Not used for automatic variables, and not used for function definitions.    Should not be called for variables of incomplete structure type.     TOP_LEVEL is nonzero if this variable has file scope.    AT_END is nonzero if this is the special handling, at end of compilation,    to define things that have had only tentative definitions.    DONT_OUTPUT_DATA if nonzero means don't actually output the    initial value (that will be done by the caller).  */
end_comment

begin_function
name|void
name|assemble_variable
parameter_list|(
name|decl
parameter_list|,
name|top_level
parameter_list|,
name|at_end
parameter_list|,
name|dont_output_data
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|int
name|top_level
decl_stmt|;
name|int
name|at_end
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|align
decl_stmt|;
name|tree
name|size_tree
decl_stmt|;
name|int
name|reloc
init|=
literal|0
decl_stmt|;
name|enum
name|in_section
name|saved_in_section
decl_stmt|;
name|last_assemble_variable_decl
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|output_bytecode
condition|)
return|return;
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
comment|/* Do output symbol info for global register variables, but do nothing 	 else for them.  */
if|if
condition|(
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|output_bytecode
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|DBX_DEBUGGING_INFO
argument_list|)
operator|||
name|defined
argument_list|(
name|XCOFF_DEBUGGING_INFO
argument_list|)
comment|/* File-scope global variables are output here.  */
if|if
condition|(
operator|(
name|write_symbols
operator|==
name|DBX_DEBUG
operator|||
name|write_symbols
operator|==
name|XCOFF_DEBUG
operator|)
operator|&&
name|top_level
condition|)
name|dbxout_symbol
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SDB_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|SDB_DEBUG
operator|&&
name|top_level
comment|/* Leave initialized global vars for end of compilation; 		 see comment in compile_file.  */
operator|&&
operator|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|||
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|sdbout_symbol
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Don't output any DWARF debugging information for variables here. 	 In the case of local variables, the information for them is output 	 when we do our recursive traversal of the tree representation for 	 the entire containing function.  In the case of file-scope variables, 	 we output information for all of them at the very end of compilation 	 while we are doing our final traversal of the chain of file-scope 	 declarations.  */
return|return;
block|}
comment|/* Normally no need to say anything here for external references,      since assemble_external is called by the langauge-specific code      when a declaration is first seen.  */
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
comment|/* Output no assembler code for a function declaration.      Only definitions of functions output anything.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
return|return;
comment|/* If type was incomplete when the variable was declared,      see if it is complete now.  */
if|if
condition|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
name|layout_decl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Still incomplete => don't allocate it; treat the tentative defn      (which is what it must have been) as an `extern' reference.  */
if|if
condition|(
operator|!
name|dont_output_data
operator|&&
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error_with_file_and_line
argument_list|(
name|DECL_SOURCE_FILE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|"storage size of `%s' isn't known"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return;
block|}
comment|/* The first declaration of a variable that comes through this function      decides whether it is global (in C, has external linkage)      or local (in C, has internal linkage).  So do nothing more      if this function has already run.  */
if|if
condition|(
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* If storage size is erroneously variable, just continue.      Error message was already made.  */
if|if
condition|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
goto|goto
name|finish
goto|;
name|app_disable
argument_list|()
expr_stmt|;
comment|/* This is better than explicit arithmetic, since it avoids overflow.  */
name|size_tree
operator|=
name|size_binop
argument_list|(
name|CEIL_DIV_EXPR
argument_list|,
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_INT_CST_HIGH
argument_list|(
name|size_tree
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"size of variable `%s' is too large"
argument_list|)
expr_stmt|;
goto|goto
name|finish
goto|;
block|}
block|}
name|name
operator|=
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Handle uninitialized definitions.  */
comment|/* ANSI specifies that a tentative definition which is not merged with      a non-tentative definition behaves exactly like a definition with an      initializer equal to zero.  (Section 3.7.2)      -fno-common gives strict ANSI behavior.  Usually you don't want it.      This matters only for variables with external linkage.  */
if|if
condition|(
operator|(
operator|!
name|flag_no_common
operator|||
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|)
operator|&&
name|DECL_COMMON
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|dont_output_data
operator|&&
operator|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|||
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|error_mark_node
operator|)
condition|)
block|{
name|int
name|size
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|size_tree
argument_list|)
decl_stmt|;
name|int
name|rounded
init|=
name|size
decl_stmt|;
if|if
condition|(
name|TREE_INT_CST_HIGH
argument_list|(
name|size_tree
argument_list|)
operator|!=
literal|0
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"size of variable `%s' is too large"
argument_list|)
expr_stmt|;
comment|/* Don't allocate zero bytes of common, 	 since that means "undefined external" in the linker.  */
if|if
condition|(
name|size
operator|==
literal|0
condition|)
name|rounded
operator|=
literal|1
expr_stmt|;
comment|/* Round size up to multiple of BIGGEST_ALIGNMENT bits 	 so that each uninitialized object starts on such a boundary.  */
name|rounded
operator|+=
operator|(
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
operator|)
operator|-
literal|1
expr_stmt|;
name|rounded
operator|=
operator|(
name|rounded
operator|/
operator|(
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
operator|)
operator|*
operator|(
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
operator|)
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DBX_DEBUGGING_INFO
comment|/* File-scope global variables are output here.  */
if|if
condition|(
name|write_symbols
operator|==
name|DBX_DEBUG
operator|&&
name|top_level
condition|)
name|dbxout_symbol
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SDB_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|SDB_DEBUG
operator|&&
name|top_level
comment|/* Leave initialized global vars for end of compilation; 	     see comment in compile_file.  */
operator|&&
operator|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|||
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|sdbout_symbol
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Don't output any DWARF debugging information for variables here. 	 In the case of local variables, the information for them is output 	 when we do our recursive traversal of the tree representation for 	 the entire containing function.  In the case of file-scope variables, 	 we output information for all of them at the very end of compilation 	 while we are doing our final traversal of the chain of file-scope 	 declarations.  */
if|#
directive|if
literal|0
block|if (flag_shared_data) 	data_section ();
endif|#
directive|endif
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|ASM_OUTPUT_SHARED_COMMON
if|if
condition|(
name|flag_shared_data
condition|)
name|ASM_OUTPUT_SHARED_COMMON
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|,
name|size
argument_list|,
name|rounded
argument_list|)
expr_stmt|;
elseif|else
endif|#
directive|endif
if|if
condition|(
name|output_bytecode
condition|)
block|{
name|BC_OUTPUT_COMMON
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|,
name|size
argument_list|,
name|rounded
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|ASM_OUTPUT_ALIGNED_COMMON
name|ASM_OUTPUT_ALIGNED_COMMON
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|,
name|size
argument_list|,
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|ASM_OUTPUT_COMMON
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|,
name|size
argument_list|,
name|rounded
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|ASM_OUTPUT_SHARED_LOCAL
if|if
condition|(
name|flag_shared_data
condition|)
name|ASM_OUTPUT_SHARED_LOCAL
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|,
name|size
argument_list|,
name|rounded
argument_list|)
expr_stmt|;
elseif|else
endif|#
directive|endif
if|if
condition|(
name|output_bytecode
condition|)
block|{
name|BC_OUTPUT_LOCAL
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|,
name|size
argument_list|,
name|rounded
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|ASM_OUTPUT_ALIGNED_LOCAL
name|ASM_OUTPUT_ALIGNED_LOCAL
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|,
name|size
argument_list|,
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|ASM_OUTPUT_LOCAL
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|,
name|size
argument_list|,
name|rounded
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
goto|goto
name|finish
goto|;
block|}
comment|/* Handle initialized definitions.  */
comment|/* First make the assembler name(s) global if appropriate.  */
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|first_global_object_name
condition|)
name|STRIP_NAME_ENCODING
argument_list|(
name|first_global_object_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|ASM_GLOBALIZE_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|for (d = equivalents; d; d = TREE_CHAIN (d))     {       tree e = TREE_VALUE (d);       if (TREE_PUBLIC (e)&& DECL_NAME (e)) 	ASM_GLOBALIZE_LABEL (asm_out_file, 			     XSTR (XEXP (DECL_RTL (e), 0), 0));     }
endif|#
directive|endif
comment|/* Output any data that we will need to use the address of.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|error_mark_node
condition|)
name|reloc
operator|=
name|contains_pointers_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
condition|)
name|reloc
operator|=
name|output_addressed_constants
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Switch to the proper section for this data.  */
if|if
condition|(
name|IN_NAMED_SECTION
argument_list|(
name|decl
argument_list|)
condition|)
name|named_section
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* C++ can have const variables that get initialized from constructors, 	 and thus can not be in a readonly section.  We prevent this by 	 verifying that the initial value is constant for objects put in a 	 readonly section.  	 error_mark_node is used by the C front end to indicate that the 	 initializer has not been seen yet.  In this case, we assume that 	 the initializer must be constant.  */
ifdef|#
directive|ifdef
name|SELECT_SECTION
name|SELECT_SECTION
argument_list|(
name|decl
argument_list|,
name|reloc
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_THIS_VOLATILE
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|&&
operator|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|error_mark_node
operator|||
name|TREE_CONSTANT
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|)
operator|&&
operator|!
operator|(
name|flag_pic
operator|&&
name|reloc
operator|)
condition|)
name|readonly_data_section
argument_list|()
expr_stmt|;
else|else
name|data_section
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* dbxout.c needs to know this.  */
if|if
condition|(
name|in_text_section
argument_list|()
condition|)
name|DECL_IN_TEXT_SECTION
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Record current section so we can restore it if dbxout.c clobbers it.  */
name|saved_in_section
operator|=
name|in_section
expr_stmt|;
comment|/* Output the dbx info now that we have chosen the section.  */
ifdef|#
directive|ifdef
name|DBX_DEBUGGING_INFO
comment|/* File-scope global variables are output here.  */
if|if
condition|(
name|write_symbols
operator|==
name|DBX_DEBUG
operator|&&
name|top_level
condition|)
name|dbxout_symbol
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SDB_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|SDB_DEBUG
operator|&&
name|top_level
comment|/* Leave initialized global vars for end of compilation; 	 see comment in compile_file.  */
operator|&&
operator|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|||
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|sdbout_symbol
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Don't output any DWARF debugging information for variables here.      In the case of local variables, the information for them is output      when we do our recursive traversal of the tree representation for      the entire containing function.  In the case of file-scope variables,      we output information for all of them at the very end of compilation      while we are doing our final traversal of the chain of file-scope      declarations.  */
comment|/* If the debugging output changed sections, reselect the section      that's supposed to be selected.  */
if|if
condition|(
name|in_section
operator|!=
name|saved_in_section
condition|)
block|{
comment|/* Switch to the proper section for this data.  */
ifdef|#
directive|ifdef
name|SELECT_SECTION
name|SELECT_SECTION
argument_list|(
name|decl
argument_list|,
name|reloc
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_THIS_VOLATILE
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|&&
operator|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|error_mark_node
operator|||
name|TREE_CONSTANT
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|)
operator|&&
operator|!
operator|(
name|flag_pic
operator|&&
name|reloc
operator|)
condition|)
name|readonly_data_section
argument_list|()
expr_stmt|;
else|else
name|data_section
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Compute and output the alignment of this data.  */
name|align
operator|=
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* In the case for initialing an array whose length isn't specified,      where we have not yet been able to do the layout,      figure out the proper alignment now.  */
if|if
condition|(
name|dont_output_data
operator|&&
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|align
operator|=
name|MAX
argument_list|(
name|align
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Some object file formats have a maximum alignment which they support.      In particular, a.out format supports a maximum alignment of 4.  */
ifndef|#
directive|ifndef
name|MAX_OFILE_ALIGNMENT
define|#
directive|define
name|MAX_OFILE_ALIGNMENT
value|BIGGEST_ALIGNMENT
endif|#
directive|endif
if|if
condition|(
name|align
operator|>
name|MAX_OFILE_ALIGNMENT
condition|)
block|{
name|warning_with_decl
argument_list|(
name|decl
argument_list|,
literal|"alignment of `%s' is greater than maximum object file alignment"
argument_list|)
expr_stmt|;
name|align
operator|=
name|MAX_OFILE_ALIGNMENT
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DATA_ALIGNMENT
comment|/* On some machines, it is good to increase alignment sometimes.  */
name|align
operator|=
name|DATA_ALIGNMENT
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|align
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CONSTANT_ALIGNMENT
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
condition|)
name|align
operator|=
name|CONSTANT_ALIGNMENT
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|,
name|align
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Reset the alignment in case we have made it tighter, so we can benefit      from it in get_pointer_alignment.  */
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|=
name|align
expr_stmt|;
if|if
condition|(
name|align
operator|>
name|BITS_PER_UNIT
condition|)
block|{
if|if
condition|(
name|output_bytecode
condition|)
name|BC_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
name|floor_log2
argument_list|(
name|align
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|ASM_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
name|floor_log2
argument_list|(
name|align
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Do any machine/system dependent processing of the object.  */
ifdef|#
directive|ifdef
name|ASM_DECLARE_OBJECT_NAME
name|last_assemble_variable_decl
operator|=
name|decl
expr_stmt|;
name|ASM_DECLARE_OBJECT_NAME
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Standard thing is just output label for the object.  */
if|if
condition|(
name|output_bytecode
condition|)
name|BC_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ASM_DECLARE_OBJECT_NAME */
if|if
condition|(
operator|!
name|dont_output_data
condition|)
block|{
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
condition|)
comment|/* Output the actual data.  */
name|output_constant
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|,
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
comment|/* Leave space for it.  */
name|assemble_zeros
argument_list|(
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|finish
label|:
ifdef|#
directive|ifdef
name|XCOFF_DEBUGGING_INFO
comment|/* Unfortunately, the IBM assembler cannot handle stabx before the actual      declaration.  When something like ".stabx  "aa:S-2",aa,133,0" is emitted       and `aa' hasn't been output yet, the assembler generates a stab entry with      a value of zero, in addition to creating an unnecessary external entry      for `aa'.  Hence, we must postpone dbxout_symbol to here at the end.  */
comment|/* File-scope global variables are output here.  */
if|if
condition|(
name|write_symbols
operator|==
name|XCOFF_DEBUG
operator|&&
name|top_level
condition|)
block|{
name|saved_in_section
operator|=
name|in_section
expr_stmt|;
name|dbxout_symbol
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_section
operator|!=
name|saved_in_section
condition|)
block|{
comment|/* Switch to the proper section for this data.  */
ifdef|#
directive|ifdef
name|SELECT_SECTION
name|SELECT_SECTION
argument_list|(
name|decl
argument_list|,
name|reloc
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_THIS_VOLATILE
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|&&
operator|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|error_mark_node
operator|||
name|TREE_CONSTANT
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|)
operator|&&
operator|!
operator|(
name|flag_pic
operator|&&
name|reloc
operator|)
condition|)
name|readonly_data_section
argument_list|()
expr_stmt|;
else|else
name|data_section
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
block|}
else|#
directive|else
comment|/* There must be a statement after a label.  */
empty_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Return 1 if type TYPE contains any pointers.  */
end_comment

begin_function
specifier|static
name|int
name|contains_pointers_p
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
comment|/* I'm not sure whether OFFSET_TYPE needs this treatment, 	 so I'll play safe and return 1.  */
case|case
name|OFFSET_TYPE
case|:
return|return
literal|1
return|;
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|QUAL_UNION_TYPE
case|:
block|{
name|tree
name|fields
decl_stmt|;
comment|/* For a type that has fields, see if the fields have pointers.  */
for|for
control|(
name|fields
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|fields
condition|;
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fields
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
name|contains_pointers_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|fields
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
case|case
name|ARRAY_TYPE
case|:
comment|/* An array type contains pointers if its element type does.  */
return|return
name|contains_pointers_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Output text storage for constructor CONSTR.  Returns rtx of    storage. */
end_comment

begin_function
name|rtx
name|bc_output_constructor
parameter_list|(
name|constr
parameter_list|)
name|tree
name|constr
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
comment|/* Must always be a literal; non-literal constructors are handled      differently. */
if|if
condition|(
operator|!
name|TREE_CONSTANT
argument_list|(
name|constr
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Always const */
name|text_section
argument_list|()
expr_stmt|;
comment|/* Align */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|TYPE_ALIGN
argument_list|(
name|constr
argument_list|)
operator|>=
name|BITS_PER_UNIT
operator|<<
operator|(
name|i
operator|+
literal|1
operator|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|BC_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Output data */
name|output_constant
argument_list|(
name|constr
argument_list|,
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|constr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create storage for constructor CONSTR. */
end_comment

begin_function
name|void
name|bc_output_data_constructor
parameter_list|(
name|constr
parameter_list|)
name|tree
name|constr
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
comment|/* Put in data section */
name|data_section
argument_list|()
expr_stmt|;
comment|/* Align */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|TYPE_ALIGN
argument_list|(
name|constr
argument_list|)
operator|>=
name|BITS_PER_UNIT
operator|<<
operator|(
name|i
operator|+
literal|1
operator|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|BC_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* The constructor is filled in at runtime. */
name|BC_OUTPUT_SKIP
argument_list|(
name|asm_out_file
argument_list|,
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|constr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output something to declare an external symbol to the assembler.    (Most assemblers don't need this, so we normally output nothing.)    Do nothing if DECL is not external.  */
end_comment

begin_function
name|void
name|assemble_external
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
if|if
condition|(
name|output_bytecode
condition|)
return|return;
ifdef|#
directive|ifdef
name|ASM_OUTPUT_EXTERNAL
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
literal|'d'
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|rtx
name|rtl
init|=
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|rtl
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
operator|!
name|SYMBOL_REF_USED
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Some systems do require some output.  */
name|SYMBOL_REF_USED
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ASM_OUTPUT_EXTERNAL
argument_list|(
name|asm_out_file
argument_list|,
name|decl
argument_list|,
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Similar, for calling a library function FUN.  */
end_comment

begin_function
name|void
name|assemble_external_libcall
parameter_list|(
name|fun
parameter_list|)
name|rtx
name|fun
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|ASM_OUTPUT_EXTERNAL_LIBCALL
if|if
condition|(
operator|!
name|output_bytecode
condition|)
block|{
comment|/* Declare library function name external when first used, if nec.  */
if|if
condition|(
operator|!
name|SYMBOL_REF_USED
argument_list|(
name|fun
argument_list|)
condition|)
block|{
name|SYMBOL_REF_USED
argument_list|(
name|fun
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ASM_OUTPUT_EXTERNAL_LIBCALL
argument_list|(
name|asm_out_file
argument_list|,
name|fun
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Declare the label NAME global.  */
end_comment

begin_function
name|void
name|assemble_global
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|ASM_GLOBALIZE_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Assemble a label named NAME.  */
end_comment

begin_function
name|void
name|assemble_label
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
if|if
condition|(
name|output_bytecode
condition|)
name|BC_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output to FILE a reference to the assembler name of a C-level name NAME.    If NAME starts with a *, the rest of NAME is output verbatim.    Otherwise NAME is transformed in an implementation-defined way    (usually by the addition of an underscore).    Many macros in the tm file are defined to call this function.  */
end_comment

begin_function
name|void
name|assemble_name
parameter_list|(
name|file
parameter_list|,
name|name
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|char
modifier|*
name|real_name
decl_stmt|;
name|STRIP_NAME_ENCODING
argument_list|(
name|real_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|TREE_SYMBOL_REFERENCED
argument_list|(
name|get_identifier
argument_list|(
name|real_name
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'*'
condition|)
block|{
if|if
condition|(
name|output_bytecode
condition|)
name|bc_emit_labelref
argument_list|(
name|name
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
operator|&
name|name
index|[
literal|1
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|output_bytecode
condition|)
name|BC_OUTPUT_LABELREF
argument_list|(
name|file
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|ASM_OUTPUT_LABELREF
argument_list|(
name|file
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Allocate SIZE bytes writable static space with a gensym name    and return an RTX to refer to its address.  */
end_comment

begin_function
name|rtx
name|assemble_static_space
parameter_list|(
name|size
parameter_list|)
name|int
name|size
decl_stmt|;
block|{
name|char
name|name
index|[
literal|12
index|]
decl_stmt|;
name|char
modifier|*
name|namestring
decl_stmt|;
name|rtx
name|x
decl_stmt|;
comment|/* Round size up to multiple of BIGGEST_ALIGNMENT bits      so that each uninitialized object starts on such a boundary.  */
name|int
name|rounded
init|=
operator|(
operator|(
name|size
operator|+
operator|(
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
operator|)
operator|-
literal|1
operator|)
operator|/
operator|(
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
operator|)
operator|*
operator|(
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
operator|)
operator|)
decl_stmt|;
if|#
directive|if
literal|0
block|if (flag_shared_data)     data_section ();
endif|#
directive|endif
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|name
argument_list|,
literal|"LF"
argument_list|,
name|const_labelno
argument_list|)
expr_stmt|;
operator|++
name|const_labelno
expr_stmt|;
name|namestring
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|saveable_obstack
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|namestring
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_bytecode
condition|)
name|x
operator|=
name|bc_gen_rtx
argument_list|(
name|namestring
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|bc_label
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
else|else
name|x
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
name|namestring
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_bytecode
condition|)
block|{
name|BC_OUTPUT_LOCAL
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|,
name|size
argument_list|,
name|rounded
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|ASM_OUTPUT_ALIGNED_LOCAL
name|ASM_OUTPUT_ALIGNED_LOCAL
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|,
name|size
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
expr_stmt|;
else|#
directive|else
name|ASM_OUTPUT_LOCAL
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|,
name|size
argument_list|,
name|rounded
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Assemble the static constant template for function entry trampolines.    This is done at most once per compilation.    Returns an RTX for the address of the template.  */
end_comment

begin_function
name|rtx
name|assemble_trampoline_template
parameter_list|()
block|{
name|char
name|label
index|[
literal|256
index|]
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|align
decl_stmt|;
comment|/* Shouldn't get here */
if|if
condition|(
name|output_bytecode
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* By default, put trampoline templates in read-only data section.  */
ifdef|#
directive|ifdef
name|TRAMPOLINE_SECTION
name|TRAMPOLINE_SECTION
argument_list|()
expr_stmt|;
else|#
directive|else
name|readonly_data_section
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* Write the assembler code to define one.  */
name|align
operator|=
name|floor_log2
argument_list|(
name|FUNCTION_BOUNDARY
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|align
operator|>
literal|0
condition|)
name|ASM_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
name|align
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|asm_out_file
argument_list|,
literal|"LTRAMP"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TRAMPOLINE_TEMPLATE
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
comment|/* Record the rtl to refer to it.  */
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|label
argument_list|,
literal|"LTRAMP"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_copy0
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
name|label
argument_list|,
name|strlen
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Assemble the integer constant X into an object of SIZE bytes.    X must be either a CONST_INT or CONST_DOUBLE.     Return 1 if we were able to output the constant, otherwise 0.  If FORCE is    non-zero, abort if we can't output the constant.  */
end_comment

begin_function
name|int
name|assemble_integer
parameter_list|(
name|x
parameter_list|,
name|size
parameter_list|,
name|force
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|force
decl_stmt|;
block|{
comment|/* First try to use the standard 1, 2, 4, 8, and 16 byte      ASM_OUTPUT... macros. */
switch|switch
condition|(
name|size
condition|)
block|{
ifdef|#
directive|ifdef
name|ASM_OUTPUT_CHAR
case|case
literal|1
case|:
name|ASM_OUTPUT_CHAR
argument_list|(
name|asm_out_file
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ASM_OUTPUT_SHORT
case|case
literal|2
case|:
name|ASM_OUTPUT_SHORT
argument_list|(
name|asm_out_file
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ASM_OUTPUT_INT
case|case
literal|4
case|:
name|ASM_OUTPUT_INT
argument_list|(
name|asm_out_file
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ASM_OUTPUT_DOUBLE_INT
case|case
literal|8
case|:
name|ASM_OUTPUT_DOUBLE_INT
argument_list|(
name|asm_out_file
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ASM_OUTPUT_QUADRUPLE_INT
case|case
literal|16
case|:
name|ASM_OUTPUT_QUADRUPLE_INT
argument_list|(
name|asm_out_file
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
endif|#
directive|endif
block|}
comment|/* If we couldn't do it that way, there are two other possibilities: First,      if the machine can output an explicit byte and this is a 1 byte constant,      we can use ASM_OUTPUT_BYTE.  */
ifdef|#
directive|ifdef
name|ASM_OUTPUT_BYTE
if|if
condition|(
name|size
operator|==
literal|1
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|ASM_OUTPUT_BYTE
argument_list|(
name|asm_out_file
argument_list|,
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
endif|#
directive|endif
comment|/* Finally, if SIZE is larger than a single word, try to output the constant      one word at a time.  */
if|if
condition|(
name|size
operator|>
name|UNITS_PER_WORD
condition|)
block|{
name|int
name|i
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|mode_for_size
argument_list|(
name|size
operator|*
name|BITS_PER_UNIT
argument_list|,
name|MODE_INT
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|word
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
operator|/
name|UNITS_PER_WORD
condition|;
name|i
operator|++
control|)
block|{
name|word
operator|=
name|operand_subword
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
literal|0
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|word
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|!
name|assemble_integer
argument_list|(
name|word
argument_list|,
name|UNITS_PER_WORD
argument_list|,
literal|0
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|size
operator|/
name|UNITS_PER_WORD
condition|)
return|return
literal|1
return|;
comment|/* If we output at least one word and then could not finish, 	 there is no valid way to continue.  */
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|force
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Assemble the floating-point constant D into an object of size MODE.  */
end_comment

begin_function
name|void
name|assemble_real
parameter_list|(
name|d
parameter_list|,
name|mode
parameter_list|)
name|REAL_VALUE_TYPE
name|d
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|jmp_buf
name|output_constant_handler
decl_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|output_constant_handler
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"floating point trap outputting a constant"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|REAL_IS_NOT_DOUBLE
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|d
argument_list|,
sizeof|sizeof
name|d
argument_list|)
expr_stmt|;
name|d
operator|=
name|dconst0
expr_stmt|;
else|#
directive|else
name|d
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
name|set_float_handler
argument_list|(
name|output_constant_handler
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
ifdef|#
directive|ifdef
name|ASM_OUTPUT_BYTE_FLOAT
case|case
name|QFmode
case|:
name|ASM_OUTPUT_BYTE_FLOAT
argument_list|(
name|asm_out_file
argument_list|,
name|d
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ASM_OUTPUT_SHORT_FLOAT
case|case
name|HFmode
case|:
name|ASM_OUTPUT_SHORT_FLOAT
argument_list|(
name|asm_out_file
argument_list|,
name|d
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ASM_OUTPUT_THREE_QUARTER_FLOAT
case|case
name|TQFmode
case|:
name|ASM_OUTPUT_THREE_QUARTER_FLOAT
argument_list|(
name|asm_out_file
argument_list|,
name|d
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ASM_OUTPUT_FLOAT
case|case
name|SFmode
case|:
name|ASM_OUTPUT_FLOAT
argument_list|(
name|asm_out_file
argument_list|,
name|d
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ASM_OUTPUT_DOUBLE
case|case
name|DFmode
case|:
name|ASM_OUTPUT_DOUBLE
argument_list|(
name|asm_out_file
argument_list|,
name|d
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ASM_OUTPUT_LONG_DOUBLE
case|case
name|XFmode
case|:
case|case
name|TFmode
case|:
name|ASM_OUTPUT_LONG_DOUBLE
argument_list|(
name|asm_out_file
argument_list|,
name|d
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|set_float_handler
argument_list|(
name|NULL_PTR
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Here we combine duplicate floating constants to make    CONST_DOUBLE rtx's, and force those out to memory when necessary.  */
end_comment

begin_comment
comment|/* Chain of all CONST_DOUBLE rtx's constructed for the current function.    They are chained through the CONST_DOUBLE_CHAIN.    A CONST_DOUBLE rtx has CONST_DOUBLE_MEM != cc0_rtx iff it is on this chain.    In that case, CONST_DOUBLE_MEM is either a MEM,    or const0_rtx if no MEM has been made for this CONST_DOUBLE yet.     (CONST_DOUBLE_MEM is used only for top-level functions.    See force_const_mem for explanation.)  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|const_double_chain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return a CONST_DOUBLE or CONST_INT for a value specified as a pair of ints.    For an integer, I0 is the low-order word and I1 is the high-order word.    For a real number, I0 is the word with the low address    and I1 is the word with the high address.  */
end_comment

begin_function
name|rtx
name|immed_double_const
parameter_list|(
name|i0
parameter_list|,
name|i1
parameter_list|,
name|mode
parameter_list|)
name|HOST_WIDE_INT
name|i0
decl_stmt|,
name|i1
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
specifier|register
name|rtx
name|r
decl_stmt|;
name|int
name|in_current_obstack
decl_stmt|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|||
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_PARTIAL_INT
condition|)
block|{
comment|/* We clear out all bits that don't belong in MODE, unless they and our 	 sign bit are all one.  So we get either a reasonable negative value 	 or a reasonable unsigned value for this mode.  */
name|int
name|width
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
if|if
condition|(
name|width
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
operator|(
name|i0
operator|&
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
operator|)
operator|!=
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
operator|)
condition|)
name|i0
operator|&=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|width
operator|)
operator|-
literal|1
operator|,
name|i1
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|width
operator|==
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|!
operator|(
name|i1
operator|==
operator|~
literal|0
operator|&&
name|i0
operator|<
literal|0
operator|)
condition|)
name|i1
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|width
operator|>
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
condition|)
comment|/* We cannot represent this value as a constant.  */
name|abort
argument_list|()
expr_stmt|;
comment|/* If this would be an entire word for the target, but is not for 	 the host, then sign-extend on the host so that the number will look 	 the same way on the host that it would on the target.  	 For example, when building a 64 bit alpha hosted 32 bit sparc 	 targeted compiler, then we want the 32 bit unsigned value -1 to be 	 represented as a 64 bit value -1, and not as 0x00000000ffffffff. 	 The later confuses the sparc backend.  */
if|if
condition|(
name|BITS_PER_WORD
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|BITS_PER_WORD
operator|==
name|width
operator|&&
operator|(
name|i0
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
operator|)
condition|)
name|i0
operator||=
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
name|width
operator|)
expr_stmt|;
comment|/* If MODE fits within HOST_BITS_PER_WIDE_INT, always use a CONST_INT.  	 ??? Strictly speaking, this is wrong if we create a CONST_INT 	 for a large unsigned constant with the size of MODE being 	 HOST_BITS_PER_WIDE_INT and later try to interpret that constant in a 	 wider mode.  In that case we will mis-interpret it as a negative 	 number.  	 Unfortunately, the only alternative is to make a CONST_DOUBLE 	 for any constant in any mode if it is an unsigned constant larger 	 than the maximum signed integer in an int on the host.  However, 	 doing this will break everyone that always expects to see a CONST_INT 	 for SImode and smaller.  	 We have always been making CONST_INTs in this case, so nothing new 	 is being broken.  */
if|if
condition|(
name|width
operator|<=
name|HOST_BITS_PER_WIDE_INT
condition|)
name|i1
operator|=
operator|(
name|i0
operator|<
literal|0
operator|)
condition|?
operator|~
literal|0
else|:
literal|0
expr_stmt|;
comment|/* If this integer fits in one word, return a CONST_INT.  */
if|if
condition|(
operator|(
name|i1
operator|==
literal|0
operator|&&
name|i0
operator|>=
literal|0
operator|)
operator|||
operator|(
name|i1
operator|==
operator|~
literal|0
operator|&&
name|i0
operator|<
literal|0
operator|)
condition|)
return|return
name|GEN_INT
argument_list|(
name|i0
argument_list|)
return|;
comment|/* We use VOIDmode for integers.  */
name|mode
operator|=
name|VOIDmode
expr_stmt|;
block|}
comment|/* Search the chain for an existing CONST_DOUBLE with the right value.      If one is found, return it.  */
for|for
control|(
name|r
operator|=
name|const_double_chain
init|;
name|r
condition|;
name|r
operator|=
name|CONST_DOUBLE_CHAIN
argument_list|(
name|r
argument_list|)
control|)
if|if
condition|(
name|CONST_DOUBLE_LOW
argument_list|(
name|r
argument_list|)
operator|==
name|i0
operator|&&
name|CONST_DOUBLE_HIGH
argument_list|(
name|r
argument_list|)
operator|==
name|i1
operator|&&
name|GET_MODE
argument_list|(
name|r
argument_list|)
operator|==
name|mode
condition|)
return|return
name|r
return|;
comment|/* No; make a new one and add it to the chain.       We may be called by an optimizer which may be discarding any memory      allocated during its processing (such as combine and loop).  However,      we will be leaving this constant on the chain, so we cannot tolerate      freed memory.  So switch to saveable_obstack for this allocation      and then switch back if we were in current_obstack.  */
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|rtl_in_saveable_obstack
argument_list|()
expr_stmt|;
name|r
operator|=
name|gen_rtx
argument_list|(
name|CONST_DOUBLE
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|,
name|i0
argument_list|,
name|i1
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
comment|/* Don't touch const_double_chain in nested function; see force_const_mem.      Also, don't touch it if not inside any function.  */
if|if
condition|(
name|outer_function_chain
operator|==
literal|0
operator|&&
name|current_function_decl
operator|!=
literal|0
condition|)
block|{
name|CONST_DOUBLE_CHAIN
argument_list|(
name|r
argument_list|)
operator|=
name|const_double_chain
expr_stmt|;
name|const_double_chain
operator|=
name|r
expr_stmt|;
block|}
comment|/* Store const0_rtx in mem-slot since this CONST_DOUBLE is on the chain.      Actual use of mem-slot is only through force_const_mem.  */
name|CONST_DOUBLE_MEM
argument_list|(
name|r
argument_list|)
operator|=
name|const0_rtx
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Return a CONST_DOUBLE for a specified `double' value    and machine mode.  */
end_comment

begin_function
name|rtx
name|immed_real_const_1
parameter_list|(
name|d
parameter_list|,
name|mode
parameter_list|)
name|REAL_VALUE_TYPE
name|d
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|union
name|real_extract
name|u
decl_stmt|;
specifier|register
name|rtx
name|r
decl_stmt|;
name|int
name|in_current_obstack
decl_stmt|;
comment|/* Get the desired `double' value as a sequence of ints      since that is how they are stored in a CONST_DOUBLE.  */
name|u
operator|.
name|d
operator|=
name|d
expr_stmt|;
comment|/* Detect special cases.  */
comment|/* Avoid REAL_VALUES_EQUAL here in order to distinguish minus zero.  */
if|if
condition|(
operator|!
name|bcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|dconst0
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|d
argument_list|,
sizeof|sizeof
name|d
argument_list|)
condition|)
return|return
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
return|;
comment|/* Check for NaN first, because some ports (specifically the i386) do not      emit correct ieee-fp code by default, and thus will generate a core      dump here if we pass a NaN to REAL_VALUES_EQUAL and if REAL_VALUES_EQUAL      does a floating point comparison.  */
elseif|else
if|if
condition|(
operator|!
name|REAL_VALUE_ISNAN
argument_list|(
name|d
argument_list|)
operator|&&
name|REAL_VALUES_EQUAL
argument_list|(
name|dconst1
argument_list|,
name|d
argument_list|)
condition|)
return|return
name|CONST1_RTX
argument_list|(
name|mode
argument_list|)
return|;
if|if
condition|(
sizeof|sizeof
name|u
operator|==
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|HOST_WIDE_INT
argument_list|)
condition|)
return|return
name|immed_double_const
argument_list|(
name|u
operator|.
name|i
index|[
literal|0
index|]
argument_list|,
name|u
operator|.
name|i
index|[
literal|1
index|]
argument_list|,
name|mode
argument_list|)
return|;
comment|/* The rest of this function handles the case where      a float value requires more than 2 ints of space.      It will be deleted as dead code on machines that don't need it.  */
comment|/* Search the chain for an existing CONST_DOUBLE with the right value.      If one is found, return it.  */
for|for
control|(
name|r
operator|=
name|const_double_chain
init|;
name|r
condition|;
name|r
operator|=
name|CONST_DOUBLE_CHAIN
argument_list|(
name|r
argument_list|)
control|)
if|if
condition|(
operator|!
name|bcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|CONST_DOUBLE_LOW
argument_list|(
name|r
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|u
argument_list|,
sizeof|sizeof
name|u
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|r
argument_list|)
operator|==
name|mode
condition|)
return|return
name|r
return|;
comment|/* No; make a new one and add it to the chain.       We may be called by an optimizer which may be discarding any memory      allocated during its processing (such as combine and loop).  However,      we will be leaving this constant on the chain, so we cannot tolerate      freed memory.  So switch to saveable_obstack for this allocation      and then switch back if we were in current_obstack.  */
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|rtl_in_saveable_obstack
argument_list|()
expr_stmt|;
name|r
operator|=
name|rtx_alloc
argument_list|(
name|CONST_DOUBLE
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|r
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|u
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|CONST_DOUBLE_LOW
argument_list|(
name|r
argument_list|)
argument_list|,
sizeof|sizeof
name|u
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
comment|/* Don't touch const_double_chain in nested function; see force_const_mem.      Also, don't touch it if not inside any function.  */
if|if
condition|(
name|outer_function_chain
operator|==
literal|0
operator|&&
name|current_function_decl
operator|!=
literal|0
condition|)
block|{
name|CONST_DOUBLE_CHAIN
argument_list|(
name|r
argument_list|)
operator|=
name|const_double_chain
expr_stmt|;
name|const_double_chain
operator|=
name|r
expr_stmt|;
block|}
comment|/* Store const0_rtx in CONST_DOUBLE_MEM since this CONST_DOUBLE is on the      chain, but has not been allocated memory.  Actual use of CONST_DOUBLE_MEM      is only through force_const_mem.  */
name|CONST_DOUBLE_MEM
argument_list|(
name|r
argument_list|)
operator|=
name|const0_rtx
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Return a CONST_DOUBLE rtx for a value specified by EXP,    which must be a REAL_CST tree node.  */
end_comment

begin_function
name|rtx
name|immed_real_const
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
return|return
name|immed_real_const_1
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|exp
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* At the end of a function, forget the memory-constants    previously made for CONST_DOUBLEs.  Mark them as not on real_constant_chain.    Also clear out real_constant_chain and clear out all the chain-pointers.  */
end_comment

begin_function
name|void
name|clear_const_double_mem
parameter_list|()
block|{
specifier|register
name|rtx
name|r
decl_stmt|,
name|next
decl_stmt|;
comment|/* Don't touch CONST_DOUBLE_MEM for nested functions.      See force_const_mem for explanation.  */
if|if
condition|(
name|outer_function_chain
operator|!=
literal|0
condition|)
return|return;
for|for
control|(
name|r
operator|=
name|const_double_chain
init|;
name|r
condition|;
name|r
operator|=
name|next
control|)
block|{
name|next
operator|=
name|CONST_DOUBLE_CHAIN
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|CONST_DOUBLE_CHAIN
argument_list|(
name|r
argument_list|)
operator|=
literal|0
expr_stmt|;
name|CONST_DOUBLE_MEM
argument_list|(
name|r
argument_list|)
operator|=
name|cc0_rtx
expr_stmt|;
block|}
name|const_double_chain
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given an expression EXP with a constant value,    reduce it to the sum of an assembler symbol and an integer.    Store them both in the structure *VALUE.    Abort if EXP does not reduce.  */
end_comment

begin_struct
struct|struct
name|addr_const
block|{
name|rtx
name|base
decl_stmt|;
name|HOST_WIDE_INT
name|offset
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|decode_addr_const
parameter_list|(
name|exp
parameter_list|,
name|value
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|struct
name|addr_const
modifier|*
name|value
decl_stmt|;
block|{
specifier|register
name|tree
name|target
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|register
name|int
name|offset
init|=
literal|0
decl_stmt|;
specifier|register
name|rtx
name|x
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|DECL_FIELD_BITPOS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|target
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|)
condition|)
block|{
name|offset
operator|+=
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_FIELD_BITPOS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|target
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
expr_stmt|;
name|target
operator|=
name|TREE_OPERAND
argument_list|(
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|ARRAY_REF
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|target
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|target
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|abort
argument_list|()
expr_stmt|;
name|offset
operator|+=
operator|(
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|target
argument_list|)
argument_list|)
argument_list|)
operator|*
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|target
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|/
name|BITS_PER_UNIT
operator|)
expr_stmt|;
name|target
operator|=
name|TREE_OPERAND
argument_list|(
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
block|}
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|target
argument_list|)
condition|)
block|{
case|case
name|VAR_DECL
case|:
case|case
name|FUNCTION_DECL
case|:
name|x
operator|=
name|DECL_RTL
argument_list|(
name|target
argument_list|)
expr_stmt|;
break|break;
case|case
name|LABEL_DECL
case|:
if|if
condition|(
name|output_bytecode
condition|)
comment|/* FIXME: this may not be correct, check it */
name|x
operator|=
name|bc_gen_rtx
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|target
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|bc_label
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
else|else
name|x
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|FUNCTION_MODE
argument_list|,
name|gen_rtx
argument_list|(
name|LABEL_REF
argument_list|,
name|VOIDmode
argument_list|,
name|label_rtx
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|REAL_CST
case|:
case|case
name|STRING_CST
case|:
case|case
name|COMPLEX_CST
case|:
case|case
name|CONSTRUCTOR
case|:
name|x
operator|=
name|TREE_CST_RTL
argument_list|(
name|target
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|output_bytecode
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
condition|)
name|abort
argument_list|()
expr_stmt|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|value
operator|->
name|base
operator|=
name|x
expr_stmt|;
name|value
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Uniquize all constants that appear in memory.    Each constant in memory thus far output is recorded    in `const_hash_table' with a `struct constant_descriptor'    that contains a polish representation of the value of    the constant.     We cannot store the trees in the hash table    because the trees may be temporary.  */
end_comment

begin_struct
struct|struct
name|constant_descriptor
block|{
name|struct
name|constant_descriptor
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|label
decl_stmt|;
name|char
name|contents
index|[
literal|1
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|HASHBITS
value|30
end_define

begin_define
define|#
directive|define
name|MAX_HASH_TABLE
value|1009
end_define

begin_decl_stmt
specifier|static
name|struct
name|constant_descriptor
modifier|*
name|const_hash_table
index|[
name|MAX_HASH_TABLE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Compute a hash code for a constant expression.  */
end_comment

begin_function
name|int
name|const_hash
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|,
name|hi
decl_stmt|,
name|i
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|INTEGER_CST
condition|)
block|{
name|p
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|TREE_INT_CST_LOW
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|len
operator|=
literal|2
operator|*
sizeof|sizeof
name|TREE_INT_CST_LOW
operator|(
name|exp
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|REAL_CST
condition|)
block|{
name|p
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|TREE_REAL_CST
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|len
operator|=
sizeof|sizeof
name|TREE_REAL_CST
operator|(
name|exp
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|STRING_CST
condition|)
name|p
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|exp
argument_list|)
operator|,
name|len
operator|=
name|TREE_STRING_LENGTH
argument_list|(
name|exp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|COMPLEX_CST
condition|)
return|return
name|const_hash
argument_list|(
name|TREE_REALPART
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|*
literal|5
operator|+
name|const_hash
argument_list|(
name|TREE_IMAGPART
argument_list|(
name|exp
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|code
operator|==
name|CONSTRUCTOR
condition|)
block|{
specifier|register
name|tree
name|link
decl_stmt|;
comment|/* For record type, include the type in the hashing. 	 We do not do so for array types 	 because (1) the sizes of the elements are sufficient 	 and (2) distinct array types can have the same constructor. 	 Instead, we include the array size because the constructor could 	 be shorter.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
name|hi
operator|=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
operator|&
operator|(
operator|(
literal|1
operator|<<
name|HASHBITS
operator|)
operator|-
literal|1
operator|)
operator|)
operator|%
name|MAX_HASH_TABLE
expr_stmt|;
else|else
name|hi
operator|=
operator|(
operator|(
literal|5
operator|+
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
name|HASHBITS
operator|)
operator|-
literal|1
operator|)
operator|)
operator|%
name|MAX_HASH_TABLE
expr_stmt|;
for|for
control|(
name|link
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
condition|)
name|hi
operator|=
operator|(
name|hi
operator|*
literal|603
operator|+
name|const_hash
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
operator|)
operator|%
name|MAX_HASH_TABLE
expr_stmt|;
return|return
name|hi
return|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|ADDR_EXPR
condition|)
block|{
name|struct
name|addr_const
name|value
decl_stmt|;
name|decode_addr_const
argument_list|(
name|exp
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
operator|.
name|base
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
block|{
comment|/* Don't hash the address of the SYMBOL_REF; 	     only use the offset and the symbol name.  */
name|hi
operator|=
name|value
operator|.
name|offset
expr_stmt|;
name|p
operator|=
name|XSTR
argument_list|(
name|value
operator|.
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|p
index|[
name|i
index|]
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
name|hi
operator|=
operator|(
operator|(
name|hi
operator|*
literal|613
operator|)
operator|+
call|(
name|unsigned
call|)
argument_list|(
name|p
index|[
name|i
index|]
argument_list|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
operator|.
name|base
argument_list|)
operator|==
name|LABEL_REF
condition|)
name|hi
operator|=
name|value
operator|.
name|offset
operator|+
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|value
operator|.
name|base
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|*
literal|13
expr_stmt|;
name|hi
operator|&=
operator|(
literal|1
operator|<<
name|HASHBITS
operator|)
operator|-
literal|1
expr_stmt|;
name|hi
operator|%=
name|MAX_HASH_TABLE
expr_stmt|;
return|return
name|hi
return|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|PLUS_EXPR
operator|||
name|code
operator|==
name|MINUS_EXPR
condition|)
return|return
name|const_hash
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|*
literal|9
operator|+
name|const_hash
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|code
operator|==
name|NOP_EXPR
operator|||
name|code
operator|==
name|CONVERT_EXPR
condition|)
return|return
name|const_hash
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|*
literal|7
operator|+
literal|2
return|;
comment|/* Compute hashing function */
name|hi
operator|=
name|len
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|hi
operator|=
operator|(
operator|(
name|hi
operator|*
literal|613
operator|)
operator|+
call|(
name|unsigned
call|)
argument_list|(
name|p
index|[
name|i
index|]
argument_list|)
operator|)
expr_stmt|;
name|hi
operator|&=
operator|(
literal|1
operator|<<
name|HASHBITS
operator|)
operator|-
literal|1
expr_stmt|;
name|hi
operator|%=
name|MAX_HASH_TABLE
expr_stmt|;
return|return
name|hi
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compare a constant expression EXP with a constant-descriptor DESC.    Return 1 if DESC describes a constant with the same value as EXP.  */
end_comment

begin_function
specifier|static
name|int
name|compare_constant
parameter_list|(
name|exp
parameter_list|,
name|desc
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|struct
name|constant_descriptor
modifier|*
name|desc
decl_stmt|;
block|{
return|return
literal|0
operator|!=
name|compare_constant_1
argument_list|(
name|exp
argument_list|,
name|desc
operator|->
name|contents
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Compare constant expression EXP with a substring P of a constant descriptor.    If they match, return a pointer to the end of the substring matched.    If they do not match, return 0.     Since descriptors are written in polish prefix notation,    this function can be used recursively to test one operand of EXP    against a subdescriptor, and if it succeeds it returns the    address of the subdescriptor for the next operand.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|compare_constant_1
parameter_list|(
name|exp
parameter_list|,
name|p
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|strp
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|!=
operator|(
expr|enum
name|tree_code
operator|)
operator|*
name|p
operator|++
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|code
operator|==
name|INTEGER_CST
condition|)
block|{
comment|/* Integer constants are the same only if the same width of type.  */
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|strp
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|TREE_INT_CST_LOW
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|len
operator|=
literal|2
operator|*
sizeof|sizeof
name|TREE_INT_CST_LOW
operator|(
name|exp
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|REAL_CST
condition|)
block|{
comment|/* Real constants are the same only if the same width of type.  */
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|strp
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|TREE_REAL_CST
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|len
operator|=
sizeof|sizeof
name|TREE_REAL_CST
operator|(
name|exp
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|STRING_CST
condition|)
block|{
if|if
condition|(
name|flag_writable_strings
condition|)
return|return
literal|0
return|;
name|strp
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|len
operator|=
name|TREE_STRING_LENGTH
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|TREE_STRING_LENGTH
argument_list|(
name|exp
argument_list|)
argument_list|,
name|p
argument_list|,
sizeof|sizeof
name|TREE_STRING_LENGTH
operator|(
name|exp
operator|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|p
operator|+=
sizeof|sizeof
name|TREE_STRING_LENGTH
operator|(
name|exp
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|COMPLEX_CST
condition|)
block|{
name|p
operator|=
name|compare_constant_1
argument_list|(
name|TREE_REALPART
argument_list|(
name|exp
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|p
operator|=
name|compare_constant_1
argument_list|(
name|TREE_IMAGPART
argument_list|(
name|exp
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|CONSTRUCTOR
condition|)
block|{
specifier|register
name|tree
name|link
decl_stmt|;
name|int
name|length
init|=
name|list_length
argument_list|(
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|length
argument_list|,
name|p
argument_list|,
sizeof|sizeof
name|length
argument_list|)
condition|)
return|return
literal|0
return|;
name|p
operator|+=
sizeof|sizeof
name|length
expr_stmt|;
comment|/* For record constructors, insist that the types match. 	 For arrays, just verify both constructors are for arrays.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
else|else
name|type
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|type
argument_list|,
name|p
argument_list|,
sizeof|sizeof
name|type
argument_list|)
condition|)
return|return
literal|0
return|;
name|p
operator|+=
sizeof|sizeof
name|type
expr_stmt|;
comment|/* For arrays, insist that the size in bytes match.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|int
name|size
init|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|size
argument_list|,
name|p
argument_list|,
sizeof|sizeof
name|size
argument_list|)
condition|)
return|return
literal|0
return|;
name|p
operator|+=
sizeof|sizeof
name|size
expr_stmt|;
block|}
for|for
control|(
name|link
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
name|compare_constant_1
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|,
name|p
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
else|else
block|{
name|tree
name|zero
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|zero
argument_list|,
name|p
argument_list|,
sizeof|sizeof
name|zero
argument_list|)
condition|)
return|return
literal|0
return|;
name|p
operator|+=
sizeof|sizeof
name|zero
expr_stmt|;
block|}
block|}
return|return
name|p
return|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|ADDR_EXPR
condition|)
block|{
name|struct
name|addr_const
name|value
decl_stmt|;
name|decode_addr_const
argument_list|(
name|exp
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
name|strp
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|value
operator|.
name|offset
expr_stmt|;
name|len
operator|=
sizeof|sizeof
name|value
operator|.
name|offset
expr_stmt|;
comment|/* Compare the offset.  */
while|while
condition|(
operator|--
name|len
operator|>=
literal|0
condition|)
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
operator|*
name|strp
operator|++
condition|)
return|return
literal|0
return|;
comment|/* Compare symbol name.  */
name|strp
operator|=
name|XSTR
argument_list|(
name|value
operator|.
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|strp
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|PLUS_EXPR
operator|||
name|code
operator|==
name|MINUS_EXPR
condition|)
block|{
name|p
operator|=
name|compare_constant_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|p
operator|=
name|compare_constant_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|NOP_EXPR
operator|||
name|code
operator|==
name|CONVERT_EXPR
condition|)
block|{
name|p
operator|=
name|compare_constant_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
comment|/* Compare constant contents.  */
while|while
condition|(
operator|--
name|len
operator|>=
literal|0
condition|)
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
operator|*
name|strp
operator|++
condition|)
return|return
literal|0
return|;
return|return
name|p
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Construct a constant descriptor for the expression EXP.    It is up to the caller to enter the descriptor in the hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|constant_descriptor
modifier|*
name|record_constant
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
name|struct
name|constant_descriptor
modifier|*
name|next
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|label
init|=
literal|0
decl_stmt|;
comment|/* Make a struct constant_descriptor.  The first two pointers will      be filled in later.  Here we just leave space for them.  */
name|obstack_grow
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|next
argument_list|,
sizeof|sizeof
name|next
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|label
argument_list|,
sizeof|sizeof
name|label
argument_list|)
expr_stmt|;
name|record_constant_1
argument_list|(
name|exp
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|constant_descriptor
operator|*
operator|)
name|obstack_finish
argument_list|(
operator|&
name|permanent_obstack
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Add a description of constant expression EXP    to the object growing in `permanent_obstack'.    No need to return its address; the caller will get that    from the obstack when the object is complete.  */
end_comment

begin_function
specifier|static
name|void
name|record_constant_1
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|strp
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|INTEGER_CST
condition|)
block|{
name|obstack_1grow
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|strp
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|TREE_INT_CST_LOW
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|len
operator|=
literal|2
operator|*
sizeof|sizeof
name|TREE_INT_CST_LOW
operator|(
name|exp
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|REAL_CST
condition|)
block|{
name|obstack_1grow
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|strp
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|TREE_REAL_CST
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|len
operator|=
sizeof|sizeof
name|TREE_REAL_CST
operator|(
name|exp
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|STRING_CST
condition|)
block|{
if|if
condition|(
name|flag_writable_strings
condition|)
return|return;
name|strp
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|len
operator|=
name|TREE_STRING_LENGTH
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|TREE_STRING_LENGTH
argument_list|(
name|exp
argument_list|)
argument_list|,
sizeof|sizeof
name|TREE_STRING_LENGTH
operator|(
name|exp
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|COMPLEX_CST
condition|)
block|{
name|record_constant_1
argument_list|(
name|TREE_REALPART
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
name|record_constant_1
argument_list|(
name|TREE_IMAGPART
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|CONSTRUCTOR
condition|)
block|{
specifier|register
name|tree
name|link
decl_stmt|;
name|int
name|length
init|=
name|list_length
argument_list|(
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|length
argument_list|,
sizeof|sizeof
name|length
argument_list|)
expr_stmt|;
comment|/* For record constructors, insist that the types match. 	 For arrays, just verify both constructors are for arrays.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
else|else
name|type
operator|=
literal|0
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|type
argument_list|,
sizeof|sizeof
name|type
argument_list|)
expr_stmt|;
comment|/* For arrays, insist that the size in bytes match.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|int
name|size
init|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|size
argument_list|,
sizeof|sizeof
name|size
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|link
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
condition|)
name|record_constant_1
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|zero
init|=
literal|0
decl_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|zero
argument_list|,
sizeof|sizeof
name|zero
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|ADDR_EXPR
condition|)
block|{
name|struct
name|addr_const
name|value
decl_stmt|;
name|decode_addr_const
argument_list|(
name|exp
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
comment|/* Record the offset.  */
name|obstack_grow
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|value
operator|.
name|offset
argument_list|,
sizeof|sizeof
name|value
operator|.
name|offset
argument_list|)
expr_stmt|;
comment|/* Record the symbol name.  */
name|obstack_grow
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
name|XSTR
argument_list|(
name|value
operator|.
name|base
argument_list|,
literal|0
argument_list|)
argument_list|,
name|strlen
argument_list|(
name|XSTR
argument_list|(
name|value
operator|.
name|base
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|PLUS_EXPR
operator|||
name|code
operator|==
name|MINUS_EXPR
condition|)
block|{
name|record_constant_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|record_constant_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|NOP_EXPR
operator|||
name|code
operator|==
name|CONVERT_EXPR
condition|)
block|{
name|record_constant_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Record constant contents.  */
name|obstack_grow
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
name|strp
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Record a list of constant expressions that were passed to    output_constant_def but that could not be output right away.  */
end_comment

begin_struct
struct|struct
name|deferred_constant
block|{
name|struct
name|deferred_constant
modifier|*
name|next
decl_stmt|;
name|tree
name|exp
decl_stmt|;
name|int
name|reloc
decl_stmt|;
name|int
name|labelno
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|deferred_constant
modifier|*
name|deferred_constants
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means defer output of addressed subconstants    (i.e., those for which output_constant_def is called.)  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|defer_addressed_constants_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Start deferring output of subconstants.  */
end_comment

begin_function
name|void
name|defer_addressed_constants
parameter_list|()
block|{
name|defer_addressed_constants_flag
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Stop deferring output of subconstants,    and output now all those that have been deferred.  */
end_comment

begin_function
name|void
name|output_deferred_addressed_constants
parameter_list|()
block|{
name|struct
name|deferred_constant
modifier|*
name|p
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|defer_addressed_constants_flag
operator|--
expr_stmt|;
if|if
condition|(
name|defer_addressed_constants_flag
operator|>
literal|0
condition|)
return|return;
for|for
control|(
name|p
operator|=
name|deferred_constants
init|;
name|p
condition|;
name|p
operator|=
name|next
control|)
block|{
name|output_constant_def_contents
argument_list|(
name|p
operator|->
name|exp
argument_list|,
name|p
operator|->
name|reloc
argument_list|,
name|p
operator|->
name|labelno
argument_list|)
expr_stmt|;
name|next
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|deferred_constants
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make a copy of the whole tree structure for a constant.    This handles the same types of nodes that compare_constant    and record_constant handle.  */
end_comment

begin_function
specifier|static
name|tree
name|copy_constant
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
case|case
name|INTEGER_CST
case|:
case|case
name|REAL_CST
case|:
case|case
name|STRING_CST
case|:
case|case
name|ADDR_EXPR
case|:
comment|/* For ADDR_EXPR, we do not want to copy the decl 	 whose address is requested.  */
return|return
name|copy_node
argument_list|(
name|exp
argument_list|)
return|;
case|case
name|COMPLEX_CST
case|:
return|return
name|build_complex
argument_list|(
name|copy_constant
argument_list|(
name|TREE_REALPART
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|copy_constant
argument_list|(
name|TREE_IMAGPART
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
return|return
name|build
argument_list|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|copy_constant
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|copy_constant
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
return|return
name|build1
argument_list|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|copy_constant
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|CONSTRUCTOR
case|:
block|{
name|tree
name|copy
init|=
name|copy_node
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|tree
name|list
init|=
name|copy_list
argument_list|(
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|tail
decl_stmt|;
name|CONSTRUCTOR_ELTS
argument_list|(
name|copy
argument_list|)
operator|=
name|list
expr_stmt|;
for|for
control|(
name|tail
operator|=
name|list
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
control|)
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
operator|=
name|copy_constant
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|copy
return|;
block|}
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return an rtx representing a reference to constant data in memory    for the constant expression EXP.     If assembler code for such a constant has already been output,    return an rtx to refer to it.    Otherwise, output such a constant in memory (or defer it for later)    and generate an rtx for it.     The TREE_CST_RTL of EXP is set up to point to that rtx.    The const_hash_table records which constants already have label strings.  */
end_comment

begin_function
name|rtx
name|output_constant_def
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
specifier|register
name|int
name|hash
decl_stmt|;
specifier|register
name|struct
name|constant_descriptor
modifier|*
name|desc
decl_stmt|;
name|char
name|label
index|[
literal|256
index|]
decl_stmt|;
name|char
modifier|*
name|found
init|=
literal|0
decl_stmt|;
name|int
name|reloc
decl_stmt|;
specifier|register
name|rtx
name|def
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* No TREE_CST_RTL slot in these.  */
if|if
condition|(
name|TREE_CST_RTL
argument_list|(
name|exp
argument_list|)
condition|)
return|return
name|TREE_CST_RTL
argument_list|(
name|exp
argument_list|)
return|;
comment|/* Make sure any other constants whose addresses appear in EXP      are assigned label numbers.  */
name|reloc
operator|=
name|output_addressed_constants
argument_list|(
name|exp
argument_list|)
expr_stmt|;
comment|/* Compute hash code of EXP.  Search the descriptors for that hash code      to see if any of them describes EXP.  If yes, the descriptor records      the label number already assigned.  */
name|hash
operator|=
name|const_hash
argument_list|(
name|exp
argument_list|)
operator|%
name|MAX_HASH_TABLE
expr_stmt|;
for|for
control|(
name|desc
operator|=
name|const_hash_table
index|[
name|hash
index|]
init|;
name|desc
condition|;
name|desc
operator|=
name|desc
operator|->
name|next
control|)
if|if
condition|(
name|compare_constant
argument_list|(
name|exp
argument_list|,
name|desc
argument_list|)
condition|)
block|{
name|found
operator|=
name|desc
operator|->
name|label
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|found
operator|==
literal|0
condition|)
block|{
comment|/* No constant equal to EXP is known to have been output. 	 Make a constant descriptor to enter EXP in the hash table. 	 Assign the label number and record it in the descriptor for 	 future calls to this function to find.  */
comment|/* Create a string containing the label name, in LABEL.  */
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|label
argument_list|,
literal|"LC"
argument_list|,
name|const_labelno
argument_list|)
expr_stmt|;
name|desc
operator|=
name|record_constant
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|desc
operator|->
name|next
operator|=
name|const_hash_table
index|[
name|hash
index|]
expr_stmt|;
name|desc
operator|->
name|label
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_copy0
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
name|label
argument_list|,
name|strlen
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|const_hash_table
index|[
name|hash
index|]
operator|=
name|desc
expr_stmt|;
block|}
else|else
block|{
comment|/* Create a string containing the label name, in LABEL.  */
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|label
argument_list|,
literal|"LC"
argument_list|,
name|const_labelno
argument_list|)
expr_stmt|;
block|}
comment|/* We have a symbol name; construct the SYMBOL_REF and the MEM.  */
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
if|if
condition|(
name|TREE_PERMANENT
argument_list|(
name|exp
argument_list|)
condition|)
name|end_temporary_allocation
argument_list|()
expr_stmt|;
name|def
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
name|desc
operator|->
name|label
argument_list|)
expr_stmt|;
name|TREE_CST_RTL
argument_list|(
name|exp
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|def
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|TREE_CST_RTL
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|AGGREGATE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|)
name|MEM_IN_STRUCT_P
argument_list|(
name|TREE_CST_RTL
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
comment|/* Optionally set flags or add text to the name to record information      such as that it is a function name.  If the name is changed, the macro      ASM_OUTPUT_LABELREF will have to know how to strip this information.  */
ifdef|#
directive|ifdef
name|ENCODE_SECTION_INFO
name|ENCODE_SECTION_INFO
argument_list|(
name|exp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If this is the first time we've seen this particular constant,      output it (or defer its output for later).  */
if|if
condition|(
name|found
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|defer_addressed_constants_flag
condition|)
block|{
name|struct
name|deferred_constant
modifier|*
name|p
decl_stmt|;
name|p
operator|=
operator|(
expr|struct
name|deferred_constant
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|deferred_constant
argument_list|)
argument_list|)
expr_stmt|;
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|suspend_momentary
argument_list|()
expr_stmt|;
name|p
operator|->
name|exp
operator|=
name|copy_constant
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
name|p
operator|->
name|reloc
operator|=
name|reloc
expr_stmt|;
name|p
operator|->
name|labelno
operator|=
name|const_labelno
operator|++
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|deferred_constants
expr_stmt|;
name|deferred_constants
operator|=
name|p
expr_stmt|;
block|}
else|else
name|output_constant_def_contents
argument_list|(
name|exp
argument_list|,
name|reloc
argument_list|,
name|const_labelno
operator|++
argument_list|)
expr_stmt|;
block|}
return|return
name|TREE_CST_RTL
argument_list|(
name|exp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Now output assembler code to define the label for EXP,    and follow it with the data of EXP.  */
end_comment

begin_function
specifier|static
name|void
name|output_constant_def_contents
parameter_list|(
name|exp
parameter_list|,
name|reloc
parameter_list|,
name|labelno
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|int
name|reloc
decl_stmt|;
name|int
name|labelno
decl_stmt|;
block|{
name|int
name|align
decl_stmt|;
if|if
condition|(
name|IN_NAMED_SECTION
argument_list|(
name|exp
argument_list|)
condition|)
name|named_section
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|DECL_SECTION_NAME
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* First switch to text section, except for writable strings.  */
ifdef|#
directive|ifdef
name|SELECT_SECTION
name|SELECT_SECTION
argument_list|(
name|exp
argument_list|,
name|reloc
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|STRING_CST
operator|)
operator|&&
name|flag_writable_strings
operator|)
operator|||
operator|(
name|flag_pic
operator|&&
name|reloc
operator|)
condition|)
name|data_section
argument_list|()
expr_stmt|;
else|else
name|readonly_data_section
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Align the location counter as required by EXP's data type.  */
name|align
operator|=
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CONSTANT_ALIGNMENT
name|align
operator|=
name|CONSTANT_ALIGNMENT
argument_list|(
name|exp
argument_list|,
name|align
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|align
operator|>
name|BITS_PER_UNIT
condition|)
block|{
if|if
condition|(
operator|!
name|output_bytecode
condition|)
block|{
name|ASM_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
name|floor_log2
argument_list|(
name|align
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|BC_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
name|floor_log2
argument_list|(
name|align
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Output the label itself.  */
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|asm_out_file
argument_list|,
literal|"LC"
argument_list|,
name|labelno
argument_list|)
expr_stmt|;
comment|/* Output the value of EXP.  */
name|output_constant
argument_list|(
name|exp
argument_list|,
operator|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|STRING_CST
condition|?
name|TREE_STRING_LENGTH
argument_list|(
name|exp
argument_list|)
else|:
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Similar hash facility for making memory-constants    from constant rtl-expressions.  It is used on RISC machines    where immediate integer arguments and constant addresses are restricted    so that such constants must be stored in memory.     This pool of constants is reinitialized for each function    so each function gets its own constants-pool that comes right before it.     All structures allocated here are discarded when functions are saved for    inlining, so they do not need to be allocated permanently.  */
end_comment

begin_define
define|#
directive|define
name|MAX_RTX_HASH_TABLE
value|61
end_define

begin_decl_stmt
specifier|static
name|struct
name|constant_descriptor
modifier|*
modifier|*
name|const_rtx_hash_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Structure to represent sufficient information about a constant so that    it can be output when the constant pool is output, so that function    integration can be done, and to simplify handling on machines that reference    constant pool as base+displacement.  */
end_comment

begin_struct
struct|struct
name|pool_constant
block|{
name|struct
name|constant_descriptor
modifier|*
name|desc
decl_stmt|;
name|struct
name|pool_constant
modifier|*
name|next
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|constant
decl_stmt|;
name|int
name|labelno
decl_stmt|;
name|int
name|align
decl_stmt|;
name|int
name|offset
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Pointers to first and last constant in pool.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|pool_constant
modifier|*
name|first_pool
decl_stmt|,
modifier|*
name|last_pool
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current offset in constant pool (does not include any machine-specific    header.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pool_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Structure used to maintain hash table mapping symbols used to their    corresponding constants.  */
end_comment

begin_struct
struct|struct
name|pool_sym
block|{
name|char
modifier|*
name|label
decl_stmt|;
name|struct
name|pool_constant
modifier|*
name|pool
decl_stmt|;
name|struct
name|pool_sym
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|pool_sym
modifier|*
modifier|*
name|const_rtx_sym_hash_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Hash code for a SYMBOL_REF with CONSTANT_POOL_ADDRESS_P true.    The argument is XSTR (... , 0)  */
end_comment

begin_define
define|#
directive|define
name|SYMHASH
parameter_list|(
name|LABEL
parameter_list|)
define|\
value|((((HOST_WIDE_INT) (LABEL))& ((1<< HASHBITS) - 1))  % MAX_RTX_HASH_TABLE)
end_define

begin_escape
end_escape

begin_comment
comment|/* Initialize constant pool hashing for next function.  */
end_comment

begin_function
name|void
name|init_const_rtx_hash_table
parameter_list|()
block|{
name|const_rtx_hash_table
operator|=
operator|(
operator|(
expr|struct
name|constant_descriptor
operator|*
operator|*
operator|)
name|oballoc
argument_list|(
name|MAX_RTX_HASH_TABLE
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|constant_descriptor
operator|*
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|const_rtx_sym_hash_table
operator|=
operator|(
operator|(
expr|struct
name|pool_sym
operator|*
operator|*
operator|)
name|oballoc
argument_list|(
name|MAX_RTX_HASH_TABLE
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pool_sym
operator|*
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|const_rtx_hash_table
argument_list|,
name|MAX_RTX_HASH_TABLE
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|constant_descriptor
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|const_rtx_sym_hash_table
argument_list|,
name|MAX_RTX_HASH_TABLE
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pool_sym
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|first_pool
operator|=
name|last_pool
operator|=
literal|0
expr_stmt|;
name|pool_offset
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Save and restore it for a nested function.  */
end_comment

begin_function
name|void
name|save_varasm_status
parameter_list|(
name|p
parameter_list|)
name|struct
name|function
modifier|*
name|p
decl_stmt|;
block|{
name|p
operator|->
name|const_rtx_hash_table
operator|=
name|const_rtx_hash_table
expr_stmt|;
name|p
operator|->
name|const_rtx_sym_hash_table
operator|=
name|const_rtx_sym_hash_table
expr_stmt|;
name|p
operator|->
name|first_pool
operator|=
name|first_pool
expr_stmt|;
name|p
operator|->
name|last_pool
operator|=
name|last_pool
expr_stmt|;
name|p
operator|->
name|pool_offset
operator|=
name|pool_offset
expr_stmt|;
block|}
end_function

begin_function
name|void
name|restore_varasm_status
parameter_list|(
name|p
parameter_list|)
name|struct
name|function
modifier|*
name|p
decl_stmt|;
block|{
name|const_rtx_hash_table
operator|=
name|p
operator|->
name|const_rtx_hash_table
expr_stmt|;
name|const_rtx_sym_hash_table
operator|=
name|p
operator|->
name|const_rtx_sym_hash_table
expr_stmt|;
name|first_pool
operator|=
name|p
operator|->
name|first_pool
expr_stmt|;
name|last_pool
operator|=
name|p
operator|->
name|last_pool
expr_stmt|;
name|pool_offset
operator|=
name|p
operator|->
name|pool_offset
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_enum
enum|enum
name|kind
block|{
name|RTX_DOUBLE
block|,
name|RTX_INT
block|}
enum|;
end_enum

begin_struct
struct|struct
name|rtx_const
block|{
ifdef|#
directive|ifdef
name|ONLY_INT_FIELDS
name|unsigned
name|int
name|kind
range|:
literal|16
decl_stmt|;
name|unsigned
name|int
name|mode
range|:
literal|16
decl_stmt|;
else|#
directive|else
name|enum
name|kind
name|kind
range|:
literal|16
decl_stmt|;
name|enum
name|machine_mode
name|mode
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
union|union
block|{
name|union
name|real_extract
name|du
decl_stmt|;
name|struct
name|addr_const
name|addr
decl_stmt|;
block|}
name|un
union|;
block|}
struct|;
end_struct

begin_comment
comment|/* Express an rtx for a constant integer (perhaps symbolic)    as the sum of a symbol or label plus an explicit integer.    They are stored into VALUE.  */
end_comment

begin_function
specifier|static
name|void
name|decode_rtx_const
parameter_list|(
name|mode
parameter_list|,
name|x
parameter_list|,
name|value
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|struct
name|rtx_const
modifier|*
name|value
decl_stmt|;
block|{
comment|/* Clear the whole structure, including any gaps.  */
block|{
name|int
modifier|*
name|p
init|=
operator|(
name|int
operator|*
operator|)
name|value
decl_stmt|;
name|int
modifier|*
name|end
init|=
operator|(
name|int
operator|*
operator|)
operator|(
name|value
operator|+
literal|1
operator|)
decl_stmt|;
while|while
condition|(
name|p
operator|<
name|end
condition|)
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
block|}
name|value
operator|->
name|kind
operator|=
name|RTX_INT
expr_stmt|;
comment|/* Most usual kind. */
name|value
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|CONST_DOUBLE
case|:
name|value
operator|->
name|kind
operator|=
name|RTX_DOUBLE
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|VOIDmode
condition|)
name|value
operator|->
name|mode
operator|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|value
operator|->
name|un
operator|.
name|du
argument_list|,
sizeof|sizeof
name|value
operator|->
name|un
operator|.
name|du
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST_INT
case|:
name|value
operator|->
name|un
operator|.
name|addr
operator|.
name|offset
operator|=
name|INTVAL
argument_list|(
name|x
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|PC
case|:
name|value
operator|->
name|un
operator|.
name|addr
operator|.
name|base
operator|=
name|x
expr_stmt|;
break|break;
case|case
name|CONST
case|:
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|value
operator|->
name|un
operator|.
name|addr
operator|.
name|base
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|abort
argument_list|()
expr_stmt|;
name|value
operator|->
name|un
operator|.
name|addr
operator|.
name|offset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MINUS
condition|)
block|{
name|value
operator|->
name|un
operator|.
name|addr
operator|.
name|base
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|abort
argument_list|()
expr_stmt|;
name|value
operator|->
name|un
operator|.
name|addr
operator|.
name|offset
operator|=
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|value
operator|->
name|kind
operator|==
name|RTX_INT
operator|&&
name|value
operator|->
name|un
operator|.
name|addr
operator|.
name|base
operator|!=
literal|0
condition|)
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|value
operator|->
name|un
operator|.
name|addr
operator|.
name|base
argument_list|)
condition|)
block|{
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
comment|/* Use the string's address, not the SYMBOL_REF's address, 	   for the sake of addresses of library routines. 	   For a LABEL_REF, compare labels.  */
name|value
operator|->
name|un
operator|.
name|addr
operator|.
name|base
operator|=
name|XEXP
argument_list|(
name|value
operator|->
name|un
operator|.
name|addr
operator|.
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Given a MINUS expression, simplify it if both sides    include the same symbol.  */
end_comment

begin_function
name|rtx
name|simplify_subtraction
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|struct
name|rtx_const
name|val0
decl_stmt|,
name|val1
decl_stmt|;
name|decode_rtx_const
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|val0
argument_list|)
expr_stmt|;
name|decode_rtx_const
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
operator|&
name|val1
argument_list|)
expr_stmt|;
if|if
condition|(
name|val0
operator|.
name|un
operator|.
name|addr
operator|.
name|base
operator|==
name|val1
operator|.
name|un
operator|.
name|addr
operator|.
name|base
condition|)
return|return
name|GEN_INT
argument_list|(
name|val0
operator|.
name|un
operator|.
name|addr
operator|.
name|offset
operator|-
name|val1
operator|.
name|un
operator|.
name|addr
operator|.
name|offset
argument_list|)
return|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Compute a hash code for a constant RTL expression.  */
end_comment

begin_function
name|int
name|const_hash_rtx
parameter_list|(
name|mode
parameter_list|,
name|x
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|int
name|hi
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|rtx_const
name|value
decl_stmt|;
name|decode_rtx_const
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
comment|/* Compute hashing function */
name|hi
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
name|value
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|;
name|i
operator|++
control|)
name|hi
operator|+=
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|value
operator|)
index|[
name|i
index|]
expr_stmt|;
name|hi
operator|&=
operator|(
literal|1
operator|<<
name|HASHBITS
operator|)
operator|-
literal|1
expr_stmt|;
name|hi
operator|%=
name|MAX_RTX_HASH_TABLE
expr_stmt|;
return|return
name|hi
return|;
block|}
end_function

begin_comment
comment|/* Compare a constant rtl object X with a constant-descriptor DESC.    Return 1 if DESC describes a constant with the same value as X.  */
end_comment

begin_function
specifier|static
name|int
name|compare_constant_rtx
parameter_list|(
name|mode
parameter_list|,
name|x
parameter_list|,
name|desc
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|struct
name|constant_descriptor
modifier|*
name|desc
decl_stmt|;
block|{
specifier|register
name|int
modifier|*
name|p
init|=
operator|(
name|int
operator|*
operator|)
name|desc
operator|->
name|contents
decl_stmt|;
specifier|register
name|int
modifier|*
name|strp
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
name|struct
name|rtx_const
name|value
decl_stmt|;
name|decode_rtx_const
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
name|strp
operator|=
operator|(
name|int
operator|*
operator|)
operator|&
name|value
expr_stmt|;
name|len
operator|=
sizeof|sizeof
name|value
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
comment|/* Compare constant contents.  */
while|while
condition|(
operator|--
name|len
operator|>=
literal|0
condition|)
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
operator|*
name|strp
operator|++
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Construct a constant descriptor for the rtl-expression X.    It is up to the caller to enter the descriptor in the hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|constant_descriptor
modifier|*
name|record_constant_rtx
parameter_list|(
name|mode
parameter_list|,
name|x
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
name|struct
name|constant_descriptor
modifier|*
name|ptr
decl_stmt|;
name|char
modifier|*
name|label
decl_stmt|;
name|struct
name|rtx_const
name|value
decl_stmt|;
name|decode_rtx_const
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
comment|/* Put these things in the saveable obstack so we can ensure it won't      be freed if we are called from combine or some other phase that discards      memory allocated from function_obstack (current_obstack).  */
name|obstack_grow
argument_list|(
name|saveable_obstack
argument_list|,
operator|&
name|ptr
argument_list|,
sizeof|sizeof
name|ptr
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
name|saveable_obstack
argument_list|,
operator|&
name|label
argument_list|,
sizeof|sizeof
name|label
argument_list|)
expr_stmt|;
comment|/* Record constant contents.  */
name|obstack_grow
argument_list|(
name|saveable_obstack
argument_list|,
operator|&
name|value
argument_list|,
sizeof|sizeof
name|value
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|constant_descriptor
operator|*
operator|)
name|obstack_finish
argument_list|(
name|saveable_obstack
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a constant rtx X, make (or find) a memory constant for its value    and return a MEM rtx to refer to it in memory.  */
end_comment

begin_function
name|rtx
name|force_const_mem
parameter_list|(
name|mode
parameter_list|,
name|x
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|int
name|hash
decl_stmt|;
specifier|register
name|struct
name|constant_descriptor
modifier|*
name|desc
decl_stmt|;
name|char
name|label
index|[
literal|256
index|]
decl_stmt|;
name|char
modifier|*
name|found
init|=
literal|0
decl_stmt|;
name|rtx
name|def
decl_stmt|;
comment|/* If we want this CONST_DOUBLE in the same mode as it is in memory      (this will always be true for floating CONST_DOUBLEs that have been      placed in memory, but not for VOIDmode (integer) CONST_DOUBLEs),      use the previous copy.  Otherwise, make a new one.  Note that in      the unlikely event that this same CONST_DOUBLE is used in two different      modes in an alternating fashion, we will allocate a lot of different      memory locations, but this should be extremely rare.  */
comment|/* Don't use CONST_DOUBLE_MEM in a nested function.      Nested functions have their own constant pools,      so they can't share the same values in CONST_DOUBLE_MEM      with the containing function.  */
if|if
condition|(
name|outer_function_chain
operator|==
literal|0
condition|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_CODE
argument_list|(
name|CONST_DOUBLE_MEM
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_MODE
argument_list|(
name|CONST_DOUBLE_MEM
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|mode
condition|)
return|return
name|CONST_DOUBLE_MEM
argument_list|(
name|x
argument_list|)
return|;
comment|/* Compute hash code of X.  Search the descriptors for that hash code      to see if any of them describes X.  If yes, the descriptor records      the label number already assigned.  */
name|hash
operator|=
name|const_hash_rtx
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
expr_stmt|;
for|for
control|(
name|desc
operator|=
name|const_rtx_hash_table
index|[
name|hash
index|]
init|;
name|desc
condition|;
name|desc
operator|=
name|desc
operator|->
name|next
control|)
if|if
condition|(
name|compare_constant_rtx
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
name|desc
argument_list|)
condition|)
block|{
name|found
operator|=
name|desc
operator|->
name|label
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|found
operator|==
literal|0
condition|)
block|{
specifier|register
name|struct
name|pool_constant
modifier|*
name|pool
decl_stmt|;
specifier|register
name|struct
name|pool_sym
modifier|*
name|sym
decl_stmt|;
name|int
name|align
decl_stmt|;
comment|/* No constant equal to X is known to have been output. 	 Make a constant descriptor to enter X in the hash table. 	 Assign the label number and record it in the descriptor for 	 future calls to this function to find.  */
name|desc
operator|=
name|record_constant_rtx
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|desc
operator|->
name|next
operator|=
name|const_rtx_hash_table
index|[
name|hash
index|]
expr_stmt|;
name|const_rtx_hash_table
index|[
name|hash
index|]
operator|=
name|desc
expr_stmt|;
comment|/* Align the location counter as required by EXP's data type.  */
name|align
operator|=
operator|(
name|mode
operator|==
name|VOIDmode
operator|)
condition|?
name|UNITS_PER_WORD
else|:
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|align
operator|>
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
condition|)
name|align
operator|=
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
expr_stmt|;
name|pool_offset
operator|+=
name|align
operator|-
literal|1
expr_stmt|;
name|pool_offset
operator|&=
operator|~
operator|(
name|align
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* If RTL is not being placed into the saveable obstack, make a 	 copy of X that is in the saveable obstack in case we are being 	 called from combine or some other phase that discards memory 	 it allocates.  We need only do this if it is a CONST, since 	 no other RTX should be allocated in this situation. */
if|if
condition|(
name|rtl_obstack
operator|!=
name|saveable_obstack
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST
condition|)
block|{
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|rtl_in_saveable_obstack
argument_list|()
expr_stmt|;
name|x
operator|=
name|gen_rtx
argument_list|(
name|CONST
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
comment|/* Allocate a pool constant descriptor, fill it in, and chain it in.  */
name|pool
operator|=
operator|(
expr|struct
name|pool_constant
operator|*
operator|)
name|savealloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pool_constant
argument_list|)
argument_list|)
expr_stmt|;
name|pool
operator|->
name|desc
operator|=
name|desc
expr_stmt|;
name|pool
operator|->
name|constant
operator|=
name|x
expr_stmt|;
name|pool
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
name|pool
operator|->
name|labelno
operator|=
name|const_labelno
expr_stmt|;
name|pool
operator|->
name|align
operator|=
name|align
expr_stmt|;
name|pool
operator|->
name|offset
operator|=
name|pool_offset
expr_stmt|;
name|pool
operator|->
name|next
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|last_pool
operator|==
literal|0
condition|)
name|first_pool
operator|=
name|pool
expr_stmt|;
else|else
name|last_pool
operator|->
name|next
operator|=
name|pool
expr_stmt|;
name|last_pool
operator|=
name|pool
expr_stmt|;
name|pool_offset
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
comment|/* Create a string containing the label name, in LABEL.  */
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|label
argument_list|,
literal|"LC"
argument_list|,
name|const_labelno
argument_list|)
expr_stmt|;
operator|++
name|const_labelno
expr_stmt|;
name|desc
operator|->
name|label
operator|=
name|found
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_copy0
argument_list|(
name|saveable_obstack
argument_list|,
name|label
argument_list|,
name|strlen
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Add label to symbol hash table.  */
name|hash
operator|=
name|SYMHASH
argument_list|(
name|found
argument_list|)
expr_stmt|;
name|sym
operator|=
operator|(
expr|struct
name|pool_sym
operator|*
operator|)
name|savealloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pool_sym
argument_list|)
argument_list|)
expr_stmt|;
name|sym
operator|->
name|label
operator|=
name|found
expr_stmt|;
name|sym
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
name|sym
operator|->
name|next
operator|=
name|const_rtx_sym_hash_table
index|[
name|hash
index|]
expr_stmt|;
name|const_rtx_sym_hash_table
index|[
name|hash
index|]
operator|=
name|sym
expr_stmt|;
block|}
comment|/* We have a symbol name; construct the SYMBOL_REF and the MEM.  */
name|def
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|mode
argument_list|,
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
name|found
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|def
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Mark the symbol_ref as belonging to this constants pool.  */
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|def
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
name|current_function_uses_const_pool
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|outer_function_chain
operator|==
literal|0
condition|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
if|if
condition|(
name|CONST_DOUBLE_MEM
argument_list|(
name|x
argument_list|)
operator|==
name|cc0_rtx
condition|)
block|{
name|CONST_DOUBLE_CHAIN
argument_list|(
name|x
argument_list|)
operator|=
name|const_double_chain
expr_stmt|;
name|const_double_chain
operator|=
name|x
expr_stmt|;
block|}
name|CONST_DOUBLE_MEM
argument_list|(
name|x
argument_list|)
operator|=
name|def
expr_stmt|;
block|}
return|return
name|def
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a SYMBOL_REF with CONSTANT_POOL_ADDRESS_P true, return a pointer to    the corresponding pool_constant structure.  */
end_comment

begin_function
specifier|static
name|struct
name|pool_constant
modifier|*
name|find_pool_constant
parameter_list|(
name|addr
parameter_list|)
name|rtx
name|addr
decl_stmt|;
block|{
name|struct
name|pool_sym
modifier|*
name|sym
decl_stmt|;
name|char
modifier|*
name|label
init|=
name|XSTR
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|sym
operator|=
name|const_rtx_sym_hash_table
index|[
name|SYMHASH
argument_list|(
name|label
argument_list|)
index|]
init|;
name|sym
condition|;
name|sym
operator|=
name|sym
operator|->
name|next
control|)
if|if
condition|(
name|sym
operator|->
name|label
operator|==
name|label
condition|)
return|return
name|sym
operator|->
name|pool
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a constant pool SYMBOL_REF, return the corresponding constant.  */
end_comment

begin_function
name|rtx
name|get_pool_constant
parameter_list|(
name|addr
parameter_list|)
name|rtx
name|addr
decl_stmt|;
block|{
return|return
operator|(
name|find_pool_constant
argument_list|(
name|addr
argument_list|)
operator|)
operator|->
name|constant
return|;
block|}
end_function

begin_comment
comment|/* Similar, return the mode.  */
end_comment

begin_function
name|enum
name|machine_mode
name|get_pool_mode
parameter_list|(
name|addr
parameter_list|)
name|rtx
name|addr
decl_stmt|;
block|{
return|return
operator|(
name|find_pool_constant
argument_list|(
name|addr
argument_list|)
operator|)
operator|->
name|mode
return|;
block|}
end_function

begin_comment
comment|/* Similar, return the offset in the constant pool.  */
end_comment

begin_function
name|int
name|get_pool_offset
parameter_list|(
name|addr
parameter_list|)
name|rtx
name|addr
decl_stmt|;
block|{
return|return
operator|(
name|find_pool_constant
argument_list|(
name|addr
argument_list|)
operator|)
operator|->
name|offset
return|;
block|}
end_function

begin_comment
comment|/* Return the size of the constant pool.  */
end_comment

begin_function
name|int
name|get_pool_size
parameter_list|()
block|{
return|return
name|pool_offset
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Write all the constants in the constant pool.  */
end_comment

begin_function
name|void
name|output_constant_pool
parameter_list|(
name|fnname
parameter_list|,
name|fndecl
parameter_list|)
name|char
modifier|*
name|fnname
decl_stmt|;
name|tree
name|fndecl
decl_stmt|;
block|{
name|struct
name|pool_constant
modifier|*
name|pool
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|union
name|real_extract
name|u
decl_stmt|;
ifdef|#
directive|ifdef
name|ASM_OUTPUT_POOL_PROLOGUE
name|ASM_OUTPUT_POOL_PROLOGUE
argument_list|(
name|asm_out_file
argument_list|,
name|fnname
argument_list|,
name|fndecl
argument_list|,
name|pool_offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|pool
operator|=
name|first_pool
init|;
name|pool
condition|;
name|pool
operator|=
name|pool
operator|->
name|next
control|)
block|{
name|x
operator|=
name|pool
operator|->
name|constant
expr_stmt|;
comment|/* See if X is a LABEL_REF (or a CONST referring to a LABEL_REF) 	 whose CODE_LABEL has been deleted.  This can occur if a jump table 	 is eliminated by optimization.  If so, write a constant of zero 	 instead.  Note that this can also happen by turning the 	 CODE_LABEL into a NOTE.  */
if|if
condition|(
operator|(
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LABEL_REF
operator|&&
operator|(
name|INSN_DELETED_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|NOTE
operator|)
operator|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|&&
operator|(
name|INSN_DELETED_P
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|NOTE
operator|)
operator|)
condition|)
name|x
operator|=
name|const0_rtx
expr_stmt|;
comment|/* First switch to correct section.  */
ifdef|#
directive|ifdef
name|SELECT_RTX_SECTION
name|SELECT_RTX_SECTION
argument_list|(
name|pool
operator|->
name|mode
argument_list|,
name|x
argument_list|)
expr_stmt|;
else|#
directive|else
name|readonly_data_section
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ASM_OUTPUT_SPECIAL_POOL_ENTRY
name|ASM_OUTPUT_SPECIAL_POOL_ENTRY
argument_list|(
name|asm_out_file
argument_list|,
name|x
argument_list|,
name|pool
operator|->
name|mode
argument_list|,
name|pool
operator|->
name|align
argument_list|,
name|pool
operator|->
name|labelno
argument_list|,
name|done
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pool
operator|->
name|align
operator|>
literal|1
condition|)
name|ASM_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
name|exact_log2
argument_list|(
name|pool
operator|->
name|align
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Output the label.  */
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|asm_out_file
argument_list|,
literal|"LC"
argument_list|,
name|pool
operator|->
name|labelno
argument_list|)
expr_stmt|;
comment|/* Output the value of the constant itself.  */
switch|switch
condition|(
name|GET_MODE_CLASS
argument_list|(
name|pool
operator|->
name|mode
argument_list|)
condition|)
block|{
case|case
name|MODE_FLOAT
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_DOUBLE
condition|)
name|abort
argument_list|()
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|u
argument_list|,
sizeof|sizeof
name|u
argument_list|)
expr_stmt|;
name|assemble_real
argument_list|(
name|u
operator|.
name|d
argument_list|,
name|pool
operator|->
name|mode
argument_list|)
expr_stmt|;
break|break;
case|case
name|MODE_INT
case|:
case|case
name|MODE_PARTIAL_INT
case|:
name|assemble_integer
argument_list|(
name|x
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|pool
operator|->
name|mode
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|done
label|:
empty_stmt|;
block|}
comment|/* Done with this pool.  */
name|first_pool
operator|=
name|last_pool
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find all the constants whose addresses are referenced inside of EXP,    and make sure assembler code with a label has been output for each one.    Indicate whether an ADDR_EXPR has been encountered.  */
end_comment

begin_function
name|int
name|output_addressed_constants
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
name|int
name|reloc
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
case|case
name|ADDR_EXPR
case|:
block|{
specifier|register
name|tree
name|constant
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|constant
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
block|{
name|constant
operator|=
name|TREE_OPERAND
argument_list|(
name|constant
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|constant
argument_list|)
argument_list|)
operator|==
literal|'c'
operator|||
name|TREE_CODE
argument_list|(
name|constant
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
comment|/* No need to do anything here 	     for addresses of variables or functions.  */
name|output_constant_def
argument_list|(
name|constant
argument_list|)
expr_stmt|;
block|}
name|reloc
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
name|reloc
operator|=
name|output_addressed_constants
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|reloc
operator||=
name|output_addressed_constants
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|NON_LVALUE_EXPR
case|:
name|reloc
operator|=
name|output_addressed_constants
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONSTRUCTOR
case|:
block|{
specifier|register
name|tree
name|link
decl_stmt|;
for|for
control|(
name|link
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
operator|!=
literal|0
condition|)
name|reloc
operator||=
name|output_addressed_constants
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ERROR_MARK
case|:
break|break;
block|}
return|return
name|reloc
return|;
block|}
end_function

begin_comment
comment|/* Output assembler for byte constant */
end_comment

begin_function
name|void
name|output_byte_asm
parameter_list|(
name|byte
parameter_list|)
name|int
name|byte
decl_stmt|;
block|{
if|if
condition|(
name|output_bytecode
condition|)
name|bc_emit_const
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|byte
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ASM_OUTPUT_BYTE
else|else
block|{
name|ASM_OUTPUT_BYTE
argument_list|(
name|asm_out_file
argument_list|,
name|byte
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output assembler code for constant EXP to FILE, with no label.    This includes the pseudo-op such as ".int" or ".byte", and a newline.    Assumes output_addressed_constants has been done on EXP already.     Generate exactly SIZE bytes of assembler data, padding at the end    with zeros if necessary.  SIZE must always be specified.     SIZE is important for structure constructors,    since trailing members may have been omitted from the constructor.    It is also important for initialization of arrays from string constants    since the full length of the string constant might not be wanted.    It is also needed for initialization of unions, where the initializer's    type is just one member, and that may not be as long as the union.     There a case in which we would fail to output exactly SIZE bytes:    for a structure constructor that wants to produce more than SIZE bytes.    But such constructors will never be generated for any possible input.  */
end_comment

begin_function
name|void
name|output_constant
parameter_list|(
name|exp
parameter_list|,
name|size
parameter_list|)
specifier|register
name|tree
name|exp
decl_stmt|;
specifier|register
name|int
name|size
decl_stmt|;
block|{
specifier|register
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|x
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
return|return;
comment|/* Eliminate the NON_LVALUE_EXPR_EXPR that makes a cast not be an lvalue.      That way we get the constant (we hope) inside it.  Also, strip      off any NOP_EXPR that converts between two record or union types.  */
while|while
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
operator|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|QUAL_UNION_TYPE
operator|)
operator|)
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|NON_LVALUE_EXPR
condition|)
name|exp
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Allow a constructor with no elements for any data type.      This means to fill the space with zeros.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONSTRUCTOR
operator|&&
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|output_bytecode
condition|)
name|bc_emit_const_skip
argument_list|(
name|size
argument_list|)
expr_stmt|;
else|else
name|assemble_zeros
argument_list|(
name|size
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CHAR_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
case|case
name|INTEGER_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
comment|/* ??? What about       (int)((float)(int)&foo + 4)    */
while|while
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|NON_LVALUE_EXPR
condition|)
name|exp
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|assemble_integer
argument_list|(
name|expand_expr
argument_list|(
name|exp
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_INITIALIZER
argument_list|)
argument_list|,
name|size
argument_list|,
literal|0
argument_list|)
condition|)
name|error
argument_list|(
literal|"initializer for integer value is too complicated"
argument_list|)
expr_stmt|;
name|size
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|REAL_TYPE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|REAL_CST
condition|)
name|error
argument_list|(
literal|"initializer for floating value is not a floating constant"
argument_list|)
expr_stmt|;
name|assemble_real
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|exp
argument_list|)
argument_list|,
name|mode_for_size
argument_list|(
name|size
operator|*
name|BITS_PER_UNIT
argument_list|,
name|MODE_FLOAT
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|COMPLEX_TYPE
case|:
name|output_constant
argument_list|(
name|TREE_REALPART
argument_list|(
name|exp
argument_list|)
argument_list|,
name|size
operator|/
literal|2
argument_list|)
expr_stmt|;
name|output_constant
argument_list|(
name|TREE_IMAGPART
argument_list|(
name|exp
argument_list|)
argument_list|,
name|size
operator|/
literal|2
argument_list|)
expr_stmt|;
name|size
operator|-=
operator|(
name|size
operator|/
literal|2
operator|)
operator|*
literal|2
expr_stmt|;
break|break;
case|case
name|ARRAY_TYPE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
block|{
name|output_constructor
argument_list|(
name|exp
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|STRING_CST
condition|)
block|{
name|int
name|excess
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|size
operator|>
name|TREE_STRING_LENGTH
argument_list|(
name|exp
argument_list|)
condition|)
block|{
name|excess
operator|=
name|size
operator|-
name|TREE_STRING_LENGTH
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|size
operator|=
name|TREE_STRING_LENGTH
argument_list|(
name|exp
argument_list|)
expr_stmt|;
block|}
name|assemble_string
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|exp
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|size
operator|=
name|excess
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
break|break;
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
name|output_constructor
argument_list|(
name|exp
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|size
operator|>
literal|0
condition|)
name|assemble_zeros
argument_list|(
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Bytecode specific code to output assembler for integer. */
end_comment

begin_function
specifier|static
name|void
name|bc_assemble_integer
parameter_list|(
name|exp
parameter_list|,
name|size
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|tree
name|const_part
decl_stmt|;
name|tree
name|addr_part
decl_stmt|;
name|tree
name|tmp
decl_stmt|;
comment|/* FIXME: is this fold() business going to be as good as the      expand_expr() using EXPAND_SUM above in the RTL case?  I      hate RMS.      FIXME: Copied as is from BC-GCC1; may need work. Don't hate. -bson */
name|exp
operator|=
name|fold
argument_list|(
name|exp
argument_list|)
expr_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONVERT_EXPR
condition|)
name|exp
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|const_part
operator|=
name|exp
expr_stmt|;
name|addr_part
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|PLUS_EXPR
condition|)
block|{
name|const_part
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|const_part
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|const_part
argument_list|)
operator|==
name|CONVERT_EXPR
condition|)
name|const_part
operator|=
name|TREE_OPERAND
argument_list|(
name|const_part
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addr_part
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|addr_part
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|addr_part
argument_list|)
operator|==
name|CONVERT_EXPR
condition|)
name|addr_part
operator|=
name|TREE_OPERAND
argument_list|(
name|addr_part
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|const_part
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|tmp
operator|=
name|const_part
operator|,
name|const_part
operator|=
name|addr_part
operator|,
name|addr_part
operator|=
name|tmp
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|const_part
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|addr_part
argument_list|)
operator|!=
name|ADDR_EXPR
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* FIXME: we really haven't considered 				   all the possible cases here.  */
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
block|{
name|const_part
operator|=
name|integer_zero_node
expr_stmt|;
name|addr_part
operator|=
name|exp
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* FIXME: ditto previous.  */
if|if
condition|(
name|addr_part
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|size
operator|==
literal|1
condition|)
block|{
name|char
name|c
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|const_part
argument_list|)
decl_stmt|;
name|bc_emit
argument_list|(
operator|&
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|size
operator|-=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
operator|==
literal|2
condition|)
block|{
name|short
name|s
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|const_part
argument_list|)
decl_stmt|;
name|bc_emit
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|s
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|size
operator|-=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
operator|==
literal|4
condition|)
block|{
name|int
name|i
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|const_part
argument_list|)
decl_stmt|;
name|bc_emit
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|i
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|size
operator|-=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
operator|==
literal|8
condition|)
block|{
if|#
directive|if
name|WORDS_BIG_ENDIAN
name|int
name|i
init|=
name|TREE_INT_CST_HIGH
argument_list|(
name|const_part
argument_list|)
decl_stmt|;
name|bc_emit
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|i
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|i
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|const_part
argument_list|)
expr_stmt|;
name|bc_emit
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|i
argument_list|,
literal|4
argument_list|)
expr_stmt|;
else|#
directive|else
name|int
name|i
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|const_part
argument_list|)
decl_stmt|;
name|bc_emit
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|i
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|i
operator|=
name|TREE_INT_CST_HIGH
argument_list|(
name|const_part
argument_list|)
expr_stmt|;
name|bc_emit
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|i
argument_list|,
literal|4
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|size
operator|-=
literal|8
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|size
operator|==
literal|4
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|addr_part
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|bc_emit_labelref
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|TREE_OPERAND
argument_list|(
name|addr_part
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|const_part
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* FIXME: there may be more cases.  */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutine of output_constant, used for CONSTRUCTORs    (aggregate constants).    Generate at least SIZE bytes, padding if necessary.  */
end_comment

begin_function
name|void
name|output_constructor
parameter_list|(
name|exp
parameter_list|,
name|size
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
specifier|register
name|tree
name|link
decl_stmt|,
name|field
init|=
literal|0
decl_stmt|;
name|HOST_WIDE_INT
name|min_index
init|=
literal|0
decl_stmt|;
comment|/* Number of bytes output or skipped so far.      In other words, current position within the constructor.  */
name|int
name|total_bytes
init|=
literal|0
decl_stmt|;
comment|/* Non-zero means BYTE contains part of a byte, to be output.  */
name|int
name|byte_buffer_in_use
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|byte
decl_stmt|;
if|if
condition|(
name|HOST_BITS_PER_WIDE_INT
operator|<
name|BITS_PER_UNIT
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|min_index
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* As LINK goes through the elements of the constant,      FIELD goes through the structure fields, if the constant is a structure.      if the constant is a union, then we override this,      by getting the field from the TREE_LIST element.      But the constant could also be an array.  Then FIELD is zero.  */
for|for
control|(
name|link
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
operator|,
name|field
operator|=
name|field
condition|?
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
else|:
literal|0
control|)
block|{
name|tree
name|val
init|=
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
decl_stmt|;
name|tree
name|index
init|=
literal|0
decl_stmt|;
comment|/* the element in a union constructor specifies the proper field.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
comment|/* if available, use the type given by link */
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
operator|!=
literal|0
condition|)
name|field
operator|=
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|index
operator|=
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
expr_stmt|;
comment|/* Eliminate the marker that makes a cast not be an lvalue.  */
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
name|STRIP_NOPS
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|field
operator|==
literal|0
operator|||
operator|!
name|DECL_BIT_FIELD
argument_list|(
name|field
argument_list|)
condition|)
block|{
comment|/* An element that is not a bit-field.  */
specifier|register
name|int
name|fieldsize
decl_stmt|;
comment|/* Since this structure is static, 	     we know the positions are constant.  */
name|int
name|bitpos
init|=
operator|(
name|field
condition|?
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_FIELD_BITPOS
argument_list|(
name|field
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
operator|)
else|:
literal|0
operator|)
decl_stmt|;
if|if
condition|(
name|index
operator|!=
literal|0
condition|)
name|bitpos
operator|=
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
operator|*
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|index
argument_list|)
operator|-
name|min_index
operator|)
operator|)
expr_stmt|;
comment|/* Output any buffered-up bit-fields preceding this element.  */
if|if
condition|(
name|byte_buffer_in_use
condition|)
block|{
name|ASM_OUTPUT_BYTE
argument_list|(
name|asm_out_file
argument_list|,
name|byte
argument_list|)
expr_stmt|;
name|total_bytes
operator|++
expr_stmt|;
name|byte_buffer_in_use
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Advance to offset of this element. 	     Note no alignment needed in an array, since that is guaranteed 	     if each element has the proper size.  */
if|if
condition|(
operator|(
name|field
operator|!=
literal|0
operator|||
name|index
operator|!=
literal|0
operator|)
operator|&&
name|bitpos
operator|!=
name|total_bytes
condition|)
block|{
if|if
condition|(
operator|!
name|output_bytecode
condition|)
name|assemble_zeros
argument_list|(
name|bitpos
operator|-
name|total_bytes
argument_list|)
expr_stmt|;
else|else
name|bc_emit_const_skip
argument_list|(
name|bitpos
operator|-
name|total_bytes
argument_list|)
expr_stmt|;
name|total_bytes
operator|=
name|bitpos
expr_stmt|;
block|}
comment|/* Determine size this element should occupy.  */
if|if
condition|(
name|field
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|>
literal|100000
condition|)
block|{
comment|/* This avoids overflow trouble.  */
name|tree
name|size_tree
init|=
name|size_binop
argument_list|(
name|CEIL_DIV_EXPR
argument_list|,
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|BITS_PER_UNIT
argument_list|)
argument_list|)
decl_stmt|;
name|fieldsize
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|size_tree
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fieldsize
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
name|fieldsize
operator|=
operator|(
name|fieldsize
operator|+
name|BITS_PER_UNIT
operator|-
literal|1
operator|)
operator|/
name|BITS_PER_UNIT
expr_stmt|;
block|}
block|}
else|else
name|fieldsize
operator|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Output the element's initial value.  */
if|if
condition|(
name|val
operator|==
literal|0
condition|)
name|assemble_zeros
argument_list|(
name|fieldsize
argument_list|)
expr_stmt|;
else|else
name|output_constant
argument_list|(
name|val
argument_list|,
name|fieldsize
argument_list|)
expr_stmt|;
comment|/* Count its size.  */
name|total_bytes
operator|+=
name|fieldsize
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|val
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|error
argument_list|(
literal|"invalid initial value for member `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Element that is a bit-field.  */
name|int
name|next_offset
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_FIELD_BITPOS
argument_list|(
name|field
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|end_offset
init|=
operator|(
name|next_offset
operator|+
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
name|val
operator|=
name|integer_zero_node
expr_stmt|;
comment|/* If this field does not start in this (or, next) byte, 	     skip some bytes.  */
if|if
condition|(
name|next_offset
operator|/
name|BITS_PER_UNIT
operator|!=
name|total_bytes
condition|)
block|{
comment|/* Output remnant of any bit field in previous bytes.  */
if|if
condition|(
name|byte_buffer_in_use
condition|)
block|{
name|ASM_OUTPUT_BYTE
argument_list|(
name|asm_out_file
argument_list|,
name|byte
argument_list|)
expr_stmt|;
name|total_bytes
operator|++
expr_stmt|;
name|byte_buffer_in_use
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If still not at proper byte, advance to there.  */
if|if
condition|(
name|next_offset
operator|/
name|BITS_PER_UNIT
operator|!=
name|total_bytes
condition|)
block|{
name|assemble_zeros
argument_list|(
name|next_offset
operator|/
name|BITS_PER_UNIT
operator|-
name|total_bytes
argument_list|)
expr_stmt|;
name|total_bytes
operator|=
name|next_offset
operator|/
name|BITS_PER_UNIT
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|byte_buffer_in_use
condition|)
name|byte
operator|=
literal|0
expr_stmt|;
comment|/* We must split the element into pieces that fall within 	     separate bytes, and combine each byte with previous or 	     following bit-fields.  */
comment|/* next_offset is the offset n fbits from the beginning of 	     the structure to the next bit of this element to be processed. 	     end_offset is the offset of the first bit past the end of 	     this element.  */
while|while
condition|(
name|next_offset
operator|<
name|end_offset
condition|)
block|{
name|int
name|this_time
decl_stmt|;
name|int
name|shift
decl_stmt|,
name|value
decl_stmt|;
name|int
name|next_byte
init|=
name|next_offset
operator|/
name|BITS_PER_UNIT
decl_stmt|;
name|int
name|next_bit
init|=
name|next_offset
operator|%
name|BITS_PER_UNIT
decl_stmt|;
comment|/* Advance from byte to byte 		 within this element when necessary.  */
while|while
condition|(
name|next_byte
operator|!=
name|total_bytes
condition|)
block|{
name|ASM_OUTPUT_BYTE
argument_list|(
name|asm_out_file
argument_list|,
name|byte
argument_list|)
expr_stmt|;
name|total_bytes
operator|++
expr_stmt|;
name|byte
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Number of bits we can process at once 		 (all part of the same byte).  */
name|this_time
operator|=
name|MIN
argument_list|(
name|end_offset
operator|-
name|next_offset
argument_list|,
name|BITS_PER_UNIT
operator|-
name|next_bit
argument_list|)
expr_stmt|;
if|#
directive|if
name|BYTES_BIG_ENDIAN
comment|/* On big-endian machine, take the most significant bits 		 first (of the bits that are significant) 		 and put them into bytes from the most significant end.  */
name|shift
operator|=
name|end_offset
operator|-
name|next_offset
operator|-
name|this_time
expr_stmt|;
comment|/* Don't try to take a bunch of bits that cross 		 the word boundary in the INTEGER_CST.  */
if|if
condition|(
name|shift
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|shift
operator|+
name|this_time
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|this_time
operator|-=
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
name|shift
operator|)
expr_stmt|;
name|shift
operator|=
name|HOST_BITS_PER_WIDE_INT
expr_stmt|;
block|}
comment|/* Now get the bits from the appropriate constant word.  */
if|if
condition|(
name|shift
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|value
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|shift
operator|<
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|value
operator|=
name|TREE_INT_CST_HIGH
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|shift
operator|-=
name|HOST_BITS_PER_WIDE_INT
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
name|byte
operator||=
operator|(
operator|(
operator|(
name|value
operator|>>
name|shift
operator|)
operator|&
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|this_time
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
operator|(
name|BITS_PER_UNIT
operator|-
name|this_time
operator|-
name|next_bit
operator|)
operator|)
expr_stmt|;
else|#
directive|else
comment|/* On little-endian machines, 		 take first the least significant bits of the value 		 and pack them starting at the least significant 		 bits of the bytes.  */
name|shift
operator|=
operator|(
name|next_offset
operator|-
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_FIELD_BITPOS
argument_list|(
name|field
argument_list|)
argument_list|)
operator|)
expr_stmt|;
comment|/* Don't try to take a bunch of bits that cross 		 the word boundary in the INTEGER_CST.  */
if|if
condition|(
name|shift
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|shift
operator|+
name|this_time
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|this_time
operator|-=
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
name|shift
operator|)
expr_stmt|;
name|shift
operator|=
name|HOST_BITS_PER_WIDE_INT
expr_stmt|;
block|}
comment|/* Now get the bits from the appropriate constant word.  */
if|if
condition|(
name|shift
operator|<
name|HOST_BITS_PER_INT
condition|)
name|value
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|val
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|shift
operator|<
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|value
operator|=
name|TREE_INT_CST_HIGH
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|shift
operator|-=
name|HOST_BITS_PER_WIDE_INT
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
name|byte
operator||=
operator|(
operator|(
name|value
operator|>>
name|shift
operator|)
operator|&
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|this_time
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
name|next_bit
expr_stmt|;
endif|#
directive|endif
name|next_offset
operator|+=
name|this_time
expr_stmt|;
name|byte_buffer_in_use
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|byte_buffer_in_use
condition|)
block|{
name|ASM_OUTPUT_BYTE
argument_list|(
name|asm_out_file
argument_list|,
name|byte
argument_list|)
expr_stmt|;
name|total_bytes
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|total_bytes
operator|<
name|size
condition|)
name|assemble_zeros
argument_list|(
name|size
operator|-
name|total_bytes
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HANDLE_SYSV_PRAGMA
end_ifdef

begin_comment
comment|/* Support #pragma weak by default if WEAK_ASM_OP and ASM_OUTPUT_DEF    are defined.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|WEAK_ASM_OP
argument_list|)
operator|&&
name|defined
argument_list|(
name|ASM_OUTPUT_DEF
argument_list|)
end_if

begin_comment
comment|/* See c-pragma.c for an identical definition.  */
end_comment

begin_enum
enum|enum
name|pragma_state
block|{
name|ps_start
block|,
name|ps_done
block|,
name|ps_bad
block|,
name|ps_weak
block|,
name|ps_name
block|,
name|ps_equals
block|,
name|ps_value
block|,
name|ps_pack
block|,
name|ps_left
block|,
name|ps_align
block|,
name|ps_right
block|}
enum|;
end_enum

begin_comment
comment|/* Output asm to handle ``#pragma weak'' */
end_comment

begin_function
name|void
name|handle_pragma_weak
parameter_list|(
name|what
parameter_list|,
name|asm_out_file
parameter_list|,
name|name
parameter_list|,
name|value
parameter_list|)
name|enum
name|pragma_state
name|what
decl_stmt|;
name|FILE
modifier|*
name|asm_out_file
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|,
decl|*
name|value
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
name|what
operator|==
name|ps_name
operator|||
name|what
operator|==
name|ps_value
condition|)
block|{
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s\t"
argument_list|,
name|WEAK_ASM_OP
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_bytecode
condition|)
name|BC_OUTPUT_LABELREF
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|ASM_OUTPUT_LABELREF
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|what
operator|==
name|ps_value
condition|)
name|ASM_OUTPUT_DEF
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|what
operator|==
name|ps_done
operator|||
name|what
operator|==
name|ps_start
operator|)
condition|)
name|warning
argument_list|(
literal|"malformed `#pragma weak'"
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HANDLE_PRAGMA_WEAK or (WEAK_ASM_OP and SET_ASM_OP) */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* WEAK_ASM_OP&& ASM_OUTPUT_DEF */
end_comment

end_unit

