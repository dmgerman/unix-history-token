begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* pr -- convert text files for printing.    Copyright (C) 1988, 1991 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/*  Author: Pete TerMaat.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Things to watch: Sys V screws up on ...    pr -n -3 -s: /usr/dict/words    pr -m -o10 -n /usr/dict/words{,,,}    pr -6 -a -n -o5 /usr/dict/words     Ideas:     Keep a things_to_do list of functions to call when we know we have    something to print.  Cleaner than current series of checks.     Improve the printing of control prefixes.      Options:     +PAGE	Begin output at page PAGE of the output.     -COLUMN	Produce output that is COLUMN columns wide and print 		columns down.     -a		Print columns across rather than down.  The input 		one 		two 		three 		four 		will be printed as 		one	two	three 		four     -b		Balance columns on the last page.     -c		Print unprintable characters as control prefixes. 		Control-g is printed as ^G.     -d		Double space the output.     -e[c[k]]	Expand tabs to spaces on input.  Optional argument C 		is the input tab character. (Default is `\t'.)  Optional 		argument K is the input tab character's width.  (Default is 8.)     -F    -f		Use formfeeds instead of newlines to separate pages.     -h header	Replace the filename in the header with the string HEADER.     -i[c[k]]	Replace spaces with tabs on output.  Optional argument 		C is the output tab character.  (Default is `\t'.)  Optional 		argument K is the output tab character's width.  (Default 		is 8.)     -l lines	Set the page length to LINES.  Default is 66.     -m		Print files in parallel.     -n[c[k]]	Precede each column with a line number. 		(With parallel files, precede each line with a line 		number.)  Optional argument C is the character to print 		after each number.  (Default `\t'.)  Optional argument 		K is the number of digits per line number.  (Default 5.)     -o offset	Offset each line with a margin OFFSET spaces wide. 		Total page width is the size of this offset plus the 		width set with `-w'.     -r		Ignore files that can't be opened.     -s[c]	Separate each line with a character.  Optional argument C is 		the character to be used.  Default is `\t'.     -t		Do not print headers or footers.     -v		Print unprintable characters as escape sequences. 		Control-G becomes \007.     -w width	Set the page width to WIDTH characters. */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<getopt.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"version.h"
end_include

begin_function_decl
name|char
modifier|*
name|xmalloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|xrealloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|error
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|char_to_clump
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|read_line
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|print_page
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|print_stored
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|open_file
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|skip_to_page
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|getoptarg
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usage
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_files
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_header
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_store_cols
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|store_columns
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|balance
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|store_char
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pad_down
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|read_rest_of_line
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_char
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cleanup
parameter_list|()
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|TRUE
end_ifndef

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Used with start_position in the struct COLUMN described below.    If start_position == ANYWHERE, we aren't truncating columns and    can begin printing a column anywhere.  Otherwise we must pad to    the horizontal position start_position. */
end_comment

begin_define
define|#
directive|define
name|ANYWHERE
value|0
end_define

begin_comment
comment|/* Each column has one of these structures allocated for it.    If we're only dealing with one file, fp is the same for all    columns.     The general strategy is to spend time setting up these column    structures (storing columns if necessary), after which printing    is a matter of flitting from column to column and calling    print_func.     Parallel files, single files printing across in multiple    columns, and single files printing down in multiple columns all    fit the same printing loop.     print_func		Function used to print lines in this column. 			If we're storing this column it will be 			print_stored(), Otherwise it will be read_line().     char_func		Function used to process characters in this column. 			If we're storing this column it will be store_char(), 			otherwise it will be print_char().     current_line		Index of the current entry in line_vector, which 			contains the index of the first character of the 			current line in buff[].     lines_stored		Number of lines in this column which are stored in 			buff.     lines_to_print	If we're storing this column, lines_to_print is 			the number of stored_lines which remain to be 			printed.  Otherwise it is the number of lines 			we can print without exceeding lines_per_body.     start_position	The horizontal position we want to be in before we 			print the first character in this column.     numbered		True means precede this column with a line number. */
end_comment

begin_struct
struct|struct
name|COLUMN
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
comment|/* Input stream for this column. */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* File name. */
enum|enum
block|{
name|OPEN
block|,
name|ON_HOLD
block|,
comment|/* Hit a form feed. */
name|CLOSED
block|}
name|status
enum|;
comment|/* Status of the file pointer. */
name|int
function_decl|(
modifier|*
name|print_func
function_decl|)
parameter_list|()
function_decl|;
comment|/* Func to print lines in this col. */
name|void
function_decl|(
modifier|*
name|char_func
function_decl|)
parameter_list|()
function_decl|;
comment|/* Func to print/store chars in this col. */
name|int
name|current_line
decl_stmt|;
comment|/* Index of current place in line_vector. */
name|int
name|lines_stored
decl_stmt|;
comment|/* Number of lines stored in buff. */
name|int
name|lines_to_print
decl_stmt|;
comment|/* No. lines stored or space left on page. */
name|int
name|start_position
decl_stmt|;
comment|/* Horizontal position of first char. */
name|int
name|numbered
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|COLUMN
name|COLUMN
typedef|;
end_typedef

begin_define
define|#
directive|define
name|NULLCOL
value|(COLUMN *)0
end_define

begin_comment
comment|/* The name under which this program was invoked. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|program_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* All of the columns to print.  */
end_comment

begin_decl_stmt
specifier|static
name|COLUMN
modifier|*
name|column_vector
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When printing a single file in multiple downward columns,    we store the leftmost columns contiguously in buff.    To print a line from buff, get the index of the first char    from line_vector[i], and print up to line_vector[i + 1]. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|buff
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index of the position in buff where the next character    will be stored. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|buff_current
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of characters in buff.    Used for allocation of buff and to detect overflow of buff. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|buff_allocated
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array of indices into buff.    Each entry is an index of the first character of a line.    This is used when storing lines to facilitate shuffling when    we do column balancing on the last page. */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|line_vector
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array of horizonal positions.    For each line in line_vector, end_vector[line] is the horizontal    position we are in after printing that line.  We keep track of this    so that we know how much we need to pad to prepare for the next    column. */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|end_vector
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (-m) True means we're printing multiple files in parallel. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|parallel_files
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (-[0-9]+) True means we're given an option explicitly specifying    number of columns.  Used to detect when this option is used with -m. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|explicit_columns
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (-t) True means we're printing headers and footers. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|extremities
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True means we need to print a header as soon as we know we've got input    to print after it. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|print_a_header
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (-h) True means we're using the standard header rather than a    customized one specified by the -h flag. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|standard_header
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (-f) True means use formfeeds instead of newlines to separate pages. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|use_form_feed
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True means we have read the standard input. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|have_read_stdin
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True means the -a flag has been given. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|print_across_flag
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True means we're printing one file in multiple (>1) downward columns. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|storing_columns
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (-b) True means balance columns on the last page as Sys V does. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|balance_columns
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (-l) Number of lines on a page, including header and footer lines. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|lines_per_page
init|=
literal|66
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of lines in the header and footer can be reset to 0 using    the -t flag. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|lines_per_header
init|=
literal|5
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lines_per_body
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lines_per_footer
init|=
literal|5
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (-w) Width in characters of the page.  Does not include the width of    the margin. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|chars_per_line
init|=
literal|72
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of characters in a column.  Based on the gutter and page widths. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|chars_per_column
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (-e) True means convert tabs to spaces on input. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|untabify_input
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (-e) The input tab character. */
end_comment

begin_decl_stmt
specifier|static
name|char
name|input_tab_char
init|=
literal|'\t'
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (-e) Tabstops are at chars_per_tab, 2*chars_per_tab, 3*chars_per_tab, ...    where the leftmost column is 1. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|chars_per_input_tab
init|=
literal|8
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (-i) True means convert spaces to tabs on output. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|tabify_output
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (-i) The output tab character. */
end_comment

begin_decl_stmt
specifier|static
name|char
name|output_tab_char
init|=
literal|'\t'
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (-i) The width of the output tab. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|chars_per_output_tab
init|=
literal|8
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Keeps track of pending white space.  When we hit a nonspace    character after some whitespace, we print whitespace, tabbing    if necessary to get to output_position + spaces_not_printed. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|spaces_not_printed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of spaces between columns (though tabs can be used when possible to    use up the equivalent amount of space).  Not sure if this is worth making    a flag for.  BSD uses 0, Sys V uses 1.  Sys V looks better. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|chars_per_gutter
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (-o) Number of spaces in the left margin (tabs used when possible). */
end_comment

begin_decl_stmt
specifier|static
name|int
name|chars_per_margin
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Position where the next character will fall.    Leftmost position is 0 + chars_per_margin.    Rightmost position is chars_per_margin + chars_per_line - 1.    This is important for converting spaces to tabs on output. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|output_position
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Horizontal position relative to the current file.    (output_position depends on where we are on the page;    input_position depends on where we are in the file.)    Important for converting tabs to spaces on input. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|input_position
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Count number of failed opens so we can exit with non-zero    status if there were any.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|failed_opens
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The horizontal position we'll be at after printing a tab character    of width c_ from the position h_. */
end_comment

begin_define
define|#
directive|define
name|pos_after_tab
parameter_list|(
name|c_
parameter_list|,
name|h_
parameter_list|)
value|h_ - h_ % c_ + c_
end_define

begin_comment
comment|/* The number of spaces taken up if we print a tab character with width    c_ from position h_. */
end_comment

begin_define
define|#
directive|define
name|tab_width
parameter_list|(
name|c_
parameter_list|,
name|h_
parameter_list|)
value|- h_ % c_ + c_
end_define

begin_comment
comment|/* (-NNN) Number of columns of text to print. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|columns
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (+NNN) Page number on which to begin printing. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|first_page_number
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of files open (not closed, not on hold). */
end_comment

begin_decl_stmt
specifier|static
name|int
name|files_ready_to_read
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current page number.  Displayed in header. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|page_number
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current line number.  Displayed when -n flag is specified.     When printing files in parallel (-m flag), line numbering is as follows:    1	foo	goo	moo    2	hoo	too	zoo     When printing files across (-a flag), ...    1	foo	2	moo	3	goo    4	hoo	3	too	6	zoo     Otherwise, line numbering is as follows:    1	foo	3	goo	5	too    2	moo	4	hoo	6	zoo */
end_comment

begin_decl_stmt
specifier|static
name|int
name|line_number
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (-n) True means lines should be preceded by numbers. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|numbered_lines
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (-n) Character which follows each line number. */
end_comment

begin_decl_stmt
specifier|static
name|char
name|number_separator
init|=
literal|'\t'
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (-n) Width in characters of a line number. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|chars_per_number
init|=
literal|5
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used when widening the first column to accommodate numbers -- only    needed when printing files in parallel.  Includes width of both the    number and the number_separator. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|number_width
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer sprintf uses to format a line number. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|number_buff
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (-v) True means unprintable characters are printed as escape sequences.    control-g becomes \007. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|use_esc_sequence
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (-c) True means unprintable characters are printed as control prefixes.    control-g becomes ^G. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|use_cntrl_prefix
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (-d) True means output is double spaced. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|double_space
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of files opened initially in init_files.  Should be 1    unless we're printing multiple files in parallel. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|total_files
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (-r) True means don't complain if we can't open a file. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ignore_failed_opens
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (-s) True means we separate columns with a specified character. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|use_column_separator
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Character used to separate columns if the the -s flag has been specified. */
end_comment

begin_decl_stmt
specifier|static
name|char
name|column_separator
init|=
literal|'\t'
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of separator characters waiting to be printed as soon as we    know that we have any input remaining to be printed. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|separators_not_printed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Position we need to pad to, as soon as we know that we have input    remaining to be printed. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|padding_not_printed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True means we should pad the end of the page.  Remains false until we    know we have a page to print. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pad_vertically
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (-h) String of characters used in place of the filename in the header. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|custom_header
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* String containing the date, filename or custom header, and "Page ". */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|header
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
modifier|*
name|clump_buff
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True means we truncate lines longer than chars_per_column. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|truncate_lines
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If non-zero, display usage information and exit.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|flag_help
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If non-zero, print the version on standard error.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|flag_version
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|option
specifier|const
name|long_options
index|[]
init|=
block|{
block|{
literal|"help"
block|,
name|no_argument
block|,
operator|&
name|flag_help
block|,
literal|1
block|}
block|,
block|{
literal|"version"
block|,
name|no_argument
block|,
operator|&
name|flag_version
block|,
literal|1
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return the number of columns that have either an open file or    stored lines. */
end_comment

begin_function
specifier|static
name|int
name|cols_ready_to_print
parameter_list|()
block|{
name|COLUMN
modifier|*
name|q
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|n
decl_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|q
operator|=
name|column_vector
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|columns
condition|;
operator|++
name|q
operator|,
operator|++
name|i
control|)
if|if
condition|(
name|q
operator|->
name|status
operator|==
name|OPEN
operator|||
operator|(
name|storing_columns
operator|&&
name|q
operator|->
name|lines_stored
operator|>
literal|0
operator|&&
name|q
operator|->
name|lines_to_print
operator|>
literal|0
operator|)
condition|)
operator|++
name|n
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_function
name|void
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|int
name|accum
init|=
literal|0
decl_stmt|;
name|int
name|n_files
decl_stmt|;
name|char
modifier|*
modifier|*
name|file_names
decl_stmt|;
name|program_name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|n_files
operator|=
literal|0
expr_stmt|;
name|file_names
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|argc
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"-0123456789abcde::fFh:i::l:mn::o:rs::tvw:"
argument_list|,
name|long_options
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|1
condition|)
comment|/* Non-option argument. */
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|optarg
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'+'
condition|)
block|{
operator|++
name|s
expr_stmt|;
if|if
condition|(
operator|!
name|ISDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"`+' requires a numeric argument"
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
comment|/* FIXME: use strtol */
name|first_page_number
operator|=
name|atoi
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|file_names
index|[
name|n_files
operator|++
index|]
operator|=
name|optarg
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ISDIGIT
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|accum
operator|=
name|accum
operator|*
literal|10
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
continue|continue;
block|}
else|else
block|{
if|if
condition|(
name|accum
operator|>
literal|0
condition|)
block|{
name|columns
operator|=
name|accum
expr_stmt|;
name|explicit_columns
operator|=
name|TRUE
expr_stmt|;
name|accum
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|c
operator|==
literal|1
condition|)
continue|continue;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|0
case|:
comment|/* getopt long option */
break|break;
case|case
literal|'a'
case|:
name|print_across_flag
operator|=
name|TRUE
expr_stmt|;
name|storing_columns
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|balance_columns
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|use_cntrl_prefix
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|double_space
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
if|if
condition|(
name|optarg
condition|)
name|getoptarg
argument_list|(
name|optarg
argument_list|,
literal|'e'
argument_list|,
operator|&
name|input_tab_char
argument_list|,
operator|&
name|chars_per_input_tab
argument_list|)
expr_stmt|;
comment|/* Could check tab width> 0. */
name|untabify_input
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
name|use_form_feed
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|custom_header
operator|=
name|optarg
expr_stmt|;
name|standard_header
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
if|if
condition|(
name|optarg
condition|)
name|getoptarg
argument_list|(
name|optarg
argument_list|,
literal|'i'
argument_list|,
operator|&
name|output_tab_char
argument_list|,
operator|&
name|chars_per_output_tab
argument_list|)
expr_stmt|;
comment|/* Could check tab width> 0. */
name|tabify_output
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|lines_per_page
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|parallel_files
operator|=
name|TRUE
expr_stmt|;
name|storing_columns
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|numbered_lines
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|optarg
condition|)
name|getoptarg
argument_list|(
name|optarg
argument_list|,
literal|'n'
argument_list|,
operator|&
name|number_separator
argument_list|,
operator|&
name|chars_per_number
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|chars_per_margin
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|ignore_failed_opens
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|use_column_separator
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|optarg
condition|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|optarg
expr_stmt|;
name|column_separator
operator|=
operator|*
name|s
expr_stmt|;
if|if
condition|(
operator|*
operator|++
name|s
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ %s: extra characters in the argument to the `-s' option: `%s'\n"
argument_list|,
name|program_name
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'t'
case|:
name|extremities
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|use_esc_sequence
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|chars_per_line
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|flag_version
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|version_string
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_help
condition|)
name|usage
argument_list|()
expr_stmt|;
if|if
condition|(
name|parallel_files
operator|&&
name|explicit_columns
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Cannot specify number of columns when printing in parallel."
argument_list|)
expr_stmt|;
if|if
condition|(
name|parallel_files
operator|&&
name|print_across_flag
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Cannot specify both printing across and printing in parallel."
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|optind
operator|<
name|argc
condition|;
name|optind
operator|++
control|)
block|{
name|file_names
index|[
name|n_files
operator|++
index|]
operator|=
name|argv
index|[
name|optind
index|]
expr_stmt|;
block|}
if|if
condition|(
name|n_files
operator|==
literal|0
condition|)
block|{
comment|/* No file arguments specified;  read from standard input.  */
name|print_files
argument_list|(
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|parallel_files
condition|)
name|print_files
argument_list|(
name|n_files
argument_list|,
name|file_names
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_files
condition|;
name|i
operator|++
control|)
name|print_files
argument_list|(
literal|1
argument_list|,
operator|&
name|file_names
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|cleanup
argument_list|()
expr_stmt|;
if|if
condition|(
name|have_read_stdin
operator|&&
name|fclose
argument_list|(
name|stdin
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"standard input"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|stdout
argument_list|)
operator|||
name|fclose
argument_list|(
name|stdout
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"write error"
argument_list|)
expr_stmt|;
if|if
condition|(
name|failed_opens
operator|>
literal|0
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse options of the form -scNNN.     Example: -nck, where 'n' is the option, c is the optional number    separator, and k is the optional width of the field used when printing    a number. */
end_comment

begin_function
specifier|static
name|void
name|getoptarg
parameter_list|(
name|arg
parameter_list|,
name|switch_char
parameter_list|,
name|character
parameter_list|,
name|number
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|,
name|switch_char
decl_stmt|,
decl|*
name|character
decl_stmt|;
end_function

begin_decl_stmt
name|int
modifier|*
name|number
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|ISDIGIT
argument_list|(
operator|*
name|arg
argument_list|)
condition|)
operator|*
name|character
operator|=
operator|*
name|arg
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|arg
condition|)
block|{
if|if
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|arg
argument_list|)
condition|)
operator|*
name|number
operator|=
name|atoi
argument_list|(
name|arg
argument_list|)
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ %s: extra characters in the argument to the `-%c' option: `%s'\n"
argument_list|,
name|program_name
argument_list|,
name|switch_char
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Set parameters related to formatting. */
end_comment

begin_function
specifier|static
name|void
name|init_parameters
parameter_list|(
name|number_of_files
parameter_list|)
name|int
name|number_of_files
decl_stmt|;
block|{
name|int
name|chars_used_by_number
init|=
literal|0
decl_stmt|;
name|lines_per_body
operator|=
name|lines_per_page
operator|-
name|lines_per_header
operator|-
name|lines_per_footer
expr_stmt|;
if|if
condition|(
name|lines_per_body
operator|<=
literal|0
condition|)
name|extremities
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|extremities
operator|==
name|FALSE
condition|)
name|lines_per_body
operator|=
name|lines_per_page
expr_stmt|;
if|if
condition|(
name|double_space
condition|)
name|lines_per_body
operator|=
name|lines_per_body
operator|/
literal|2
expr_stmt|;
comment|/* If input is stdin, cannot print parallel files.  BSD dumps core      on this. */
if|if
condition|(
name|number_of_files
operator|==
literal|0
condition|)
name|parallel_files
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|parallel_files
condition|)
name|columns
operator|=
name|number_of_files
expr_stmt|;
comment|/* Tabification is assumed for multiple columns. */
if|if
condition|(
name|columns
operator|>
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|use_column_separator
condition|)
name|truncate_lines
operator|=
name|TRUE
expr_stmt|;
name|untabify_input
operator|=
name|TRUE
expr_stmt|;
name|tabify_output
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
name|storing_columns
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|numbered_lines
condition|)
block|{
if|if
condition|(
name|number_separator
operator|==
name|input_tab_char
condition|)
block|{
name|number_width
operator|=
name|chars_per_number
operator|+
name|tab_width
argument_list|(
name|chars_per_input_tab
argument_list|,
operator|(
name|chars_per_margin
operator|+
name|chars_per_number
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
name|number_width
operator|=
name|chars_per_number
operator|+
literal|1
expr_stmt|;
comment|/* The number is part of the column width unless we are          printing files in parallel. */
if|if
condition|(
name|parallel_files
condition|)
name|chars_used_by_number
operator|=
name|number_width
expr_stmt|;
block|}
name|chars_per_column
operator|=
operator|(
name|chars_per_line
operator|-
name|chars_used_by_number
operator|-
operator|(
name|columns
operator|-
literal|1
operator|)
operator|*
name|chars_per_gutter
operator|)
operator|/
name|columns
expr_stmt|;
if|if
condition|(
name|chars_per_column
operator|<
literal|1
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"page width too narrow"
argument_list|)
expr_stmt|;
if|if
condition|(
name|numbered_lines
condition|)
block|{
if|if
condition|(
name|number_buff
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
name|free
argument_list|(
name|number_buff
argument_list|)
expr_stmt|;
name|number_buff
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|2
operator|*
name|chars_per_number
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Pick the maximum between the tab width and the width of an      escape sequence. */
if|if
condition|(
name|clump_buff
operator|!=
operator|(
name|int
operator|*
operator|)
literal|0
condition|)
name|free
argument_list|(
name|clump_buff
argument_list|)
expr_stmt|;
name|clump_buff
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|chars_per_input_tab
operator|>
literal|4
condition|?
name|chars_per_input_tab
else|:
literal|4
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Open the necessary files,    maintaining a COLUMN structure for each column.     With multiple files, each column p has a different p->fp.    With single files, each column p has the same p->fp.    Return 1 if (number_of_files> 0) and no files can be opened,    0 otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|init_fps
parameter_list|(
name|number_of_files
parameter_list|,
name|av
parameter_list|)
name|int
name|number_of_files
decl_stmt|;
name|char
modifier|*
modifier|*
name|av
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|files_left
decl_stmt|;
name|COLUMN
modifier|*
name|p
decl_stmt|;
name|FILE
modifier|*
name|firstfp
decl_stmt|;
name|char
modifier|*
name|firstname
decl_stmt|;
name|total_files
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|column_vector
operator|!=
name|NULLCOL
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|column_vector
argument_list|)
expr_stmt|;
name|column_vector
operator|=
operator|(
name|COLUMN
operator|*
operator|)
name|xmalloc
argument_list|(
name|columns
operator|*
sizeof|sizeof
argument_list|(
name|COLUMN
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|parallel_files
condition|)
block|{
name|files_left
operator|=
name|number_of_files
expr_stmt|;
for|for
control|(
name|p
operator|=
name|column_vector
init|;
name|files_left
operator|--
condition|;
operator|++
name|p
operator|,
operator|++
name|av
control|)
block|{
if|if
condition|(
name|open_file
argument_list|(
operator|*
name|av
argument_list|,
name|p
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|--
name|p
expr_stmt|;
operator|--
name|columns
expr_stmt|;
block|}
block|}
if|if
condition|(
name|columns
operator|==
literal|0
condition|)
return|return
literal|1
return|;
name|init_header
argument_list|(
literal|""
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|column_vector
expr_stmt|;
if|if
condition|(
name|number_of_files
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|open_file
argument_list|(
operator|*
name|av
argument_list|,
name|p
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
name|init_header
argument_list|(
operator|*
name|av
argument_list|,
name|fileno
argument_list|(
name|p
operator|->
name|fp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|name
operator|=
literal|"standard input"
expr_stmt|;
name|p
operator|->
name|fp
operator|=
name|stdin
expr_stmt|;
name|have_read_stdin
operator|=
name|TRUE
expr_stmt|;
name|p
operator|->
name|status
operator|=
name|OPEN
expr_stmt|;
operator|++
name|total_files
expr_stmt|;
name|init_header
argument_list|(
literal|""
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|firstname
operator|=
name|p
operator|->
name|name
expr_stmt|;
name|firstfp
operator|=
name|p
operator|->
name|fp
expr_stmt|;
for|for
control|(
name|i
operator|=
name|columns
operator|-
literal|1
operator|,
operator|++
name|p
init|;
name|i
condition|;
operator|--
name|i
operator|,
operator|++
name|p
control|)
block|{
name|p
operator|->
name|name
operator|=
name|firstname
expr_stmt|;
name|p
operator|->
name|fp
operator|=
name|firstfp
expr_stmt|;
name|p
operator|->
name|status
operator|=
name|OPEN
expr_stmt|;
block|}
block|}
name|files_ready_to_read
operator|=
name|total_files
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Determine print_func and char_func, the functions    used by each column for printing and/or storing.     Determine the horizontal position desired when we begin    printing a column (p->start_position). */
end_comment

begin_function
specifier|static
name|void
name|init_funcs
parameter_list|()
block|{
name|int
name|i
decl_stmt|,
name|h
decl_stmt|,
name|h_next
decl_stmt|;
name|COLUMN
modifier|*
name|p
decl_stmt|;
name|h
operator|=
name|chars_per_margin
expr_stmt|;
if|if
condition|(
name|use_column_separator
condition|)
name|h_next
operator|=
name|ANYWHERE
expr_stmt|;
else|else
block|{
comment|/* When numbering lines of parallel files, we enlarge the          first column to accomodate the number.  Looks better than          the Sys V approach. */
if|if
condition|(
name|parallel_files
operator|&&
name|numbered_lines
condition|)
name|h_next
operator|=
name|h
operator|+
name|chars_per_column
operator|+
name|number_width
expr_stmt|;
else|else
name|h_next
operator|=
name|h
operator|+
name|chars_per_column
expr_stmt|;
block|}
comment|/* This loop takes care of all but the rightmost column. */
for|for
control|(
name|p
operator|=
name|column_vector
operator|,
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|columns
condition|;
operator|++
name|p
operator|,
operator|++
name|i
control|)
block|{
if|if
condition|(
name|storing_columns
condition|)
comment|/* One file, multi columns down. */
block|{
name|p
operator|->
name|char_func
operator|=
name|store_char
expr_stmt|;
name|p
operator|->
name|print_func
operator|=
name|print_stored
expr_stmt|;
block|}
else|else
comment|/* One file, multi columns across; or parallel files.  */
block|{
name|p
operator|->
name|char_func
operator|=
name|print_char
expr_stmt|;
name|p
operator|->
name|print_func
operator|=
name|read_line
expr_stmt|;
block|}
comment|/* Number only the first column when printing files in          parallel. */
name|p
operator|->
name|numbered
operator|=
name|numbered_lines
operator|&&
operator|(
operator|!
name|parallel_files
operator|||
name|i
operator|==
literal|1
operator|)
expr_stmt|;
name|p
operator|->
name|start_position
operator|=
name|h
expr_stmt|;
comment|/* If we're using separators, all start_positions are          ANYWHERE, except the first column's start_position when          using a margin. */
if|if
condition|(
name|use_column_separator
condition|)
block|{
name|h
operator|=
name|ANYWHERE
expr_stmt|;
name|h_next
operator|=
name|ANYWHERE
expr_stmt|;
block|}
else|else
block|{
name|h
operator|=
name|h_next
operator|+
name|chars_per_gutter
expr_stmt|;
name|h_next
operator|=
name|h
operator|+
name|chars_per_column
expr_stmt|;
block|}
block|}
comment|/* The rightmost column.       Doesn't need to be stored unless we intend to balance      columns on the last page. */
if|if
condition|(
name|storing_columns
operator|&&
name|balance_columns
condition|)
block|{
name|p
operator|->
name|char_func
operator|=
name|store_char
expr_stmt|;
name|p
operator|->
name|print_func
operator|=
name|print_stored
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|char_func
operator|=
name|print_char
expr_stmt|;
name|p
operator|->
name|print_func
operator|=
name|read_line
expr_stmt|;
block|}
name|p
operator|->
name|numbered
operator|=
name|numbered_lines
operator|&&
operator|(
operator|!
name|parallel_files
operator|||
name|i
operator|==
literal|1
operator|)
expr_stmt|;
name|p
operator|->
name|start_position
operator|=
name|h
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Open a file.  Return nonzero if successful, zero if failed. */
end_comment

begin_function
specifier|static
name|int
name|open_file
parameter_list|(
name|name
parameter_list|,
name|p
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|COLUMN
modifier|*
name|p
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"-"
argument_list|)
condition|)
block|{
name|p
operator|->
name|name
operator|=
literal|"standard input"
expr_stmt|;
name|p
operator|->
name|fp
operator|=
name|stdin
expr_stmt|;
name|have_read_stdin
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|p
operator|->
name|fp
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|fp
operator|==
name|NULL
condition|)
block|{
operator|++
name|failed_opens
expr_stmt|;
if|if
condition|(
operator|!
name|ignore_failed_opens
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|p
operator|->
name|status
operator|=
name|OPEN
expr_stmt|;
operator|++
name|total_files
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Close the file in P.     If we aren't dealing with multiple files in parallel, we change    the status of all columns in the column list to reflect the close. */
end_comment

begin_function
specifier|static
name|void
name|close_file
parameter_list|(
name|p
parameter_list|)
name|COLUMN
modifier|*
name|p
decl_stmt|;
block|{
name|COLUMN
modifier|*
name|q
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|status
operator|==
name|CLOSED
condition|)
return|return;
if|if
condition|(
name|ferror
argument_list|(
name|p
operator|->
name|fp
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|fp
operator|!=
name|stdin
operator|&&
name|fclose
argument_list|(
name|p
operator|->
name|fp
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parallel_files
condition|)
block|{
for|for
control|(
name|q
operator|=
name|column_vector
operator|,
name|i
operator|=
name|columns
init|;
name|i
condition|;
operator|++
name|q
operator|,
operator|--
name|i
control|)
block|{
name|q
operator|->
name|status
operator|=
name|CLOSED
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|lines_stored
operator|==
literal|0
condition|)
block|{
name|q
operator|->
name|lines_to_print
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|p
operator|->
name|status
operator|=
name|CLOSED
expr_stmt|;
name|p
operator|->
name|lines_to_print
operator|=
literal|0
expr_stmt|;
block|}
operator|--
name|files_ready_to_read
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Put a file on hold until we start a new page,    since we've hit a form feed.     If we aren't dealing with parallel files, we must change the    status of all columns in the column list. */
end_comment

begin_function
specifier|static
name|void
name|hold_file
parameter_list|(
name|p
parameter_list|)
name|COLUMN
modifier|*
name|p
decl_stmt|;
block|{
name|COLUMN
modifier|*
name|q
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|parallel_files
condition|)
for|for
control|(
name|q
operator|=
name|column_vector
operator|,
name|i
operator|=
name|columns
init|;
name|i
condition|;
operator|++
name|q
operator|,
operator|--
name|i
control|)
name|q
operator|->
name|status
operator|=
name|ON_HOLD
expr_stmt|;
else|else
name|p
operator|->
name|status
operator|=
name|ON_HOLD
expr_stmt|;
name|p
operator|->
name|lines_to_print
operator|=
literal|0
expr_stmt|;
operator|--
name|files_ready_to_read
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Undo hold_file -- go through the column list and change any    ON_HOLD columns to OPEN.  Used at the end of each page. */
end_comment

begin_function
specifier|static
name|void
name|reset_status
parameter_list|()
block|{
name|int
name|i
init|=
name|columns
decl_stmt|;
name|COLUMN
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|column_vector
init|;
name|i
condition|;
operator|--
name|i
operator|,
operator|++
name|p
control|)
if|if
condition|(
name|p
operator|->
name|status
operator|==
name|ON_HOLD
condition|)
block|{
name|p
operator|->
name|status
operator|=
name|OPEN
expr_stmt|;
name|files_ready_to_read
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print a single file, or multiple files in parallel.     Set up the list of columns, opening the necessary files.    Allocate space for storing columns, if necessary.    Skip to first_page_number, if user has asked to skip leading pages.    Determine which functions are appropriate to store/print lines    in each column.    Print the file(s). */
end_comment

begin_function
specifier|static
name|void
name|print_files
parameter_list|(
name|number_of_files
parameter_list|,
name|av
parameter_list|)
name|int
name|number_of_files
decl_stmt|;
name|char
modifier|*
modifier|*
name|av
decl_stmt|;
block|{
name|init_parameters
argument_list|(
name|number_of_files
argument_list|)
expr_stmt|;
if|if
condition|(
name|init_fps
argument_list|(
name|number_of_files
argument_list|,
name|av
argument_list|)
condition|)
return|return;
if|if
condition|(
name|storing_columns
condition|)
name|init_store_cols
argument_list|()
expr_stmt|;
if|if
condition|(
name|first_page_number
operator|>
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|skip_to_page
argument_list|(
name|first_page_number
argument_list|)
condition|)
return|return;
else|else
name|page_number
operator|=
name|first_page_number
expr_stmt|;
block|}
else|else
name|page_number
operator|=
literal|1
expr_stmt|;
name|init_funcs
argument_list|()
expr_stmt|;
name|line_number
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|print_page
argument_list|()
condition|)
empty_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generous estimate of number of characters taken up by "Jun  7 00:08 " and    "Page NNNNN". */
end_comment

begin_define
define|#
directive|define
name|CHARS_FOR_DATE_AND_PAGE
value|50
end_define

begin_comment
comment|/* Initialize header information.    If DESC is non-negative, it is a file descriptor open to    FILENAME for reading.     Allocate space for a header string,    Determine the time, insert file name or user-specified string.     It might be nice to have a "blank headers" option, since    pr -h "" still prints the date and page number. */
end_comment

begin_function
specifier|static
name|void
name|init_header
parameter_list|(
name|filename
parameter_list|,
name|desc
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|desc
decl_stmt|;
block|{
name|int
name|chars_per_header
decl_stmt|;
name|char
modifier|*
name|f
init|=
name|filename
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|,
modifier|*
name|middle
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
name|filename
operator|==
literal|0
condition|)
name|f
operator|=
literal|""
expr_stmt|;
comment|/* If parallel files or standard input, use current time. */
if|if
condition|(
name|desc
operator|<
literal|0
operator|||
operator|!
name|strcmp
argument_list|(
name|filename
argument_list|,
literal|"-"
argument_list|)
operator|||
name|fstat
argument_list|(
name|desc
argument_list|,
operator|&
name|st
argument_list|)
condition|)
name|st
operator|.
name|st_mtime
operator|=
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|t
operator|=
name|ctime
argument_list|(
operator|&
name|st
operator|.
name|st_mtime
argument_list|)
expr_stmt|;
name|t
index|[
literal|16
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Mark end of month and time string. */
name|t
index|[
literal|24
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Mark end of year string. */
name|middle
operator|=
name|standard_header
condition|?
name|f
else|:
name|custom_header
expr_stmt|;
name|chars_per_header
operator|=
name|strlen
argument_list|(
name|middle
argument_list|)
operator|+
name|CHARS_FOR_DATE_AND_PAGE
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|header
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
name|free
argument_list|(
name|header
argument_list|)
expr_stmt|;
name|header
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|chars_per_header
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|header
argument_list|,
literal|"%s %s  %s Page"
argument_list|,
operator|&
name|t
index|[
literal|4
index|]
argument_list|,
operator|&
name|t
index|[
literal|20
index|]
argument_list|,
name|middle
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Set things up for printing a page     Scan through the columns ...      Determine which are ready to print        (i.e., which have lines stored or open files)      Set p->lines_to_print appropriately        (to p->lines_stored if we're storing, or lines_per_body        if we're reading straight from the file)      Keep track of this total so we know when to stop printing */
end_comment

begin_function
specifier|static
name|void
name|init_page
parameter_list|()
block|{
name|int
name|j
decl_stmt|;
name|COLUMN
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|storing_columns
condition|)
block|{
name|store_columns
argument_list|()
expr_stmt|;
for|for
control|(
name|j
operator|=
name|columns
operator|-
literal|1
operator|,
name|p
operator|=
name|column_vector
init|;
name|j
condition|;
operator|--
name|j
operator|,
operator|++
name|p
control|)
block|{
name|p
operator|->
name|lines_to_print
operator|=
name|p
operator|->
name|lines_stored
expr_stmt|;
block|}
comment|/* Last column. */
if|if
condition|(
name|balance_columns
condition|)
block|{
name|p
operator|->
name|lines_to_print
operator|=
name|p
operator|->
name|lines_stored
expr_stmt|;
block|}
comment|/* Since we're not balancing columns, we don't need to store          the rightmost column.   Read it straight from the file. */
else|else
block|{
if|if
condition|(
name|p
operator|->
name|status
operator|==
name|OPEN
condition|)
block|{
name|p
operator|->
name|lines_to_print
operator|=
name|lines_per_body
expr_stmt|;
block|}
else|else
name|p
operator|->
name|lines_to_print
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
for|for
control|(
name|j
operator|=
name|columns
operator|,
name|p
operator|=
name|column_vector
init|;
name|j
condition|;
operator|--
name|j
operator|,
operator|++
name|p
control|)
if|if
condition|(
name|p
operator|->
name|status
operator|==
name|OPEN
condition|)
block|{
name|p
operator|->
name|lines_to_print
operator|=
name|lines_per_body
expr_stmt|;
block|}
else|else
name|p
operator|->
name|lines_to_print
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print one page.     As long as there are lines left on the page and columns ready to print,      Scan across the column list        if the column has stored lines or the file is open          pad to the appropriate spot          print the column    pad the remainder of the page with \n or \f as requested    reset the status of all files -- any files which where on hold because      of formfeeds are now put back into the lineup. */
end_comment

begin_function
specifier|static
name|int
name|print_page
parameter_list|()
block|{
name|int
name|j
decl_stmt|;
name|int
name|lines_left_on_page
decl_stmt|;
name|COLUMN
modifier|*
name|p
decl_stmt|;
comment|/* Used as an accumulator (with | operator) of successive values of      pad_vertically.  The trick is to set pad_vertically      to zero before each run through the inner loop, then after that      loop, it tells us whether a line was actually printed (whether a      newline needs to be output -- or two for double spacing).  But those      values have to be accumulated (in pv) so we can invoke pad_down      properly after the outer loop completes. */
name|int
name|pv
decl_stmt|;
name|init_page
argument_list|()
expr_stmt|;
if|if
condition|(
name|cols_ready_to_print
argument_list|()
operator|==
literal|0
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|extremities
condition|)
name|print_a_header
operator|=
name|TRUE
expr_stmt|;
comment|/* Don't pad unless we know a page was printed. */
name|pad_vertically
operator|=
name|FALSE
expr_stmt|;
name|pv
operator|=
name|FALSE
expr_stmt|;
name|lines_left_on_page
operator|=
name|lines_per_body
expr_stmt|;
if|if
condition|(
name|double_space
condition|)
name|lines_left_on_page
operator|*=
literal|2
expr_stmt|;
while|while
condition|(
name|lines_left_on_page
operator|>
literal|0
operator|&&
name|cols_ready_to_print
argument_list|()
operator|>
literal|0
condition|)
block|{
name|output_position
operator|=
literal|0
expr_stmt|;
name|spaces_not_printed
operator|=
literal|0
expr_stmt|;
name|separators_not_printed
operator|=
literal|0
expr_stmt|;
name|pad_vertically
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
operator|,
name|p
operator|=
name|column_vector
init|;
name|j
operator|<=
name|columns
condition|;
operator|++
name|j
operator|,
operator|++
name|p
control|)
block|{
name|input_position
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|lines_to_print
operator|>
literal|0
condition|)
block|{
name|padding_not_printed
operator|=
name|p
operator|->
name|start_position
expr_stmt|;
if|if
condition|(
operator|!
call|(
name|p
operator|->
name|print_func
call|)
argument_list|(
name|p
argument_list|)
condition|)
name|read_rest_of_line
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|pv
operator||=
name|pad_vertically
expr_stmt|;
if|if
condition|(
name|use_column_separator
condition|)
operator|++
name|separators_not_printed
expr_stmt|;
operator|--
name|p
operator|->
name|lines_to_print
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|lines_to_print
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|cols_ready_to_print
argument_list|()
operator|<=
literal|0
condition|)
break|break;
block|}
block|}
block|}
if|if
condition|(
name|pad_vertically
condition|)
block|{
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
operator|--
name|lines_left_on_page
expr_stmt|;
block|}
if|if
condition|(
name|double_space
operator|&&
name|pv
operator|&&
name|extremities
condition|)
block|{
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
operator|--
name|lines_left_on_page
expr_stmt|;
block|}
block|}
name|pad_vertically
operator|=
name|pv
expr_stmt|;
if|if
condition|(
name|pad_vertically
operator|&&
name|extremities
condition|)
name|pad_down
argument_list|(
name|lines_left_on_page
operator|+
name|lines_per_footer
argument_list|)
expr_stmt|;
name|reset_status
argument_list|()
expr_stmt|;
comment|/* Change ON_HOLD to OPEN. */
return|return
name|TRUE
return|;
comment|/* More pages to go. */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Allocate space for storing columns.     This is necessary when printing multiple columns from a single file.    Lines are stored consecutively in buff, separated by '\0'.    (We can't use a fixed offset since with the '-s' flag lines aren't    truncated.)     We maintain a list (line_vector) of pointers to the beginnings    of lines in buff.  We allocate one more than the number of lines    because the last entry tells us the index of the last character,    which we need to know in order to print the last line in buff. */
end_comment

begin_function
specifier|static
name|void
name|init_store_cols
parameter_list|()
block|{
name|int
name|total_lines
init|=
name|lines_per_body
operator|*
name|columns
decl_stmt|;
name|int
name|chars_if_truncate
init|=
name|total_lines
operator|*
operator|(
name|chars_per_column
operator|+
literal|1
operator|)
decl_stmt|;
if|if
condition|(
name|line_vector
operator|!=
operator|(
name|int
operator|*
operator|)
literal|0
condition|)
name|free
argument_list|(
operator|(
name|int
operator|*
operator|)
name|line_vector
argument_list|)
expr_stmt|;
name|line_vector
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|total_lines
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|end_vector
operator|!=
operator|(
name|int
operator|*
operator|)
literal|0
condition|)
name|free
argument_list|(
operator|(
name|int
operator|*
operator|)
name|end_vector
argument_list|)
expr_stmt|;
name|end_vector
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|total_lines
operator|*
sizeof|sizeof
argument_list|(
name|int
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|buff
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
name|free
argument_list|(
name|buff
argument_list|)
expr_stmt|;
name|buff_allocated
operator|=
name|use_column_separator
condition|?
literal|2
operator|*
name|chars_if_truncate
else|:
name|chars_if_truncate
expr_stmt|;
comment|/* Tune this. */
name|buff
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|buff_allocated
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Store all but the rightmost column.    (Used when printing a single file in multiple downward columns)     For each column      set p->current_line to be the index in line_vector of the        first line in the column      For each line in the column        store the line in buff        add to line_vector the index of the line's first char     buff_start is the index in buff of the first character in the      current line. */
end_comment

begin_function
specifier|static
name|void
name|store_columns
parameter_list|()
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|line
init|=
literal|0
decl_stmt|;
name|int
name|buff_start
decl_stmt|;
name|int
name|last_col
decl_stmt|;
comment|/* The rightmost column which will be saved in buff */
name|COLUMN
modifier|*
name|p
decl_stmt|;
name|buff_current
operator|=
literal|0
expr_stmt|;
name|buff_start
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|balance_columns
condition|)
name|last_col
operator|=
name|columns
expr_stmt|;
else|else
name|last_col
operator|=
name|columns
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|p
operator|=
name|column_vector
init|;
name|i
operator|<=
name|last_col
condition|;
operator|++
name|i
operator|,
operator|++
name|p
control|)
name|p
operator|->
name|lines_stored
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|p
operator|=
name|column_vector
init|;
name|i
operator|<=
name|last_col
operator|&&
name|files_ready_to_read
condition|;
operator|++
name|i
operator|,
operator|++
name|p
control|)
block|{
name|p
operator|->
name|current_line
operator|=
name|line
expr_stmt|;
for|for
control|(
name|j
operator|=
name|lines_per_body
init|;
name|j
operator|&&
name|files_ready_to_read
condition|;
operator|--
name|j
control|)
if|if
condition|(
name|p
operator|->
name|status
operator|==
name|OPEN
condition|)
comment|/* Redundant.  Clean up. */
block|{
name|input_position
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|read_line
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
condition|)
name|read_rest_of_line
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|status
operator|==
name|OPEN
operator|||
name|buff_start
operator|!=
name|buff_current
condition|)
block|{
operator|++
name|p
operator|->
name|lines_stored
expr_stmt|;
name|line_vector
index|[
name|line
index|]
operator|=
name|buff_start
expr_stmt|;
name|end_vector
index|[
name|line
operator|++
index|]
operator|=
name|input_position
expr_stmt|;
name|buff_start
operator|=
name|buff_current
expr_stmt|;
block|}
block|}
block|}
comment|/* Keep track of the location of the last char in buff. */
name|line_vector
index|[
name|line
index|]
operator|=
name|buff_start
expr_stmt|;
if|if
condition|(
name|balance_columns
operator|&&
name|p
operator|->
name|lines_stored
operator|!=
name|lines_per_body
condition|)
name|balance
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|balance
parameter_list|(
name|total_stored
parameter_list|)
name|int
name|total_stored
decl_stmt|;
block|{
name|COLUMN
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|,
name|lines
decl_stmt|;
name|int
name|first_line
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|p
operator|=
name|column_vector
init|;
name|i
operator|<=
name|columns
condition|;
operator|++
name|i
operator|,
operator|++
name|p
control|)
block|{
name|lines
operator|=
name|total_stored
operator|/
name|columns
expr_stmt|;
if|if
condition|(
name|i
operator|<=
name|total_stored
operator|%
name|columns
condition|)
operator|++
name|lines
expr_stmt|;
name|p
operator|->
name|lines_stored
operator|=
name|lines
expr_stmt|;
name|p
operator|->
name|current_line
operator|=
name|first_line
expr_stmt|;
name|first_line
operator|+=
name|lines
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Store a character in the buffer. */
end_comment

begin_function
specifier|static
name|void
name|store_char
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
if|if
condition|(
name|buff_current
operator|>=
name|buff_allocated
condition|)
block|{
comment|/* May be too generous. */
name|buff_allocated
operator|=
literal|2
operator|*
name|buff_allocated
expr_stmt|;
name|buff
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|buff
argument_list|,
name|buff_allocated
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|buff
index|[
name|buff_current
operator|++
index|]
operator|=
operator|(
name|char
operator|)
name|c
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|number
parameter_list|(
name|p
parameter_list|)
name|COLUMN
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|sprintf
argument_list|(
name|number_buff
argument_list|,
literal|"%*d"
argument_list|,
name|chars_per_number
argument_list|,
name|line_number
operator|++
argument_list|)
expr_stmt|;
name|s
operator|=
name|number_buff
expr_stmt|;
for|for
control|(
name|i
operator|=
name|chars_per_number
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
call|(
name|p
operator|->
name|char_func
call|)
argument_list|(
operator|(
name|int
operator|)
operator|*
name|s
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|number_separator
operator|==
name|input_tab_char
condition|)
block|{
name|i
operator|=
name|number_width
operator|-
name|chars_per_number
expr_stmt|;
while|while
condition|(
name|i
operator|--
operator|>
literal|0
condition|)
call|(
name|p
operator|->
name|char_func
call|)
argument_list|(
operator|(
name|int
operator|)
literal|' '
argument_list|)
expr_stmt|;
block|}
else|else
call|(
name|p
operator|->
name|char_func
call|)
argument_list|(
operator|(
name|int
operator|)
name|number_separator
argument_list|)
expr_stmt|;
if|if
condition|(
name|truncate_lines
operator|&&
operator|!
name|parallel_files
condition|)
name|input_position
operator|+=
name|number_width
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print (or store) padding until the current horizontal position    is position. */
end_comment

begin_function
specifier|static
name|void
name|pad_across_to
parameter_list|(
name|position
parameter_list|)
name|int
name|position
decl_stmt|;
block|{
specifier|register
name|int
name|h
init|=
name|output_position
decl_stmt|;
if|if
condition|(
name|tabify_output
condition|)
name|spaces_not_printed
operator|=
name|position
operator|-
name|output_position
expr_stmt|;
else|else
block|{
while|while
condition|(
operator|++
name|h
operator|<=
name|position
condition|)
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|output_position
operator|=
name|position
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Pad to the bottom of the page.     If the user has requested a formfeed, use one.    Otherwise, use newlines. */
end_comment

begin_function
specifier|static
name|void
name|pad_down
parameter_list|(
name|lines
parameter_list|)
name|int
name|lines
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|use_form_feed
condition|)
name|putchar
argument_list|(
literal|'\f'
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
name|lines
init|;
name|i
condition|;
operator|--
name|i
control|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read the rest of the line.     Read from the current column's file until an end of line is    hit.  Used when we've truncated a line and we no longer need    to print or store its characters. */
end_comment

begin_function
specifier|static
name|void
name|read_rest_of_line
parameter_list|(
name|p
parameter_list|)
name|COLUMN
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|FILE
modifier|*
name|f
init|=
name|p
operator|->
name|fp
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|f
argument_list|)
operator|)
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\f'
condition|)
block|{
name|hold_file
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
name|close_file
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If we're tabifying output,     When print_char encounters white space it keeps track    of our desired horizontal position and delays printing    until this function is called. */
end_comment

begin_function
specifier|static
name|void
name|print_white_space
parameter_list|()
block|{
specifier|register
name|int
name|h_new
decl_stmt|;
specifier|register
name|int
name|h_old
init|=
name|output_position
decl_stmt|;
specifier|register
name|int
name|goal
init|=
name|h_old
operator|+
name|spaces_not_printed
decl_stmt|;
while|while
condition|(
name|goal
operator|-
name|h_old
operator|>
literal|1
operator|&&
operator|(
name|h_new
operator|=
name|pos_after_tab
argument_list|(
name|chars_per_output_tab
argument_list|,
name|h_old
argument_list|)
operator|)
operator|<=
name|goal
condition|)
block|{
name|putchar
argument_list|(
name|output_tab_char
argument_list|)
expr_stmt|;
name|h_old
operator|=
name|h_new
expr_stmt|;
block|}
while|while
condition|(
operator|++
name|h_old
operator|<=
name|goal
condition|)
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|output_position
operator|=
name|goal
expr_stmt|;
name|spaces_not_printed
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print column separators.     We keep a count until we know that we'll be printing a line,    then print_separators() is called. */
end_comment

begin_function
specifier|static
name|void
name|print_separators
parameter_list|()
block|{
for|for
control|(
init|;
name|separators_not_printed
operator|>
literal|0
condition|;
operator|--
name|separators_not_printed
control|)
name|print_char
argument_list|(
name|column_separator
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print (or store, depending on p->char_func) a clump of N    characters. */
end_comment

begin_function
specifier|static
name|void
name|print_clump
parameter_list|(
name|p
parameter_list|,
name|n
parameter_list|,
name|clump
parameter_list|)
name|COLUMN
modifier|*
name|p
decl_stmt|;
name|int
name|n
decl_stmt|;
name|int
modifier|*
name|clump
decl_stmt|;
block|{
while|while
condition|(
name|n
operator|--
condition|)
call|(
name|p
operator|->
name|char_func
call|)
argument_list|(
operator|*
name|clump
operator|++
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print a character.     If we're tabifying, all tabs have been converted to spaces by    process_char().  Keep a count of consecutive spaces, and when    a nonspace is encountered, call print_white_space() to print the    required number of tabs and spaces. */
end_comment

begin_function
specifier|static
name|void
name|print_char
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
if|if
condition|(
name|tabify_output
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|' '
condition|)
block|{
operator|++
name|spaces_not_printed
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|spaces_not_printed
operator|>
literal|0
condition|)
name|print_white_space
argument_list|()
expr_stmt|;
comment|/* Nonprintables are assumed to have width 0, except '\b'. */
if|if
condition|(
operator|!
name|ISPRINT
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\b'
condition|)
operator|--
name|output_position
expr_stmt|;
block|}
else|else
operator|++
name|output_position
expr_stmt|;
block|}
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Skip to page PAGE before printing. */
end_comment

begin_function
specifier|static
name|int
name|skip_to_page
parameter_list|(
name|page
parameter_list|)
name|int
name|page
decl_stmt|;
block|{
name|int
name|n
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|COLUMN
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|1
init|;
name|n
operator|<
name|page
condition|;
operator|++
name|n
control|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|lines_per_body
condition|;
operator|++
name|i
control|)
block|{
for|for
control|(
name|j
operator|=
literal|1
operator|,
name|p
operator|=
name|column_vector
init|;
name|j
operator|<=
name|columns
condition|;
operator|++
name|j
operator|,
operator|++
name|p
control|)
name|read_rest_of_line
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|reset_status
argument_list|()
expr_stmt|;
block|}
return|return
name|files_ready_to_read
operator|>
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Print a header.     Formfeeds are assumed to use up two lines at the beginning of    the page. */
end_comment

begin_function
specifier|static
name|void
name|print_header
parameter_list|()
block|{
if|if
condition|(
operator|!
name|use_form_feed
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
name|output_position
operator|=
literal|0
expr_stmt|;
name|pad_across_to
argument_list|(
name|chars_per_margin
argument_list|)
expr_stmt|;
name|print_white_space
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s %d\n\n\n"
argument_list|,
name|header
argument_list|,
name|page_number
operator|++
argument_list|)
expr_stmt|;
name|print_a_header
operator|=
name|FALSE
expr_stmt|;
name|output_position
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print (or store, if p->char_func is store_char()) a line.     Read a character to determine whether we have a line or not.    (We may hit EOF, \n, or \f)     Once we know we have a line,      set pad_vertically = TRUE, meaning it's safe        to pad down at the end of the page, since we do have a page.        print a header if needed.      pad across to padding_not_printed if needed.      print any separators which need to be printed.      print a line number if it needs to be printed.     Print the clump which corresponds to the first character.     Enter a loop and keep printing until an end of line condition      exists, or until we exceed chars_per_column.     Return FALSE if we exceed chars_per_column before reading      an end of line character, TRUE otherwise. */
end_comment

begin_function
specifier|static
name|int
name|read_line
parameter_list|(
name|p
parameter_list|)
name|COLUMN
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|,
name|chars
decl_stmt|;
name|int
name|last_input_position
decl_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|p
operator|->
name|fp
argument_list|)
expr_stmt|;
name|last_input_position
operator|=
name|input_position
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\f'
case|:
name|hold_file
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
case|case
name|EOF
case|:
name|close_file
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
case|case
literal|'\n'
case|:
break|break;
default|default:
name|chars
operator|=
name|char_to_clump
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|truncate_lines
operator|&&
name|input_position
operator|>
name|chars_per_column
condition|)
block|{
name|input_position
operator|=
name|last_input_position
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|p
operator|->
name|char_func
operator|!=
name|store_char
condition|)
block|{
name|pad_vertically
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|print_a_header
condition|)
name|print_header
argument_list|()
expr_stmt|;
if|if
condition|(
name|padding_not_printed
operator|!=
name|ANYWHERE
condition|)
block|{
name|pad_across_to
argument_list|(
name|padding_not_printed
argument_list|)
expr_stmt|;
name|padding_not_printed
operator|=
name|ANYWHERE
expr_stmt|;
block|}
if|if
condition|(
name|use_column_separator
condition|)
name|print_separators
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|numbered
condition|)
name|number
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
return|return
name|TRUE
return|;
name|print_clump
argument_list|(
name|p
argument_list|,
name|chars
argument_list|,
name|clump_buff
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|getc
argument_list|(
name|p
operator|->
name|fp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
return|return
name|TRUE
return|;
case|case
literal|'\f'
case|:
name|hold_file
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
case|case
name|EOF
case|:
name|close_file
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|last_input_position
operator|=
name|input_position
expr_stmt|;
name|chars
operator|=
name|char_to_clump
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|truncate_lines
operator|&&
name|input_position
operator|>
name|chars_per_column
condition|)
block|{
name|input_position
operator|=
name|last_input_position
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|print_clump
argument_list|(
name|p
argument_list|,
name|chars
argument_list|,
name|clump_buff
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print a line from buff.     If this function has been called, we know we have something to    print.  Therefore we set pad_vertically to TRUE, print    a header if necessary, pad across if necessary, and print    separators if necessary.     Return TRUE, meaning there is no need to call read_rest_of_line. */
end_comment

begin_function
specifier|static
name|int
name|print_stored
parameter_list|(
name|p
parameter_list|)
name|COLUMN
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|line
init|=
name|p
operator|->
name|current_line
operator|++
decl_stmt|;
specifier|register
name|char
modifier|*
name|first
init|=
operator|&
name|buff
index|[
name|line_vector
index|[
name|line
index|]
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|last
init|=
operator|&
name|buff
index|[
name|line_vector
index|[
name|line
operator|+
literal|1
index|]
index|]
decl_stmt|;
name|pad_vertically
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|print_a_header
condition|)
name|print_header
argument_list|()
expr_stmt|;
if|if
condition|(
name|padding_not_printed
operator|!=
name|ANYWHERE
condition|)
block|{
name|pad_across_to
argument_list|(
name|padding_not_printed
argument_list|)
expr_stmt|;
name|padding_not_printed
operator|=
name|ANYWHERE
expr_stmt|;
block|}
if|if
condition|(
name|use_column_separator
condition|)
name|print_separators
argument_list|()
expr_stmt|;
while|while
condition|(
name|first
operator|!=
name|last
condition|)
name|print_char
argument_list|(
operator|*
name|first
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|spaces_not_printed
operator|==
literal|0
condition|)
name|output_position
operator|=
name|p
operator|->
name|start_position
operator|+
name|end_vector
index|[
name|line
index|]
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Convert a character to the proper format and return the number of    characters in the resulting clump.  Increment input_position by    the width of the clump.     Tabs are converted to clumps of spaces.    Nonprintable characters may be converted to clumps of escape    sequences or control prefixes.     Note: the width of a clump is not necessarily equal to the number of    characters in clump_buff.  (e.g, the width of '\b' is -1, while the    number of characters is 1.) */
end_comment

begin_function
specifier|static
name|int
name|char_to_clump
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
specifier|register
name|int
modifier|*
name|s
init|=
name|clump_buff
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|char
name|esc_buff
index|[
literal|4
index|]
decl_stmt|;
name|int
name|width
decl_stmt|;
name|int
name|chars
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|input_tab_char
condition|)
block|{
name|width
operator|=
name|tab_width
argument_list|(
name|chars_per_input_tab
argument_list|,
name|input_position
argument_list|)
expr_stmt|;
if|if
condition|(
name|untabify_input
condition|)
block|{
for|for
control|(
name|i
operator|=
name|width
init|;
name|i
condition|;
operator|--
name|i
control|)
operator|*
name|s
operator|++
operator|=
literal|' '
expr_stmt|;
name|chars
operator|=
name|width
expr_stmt|;
block|}
else|else
block|{
operator|*
name|s
operator|=
name|c
expr_stmt|;
name|chars
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|ISPRINT
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|use_esc_sequence
condition|)
block|{
name|width
operator|=
literal|4
expr_stmt|;
name|chars
operator|=
literal|4
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|'\\'
expr_stmt|;
name|sprintf
argument_list|(
name|esc_buff
argument_list|,
literal|"%03o"
argument_list|,
name|c
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|2
condition|;
operator|++
name|i
control|)
operator|*
name|s
operator|++
operator|=
operator|(
name|int
operator|)
name|esc_buff
index|[
name|i
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|use_cntrl_prefix
condition|)
block|{
if|if
condition|(
name|c
operator|<
literal|0200
condition|)
block|{
name|width
operator|=
literal|2
expr_stmt|;
name|chars
operator|=
literal|2
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|'^'
expr_stmt|;
operator|*
name|s
operator|++
operator|=
name|c
operator|^
literal|0100
expr_stmt|;
block|}
else|else
block|{
name|width
operator|=
literal|4
expr_stmt|;
name|chars
operator|=
literal|4
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|'\\'
expr_stmt|;
name|sprintf
argument_list|(
name|esc_buff
argument_list|,
literal|"%03o"
argument_list|,
name|c
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|2
condition|;
operator|++
name|i
control|)
operator|*
name|s
operator|++
operator|=
operator|(
name|int
operator|)
name|esc_buff
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\b'
condition|)
block|{
name|width
operator|=
operator|-
literal|1
expr_stmt|;
name|chars
operator|=
literal|1
expr_stmt|;
operator|*
name|s
operator|=
name|c
expr_stmt|;
block|}
else|else
block|{
name|width
operator|=
literal|0
expr_stmt|;
name|chars
operator|=
literal|1
expr_stmt|;
operator|*
name|s
operator|=
name|c
expr_stmt|;
block|}
block|}
else|else
block|{
name|width
operator|=
literal|1
expr_stmt|;
name|chars
operator|=
literal|1
expr_stmt|;
operator|*
name|s
operator|=
name|c
expr_stmt|;
block|}
name|input_position
operator|+=
name|width
expr_stmt|;
return|return
name|chars
return|;
block|}
end_function

begin_comment
comment|/* We've just printed some files and need to clean up things before    looking for more options and printing the next batch of files.     Free everything we've xmalloc'ed, except `header'. */
end_comment

begin_function
specifier|static
name|void
name|cleanup
parameter_list|()
block|{
if|if
condition|(
name|number_buff
condition|)
name|free
argument_list|(
name|number_buff
argument_list|)
expr_stmt|;
if|if
condition|(
name|clump_buff
condition|)
name|free
argument_list|(
name|clump_buff
argument_list|)
expr_stmt|;
if|if
condition|(
name|column_vector
condition|)
name|free
argument_list|(
name|column_vector
argument_list|)
expr_stmt|;
if|if
condition|(
name|line_vector
condition|)
name|free
argument_list|(
name|line_vector
argument_list|)
expr_stmt|;
if|if
condition|(
name|end_vector
condition|)
name|free
argument_list|(
name|end_vector
argument_list|)
expr_stmt|;
if|if
condition|(
name|buff
condition|)
name|free
argument_list|(
name|buff
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Complain, print a usage message, and die. */
end_comment

begin_function
specifier|static
name|void
name|usage
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ Usage: %s [+PAGE] [-COLUMN] [-abcdfFmrtv] [-e[in-tab-char[in-tab-width]]]\n\        [-h header] [-i[out-tab-char[out-tab-width]]] [-l page-length]\n\        [-n[number-separator[digits]]] [-o left-margin]\n\        [-s[column-separator]] [-w page-width] [--help] [--version] [file...]\n"
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

