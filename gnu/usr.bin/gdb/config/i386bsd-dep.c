begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * This code is derived from software copyrighted by the Free Software  * Foundation.  *  * Modified 1991 by Donn Seeley at UUNET Technologies, Inc.  * Modified 1990 by Van Jacobson at Lawrence Berkeley Laboratory.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)i386bsd-dep.c	6.10 (Berkeley) 6/26/91"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/* Low level interface to ptrace, for GDB when running on the Intel 386.    Copyright (C) 1988, 1989 Free Software Foundation, Inc.  This file is part of GDB.  GDB is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GDB is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GDB; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|N_SET_MAGIC
end_ifndef

begin_define
define|#
directive|define
name|N_SET_MAGIC
parameter_list|(
name|exec
parameter_list|,
name|val
parameter_list|)
value|((exec).a_magic = (val))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_define
define|#
directive|define
name|curpcb
value|Xcurpcb
end_define

begin_comment
comment|/* XXX avoid leaking declaration from pcb.h */
end_comment

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_undef
undef|#
directive|undef
name|curpcb
end_undef

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_include
include|#
directive|include
file|<machine/reg.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|KERNELDEBUG
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|NEWVM
end_ifndef

begin_include
include|#
directive|include
file|<sys/vmmac.h>
end_include

begin_include
include|#
directive|include
file|<machine/pte.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_comment
comment|/* for curproc */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<machine/vmparam.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_comment
comment|/* XXX */
end_comment

begin_undef
undef|#
directive|undef
name|vtophys
end_undef

begin_comment
comment|/* XXX */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|kernel_debugging
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|KERNOFF
value|((unsigned)KERNBASE)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|NEWVM
end_ifndef

begin_define
define|#
directive|define
name|INKERNEL
parameter_list|(
name|x
parameter_list|)
value|((x)>= KERNOFF&& (x)< KERNOFF + ctob(slr))
end_define

begin_define
define|#
directive|define
name|INUPAGE
parameter_list|(
name|x
parameter_list|)
define|\
value|((x)>= KERNEL_U_ADDR&& (x)< KERNEL_U_ADDR + NBPG)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|INKERNEL
parameter_list|(
name|x
parameter_list|)
value|((x)>= KERNOFF)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|PT_ADDR_ANY
value|((caddr_t) 1)
end_define

begin_comment
comment|/*  * Convert from sysmap pte index to system virtual address& vice-versa.  * (why aren't these in one of the system vm macro files???)  */
end_comment

begin_define
define|#
directive|define
name|smxtob
parameter_list|(
name|a
parameter_list|)
value|(sbr + (a) * sizeof(pte))
end_define

begin_define
define|#
directive|define
name|btosmx
parameter_list|(
name|b
parameter_list|)
value|(((b) - sbr) / sizeof(pte))
end_define

begin_function_decl
specifier|static
name|int
name|ok_to_cache
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|found_pcb
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|NEWVM
end_ifdef

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|curpcb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|kstack
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|setregmap
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This function simply calls ptrace with the given arguments.  It exists so  * that all calls to ptrace are isolated in this machine-dependent file.   */
end_comment

begin_function
name|int
name|call_ptrace
parameter_list|(
name|request
parameter_list|,
name|pid
parameter_list|,
name|arg3
parameter_list|,
name|arg4
parameter_list|)
name|int
name|request
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|caddr_t
name|arg3
decl_stmt|;
name|int
name|arg4
decl_stmt|;
block|{
return|return
operator|(
name|ptrace
argument_list|(
name|request
argument_list|,
name|pid
argument_list|,
name|arg3
argument_list|,
name|arg4
argument_list|)
operator|)
return|;
block|}
end_function

begin_macro
name|kill_inferior
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|remote_debugging
condition|)
block|{
ifdef|#
directive|ifdef
name|KERNELDEBUG
if|if
condition|(
name|kernel_debugging
condition|)
comment|/* 			 * It's a very, very bad idea to go away leaving 			 * breakpoints in a remote kernel or to leave it 			 * stopped at a breakpoint.  			 */
name|clear_breakpoints
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|remote_close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|inferior_died
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|inferior_pid
operator|!=
literal|0
condition|)
block|{
name|ptrace
argument_list|(
name|PT_KILL
argument_list|,
name|inferior_pid
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wait
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|inferior_died
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * This is used when GDB is exiting.  It gives less chance of error.  */
end_comment

begin_macro
name|kill_inferior_fast
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|remote_debugging
condition|)
block|{
ifdef|#
directive|ifdef
name|KERNELDEBUG
if|if
condition|(
name|kernel_debugging
condition|)
name|clear_breakpoints
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|remote_close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|inferior_pid
operator|==
literal|0
condition|)
return|return;
name|ptrace
argument_list|(
name|PT_KILL
argument_list|,
name|inferior_pid
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wait
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Resume execution of the inferior process. If STEP is nonzero, single-step  * it. If SIGNAL is nonzero, give it that signal.    */
end_comment

begin_function
name|void
name|resume
parameter_list|(
name|step
parameter_list|,
name|signal
parameter_list|)
name|int
name|step
decl_stmt|;
name|int
name|signal
decl_stmt|;
block|{
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|remote_debugging
condition|)
name|remote_resume
argument_list|(
name|step
argument_list|,
name|signal
argument_list|)
expr_stmt|;
else|else
block|{
name|ptrace
argument_list|(
name|step
condition|?
name|PT_STEP
else|:
name|PT_CONTINUE
argument_list|,
name|inferior_pid
argument_list|,
name|PT_ADDR_ANY
argument_list|,
name|signal
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
name|perror_with_name
argument_list|(
literal|"ptrace"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ATTACH_DETACH
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|attach_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Start debugging the process whose number is PID.  */
end_comment

begin_macro
name|attach
argument_list|(
argument|pid
argument_list|)
end_macro

begin_decl_stmt
name|int
name|pid
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|ptrace
argument_list|(
name|PT_ATTACH
argument_list|,
name|pid
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
name|perror_with_name
argument_list|(
literal|"ptrace"
argument_list|)
expr_stmt|;
name|attach_flag
operator|=
literal|1
expr_stmt|;
return|return
name|pid
return|;
block|}
end_block

begin_comment
comment|/*  * Stop debugging the process whose number is PID and continue it  * with signal number SIGNAL.  SIGNAL = 0 means just continue it.    */
end_comment

begin_function
name|void
name|detach
parameter_list|(
name|signal
parameter_list|)
name|int
name|signal
decl_stmt|;
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|ptrace
argument_list|(
name|PT_DETACH
argument_list|,
name|inferior_pid
argument_list|,
name|PT_ADDR_ANY
argument_list|,
name|signal
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
name|perror_with_name
argument_list|(
literal|"ptrace"
argument_list|)
expr_stmt|;
name|attach_flag
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ATTACH_DETACH */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|get_register_offset
parameter_list|()
block|{
name|unsigned
name|int
name|offset
decl_stmt|;
name|struct
name|user
name|u
decl_stmt|;
comment|/* XXX */
name|unsigned
name|int
name|flags
init|=
operator|(
name|char
operator|*
operator|)
operator|&
name|u
operator|.
name|u_pcb
operator|.
name|pcb_flags
operator|-
operator|(
name|char
operator|*
operator|)
operator|&
name|u
decl_stmt|;
name|setregmap
argument_list|(
name|ptrace
argument_list|(
name|PT_READ_U
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|caddr_t
operator|)
name|flags
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NEWVM
name|offset
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|u
operator|.
name|u_kproc
operator|.
name|kp_proc
operator|.
name|p_regs
operator|-
operator|(
name|char
operator|*
operator|)
operator|&
name|u
expr_stmt|;
name|offset
operator|=
name|ptrace
argument_list|(
name|PT_READ_U
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|caddr_t
operator|)
name|offset
argument_list|,
literal|0
argument_list|)
operator|-
name|USRSTACK
expr_stmt|;
else|#
directive|else
name|offset
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|u
operator|.
name|u_ar0
operator|-
operator|(
name|char
operator|*
operator|)
operator|&
name|u
expr_stmt|;
name|offset
operator|=
name|ptrace
argument_list|(
name|PT_READ_U
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|caddr_t
operator|)
name|offset
argument_list|,
literal|0
argument_list|)
operator|-
name|KERNEL_U_ADDR
expr_stmt|;
endif|#
directive|endif
return|return
name|offset
return|;
block|}
end_function

begin_function
name|void
name|fetch_inferior_registers
parameter_list|()
block|{
specifier|register
name|int
name|regno
decl_stmt|;
specifier|register
name|unsigned
name|int
name|regaddr
decl_stmt|;
name|char
name|buf
index|[
name|MAX_REGISTER_RAW_SIZE
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|offset
decl_stmt|;
if|if
condition|(
name|remote_debugging
condition|)
block|{
specifier|extern
name|char
name|registers
index|[]
decl_stmt|;
name|remote_fetch_registers
argument_list|(
name|registers
argument_list|)
expr_stmt|;
return|return;
block|}
name|offset
operator|=
name|get_register_offset
argument_list|()
expr_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|NUM_REGS
condition|;
name|regno
operator|++
control|)
block|{
name|regaddr
operator|=
name|register_addr
argument_list|(
name|regno
argument_list|,
name|offset
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
condition|;
name|i
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
control|)
block|{
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|buf
index|[
name|i
index|]
operator|=
name|ptrace
argument_list|(
name|PT_READ_U
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|caddr_t
operator|)
name|regaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|regaddr
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
block|}
name|supply_register
argument_list|(
name|regno
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Store our register values back into the inferior. If REGNO is -1, do this  * for all registers. Otherwise, REGNO specifies which register (so we can  * save time).    */
end_comment

begin_macro
name|store_inferior_registers
argument_list|(
argument|regno
argument_list|)
end_macro

begin_decl_stmt
name|int
name|regno
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|unsigned
name|int
name|regaddr
decl_stmt|;
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
specifier|extern
name|char
name|registers
index|[]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|offset
decl_stmt|;
if|if
condition|(
name|remote_debugging
condition|)
block|{
specifier|extern
name|char
name|registers
index|[]
decl_stmt|;
name|remote_store_registers
argument_list|(
name|registers
argument_list|)
expr_stmt|;
return|return;
block|}
name|offset
operator|=
name|get_register_offset
argument_list|()
expr_stmt|;
if|if
condition|(
name|regno
operator|>=
literal|0
condition|)
block|{
name|regaddr
operator|=
name|register_addr
argument_list|(
name|regno
argument_list|,
name|offset
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
condition|;
name|i
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
control|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|ptrace
argument_list|(
name|PT_WRITE_U
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|caddr_t
operator|)
name|regaddr
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|regno
argument_list|)
operator|+
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"writing register number %d(%d)"
argument_list|,
name|regno
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|perror_with_name
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|regaddr
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
block|}
block|}
else|else
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|NUM_REGS
condition|;
name|regno
operator|++
control|)
block|{
name|regaddr
operator|=
name|register_addr
argument_list|(
name|regno
argument_list|,
name|offset
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
condition|;
name|i
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
control|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|ptrace
argument_list|(
name|PT_WRITE_U
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|caddr_t
operator|)
name|regaddr
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|regno
argument_list|)
operator|+
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"writing register number %d(%d)"
argument_list|,
name|regno
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|perror_with_name
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|regaddr
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * Copy LEN bytes from inferior's memory starting at MEMADDR to debugger  * memory starting at MYADDR. On failure (cannot read from inferior, usually  * because address is out of bounds) returns the value of errno.   */
end_comment

begin_function
name|int
name|read_inferior_memory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Round starting address down to longword boundary.  */
specifier|register
name|CORE_ADDR
name|addr
init|=
name|memaddr
operator|&
operator|-
sizeof|sizeof
argument_list|(
name|int
argument_list|)
decl_stmt|;
comment|/* Round ending address up; get number of longwords that makes.  */
specifier|register
name|int
name|count
init|=
operator|(
operator|(
operator|(
name|memaddr
operator|+
name|len
operator|)
operator|-
name|addr
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
decl_stmt|;
comment|/* Allocate buffer of that many longwords.  */
specifier|register
name|int
modifier|*
name|buffer
init|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|count
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|errno
decl_stmt|;
if|if
condition|(
name|remote_debugging
condition|)
return|return
operator|(
name|remote_read_inferior_memory
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
operator|)
return|;
comment|/* Read all the longwords */
name|errno
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
operator|&&
name|errno
operator|==
literal|0
condition|;
name|i
operator|++
operator|,
name|addr
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
control|)
name|buffer
index|[
name|i
index|]
operator|=
name|ptrace
argument_list|(
name|PT_READ_I
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|caddr_t
operator|)
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Copy appropriate bytes out of the buffer.  */
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buffer
operator|+
operator|(
name|memaddr
operator|&
operator|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
name|errno
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Copy LEN bytes of data from debugger memory at MYADDR to inferior's memory  * at MEMADDR. On failure (cannot write the inferior) returns the value of  * errno.    */
end_comment

begin_function
name|int
name|write_inferior_memory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Round starting address down to longword boundary.  */
specifier|register
name|CORE_ADDR
name|addr
init|=
name|memaddr
operator|&
operator|-
sizeof|sizeof
argument_list|(
name|int
argument_list|)
decl_stmt|;
comment|/* Round ending address up; get number of longwords that makes.  */
specifier|register
name|int
name|count
init|=
operator|(
operator|(
operator|(
name|memaddr
operator|+
name|len
operator|)
operator|-
name|addr
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
decl_stmt|;
comment|/* Allocate buffer of that many longwords.  */
specifier|register
name|int
modifier|*
name|buffer
init|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|count
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|errno
decl_stmt|;
comment|/* 	 * Fill start and end extra bytes of buffer with existing memory 	 * data.   	 */
if|if
condition|(
name|remote_debugging
condition|)
return|return
operator|(
name|remote_write_inferior_memory
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
operator|)
return|;
comment|/* 	 * Fill start and end extra bytes of buffer with existing memory 	 * data.   	 */
name|buffer
index|[
literal|0
index|]
operator|=
name|ptrace
argument_list|(
name|PT_READ_I
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|caddr_t
operator|)
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|1
condition|)
name|buffer
index|[
name|count
operator|-
literal|1
index|]
operator|=
name|ptrace
argument_list|(
name|PT_READ_I
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|caddr_t
operator|)
name|addr
operator|+
operator|(
name|count
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Copy data to be written over corresponding part of buffer */
name|bcopy
argument_list|(
name|myaddr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buffer
operator|+
operator|(
name|memaddr
operator|&
operator|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Write the entire buffer.  */
name|errno
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
operator|&&
name|errno
operator|==
literal|0
condition|;
name|i
operator|++
operator|,
name|addr
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
control|)
name|ptrace
argument_list|(
name|PT_WRITE_I
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|caddr_t
operator|)
name|addr
argument_list|,
name|buffer
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|errno
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Work with core dump and executable files, for GDB.   * This code would be in core.c if it weren't machine-dependent.   */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|N_TXTADDR
end_ifndef

begin_define
define|#
directive|define
name|N_TXTADDR
parameter_list|(
name|hdr
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* no N_TXTADDR */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|N_DATADDR
end_ifndef

begin_define
define|#
directive|define
name|N_DATADDR
parameter_list|(
name|hdr
parameter_list|)
value|hdr.a_text
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* no N_DATADDR */
end_comment

begin_comment
comment|/*  * Make COFF and non-COFF names for things a little more compatible to reduce  * conditionals later.    */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|AOUTHDR
end_ifndef

begin_define
define|#
directive|define
name|AOUTHDR
value|struct exec
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|sys_siglist
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Hook for `exec_file_command' command to call.  */
end_comment

begin_function_decl
specifier|extern
name|void
function_decl|(
modifier|*
name|exec_file_display_hook
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* File names of core file and executable file.  */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|corefile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|execfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Descriptors on which core file and executable file are open.    Note that the execchan is closed when an inferior is created    and reopened if the inferior dies or is killed.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|corechan
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|execchan
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last modification time of executable file.    Also used in source.c to compare against mtime of a source file.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|exec_mtime
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Virtual addresses of bounds of the two areas of memory in the core file.  */
end_comment

begin_decl_stmt
specifier|extern
name|CORE_ADDR
name|data_start
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|CORE_ADDR
name|data_end
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|CORE_ADDR
name|stack_start
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|CORE_ADDR
name|stack_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Virtual addresses of bounds of two areas of memory in the exec file.    Note that the data area in the exec file is used only when there is no core file.  */
end_comment

begin_decl_stmt
specifier|extern
name|CORE_ADDR
name|text_start
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|CORE_ADDR
name|text_end
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|CORE_ADDR
name|exec_data_start
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|CORE_ADDR
name|exec_data_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Address in executable file of start of text area data.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|text_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Address in executable file of start of data area data.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|exec_data_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Address in core file of start of data area data.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|data_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Address in core file of start of stack area data.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|stack_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* a.out header saved in core file.  */
end_comment

begin_decl_stmt
specifier|extern
name|AOUTHDR
name|core_aouthdr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* a.out header of exec file.  */
end_comment

begin_decl_stmt
specifier|extern
name|AOUTHDR
name|exec_aouthdr
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|void
name|validate_files
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
function_decl|(
modifier|*
name|core_file_hook
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|KERNELDEBUG
end_ifdef

begin_comment
comment|/*  * Kernel debugging routines.  */
end_comment

begin_define
define|#
directive|define
name|IOTOP
value|0x100000
end_define

begin_comment
comment|/* XXX should get this from include file */
end_comment

begin_define
define|#
directive|define
name|IOBASE
value|0xa0000
end_define

begin_comment
comment|/* XXX should get this from include file */
end_comment

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|file_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|lowram
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|sbr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|slr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pcb
name|pcb
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|CORE_ADDR
name|ksym_lookup
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|lookup_misc_func
argument_list|(
name|name
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"kernel symbol `%s' not found."
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|misc_function_vector
index|[
name|i
index|]
operator|.
name|address
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * return true if 'len' bytes starting at 'addr' can be read out as  * longwords and/or locally cached (this is mostly for memory mapped  * i/o register access when debugging remote kernels).  *  * XXX the HP code does this differently with NEWVM  */
end_comment

begin_function
specifier|static
name|int
name|ok_to_cache
parameter_list|(
name|addr
parameter_list|,
name|len
parameter_list|)
block|{
specifier|static
name|CORE_ADDR
name|atdevbase
decl_stmt|;
if|if
condition|(
operator|!
name|atdevbase
condition|)
name|atdevbase
operator|=
name|ksym_lookup
argument_list|(
literal|"atdevbase"
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|>=
name|atdevbase
operator|&&
name|addr
operator|<
name|atdevbase
operator|+
operator|(
name|IOTOP
operator|-
name|IOBASE
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|physrd
argument_list|(
argument|addr
argument_list|,
argument|dat
argument_list|,
argument|len
argument_list|)
name|u_int
name|addr
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|dat
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|lseek
argument_list|(
name|corechan
argument_list|,
name|addr
operator|-
name|file_offset
argument_list|,
name|L_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|read
argument_list|(
name|corechan
argument_list|,
name|dat
argument_list|,
name|len
argument_list|)
operator|!=
name|len
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * When looking at kernel data space through /dev/mem or with a core file, do  * virtual memory mapping.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NEWVM
end_ifdef

begin_function
specifier|static
name|CORE_ADDR
name|vtophys
parameter_list|(
name|addr
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
block|{
name|CORE_ADDR
name|v
decl_stmt|;
name|struct
name|pte
name|pte
decl_stmt|;
specifier|static
name|CORE_ADDR
name|PTD
init|=
operator|-
literal|1
decl_stmt|;
name|CORE_ADDR
name|current_ptd
decl_stmt|;
comment|/* 	 * If we're looking at the kernel stack, 	 * munge the address to refer to the user space mapping instead; 	 * that way we get the requested process's kstack, not the running one. 	 */
if|if
condition|(
name|addr
operator|>=
name|kstack
operator|&&
name|addr
operator|<
name|kstack
operator|+
name|ctob
argument_list|(
name|UPAGES
argument_list|)
condition|)
name|addr
operator|=
operator|(
name|addr
operator|-
name|kstack
operator|)
operator|+
name|curpcb
expr_stmt|;
comment|/* 	 * We may no longer have a linear system page table... 	 * 	 * Here's the scoop.  IdlePTD contains the physical address 	 * of a page table directory that always maps the kernel. 	 * IdlePTD is in memory that is mapped 1-to-1, so we can 	 * find it easily given its 'virtual' address from ksym_lookup(). 	 * For hysterical reasons, the value of IdlePTD is stored in sbr. 	 * 	 * To look up a kernel address, we first convert it to a 1st-level 	 * address and look it up in IdlePTD.  This gives us the physical 	 * address of a page table page; we extract the 2nd-level part of 	 * VA and read the 2nd-level pte.  Finally, we add the offset part 	 * of the VA into the physical address from the pte and return it. 	 * 	 * User addresses are a little more complicated.  If we don't have 	 * a current PCB from read_pcb(), we use PTD, which is the (fixed) 	 * virtual address of the current ptd.  Since it's NOT in 1-to-1 	 * kernel space, we must look it up using IdlePTD.  If we do have 	 * a pcb, we get the ptd from pcb_ptd. 	 */
if|if
condition|(
name|INKERNEL
argument_list|(
name|addr
argument_list|)
condition|)
name|current_ptd
operator|=
name|sbr
expr_stmt|;
elseif|else
if|if
condition|(
name|found_pcb
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|PTD
operator|==
operator|-
literal|1
condition|)
name|PTD
operator|=
name|vtophys
argument_list|(
name|ksym_lookup
argument_list|(
literal|"PTD"
argument_list|)
argument_list|)
expr_stmt|;
name|current_ptd
operator|=
name|PTD
expr_stmt|;
block|}
else|else
name|current_ptd
operator|=
name|pcb
operator|.
name|pcb_ptd
expr_stmt|;
comment|/* 	 * Read the first-level page table (ptd). 	 */
name|v
operator|=
name|current_ptd
operator|+
operator|(
operator|(
name|unsigned
operator|)
name|addr
operator|>>
name|PD_SHIFT
operator|)
operator|*
sizeof|sizeof
name|pte
expr_stmt|;
if|if
condition|(
name|physrd
argument_list|(
name|v
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pte
argument_list|,
sizeof|sizeof
name|pte
argument_list|)
operator|||
name|pte
operator|.
name|pg_v
operator|==
literal|0
condition|)
return|return
operator|(
operator|~
literal|0
operator|)
return|;
comment|/* 	 * Read the second-level page table. 	 */
name|v
operator|=
name|i386_ptob
argument_list|(
name|pte
operator|.
name|pg_pfnum
argument_list|)
operator|+
operator|(
operator|(
name|addr
operator|&
name|PT_MASK
operator|)
operator|>>
name|PG_SHIFT
operator|)
operator|*
sizeof|sizeof
name|pte
expr_stmt|;
if|if
condition|(
name|physrd
argument_list|(
name|v
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pte
argument_list|,
sizeof|sizeof
argument_list|(
name|pte
argument_list|)
argument_list|)
operator|||
name|pte
operator|.
name|pg_v
operator|==
literal|0
condition|)
return|return
operator|(
operator|~
literal|0
operator|)
return|;
name|addr
operator|=
name|i386_ptob
argument_list|(
name|pte
operator|.
name|pg_pfnum
argument_list|)
operator|+
operator|(
name|addr
operator|&
name|PGOFSET
operator|)
expr_stmt|;
if|#
directive|if
literal|0
block|printf("vtophys(%x) -> %x\n", oldaddr, addr);
endif|#
directive|endif
return|return
operator|(
name|addr
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|CORE_ADDR
name|vtophys
parameter_list|(
name|addr
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
block|{
name|CORE_ADDR
name|v
decl_stmt|;
name|struct
name|pte
name|pte
decl_stmt|;
name|CORE_ADDR
name|oldaddr
init|=
name|addr
decl_stmt|;
if|if
condition|(
name|found_pcb
operator|==
literal|0
operator|&&
name|INUPAGE
argument_list|(
name|addr
argument_list|)
condition|)
block|{
specifier|static
name|CORE_ADDR
name|pSwtchmap
decl_stmt|;
if|if
condition|(
name|pSwtchmap
operator|==
literal|0
condition|)
name|pSwtchmap
operator|=
name|vtophys
argument_list|(
name|ksym_lookup
argument_list|(
literal|"Swtchmap"
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|=
name|pSwtchmap
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|INKERNEL
argument_list|(
name|addr
argument_list|)
condition|)
block|{
comment|/* 		 * In system space get system pte.  If valid or reclaimable 		 * then physical address is combination of its page number 		 * and the page offset of the original address. 		 */
name|addr
operator|=
name|smxtob
argument_list|(
name|btop
argument_list|(
name|addr
operator|-
name|KERNOFF
argument_list|)
argument_list|)
operator|-
name|KERNOFF
expr_stmt|;
block|}
else|else
block|{
name|v
operator|=
name|btop
argument_list|(
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|<
name|pcb
operator|.
name|pcb_p0lr
condition|)
name|addr
operator|=
operator|(
name|CORE_ADDR
operator|)
name|pcb
operator|.
name|pcb_p0br
operator|+
name|v
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pte
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|v
operator|>=
name|pcb
operator|.
name|pcb_p1lr
operator|&&
name|v
operator|<
name|P1PAGES
condition|)
name|addr
operator|=
operator|(
name|CORE_ADDR
operator|)
name|pcb
operator|.
name|pcb_p0br
operator|+
operator|(
operator|(
name|pcb
operator|.
name|pcb_szpt
operator|*
name|NPTEPG
operator|-
name|HIGHPAGES
operator|)
operator|-
operator|(
name|BTOPUSRSTACK
operator|-
name|v
operator|)
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pte
argument_list|)
expr_stmt|;
else|else
return|return
operator|(
operator|~
literal|0
operator|)
return|;
comment|/* 		 * For p0/p1 address, user-level page table should be in 		 * kernel vm.  Do second-level indirect by recursing. 		 */
if|if
condition|(
operator|!
name|INKERNEL
argument_list|(
name|addr
argument_list|)
condition|)
return|return
operator|(
operator|~
literal|0
operator|)
return|;
name|addr
operator|=
name|vtophys
argument_list|(
name|addr
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Addr is now address of the pte of the page we are interested in; 	 * get the pte and paste up the physical address. 	 */
if|if
condition|(
name|physrd
argument_list|(
name|addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pte
argument_list|,
sizeof|sizeof
argument_list|(
name|pte
argument_list|)
argument_list|)
condition|)
return|return
operator|(
operator|~
literal|0
operator|)
return|;
if|if
condition|(
name|pte
operator|.
name|pg_v
operator|==
literal|0
operator|&&
operator|(
name|pte
operator|.
name|pg_fod
operator|||
name|pte
operator|.
name|pg_pfnum
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
operator|~
literal|0
operator|)
return|;
name|addr
operator|=
operator|(
name|CORE_ADDR
operator|)
name|ptob
argument_list|(
name|pte
operator|.
name|pg_pfnum
argument_list|)
operator|+
operator|(
name|oldaddr
operator|&
name|PGOFSET
operator|)
expr_stmt|;
if|#
directive|if
literal|0
block|printf("vtophys(%x) -> %x\n", oldaddr, addr);
endif|#
directive|endif
return|return
operator|(
name|addr
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
specifier|static
name|kvread
argument_list|(
argument|addr
argument_list|)
name|CORE_ADDR
name|addr
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|CORE_ADDR
name|paddr
init|=
name|vtophys
argument_list|(
name|addr
argument_list|)
decl_stmt|;
if|if
condition|(
name|paddr
operator|!=
operator|~
literal|0
condition|)
if|if
condition|(
name|physrd
argument_list|(
name|paddr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
empty_stmt|;
return|return
operator|(
name|addr
operator|)
return|;
return|return
operator|(
operator|~
literal|0
operator|)
return|;
block|}
end_block

begin_function
specifier|static
name|void
name|read_pcb
parameter_list|(
name|uaddr
parameter_list|)
name|u_int
name|uaddr
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
modifier|*
name|pcb_regs
init|=
operator|(
name|int
operator|*
operator|)
operator|&
name|pcb
decl_stmt|;
ifdef|#
directive|ifdef
name|NEWVM
if|if
condition|(
name|physrd
argument_list|(
name|uaddr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pcb
argument_list|,
sizeof|sizeof
name|pcb
argument_list|)
condition|)
name|error
argument_list|(
literal|"cannot read pcb at %x\n"
argument_list|,
name|uaddr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"current pcb at %x\n"
argument_list|,
name|uaddr
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|physrd
argument_list|(
name|uaddr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pcb
argument_list|,
sizeof|sizeof
name|pcb
argument_list|)
condition|)
name|error
argument_list|(
literal|"cannot read pcb at %x\n"
argument_list|,
name|uaddr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"p0br %x p0lr %x p1br %x p1lr %x\n"
argument_list|,
name|pcb
operator|.
name|pcb_p0br
argument_list|,
name|pcb
operator|.
name|pcb_p0lr
argument_list|,
name|pcb
operator|.
name|pcb_p1br
argument_list|,
name|pcb
operator|.
name|pcb_p1lr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * get the register values out of the sys pcb and 	 * store them where `read_register' will find them. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
operator|++
name|i
control|)
name|supply_register
argument_list|(
name|i
argument_list|,
operator|&
name|pcb_regs
index|[
name|i
operator|+
literal|10
index|]
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
literal|8
argument_list|,
operator|&
name|pcb_regs
index|[
literal|8
index|]
argument_list|)
expr_stmt|;
comment|/* eip */
name|supply_register
argument_list|(
literal|9
argument_list|,
operator|&
name|pcb_regs
index|[
literal|9
index|]
argument_list|)
expr_stmt|;
comment|/* eflags */
for|for
control|(
name|i
operator|=
literal|10
init|;
name|i
operator|<
literal|13
condition|;
operator|++
name|i
control|)
comment|/* cs, ss, ds */
name|supply_register
argument_list|(
name|i
argument_list|,
operator|&
name|pcb_regs
index|[
name|i
operator|+
literal|9
index|]
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
literal|13
argument_list|,
operator|&
name|pcb_regs
index|[
literal|18
index|]
argument_list|)
expr_stmt|;
comment|/* es */
for|for
control|(
name|i
operator|=
literal|14
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
comment|/* fs, gs */
name|supply_register
argument_list|(
name|i
argument_list|,
operator|&
name|pcb_regs
index|[
name|i
operator|+
literal|8
index|]
argument_list|)
expr_stmt|;
comment|/* XXX 80387 registers? */
block|}
end_function

begin_function
specifier|static
name|void
name|setup_kernel_debugging
parameter_list|()
block|{
name|struct
name|stat
name|stb
decl_stmt|;
name|int
name|devmem
init|=
literal|0
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|fstat
argument_list|(
name|corechan
argument_list|,
operator|&
name|stb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stb
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFCHR
operator|&&
name|stb
operator|.
name|st_rdev
operator|==
name|makedev
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
condition|)
name|devmem
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|NEWVM
name|physrd
argument_list|(
name|ksym_lookup
argument_list|(
literal|"IdlePTD"
argument_list|)
operator|-
name|KERNOFF
argument_list|,
operator|&
name|sbr
argument_list|,
sizeof|sizeof
name|sbr
argument_list|)
expr_stmt|;
name|slr
operator|=
literal|2
operator|*
name|NPTEPG
expr_stmt|;
comment|/* XXX temporary */
name|printf
argument_list|(
literal|"IdlePTD %x\n"
argument_list|,
name|sbr
argument_list|)
expr_stmt|;
name|curpcb
operator|=
name|ksym_lookup
argument_list|(
literal|"curpcb"
argument_list|)
operator|-
name|KERNOFF
expr_stmt|;
name|physrd
argument_list|(
name|curpcb
argument_list|,
operator|&
name|curpcb
argument_list|,
sizeof|sizeof
name|curpcb
argument_list|)
expr_stmt|;
name|kstack
operator|=
name|ksym_lookup
argument_list|(
literal|"kstack"
argument_list|)
expr_stmt|;
else|#
directive|else
name|sbr
operator|=
name|ksym_lookup
argument_list|(
literal|"Sysmap"
argument_list|)
expr_stmt|;
name|slr
operator|=
name|ksym_lookup
argument_list|(
literal|"Syssize"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sbr %x slr %x\n"
argument_list|,
name|sbr
argument_list|,
name|slr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * pcb where "panic" saved registers in first thing in current 	 * u area. 	 */
ifndef|#
directive|ifndef
name|NEWVM
name|read_pcb
argument_list|(
name|vtophys
argument_list|(
name|ksym_lookup
argument_list|(
literal|"u"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|found_pcb
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|devmem
condition|)
block|{
comment|/* find stack frame */
name|CORE_ADDR
name|panicstr
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|panicstr
operator|=
name|kvread
argument_list|(
name|ksym_lookup
argument_list|(
literal|"panicstr"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|panicstr
operator|==
operator|~
literal|0
condition|)
return|return;
operator|(
name|void
operator|)
name|kernel_core_file_hook
argument_list|(
name|panicstr
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|buf
init|;
name|cp
operator|<
operator|&
name|buf
index|[
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
index|]
operator|&&
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
if|if
condition|(
operator|!
name|isascii
argument_list|(
operator|*
name|cp
argument_list|)
operator|||
operator|(
operator|!
name|isprint
argument_list|(
operator|*
name|cp
argument_list|)
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
operator|)
condition|)
operator|*
name|cp
operator|=
literal|'?'
expr_stmt|;
if|if
condition|(
operator|*
name|cp
condition|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|printf
argument_list|(
literal|"panic: %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|read_pcb
argument_list|(
name|ksym_lookup
argument_list|(
literal|"dumppcb"
argument_list|)
operator|-
name|KERNOFF
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|NEWVM
else|else
name|read_pcb
argument_list|(
name|vtophys
argument_list|(
name|kstack
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|stack_start
operator|=
name|USRSTACK
expr_stmt|;
name|stack_end
operator|=
name|USRSTACK
operator|+
name|ctob
argument_list|(
name|UPAGES
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|set_paddr_command
argument_list|(
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|u_int
name|uaddr
decl_stmt|;
if|if
condition|(
operator|!
name|arg
condition|)
name|error_no_arg
argument_list|(
literal|"ps-style address for new current process"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|kernel_debugging
condition|)
name|error
argument_list|(
literal|"not debugging kernel"
argument_list|)
expr_stmt|;
name|uaddr
operator|=
operator|(
name|u_int
operator|)
name|parse_and_eval_address
argument_list|(
name|arg
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NEWVM
name|read_pcb
argument_list|(
name|ctob
argument_list|(
name|uaddr
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* p_addr is now a pcb virtual address */
name|read_pcb
argument_list|(
name|vtophys
argument_list|(
name|uaddr
argument_list|)
argument_list|)
expr_stmt|;
name|curpcb
operator|=
name|uaddr
expr_stmt|;
endif|#
directive|endif
name|flush_cached_frames
argument_list|()
expr_stmt|;
name|set_current_frame
argument_list|(
name|create_new_frame
argument_list|(
name|read_register
argument_list|(
name|FP_REGNUM
argument_list|)
argument_list|,
name|read_pc
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|select_frame
argument_list|(
name|get_current_frame
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * read len bytes from kernel virtual address 'addr' into local   * buffer 'buf'.  Return 0 if read ok, 1 otherwise.  On read  * errors, portion of buffer not read is zeroed.  */
end_comment

begin_macro
name|kernel_core_file_hook
argument_list|(
argument|addr
argument_list|,
argument|buf
argument_list|,
argument|len
argument_list|)
end_macro

begin_decl_stmt
name|CORE_ADDR
name|addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|CORE_ADDR
name|paddr
decl_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|paddr
operator|=
name|vtophys
argument_list|(
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|paddr
operator|==
operator|~
literal|0
condition|)
block|{
name|bzero
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* we can't read across a page boundary */
name|i
operator|=
name|min
argument_list|(
name|len
argument_list|,
name|NBPG
operator|-
operator|(
name|addr
operator|&
name|PGOFSET
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|physrd
argument_list|(
name|paddr
argument_list|,
name|buf
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|bzero
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|buf
operator|+=
name|i
expr_stmt|;
name|addr
operator|+=
name|i
expr_stmt|;
name|len
operator|-=
name|i
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|core_file_command
argument_list|(
argument|filename
argument_list|,
argument|from_tty
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|from_tty
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|val
decl_stmt|;
specifier|extern
name|char
name|registers
index|[]
decl_stmt|;
ifdef|#
directive|ifdef
name|KERNELDEBUG
name|struct
name|stat
name|stb
decl_stmt|;
endif|#
directive|endif
comment|/* 	 * Discard all vestiges of any previous core file and mark data and 	 * stack spaces as empty.   	 */
if|if
condition|(
name|corefile
condition|)
name|free
argument_list|(
name|corefile
argument_list|)
expr_stmt|;
name|corefile
operator|=
literal|0
expr_stmt|;
name|core_file_hook
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|corechan
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|corechan
argument_list|)
expr_stmt|;
name|corechan
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Now, if a new core file was specified, open it and digest it.  */
if|if
condition|(
name|filename
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|from_tty
condition|)
name|printf
argument_list|(
literal|"No core file now.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|filename
operator|=
name|tilde_expand
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_inferior_p
argument_list|()
condition|)
name|error
argument_list|(
literal|"To look at a core file, you must kill the inferior with \"kill\"."
argument_list|)
expr_stmt|;
name|corechan
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|corechan
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KERNELDEBUG
name|fstat
argument_list|(
name|corechan
argument_list|,
operator|&
name|stb
argument_list|)
expr_stmt|;
if|if
condition|(
name|kernel_debugging
condition|)
block|{
name|setup_kernel_debugging
argument_list|()
expr_stmt|;
name|core_file_hook
operator|=
name|kernel_core_file_hook
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|stb
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFCHR
operator|&&
name|stb
operator|.
name|st_rdev
operator|==
name|makedev
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|)
condition|)
block|{
comment|/* looking at /dev/kmem */
name|data_offset
operator|=
name|data_start
operator|=
name|KERNOFF
expr_stmt|;
name|data_end
operator|=
operator|~
literal|0
expr_stmt|;
comment|/* XXX */
name|stack_end
operator|=
name|stack_start
operator|=
name|data_end
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
comment|/* 		 * 4.2-style core dump file. 		 */
name|struct
name|user
name|u
decl_stmt|;
name|unsigned
name|int
name|reg_offset
decl_stmt|;
name|val
operator|=
name|myread
argument_list|(
name|corechan
argument_list|,
operator|&
name|u
argument_list|,
sizeof|sizeof
name|u
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
literal|"Not a core file: reading upage"
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
sizeof|sizeof
name|u
condition|)
name|error
argument_list|(
literal|"Not a core file: could only read %d bytes"
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* 		 * We are depending on exec_file_command having been 		 * called previously to set exec_data_start.  Since 		 * the executable and the core file share the same 		 * text segment, the address of the data segment will 		 * be the same in both.   		 */
name|data_start
operator|=
name|exec_data_start
expr_stmt|;
ifndef|#
directive|ifndef
name|NEWVM
name|data_end
operator|=
name|data_start
operator|+
name|NBPG
operator|*
name|u
operator|.
name|u_dsize
expr_stmt|;
name|stack_start
operator|=
name|stack_end
operator|-
name|NBPG
operator|*
name|u
operator|.
name|u_ssize
expr_stmt|;
name|data_offset
operator|=
name|NBPG
operator|*
name|UPAGES
expr_stmt|;
name|stack_offset
operator|=
name|NBPG
operator|*
operator|(
name|UPAGES
operator|+
name|u
operator|.
name|u_dsize
operator|)
expr_stmt|;
comment|/* 		 * Some machines put an absolute address in here and 		 * some put the offset in the upage of the regs.   		 */
name|reg_offset
operator|=
operator|(
name|int
operator|)
name|u
operator|.
name|u_ar0
operator|-
name|KERNEL_U_ADDR
expr_stmt|;
else|#
directive|else
name|stack_end
operator|=
operator|(
name|CORE_ADDR
operator|)
name|u
operator|.
name|u_kproc
operator|.
name|kp_eproc
operator|.
name|e_vm
operator|.
name|vm_maxsaddr
operator|+
name|MAXSSIZ
expr_stmt|;
name|data_end
operator|=
name|data_start
operator|+
name|NBPG
operator|*
name|u
operator|.
name|u_kproc
operator|.
name|kp_eproc
operator|.
name|e_vm
operator|.
name|vm_dsize
expr_stmt|;
name|stack_start
operator|=
name|stack_end
operator|-
name|NBPG
operator|*
name|u
operator|.
name|u_kproc
operator|.
name|kp_eproc
operator|.
name|e_vm
operator|.
name|vm_ssize
expr_stmt|;
name|data_offset
operator|=
name|NBPG
operator|*
name|UPAGES
expr_stmt|;
name|stack_offset
operator|=
name|NBPG
operator|*
operator|(
name|UPAGES
operator|+
name|u
operator|.
name|u_kproc
operator|.
name|kp_eproc
operator|.
name|e_vm
operator|.
name|vm_dsize
operator|)
expr_stmt|;
name|reg_offset
operator|=
operator|(
name|int
operator|)
name|u
operator|.
name|u_kproc
operator|.
name|kp_proc
operator|.
name|p_regs
operator|-
name|USRSTACK
expr_stmt|;
endif|#
directive|endif
name|setregmap
argument_list|(
name|u
operator|.
name|u_pcb
operator|.
name|pcb_flags
argument_list|)
expr_stmt|;
comment|/* 		 * I don't know where to find this info. So, for now, 		 * mark it as not available.   		 */
comment|/*	N_SET_MAGIC (core_aouthdr, 0);  */
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|core_aouthdr
argument_list|,
sizeof|sizeof
name|core_aouthdr
argument_list|)
expr_stmt|;
comment|/* 		 * Read the register values out of the core file and 		 * store them where `read_register' will find them.   		 */
block|{
specifier|register
name|int
name|regno
decl_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|NUM_REGS
condition|;
name|regno
operator|++
control|)
block|{
name|char
name|buf
index|[
name|MAX_REGISTER_RAW_SIZE
index|]
decl_stmt|;
name|val
operator|=
name|lseek
argument_list|(
name|corechan
argument_list|,
name|register_addr
argument_list|(
name|regno
argument_list|,
name|reg_offset
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
operator|||
operator|(
name|val
operator|=
name|myread
argument_list|(
name|corechan
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|char
modifier|*
name|buffer
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|reg_names
index|[
name|regno
index|]
argument_list|)
operator|+
literal|30
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|buffer
argument_list|,
literal|"Reading register "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buffer
argument_list|,
name|reg_names
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
name|perror_with_name
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
name|supply_register
argument_list|(
name|regno
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|filename
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
name|corefile
operator|=
name|savestring
argument_list|(
name|filename
argument_list|,
name|strlen
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|corefile
operator|=
name|concat
argument_list|(
name|current_directory
argument_list|,
literal|"/"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|set_current_frame
argument_list|(
name|create_new_frame
argument_list|(
name|read_register
argument_list|(
name|FP_REGNUM
argument_list|)
argument_list|,
name|read_pc
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|select_frame
argument_list|(
name|get_current_frame
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|validate_files
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|exec_file_command
argument_list|(
argument|filename
argument_list|,
argument|from_tty
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|from_tty
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|val
decl_stmt|;
comment|/* 	 * Eliminate all traces of old exec file. Mark text segment as empty.   	 */
if|if
condition|(
name|execfile
condition|)
name|free
argument_list|(
name|execfile
argument_list|)
expr_stmt|;
name|execfile
operator|=
literal|0
expr_stmt|;
name|data_start
operator|=
literal|0
expr_stmt|;
name|data_end
operator|=
literal|0
expr_stmt|;
name|stack_start
operator|=
literal|0
expr_stmt|;
name|stack_end
operator|=
literal|0
expr_stmt|;
name|text_start
operator|=
literal|0
expr_stmt|;
name|text_end
operator|=
literal|0
expr_stmt|;
name|exec_data_start
operator|=
literal|0
expr_stmt|;
name|exec_data_end
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|execchan
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|execchan
argument_list|)
expr_stmt|;
name|execchan
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Now open and digest the file the user requested, if any.  */
if|if
condition|(
name|filename
condition|)
block|{
name|filename
operator|=
name|tilde_expand
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|execchan
operator|=
name|openp
argument_list|(
name|getenv
argument_list|(
literal|"PATH"
argument_list|)
argument_list|,
literal|1
argument_list|,
name|filename
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|,
operator|&
name|execfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|execchan
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|{
name|struct
name|stat
name|st_exec
decl_stmt|;
ifdef|#
directive|ifdef
name|HEADER_SEEK_FD
name|HEADER_SEEK_FD
argument_list|(
name|execchan
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|val
operator|=
name|myread
argument_list|(
name|execchan
argument_list|,
operator|&
name|exec_aouthdr
argument_list|,
sizeof|sizeof
argument_list|(
name|AOUTHDR
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KERNELDEBUG
if|if
condition|(
name|kernel_debugging
condition|)
block|{
comment|/* Gross and disgusting XXX */
name|text_start
operator|=
name|KERNTEXT_BASE
expr_stmt|;
name|exec_data_start
operator|=
name|KERNTEXT_BASE
operator|+
operator|(
name|exec_aouthdr
operator|.
name|a_text
operator|+
literal|4095
operator|)
operator|&
operator|~
literal|4095
expr_stmt|;
block|}
else|else
block|{
endif|#
directive|endif
name|text_start
operator|=
name|N_TXTADDR
argument_list|(
name|exec_aouthdr
argument_list|)
expr_stmt|;
name|exec_data_start
operator|=
name|N_DATADDR
argument_list|(
name|exec_aouthdr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KERNELDEBUG
block|}
endif|#
directive|endif
name|text_offset
operator|=
name|N_TXTOFF
argument_list|(
name|exec_aouthdr
argument_list|)
expr_stmt|;
name|exec_data_offset
operator|=
name|N_TXTOFF
argument_list|(
name|exec_aouthdr
argument_list|)
operator|+
name|exec_aouthdr
operator|.
name|a_text
expr_stmt|;
name|text_end
operator|=
name|text_start
operator|+
name|exec_aouthdr
operator|.
name|a_text
expr_stmt|;
name|exec_data_end
operator|=
name|exec_data_start
operator|+
name|exec_aouthdr
operator|.
name|a_data
expr_stmt|;
name|fstat
argument_list|(
name|execchan
argument_list|,
operator|&
name|st_exec
argument_list|)
expr_stmt|;
name|exec_mtime
operator|=
name|st_exec
operator|.
name|st_mtime
expr_stmt|;
block|}
name|validate_files
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|from_tty
condition|)
name|printf
argument_list|(
literal|"No exec file now.\n"
argument_list|)
expr_stmt|;
comment|/* Tell display code (if any) about the changed file name.  */
if|if
condition|(
name|exec_file_display_hook
condition|)
call|(
modifier|*
name|exec_file_display_hook
call|)
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|int
name|dummy_code
index|[]
init|=
block|{
literal|0xb8909090
block|,
comment|/* nop; nop; nop; movl $0x32323232,%eax */
literal|0x32323232
block|,
define|#
directive|define
name|DUMMY_CALL_INDEX
value|1
literal|0x90ccd0ff
block|,
comment|/* call %eax; int3; nop */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Build `dummy' call instructions on inferior's stack to cause  * it to call a subroutine.  *  * N.B. - code in wait_for_inferior requires that sp< pc< fp when  * we take the trap 2 above so it will recognize that we stopped  * at a `dummy' call.  So, after the call sp is *not* decremented  * to clean the arguments, code& other stuff we lay on the stack.  * Since the regs are restored to saved values at the breakpoint,  * sp will get reset correctly.  Also, this restore means we don't  * have to construct frame linkage info to save pc& fp.  The lack  * of frame linkage means we can't do a backtrace, etc., if the  * called function gets a fault or hits a breakpoint but code in  * run_stack_dummy makes this impossible anyway.  */
end_comment

begin_decl_stmt
name|CORE_ADDR
name|setup_dummy
argument_list|(
name|sp
argument_list|,
name|funaddr
argument_list|,
name|nargs
argument_list|,
name|args
argument_list|,
name|struct_return_bytes
argument_list|,
name|pushfn
argument_list|)
name|CORE_ADDR
name|sp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|CORE_ADDR
name|funaddr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nargs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|value
modifier|*
name|args
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|struct_return_bytes
decl_stmt|;
end_decl_stmt

begin_function_decl
name|CORE_ADDR
function_decl|(
modifier|*
name|pushfn
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
name|int
name|padding
decl_stmt|,
name|i
decl_stmt|;
name|CORE_ADDR
name|top
init|=
name|sp
decl_stmt|,
name|struct_addr
decl_stmt|,
name|pc
decl_stmt|;
name|i
operator|=
name|arg_stacklen
argument_list|(
name|nargs
argument_list|,
name|args
argument_list|)
operator|+
name|struct_return_bytes
operator|+
sizeof|sizeof
argument_list|(
name|dummy_code
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&
literal|3
condition|)
name|padding
operator|=
literal|4
operator|-
operator|(
name|i
operator|&
literal|3
operator|)
expr_stmt|;
else|else
name|padding
operator|=
literal|0
expr_stmt|;
name|pc
operator|=
name|sp
operator|-
sizeof|sizeof
argument_list|(
name|dummy_code
argument_list|)
expr_stmt|;
name|sp
operator|=
name|pc
operator|-
name|padding
operator|-
name|struct_return_bytes
expr_stmt|;
name|struct_addr
operator|=
name|sp
expr_stmt|;
while|while
condition|(
operator|--
name|nargs
operator|>=
literal|0
condition|)
name|sp
operator|=
call|(
modifier|*
name|pushfn
call|)
argument_list|(
name|sp
argument_list|,
operator|*
name|args
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|struct_return_bytes
condition|)
name|STORE_STRUCT_RETURN
argument_list|(
name|struct_addr
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|SP_REGNUM
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|dummy_code
index|[
name|DUMMY_CALL_INDEX
index|]
operator|=
operator|(
name|int
operator|)
name|funaddr
expr_stmt|;
name|write_memory
argument_list|(
name|pc
argument_list|,
operator|(
name|char
operator|*
operator|)
name|dummy_code
argument_list|,
sizeof|sizeof
argument_list|(
name|dummy_code
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|pc
return|;
block|}
end_block

begin_comment
comment|/* helper functions for m-i386.h */
end_comment

begin_comment
comment|/* stdio style buffering to minimize calls to ptrace */
end_comment

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|codestream_next_addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|codestream_addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|codestream_buf
index|[
sizeof|sizeof
argument_list|(
name|int
argument_list|)
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|codestream_off
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|codestream_cnt
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|codestream_tell
parameter_list|()
value|(codestream_addr + codestream_off)
end_define

begin_define
define|#
directive|define
name|codestream_peek
parameter_list|()
value|(codestream_cnt == 0 ? \ 			   codestream_fill(1): codestream_buf[codestream_off])
end_define

begin_define
define|#
directive|define
name|codestream_get
parameter_list|()
value|(codestream_cnt-- == 0 ? \ 			 codestream_fill(0) : codestream_buf[codestream_off++])
end_define

begin_function
specifier|static
name|unsigned
name|char
name|codestream_fill
parameter_list|(
name|peek_flag
parameter_list|)
block|{
name|codestream_addr
operator|=
name|codestream_next_addr
expr_stmt|;
name|codestream_next_addr
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|codestream_off
operator|=
literal|0
expr_stmt|;
name|codestream_cnt
operator|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|read_memory
argument_list|(
name|codestream_addr
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|codestream_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|peek_flag
condition|)
return|return
operator|(
name|codestream_peek
argument_list|()
operator|)
return|;
else|else
return|return
operator|(
name|codestream_get
argument_list|()
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|codestream_seek
parameter_list|(
name|place
parameter_list|)
block|{
name|codestream_next_addr
operator|=
name|place
operator|&
operator|-
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|codestream_cnt
operator|=
literal|0
expr_stmt|;
name|codestream_fill
argument_list|(
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|codestream_tell
argument_list|()
operator|!=
name|place
condition|)
name|codestream_get
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|codestream_read
parameter_list|(
name|buf
parameter_list|,
name|count
parameter_list|)
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|;
block|{
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
name|codestream_get
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* next instruction is a jump, move to target */
end_comment

begin_expr_stmt
specifier|static
name|i386_follow_jump
argument_list|()
block|{
name|int
name|long_delta
block|;
name|short
name|short_delta
block|;
name|char
name|byte_delta
block|;
name|int
name|data16
block|;
name|int
name|pos
block|;
name|pos
operator|=
name|codestream_tell
argument_list|()
block|;
name|data16
operator|=
literal|0
block|;
if|if
condition|(
name|codestream_peek
argument_list|()
operator|==
literal|0x66
condition|)
block|{
name|codestream_get
argument_list|()
expr_stmt|;
name|data16
operator|=
literal|1
expr_stmt|;
block|}
end_expr_stmt

begin_switch
switch|switch
condition|(
name|codestream_get
argument_list|()
condition|)
block|{
case|case
literal|0xe9
case|:
comment|/* relative jump: if data16 == 0, disp32, else disp16 */
if|if
condition|(
name|data16
condition|)
block|{
name|codestream_read
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|short_delta
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|short_delta
operator|+
literal|3
expr_stmt|;
comment|/* include size of jmp inst */
block|}
else|else
block|{
name|codestream_read
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|long_delta
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|long_delta
operator|+
literal|5
expr_stmt|;
block|}
break|break;
case|case
literal|0xeb
case|:
comment|/* relative jump, disp8 (ignore data16) */
name|codestream_read
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|byte_delta
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|byte_delta
operator|+
literal|2
expr_stmt|;
break|break;
block|}
end_switch

begin_expr_stmt
name|codestream_seek
argument_list|(
name|pos
operator|+
name|data16
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/*  * find& return amound a local space allocated, and advance codestream to  * first register push (if any)  *  * if entry sequence doesn't make sense, return -1, and leave   * codestream pointer random  */
end_comment

begin_function
unit|static
name|long
name|i386_get_frame_setup
parameter_list|(
name|pc
parameter_list|)
block|{
name|unsigned
name|char
name|op
decl_stmt|;
name|codestream_seek
argument_list|(
name|pc
argument_list|)
expr_stmt|;
name|i386_follow_jump
argument_list|()
expr_stmt|;
name|op
operator|=
name|codestream_get
argument_list|()
expr_stmt|;
if|if
condition|(
name|op
operator|==
literal|0x58
condition|)
comment|/* popl %eax */
block|{
comment|/*        * this function must start with        *         *    popl %eax		  0x58        *    xchgl %eax, (%esp)  0x87 0x04 0x24        * or xchgl %eax, 0(%esp) 0x87 0x44 0x24 0x00        *        * (the system 5 compiler puts out the second xchg        * inst, and the assembler doesn't try to optimize it,        * so the 'sib' form gets generated)        *         * this sequence is used to get the address of the return        * buffer for a function that returns a structure        */
name|int
name|pos
decl_stmt|;
name|unsigned
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
specifier|static
name|unsigned
name|char
name|proto1
index|[
literal|3
index|]
init|=
block|{
literal|0x87
block|,
literal|0x04
block|,
literal|0x24
block|}
decl_stmt|;
specifier|static
name|unsigned
name|char
name|proto2
index|[
literal|4
index|]
init|=
block|{
literal|0x87
block|,
literal|0x44
block|,
literal|0x24
block|,
literal|0x00
block|}
decl_stmt|;
name|pos
operator|=
name|codestream_tell
argument_list|()
expr_stmt|;
name|codestream_read
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
name|buf
argument_list|,
name|proto1
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
name|pos
operator|+=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|bcmp
argument_list|(
name|buf
argument_list|,
name|proto2
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
name|pos
operator|+=
literal|4
expr_stmt|;
name|codestream_seek
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|op
operator|=
name|codestream_get
argument_list|()
expr_stmt|;
comment|/* update next opcode */
block|}
if|if
condition|(
name|op
operator|==
literal|0x55
condition|)
comment|/* pushl %esp */
block|{
comment|/* check for movl %esp, %ebp - can be written two ways */
switch|switch
condition|(
name|codestream_get
argument_list|()
condition|)
block|{
case|case
literal|0x8b
case|:
if|if
condition|(
name|codestream_get
argument_list|()
operator|!=
literal|0xec
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
break|break;
case|case
literal|0x89
case|:
if|if
condition|(
name|codestream_get
argument_list|()
operator|!=
literal|0xe5
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
break|break;
default|default:
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* check for stack adjustment         *        *  subl $XXX, %esp        *        * note: you can't subtract a 16 bit immediate        * from a 32 bit reg, so we don't have to worry        * about a data16 prefix         */
name|op
operator|=
name|codestream_peek
argument_list|()
expr_stmt|;
if|if
condition|(
name|op
operator|==
literal|0x83
condition|)
block|{
comment|/* subl with 8 bit immed */
name|codestream_get
argument_list|()
expr_stmt|;
if|if
condition|(
name|codestream_get
argument_list|()
operator|!=
literal|0xec
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* subl with signed byte immediate  	   * (though it wouldn't make sense to be negative) 	   */
return|return
operator|(
name|codestream_get
argument_list|()
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
literal|0x81
condition|)
block|{
comment|/* subl with 32 bit immed */
name|int
name|locals
decl_stmt|;
name|codestream_get
argument_list|()
expr_stmt|;
if|if
condition|(
name|codestream_get
argument_list|()
operator|!=
literal|0xec
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* subl with 32 bit immediate */
name|codestream_read
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|locals
argument_list|,
literal|4
argument_list|)
expr_stmt|;
return|return
operator|(
name|locals
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|op
operator|==
literal|0xc8
condition|)
block|{
comment|/* enter instruction: arg is 16 bit unsigned immed */
name|unsigned
name|short
name|slocals
decl_stmt|;
name|codestream_read
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|slocals
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|codestream_get
argument_list|()
expr_stmt|;
comment|/* flush final byte of enter instruction */
return|return
operator|(
name|slocals
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return number of args passed to a frame.    Can return -1, meaning no way to tell.  */
end_comment

begin_comment
comment|/* on the 386, the instruction following the call could be:  *  popl %ecx        -  one arg  *  addl $imm, %esp  -  imm/4 args; imm may be 8 or 32 bits  *  anything else    -  zero args  */
end_comment

begin_function
name|int
name|i386_frame_num_args
parameter_list|(
name|fi
parameter_list|)
name|struct
name|frame_info
name|fi
decl_stmt|;
block|{
name|int
name|retpc
decl_stmt|;
name|unsigned
name|char
name|op
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|pfi
decl_stmt|;
name|pfi
operator|=
name|get_prev_frame_info
argument_list|(
operator|(
name|fi
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfi
operator|==
literal|0
condition|)
block|{
comment|/* Note:  this can happen if we are looking at the frame for 	 main, because FRAME_CHAIN_VALID won't let us go into 	 start.  If we have debugging symbols, that's not really 	 a big deal; it just means it will only show as many arguments 	 to main as are declared.  */
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
name|retpc
operator|=
name|pfi
operator|->
name|pc
expr_stmt|;
name|op
operator|=
name|read_memory_integer
argument_list|(
name|retpc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
literal|0x59
condition|)
comment|/* pop %ecx */
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|op
operator|==
literal|0x83
condition|)
block|{
name|op
operator|=
name|read_memory_integer
argument_list|(
name|retpc
operator|+
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
literal|0xc4
condition|)
comment|/* addl $<signed imm 8 bits>, %esp */
return|return
operator|(
name|read_memory_integer
argument_list|(
name|retpc
operator|+
literal|2
argument_list|,
literal|1
argument_list|)
operator|&
literal|0xff
operator|)
operator|/
literal|4
return|;
else|else
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
literal|0x81
condition|)
block|{
comment|/* add with 32 bit immediate */
name|op
operator|=
name|read_memory_integer
argument_list|(
name|retpc
operator|+
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
literal|0xc4
condition|)
comment|/* addl $<imm 32>, %esp */
return|return
name|read_memory_integer
argument_list|(
name|retpc
operator|+
literal|2
argument_list|,
literal|4
argument_list|)
operator|/
literal|4
return|;
else|else
return|return
literal|0
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * parse the first few instructions of the function to see  * what registers were stored.  *  * We handle these cases:  *  * The startup sequence can be at the start of the function,  * or the function can start with a branch to startup code at the end.  *  * %ebp can be set up with either the 'enter' instruction, or   * 'pushl %ebp, movl %esp, %ebp' (enter is too slow to be useful,  * but was once used in the sys5 compiler)  *  * Local space is allocated just below the saved %ebp by either the  * 'enter' instruction, or by 'subl $<size>, %esp'.  'enter' has  * a 16 bit unsigned argument for space to allocate, and the  * 'addl' instruction could have either a signed byte, or  * 32 bit immediate.  *  * Next, the registers used by this function are pushed.  In  * the sys5 compiler they will always be in the order: %edi, %esi, %ebx  * (and sometimes a harmless bug causes it to also save but not restore %eax);  * however, the code below is willing to see the pushes in any order,  * and will handle up to 8 of them.  *  * If the setup sequence is at the end of the function, then the  * next instruction will be a branch back to the start.  */
end_comment

begin_macro
name|i386_frame_find_saved_regs
argument_list|(
argument|fip
argument_list|,
argument|fsrp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|frame_info
modifier|*
name|fip
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|frame_saved_regs
modifier|*
name|fsrp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|unsigned
name|long
name|locals
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|char
name|op
decl_stmt|;
name|CORE_ADDR
name|dummy_bottom
decl_stmt|;
name|CORE_ADDR
name|adr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|bzero
argument_list|(
name|fsrp
argument_list|,
sizeof|sizeof
expr|*
name|fsrp
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* if frame is the end of a dummy, compute where the    * beginning would be    */
block|dummy_bottom = fip->frame - 4 - NUM_REGS*4 - CALL_DUMMY_LENGTH;
comment|/* check if the PC is in the stack, in a dummy frame */
block|if (dummy_bottom<= fip->pc&& fip->pc<= fip->frame)      {
comment|/* all regs were saved by push_call_dummy () */
block|adr = fip->frame - 4;       for (i = 0; i< NUM_REGS; i++)  	{ 	  fsrp->regs[i] = adr; 	  adr -= 4; 	}       return;     }
endif|#
directive|endif
name|locals
operator|=
name|i386_get_frame_setup
argument_list|(
name|get_pc_function_start
argument_list|(
name|fip
operator|->
name|pc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|locals
operator|>=
literal|0
condition|)
block|{
name|adr
operator|=
name|fip
operator|->
name|frame
operator|-
literal|4
operator|-
name|locals
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|op
operator|=
name|codestream_get
argument_list|()
expr_stmt|;
if|if
condition|(
name|op
operator|<
literal|0x50
operator|||
name|op
operator|>
literal|0x57
condition|)
break|break;
name|fsrp
operator|->
name|regs
index|[
name|op
operator|-
literal|0x50
index|]
operator|=
name|adr
expr_stmt|;
name|adr
operator|-=
literal|4
expr_stmt|;
block|}
block|}
name|fsrp
operator|->
name|regs
index|[
name|PC_REGNUM
index|]
operator|=
name|fip
operator|->
name|frame
operator|+
literal|4
expr_stmt|;
name|fsrp
operator|->
name|regs
index|[
name|FP_REGNUM
index|]
operator|=
name|fip
operator|->
name|frame
expr_stmt|;
block|}
end_block

begin_comment
comment|/* return pc of first real instruction */
end_comment

begin_macro
name|i386_skip_prologue
argument_list|(
argument|pc
argument_list|)
end_macro

begin_block
block|{
name|unsigned
name|char
name|op
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|i386_get_frame_setup
argument_list|(
name|pc
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|pc
operator|)
return|;
comment|/* found valid frame setup - codestream now points to     * start of push instructions for saving registers    */
comment|/* skip over register saves */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|op
operator|=
name|codestream_peek
argument_list|()
expr_stmt|;
comment|/* break if not pushl inst */
if|if
condition|(
name|op
operator|<
literal|0x50
operator|||
name|op
operator|>
literal|0x57
condition|)
break|break;
name|codestream_get
argument_list|()
expr_stmt|;
block|}
name|i386_follow_jump
argument_list|()
expr_stmt|;
return|return
operator|(
name|codestream_tell
argument_list|()
operator|)
return|;
block|}
end_block

begin_macro
name|i386_pop_frame
argument_list|()
end_macro

begin_block
block|{
name|FRAME
name|frame
init|=
name|get_current_frame
argument_list|()
decl_stmt|;
name|CORE_ADDR
name|fp
decl_stmt|;
name|int
name|regnum
decl_stmt|;
name|struct
name|frame_saved_regs
name|fsr
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
name|fi
operator|=
name|get_frame_info
argument_list|(
name|frame
argument_list|)
expr_stmt|;
name|fp
operator|=
name|fi
operator|->
name|frame
expr_stmt|;
name|get_frame_saved_regs
argument_list|(
name|fi
argument_list|,
operator|&
name|fsr
argument_list|)
expr_stmt|;
for|for
control|(
name|regnum
operator|=
literal|0
init|;
name|regnum
operator|<
name|NUM_REGS
condition|;
name|regnum
operator|++
control|)
block|{
name|CORE_ADDR
name|adr
decl_stmt|;
name|adr
operator|=
name|fsr
operator|.
name|regs
index|[
name|regnum
index|]
expr_stmt|;
if|if
condition|(
name|adr
condition|)
name|write_register
argument_list|(
name|regnum
argument_list|,
name|read_memory_integer
argument_list|(
name|adr
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|write_register
argument_list|(
name|FP_REGNUM
argument_list|,
name|read_memory_integer
argument_list|(
name|fp
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|PC_REGNUM
argument_list|,
name|read_memory_integer
argument_list|(
name|fp
operator|+
literal|4
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|SP_REGNUM
argument_list|,
name|fp
operator|+
literal|8
argument_list|)
expr_stmt|;
name|flush_cached_frames
argument_list|()
expr_stmt|;
name|set_current_frame
argument_list|(
name|create_new_frame
argument_list|(
name|read_register
argument_list|(
name|FP_REGNUM
argument_list|)
argument_list|,
name|read_pc
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* this table must line up with REGISTER_NAMES in m-i386.h */
end_comment

begin_comment
comment|/* symbols like 'EAX' come from<sys/reg.h> */
end_comment

begin_decl_stmt
specifier|static
name|int
name|trapmap
index|[]
init|=
block|{
name|tEAX
block|,
name|tECX
block|,
name|tEDX
block|,
name|tEBX
block|,
name|tESP
block|,
name|tEBP
block|,
name|tESI
block|,
name|tEDI
block|,
name|tEIP
block|,
name|tEFLAGS
block|,
name|tCS
block|,
name|tSS
block|,
name|tDS
block|,
name|tES
block|,
name|tES
block|,
name|tES
comment|/* lies: no fs or gs */
block|}
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|FM_TRAP
argument_list|)
operator|||
name|defined
argument_list|(
name|EX_TRAPSTK
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|int
name|syscallmap
index|[]
init|=
block|{
name|sEAX
block|,
name|sECX
block|,
name|sEDX
block|,
name|sEBX
block|,
name|sESP
block|,
name|sEBP
block|,
name|sESI
block|,
name|sEDI
block|,
name|sEIP
block|,
name|sEFLAGS
block|,
name|sCS
block|,
name|sSS
block|,
name|sCS
block|,
name|sCS
block|,
name|sCS
block|,
name|sCS
comment|/* lies: no ds, es, fs or gs */
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
modifier|*
name|regmap
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|setregmap
parameter_list|(
name|flags
parameter_list|)
name|int
name|flags
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|FM_TRAP
name|regmap
operator|=
name|flags
operator|&
name|FM_TRAP
condition|?
name|trapmap
else|:
name|syscallmap
expr_stmt|;
elif|#
directive|elif
name|EX_TRAPSTK
name|regmap
operator|=
name|flags
operator|&
name|EX_TRAPSTK
condition|?
name|trapmap
else|:
name|syscallmap
expr_stmt|;
else|#
directive|else
name|regmap
operator|=
name|trapmap
expr_stmt|;
comment|/* the lesser evil */
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* blockend is the value of u.u_ar0, and points to the  * place where GS is stored  */
end_comment

begin_macro
name|i386_register_u_addr
argument_list|(
argument|blockend
argument_list|,
argument|regnum
argument_list|)
end_macro

begin_block
block|{
if|#
directive|if
literal|0
comment|/* this will be needed if fp registers are reinstated */
comment|/* for now, you can look at them with 'info float'    * sys5 wont let you change them with ptrace anyway    */
block|if (regnum>= FP0_REGNUM&& regnum<= FP7_REGNUM)      {       int ubase, fpstate;       struct user u;       ubase = blockend + 4 * (SS + 1) - KSTKSZ;       fpstate = ubase + ((char *)&u.u_fpstate - (char *)&u);       return (fpstate + 0x1c + 10 * (regnum - FP0_REGNUM));     }    else
endif|#
directive|endif
return|return
operator|(
name|blockend
operator|+
literal|4
operator|*
name|regmap
index|[
name|regnum
index|]
operator|)
return|;
block|}
end_block

begin_macro
name|i387_to_double
argument_list|(
argument|from
argument_list|,
argument|to
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|from
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|to
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|long
modifier|*
name|lp
decl_stmt|;
comment|/* push extended mode on 387 stack, then pop in double mode    *    * first, set exception masks so no error is generated -    * number will be rounded to inf or 0, if necessary     */
asm|asm ("pushl %eax");
comment|/* grab a stack slot */
asm|asm ("fstcw (%esp)");
comment|/* get 387 control word */
asm|asm ("movl (%esp),%eax");
comment|/* save old value */
asm|asm ("orl $0x3f,%eax");
comment|/* mask all exceptions */
asm|asm ("pushl %eax");
asm|asm ("fldcw (%esp)");
comment|/* load new value into 387 */
asm|asm ("movl 8(%ebp),%eax");
asm|asm ("fldt (%eax)");
comment|/* push extended number on 387 stack */
asm|asm ("fwait");
asm|asm ("movl 12(%ebp),%eax");
asm|asm ("fstpl (%eax)");
comment|/* pop double */
asm|asm ("fwait");
asm|asm ("popl %eax");
comment|/* flush modified control word */
asm|asm ("fnclex");
comment|/* clear exceptions */
asm|asm ("fldcw (%esp)");
comment|/* restore original control word */
asm|asm ("popl %eax");
comment|/* flush saved copy */
block|}
end_block

begin_macro
name|double_to_i387
argument_list|(
argument|from
argument_list|,
argument|to
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|from
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|to
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* push double mode on 387 stack, then pop in extended mode    * no errors are possible because every 64-bit pattern    * can be converted to an extended    */
asm|asm ("movl 8(%ebp),%eax");
asm|asm ("fldl (%eax)");
asm|asm ("fwait");
asm|asm ("movl 12(%ebp),%eax");
asm|asm ("fstpt (%eax)");
asm|asm ("fwait");
block|}
end_block

begin_struct
struct|struct
name|env387
block|{
name|unsigned
name|short
name|control
decl_stmt|;
name|unsigned
name|short
name|r0
decl_stmt|;
name|unsigned
name|short
name|status
decl_stmt|;
name|unsigned
name|short
name|r1
decl_stmt|;
name|unsigned
name|short
name|tag
decl_stmt|;
name|unsigned
name|short
name|r2
decl_stmt|;
name|unsigned
name|long
name|eip
decl_stmt|;
name|unsigned
name|short
name|code_seg
decl_stmt|;
name|unsigned
name|short
name|opcode
decl_stmt|;
name|unsigned
name|long
name|operand
decl_stmt|;
name|unsigned
name|short
name|operand_seg
decl_stmt|;
name|unsigned
name|short
name|r3
decl_stmt|;
name|unsigned
name|char
name|regs
index|[
literal|8
index|]
index|[
literal|10
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
specifier|static
name|print_387_control_word
argument_list|(
argument|control
argument_list|)
name|unsigned
name|short
name|control
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|printf
argument_list|(
literal|"control 0x%04x: "
argument_list|,
name|control
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"compute to "
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|control
operator|>>
literal|8
operator|)
operator|&
literal|3
condition|)
block|{
case|case
literal|0
case|:
name|printf
argument_list|(
literal|"24 bits; "
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|printf
argument_list|(
literal|"(bad); "
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|printf
argument_list|(
literal|"53 bits; "
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|printf
argument_list|(
literal|"64 bits; "
argument_list|)
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|"round "
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|control
operator|>>
literal|10
operator|)
operator|&
literal|3
condition|)
block|{
case|case
literal|0
case|:
name|printf
argument_list|(
literal|"NEAREST; "
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|printf
argument_list|(
literal|"DOWN; "
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|printf
argument_list|(
literal|"UP; "
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|printf
argument_list|(
literal|"CHOP; "
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|control
operator|&
literal|0x3f
condition|)
block|{
name|printf
argument_list|(
literal|"mask:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|&
literal|0x0001
condition|)
name|printf
argument_list|(
literal|" INVALID"
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|&
literal|0x0002
condition|)
name|printf
argument_list|(
literal|" DENORM"
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|&
literal|0x0004
condition|)
name|printf
argument_list|(
literal|" DIVZ"
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|&
literal|0x0008
condition|)
name|printf
argument_list|(
literal|" OVERF"
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|&
literal|0x0010
condition|)
name|printf
argument_list|(
literal|" UNDERF"
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|&
literal|0x0020
condition|)
name|printf
argument_list|(
literal|" LOS"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|";"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|&
literal|0xe080
condition|)
name|printf
argument_list|(
literal|"warning: reserved bits on 0x%x\n"
argument_list|,
name|control
operator|&
literal|0xe080
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|print_387_status_word
argument_list|(
argument|status
argument_list|)
name|unsigned
name|short
name|status
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|printf
argument_list|(
literal|"status 0x%04x: "
argument_list|,
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
literal|0xff
condition|)
block|{
name|printf
argument_list|(
literal|"exceptions:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
literal|0x0001
condition|)
name|printf
argument_list|(
literal|" INVALID"
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
literal|0x0002
condition|)
name|printf
argument_list|(
literal|" DENORM"
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
literal|0x0004
condition|)
name|printf
argument_list|(
literal|" DIVZ"
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
literal|0x0008
condition|)
name|printf
argument_list|(
literal|" OVERF"
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
literal|0x0010
condition|)
name|printf
argument_list|(
literal|" UNDERF"
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
literal|0x0020
condition|)
name|printf
argument_list|(
literal|" LOS"
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
literal|0x0040
condition|)
name|printf
argument_list|(
literal|" FPSTACK"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"; "
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"flags: %d%d%d%d; "
argument_list|,
operator|(
name|status
operator|&
literal|0x4000
operator|)
operator|!=
literal|0
argument_list|,
operator|(
name|status
operator|&
literal|0x0400
operator|)
operator|!=
literal|0
argument_list|,
operator|(
name|status
operator|&
literal|0x0200
operator|)
operator|!=
literal|0
argument_list|,
operator|(
name|status
operator|&
literal|0x0100
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"top %d\n"
argument_list|,
operator|(
name|status
operator|>>
literal|11
operator|)
operator|&
literal|7
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|print_387_status
argument_list|(
argument|status
argument_list|,
argument|ep
argument_list|)
name|unsigned
name|short
name|status
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|env387
modifier|*
name|ep
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|int
name|bothstatus
decl_stmt|;
name|int
name|top
decl_stmt|;
name|int
name|fpreg
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|bothstatus
operator|=
operator|(
operator|(
name|status
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|ep
operator|->
name|status
operator|!=
literal|0
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|bothstatus
condition|)
name|printf
argument_list|(
literal|"u: "
argument_list|)
expr_stmt|;
name|print_387_status_word
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ep
operator|->
name|status
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|bothstatus
condition|)
name|printf
argument_list|(
literal|"e: "
argument_list|)
expr_stmt|;
name|print_387_status_word
argument_list|(
name|ep
operator|->
name|status
argument_list|)
expr_stmt|;
block|}
name|print_387_control_word
argument_list|(
name|ep
operator|->
name|control
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"last exception: "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"opcode 0x%x; "
argument_list|,
name|ep
operator|->
name|opcode
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"pc 0x%x:0x%x; "
argument_list|,
name|ep
operator|->
name|code_seg
argument_list|,
name|ep
operator|->
name|eip
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"operand 0x%x:0x%x\n"
argument_list|,
name|ep
operator|->
name|operand_seg
argument_list|,
name|ep
operator|->
name|operand
argument_list|)
expr_stmt|;
name|top
operator|=
operator|(
name|ep
operator|->
name|status
operator|>>
literal|11
operator|)
operator|&
literal|7
expr_stmt|;
name|printf
argument_list|(
literal|" regno     tag  msb              lsb  value\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|fpreg
operator|=
literal|7
init|;
name|fpreg
operator|>=
literal|0
condition|;
name|fpreg
operator|--
control|)
block|{
name|int
name|st_regno
decl_stmt|;
name|double
name|val
decl_stmt|;
comment|/* The physical regno `fpreg' is only relevant as an index into the        * tag word.  Logical `%st' numbers are required for indexing `p->regs.        */
name|st_regno
operator|=
operator|(
name|fpreg
operator|+
literal|8
operator|-
name|top
operator|)
operator|&
literal|0x7
expr_stmt|;
name|printf
argument_list|(
literal|"%%st(%d) %s "
argument_list|,
name|st_regno
argument_list|,
name|fpreg
operator|==
name|top
condition|?
literal|"=>"
else|:
literal|"  "
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|ep
operator|->
name|tag
operator|>>
operator|(
name|fpreg
operator|*
literal|2
operator|)
operator|)
operator|&
literal|3
condition|)
block|{
case|case
literal|0
case|:
name|printf
argument_list|(
literal|"valid "
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|printf
argument_list|(
literal|"zero  "
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|printf
argument_list|(
literal|"trap  "
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|printf
argument_list|(
literal|"empty "
argument_list|)
expr_stmt|;
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|9
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|printf
argument_list|(
literal|"%02x"
argument_list|,
name|ep
operator|->
name|regs
index|[
name|st_regno
index|]
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|i387_to_double
argument_list|(
name|ep
operator|->
name|regs
index|[
name|st_regno
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|val
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  %g\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* reserved fields are always 0xffff on 486's */
block|if (ep->r0)     printf ("warning: reserved0 is 0x%x\n", ep->r0);   if (ep->r1)     printf ("warning: reserved1 is 0x%x\n", ep->r1);   if (ep->r2)     printf ("warning: reserved2 is 0x%x\n", ep->r2);   if (ep->r3)     printf ("warning: reserved3 is 0x%x\n", ep->r3);
endif|#
directive|endif
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|__386BSD__
end_ifdef

begin_define
define|#
directive|define
name|fpstate
value|save87
end_define

begin_define
define|#
directive|define
name|U_FPSTATE
parameter_list|(
name|u
parameter_list|)
value|u.u_pcb.pcb_savefpu
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|U_FPSTATE
end_ifndef

begin_define
define|#
directive|define
name|U_FPSTATE
parameter_list|(
name|u
parameter_list|)
value|u.u_fpstate
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|i386_float_info
argument_list|()
end_macro

begin_block
block|{
name|struct
name|user
name|u
decl_stmt|;
comment|/* just for address computations */
name|int
name|i
decl_stmt|;
comment|/* fpstate defined in<sys/user.h> */
name|struct
name|fpstate
modifier|*
name|fpstatep
decl_stmt|;
name|char
name|buf
index|[
sizeof|sizeof
argument_list|(
expr|struct
name|fpstate
argument_list|)
operator|+
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
index|]
decl_stmt|;
name|unsigned
name|int
name|uaddr
decl_stmt|;
name|char
name|fpvalid
decl_stmt|;
name|unsigned
name|int
name|rounded_addr
decl_stmt|;
name|unsigned
name|int
name|rounded_size
decl_stmt|;
specifier|extern
name|int
name|corechan
decl_stmt|;
name|int
name|skip
decl_stmt|;
ifndef|#
directive|ifndef
name|__386BSD__
comment|/* XXX - look at pcb flags */
name|uaddr
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|u
operator|.
name|u_fpvalid
operator|-
operator|(
name|char
operator|*
operator|)
operator|&
name|u
expr_stmt|;
if|if
condition|(
name|have_inferior_p
argument_list|()
condition|)
block|{
name|unsigned
name|int
name|data
decl_stmt|;
name|unsigned
name|int
name|mask
decl_stmt|;
name|rounded_addr
operator|=
name|uaddr
operator|&
operator|-
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|data
operator|=
name|ptrace
argument_list|(
name|PT_READ_U
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|caddr_t
operator|)
name|rounded_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mask
operator|=
literal|0xff
operator|<<
operator|(
operator|(
name|uaddr
operator|-
name|rounded_addr
operator|)
operator|*
literal|8
operator|)
expr_stmt|;
name|fpvalid
operator|=
operator|(
operator|(
name|data
operator|&
name|mask
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|lseek
argument_list|(
name|corechan
argument_list|,
name|uaddr
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|perror
argument_list|(
literal|"seek on core file"
argument_list|)
expr_stmt|;
if|if
condition|(
name|myread
argument_list|(
name|corechan
argument_list|,
operator|&
name|fpvalid
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
name|perror
argument_list|(
literal|"read on core file"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fpvalid
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"no floating point status saved\n"
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* not __386BSD__ */
name|uaddr
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|U_FPSTATE
argument_list|(
name|u
argument_list|)
operator|-
operator|(
name|char
operator|*
operator|)
operator|&
name|u
expr_stmt|;
if|if
condition|(
name|have_inferior_p
argument_list|()
condition|)
block|{
name|int
modifier|*
name|ip
decl_stmt|;
name|rounded_addr
operator|=
name|uaddr
operator|&
operator|-
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|rounded_size
operator|=
operator|(
operator|(
operator|(
name|uaddr
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|fpstate
argument_list|)
operator|)
operator|-
name|uaddr
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|skip
operator|=
name|uaddr
operator|-
name|rounded_addr
expr_stmt|;
name|ip
operator|=
operator|(
name|int
operator|*
operator|)
name|buf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rounded_size
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|ip
operator|++
operator|=
name|ptrace
argument_list|(
name|PT_READ_U
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|caddr_t
operator|)
name|rounded_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rounded_addr
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|lseek
argument_list|(
name|corechan
argument_list|,
name|uaddr
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
literal|"seek on core file"
argument_list|)
expr_stmt|;
if|if
condition|(
name|myread
argument_list|(
name|corechan
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fpstate
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
literal|"read from core file"
argument_list|)
expr_stmt|;
name|skip
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|__386BSD__
name|print_387_status
argument_list|(
literal|0
argument_list|,
operator|(
expr|struct
name|env387
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
else|#
directive|else
name|fpstatep
operator|=
operator|(
expr|struct
name|fpstate
operator|*
operator|)
operator|(
name|buf
operator|+
name|skip
operator|)
expr_stmt|;
name|print_387_status
argument_list|(
name|fpstatep
operator|->
name|status
argument_list|,
operator|(
expr|struct
name|env387
operator|*
operator|)
name|fpstatep
operator|->
name|state
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_function
name|void
name|_initialize_i386bsd_dep
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|KERNELDEBUG
name|add_com
argument_list|(
literal|"process-address"
argument_list|,
name|class_obscure
argument_list|,
name|set_paddr_command
argument_list|,
literal|"The process identified by (ps-style) ADDR becomes the\n\ \"current\" process context for kernel debugging."
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"paddr"
argument_list|,
literal|"process-address"
argument_list|,
name|class_obscure
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

end_unit

