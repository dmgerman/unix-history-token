begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Memory allocator `malloc'.    Copyright 1990, 1991, 1992 Free Software Foundation     Written May 1989 by Mike Haertel.    Heavily modified Mar 1992 by Fred Fish for mmap'd version.  The GNU C Library is free software; you can redistribute it and/or modify it under the terms of the GNU Library General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  The GNU C Library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for more details.  You should have received a copy of the GNU Library General Public License along with the GNU C Library; see the file COPYING.LIB.  If not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.     The author may be reached (Email) at the address mike@ai.mit.edu,    or (US mail) as Mike Haertel c/o Free Software Foundation. */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|/* Prototypes for memcpy, memmove, memset, etc */
end_comment

begin_include
include|#
directive|include
file|"mmalloc.h"
end_include

begin_comment
comment|/* Prototypes for local functions */
end_comment

begin_decl_stmt
specifier|static
name|int
name|initialize
name|PARAMS
argument_list|(
operator|(
expr|struct
name|mdesc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|PTR
name|morecore
name|PARAMS
argument_list|(
operator|(
expr|struct
name|mdesc
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|PTR
name|align
name|PARAMS
argument_list|(
operator|(
expr|struct
name|mdesc
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Aligned allocation.  */
end_comment

begin_function
specifier|static
name|PTR
name|align
parameter_list|(
name|mdp
parameter_list|,
name|size
parameter_list|)
name|struct
name|mdesc
modifier|*
name|mdp
decl_stmt|;
name|size_t
name|size
decl_stmt|;
block|{
name|PTR
name|result
decl_stmt|;
name|unsigned
name|long
name|int
name|adj
decl_stmt|;
name|result
operator|=
name|mdp
operator|->
name|morecore
argument_list|(
name|mdp
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|adj
operator|=
name|RESIDUAL
argument_list|(
name|result
argument_list|,
name|BLOCKSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|adj
operator|!=
literal|0
condition|)
block|{
name|adj
operator|=
name|BLOCKSIZE
operator|-
name|adj
expr_stmt|;
name|mdp
operator|->
name|morecore
argument_list|(
name|mdp
argument_list|,
name|adj
argument_list|)
expr_stmt|;
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|result
operator|+
name|adj
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Set everything up and remember that we have.  */
end_comment

begin_function
specifier|static
name|int
name|initialize
parameter_list|(
name|mdp
parameter_list|)
name|struct
name|mdesc
modifier|*
name|mdp
decl_stmt|;
block|{
name|mdp
operator|->
name|heapsize
operator|=
name|HEAP
operator|/
name|BLOCKSIZE
expr_stmt|;
name|mdp
operator|->
name|heapinfo
operator|=
operator|(
name|malloc_info
operator|*
operator|)
name|align
argument_list|(
name|mdp
argument_list|,
name|mdp
operator|->
name|heapsize
operator|*
sizeof|sizeof
argument_list|(
name|malloc_info
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mdp
operator|->
name|heapinfo
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|memset
argument_list|(
operator|(
name|PTR
operator|)
name|mdp
operator|->
name|heapinfo
argument_list|,
literal|0
argument_list|,
name|mdp
operator|->
name|heapsize
operator|*
sizeof|sizeof
argument_list|(
name|malloc_info
argument_list|)
argument_list|)
expr_stmt|;
name|mdp
operator|->
name|heapinfo
index|[
literal|0
index|]
operator|.
name|free
operator|.
name|size
operator|=
literal|0
expr_stmt|;
name|mdp
operator|->
name|heapinfo
index|[
literal|0
index|]
operator|.
name|free
operator|.
name|next
operator|=
name|mdp
operator|->
name|heapinfo
index|[
literal|0
index|]
operator|.
name|free
operator|.
name|prev
operator|=
literal|0
expr_stmt|;
name|mdp
operator|->
name|heapindex
operator|=
literal|0
expr_stmt|;
name|mdp
operator|->
name|heapbase
operator|=
operator|(
name|char
operator|*
operator|)
name|mdp
operator|->
name|heapinfo
expr_stmt|;
name|mdp
operator|->
name|flags
operator||=
name|MMALLOC_INITIALIZED
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Get neatly aligned memory, initializing or    growing the heap info table as necessary. */
end_comment

begin_function
specifier|static
name|PTR
name|morecore
parameter_list|(
name|mdp
parameter_list|,
name|size
parameter_list|)
name|struct
name|mdesc
modifier|*
name|mdp
decl_stmt|;
name|size_t
name|size
decl_stmt|;
block|{
name|PTR
name|result
decl_stmt|;
name|malloc_info
modifier|*
name|newinfo
decl_stmt|,
modifier|*
name|oldinfo
decl_stmt|;
name|size_t
name|newsize
decl_stmt|;
name|result
operator|=
name|align
argument_list|(
name|mdp
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Check if we need to grow the info table.  */
if|if
condition|(
operator|(
name|size_t
operator|)
name|BLOCK
argument_list|(
operator|(
name|char
operator|*
operator|)
name|result
operator|+
name|size
argument_list|)
operator|>
name|mdp
operator|->
name|heapsize
condition|)
block|{
name|newsize
operator|=
name|mdp
operator|->
name|heapsize
expr_stmt|;
while|while
condition|(
operator|(
name|size_t
operator|)
name|BLOCK
argument_list|(
operator|(
name|char
operator|*
operator|)
name|result
operator|+
name|size
argument_list|)
operator|>
name|newsize
condition|)
block|{
name|newsize
operator|*=
literal|2
expr_stmt|;
block|}
name|newinfo
operator|=
operator|(
name|malloc_info
operator|*
operator|)
name|align
argument_list|(
name|mdp
argument_list|,
name|newsize
operator|*
sizeof|sizeof
argument_list|(
name|malloc_info
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newinfo
operator|==
name|NULL
condition|)
block|{
name|mdp
operator|->
name|morecore
argument_list|(
name|mdp
argument_list|,
operator|-
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|memset
argument_list|(
operator|(
name|PTR
operator|)
name|newinfo
argument_list|,
literal|0
argument_list|,
name|newsize
operator|*
sizeof|sizeof
argument_list|(
name|malloc_info
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|PTR
operator|)
name|newinfo
argument_list|,
operator|(
name|PTR
operator|)
name|mdp
operator|->
name|heapinfo
argument_list|,
name|mdp
operator|->
name|heapsize
operator|*
sizeof|sizeof
argument_list|(
name|malloc_info
argument_list|)
argument_list|)
expr_stmt|;
name|oldinfo
operator|=
name|mdp
operator|->
name|heapinfo
expr_stmt|;
name|newinfo
index|[
name|BLOCK
argument_list|(
name|oldinfo
argument_list|)
index|]
operator|.
name|busy
operator|.
name|type
operator|=
literal|0
expr_stmt|;
name|newinfo
index|[
name|BLOCK
argument_list|(
name|oldinfo
argument_list|)
index|]
operator|.
name|busy
operator|.
name|info
operator|.
name|size
operator|=
name|BLOCKIFY
argument_list|(
name|mdp
operator|->
name|heapsize
operator|*
sizeof|sizeof
argument_list|(
name|malloc_info
argument_list|)
argument_list|)
expr_stmt|;
name|mdp
operator|->
name|heapinfo
operator|=
name|newinfo
expr_stmt|;
name|__mmalloc_free
argument_list|(
name|mdp
argument_list|,
operator|(
name|PTR
operator|)
name|oldinfo
argument_list|)
expr_stmt|;
name|mdp
operator|->
name|heapsize
operator|=
name|newsize
expr_stmt|;
block|}
name|mdp
operator|->
name|heaplimit
operator|=
name|BLOCK
argument_list|(
operator|(
name|char
operator|*
operator|)
name|result
operator|+
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Allocate memory from the heap.  */
end_comment

begin_function
name|PTR
name|mmalloc
parameter_list|(
name|md
parameter_list|,
name|size
parameter_list|)
name|PTR
name|md
decl_stmt|;
name|size_t
name|size
decl_stmt|;
block|{
name|struct
name|mdesc
modifier|*
name|mdp
decl_stmt|;
name|PTR
name|result
decl_stmt|;
name|size_t
name|block
decl_stmt|,
name|blocks
decl_stmt|,
name|lastblocks
decl_stmt|,
name|start
decl_stmt|;
specifier|register
name|size_t
name|i
decl_stmt|;
name|struct
name|list
modifier|*
name|next
decl_stmt|;
specifier|register
name|size_t
name|log
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|mdp
operator|=
name|MD_TO_MDP
argument_list|(
name|md
argument_list|)
expr_stmt|;
if|if
condition|(
name|mdp
operator|->
name|mmalloc_hook
operator|!=
name|NULL
condition|)
block|{
return|return
operator|(
call|(
modifier|*
name|mdp
operator|->
name|mmalloc_hook
call|)
argument_list|(
name|md
argument_list|,
name|size
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|mdp
operator|->
name|flags
operator|&
name|MMALLOC_INITIALIZED
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|initialize
argument_list|(
name|mdp
argument_list|)
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
if|if
condition|(
name|size
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|list
argument_list|)
condition|)
block|{
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|list
argument_list|)
expr_stmt|;
block|}
comment|/* Determine the allocation policy based on the request size.  */
if|if
condition|(
name|size
operator|<=
name|BLOCKSIZE
operator|/
literal|2
condition|)
block|{
comment|/* Small allocation to receive a fragment of a block. 	 Determine the logarithm to base two of the fragment size. */
name|log
operator|=
literal|1
expr_stmt|;
operator|--
name|size
expr_stmt|;
while|while
condition|(
operator|(
name|size
operator|/=
literal|2
operator|)
operator|!=
literal|0
condition|)
block|{
operator|++
name|log
expr_stmt|;
block|}
comment|/* Look in the fragment lists for a 	 free fragment of the desired size. */
name|next
operator|=
name|mdp
operator|->
name|fraghead
index|[
name|log
index|]
operator|.
name|next
expr_stmt|;
if|if
condition|(
name|next
operator|!=
name|NULL
condition|)
block|{
comment|/* There are free fragments of this size. 	     Pop a fragment out of the fragment list and return it. 	     Update the block's nfree and first counters. */
name|result
operator|=
operator|(
name|PTR
operator|)
name|next
expr_stmt|;
name|next
operator|->
name|prev
operator|->
name|next
operator|=
name|next
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|next
operator|->
name|next
operator|!=
name|NULL
condition|)
block|{
name|next
operator|->
name|next
operator|->
name|prev
operator|=
name|next
operator|->
name|prev
expr_stmt|;
block|}
name|block
operator|=
name|BLOCK
argument_list|(
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|mdp
operator|->
name|heapinfo
index|[
name|block
index|]
operator|.
name|busy
operator|.
name|info
operator|.
name|frag
operator|.
name|nfree
operator|!=
literal|0
condition|)
block|{
name|mdp
operator|->
name|heapinfo
index|[
name|block
index|]
operator|.
name|busy
operator|.
name|info
operator|.
name|frag
operator|.
name|first
operator|=
name|RESIDUAL
argument_list|(
name|next
operator|->
name|next
argument_list|,
name|BLOCKSIZE
argument_list|)
operator|>>
name|log
expr_stmt|;
block|}
comment|/* Update the statistics.  */
name|mdp
operator|->
name|heapstats
operator|.
name|chunks_used
operator|++
expr_stmt|;
name|mdp
operator|->
name|heapstats
operator|.
name|bytes_used
operator|+=
literal|1
operator|<<
name|log
expr_stmt|;
name|mdp
operator|->
name|heapstats
operator|.
name|chunks_free
operator|--
expr_stmt|;
name|mdp
operator|->
name|heapstats
operator|.
name|bytes_free
operator|-=
literal|1
operator|<<
name|log
expr_stmt|;
block|}
else|else
block|{
comment|/* No free fragments of the desired size, so get a new block 	     and break it into fragments, returning the first.  */
name|result
operator|=
name|mmalloc
argument_list|(
name|md
argument_list|,
name|BLOCKSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Link all fragments but the first into the free list.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
call|(
name|size_t
call|)
argument_list|(
name|BLOCKSIZE
operator|>>
name|log
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|next
operator|=
operator|(
expr|struct
name|list
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|result
operator|+
operator|(
name|i
operator|<<
name|log
operator|)
operator|)
expr_stmt|;
name|next
operator|->
name|next
operator|=
name|mdp
operator|->
name|fraghead
index|[
name|log
index|]
operator|.
name|next
expr_stmt|;
name|next
operator|->
name|prev
operator|=
operator|&
name|mdp
operator|->
name|fraghead
index|[
name|log
index|]
expr_stmt|;
name|next
operator|->
name|prev
operator|->
name|next
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|next
operator|->
name|next
operator|!=
name|NULL
condition|)
block|{
name|next
operator|->
name|next
operator|->
name|prev
operator|=
name|next
expr_stmt|;
block|}
block|}
comment|/* Initialize the nfree and first counters for this block.  */
name|block
operator|=
name|BLOCK
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|mdp
operator|->
name|heapinfo
index|[
name|block
index|]
operator|.
name|busy
operator|.
name|type
operator|=
name|log
expr_stmt|;
name|mdp
operator|->
name|heapinfo
index|[
name|block
index|]
operator|.
name|busy
operator|.
name|info
operator|.
name|frag
operator|.
name|nfree
operator|=
name|i
operator|-
literal|1
expr_stmt|;
name|mdp
operator|->
name|heapinfo
index|[
name|block
index|]
operator|.
name|busy
operator|.
name|info
operator|.
name|frag
operator|.
name|first
operator|=
name|i
operator|-
literal|1
expr_stmt|;
name|mdp
operator|->
name|heapstats
operator|.
name|chunks_free
operator|+=
operator|(
name|BLOCKSIZE
operator|>>
name|log
operator|)
operator|-
literal|1
expr_stmt|;
name|mdp
operator|->
name|heapstats
operator|.
name|bytes_free
operator|+=
name|BLOCKSIZE
operator|-
operator|(
literal|1
operator|<<
name|log
operator|)
expr_stmt|;
name|mdp
operator|->
name|heapstats
operator|.
name|bytes_used
operator|-=
name|BLOCKSIZE
operator|-
operator|(
literal|1
operator|<<
name|log
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Large allocation to receive one or more blocks. 	 Search the free list in a circle starting at the last place visited. 	 If we loop completely around without finding a large enough 	 space we will have to get more memory from the system.  */
name|blocks
operator|=
name|BLOCKIFY
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|start
operator|=
name|block
operator|=
name|MALLOC_SEARCH_START
expr_stmt|;
while|while
condition|(
name|mdp
operator|->
name|heapinfo
index|[
name|block
index|]
operator|.
name|free
operator|.
name|size
operator|<
name|blocks
condition|)
block|{
name|block
operator|=
name|mdp
operator|->
name|heapinfo
index|[
name|block
index|]
operator|.
name|free
operator|.
name|next
expr_stmt|;
if|if
condition|(
name|block
operator|==
name|start
condition|)
block|{
comment|/* Need to get more from the system.  Check to see if 		 the new core will be contiguous with the final free 		 block; if so we don't need to get as much.  */
name|block
operator|=
name|mdp
operator|->
name|heapinfo
index|[
literal|0
index|]
operator|.
name|free
operator|.
name|prev
expr_stmt|;
name|lastblocks
operator|=
name|mdp
operator|->
name|heapinfo
index|[
name|block
index|]
operator|.
name|free
operator|.
name|size
expr_stmt|;
if|if
condition|(
name|mdp
operator|->
name|heaplimit
operator|!=
literal|0
operator|&&
name|block
operator|+
name|lastblocks
operator|==
name|mdp
operator|->
name|heaplimit
operator|&&
name|mdp
operator|->
name|morecore
argument_list|(
name|mdp
argument_list|,
literal|0
argument_list|)
operator|==
name|ADDRESS
argument_list|(
name|block
operator|+
name|lastblocks
argument_list|)
operator|&&
operator|(
name|morecore
argument_list|(
name|mdp
argument_list|,
operator|(
name|blocks
operator|-
name|lastblocks
operator|)
operator|*
name|BLOCKSIZE
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* Which block we are extending (the `final free 		     block' referred to above) might have changed, if 		     it got combined with a freed info table.  */
name|block
operator|=
name|mdp
operator|->
name|heapinfo
index|[
literal|0
index|]
operator|.
name|free
operator|.
name|prev
expr_stmt|;
name|mdp
operator|->
name|heapinfo
index|[
name|block
index|]
operator|.
name|free
operator|.
name|size
operator|+=
operator|(
name|blocks
operator|-
name|lastblocks
operator|)
expr_stmt|;
name|mdp
operator|->
name|heapstats
operator|.
name|bytes_free
operator|+=
operator|(
name|blocks
operator|-
name|lastblocks
operator|)
operator|*
name|BLOCKSIZE
expr_stmt|;
continue|continue;
block|}
name|result
operator|=
name|morecore
argument_list|(
name|mdp
argument_list|,
name|blocks
operator|*
name|BLOCKSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|block
operator|=
name|BLOCK
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|mdp
operator|->
name|heapinfo
index|[
name|block
index|]
operator|.
name|busy
operator|.
name|type
operator|=
literal|0
expr_stmt|;
name|mdp
operator|->
name|heapinfo
index|[
name|block
index|]
operator|.
name|busy
operator|.
name|info
operator|.
name|size
operator|=
name|blocks
expr_stmt|;
name|mdp
operator|->
name|heapstats
operator|.
name|chunks_used
operator|++
expr_stmt|;
name|mdp
operator|->
name|heapstats
operator|.
name|bytes_used
operator|+=
name|blocks
operator|*
name|BLOCKSIZE
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
block|}
comment|/* At this point we have found a suitable free list entry. 	 Figure out how to remove what we need from the list. */
name|result
operator|=
name|ADDRESS
argument_list|(
name|block
argument_list|)
expr_stmt|;
if|if
condition|(
name|mdp
operator|->
name|heapinfo
index|[
name|block
index|]
operator|.
name|free
operator|.
name|size
operator|>
name|blocks
condition|)
block|{
comment|/* The block we found has a bit left over, 	     so relink the tail end back into the free list. */
name|mdp
operator|->
name|heapinfo
index|[
name|block
operator|+
name|blocks
index|]
operator|.
name|free
operator|.
name|size
operator|=
name|mdp
operator|->
name|heapinfo
index|[
name|block
index|]
operator|.
name|free
operator|.
name|size
operator|-
name|blocks
expr_stmt|;
name|mdp
operator|->
name|heapinfo
index|[
name|block
operator|+
name|blocks
index|]
operator|.
name|free
operator|.
name|next
operator|=
name|mdp
operator|->
name|heapinfo
index|[
name|block
index|]
operator|.
name|free
operator|.
name|next
expr_stmt|;
name|mdp
operator|->
name|heapinfo
index|[
name|block
operator|+
name|blocks
index|]
operator|.
name|free
operator|.
name|prev
operator|=
name|mdp
operator|->
name|heapinfo
index|[
name|block
index|]
operator|.
name|free
operator|.
name|prev
expr_stmt|;
name|mdp
operator|->
name|heapinfo
index|[
name|mdp
operator|->
name|heapinfo
index|[
name|block
index|]
operator|.
name|free
operator|.
name|prev
index|]
operator|.
name|free
operator|.
name|next
operator|=
name|mdp
operator|->
name|heapinfo
index|[
name|mdp
operator|->
name|heapinfo
index|[
name|block
index|]
operator|.
name|free
operator|.
name|next
index|]
operator|.
name|free
operator|.
name|prev
operator|=
name|mdp
operator|->
name|heapindex
operator|=
name|block
operator|+
name|blocks
expr_stmt|;
block|}
else|else
block|{
comment|/* The block exactly matches our requirements, 	     so just remove it from the list. */
name|mdp
operator|->
name|heapinfo
index|[
name|mdp
operator|->
name|heapinfo
index|[
name|block
index|]
operator|.
name|free
operator|.
name|next
index|]
operator|.
name|free
operator|.
name|prev
operator|=
name|mdp
operator|->
name|heapinfo
index|[
name|block
index|]
operator|.
name|free
operator|.
name|prev
expr_stmt|;
name|mdp
operator|->
name|heapinfo
index|[
name|mdp
operator|->
name|heapinfo
index|[
name|block
index|]
operator|.
name|free
operator|.
name|prev
index|]
operator|.
name|free
operator|.
name|next
operator|=
name|mdp
operator|->
name|heapindex
operator|=
name|mdp
operator|->
name|heapinfo
index|[
name|block
index|]
operator|.
name|free
operator|.
name|next
expr_stmt|;
name|mdp
operator|->
name|heapstats
operator|.
name|chunks_free
operator|--
expr_stmt|;
block|}
name|mdp
operator|->
name|heapinfo
index|[
name|block
index|]
operator|.
name|busy
operator|.
name|type
operator|=
literal|0
expr_stmt|;
name|mdp
operator|->
name|heapinfo
index|[
name|block
index|]
operator|.
name|busy
operator|.
name|info
operator|.
name|size
operator|=
name|blocks
expr_stmt|;
name|mdp
operator|->
name|heapstats
operator|.
name|chunks_used
operator|++
expr_stmt|;
name|mdp
operator|->
name|heapstats
operator|.
name|bytes_used
operator|+=
name|blocks
operator|*
name|BLOCKSIZE
expr_stmt|;
name|mdp
operator|->
name|heapstats
operator|.
name|bytes_free
operator|-=
name|blocks
operator|*
name|BLOCKSIZE
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/* When using this package, provide a version of malloc/realloc/free built    on top of it, so that if we use the default sbrk() region we will not    collide with another malloc package trying to do the same thing, if    the application contains any "hidden" calls to malloc/realloc/free (such    as inside a system library). */
end_comment

begin_function
name|PTR
name|malloc
parameter_list|(
name|size
parameter_list|)
name|size_t
name|size
decl_stmt|;
block|{
return|return
operator|(
name|mmalloc
argument_list|(
operator|(
name|PTR
operator|)
name|NULL
argument_list|,
name|size
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

