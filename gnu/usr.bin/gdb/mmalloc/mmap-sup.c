begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Support for an sbrk-like function that uses mmap.    Copyright 1992 Free Software Foundation, Inc.     Contributed by Fred Fish at Cygnus Support.   fnf@cygnus.com  This file is part of the GNU C Library.  The GNU C Library is free software; you can redistribute it and/or modify it under the terms of the GNU Library General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  The GNU C Library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for more details.  You should have received a copy of the GNU Library General Public License along with the GNU C Library; see the file COPYING.LIB.  If not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_MMAP
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|SEEK_SET
end_ifndef

begin_define
define|#
directive|define
name|SEEK_SET
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"mmalloc.h"
end_include

begin_decl_stmt
specifier|extern
name|int
name|munmap
name|PARAMS
argument_list|(
operator|(
name|caddr_t
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Not in any header file */
end_comment

begin_comment
comment|/* Cache the pagesize for the current host machine.  Note that if the host    does not readily provide a getpagesize() function, we need to emulate it    elsewhere, not clutter up this file with lots of kluges to try to figure    it out. */
end_comment

begin_decl_stmt
specifier|static
name|size_t
name|pagesize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|getpagesize
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|PAGE_ALIGN
parameter_list|(
name|addr
parameter_list|)
value|(caddr_t) (((long)(addr) + pagesize - 1)& \ 				    ~(pagesize - 1))
end_define

begin_comment
comment|/*  Get core for the memory region specified by MDP, using SIZE as the     amount to either add to or subtract from the existing region.  Works     like sbrk(), but using mmap(). */
end_comment

begin_function
name|PTR
name|__mmalloc_mmap_morecore
parameter_list|(
name|mdp
parameter_list|,
name|size
parameter_list|)
name|struct
name|mdesc
modifier|*
name|mdp
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|PTR
name|result
init|=
name|NULL
decl_stmt|;
name|off_t
name|foffset
decl_stmt|;
comment|/* File offset at which new mapping will start */
name|size_t
name|mapbytes
decl_stmt|;
comment|/* Number of bytes to map */
name|caddr_t
name|moveto
decl_stmt|;
comment|/* Address where we wish to move "break value" to */
name|caddr_t
name|mapto
decl_stmt|;
comment|/* Address we actually mapped to */
name|char
name|buf
init|=
literal|0
decl_stmt|;
comment|/* Single byte to write to extend mapped file */
if|if
condition|(
name|pagesize
operator|==
literal|0
condition|)
block|{
name|pagesize
operator|=
name|getpagesize
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
comment|/* Just return the current "break" value. */
name|result
operator|=
name|mdp
operator|->
name|breakval
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
operator|<
literal|0
condition|)
block|{
comment|/* We are deallocating memory.  If the amount requested would cause 	 us to try to deallocate back past the base of the mmap'd region 	 then do nothing, and return NULL.  Otherwise, deallocate the 	 memory and return the old break value. */
if|if
condition|(
name|mdp
operator|->
name|breakval
operator|+
name|size
operator|>=
name|mdp
operator|->
name|base
condition|)
block|{
name|result
operator|=
operator|(
name|PTR
operator|)
name|mdp
operator|->
name|breakval
expr_stmt|;
name|mdp
operator|->
name|breakval
operator|+=
name|size
expr_stmt|;
name|moveto
operator|=
name|PAGE_ALIGN
argument_list|(
name|mdp
operator|->
name|breakval
argument_list|)
expr_stmt|;
name|munmap
argument_list|(
name|moveto
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|mdp
operator|->
name|top
operator|-
name|moveto
argument_list|)
argument_list|)
expr_stmt|;
name|mdp
operator|->
name|top
operator|=
name|moveto
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* We are allocating memory.  Make sure we have an open file 	 descriptor and then go on to get the memory. */
if|if
condition|(
name|mdp
operator|->
name|fd
operator|<
literal|0
condition|)
block|{
name|result
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mdp
operator|->
name|breakval
operator|+
name|size
operator|>
name|mdp
operator|->
name|top
condition|)
block|{
comment|/* The request would move us past the end of the currently 	     mapped memory, so map in enough more memory to satisfy 	     the request.  This means we also have to grow the mapped-to 	     file by an appropriate amount, since mmap cannot be used 	     to extend a file. */
name|moveto
operator|=
name|PAGE_ALIGN
argument_list|(
name|mdp
operator|->
name|breakval
operator|+
name|size
argument_list|)
expr_stmt|;
name|mapbytes
operator|=
name|moveto
operator|-
name|mdp
operator|->
name|top
expr_stmt|;
name|foffset
operator|=
name|mdp
operator|->
name|top
operator|-
name|mdp
operator|->
name|base
expr_stmt|;
comment|/* FIXME:  Test results of lseek() and write() */
name|lseek
argument_list|(
name|mdp
operator|->
name|fd
argument_list|,
name|foffset
operator|+
name|mapbytes
operator|-
literal|1
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|mdp
operator|->
name|fd
argument_list|,
operator|&
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mapto
operator|=
name|mmap
argument_list|(
name|mdp
operator|->
name|top
argument_list|,
name|mapbytes
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_SHARED
operator||
name|MAP_FIXED
argument_list|,
name|mdp
operator|->
name|fd
argument_list|,
name|foffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|mapto
operator|==
name|mdp
operator|->
name|top
condition|)
block|{
name|mdp
operator|->
name|top
operator|=
name|moveto
expr_stmt|;
name|result
operator|=
operator|(
name|PTR
operator|)
name|mdp
operator|->
name|breakval
expr_stmt|;
name|mdp
operator|->
name|breakval
operator|+=
name|size
expr_stmt|;
block|}
block|}
else|else
block|{
name|result
operator|=
operator|(
name|PTR
operator|)
name|mdp
operator|->
name|breakval
expr_stmt|;
name|mdp
operator|->
name|breakval
operator|+=
name|size
expr_stmt|;
block|}
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|PTR
name|__mmalloc_remap_core
parameter_list|(
name|mdp
parameter_list|)
name|struct
name|mdesc
modifier|*
name|mdp
decl_stmt|;
block|{
name|caddr_t
name|base
decl_stmt|;
comment|/* FIXME:  Quick hack, needs error checking and other attention. */
name|base
operator|=
name|mmap
argument_list|(
name|mdp
operator|->
name|base
argument_list|,
name|mdp
operator|->
name|top
operator|-
name|mdp
operator|->
name|base
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_SHARED
operator||
name|MAP_FIXED
argument_list|,
name|mdp
operator|->
name|fd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|PTR
operator|)
name|base
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* defined(HAVE_MMAP) */
end_comment

begin_comment
comment|/* Prevent "empty translation unit" warnings from the idiots at X3J11. */
end_comment

begin_decl_stmt
specifier|static
name|char
name|ansi_c_idiots
init|=
literal|69
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(HAVE_MMAP) */
end_comment

end_unit

