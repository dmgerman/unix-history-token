begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Initialization for access to a mmap'd malloc managed region.    Copyright 1992 Free Software Foundation, Inc.     Contributed by Fred Fish at Cygnus Support.   fnf@cygnus.com  This file is part of the GNU C Library.  The GNU C Library is free software; you can redistribute it and/or modify it under the terms of the GNU Library General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  The GNU C Library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for more details.  You should have received a copy of the GNU Library General Public License along with the GNU C Library; see the file COPYING.LIB.  If not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_comment
comment|/* After sys/types.h, at least for dpx/2.  */
end_comment

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"mmalloc.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|SEEK_SET
end_ifndef

begin_define
define|#
directive|define
name|SEEK_SET
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_MMAP
argument_list|)
end_if

begin_comment
comment|/* Forward declarations/prototypes for local functions */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mdesc
modifier|*
name|reuse
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize access to a mmalloc managed region.     If FD is a valid file descriptor for an open file then data for the    mmalloc managed region is mapped to that file, otherwise "/dev/zero"    is used and the data will not exist in any filesystem object.     If the open file corresponding to FD is from a previous use of    mmalloc and passes some basic sanity checks to ensure that it is    compatible with the current mmalloc package, then it's data is    mapped in and is immediately accessible at the same addresses in    the current process as the process that created the file.     If BASEADDR is not NULL, the mapping is established starting at the    specified address in the process address space.  If BASEADDR is NULL,    the mmalloc package chooses a suitable address at which to start the    mapped region, which will be the value of the previous mapping if    opening an existing file which was previously built by mmalloc, or    for new files will be a value chosen by mmap.     Specifying BASEADDR provides more control over where the regions    start and how big they can be before bumping into existing mapped    regions or future mapped regions.     On success, returns a "malloc descriptor" which is used in subsequent    calls to other mmalloc package functions.  It is explicitly "void *"    ("char *" for systems that don't fully support void) so that users    of the package don't have to worry about the actual implementation    details.     On failure returns NULL. */
end_comment

begin_function
name|PTR
name|mmalloc_attach
parameter_list|(
name|fd
parameter_list|,
name|baseaddr
parameter_list|)
name|int
name|fd
decl_stmt|;
name|PTR
name|baseaddr
decl_stmt|;
block|{
name|struct
name|mdesc
name|mtemp
decl_stmt|;
name|struct
name|mdesc
modifier|*
name|mdp
decl_stmt|;
name|PTR
name|mbase
decl_stmt|;
name|struct
name|stat
name|sbuf
decl_stmt|;
comment|/* First check to see if FD is a valid file descriptor, and if so, see      if the file has any current contents (size> 0).  If it does, then      attempt to reuse the file.  If we can't reuse the file, either      because it isn't a valid mmalloc produced file, was produced by an      obsolete version, or any other reason, then we fail to attach to      this file. */
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|sbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|sbuf
operator|.
name|st_size
operator|>
literal|0
condition|)
block|{
return|return
operator|(
operator|(
name|PTR
operator|)
name|reuse
argument_list|(
name|fd
argument_list|)
operator|)
return|;
block|}
block|}
comment|/* We start off with the malloc descriptor allocated on the stack, until      we build it up enough to call _mmalloc_mmap_morecore() to allocate the      first page of the region and copy it there.  Ensure that it is zero'd and      then initialize the fields that we know values for. */
name|mdp
operator|=
operator|&
name|mtemp
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|mdp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mtemp
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|mdp
operator|->
name|magic
argument_list|,
name|MMALLOC_MAGIC
argument_list|,
name|MMALLOC_MAGIC_SIZE
argument_list|)
expr_stmt|;
name|mdp
operator|->
name|headersize
operator|=
sizeof|sizeof
argument_list|(
name|mtemp
argument_list|)
expr_stmt|;
name|mdp
operator|->
name|version
operator|=
name|MMALLOC_VERSION
expr_stmt|;
name|mdp
operator|->
name|morecore
operator|=
name|__mmalloc_mmap_morecore
expr_stmt|;
name|mdp
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
name|mdp
operator|->
name|base
operator|=
name|mdp
operator|->
name|breakval
operator|=
name|mdp
operator|->
name|top
operator|=
name|baseaddr
expr_stmt|;
comment|/* If we have not been passed a valid open file descriptor for the file      to map to, then open /dev/zero and use that to map to. */
if|if
condition|(
name|mdp
operator|->
name|fd
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|mdp
operator|->
name|fd
operator|=
name|open
argument_list|(
literal|"/dev/zero"
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
else|else
block|{
name|mdp
operator|->
name|flags
operator||=
name|MMALLOC_DEVZERO
expr_stmt|;
block|}
block|}
comment|/*  Now try to map in the first page, copy the malloc descriptor structure       there, and arrange to return a pointer to this new copy.  If the mapping       fails, then close the file descriptor if it was opened by us, and arrange       to return a NULL. */
if|if
condition|(
operator|(
name|mbase
operator|=
name|mdp
operator|->
name|morecore
argument_list|(
name|mdp
argument_list|,
sizeof|sizeof
argument_list|(
name|mtemp
argument_list|)
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|memcpy
argument_list|(
name|mbase
argument_list|,
name|mdp
argument_list|,
sizeof|sizeof
argument_list|(
name|mtemp
argument_list|)
argument_list|)
expr_stmt|;
name|mdp
operator|=
operator|(
expr|struct
name|mdesc
operator|*
operator|)
name|mbase
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|mdp
operator|->
name|flags
operator|&
name|MMALLOC_DEVZERO
condition|)
block|{
name|close
argument_list|(
name|mdp
operator|->
name|fd
argument_list|)
expr_stmt|;
block|}
name|mdp
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|PTR
operator|)
name|mdp
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Given an valid file descriptor on an open file, test to see if that file    is a valid mmalloc produced file, and if so, attempt to remap it into the    current process at the same address to which it was previously mapped.     Note that we have to update the file descriptor number in the malloc-    descriptor read from the file to match the current valid one, before    trying to map the file in, and again after a successful mapping and    after we've switched over to using the mapped in malloc descriptor    rather than the temporary one on the stack.     Once we've switched over to using the mapped in malloc descriptor, we    have to update the pointer to the morecore function, since it almost    certainly will be at a different address if the process reusing the    mapped region is from a different executable.     Also note that if the heap being remapped previously used the mmcheck()    routines, we need to update the hooks since their target functions    will have certainly moved if the executable has changed in any way.    We do this by calling mmcheck() internally.     Returns a pointer to the malloc descriptor if successful, or NULL if    unsuccessful for some reason. */
end_comment

begin_function
specifier|static
name|struct
name|mdesc
modifier|*
name|reuse
parameter_list|(
name|fd
parameter_list|)
name|int
name|fd
decl_stmt|;
block|{
name|struct
name|mdesc
name|mtemp
decl_stmt|;
name|struct
name|mdesc
modifier|*
name|mdp
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|(
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0L
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|read
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|mtemp
argument_list|,
sizeof|sizeof
argument_list|(
name|mtemp
argument_list|)
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|mtemp
argument_list|)
operator|)
operator|&&
operator|(
name|mtemp
operator|.
name|headersize
operator|==
sizeof|sizeof
argument_list|(
name|mtemp
argument_list|)
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|mtemp
operator|.
name|magic
argument_list|,
name|MMALLOC_MAGIC
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|mtemp
operator|.
name|version
operator|<=
name|MMALLOC_VERSION
operator|)
condition|)
block|{
name|mtemp
operator|.
name|fd
operator|=
name|fd
expr_stmt|;
if|if
condition|(
name|__mmalloc_remap_core
argument_list|(
operator|&
name|mtemp
argument_list|)
operator|==
name|mtemp
operator|.
name|base
condition|)
block|{
name|mdp
operator|=
operator|(
expr|struct
name|mdesc
operator|*
operator|)
name|mtemp
operator|.
name|base
expr_stmt|;
name|mdp
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
name|mdp
operator|->
name|morecore
operator|=
name|__mmalloc_mmap_morecore
expr_stmt|;
if|if
condition|(
name|mdp
operator|->
name|mfree_hook
operator|!=
name|NULL
condition|)
block|{
name|mmcheck
argument_list|(
operator|(
name|PTR
operator|)
name|mdp
argument_list|,
operator|(
name|void
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|mdp
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !defined (HAVE_MMAP) */
end_comment

begin_comment
comment|/* For systems without mmap, the library still supplies an entry point    to link to, but trying to initialize access to an mmap'd managed region    always fails. */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|PTR
name|mmalloc_attach
parameter_list|(
name|fd
parameter_list|,
name|baseaddr
parameter_list|)
name|int
name|fd
decl_stmt|;
name|PTR
name|baseaddr
decl_stmt|;
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined (HAVE_MMAP) */
end_comment

end_unit

