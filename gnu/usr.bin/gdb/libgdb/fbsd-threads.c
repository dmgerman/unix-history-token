begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/* FreeBSD libthread_db assisted debugging support.    Copyright 1999, 2000, 2001 Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdb_assert.h"
end_include

begin_include
include|#
directive|include
file|<dlfcn.h>
end_include

begin_include
include|#
directive|include
file|"proc_service.h"
end_include

begin_include
include|#
directive|include
file|"thread_db.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"gdbthread.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_define
define|#
directive|define
name|LIBTHREAD_DB_SO
value|"libthread_db.so"
end_define

begin_struct
struct|struct
name|ps_prochandle
block|{
name|pid_t
name|pid
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|extern
name|struct
name|target_ops
name|child_ops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This module's target vector.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|target_ops
name|thread_db_ops
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|target_ops
name|base_ops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to the next function on the objfile event chain.  */
end_comment

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
name|target_new_objfile_chain
function_decl|)
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Non-zero if we're using this module's target vector.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|using_thread_db
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero if we have to keep this module's target vector active    across re-runs.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|keep_thread_db
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Structure that identifies the child process for the<proc_service.h> interface.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ps_prochandle
name|proc_handle
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Connection to the libthread_db library.  */
end_comment

begin_decl_stmt
specifier|static
name|td_thragent_t
modifier|*
name|thread_agent
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The last thread we are single stepping */
end_comment

begin_decl_stmt
specifier|static
name|ptid_t
name|last_single_step_thread
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointers to the libthread_db functions.  */
end_comment

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|td_init_p
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|td_ta_new_p
function_decl|)
parameter_list|(
name|struct
name|ps_prochandle
modifier|*
name|ps
parameter_list|,
name|td_thragent_t
modifier|*
modifier|*
name|ta
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|td_ta_map_id2thr_p
function_decl|)
parameter_list|(
specifier|const
name|td_thragent_t
modifier|*
name|ta
parameter_list|,
name|thread_t
name|pt
parameter_list|,
name|td_thrhandle_t
modifier|*
name|__th
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|td_ta_map_lwp2thr_p
function_decl|)
parameter_list|(
specifier|const
name|td_thragent_t
modifier|*
name|ta
parameter_list|,
name|lwpid_t
name|lwpid
parameter_list|,
name|td_thrhandle_t
modifier|*
name|th
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|td_ta_thr_iter_p
function_decl|)
parameter_list|(
specifier|const
name|td_thragent_t
modifier|*
name|ta
parameter_list|,
name|td_thr_iter_f
modifier|*
name|callback
parameter_list|,
name|void
modifier|*
name|cbdata_p
parameter_list|,
name|td_thr_state_e
name|state
parameter_list|,
name|int
name|ti_pri
parameter_list|,
name|sigset_t
modifier|*
name|ti_sigmask_p
parameter_list|,
name|unsigned
name|int
name|ti_user_flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|td_ta_event_addr_p
function_decl|)
parameter_list|(
specifier|const
name|td_thragent_t
modifier|*
name|ta
parameter_list|,
name|td_event_e
name|event
parameter_list|,
name|td_notify_t
modifier|*
name|ptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|td_ta_set_event_p
function_decl|)
parameter_list|(
specifier|const
name|td_thragent_t
modifier|*
name|ta
parameter_list|,
name|td_thr_events_t
modifier|*
name|event
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|td_ta_event_getmsg_p
function_decl|)
parameter_list|(
specifier|const
name|td_thragent_t
modifier|*
name|ta
parameter_list|,
name|td_event_msg_t
modifier|*
name|msg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|td_thr_validate_p
function_decl|)
parameter_list|(
specifier|const
name|td_thrhandle_t
modifier|*
name|th
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|td_thr_get_info_p
function_decl|)
parameter_list|(
specifier|const
name|td_thrhandle_t
modifier|*
name|th
parameter_list|,
name|td_thrinfo_t
modifier|*
name|infop
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|td_thr_getfpregs_p
function_decl|)
parameter_list|(
specifier|const
name|td_thrhandle_t
modifier|*
name|th
parameter_list|,
name|prfpregset_t
modifier|*
name|regset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|td_thr_getgregs_p
function_decl|)
parameter_list|(
specifier|const
name|td_thrhandle_t
modifier|*
name|th
parameter_list|,
name|prgregset_t
name|gregs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|td_thr_setfpregs_p
function_decl|)
parameter_list|(
specifier|const
name|td_thrhandle_t
modifier|*
name|th
parameter_list|,
specifier|const
name|prfpregset_t
modifier|*
name|fpregs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|td_thr_setgregs_p
function_decl|)
parameter_list|(
specifier|const
name|td_thrhandle_t
modifier|*
name|th
parameter_list|,
name|prgregset_t
name|gregs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|td_thr_event_enable_p
function_decl|)
parameter_list|(
specifier|const
name|td_thrhandle_t
modifier|*
name|th
parameter_list|,
name|int
name|event
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|td_thr_sstep_p
function_decl|)
parameter_list|(
name|td_thrhandle_t
modifier|*
name|th
parameter_list|,
name|int
name|step
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|td_ta_tsd_iter_p
function_decl|)
parameter_list|(
specifier|const
name|td_thragent_t
modifier|*
name|ta
parameter_list|,
name|td_key_iter_f
modifier|*
name|func
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|td_thr_dbsuspend_p
function_decl|)
parameter_list|(
specifier|const
name|td_thrhandle_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|td_thr_dbresume_p
function_decl|)
parameter_list|(
specifier|const
name|td_thrhandle_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Prototypes for local functions.  */
end_comment

begin_function_decl
specifier|static
name|void
name|fbsd_thread_find_new_threads
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Building process ids.  */
end_comment

begin_define
define|#
directive|define
name|GET_PID
parameter_list|(
name|ptid
parameter_list|)
value|ptid_get_pid (ptid)
end_define

begin_define
define|#
directive|define
name|GET_LWP
parameter_list|(
name|ptid
parameter_list|)
value|ptid_get_lwp (ptid)
end_define

begin_define
define|#
directive|define
name|GET_THREAD
parameter_list|(
name|ptid
parameter_list|)
value|ptid_get_tid (ptid)
end_define

begin_define
define|#
directive|define
name|IS_LWP
parameter_list|(
name|ptid
parameter_list|)
value|(GET_LWP (ptid) != 0)
end_define

begin_define
define|#
directive|define
name|IS_THREAD
parameter_list|(
name|ptid
parameter_list|)
value|(GET_THREAD (ptid) != 0)
end_define

begin_define
define|#
directive|define
name|BUILD_LWP
parameter_list|(
name|lwp
parameter_list|,
name|pid
parameter_list|)
value|ptid_build (pid, lwp, 0)
end_define

begin_define
define|#
directive|define
name|BUILD_THREAD
parameter_list|(
name|tid
parameter_list|,
name|pid
parameter_list|)
value|ptid_build (pid, 0, tid)
end_define

begin_function
specifier|static
name|char
modifier|*
name|thread_db_err_str
parameter_list|(
name|td_err_e
name|err
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
switch|switch
condition|(
name|err
condition|)
block|{
case|case
name|TD_OK
case|:
return|return
literal|"generic 'call succeeded'"
return|;
case|case
name|TD_ERR
case|:
return|return
literal|"generic error"
return|;
case|case
name|TD_NOTHR
case|:
return|return
literal|"no thread to satisfy query"
return|;
case|case
name|TD_NOSV
case|:
return|return
literal|"no sync handle to satisfy query"
return|;
case|case
name|TD_NOLWP
case|:
return|return
literal|"no LWP to satisfy query"
return|;
case|case
name|TD_BADPH
case|:
return|return
literal|"invalid process handle"
return|;
case|case
name|TD_BADTH
case|:
return|return
literal|"invalid thread handle"
return|;
case|case
name|TD_BADSH
case|:
return|return
literal|"invalid synchronization handle"
return|;
case|case
name|TD_BADTA
case|:
return|return
literal|"invalid thread agent"
return|;
case|case
name|TD_BADKEY
case|:
return|return
literal|"invalid key"
return|;
case|case
name|TD_NOMSG
case|:
return|return
literal|"no event message for getmsg"
return|;
case|case
name|TD_NOFPREGS
case|:
return|return
literal|"FPU register set not available"
return|;
case|case
name|TD_NOLIBTHREAD
case|:
return|return
literal|"application not linked with libthread"
return|;
case|case
name|TD_NOEVENT
case|:
return|return
literal|"requested event is not supported"
return|;
case|case
name|TD_NOCAPAB
case|:
return|return
literal|"capability not available"
return|;
case|case
name|TD_DBERR
case|:
return|return
literal|"debugger service failed"
return|;
case|case
name|TD_NOAPLIC
case|:
return|return
literal|"operation not applicable to"
return|;
case|case
name|TD_NOTSD
case|:
return|return
literal|"no thread-specific data for this thread"
return|;
case|case
name|TD_MALLOC
case|:
return|return
literal|"malloc failed"
return|;
case|case
name|TD_PARTIALREG
case|:
return|return
literal|"only part of register set was written/read"
return|;
case|case
name|TD_NOXREGS
case|:
return|return
literal|"X register set not available for this thread"
return|;
default|default:
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"unknown thread_db error '%d'"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|thread_db_state_str
parameter_list|(
name|td_thr_state_e
name|state
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|TD_THR_STOPPED
case|:
return|return
literal|"stopped by debugger"
return|;
case|case
name|TD_THR_RUN
case|:
return|return
literal|"runnable"
return|;
case|case
name|TD_THR_ACTIVE
case|:
return|return
literal|"active"
return|;
case|case
name|TD_THR_ZOMBIE
case|:
return|return
literal|"zombie"
return|;
case|case
name|TD_THR_SLEEP
case|:
return|return
literal|"sleeping"
return|;
case|case
name|TD_THR_STOPPED_ASLEEP
case|:
return|return
literal|"stopped by debugger AND blocked"
return|;
default|default:
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"unknown thread_db state %d"
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
block|}
end_function

begin_comment
comment|/* Convert LWP to user-level thread id. */
end_comment

begin_function
specifier|static
name|ptid_t
name|thread_from_lwp
parameter_list|(
name|ptid_t
name|ptid
parameter_list|)
block|{
name|td_thrinfo_t
name|ti
decl_stmt|;
name|td_thrhandle_t
name|th
decl_stmt|;
name|td_err_e
name|err
decl_stmt|;
name|gdb_assert
argument_list|(
name|IS_LWP
argument_list|(
name|ptid
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|td_ta_map_lwp2thr_p
argument_list|(
name|thread_agent
argument_list|,
name|GET_LWP
argument_list|(
name|ptid
argument_list|)
argument_list|,
operator|&
name|th
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|TD_OK
condition|)
block|{
name|err
operator|=
name|td_thr_get_info_p
argument_list|(
operator|&
name|th
argument_list|,
operator|&
name|ti
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|TD_OK
condition|)
name|error
argument_list|(
literal|"Cannot get thread info: %s"
argument_list|,
name|thread_db_err_str
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|BUILD_THREAD
argument_list|(
name|ti
operator|.
name|ti_tid
argument_list|,
name|GET_PID
argument_list|(
name|ptid
argument_list|)
argument_list|)
return|;
block|}
comment|/* the LWP is not mapped to user thread */
return|return
name|BUILD_LWP
argument_list|(
name|GET_LWP
argument_list|(
name|ptid
argument_list|)
argument_list|,
name|GET_PID
argument_list|(
name|ptid
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|long
name|get_current_lwp
parameter_list|(
name|int
name|pid
parameter_list|)
block|{
name|struct
name|ptrace_lwpinfo
name|pl
decl_stmt|;
if|if
condition|(
name|ptrace
argument_list|(
name|PT_LWPINFO
argument_list|,
name|pid
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|pl
argument_list|,
sizeof|sizeof
argument_list|(
name|pl
argument_list|)
argument_list|)
condition|)
name|perror_with_name
argument_list|(
literal|"PT_LWPINFO"
argument_list|)
expr_stmt|;
return|return
operator|(
name|long
operator|)
name|pl
operator|.
name|pl_lwpid
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|get_current_thread
parameter_list|()
block|{
name|long
name|lwp
decl_stmt|;
name|ptid_t
name|tmp
decl_stmt|,
name|ptid
decl_stmt|;
name|lwp
operator|=
name|get_current_lwp
argument_list|(
name|proc_handle
operator|.
name|pid
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|BUILD_LWP
argument_list|(
name|lwp
argument_list|,
name|proc_handle
operator|.
name|pid
argument_list|)
expr_stmt|;
name|ptid
operator|=
name|thread_from_lwp
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|in_thread_list
argument_list|(
name|ptid
argument_list|)
condition|)
block|{
name|add_thread
argument_list|(
name|ptid
argument_list|)
expr_stmt|;
name|inferior_ptid
operator|=
name|ptid
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|fbsd_thread_new_objfile
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|td_err_e
name|err
decl_stmt|;
comment|/* Don't attempt to use thread_db on targets which can not run      (core files).  */
if|if
condition|(
name|objfile
operator|==
name|NULL
operator|||
operator|!
name|target_has_execution
condition|)
block|{
comment|/* All symbols have been discarded.  If the thread_db target is          active, deactivate it now.  */
if|if
condition|(
name|using_thread_db
condition|)
block|{
name|gdb_assert
argument_list|(
name|proc_handle
operator|.
name|pid
operator|==
literal|0
argument_list|)
expr_stmt|;
name|unpush_target
argument_list|(
operator|&
name|thread_db_ops
argument_list|)
expr_stmt|;
name|using_thread_db
operator|=
literal|0
expr_stmt|;
block|}
name|keep_thread_db
operator|=
literal|0
expr_stmt|;
goto|goto
name|quit
goto|;
block|}
if|if
condition|(
name|using_thread_db
condition|)
comment|/* Nothing to do.  The thread library was already detected and the        target vector was already activated.  */
goto|goto
name|quit
goto|;
comment|/* Initialize the structure that identifies the child process.  Note      that at this point there is no guarantee that we actually have a      child process.  */
name|proc_handle
operator|.
name|pid
operator|=
name|GET_PID
argument_list|(
name|inferior_ptid
argument_list|)
expr_stmt|;
comment|/* Now attempt to open a connection to the thread library.  */
name|err
operator|=
name|td_ta_new_p
argument_list|(
operator|&
name|proc_handle
argument_list|,
operator|&
name|thread_agent
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|err
condition|)
block|{
case|case
name|TD_NOLIBTHREAD
case|:
comment|/* No thread library was detected.  */
break|break;
case|case
name|TD_OK
case|:
comment|/* The thread library was detected.  Activate the thread_db target.  */
name|base_ops
operator|=
name|current_target
expr_stmt|;
name|push_target
argument_list|(
operator|&
name|thread_db_ops
argument_list|)
expr_stmt|;
name|using_thread_db
operator|=
literal|1
expr_stmt|;
comment|/* If the thread library was detected in the main symbol file          itself, we assume that the program was statically linked          against the thread library and well have to keep this          module's target vector activated until forever...  Well, at          least until all symbols have been discarded anyway (see          above).  */
if|if
condition|(
name|objfile
operator|==
name|symfile_objfile
condition|)
block|{
name|gdb_assert
argument_list|(
name|proc_handle
operator|.
name|pid
operator|==
literal|0
argument_list|)
expr_stmt|;
name|keep_thread_db
operator|=
literal|1
expr_stmt|;
block|}
comment|/* We can only poke around if there actually is a child process.          If there is no child process alive, postpone the steps below          until one has been created.  */
if|if
condition|(
name|proc_handle
operator|.
name|pid
operator|!=
literal|0
condition|)
block|{
name|fbsd_thread_find_new_threads
argument_list|()
expr_stmt|;
name|get_current_thread
argument_list|()
expr_stmt|;
block|}
else|else
name|printf_filtered
argument_list|(
literal|"%s postpone processing\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
break|break;
default|default:
name|warning
argument_list|(
literal|"Cannot initialize thread debugging library: %s"
argument_list|,
name|thread_db_err_str
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|quit
label|:
if|if
condition|(
name|target_new_objfile_chain
condition|)
name|target_new_objfile_chain
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fbsd_thread_attach
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|child_ops
operator|.
name|to_attach
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
comment|/* Destroy thread info; it's no longer valid.  */
name|init_thread_list
argument_list|()
expr_stmt|;
comment|/* The child process is now the actual multi-threaded      program.  Snatch its process ID...  */
name|proc_handle
operator|.
name|pid
operator|=
name|GET_PID
argument_list|(
name|inferior_ptid
argument_list|)
expr_stmt|;
comment|/* ...and perform the remaining initialization steps.  */
name|fbsd_thread_find_new_threads
argument_list|()
expr_stmt|;
name|get_current_thread
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fbsd_thread_detach
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|proc_handle
operator|.
name|pid
operator|=
literal|0
expr_stmt|;
name|child_ops
operator|.
name|to_detach
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|suspend_thread_callback
parameter_list|(
specifier|const
name|td_thrhandle_t
modifier|*
name|th_p
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
return|return
name|td_thr_dbsuspend_p
argument_list|(
name|th_p
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|resume_thread_callback
parameter_list|(
specifier|const
name|td_thrhandle_t
modifier|*
name|th_p
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
return|return
name|td_thr_dbresume_p
argument_list|(
name|th_p
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fbsd_thread_resume
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|int
name|step
parameter_list|,
name|enum
name|target_signal
name|signo
parameter_list|)
block|{
name|td_thrhandle_t
name|th
decl_stmt|;
name|td_thrinfo_t
name|ti
decl_stmt|;
name|ptid_t
name|work_ptid
decl_stmt|;
name|int
name|resume_all
decl_stmt|,
name|ret
decl_stmt|;
name|long
name|lwp
decl_stmt|,
name|thvalid
init|=
literal|0
decl_stmt|;
if|#
directive|if
literal|0
block|printf_filtered("%s ptid=%ld.%ld.%ld step=%d\n", __func__, 	GET_PID(ptid), GET_LWP(ptid), GET_THREAD(ptid), step);   printf_filtered("%s inferior_ptid=%ld.%ld.%ld\n", __func__, 	GET_PID(inferior_ptid), GET_LWP(inferior_ptid), 	GET_THREAD(inferior_ptid));
endif|#
directive|endif
if|if
condition|(
name|proc_handle
operator|.
name|pid
operator|==
literal|0
condition|)
block|{
name|base_ops
operator|.
name|to_resume
argument_list|(
name|ptid
argument_list|,
name|step
argument_list|,
name|signo
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|GET_PID
argument_list|(
name|ptid
argument_list|)
operator|!=
operator|-
literal|1
operator|&&
name|step
operator|!=
literal|0
condition|)
block|{
name|resume_all
operator|=
literal|0
expr_stmt|;
name|work_ptid
operator|=
name|ptid
expr_stmt|;
block|}
else|else
block|{
name|resume_all
operator|=
literal|1
expr_stmt|;
name|work_ptid
operator|=
name|inferior_ptid
expr_stmt|;
block|}
name|lwp
operator|=
name|GET_LWP
argument_list|(
name|work_ptid
argument_list|)
expr_stmt|;
if|if
condition|(
name|lwp
operator|==
literal|0
condition|)
block|{
comment|/* check user thread */
name|ret
operator|=
name|td_ta_map_id2thr_p
argument_list|(
name|thread_agent
argument_list|,
name|GET_THREAD
argument_list|(
name|work_ptid
argument_list|)
argument_list|,
operator|&
name|th
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|error
argument_list|(
name|thread_db_err_str
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
comment|/*        * For M:N thread, we need to tell UTS to set/unset single step        * flag at context switch time, the flag will be written into        * thread mailbox. This becauses some architecture may not have        * machine single step flag in ucontext, so we put the flag in mailbox,        * when the thread switches back, kse_switchin restores the single step        * state.        */
name|ret
operator|=
name|td_thr_sstep_p
argument_list|(
operator|&
name|th
argument_list|,
name|step
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|error
argument_list|(
name|thread_db_err_str
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|td_thr_get_info_p
argument_list|(
operator|&
name|th
argument_list|,
operator|&
name|ti
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|error
argument_list|(
name|thread_db_err_str
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
name|thvalid
operator|=
literal|1
expr_stmt|;
name|lwp
operator|=
name|ti
operator|.
name|ti_lid
expr_stmt|;
block|}
if|if
condition|(
name|lwp
condition|)
block|{
name|int
name|req
init|=
name|step
condition|?
name|PT_SETSTEP
else|:
name|PT_CLEARSTEP
decl_stmt|;
if|if
condition|(
name|ptrace
argument_list|(
name|req
argument_list|,
operator|(
name|pid_t
operator|)
name|lwp
argument_list|,
operator|(
name|caddr_t
operator|)
literal|1
argument_list|,
name|target_signal_to_host
argument_list|(
name|signo
argument_list|)
argument_list|)
condition|)
name|perror_with_name
argument_list|(
literal|"PT_SETSTEP/PT_CLEARSTEP"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ptid_equal
argument_list|(
name|last_single_step_thread
argument_list|,
name|null_ptid
argument_list|)
condition|)
block|{
name|ret
operator|=
name|td_ta_thr_iter_p
argument_list|(
name|thread_agent
argument_list|,
name|resume_thread_callback
argument_list|,
name|NULL
argument_list|,
name|TD_THR_ANY_STATE
argument_list|,
name|TD_THR_LOWEST_PRIORITY
argument_list|,
name|TD_SIGNO_MASK
argument_list|,
name|TD_THR_ANY_USER_FLAGS
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|TD_OK
condition|)
name|error
argument_list|(
literal|"resume error: %s"
argument_list|,
name|thread_db_err_str
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|resume_all
condition|)
block|{
name|ret
operator|=
name|td_ta_thr_iter_p
argument_list|(
name|thread_agent
argument_list|,
name|suspend_thread_callback
argument_list|,
name|NULL
argument_list|,
name|TD_THR_ANY_STATE
argument_list|,
name|TD_THR_LOWEST_PRIORITY
argument_list|,
name|TD_SIGNO_MASK
argument_list|,
name|TD_THR_ANY_USER_FLAGS
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|TD_OK
condition|)
name|error
argument_list|(
literal|"suspend error: %s"
argument_list|,
name|thread_db_err_str
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
name|last_single_step_thread
operator|=
name|work_ptid
expr_stmt|;
block|}
else|else
name|last_single_step_thread
operator|=
name|null_ptid
expr_stmt|;
if|if
condition|(
name|thvalid
condition|)
block|{
name|ret
operator|=
name|td_thr_dbresume_p
argument_list|(
operator|&
name|th
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|TD_OK
condition|)
name|error
argument_list|(
literal|"resume error: %s"
argument_list|,
name|thread_db_err_str
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* it is not necessary, put it here for completness */
name|ret
operator|=
name|ptrace
argument_list|(
name|PT_RESUME
argument_list|,
name|lwp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* now continue the process, suspended thread wont run */
if|if
condition|(
name|ptrace
argument_list|(
name|PT_CONTINUE
argument_list|,
name|proc_handle
operator|.
name|pid
argument_list|,
operator|(
name|caddr_t
operator|)
literal|1
argument_list|,
name|target_signal_to_host
argument_list|(
name|signo
argument_list|)
argument_list|)
condition|)
name|perror_with_name
argument_list|(
literal|"PT_CONTINUE"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|ptid_t
name|fbsd_thread_wait
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|struct
name|target_waitstatus
modifier|*
name|ourstatus
parameter_list|)
block|{
name|ptid_t
name|ret
decl_stmt|;
name|long
name|lwp
decl_stmt|;
name|CORE_ADDR
name|stop_pc
decl_stmt|;
name|ret
operator|=
name|child_ops
operator|.
name|to_wait
argument_list|(
name|ptid
argument_list|,
name|ourstatus
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_PID
argument_list|(
name|ret
argument_list|)
operator|>=
literal|0
operator|&&
name|ourstatus
operator|->
name|kind
operator|==
name|TARGET_WAITKIND_STOPPED
condition|)
block|{
name|lwp
operator|=
name|get_current_lwp
argument_list|(
name|proc_handle
operator|.
name|pid
argument_list|)
expr_stmt|;
name|ret
operator|=
name|thread_from_lwp
argument_list|(
name|BUILD_LWP
argument_list|(
name|lwp
argument_list|,
name|GET_PID
argument_list|(
name|ret
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|in_thread_list
argument_list|(
name|ret
argument_list|)
condition|)
name|add_thread
argument_list|(
name|ret
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fbsd_thread_xfer_memory
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|write
parameter_list|,
name|struct
name|mem_attrib
modifier|*
name|attrib
parameter_list|,
name|struct
name|target_ops
modifier|*
name|target
parameter_list|)
block|{
return|return
name|base_ops
operator|.
name|to_xfer_memory
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|,
name|write
argument_list|,
name|attrib
argument_list|,
name|target
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fbsd_lwp_fetch_registers
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
name|gregset_t
name|gregs
decl_stmt|;
name|fpregset_t
name|fpregs
decl_stmt|;
name|lwpid_t
name|lwp
decl_stmt|;
comment|/* FIXME, use base_ops to fetch lwp registers! */
name|lwp
operator|=
name|GET_LWP
argument_list|(
name|inferior_ptid
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptrace
argument_list|(
name|PT_GETREGS
argument_list|,
name|lwp
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|gregs
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"Cannot get lwp %d registers: %s\n"
argument_list|,
name|lwp
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|supply_gregset
argument_list|(
operator|&
name|gregs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptrace
argument_list|(
name|PT_GETFPREGS
argument_list|,
name|lwp
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|fpregs
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"Cannot get lwp %d registers: %s\n "
argument_list|,
name|lwp
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|supply_fpregset
argument_list|(
operator|&
name|fpregs
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fbsd_thread_fetch_registers
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
name|prgregset_t
name|gregset
decl_stmt|;
name|prfpregset_t
name|fpregset
decl_stmt|;
name|td_thrhandle_t
name|th
decl_stmt|;
name|td_err_e
name|err
decl_stmt|;
if|if
condition|(
operator|!
name|IS_THREAD
argument_list|(
name|inferior_ptid
argument_list|)
condition|)
block|{
name|fbsd_lwp_fetch_registers
argument_list|(
name|regno
argument_list|)
expr_stmt|;
return|return;
block|}
name|err
operator|=
name|td_ta_map_id2thr_p
argument_list|(
name|thread_agent
argument_list|,
name|GET_THREAD
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
operator|&
name|th
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|TD_OK
condition|)
name|error
argument_list|(
literal|"Cannot find thread %d: Thread ID=%ld, %s"
argument_list|,
name|pid_to_thread_id
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
name|GET_THREAD
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
name|thread_db_err_str
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|td_thr_getgregs_p
argument_list|(
operator|&
name|th
argument_list|,
name|gregset
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|TD_OK
condition|)
name|error
argument_list|(
literal|"Cannot fetch general-purpose registers for thread %d: Thread ID=%ld, %s"
argument_list|,
name|pid_to_thread_id
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
name|GET_THREAD
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
name|thread_db_err_str
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|td_thr_getfpregs_p
argument_list|(
operator|&
name|th
argument_list|,
operator|&
name|fpregset
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|TD_OK
condition|)
name|error
argument_list|(
literal|"Cannot get floating-point registers for thread %d: Thread ID=%ld, %s"
argument_list|,
name|pid_to_thread_id
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
name|GET_THREAD
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
name|thread_db_err_str
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
name|supply_gregset
argument_list|(
name|gregset
argument_list|)
expr_stmt|;
name|supply_fpregset
argument_list|(
operator|&
name|fpregset
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fbsd_lwp_store_registers
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
name|gregset_t
name|gregs
decl_stmt|;
name|fpregset_t
name|fpregs
decl_stmt|;
name|lwpid_t
name|lwp
decl_stmt|;
comment|/* FIXME, is it possible ? */
if|if
condition|(
operator|!
name|IS_LWP
argument_list|(
name|inferior_ptid
argument_list|)
condition|)
block|{
name|child_ops
operator|.
name|to_store_registers
argument_list|(
name|regno
argument_list|)
expr_stmt|;
return|return ;
block|}
name|lwp
operator|=
name|GET_LWP
argument_list|(
name|inferior_ptid
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|!=
operator|-
literal|1
condition|)
if|if
condition|(
name|ptrace
argument_list|(
name|PT_GETREGS
argument_list|,
name|lwp
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|gregs
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"Cannot get lwp %d registers: %s\n"
argument_list|,
name|lwp
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|fill_gregset
argument_list|(
operator|&
name|gregs
argument_list|,
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptrace
argument_list|(
name|PT_SETREGS
argument_list|,
name|lwp
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|gregs
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"Cannot set lwp %d registers: %s\n"
argument_list|,
name|lwp
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|!=
operator|-
literal|1
condition|)
if|if
condition|(
name|ptrace
argument_list|(
name|PT_GETFPREGS
argument_list|,
name|lwp
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|fpregs
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"Cannot get lwp %d float registers: %s\n"
argument_list|,
name|lwp
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|fill_fpregset
argument_list|(
operator|&
name|fpregs
argument_list|,
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptrace
argument_list|(
name|PT_SETFPREGS
argument_list|,
name|lwp
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|fpregs
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"Cannot set lwp %d float registers: %s\n"
argument_list|,
name|lwp
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fbsd_thread_store_registers
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
name|prgregset_t
name|gregset
decl_stmt|;
name|prfpregset_t
name|fpregset
decl_stmt|;
name|td_thrhandle_t
name|th
decl_stmt|;
name|td_err_e
name|err
decl_stmt|;
if|if
condition|(
operator|!
name|IS_THREAD
argument_list|(
name|inferior_ptid
argument_list|)
condition|)
block|{
name|fbsd_lwp_store_registers
argument_list|(
name|regno
argument_list|)
expr_stmt|;
return|return;
block|}
name|err
operator|=
name|td_ta_map_id2thr_p
argument_list|(
name|thread_agent
argument_list|,
name|GET_THREAD
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
operator|&
name|th
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|TD_OK
condition|)
name|error
argument_list|(
literal|"Cannot find thread %d: Thread ID=%ld, %s"
argument_list|,
name|pid_to_thread_id
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
name|GET_THREAD
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
name|thread_db_err_str
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|!=
operator|-
literal|1
condition|)
block|{
name|char
name|old_value
index|[
name|MAX_REGISTER_SIZE
index|]
decl_stmt|;
name|regcache_collect
argument_list|(
name|regno
argument_list|,
name|old_value
argument_list|)
expr_stmt|;
name|err
operator|=
name|td_thr_getgregs_p
argument_list|(
operator|&
name|th
argument_list|,
name|gregset
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|TD_OK
condition|)
name|error
argument_list|(
literal|"%s: td_thr_getgregs %s"
argument_list|,
name|__func__
argument_list|,
name|thread_db_err_str
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|td_thr_getfpregs_p
argument_list|(
operator|&
name|th
argument_list|,
operator|&
name|fpregset
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|TD_OK
condition|)
name|error
argument_list|(
literal|"%s: td_thr_getfpgregs %s"
argument_list|,
name|__func__
argument_list|,
name|thread_db_err_str
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|regno
argument_list|,
name|old_value
argument_list|)
expr_stmt|;
block|}
name|fill_gregset
argument_list|(
name|gregset
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|fill_fpregset
argument_list|(
operator|&
name|fpregset
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|err
operator|=
name|td_thr_setgregs_p
argument_list|(
operator|&
name|th
argument_list|,
name|gregset
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|TD_OK
condition|)
name|error
argument_list|(
literal|"Cannot store general-purpose registers for thread %d: Thread ID=%d, %s"
argument_list|,
name|pid_to_thread_id
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
name|GET_THREAD
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
name|thread_db_err_str
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|td_thr_setfpregs_p
argument_list|(
operator|&
name|th
argument_list|,
operator|&
name|fpregset
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|TD_OK
condition|)
name|error
argument_list|(
literal|"Cannot store floating-point registers for thread %d: Thread ID=%d, %s"
argument_list|,
name|pid_to_thread_id
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
name|GET_THREAD
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
name|thread_db_err_str
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fbsd_thread_kill
parameter_list|(
name|void
parameter_list|)
block|{
name|child_ops
operator|.
name|to_kill
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fbsd_thread_create_inferior
parameter_list|(
name|char
modifier|*
name|exec_file
parameter_list|,
name|char
modifier|*
name|allargs
parameter_list|,
name|char
modifier|*
modifier|*
name|env
parameter_list|)
block|{
if|if
condition|(
operator|!
name|keep_thread_db
condition|)
block|{
name|unpush_target
argument_list|(
operator|&
name|thread_db_ops
argument_list|)
expr_stmt|;
name|using_thread_db
operator|=
literal|0
expr_stmt|;
block|}
name|child_ops
operator|.
name|to_create_inferior
argument_list|(
name|exec_file
argument_list|,
name|allargs
argument_list|,
name|env
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fbsd_thread_post_startup_inferior
parameter_list|(
name|ptid_t
name|ptid
parameter_list|)
block|{
if|if
condition|(
name|proc_handle
operator|.
name|pid
operator|==
literal|0
condition|)
block|{
comment|/*        * The child process is now the actual multi-threaded        * program.  Snatch its process ID...         */
name|proc_handle
operator|.
name|pid
operator|=
name|GET_PID
argument_list|(
name|ptid
argument_list|)
expr_stmt|;
name|fbsd_thread_find_new_threads
argument_list|()
expr_stmt|;
name|get_current_thread
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|fbsd_thread_mourn_inferior
parameter_list|(
name|void
parameter_list|)
block|{
comment|/*    * Forget about the child's process ID.  We shouldn't need it    * anymore.    */
name|proc_handle
operator|.
name|pid
operator|=
literal|0
expr_stmt|;
name|child_ops
operator|.
name|to_mourn_inferior
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|fbsd_thread_alive
parameter_list|(
name|ptid_t
name|ptid
parameter_list|)
block|{
name|td_thrhandle_t
name|th
decl_stmt|;
name|td_thrinfo_t
name|ti
decl_stmt|;
name|td_err_e
name|err
decl_stmt|;
name|gregset_t
name|gregs
decl_stmt|;
if|if
condition|(
name|IS_THREAD
argument_list|(
name|ptid
argument_list|)
condition|)
block|{
name|err
operator|=
name|td_ta_map_id2thr_p
argument_list|(
name|thread_agent
argument_list|,
name|GET_THREAD
argument_list|(
name|ptid
argument_list|)
argument_list|,
operator|&
name|th
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|TD_OK
condition|)
return|return
literal|0
return|;
name|err
operator|=
name|td_thr_get_info_p
argument_list|(
operator|&
name|th
argument_list|,
operator|&
name|ti
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|TD_OK
condition|)
return|return
literal|0
return|;
comment|/* A zombie thread. */
if|if
condition|(
name|ti
operator|.
name|ti_state
operator|==
name|TD_THR_UNKNOWN
operator|||
name|ti
operator|.
name|ti_state
operator|==
name|TD_THR_ZOMBIE
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|GET_LWP
argument_list|(
name|ptid
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* we sometimes are called with lwp == 0 */
return|return
literal|1
return|;
block|}
name|err
operator|=
name|td_ta_map_lwp2thr_p
argument_list|(
name|thread_agent
argument_list|,
name|GET_LWP
argument_list|(
name|ptid
argument_list|)
argument_list|,
operator|&
name|th
argument_list|)
expr_stmt|;
comment|/*     * if the lwp was already mapped to user thread, don't use it     * directly, please use user thread id instead.     */
if|if
condition|(
name|err
operator|==
name|TD_OK
condition|)
return|return
literal|0
return|;
comment|/* check lwp in kernel */
return|return
name|ptrace
argument_list|(
name|PT_GETREGS
argument_list|,
name|GET_LWP
argument_list|(
name|ptid
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|gregs
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|find_new_threads_callback
parameter_list|(
specifier|const
name|td_thrhandle_t
modifier|*
name|th_p
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|td_thrinfo_t
name|ti
decl_stmt|;
name|td_err_e
name|err
decl_stmt|;
name|ptid_t
name|ptid
decl_stmt|;
name|err
operator|=
name|td_thr_get_info_p
argument_list|(
name|th_p
argument_list|,
operator|&
name|ti
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|TD_OK
condition|)
name|error
argument_list|(
literal|"Cannot get thread info: %s"
argument_list|,
name|thread_db_err_str
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Ignore zombie */
if|if
condition|(
name|ti
operator|.
name|ti_state
operator|==
name|TD_THR_UNKNOWN
operator|||
name|ti
operator|.
name|ti_state
operator|==
name|TD_THR_ZOMBIE
condition|)
return|return
literal|0
return|;
name|ptid
operator|=
name|BUILD_THREAD
argument_list|(
name|ti
operator|.
name|ti_tid
argument_list|,
name|GET_PID
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|in_thread_list
argument_list|(
name|ptid
argument_list|)
condition|)
name|add_thread
argument_list|(
name|ptid
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fbsd_thread_find_new_threads
parameter_list|(
name|void
parameter_list|)
block|{
name|td_err_e
name|err
decl_stmt|;
comment|/* Iterate over all user-space threads to discover new threads. */
name|err
operator|=
name|td_ta_thr_iter_p
argument_list|(
name|thread_agent
argument_list|,
name|find_new_threads_callback
argument_list|,
name|NULL
argument_list|,
name|TD_THR_ANY_STATE
argument_list|,
name|TD_THR_LOWEST_PRIORITY
argument_list|,
name|TD_SIGNO_MASK
argument_list|,
name|TD_THR_ANY_USER_FLAGS
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|TD_OK
condition|)
name|error
argument_list|(
literal|"Cannot find new threads: %s"
argument_list|,
name|thread_db_err_str
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|fbsd_thread_pid_to_str
parameter_list|(
name|ptid_t
name|ptid
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
if|if
condition|(
name|IS_THREAD
argument_list|(
name|ptid
argument_list|)
condition|)
block|{
name|td_thrhandle_t
name|th
decl_stmt|;
name|td_thrinfo_t
name|ti
decl_stmt|;
name|td_err_e
name|err
decl_stmt|;
name|err
operator|=
name|td_ta_map_id2thr_p
argument_list|(
name|thread_agent
argument_list|,
name|GET_THREAD
argument_list|(
name|ptid
argument_list|)
argument_list|,
operator|&
name|th
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|TD_OK
condition|)
name|error
argument_list|(
literal|"Cannot find thread, Thread ID=%ld, %s"
argument_list|,
name|GET_THREAD
argument_list|(
name|ptid
argument_list|)
argument_list|,
name|thread_db_err_str
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|td_thr_get_info_p
argument_list|(
operator|&
name|th
argument_list|,
operator|&
name|ti
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|TD_OK
condition|)
name|error
argument_list|(
literal|"Cannot get thread info, Thread ID=%ld, %s"
argument_list|,
name|GET_THREAD
argument_list|(
name|ptid
argument_list|)
argument_list|,
name|thread_db_err_str
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ti
operator|.
name|ti_lid
operator|!=
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"Thread %ld (LWP %d)"
argument_list|,
name|GET_THREAD
argument_list|(
name|ptid
argument_list|)
argument_list|,
name|ti
operator|.
name|ti_lid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"Thread %ld (%s)"
argument_list|,
name|GET_THREAD
argument_list|(
name|ptid
argument_list|)
argument_list|,
name|thread_db_state_str
argument_list|(
name|ti
operator|.
name|ti_state
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
return|;
block|}
elseif|else
if|if
condition|(
name|IS_LWP
argument_list|(
name|ptid
argument_list|)
condition|)
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"LWP %d"
argument_list|,
operator|(
name|int
operator|)
name|GET_LWP
argument_list|(
name|ptid
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
return|return
name|normal_pid_to_str
argument_list|(
name|ptid
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tsd_cb
parameter_list|(
name|thread_key_t
name|key
parameter_list|,
name|void
function_decl|(
modifier|*
name|destructor
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|ignore
parameter_list|)
block|{
name|struct
name|minimal_symbol
modifier|*
name|ms
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|ms
operator|=
name|lookup_minimal_symbol_by_pc
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|destructor
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ms
condition|)
name|name
operator|=
literal|"???"
expr_stmt|;
else|else
name|name
operator|=
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|ms
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Destructor %p<%s>\n"
argument_list|,
name|destructor
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fbsd_thread_tsd_cmd
parameter_list|(
name|char
modifier|*
name|exp
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|td_ta_tsd_iter_p
argument_list|(
name|thread_agent
argument_list|,
name|tsd_cb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_thread_db_ops
parameter_list|(
name|void
parameter_list|)
block|{
name|thread_db_ops
operator|.
name|to_shortname
operator|=
literal|"multi-thread"
expr_stmt|;
name|thread_db_ops
operator|.
name|to_longname
operator|=
literal|"multi-threaded child process."
expr_stmt|;
name|thread_db_ops
operator|.
name|to_doc
operator|=
literal|"Threads and pthreads support."
expr_stmt|;
name|thread_db_ops
operator|.
name|to_attach
operator|=
name|fbsd_thread_attach
expr_stmt|;
name|thread_db_ops
operator|.
name|to_detach
operator|=
name|fbsd_thread_detach
expr_stmt|;
name|thread_db_ops
operator|.
name|to_resume
operator|=
name|fbsd_thread_resume
expr_stmt|;
name|thread_db_ops
operator|.
name|to_wait
operator|=
name|fbsd_thread_wait
expr_stmt|;
name|thread_db_ops
operator|.
name|to_fetch_registers
operator|=
name|fbsd_thread_fetch_registers
expr_stmt|;
name|thread_db_ops
operator|.
name|to_store_registers
operator|=
name|fbsd_thread_store_registers
expr_stmt|;
name|thread_db_ops
operator|.
name|to_xfer_memory
operator|=
name|fbsd_thread_xfer_memory
expr_stmt|;
name|thread_db_ops
operator|.
name|to_kill
operator|=
name|fbsd_thread_kill
expr_stmt|;
name|thread_db_ops
operator|.
name|to_create_inferior
operator|=
name|fbsd_thread_create_inferior
expr_stmt|;
name|thread_db_ops
operator|.
name|to_post_startup_inferior
operator|=
name|fbsd_thread_post_startup_inferior
expr_stmt|;
name|thread_db_ops
operator|.
name|to_mourn_inferior
operator|=
name|fbsd_thread_mourn_inferior
expr_stmt|;
name|thread_db_ops
operator|.
name|to_thread_alive
operator|=
name|fbsd_thread_alive
expr_stmt|;
name|thread_db_ops
operator|.
name|to_find_new_threads
operator|=
name|fbsd_thread_find_new_threads
expr_stmt|;
name|thread_db_ops
operator|.
name|to_pid_to_str
operator|=
name|fbsd_thread_pid_to_str
expr_stmt|;
name|thread_db_ops
operator|.
name|to_stratum
operator|=
name|thread_stratum
expr_stmt|;
name|thread_db_ops
operator|.
name|to_has_thread_control
operator|=
name|tc_none
expr_stmt|;
name|thread_db_ops
operator|.
name|to_insert_breakpoint
operator|=
name|memory_insert_breakpoint
expr_stmt|;
name|thread_db_ops
operator|.
name|to_remove_breakpoint
operator|=
name|memory_remove_breakpoint
expr_stmt|;
name|thread_db_ops
operator|.
name|to_magic
operator|=
name|OPS_MAGIC
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|thread_db_load
parameter_list|(
name|void
parameter_list|)
block|{
name|void
modifier|*
name|handle
decl_stmt|;
name|td_err_e
name|err
decl_stmt|;
name|handle
operator|=
name|dlopen
argument_list|(
name|LIBTHREAD_DB_SO
argument_list|,
name|RTLD_NOW
argument_list|)
expr_stmt|;
if|if
condition|(
name|handle
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|td_init_p
operator|=
name|dlsym
argument_list|(
name|handle
argument_list|,
literal|"td_init"
argument_list|)
expr_stmt|;
if|if
condition|(
name|td_init_p
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|td_ta_new_p
operator|=
name|dlsym
argument_list|(
name|handle
argument_list|,
literal|"td_ta_new"
argument_list|)
expr_stmt|;
if|if
condition|(
name|td_ta_new_p
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|td_ta_map_id2thr_p
operator|=
name|dlsym
argument_list|(
name|handle
argument_list|,
literal|"td_ta_map_id2thr"
argument_list|)
expr_stmt|;
if|if
condition|(
name|td_ta_map_id2thr_p
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|td_ta_map_lwp2thr_p
operator|=
name|dlsym
argument_list|(
name|handle
argument_list|,
literal|"td_ta_map_lwp2thr"
argument_list|)
expr_stmt|;
if|if
condition|(
name|td_ta_map_lwp2thr_p
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|td_ta_thr_iter_p
operator|=
name|dlsym
argument_list|(
name|handle
argument_list|,
literal|"td_ta_thr_iter"
argument_list|)
expr_stmt|;
if|if
condition|(
name|td_ta_thr_iter_p
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|td_thr_validate_p
operator|=
name|dlsym
argument_list|(
name|handle
argument_list|,
literal|"td_thr_validate"
argument_list|)
expr_stmt|;
if|if
condition|(
name|td_thr_validate_p
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|td_thr_get_info_p
operator|=
name|dlsym
argument_list|(
name|handle
argument_list|,
literal|"td_thr_get_info"
argument_list|)
expr_stmt|;
if|if
condition|(
name|td_thr_get_info_p
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|td_thr_getfpregs_p
operator|=
name|dlsym
argument_list|(
name|handle
argument_list|,
literal|"td_thr_getfpregs"
argument_list|)
expr_stmt|;
if|if
condition|(
name|td_thr_getfpregs_p
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|td_thr_getgregs_p
operator|=
name|dlsym
argument_list|(
name|handle
argument_list|,
literal|"td_thr_getgregs"
argument_list|)
expr_stmt|;
if|if
condition|(
name|td_thr_getgregs_p
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|td_thr_setfpregs_p
operator|=
name|dlsym
argument_list|(
name|handle
argument_list|,
literal|"td_thr_setfpregs"
argument_list|)
expr_stmt|;
if|if
condition|(
name|td_thr_setfpregs_p
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|td_thr_setgregs_p
operator|=
name|dlsym
argument_list|(
name|handle
argument_list|,
literal|"td_thr_setgregs"
argument_list|)
expr_stmt|;
if|if
condition|(
name|td_thr_setgregs_p
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|td_thr_sstep_p
operator|=
name|dlsym
argument_list|(
name|handle
argument_list|,
literal|"td_thr_sstep"
argument_list|)
expr_stmt|;
if|if
condition|(
name|td_thr_sstep_p
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|td_ta_tsd_iter_p
operator|=
name|dlsym
argument_list|(
name|handle
argument_list|,
literal|"td_ta_tsd_iter"
argument_list|)
expr_stmt|;
if|if
condition|(
name|td_ta_tsd_iter_p
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|td_thr_dbsuspend_p
operator|=
name|dlsym
argument_list|(
name|handle
argument_list|,
literal|"td_thr_dbsuspend"
argument_list|)
expr_stmt|;
if|if
condition|(
name|td_thr_dbsuspend_p
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|td_thr_dbresume_p
operator|=
name|dlsym
argument_list|(
name|handle
argument_list|,
literal|"td_thr_dbresume"
argument_list|)
expr_stmt|;
if|if
condition|(
name|td_thr_dbresume_p
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* Initialize the library.  */
name|err
operator|=
name|td_init_p
argument_list|()
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|TD_OK
condition|)
block|{
name|warning
argument_list|(
literal|"Cannot initialize libthread_db: %s"
argument_list|,
name|thread_db_err_str
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|_initialize_thread_db
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Only initialize the module if we can load libthread_db. */
if|if
condition|(
name|thread_db_load
argument_list|()
condition|)
block|{
name|init_thread_db_ops
argument_list|()
expr_stmt|;
name|add_target
argument_list|(
operator|&
name|thread_db_ops
argument_list|)
expr_stmt|;
comment|/* "thread tsd" command */
name|add_cmd
argument_list|(
literal|"tsd"
argument_list|,
name|class_run
argument_list|,
name|fbsd_thread_tsd_cmd
argument_list|,
literal|"Show the thread-specific data keys and destructors "
literal|"for the process.\n"
argument_list|,
operator|&
name|thread_cmd_list
argument_list|)
expr_stmt|;
comment|/* Add ourselves to objfile event chain. */
name|target_new_objfile_chain
operator|=
name|target_new_objfile_hook
expr_stmt|;
name|target_new_objfile_hook
operator|=
name|fbsd_thread_new_objfile
expr_stmt|;
block|}
else|else
block|{
name|printf_filtered
argument_list|(
literal|"%s: can not load %s.\n"
argument_list|,
name|__func__
argument_list|,
name|LIBTHREAD_DB_SO
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* proc service functions */
end_comment

begin_function
name|void
name|ps_plog
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vfprintf_filtered
argument_list|(
name|gdb_stderr
argument_list|,
name|fmt
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|ps_err_e
name|ps_pglobal_lookup
parameter_list|(
name|struct
name|ps_prochandle
modifier|*
name|ph
parameter_list|,
specifier|const
name|char
modifier|*
name|obj
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|psaddr_t
modifier|*
name|sym_addr
parameter_list|)
block|{
name|struct
name|minimal_symbol
modifier|*
name|ms
decl_stmt|;
name|ms
operator|=
name|lookup_minimal_symbol
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ms
operator|==
name|NULL
condition|)
return|return
name|PS_NOSYM
return|;
operator|*
name|sym_addr
operator|=
operator|(
name|psaddr_t
operator|)
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|ms
argument_list|)
expr_stmt|;
return|return
name|PS_OK
return|;
block|}
end_function

begin_function
name|ps_err_e
name|ps_pdread
parameter_list|(
name|struct
name|ps_prochandle
modifier|*
name|ph
parameter_list|,
name|psaddr_t
name|addr
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
return|return
name|target_read_memory
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|addr
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_function
name|ps_err_e
name|ps_pdwrite
parameter_list|(
name|struct
name|ps_prochandle
modifier|*
name|ph
parameter_list|,
name|psaddr_t
name|addr
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
return|return
name|target_write_memory
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|addr
argument_list|,
operator|(
name|void
operator|*
operator|)
name|buf
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_function
name|ps_err_e
name|ps_ptread
parameter_list|(
name|struct
name|ps_prochandle
modifier|*
name|ph
parameter_list|,
name|psaddr_t
name|addr
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
return|return
name|target_read_memory
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|addr
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_function
name|ps_err_e
name|ps_ptwrite
parameter_list|(
name|struct
name|ps_prochandle
modifier|*
name|ph
parameter_list|,
name|psaddr_t
name|addr
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
return|return
name|target_write_memory
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|addr
argument_list|,
operator|(
name|void
operator|*
operator|)
name|buf
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_function
name|ps_err_e
name|ps_lgetregs
parameter_list|(
name|struct
name|ps_prochandle
modifier|*
name|ph
parameter_list|,
name|lwpid_t
name|lwpid
parameter_list|,
name|prgregset_t
name|gregset
parameter_list|)
block|{
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|old_chain
operator|=
name|save_inferior_ptid
argument_list|()
expr_stmt|;
name|inferior_ptid
operator|=
name|BUILD_LWP
argument_list|(
name|lwpid
argument_list|,
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|)
expr_stmt|;
name|target_fetch_registers
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fill_gregset
argument_list|(
name|gregset
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
name|PS_OK
return|;
block|}
end_function

begin_function
name|ps_err_e
name|ps_lsetregs
parameter_list|(
name|struct
name|ps_prochandle
modifier|*
name|ph
parameter_list|,
name|lwpid_t
name|lwpid
parameter_list|,
specifier|const
name|prgregset_t
name|gregset
parameter_list|)
block|{
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|old_chain
operator|=
name|save_inferior_ptid
argument_list|()
expr_stmt|;
name|inferior_ptid
operator|=
name|BUILD_LWP
argument_list|(
name|lwpid
argument_list|,
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|)
expr_stmt|;
name|supply_gregset
argument_list|(
name|gregset
argument_list|)
expr_stmt|;
name|target_store_registers
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
name|PS_OK
return|;
block|}
end_function

begin_function
name|ps_err_e
name|ps_lgetfpregs
parameter_list|(
name|struct
name|ps_prochandle
modifier|*
name|ph
parameter_list|,
name|lwpid_t
name|lwpid
parameter_list|,
name|prfpregset_t
modifier|*
name|fpregset
parameter_list|)
block|{
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|old_chain
operator|=
name|save_inferior_ptid
argument_list|()
expr_stmt|;
name|inferior_ptid
operator|=
name|BUILD_LWP
argument_list|(
name|lwpid
argument_list|,
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|)
expr_stmt|;
name|target_fetch_registers
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fill_fpregset
argument_list|(
name|fpregset
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
name|PS_OK
return|;
block|}
end_function

begin_function
name|ps_err_e
name|ps_lsetfpregs
parameter_list|(
name|struct
name|ps_prochandle
modifier|*
name|ph
parameter_list|,
name|lwpid_t
name|lwpid
parameter_list|,
specifier|const
name|prfpregset_t
modifier|*
name|fpregset
parameter_list|)
block|{
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|old_chain
operator|=
name|save_inferior_ptid
argument_list|()
expr_stmt|;
name|inferior_ptid
operator|=
name|BUILD_LWP
argument_list|(
name|lwpid
argument_list|,
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|)
expr_stmt|;
name|supply_fpregset
argument_list|(
name|fpregset
argument_list|)
expr_stmt|;
name|target_store_registers
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
name|PS_OK
return|;
block|}
end_function

begin_function
name|ps_err_e
name|ps_lstop
parameter_list|(
name|struct
name|ps_prochandle
modifier|*
name|ph
parameter_list|,
name|lwpid_t
name|lwpid
parameter_list|)
block|{
return|return
operator|(
name|ptrace
argument_list|(
name|lwpid
argument_list|,
name|PT_SUSPEND
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|ps_err_e
name|ps_lcontinue
parameter_list|(
name|struct
name|ps_prochandle
modifier|*
name|ph
parameter_list|,
name|lwpid_t
name|lwpid
parameter_list|)
block|{
return|return
operator|(
name|ptrace
argument_list|(
name|lwpid
argument_list|,
name|PT_RESUME
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|pid_t
name|ps_getpid
parameter_list|(
name|struct
name|ps_prochandle
modifier|*
name|ph
parameter_list|)
block|{
return|return
name|ph
operator|->
name|pid
return|;
block|}
end_function

end_unit

