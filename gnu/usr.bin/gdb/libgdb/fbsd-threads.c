begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/* FreeBSD libthread_db assisted debugging support.    Copyright 1999, 2000, 2001 Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|<dlfcn.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"proc_service.h"
end_include

begin_include
include|#
directive|include
file|"thread_db.h"
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"gdb_assert.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"gdbthread.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"solib-svr4.h"
end_include

begin_define
define|#
directive|define
name|LIBTHREAD_DB_SO
value|"libthread_db.so"
end_define

begin_struct
struct|struct
name|ps_prochandle
block|{
name|pid_t
name|pid
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|extern
name|int
name|child_suppress_run
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|target_ops
name|child_ops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This module's target vectors.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|target_ops
name|fbsd_thread_ops
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|target_ops
name|fbsd_core_ops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Saved copy of orignal core_ops. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|target_ops
name|orig_core_ops
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|target_ops
name|core_ops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to the next function on the objfile event chain.  */
end_comment

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
name|target_new_objfile_chain
function_decl|)
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Non-zero if there is a thread module */
end_comment

begin_decl_stmt
specifier|static
name|int
name|fbsd_thread_present
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero if we're using this module's target vector.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|fbsd_thread_active
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero if core_open is called */
end_comment

begin_decl_stmt
specifier|static
name|int
name|fbsd_thread_core
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero if we have to keep this module's target vector active    across re-runs.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|keep_thread_db
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Structure that identifies the child process for the<proc_service.h> interface.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ps_prochandle
name|proc_handle
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Connection to the libthread_db library.  */
end_comment

begin_decl_stmt
specifier|static
name|td_thragent_t
modifier|*
name|thread_agent
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The last thread we are single stepping */
end_comment

begin_decl_stmt
specifier|static
name|ptid_t
name|last_single_step_thread
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointers to the libthread_db functions.  */
end_comment

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|td_init_p
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|td_ta_new_p
function_decl|)
parameter_list|(
name|struct
name|ps_prochandle
modifier|*
name|ps
parameter_list|,
name|td_thragent_t
modifier|*
modifier|*
name|ta
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|td_ta_delete_p
function_decl|)
parameter_list|(
name|td_thragent_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|td_ta_map_id2thr_p
function_decl|)
parameter_list|(
specifier|const
name|td_thragent_t
modifier|*
name|ta
parameter_list|,
name|thread_t
name|pt
parameter_list|,
name|td_thrhandle_t
modifier|*
name|__th
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|td_ta_map_lwp2thr_p
function_decl|)
parameter_list|(
specifier|const
name|td_thragent_t
modifier|*
name|ta
parameter_list|,
name|lwpid_t
name|lwpid
parameter_list|,
name|td_thrhandle_t
modifier|*
name|th
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|td_ta_thr_iter_p
function_decl|)
parameter_list|(
specifier|const
name|td_thragent_t
modifier|*
name|ta
parameter_list|,
name|td_thr_iter_f
modifier|*
name|callback
parameter_list|,
name|void
modifier|*
name|cbdata_p
parameter_list|,
name|td_thr_state_e
name|state
parameter_list|,
name|int
name|ti_pri
parameter_list|,
name|sigset_t
modifier|*
name|ti_sigmask_p
parameter_list|,
name|unsigned
name|int
name|ti_user_flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|td_ta_event_addr_p
function_decl|)
parameter_list|(
specifier|const
name|td_thragent_t
modifier|*
name|ta
parameter_list|,
name|td_event_e
name|event
parameter_list|,
name|td_notify_t
modifier|*
name|ptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|td_ta_set_event_p
function_decl|)
parameter_list|(
specifier|const
name|td_thragent_t
modifier|*
name|ta
parameter_list|,
name|td_thr_events_t
modifier|*
name|event
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|td_ta_event_getmsg_p
function_decl|)
parameter_list|(
specifier|const
name|td_thragent_t
modifier|*
name|ta
parameter_list|,
name|td_event_msg_t
modifier|*
name|msg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|td_thr_get_info_p
function_decl|)
parameter_list|(
specifier|const
name|td_thrhandle_t
modifier|*
name|th
parameter_list|,
name|td_thrinfo_t
modifier|*
name|infop
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|PT_GETXMMREGS
end_ifdef

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|td_thr_getxmmregs_p
function_decl|)
parameter_list|(
specifier|const
name|td_thrhandle_t
modifier|*
name|th
parameter_list|,
name|char
modifier|*
name|regset
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|td_thr_getfpregs_p
function_decl|)
parameter_list|(
specifier|const
name|td_thrhandle_t
modifier|*
name|th
parameter_list|,
name|prfpregset_t
modifier|*
name|regset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|td_thr_getgregs_p
function_decl|)
parameter_list|(
specifier|const
name|td_thrhandle_t
modifier|*
name|th
parameter_list|,
name|prgregset_t
name|gregs
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|PT_GETXMMREGS
end_ifdef

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|td_thr_setxmmregs_p
function_decl|)
parameter_list|(
specifier|const
name|td_thrhandle_t
modifier|*
name|th
parameter_list|,
specifier|const
name|char
modifier|*
name|fpregs
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|td_thr_setfpregs_p
function_decl|)
parameter_list|(
specifier|const
name|td_thrhandle_t
modifier|*
name|th
parameter_list|,
specifier|const
name|prfpregset_t
modifier|*
name|fpregs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|td_thr_setgregs_p
function_decl|)
parameter_list|(
specifier|const
name|td_thrhandle_t
modifier|*
name|th
parameter_list|,
name|prgregset_t
name|gregs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|td_thr_event_enable_p
function_decl|)
parameter_list|(
specifier|const
name|td_thrhandle_t
modifier|*
name|th
parameter_list|,
name|int
name|event
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|td_thr_sstep_p
function_decl|)
parameter_list|(
name|td_thrhandle_t
modifier|*
name|th
parameter_list|,
name|int
name|step
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|td_ta_tsd_iter_p
function_decl|)
parameter_list|(
specifier|const
name|td_thragent_t
modifier|*
name|ta
parameter_list|,
name|td_key_iter_f
modifier|*
name|func
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|td_thr_tls_get_addr_p
function_decl|)
parameter_list|(
specifier|const
name|td_thrhandle_t
modifier|*
name|th
parameter_list|,
name|void
modifier|*
name|map_address
parameter_list|,
name|size_t
name|offset
parameter_list|,
name|void
modifier|*
modifier|*
name|address
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|td_thr_dbsuspend_p
function_decl|)
parameter_list|(
specifier|const
name|td_thrhandle_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|td_err_e
function_decl|(
modifier|*
name|td_thr_dbresume_p
function_decl|)
parameter_list|(
specifier|const
name|td_thrhandle_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|td_create_bp_addr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Location of the thread death event breakpoint.  */
end_comment

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|td_death_bp_addr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Prototypes for local functions.  */
end_comment

begin_function_decl
specifier|static
name|void
name|fbsd_thread_find_new_threads
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fbsd_thread_alive
parameter_list|(
name|ptid_t
name|ptid
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|attach_thread
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
specifier|const
name|td_thrhandle_t
modifier|*
name|th_p
parameter_list|,
specifier|const
name|td_thrinfo_t
modifier|*
name|ti_p
parameter_list|,
name|int
name|verbose
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fbsd_thread_detach
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Building process ids.  */
end_comment

begin_define
define|#
directive|define
name|GET_PID
parameter_list|(
name|ptid
parameter_list|)
value|ptid_get_pid (ptid)
end_define

begin_define
define|#
directive|define
name|GET_LWP
parameter_list|(
name|ptid
parameter_list|)
value|ptid_get_lwp (ptid)
end_define

begin_define
define|#
directive|define
name|GET_THREAD
parameter_list|(
name|ptid
parameter_list|)
value|ptid_get_tid (ptid)
end_define

begin_define
define|#
directive|define
name|IS_LWP
parameter_list|(
name|ptid
parameter_list|)
value|(GET_LWP (ptid) != 0)
end_define

begin_define
define|#
directive|define
name|IS_THREAD
parameter_list|(
name|ptid
parameter_list|)
value|(GET_THREAD (ptid) != 0)
end_define

begin_define
define|#
directive|define
name|BUILD_LWP
parameter_list|(
name|lwp
parameter_list|,
name|pid
parameter_list|)
value|ptid_build (pid, lwp, 0)
end_define

begin_define
define|#
directive|define
name|BUILD_THREAD
parameter_list|(
name|tid
parameter_list|,
name|pid
parameter_list|)
value|ptid_build (pid, 0, tid)
end_define

begin_function
specifier|static
name|char
modifier|*
name|thread_db_err_str
parameter_list|(
name|td_err_e
name|err
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
switch|switch
condition|(
name|err
condition|)
block|{
case|case
name|TD_OK
case|:
return|return
literal|"generic 'call succeeded'"
return|;
case|case
name|TD_ERR
case|:
return|return
literal|"generic error"
return|;
case|case
name|TD_NOTHR
case|:
return|return
literal|"no thread to satisfy query"
return|;
case|case
name|TD_NOSV
case|:
return|return
literal|"no sync handle to satisfy query"
return|;
case|case
name|TD_NOLWP
case|:
return|return
literal|"no LWP to satisfy query"
return|;
case|case
name|TD_BADPH
case|:
return|return
literal|"invalid process handle"
return|;
case|case
name|TD_BADTH
case|:
return|return
literal|"invalid thread handle"
return|;
case|case
name|TD_BADSH
case|:
return|return
literal|"invalid synchronization handle"
return|;
case|case
name|TD_BADTA
case|:
return|return
literal|"invalid thread agent"
return|;
case|case
name|TD_BADKEY
case|:
return|return
literal|"invalid key"
return|;
case|case
name|TD_NOMSG
case|:
return|return
literal|"no event message for getmsg"
return|;
case|case
name|TD_NOFPREGS
case|:
return|return
literal|"FPU register set not available"
return|;
case|case
name|TD_NOLIBTHREAD
case|:
return|return
literal|"application not linked with libthread"
return|;
case|case
name|TD_NOEVENT
case|:
return|return
literal|"requested event is not supported"
return|;
case|case
name|TD_NOCAPAB
case|:
return|return
literal|"capability not available"
return|;
case|case
name|TD_DBERR
case|:
return|return
literal|"debugger service failed"
return|;
case|case
name|TD_NOAPLIC
case|:
return|return
literal|"operation not applicable to"
return|;
case|case
name|TD_NOTSD
case|:
return|return
literal|"no thread-specific data for this thread"
return|;
case|case
name|TD_MALLOC
case|:
return|return
literal|"malloc failed"
return|;
case|case
name|TD_PARTIALREG
case|:
return|return
literal|"only part of register set was written/read"
return|;
case|case
name|TD_NOXREGS
case|:
return|return
literal|"X register set not available for this thread"
return|;
default|default:
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"unknown thread_db error '%d'"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|thread_db_state_str
parameter_list|(
name|td_thr_state_e
name|state
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|TD_THR_STOPPED
case|:
return|return
literal|"stopped by debugger"
return|;
case|case
name|TD_THR_RUN
case|:
return|return
literal|"runnable"
return|;
case|case
name|TD_THR_ACTIVE
case|:
return|return
literal|"active"
return|;
case|case
name|TD_THR_ZOMBIE
case|:
return|return
literal|"zombie"
return|;
case|case
name|TD_THR_SLEEP
case|:
return|return
literal|"sleeping"
return|;
case|case
name|TD_THR_STOPPED_ASLEEP
case|:
return|return
literal|"stopped by debugger AND blocked"
return|;
default|default:
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"unknown thread_db state %d"
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
block|}
end_function

begin_comment
comment|/* Convert LWP to user-level thread id. */
end_comment

begin_function
specifier|static
name|ptid_t
name|thread_from_lwp
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|td_thrhandle_t
modifier|*
name|th
parameter_list|,
name|td_thrinfo_t
modifier|*
name|ti
parameter_list|)
block|{
name|td_err_e
name|err
decl_stmt|;
name|gdb_assert
argument_list|(
name|IS_LWP
argument_list|(
name|ptid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fbsd_thread_active
condition|)
block|{
name|err
operator|=
name|td_ta_map_lwp2thr_p
argument_list|(
name|thread_agent
argument_list|,
name|GET_LWP
argument_list|(
name|ptid
argument_list|)
argument_list|,
name|th
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|TD_OK
condition|)
block|{
name|err
operator|=
name|td_thr_get_info_p
argument_list|(
name|th
argument_list|,
name|ti
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|TD_OK
condition|)
name|error
argument_list|(
literal|"Cannot get thread info: %s"
argument_list|,
name|thread_db_err_str
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|BUILD_THREAD
argument_list|(
name|ti
operator|->
name|ti_tid
argument_list|,
name|GET_PID
argument_list|(
name|ptid
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/* the LWP is not mapped to user thread */
return|return
name|BUILD_LWP
argument_list|(
name|GET_LWP
argument_list|(
name|ptid
argument_list|)
argument_list|,
name|GET_PID
argument_list|(
name|ptid
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fbsd_core_get_first_lwp
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|asect
parameter_list|,
name|void
modifier|*
name|obj
parameter_list|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|bfd_section_name
argument_list|(
name|abfd
argument_list|,
name|asect
argument_list|)
argument_list|,
literal|".reg/"
argument_list|,
literal|5
argument_list|)
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
operator|*
operator|(
name|lwpid_t
operator|*
operator|)
name|obj
operator|!=
literal|0
condition|)
return|return;
operator|*
operator|(
name|lwpid_t
operator|*
operator|)
name|obj
operator|=
name|atoi
argument_list|(
name|bfd_section_name
argument_list|(
name|abfd
argument_list|,
name|asect
argument_list|)
operator|+
literal|5
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|long
name|get_current_lwp
parameter_list|(
name|int
name|pid
parameter_list|)
block|{
name|struct
name|ptrace_lwpinfo
name|pl
decl_stmt|;
name|lwpid_t
name|lwpid
decl_stmt|;
if|if
condition|(
operator|!
name|target_has_execution
condition|)
block|{
name|lwpid
operator|=
literal|0
expr_stmt|;
name|bfd_map_over_sections
argument_list|(
name|core_bfd
argument_list|,
name|fbsd_core_get_first_lwp
argument_list|,
operator|&
name|lwpid
argument_list|)
expr_stmt|;
return|return
name|lwpid
return|;
block|}
if|if
condition|(
name|ptrace
argument_list|(
name|PT_LWPINFO
argument_list|,
name|pid
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|pl
argument_list|,
sizeof|sizeof
argument_list|(
name|pl
argument_list|)
argument_list|)
condition|)
name|perror_with_name
argument_list|(
literal|"PT_LWPINFO"
argument_list|)
expr_stmt|;
return|return
operator|(
name|long
operator|)
name|pl
operator|.
name|pl_lwpid
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|get_current_thread
parameter_list|()
block|{
name|td_thrhandle_t
name|th
decl_stmt|;
name|td_thrinfo_t
name|ti
decl_stmt|;
name|long
name|lwp
decl_stmt|;
name|ptid_t
name|tmp
decl_stmt|,
name|ptid
decl_stmt|;
name|lwp
operator|=
name|get_current_lwp
argument_list|(
name|proc_handle
operator|.
name|pid
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|BUILD_LWP
argument_list|(
name|lwp
argument_list|,
name|proc_handle
operator|.
name|pid
argument_list|)
expr_stmt|;
name|ptid
operator|=
name|thread_from_lwp
argument_list|(
name|tmp
argument_list|,
operator|&
name|th
argument_list|,
operator|&
name|ti
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|in_thread_list
argument_list|(
name|ptid
argument_list|)
condition|)
block|{
name|attach_thread
argument_list|(
name|ptid
argument_list|,
operator|&
name|th
argument_list|,
operator|&
name|ti
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|inferior_ptid
operator|=
name|ptid
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|td_err_e
name|enable_thread_event
parameter_list|(
name|td_thragent_t
modifier|*
name|thread_agent
parameter_list|,
name|int
name|event
parameter_list|,
name|CORE_ADDR
modifier|*
name|bp
parameter_list|)
block|{
name|td_notify_t
name|notify
decl_stmt|;
name|td_err_e
name|err
decl_stmt|;
comment|/* Get the breakpoint address for thread EVENT.  */
name|err
operator|=
name|td_ta_event_addr_p
argument_list|(
name|thread_agent
argument_list|,
name|event
argument_list|,
operator|&
name|notify
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|TD_OK
condition|)
return|return
name|err
return|;
comment|/* Set up the breakpoint.  */
operator|(
operator|*
name|bp
operator|)
operator|=
name|gdbarch_convert_from_func_ptr_addr
argument_list|(
name|current_gdbarch
argument_list|,
name|extract_typed_address
argument_list|(
operator|&
name|notify
operator|.
name|u
operator|.
name|bptaddr
argument_list|,
name|builtin_type_void_func_ptr
argument_list|)
argument_list|,
operator|&
name|current_target
argument_list|)
expr_stmt|;
name|create_thread_event_breakpoint
argument_list|(
operator|(
operator|*
name|bp
operator|)
argument_list|)
expr_stmt|;
return|return
name|TD_OK
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|enable_thread_event_reporting
parameter_list|(
name|void
parameter_list|)
block|{
name|td_thr_events_t
name|events
decl_stmt|;
name|td_notify_t
name|notify
decl_stmt|;
name|td_err_e
name|err
decl_stmt|;
comment|/* We cannot use the thread event reporting facility if these      functions aren't available.  */
if|if
condition|(
name|td_ta_event_addr_p
operator|==
name|NULL
operator|||
name|td_ta_set_event_p
operator|==
name|NULL
operator|||
name|td_ta_event_getmsg_p
operator|==
name|NULL
operator|||
name|td_thr_event_enable_p
operator|==
name|NULL
condition|)
return|return;
comment|/* Set the process wide mask saying which events we're interested in.  */
name|td_event_emptyset
argument_list|(
operator|&
name|events
argument_list|)
expr_stmt|;
name|td_event_addset
argument_list|(
operator|&
name|events
argument_list|,
name|TD_CREATE
argument_list|)
expr_stmt|;
name|td_event_addset
argument_list|(
operator|&
name|events
argument_list|,
name|TD_DEATH
argument_list|)
expr_stmt|;
name|err
operator|=
name|td_ta_set_event_p
argument_list|(
name|thread_agent
argument_list|,
operator|&
name|events
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|TD_OK
condition|)
block|{
name|warning
argument_list|(
literal|"Unable to set global thread event mask: %s"
argument_list|,
name|thread_db_err_str
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Delete previous thread event breakpoints, if any.  */
name|remove_thread_event_breakpoints
argument_list|()
expr_stmt|;
name|td_create_bp_addr
operator|=
literal|0
expr_stmt|;
name|td_death_bp_addr
operator|=
literal|0
expr_stmt|;
comment|/* Set up the thread creation event.  */
name|err
operator|=
name|enable_thread_event
argument_list|(
name|thread_agent
argument_list|,
name|TD_CREATE
argument_list|,
operator|&
name|td_create_bp_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|TD_OK
condition|)
block|{
name|warning
argument_list|(
literal|"Unable to get location for thread creation breakpoint: %s"
argument_list|,
name|thread_db_err_str
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Set up the thread death event.  */
name|err
operator|=
name|enable_thread_event
argument_list|(
name|thread_agent
argument_list|,
name|TD_DEATH
argument_list|,
operator|&
name|td_death_bp_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|TD_OK
condition|)
block|{
name|warning
argument_list|(
literal|"Unable to get location for thread death breakpoint: %s"
argument_list|,
name|thread_db_err_str
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|disable_thread_event_reporting
parameter_list|(
name|void
parameter_list|)
block|{
name|td_thr_events_t
name|events
decl_stmt|;
comment|/* Set the process wide mask saying we aren't interested in any      events anymore.  */
name|td_event_emptyset
argument_list|(
operator|&
name|events
argument_list|)
expr_stmt|;
name|td_ta_set_event_p
argument_list|(
name|thread_agent
argument_list|,
operator|&
name|events
argument_list|)
expr_stmt|;
comment|/* Delete thread event breakpoints, if any.  */
name|remove_thread_event_breakpoints
argument_list|()
expr_stmt|;
name|td_create_bp_addr
operator|=
literal|0
expr_stmt|;
name|td_death_bp_addr
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fbsd_thread_activate
parameter_list|(
name|void
parameter_list|)
block|{
name|fbsd_thread_active
operator|=
literal|1
expr_stmt|;
name|init_thread_list
argument_list|()
expr_stmt|;
if|if
condition|(
name|fbsd_thread_core
operator|==
literal|0
condition|)
name|enable_thread_event_reporting
argument_list|()
expr_stmt|;
name|fbsd_thread_find_new_threads
argument_list|()
expr_stmt|;
name|get_current_thread
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fbsd_thread_deactivate
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|fbsd_thread_core
operator|==
literal|0
condition|)
name|disable_thread_event_reporting
argument_list|()
expr_stmt|;
name|td_ta_delete_p
argument_list|(
name|thread_agent
argument_list|)
expr_stmt|;
name|inferior_ptid
operator|=
name|pid_to_ptid
argument_list|(
name|proc_handle
operator|.
name|pid
argument_list|)
expr_stmt|;
name|proc_handle
operator|.
name|pid
operator|=
literal|0
expr_stmt|;
name|fbsd_thread_active
operator|=
literal|0
expr_stmt|;
name|fbsd_thread_present
operator|=
literal|0
expr_stmt|;
name|init_thread_list
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fbsd_thread_new_objfile
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|td_err_e
name|err
decl_stmt|;
if|if
condition|(
name|objfile
operator|==
name|NULL
condition|)
block|{
comment|/* All symbols have been discarded.  If the thread_db target is          active, deactivate it now.  */
if|if
condition|(
name|fbsd_thread_active
condition|)
block|{
name|gdb_assert
argument_list|(
name|proc_handle
operator|.
name|pid
operator|==
literal|0
argument_list|)
expr_stmt|;
name|fbsd_thread_active
operator|=
literal|0
expr_stmt|;
block|}
goto|goto
name|quit
goto|;
block|}
if|if
condition|(
operator|!
name|child_suppress_run
condition|)
goto|goto
name|quit
goto|;
comment|/* Nothing to do.  The thread library was already detected and the      target vector was already activated.  */
if|if
condition|(
name|fbsd_thread_active
condition|)
goto|goto
name|quit
goto|;
comment|/* Initialize the structure that identifies the child process.  Note      that at this point there is no guarantee that we actually have a      child process.  */
name|proc_handle
operator|.
name|pid
operator|=
name|GET_PID
argument_list|(
name|inferior_ptid
argument_list|)
expr_stmt|;
comment|/* Now attempt to open a connection to the thread library.  */
name|err
operator|=
name|td_ta_new_p
argument_list|(
operator|&
name|proc_handle
argument_list|,
operator|&
name|thread_agent
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|err
condition|)
block|{
case|case
name|TD_NOLIBTHREAD
case|:
comment|/* No thread library was detected.  */
break|break;
case|case
name|TD_OK
case|:
comment|/* The thread library was detected.  Activate the thread_db target.  */
name|fbsd_thread_present
operator|=
literal|1
expr_stmt|;
comment|/* We can only poke around if there actually is a child process.          If there is no child process alive, postpone the steps below          until one has been created.  */
if|if
condition|(
name|fbsd_thread_core
operator|==
literal|0
operator|&&
name|proc_handle
operator|.
name|pid
operator|!=
literal|0
condition|)
block|{
name|push_target
argument_list|(
operator|&
name|fbsd_thread_ops
argument_list|)
expr_stmt|;
name|fbsd_thread_activate
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|td_ta_delete_p
argument_list|(
name|thread_agent
argument_list|)
expr_stmt|;
name|thread_agent
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
default|default:
name|warning
argument_list|(
literal|"Cannot initialize thread debugging library: %s"
argument_list|,
name|thread_db_err_str
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|quit
label|:
if|if
condition|(
name|target_new_objfile_chain
condition|)
name|target_new_objfile_chain
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fbsd_thread_attach
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|fbsd_thread_core
operator|=
literal|0
expr_stmt|;
name|child_ops
operator|.
name|to_attach
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
comment|/* Must get symbols from solibs before libthread_db can run! */
name|SOLIB_ADD
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|from_tty
argument_list|,
operator|(
expr|struct
name|target_ops
operator|*
operator|)
literal|0
argument_list|,
name|auto_solib_add
argument_list|)
expr_stmt|;
if|if
condition|(
name|fbsd_thread_present
operator|&&
operator|!
name|fbsd_thread_active
condition|)
name|push_target
argument_list|(
operator|&
name|fbsd_thread_ops
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fbsd_thread_post_attach
parameter_list|(
name|int
name|pid
parameter_list|)
block|{
name|child_ops
operator|.
name|to_post_attach
argument_list|(
name|pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|fbsd_thread_present
operator|&&
operator|!
name|fbsd_thread_active
condition|)
block|{
name|proc_handle
operator|.
name|pid
operator|=
name|GET_PID
argument_list|(
name|inferior_ptid
argument_list|)
expr_stmt|;
name|fbsd_thread_activate
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|fbsd_thread_detach
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|fbsd_thread_deactivate
argument_list|()
expr_stmt|;
name|unpush_target
argument_list|(
operator|&
name|fbsd_thread_ops
argument_list|)
expr_stmt|;
comment|/* Clear gdb solib information and symbol file      cache, so that after detach and re-attach, new_objfile      hook will be called */
name|clear_solib
argument_list|()
expr_stmt|;
name|symbol_file_clear
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|proc_handle
operator|.
name|pid
operator|=
literal|0
expr_stmt|;
name|child_ops
operator|.
name|to_detach
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|suspend_thread_callback
parameter_list|(
specifier|const
name|td_thrhandle_t
modifier|*
name|th_p
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
name|err
init|=
name|td_thr_dbsuspend_p
argument_list|(
name|th_p
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
name|fprintf_filtered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"%s %s\n"
argument_list|,
name|__func__
argument_list|,
name|thread_db_err_str
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|resume_thread_callback
parameter_list|(
specifier|const
name|td_thrhandle_t
modifier|*
name|th_p
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
name|err
init|=
name|td_thr_dbresume_p
argument_list|(
name|th_p
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
name|fprintf_filtered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"%s %s\n"
argument_list|,
name|__func__
argument_list|,
name|thread_db_err_str
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fbsd_thread_resume
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|int
name|step
parameter_list|,
name|enum
name|target_signal
name|signo
parameter_list|)
block|{
name|td_thrhandle_t
name|th
decl_stmt|;
name|td_thrinfo_t
name|ti
decl_stmt|;
name|ptid_t
name|work_ptid
decl_stmt|;
name|int
name|resume_all
decl_stmt|,
name|ret
decl_stmt|;
name|long
name|lwp
decl_stmt|,
name|thvalid
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|fbsd_thread_active
condition|)
block|{
name|child_ops
operator|.
name|to_resume
argument_list|(
name|ptid
argument_list|,
name|step
argument_list|,
name|signo
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|GET_PID
argument_list|(
name|ptid
argument_list|)
operator|!=
operator|-
literal|1
operator|&&
name|step
operator|!=
literal|0
condition|)
block|{
name|resume_all
operator|=
literal|0
expr_stmt|;
name|work_ptid
operator|=
name|ptid
expr_stmt|;
block|}
else|else
block|{
name|resume_all
operator|=
literal|1
expr_stmt|;
name|work_ptid
operator|=
name|inferior_ptid
expr_stmt|;
block|}
name|lwp
operator|=
name|GET_LWP
argument_list|(
name|work_ptid
argument_list|)
expr_stmt|;
if|if
condition|(
name|lwp
operator|==
literal|0
condition|)
block|{
comment|/* check user thread */
name|ret
operator|=
name|td_ta_map_id2thr_p
argument_list|(
name|thread_agent
argument_list|,
name|GET_THREAD
argument_list|(
name|work_ptid
argument_list|)
argument_list|,
operator|&
name|th
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|error
argument_list|(
name|thread_db_err_str
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For M:N thread, we need to tell UTS to set/unset single step          flag at context switch time, the flag will be written into          thread mailbox. This becauses some architecture may not have          machine single step flag in ucontext, so we put the flag in mailbox,          when the thread switches back, kse_switchin restores the single step          state.  */
name|ret
operator|=
name|td_thr_sstep_p
argument_list|(
operator|&
name|th
argument_list|,
name|step
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|error
argument_list|(
name|thread_db_err_str
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|td_thr_get_info_p
argument_list|(
operator|&
name|th
argument_list|,
operator|&
name|ti
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|error
argument_list|(
name|thread_db_err_str
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
name|thvalid
operator|=
literal|1
expr_stmt|;
name|lwp
operator|=
name|ti
operator|.
name|ti_lid
expr_stmt|;
block|}
if|if
condition|(
name|lwp
condition|)
block|{
name|int
name|req
init|=
name|step
condition|?
name|PT_SETSTEP
else|:
name|PT_CLEARSTEP
decl_stmt|;
if|if
condition|(
name|ptrace
argument_list|(
name|req
argument_list|,
operator|(
name|pid_t
operator|)
name|lwp
argument_list|,
operator|(
name|caddr_t
operator|)
literal|1
argument_list|,
name|target_signal_to_host
argument_list|(
name|signo
argument_list|)
argument_list|)
condition|)
name|perror_with_name
argument_list|(
literal|"PT_SETSTEP/PT_CLEARSTEP"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ptid_equal
argument_list|(
name|last_single_step_thread
argument_list|,
name|null_ptid
argument_list|)
condition|)
block|{
name|ret
operator|=
name|td_ta_thr_iter_p
argument_list|(
name|thread_agent
argument_list|,
name|resume_thread_callback
argument_list|,
name|NULL
argument_list|,
name|TD_THR_ANY_STATE
argument_list|,
name|TD_THR_LOWEST_PRIORITY
argument_list|,
name|TD_SIGNO_MASK
argument_list|,
name|TD_THR_ANY_USER_FLAGS
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|TD_OK
condition|)
name|error
argument_list|(
literal|"resume error: %s"
argument_list|,
name|thread_db_err_str
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|resume_all
condition|)
block|{
name|ret
operator|=
name|td_ta_thr_iter_p
argument_list|(
name|thread_agent
argument_list|,
name|suspend_thread_callback
argument_list|,
name|NULL
argument_list|,
name|TD_THR_ANY_STATE
argument_list|,
name|TD_THR_LOWEST_PRIORITY
argument_list|,
name|TD_SIGNO_MASK
argument_list|,
name|TD_THR_ANY_USER_FLAGS
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|TD_OK
condition|)
name|error
argument_list|(
literal|"suspend error: %s"
argument_list|,
name|thread_db_err_str
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
name|last_single_step_thread
operator|=
name|work_ptid
expr_stmt|;
block|}
else|else
name|last_single_step_thread
operator|=
name|null_ptid
expr_stmt|;
if|if
condition|(
name|thvalid
condition|)
block|{
name|ret
operator|=
name|td_thr_dbresume_p
argument_list|(
operator|&
name|th
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|TD_OK
condition|)
name|error
argument_list|(
literal|"resume error: %s"
argument_list|,
name|thread_db_err_str
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* it is not necessary, put it here for completness */
name|ret
operator|=
name|ptrace
argument_list|(
name|PT_RESUME
argument_list|,
name|lwp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* now continue the process, suspended thread wont run */
if|if
condition|(
name|ptrace
argument_list|(
name|PT_CONTINUE
argument_list|,
name|proc_handle
operator|.
name|pid
argument_list|,
operator|(
name|caddr_t
operator|)
literal|1
argument_list|,
name|target_signal_to_host
argument_list|(
name|signo
argument_list|)
argument_list|)
condition|)
name|perror_with_name
argument_list|(
literal|"PT_CONTINUE"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|attach_thread
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
specifier|const
name|td_thrhandle_t
modifier|*
name|th_p
parameter_list|,
specifier|const
name|td_thrinfo_t
modifier|*
name|ti_p
parameter_list|,
name|int
name|verbose
parameter_list|)
block|{
name|td_err_e
name|err
decl_stmt|;
comment|/* Add the thread to GDB's thread list.  */
if|if
condition|(
operator|!
name|in_thread_list
argument_list|(
name|ptid
argument_list|)
condition|)
block|{
name|add_thread
argument_list|(
name|ptid
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf_unfiltered
argument_list|(
literal|"[New %s]\n"
argument_list|,
name|target_pid_to_str
argument_list|(
name|ptid
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ti_p
operator|->
name|ti_state
operator|==
name|TD_THR_UNKNOWN
operator|||
name|ti_p
operator|->
name|ti_state
operator|==
name|TD_THR_ZOMBIE
condition|)
return|return;
comment|/* A zombie thread -- do not attach.  */
if|if
condition|(
operator|!
name|IS_THREAD
argument_list|(
name|ptid
argument_list|)
condition|)
return|return;
if|if
condition|(
name|fbsd_thread_core
operator|!=
literal|0
condition|)
return|return;
comment|/* Enable thread event reporting for this thread. */
name|err
operator|=
name|td_thr_event_enable_p
argument_list|(
name|th_p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|TD_OK
condition|)
name|error
argument_list|(
literal|"Cannot enable thread event reporting for %s: %s"
argument_list|,
name|target_pid_to_str
argument_list|(
name|ptid
argument_list|)
argument_list|,
name|thread_db_err_str
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|detach_thread
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|int
name|verbose
parameter_list|)
block|{
if|if
condition|(
name|verbose
condition|)
name|printf_unfiltered
argument_list|(
literal|"[%s exited]\n"
argument_list|,
name|target_pid_to_str
argument_list|(
name|ptid
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|check_event
parameter_list|(
name|ptid_t
name|ptid
parameter_list|)
block|{
name|td_event_msg_t
name|msg
decl_stmt|;
name|td_thrinfo_t
name|ti
decl_stmt|;
name|td_err_e
name|err
decl_stmt|;
name|CORE_ADDR
name|stop_pc
decl_stmt|;
name|int
name|loop
init|=
literal|0
decl_stmt|;
comment|/* Bail out early if we're not at a thread event breakpoint.  */
name|stop_pc
operator|=
name|read_pc_pid
argument_list|(
name|ptid
argument_list|)
operator|-
name|DECR_PC_AFTER_BREAK
expr_stmt|;
if|if
condition|(
name|stop_pc
operator|!=
name|td_create_bp_addr
operator|&&
name|stop_pc
operator|!=
name|td_death_bp_addr
condition|)
return|return;
name|loop
operator|=
literal|1
expr_stmt|;
do|do
block|{
name|err
operator|=
name|td_ta_event_getmsg_p
argument_list|(
name|thread_agent
argument_list|,
operator|&
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|TD_OK
condition|)
block|{
if|if
condition|(
name|err
operator|==
name|TD_NOMSG
condition|)
return|return;
name|error
argument_list|(
literal|"Cannot get thread event message: %s"
argument_list|,
name|thread_db_err_str
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|td_thr_get_info_p
argument_list|(
name|msg
operator|.
name|th_p
argument_list|,
operator|&
name|ti
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|TD_OK
condition|)
name|error
argument_list|(
literal|"Cannot get thread info: %s"
argument_list|,
name|thread_db_err_str
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
name|ptid
operator|=
name|BUILD_THREAD
argument_list|(
name|ti
operator|.
name|ti_tid
argument_list|,
name|GET_PID
argument_list|(
name|ptid
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|msg
operator|.
name|event
condition|)
block|{
case|case
name|TD_CREATE
case|:
comment|/* We may already know about this thread, for instance when the              user has issued the `info threads' command before the SIGTRAP              for hitting the thread creation breakpoint was reported.  */
name|attach_thread
argument_list|(
name|ptid
argument_list|,
name|msg
operator|.
name|th_p
argument_list|,
operator|&
name|ti
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|TD_DEATH
case|:
if|if
condition|(
operator|!
name|in_thread_list
argument_list|(
name|ptid
argument_list|)
condition|)
name|error
argument_list|(
literal|"Spurious thread death event."
argument_list|)
expr_stmt|;
name|detach_thread
argument_list|(
name|ptid
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Spurious thread event."
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|loop
condition|)
do|;
block|}
end_function

begin_function
specifier|static
name|ptid_t
name|fbsd_thread_wait
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|struct
name|target_waitstatus
modifier|*
name|ourstatus
parameter_list|)
block|{
name|ptid_t
name|ret
decl_stmt|;
name|long
name|lwp
decl_stmt|;
name|CORE_ADDR
name|stop_pc
decl_stmt|;
name|td_thrhandle_t
name|th
decl_stmt|;
name|td_thrinfo_t
name|ti
decl_stmt|;
name|ret
operator|=
name|child_ops
operator|.
name|to_wait
argument_list|(
name|ptid
argument_list|,
name|ourstatus
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_PID
argument_list|(
name|ret
argument_list|)
operator|>=
literal|0
operator|&&
name|ourstatus
operator|->
name|kind
operator|==
name|TARGET_WAITKIND_STOPPED
condition|)
block|{
name|lwp
operator|=
name|get_current_lwp
argument_list|(
name|GET_PID
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|thread_from_lwp
argument_list|(
name|BUILD_LWP
argument_list|(
name|lwp
argument_list|,
name|GET_PID
argument_list|(
name|ret
argument_list|)
argument_list|)
argument_list|,
operator|&
name|th
argument_list|,
operator|&
name|ti
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|in_thread_list
argument_list|(
name|ret
argument_list|)
condition|)
block|{
comment|/*          * We have to enable event reporting for initial thread          * which was not mapped before. 	 */
name|attach_thread
argument_list|(
name|ret
argument_list|,
operator|&
name|th
argument_list|,
operator|&
name|ti
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ourstatus
operator|->
name|value
operator|.
name|sig
operator|==
name|TARGET_SIGNAL_TRAP
condition|)
name|check_event
argument_list|(
name|ret
argument_list|)
expr_stmt|;
comment|/* this is a hack, if an event won't cause gdb to stop, for example,          SIGARLM, gdb resumes the process immediatly without setting          inferior_ptid to the new thread returned here, this is a bug          because inferior_ptid may already not exist there, and passing          a none existing thread to fbsd_thread_resume causes error. */
if|if
condition|(
operator|!
name|fbsd_thread_alive
argument_list|(
name|inferior_ptid
argument_list|)
condition|)
block|{
name|delete_thread
argument_list|(
name|inferior_ptid
argument_list|)
expr_stmt|;
name|inferior_ptid
operator|=
name|ret
expr_stmt|;
block|}
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fbsd_thread_xfer_memory
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|write
parameter_list|,
name|struct
name|mem_attrib
modifier|*
name|attrib
parameter_list|,
name|struct
name|target_ops
modifier|*
name|target
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
if|if
condition|(
name|target_has_execution
condition|)
name|err
operator|=
name|child_ops
operator|.
name|to_xfer_memory
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|,
name|write
argument_list|,
name|attrib
argument_list|,
name|target
argument_list|)
expr_stmt|;
else|else
name|err
operator|=
name|orig_core_ops
operator|.
name|to_xfer_memory
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|,
name|write
argument_list|,
name|attrib
argument_list|,
name|target
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fbsd_lwp_fetch_registers
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
name|gregset_t
name|gregs
decl_stmt|;
name|fpregset_t
name|fpregs
decl_stmt|;
name|lwpid_t
name|lwp
decl_stmt|;
ifdef|#
directive|ifdef
name|PT_GETXMMREGS
name|char
name|xmmregs
index|[
literal|512
index|]
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|target_has_execution
condition|)
block|{
name|orig_core_ops
operator|.
name|to_fetch_registers
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* XXX: We've replaced the pid with the lwpid for GDB's benefit. */
name|lwp
operator|=
name|GET_PID
argument_list|(
name|inferior_ptid
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptrace
argument_list|(
name|PT_GETREGS
argument_list|,
name|lwp
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|gregs
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"Cannot get lwp %d registers: %s\n"
argument_list|,
name|lwp
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|supply_gregset
argument_list|(
operator|&
name|gregs
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PT_GETXMMREGS
if|if
condition|(
name|ptrace
argument_list|(
name|PT_GETXMMREGS
argument_list|,
name|lwp
argument_list|,
name|xmmregs
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
name|i387_supply_fxsave
argument_list|(
name|current_regcache
argument_list|,
operator|-
literal|1
argument_list|,
name|xmmregs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
endif|#
directive|endif
if|if
condition|(
name|ptrace
argument_list|(
name|PT_GETFPREGS
argument_list|,
name|lwp
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|fpregs
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"Cannot get lwp %d registers: %s\n "
argument_list|,
name|lwp
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|supply_fpregset
argument_list|(
operator|&
name|fpregs
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PT_GETXMMREGS
block|}
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|fbsd_thread_fetch_registers
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
name|prgregset_t
name|gregset
decl_stmt|;
name|prfpregset_t
name|fpregset
decl_stmt|;
name|td_thrhandle_t
name|th
decl_stmt|;
name|td_err_e
name|err
decl_stmt|;
ifdef|#
directive|ifdef
name|PT_GETXMMREGS
name|char
name|xmmregs
index|[
literal|512
index|]
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|IS_THREAD
argument_list|(
name|inferior_ptid
argument_list|)
condition|)
block|{
name|fbsd_lwp_fetch_registers
argument_list|(
name|regno
argument_list|)
expr_stmt|;
return|return;
block|}
name|err
operator|=
name|td_ta_map_id2thr_p
argument_list|(
name|thread_agent
argument_list|,
name|GET_THREAD
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
operator|&
name|th
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|TD_OK
condition|)
name|error
argument_list|(
literal|"Cannot find thread %d: Thread ID=%ld, %s"
argument_list|,
name|pid_to_thread_id
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
name|GET_THREAD
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
name|thread_db_err_str
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|td_thr_getgregs_p
argument_list|(
operator|&
name|th
argument_list|,
name|gregset
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|TD_OK
condition|)
name|error
argument_list|(
literal|"Cannot fetch general-purpose registers for thread %d: Thread ID=%ld, %s"
argument_list|,
name|pid_to_thread_id
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
name|GET_THREAD
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
name|thread_db_err_str
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PT_GETXMMREGS
name|err
operator|=
name|td_thr_getxmmregs_p
argument_list|(
operator|&
name|th
argument_list|,
name|xmmregs
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|TD_OK
condition|)
block|{
name|i387_supply_fxsave
argument_list|(
name|current_regcache
argument_list|,
operator|-
literal|1
argument_list|,
name|xmmregs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
endif|#
directive|endif
name|err
operator|=
name|td_thr_getfpregs_p
argument_list|(
operator|&
name|th
argument_list|,
operator|&
name|fpregset
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|TD_OK
condition|)
name|error
argument_list|(
literal|"Cannot get floating-point registers for thread %d: Thread ID=%ld, %s"
argument_list|,
name|pid_to_thread_id
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
name|GET_THREAD
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
name|thread_db_err_str
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
name|supply_fpregset
argument_list|(
operator|&
name|fpregset
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PT_GETXMMREGS
block|}
endif|#
directive|endif
name|supply_gregset
argument_list|(
name|gregset
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fbsd_lwp_store_registers
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
name|gregset_t
name|gregs
decl_stmt|;
name|fpregset_t
name|fpregs
decl_stmt|;
name|lwpid_t
name|lwp
decl_stmt|;
ifdef|#
directive|ifdef
name|PT_GETXMMREGS
name|char
name|xmmregs
index|[
literal|512
index|]
decl_stmt|;
endif|#
directive|endif
comment|/* FIXME, is it possible ? */
if|if
condition|(
operator|!
name|IS_LWP
argument_list|(
name|inferior_ptid
argument_list|)
condition|)
block|{
name|child_ops
operator|.
name|to_store_registers
argument_list|(
name|regno
argument_list|)
expr_stmt|;
return|return ;
block|}
name|lwp
operator|=
name|GET_LWP
argument_list|(
name|inferior_ptid
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|!=
operator|-
literal|1
condition|)
if|if
condition|(
name|ptrace
argument_list|(
name|PT_GETREGS
argument_list|,
name|lwp
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|gregs
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"Cannot get lwp %d registers: %s\n"
argument_list|,
name|lwp
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|fill_gregset
argument_list|(
operator|&
name|gregs
argument_list|,
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptrace
argument_list|(
name|PT_SETREGS
argument_list|,
name|lwp
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|gregs
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"Cannot set lwp %d registers: %s\n"
argument_list|,
name|lwp
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PT_GETXMMREGS
if|if
condition|(
name|regno
operator|!=
operator|-
literal|1
condition|)
if|if
condition|(
name|ptrace
argument_list|(
name|PT_GETXMMREGS
argument_list|,
name|lwp
argument_list|,
name|xmmregs
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|noxmm
goto|;
name|i387_fill_fxsave
argument_list|(
name|xmmregs
argument_list|,
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptrace
argument_list|(
name|PT_SETXMMREGS
argument_list|,
name|lwp
argument_list|,
name|xmmregs
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|noxmm
goto|;
return|return;
name|noxmm
label|:
endif|#
directive|endif
if|if
condition|(
name|regno
operator|!=
operator|-
literal|1
condition|)
if|if
condition|(
name|ptrace
argument_list|(
name|PT_GETFPREGS
argument_list|,
name|lwp
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|fpregs
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"Cannot get lwp %d float registers: %s\n"
argument_list|,
name|lwp
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|fill_fpregset
argument_list|(
operator|&
name|fpregs
argument_list|,
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptrace
argument_list|(
name|PT_SETFPREGS
argument_list|,
name|lwp
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|fpregs
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"Cannot set lwp %d float registers: %s\n"
argument_list|,
name|lwp
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fbsd_thread_store_registers
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
name|prgregset_t
name|gregset
decl_stmt|;
name|prfpregset_t
name|fpregset
decl_stmt|;
name|td_thrhandle_t
name|th
decl_stmt|;
name|td_err_e
name|err
decl_stmt|;
ifdef|#
directive|ifdef
name|PT_GETXMMREGS
name|char
name|xmmregs
index|[
literal|512
index|]
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|IS_THREAD
argument_list|(
name|inferior_ptid
argument_list|)
condition|)
block|{
name|fbsd_lwp_store_registers
argument_list|(
name|regno
argument_list|)
expr_stmt|;
return|return;
block|}
name|err
operator|=
name|td_ta_map_id2thr_p
argument_list|(
name|thread_agent
argument_list|,
name|GET_THREAD
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
operator|&
name|th
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|TD_OK
condition|)
name|error
argument_list|(
literal|"Cannot find thread %d: Thread ID=%ld, %s"
argument_list|,
name|pid_to_thread_id
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
name|GET_THREAD
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
name|thread_db_err_str
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|!=
operator|-
literal|1
condition|)
block|{
name|char
name|old_value
index|[
name|MAX_REGISTER_SIZE
index|]
decl_stmt|;
name|regcache_collect
argument_list|(
name|regno
argument_list|,
name|old_value
argument_list|)
expr_stmt|;
name|err
operator|=
name|td_thr_getgregs_p
argument_list|(
operator|&
name|th
argument_list|,
name|gregset
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|TD_OK
condition|)
name|error
argument_list|(
literal|"%s: td_thr_getgregs %s"
argument_list|,
name|__func__
argument_list|,
name|thread_db_err_str
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PT_GETXMMREGS
name|err
operator|=
name|td_thr_getxmmregs_p
argument_list|(
operator|&
name|th
argument_list|,
name|xmmregs
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|TD_OK
condition|)
block|{
endif|#
directive|endif
name|err
operator|=
name|td_thr_getfpregs_p
argument_list|(
operator|&
name|th
argument_list|,
operator|&
name|fpregset
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|TD_OK
condition|)
name|error
argument_list|(
literal|"%s: td_thr_getfpgregs %s"
argument_list|,
name|__func__
argument_list|,
name|thread_db_err_str
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PT_GETXMMREGS
block|}
endif|#
directive|endif
name|supply_register
argument_list|(
name|regno
argument_list|,
name|old_value
argument_list|)
expr_stmt|;
block|}
name|fill_gregset
argument_list|(
name|gregset
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|err
operator|=
name|td_thr_setgregs_p
argument_list|(
operator|&
name|th
argument_list|,
name|gregset
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|TD_OK
condition|)
name|error
argument_list|(
literal|"Cannot store general-purpose registers for thread %d: Thread ID=%d, %s"
argument_list|,
name|pid_to_thread_id
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
name|GET_THREAD
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
name|thread_db_err_str
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PT_GETXMMREGS
name|i387_fill_fxsave
argument_list|(
name|xmmregs
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|err
operator|=
name|td_thr_setxmmregs_p
argument_list|(
operator|&
name|th
argument_list|,
name|xmmregs
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|TD_OK
condition|)
return|return;
endif|#
directive|endif
name|fill_fpregset
argument_list|(
operator|&
name|fpregset
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|err
operator|=
name|td_thr_setfpregs_p
argument_list|(
operator|&
name|th
argument_list|,
operator|&
name|fpregset
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|TD_OK
condition|)
name|error
argument_list|(
literal|"Cannot store floating-point registers for thread %d: Thread ID=%d, %s"
argument_list|,
name|pid_to_thread_id
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
name|GET_THREAD
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
name|thread_db_err_str
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fbsd_thread_kill
parameter_list|(
name|void
parameter_list|)
block|{
name|child_ops
operator|.
name|to_kill
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|fbsd_thread_can_run
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|child_suppress_run
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fbsd_thread_create_inferior
parameter_list|(
name|char
modifier|*
name|exec_file
parameter_list|,
name|char
modifier|*
name|allargs
parameter_list|,
name|char
modifier|*
modifier|*
name|env
parameter_list|)
block|{
if|if
condition|(
name|fbsd_thread_present
operator|&&
operator|!
name|fbsd_thread_active
condition|)
name|push_target
argument_list|(
operator|&
name|fbsd_thread_ops
argument_list|)
expr_stmt|;
name|child_ops
operator|.
name|to_create_inferior
argument_list|(
name|exec_file
argument_list|,
name|allargs
argument_list|,
name|env
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fbsd_thread_post_startup_inferior
parameter_list|(
name|ptid_t
name|ptid
parameter_list|)
block|{
if|if
condition|(
name|fbsd_thread_present
operator|&&
operator|!
name|fbsd_thread_active
condition|)
block|{
comment|/* The child process is now the actual multi-threaded          program.  Snatch its process ID... */
name|proc_handle
operator|.
name|pid
operator|=
name|GET_PID
argument_list|(
name|ptid
argument_list|)
expr_stmt|;
name|td_ta_new_p
argument_list|(
operator|&
name|proc_handle
argument_list|,
operator|&
name|thread_agent
argument_list|)
expr_stmt|;
name|fbsd_thread_activate
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|fbsd_thread_mourn_inferior
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|fbsd_thread_active
condition|)
name|fbsd_thread_deactivate
argument_list|()
expr_stmt|;
name|unpush_target
argument_list|(
operator|&
name|fbsd_thread_ops
argument_list|)
expr_stmt|;
name|child_ops
operator|.
name|to_mourn_inferior
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fbsd_core_check_lwp
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|asect
parameter_list|,
name|void
modifier|*
name|obj
parameter_list|)
block|{
name|lwpid_t
name|lwp
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|bfd_section_name
argument_list|(
name|abfd
argument_list|,
name|asect
argument_list|)
argument_list|,
literal|".reg/"
argument_list|,
literal|5
argument_list|)
operator|!=
literal|0
condition|)
return|return;
comment|/* already found */
if|if
condition|(
operator|*
operator|(
name|lwpid_t
operator|*
operator|)
name|obj
operator|==
literal|0
condition|)
return|return;
name|lwp
operator|=
name|atoi
argument_list|(
name|bfd_section_name
argument_list|(
name|abfd
argument_list|,
name|asect
argument_list|)
operator|+
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|lwpid_t
operator|*
operator|)
name|obj
operator|==
name|lwp
condition|)
operator|*
operator|(
name|lwpid_t
operator|*
operator|)
name|obj
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|fbsd_thread_alive
parameter_list|(
name|ptid_t
name|ptid
parameter_list|)
block|{
name|td_thrhandle_t
name|th
decl_stmt|;
name|td_thrinfo_t
name|ti
decl_stmt|;
name|td_err_e
name|err
decl_stmt|;
name|gregset_t
name|gregs
decl_stmt|;
name|lwpid_t
name|lwp
decl_stmt|;
if|if
condition|(
name|IS_THREAD
argument_list|(
name|ptid
argument_list|)
condition|)
block|{
name|err
operator|=
name|td_ta_map_id2thr_p
argument_list|(
name|thread_agent
argument_list|,
name|GET_THREAD
argument_list|(
name|ptid
argument_list|)
argument_list|,
operator|&
name|th
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|TD_OK
condition|)
return|return
literal|0
return|;
name|err
operator|=
name|td_thr_get_info_p
argument_list|(
operator|&
name|th
argument_list|,
operator|&
name|ti
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|TD_OK
condition|)
return|return
literal|0
return|;
comment|/* A zombie thread. */
if|if
condition|(
name|ti
operator|.
name|ti_state
operator|==
name|TD_THR_UNKNOWN
operator|||
name|ti
operator|.
name|ti_state
operator|==
name|TD_THR_ZOMBIE
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|GET_LWP
argument_list|(
name|ptid
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* we sometimes are called with lwp == 0 */
return|return
literal|1
return|;
block|}
if|if
condition|(
name|fbsd_thread_active
condition|)
block|{
name|err
operator|=
name|td_ta_map_lwp2thr_p
argument_list|(
name|thread_agent
argument_list|,
name|GET_LWP
argument_list|(
name|ptid
argument_list|)
argument_list|,
operator|&
name|th
argument_list|)
expr_stmt|;
comment|/*        * if the lwp was already mapped to user thread, don't use it        * directly, please use user thread id instead.        */
if|if
condition|(
name|err
operator|==
name|TD_OK
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|target_has_execution
condition|)
block|{
name|lwp
operator|=
name|GET_LWP
argument_list|(
name|ptid
argument_list|)
expr_stmt|;
name|bfd_map_over_sections
argument_list|(
name|core_bfd
argument_list|,
name|fbsd_core_check_lwp
argument_list|,
operator|&
name|lwp
argument_list|)
expr_stmt|;
return|return
operator|(
name|lwp
operator|==
literal|0
operator|)
return|;
block|}
comment|/* check lwp in kernel */
return|return
name|ptrace
argument_list|(
name|PT_GETREGS
argument_list|,
name|GET_LWP
argument_list|(
name|ptid
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|gregs
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fbsd_thread_files_info
parameter_list|(
name|struct
name|target_ops
modifier|*
name|ignore
parameter_list|)
block|{
name|child_ops
operator|.
name|to_files_info
argument_list|(
name|ignore
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|find_new_threads_callback
parameter_list|(
specifier|const
name|td_thrhandle_t
modifier|*
name|th_p
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|td_thrinfo_t
name|ti
decl_stmt|;
name|td_err_e
name|err
decl_stmt|;
name|ptid_t
name|ptid
decl_stmt|;
name|err
operator|=
name|td_thr_get_info_p
argument_list|(
name|th_p
argument_list|,
operator|&
name|ti
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|TD_OK
condition|)
name|error
argument_list|(
literal|"Cannot get thread info: %s"
argument_list|,
name|thread_db_err_str
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Ignore zombie */
if|if
condition|(
name|ti
operator|.
name|ti_state
operator|==
name|TD_THR_UNKNOWN
operator|||
name|ti
operator|.
name|ti_state
operator|==
name|TD_THR_ZOMBIE
condition|)
return|return
literal|0
return|;
name|ptid
operator|=
name|BUILD_THREAD
argument_list|(
name|ti
operator|.
name|ti_tid
argument_list|,
name|proc_handle
operator|.
name|pid
argument_list|)
expr_stmt|;
name|attach_thread
argument_list|(
name|ptid
argument_list|,
name|th_p
argument_list|,
operator|&
name|ti
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fbsd_thread_find_new_threads
parameter_list|(
name|void
parameter_list|)
block|{
name|td_err_e
name|err
decl_stmt|;
if|if
condition|(
operator|!
name|fbsd_thread_active
condition|)
return|return;
comment|/* Iterate over all user-space threads to discover new threads. */
name|err
operator|=
name|td_ta_thr_iter_p
argument_list|(
name|thread_agent
argument_list|,
name|find_new_threads_callback
argument_list|,
name|NULL
argument_list|,
name|TD_THR_ANY_STATE
argument_list|,
name|TD_THR_LOWEST_PRIORITY
argument_list|,
name|TD_SIGNO_MASK
argument_list|,
name|TD_THR_ANY_USER_FLAGS
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|TD_OK
condition|)
name|error
argument_list|(
literal|"Cannot find new threads: %s"
argument_list|,
name|thread_db_err_str
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|fbsd_thread_pid_to_str
parameter_list|(
name|ptid_t
name|ptid
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
if|if
condition|(
name|IS_THREAD
argument_list|(
name|ptid
argument_list|)
condition|)
block|{
name|td_thrhandle_t
name|th
decl_stmt|;
name|td_thrinfo_t
name|ti
decl_stmt|;
name|td_err_e
name|err
decl_stmt|;
name|err
operator|=
name|td_ta_map_id2thr_p
argument_list|(
name|thread_agent
argument_list|,
name|GET_THREAD
argument_list|(
name|ptid
argument_list|)
argument_list|,
operator|&
name|th
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|TD_OK
condition|)
name|error
argument_list|(
literal|"Cannot find thread, Thread ID=%ld, %s"
argument_list|,
name|GET_THREAD
argument_list|(
name|ptid
argument_list|)
argument_list|,
name|thread_db_err_str
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|td_thr_get_info_p
argument_list|(
operator|&
name|th
argument_list|,
operator|&
name|ti
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|TD_OK
condition|)
name|error
argument_list|(
literal|"Cannot get thread info, Thread ID=%ld, %s"
argument_list|,
name|GET_THREAD
argument_list|(
name|ptid
argument_list|)
argument_list|,
name|thread_db_err_str
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ti
operator|.
name|ti_lid
operator|!=
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"Thread %p (LWP %d)"
argument_list|,
name|th
operator|.
name|th_thread
argument_list|,
name|ti
operator|.
name|ti_lid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"Thread %p (%s)"
argument_list|,
name|th
operator|.
name|th_thread
argument_list|,
name|thread_db_state_str
argument_list|(
name|ti
operator|.
name|ti_state
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
return|;
block|}
elseif|else
if|if
condition|(
name|IS_LWP
argument_list|(
name|ptid
argument_list|)
condition|)
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"LWP %d"
argument_list|,
operator|(
name|int
operator|)
name|GET_LWP
argument_list|(
name|ptid
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
return|return
name|normal_pid_to_str
argument_list|(
name|ptid
argument_list|)
return|;
block|}
end_function

begin_function
name|CORE_ADDR
name|fbsd_thread_get_local_address
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|,
name|CORE_ADDR
name|offset
parameter_list|)
block|{
name|td_thrhandle_t
name|th
decl_stmt|;
name|void
modifier|*
name|address
decl_stmt|;
name|CORE_ADDR
name|lm
decl_stmt|;
name|void
modifier|*
name|lm2
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|is_library
init|=
operator|(
name|objfile
operator|->
name|flags
operator|&
name|OBJF_SHARED
operator|)
decl_stmt|;
if|if
condition|(
name|IS_THREAD
argument_list|(
name|ptid
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|td_thr_tls_get_addr_p
condition|)
name|error
argument_list|(
literal|"Cannot find thread-local interface in thread_db library."
argument_list|)
expr_stmt|;
comment|/* Get the address of the link map for this objfile. */
name|lm
operator|=
name|svr4_fetch_objfile_link_map
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
comment|/* Couldn't find link map. Bail out. */
if|if
condition|(
operator|!
name|lm
condition|)
block|{
if|if
condition|(
name|is_library
condition|)
name|error
argument_list|(
literal|"Cannot find shared library `%s' link_map in dynamic"
literal|" linker's module list"
argument_list|,
name|objfile
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"Cannot find executable file `%s' link_map in dynamic"
literal|" linker's module list"
argument_list|,
name|objfile
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|td_ta_map_id2thr_p
argument_list|(
name|thread_agent
argument_list|,
name|GET_THREAD
argument_list|(
name|ptid
argument_list|)
argument_list|,
operator|&
name|th
argument_list|)
expr_stmt|;
comment|/* get the address of the variable. */
name|store_typed_address
argument_list|(
operator|&
name|lm2
argument_list|,
name|builtin_type_void_data_ptr
argument_list|,
name|lm
argument_list|)
expr_stmt|;
name|ret
operator|=
name|td_thr_tls_get_addr_p
argument_list|(
operator|&
name|th
argument_list|,
name|lm2
argument_list|,
name|offset
argument_list|,
operator|&
name|address
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|TD_OK
condition|)
block|{
if|if
condition|(
name|is_library
condition|)
name|error
argument_list|(
literal|"Cannot find thread-local storage for thread %ld, "
literal|"shared library %s:\n%s"
argument_list|,
operator|(
name|long
operator|)
name|GET_THREAD
argument_list|(
name|ptid
argument_list|)
argument_list|,
name|objfile
operator|->
name|name
argument_list|,
name|thread_db_err_str
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"Cannot find thread-local storage for thread %ld, "
literal|"executable file %s:\n%s"
argument_list|,
operator|(
name|long
operator|)
name|GET_THREAD
argument_list|(
name|ptid
argument_list|)
argument_list|,
name|objfile
operator|->
name|name
argument_list|,
name|thread_db_err_str
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Cast assuming host == target. */
return|return
name|extract_typed_address
argument_list|(
operator|&
name|address
argument_list|,
name|builtin_type_void_data_ptr
argument_list|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tsd_cb
parameter_list|(
name|thread_key_t
name|key
parameter_list|,
name|void
function_decl|(
modifier|*
name|destructor
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|ignore
parameter_list|)
block|{
name|struct
name|minimal_symbol
modifier|*
name|ms
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|ms
operator|=
name|lookup_minimal_symbol_by_pc
argument_list|(
name|extract_typed_address
argument_list|(
operator|&
name|destructor
argument_list|,
name|builtin_type_void_func_ptr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ms
condition|)
name|name
operator|=
literal|"???"
expr_stmt|;
else|else
name|name
operator|=
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|ms
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Destructor %p<%s>\n"
argument_list|,
name|destructor
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fbsd_thread_tsd_cmd
parameter_list|(
name|char
modifier|*
name|exp
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
if|if
condition|(
name|fbsd_thread_active
condition|)
name|td_ta_tsd_iter_p
argument_list|(
name|thread_agent
argument_list|,
name|tsd_cb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fbsd_print_sigset
parameter_list|(
name|sigset_t
modifier|*
name|set
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|_SIG_MAXSIG
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|sigismember
argument_list|(
name|set
argument_list|,
name|i
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|<
sizeof|sizeof
argument_list|(
name|sys_signame
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|sys_signame
index|[
literal|0
index|]
argument_list|)
condition|)
name|printf_filtered
argument_list|(
literal|"%s "
argument_list|,
name|sys_signame
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|"sig%d "
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fbsd_thread_signal_cmd
parameter_list|(
name|char
modifier|*
name|exp
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|td_thrhandle_t
name|th
decl_stmt|;
name|td_thrinfo_t
name|ti
decl_stmt|;
name|td_err_e
name|err
decl_stmt|;
if|if
condition|(
operator|!
name|fbsd_thread_active
operator|||
operator|!
name|IS_THREAD
argument_list|(
name|inferior_ptid
argument_list|)
condition|)
return|return;
name|err
operator|=
name|td_ta_map_id2thr_p
argument_list|(
name|thread_agent
argument_list|,
name|GET_THREAD
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
operator|&
name|th
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|TD_OK
condition|)
return|return;
name|err
operator|=
name|td_thr_get_info_p
argument_list|(
operator|&
name|th
argument_list|,
operator|&
name|ti
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|TD_OK
condition|)
return|return;
name|printf_filtered
argument_list|(
literal|"signal mask:\n"
argument_list|)
expr_stmt|;
name|fbsd_print_sigset
argument_list|(
operator|&
name|ti
operator|.
name|ti_sigmask
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"signal pending:\n"
argument_list|)
expr_stmt|;
name|fbsd_print_sigset
argument_list|(
operator|&
name|ti
operator|.
name|ti_pending
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ignore
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|char
modifier|*
name|contents
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fbsd_core_open
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|fbsd_thread_core
operator|=
literal|1
expr_stmt|;
name|orig_core_ops
operator|.
name|to_open
argument_list|(
name|filename
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
if|if
condition|(
name|fbsd_thread_present
condition|)
block|{
name|err
operator|=
name|td_ta_new_p
argument_list|(
operator|&
name|proc_handle
argument_list|,
operator|&
name|thread_agent
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|TD_OK
condition|)
block|{
name|proc_handle
operator|.
name|pid
operator|=
name|elf_tdata
argument_list|(
name|core_bfd
argument_list|)
operator|->
name|core_pid
expr_stmt|;
name|fbsd_thread_activate
argument_list|()
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"fbsd_core_open: td_ta_new: %s"
argument_list|,
name|thread_db_err_str
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|fbsd_core_close
parameter_list|(
name|int
name|quitting
parameter_list|)
block|{
name|orig_core_ops
operator|.
name|to_close
argument_list|(
name|quitting
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fbsd_core_detach
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
if|if
condition|(
name|fbsd_thread_active
condition|)
name|fbsd_thread_deactivate
argument_list|()
expr_stmt|;
name|unpush_target
argument_list|(
operator|&
name|fbsd_thread_ops
argument_list|)
expr_stmt|;
name|orig_core_ops
operator|.
name|to_detach
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
comment|/* Clear gdb solib information and symbol file      cache, so that after detach and re-attach, new_objfile      hook will be called */
name|clear_solib
argument_list|()
expr_stmt|;
name|symbol_file_clear
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fbsd_core_files_info
parameter_list|(
name|struct
name|target_ops
modifier|*
name|ignore
parameter_list|)
block|{
name|orig_core_ops
operator|.
name|to_files_info
argument_list|(
name|ignore
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_fbsd_core_ops
parameter_list|(
name|void
parameter_list|)
block|{
name|fbsd_core_ops
operator|.
name|to_shortname
operator|=
literal|"FreeBSD-core"
expr_stmt|;
name|fbsd_core_ops
operator|.
name|to_longname
operator|=
literal|"FreeBSD core thread."
expr_stmt|;
name|fbsd_core_ops
operator|.
name|to_doc
operator|=
literal|"FreeBSD threads support for core files."
expr_stmt|;
name|fbsd_core_ops
operator|.
name|to_open
operator|=
name|fbsd_core_open
expr_stmt|;
name|fbsd_core_ops
operator|.
name|to_close
operator|=
name|fbsd_core_close
expr_stmt|;
name|fbsd_core_ops
operator|.
name|to_attach
operator|=
literal|0
expr_stmt|;
name|fbsd_core_ops
operator|.
name|to_post_attach
operator|=
literal|0
expr_stmt|;
name|fbsd_core_ops
operator|.
name|to_detach
operator|=
name|fbsd_core_detach
expr_stmt|;
comment|/* fbsd_core_ops.to_resume  = 0; */
comment|/* fbsd_core_ops.to_wait  = 0;  */
name|fbsd_core_ops
operator|.
name|to_fetch_registers
operator|=
name|fbsd_thread_fetch_registers
expr_stmt|;
comment|/* fbsd_core_ops.to_store_registers  = 0; */
comment|/* fbsd_core_ops.to_prepare_to_store  = 0; */
name|fbsd_core_ops
operator|.
name|to_xfer_memory
operator|=
name|fbsd_thread_xfer_memory
expr_stmt|;
name|fbsd_core_ops
operator|.
name|to_files_info
operator|=
name|fbsd_core_files_info
expr_stmt|;
name|fbsd_core_ops
operator|.
name|to_insert_breakpoint
operator|=
name|ignore
expr_stmt|;
name|fbsd_core_ops
operator|.
name|to_remove_breakpoint
operator|=
name|ignore
expr_stmt|;
comment|/* fbsd_core_ops.to_lookup_symbol  = 0; */
name|fbsd_core_ops
operator|.
name|to_create_inferior
operator|=
name|fbsd_thread_create_inferior
expr_stmt|;
name|fbsd_core_ops
operator|.
name|to_stratum
operator|=
name|core_stratum
expr_stmt|;
name|fbsd_core_ops
operator|.
name|to_has_all_memory
operator|=
literal|0
expr_stmt|;
name|fbsd_core_ops
operator|.
name|to_has_memory
operator|=
literal|1
expr_stmt|;
name|fbsd_core_ops
operator|.
name|to_has_stack
operator|=
literal|1
expr_stmt|;
name|fbsd_core_ops
operator|.
name|to_has_registers
operator|=
literal|1
expr_stmt|;
name|fbsd_core_ops
operator|.
name|to_has_execution
operator|=
literal|0
expr_stmt|;
name|fbsd_core_ops
operator|.
name|to_has_thread_control
operator|=
name|tc_none
expr_stmt|;
name|fbsd_core_ops
operator|.
name|to_thread_alive
operator|=
name|fbsd_thread_alive
expr_stmt|;
name|fbsd_core_ops
operator|.
name|to_pid_to_str
operator|=
name|fbsd_thread_pid_to_str
expr_stmt|;
name|fbsd_core_ops
operator|.
name|to_find_new_threads
operator|=
name|fbsd_thread_find_new_threads
expr_stmt|;
name|fbsd_core_ops
operator|.
name|to_sections
operator|=
literal|0
expr_stmt|;
name|fbsd_core_ops
operator|.
name|to_sections_end
operator|=
literal|0
expr_stmt|;
name|fbsd_core_ops
operator|.
name|to_magic
operator|=
name|OPS_MAGIC
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_fbsd_thread_ops
parameter_list|(
name|void
parameter_list|)
block|{
name|fbsd_thread_ops
operator|.
name|to_shortname
operator|=
literal|"freebsd-threads"
expr_stmt|;
name|fbsd_thread_ops
operator|.
name|to_longname
operator|=
literal|"FreeBSD multithreaded child process."
expr_stmt|;
name|fbsd_thread_ops
operator|.
name|to_doc
operator|=
literal|"FreeBSD threads support."
expr_stmt|;
name|fbsd_thread_ops
operator|.
name|to_attach
operator|=
name|fbsd_thread_attach
expr_stmt|;
name|fbsd_thread_ops
operator|.
name|to_detach
operator|=
name|fbsd_thread_detach
expr_stmt|;
name|fbsd_thread_ops
operator|.
name|to_post_attach
operator|=
name|fbsd_thread_post_attach
expr_stmt|;
name|fbsd_thread_ops
operator|.
name|to_resume
operator|=
name|fbsd_thread_resume
expr_stmt|;
name|fbsd_thread_ops
operator|.
name|to_wait
operator|=
name|fbsd_thread_wait
expr_stmt|;
name|fbsd_thread_ops
operator|.
name|to_fetch_registers
operator|=
name|fbsd_thread_fetch_registers
expr_stmt|;
name|fbsd_thread_ops
operator|.
name|to_store_registers
operator|=
name|fbsd_thread_store_registers
expr_stmt|;
name|fbsd_thread_ops
operator|.
name|to_xfer_memory
operator|=
name|fbsd_thread_xfer_memory
expr_stmt|;
name|fbsd_thread_ops
operator|.
name|to_files_info
operator|=
name|fbsd_thread_files_info
expr_stmt|;
name|fbsd_thread_ops
operator|.
name|to_kill
operator|=
name|fbsd_thread_kill
expr_stmt|;
name|fbsd_thread_ops
operator|.
name|to_create_inferior
operator|=
name|fbsd_thread_create_inferior
expr_stmt|;
name|fbsd_thread_ops
operator|.
name|to_post_startup_inferior
operator|=
name|fbsd_thread_post_startup_inferior
expr_stmt|;
name|fbsd_thread_ops
operator|.
name|to_mourn_inferior
operator|=
name|fbsd_thread_mourn_inferior
expr_stmt|;
name|fbsd_thread_ops
operator|.
name|to_can_run
operator|=
name|fbsd_thread_can_run
expr_stmt|;
name|fbsd_thread_ops
operator|.
name|to_thread_alive
operator|=
name|fbsd_thread_alive
expr_stmt|;
name|fbsd_thread_ops
operator|.
name|to_find_new_threads
operator|=
name|fbsd_thread_find_new_threads
expr_stmt|;
name|fbsd_thread_ops
operator|.
name|to_pid_to_str
operator|=
name|fbsd_thread_pid_to_str
expr_stmt|;
name|fbsd_thread_ops
operator|.
name|to_stratum
operator|=
name|thread_stratum
expr_stmt|;
name|fbsd_thread_ops
operator|.
name|to_has_thread_control
operator|=
name|tc_none
expr_stmt|;
name|fbsd_thread_ops
operator|.
name|to_has_all_memory
operator|=
literal|1
expr_stmt|;
name|fbsd_thread_ops
operator|.
name|to_has_memory
operator|=
literal|1
expr_stmt|;
name|fbsd_thread_ops
operator|.
name|to_has_stack
operator|=
literal|1
expr_stmt|;
name|fbsd_thread_ops
operator|.
name|to_has_registers
operator|=
literal|1
expr_stmt|;
name|fbsd_thread_ops
operator|.
name|to_has_execution
operator|=
literal|1
expr_stmt|;
name|fbsd_thread_ops
operator|.
name|to_insert_breakpoint
operator|=
name|memory_insert_breakpoint
expr_stmt|;
name|fbsd_thread_ops
operator|.
name|to_remove_breakpoint
operator|=
name|memory_remove_breakpoint
expr_stmt|;
name|fbsd_thread_ops
operator|.
name|to_get_thread_local_address
operator|=
name|fbsd_thread_get_local_address
expr_stmt|;
name|fbsd_thread_ops
operator|.
name|to_magic
operator|=
name|OPS_MAGIC
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|thread_db_load
parameter_list|(
name|void
parameter_list|)
block|{
name|void
modifier|*
name|handle
decl_stmt|;
name|td_err_e
name|err
decl_stmt|;
name|handle
operator|=
name|dlopen
argument_list|(
name|LIBTHREAD_DB_SO
argument_list|,
name|RTLD_NOW
argument_list|)
expr_stmt|;
if|if
condition|(
name|handle
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
define|#
directive|define
name|resolve
parameter_list|(
name|X
parameter_list|)
define|\
value|if (!(X##_p = dlsym (handle, #X)))	\    return 0;
name|resolve
argument_list|(
name|td_init
argument_list|)
expr_stmt|;
name|resolve
argument_list|(
name|td_ta_new
argument_list|)
expr_stmt|;
name|resolve
argument_list|(
name|td_ta_delete
argument_list|)
expr_stmt|;
name|resolve
argument_list|(
name|td_ta_map_id2thr
argument_list|)
expr_stmt|;
name|resolve
argument_list|(
name|td_ta_map_lwp2thr
argument_list|)
expr_stmt|;
name|resolve
argument_list|(
name|td_ta_thr_iter
argument_list|)
expr_stmt|;
name|resolve
argument_list|(
name|td_thr_get_info
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PT_GETXMMREGS
name|resolve
argument_list|(
name|td_thr_getxmmregs
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|resolve
argument_list|(
name|td_thr_getfpregs
argument_list|)
expr_stmt|;
name|resolve
argument_list|(
name|td_thr_getgregs
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PT_GETXMMREGS
name|resolve
argument_list|(
name|td_thr_setxmmregs
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|resolve
argument_list|(
name|td_thr_setfpregs
argument_list|)
expr_stmt|;
name|resolve
argument_list|(
name|td_thr_setgregs
argument_list|)
expr_stmt|;
name|resolve
argument_list|(
name|td_thr_sstep
argument_list|)
expr_stmt|;
name|resolve
argument_list|(
name|td_ta_tsd_iter
argument_list|)
expr_stmt|;
name|resolve
argument_list|(
name|td_thr_dbsuspend
argument_list|)
expr_stmt|;
name|resolve
argument_list|(
name|td_thr_dbresume
argument_list|)
expr_stmt|;
name|resolve
argument_list|(
name|td_thr_tls_get_addr
argument_list|)
expr_stmt|;
comment|/* Initialize the library.  */
name|err
operator|=
name|td_init_p
argument_list|()
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|TD_OK
condition|)
block|{
name|warning
argument_list|(
literal|"Cannot initialize libthread_db: %s"
argument_list|,
name|thread_db_err_str
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* These are not essential.  */
name|td_ta_event_addr_p
operator|=
name|dlsym
argument_list|(
name|handle
argument_list|,
literal|"td_ta_event_addr"
argument_list|)
expr_stmt|;
name|td_ta_set_event_p
operator|=
name|dlsym
argument_list|(
name|handle
argument_list|,
literal|"td_ta_set_event"
argument_list|)
expr_stmt|;
name|td_ta_event_getmsg_p
operator|=
name|dlsym
argument_list|(
name|handle
argument_list|,
literal|"td_ta_event_getmsg"
argument_list|)
expr_stmt|;
name|td_thr_event_enable_p
operator|=
name|dlsym
argument_list|(
name|handle
argument_list|,
literal|"td_thr_event_enable"
argument_list|)
expr_stmt|;
name|td_thr_tls_get_addr_p
operator|=
name|dlsym
argument_list|(
name|handle
argument_list|,
literal|"td_thr_tls_get_addr"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* we suppress the call to add_target of core_ops in corelow because    if there are two targets in the stratum core_stratum, find_core_target    won't know which one to return.  see corelow.c for an additonal    comment on coreops_suppress_target. */
end_comment

begin_decl_stmt
name|int
name|coreops_suppress_target
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|_initialize_thread_db
parameter_list|(
name|void
parameter_list|)
block|{
name|init_fbsd_thread_ops
argument_list|()
expr_stmt|;
name|init_fbsd_core_ops
argument_list|()
expr_stmt|;
if|if
condition|(
name|thread_db_load
argument_list|()
condition|)
block|{
name|add_target
argument_list|(
operator|&
name|fbsd_thread_ops
argument_list|)
expr_stmt|;
comment|/* "thread tsd" command */
name|add_cmd
argument_list|(
literal|"tsd"
argument_list|,
name|class_run
argument_list|,
name|fbsd_thread_tsd_cmd
argument_list|,
literal|"Show the thread-specific data keys and destructors "
literal|"for the process.\n"
argument_list|,
operator|&
name|thread_cmd_list
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"signal"
argument_list|,
name|class_run
argument_list|,
name|fbsd_thread_signal_cmd
argument_list|,
literal|"Show the thread signal info.\n"
argument_list|,
operator|&
name|thread_cmd_list
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|orig_core_ops
argument_list|,
operator|&
name|core_ops
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|target_ops
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|core_ops
argument_list|,
operator|&
name|fbsd_core_ops
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|target_ops
argument_list|)
argument_list|)
expr_stmt|;
name|add_target
argument_list|(
operator|&
name|core_ops
argument_list|)
expr_stmt|;
comment|/* Add ourselves to objfile event chain. */
name|target_new_objfile_chain
operator|=
name|target_new_objfile_hook
expr_stmt|;
name|target_new_objfile_hook
operator|=
name|fbsd_thread_new_objfile
expr_stmt|;
name|child_suppress_run
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"[GDB will not be able to debug user-mode threads: %s]\n"
argument_list|,
name|dlerror
argument_list|()
argument_list|)
expr_stmt|;
comment|/* allow the user to debug non-threaded core files */
name|add_target
argument_list|(
operator|&
name|core_ops
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* proc service functions */
end_comment

begin_function
name|void
name|ps_plog
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vfprintf_filtered
argument_list|(
name|gdb_stderr
argument_list|,
name|fmt
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|ps_err_e
name|ps_pglobal_lookup
parameter_list|(
name|struct
name|ps_prochandle
modifier|*
name|ph
parameter_list|,
specifier|const
name|char
modifier|*
name|obj
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|psaddr_t
modifier|*
name|sym_addr
parameter_list|)
block|{
name|struct
name|minimal_symbol
modifier|*
name|ms
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|ms
operator|=
name|lookup_minimal_symbol
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ms
operator|==
name|NULL
condition|)
return|return
name|PS_NOSYM
return|;
name|addr
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|ms
argument_list|)
expr_stmt|;
name|store_typed_address
argument_list|(
name|sym_addr
argument_list|,
name|builtin_type_void_data_ptr
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
name|PS_OK
return|;
block|}
end_function

begin_function
name|ps_err_e
name|ps_pread
parameter_list|(
name|struct
name|ps_prochandle
modifier|*
name|ph
parameter_list|,
name|psaddr_t
name|addr
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|int
name|err
init|=
name|target_read_memory
argument_list|(
name|extract_typed_address
argument_list|(
operator|&
name|addr
argument_list|,
name|builtin_type_void_data_ptr
argument_list|)
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
decl_stmt|;
return|return
operator|(
name|err
operator|==
literal|0
condition|?
name|PS_OK
else|:
name|PS_ERR
operator|)
return|;
block|}
end_function

begin_function
name|ps_err_e
name|ps_pwrite
parameter_list|(
name|struct
name|ps_prochandle
modifier|*
name|ph
parameter_list|,
name|psaddr_t
name|addr
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|int
name|err
init|=
name|target_write_memory
argument_list|(
name|extract_typed_address
argument_list|(
operator|&
name|addr
argument_list|,
name|builtin_type_void_data_ptr
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
name|buf
argument_list|,
name|len
argument_list|)
decl_stmt|;
return|return
operator|(
name|err
operator|==
literal|0
condition|?
name|PS_OK
else|:
name|PS_ERR
operator|)
return|;
block|}
end_function

begin_function
name|ps_err_e
name|ps_lgetregs
parameter_list|(
name|struct
name|ps_prochandle
modifier|*
name|ph
parameter_list|,
name|lwpid_t
name|lwpid
parameter_list|,
name|prgregset_t
name|gregset
parameter_list|)
block|{
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|old_chain
operator|=
name|save_inferior_ptid
argument_list|()
expr_stmt|;
comment|/* XXX: Target operation isn't lwp aware: replace pid with lwp */
name|inferior_ptid
operator|=
name|BUILD_LWP
argument_list|(
literal|0
argument_list|,
name|lwpid
argument_list|)
expr_stmt|;
name|target_fetch_registers
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fill_gregset
argument_list|(
name|gregset
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
name|PS_OK
return|;
block|}
end_function

begin_function
name|ps_err_e
name|ps_lsetregs
parameter_list|(
name|struct
name|ps_prochandle
modifier|*
name|ph
parameter_list|,
name|lwpid_t
name|lwpid
parameter_list|,
specifier|const
name|prgregset_t
name|gregset
parameter_list|)
block|{
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|old_chain
operator|=
name|save_inferior_ptid
argument_list|()
expr_stmt|;
name|inferior_ptid
operator|=
name|BUILD_LWP
argument_list|(
name|lwpid
argument_list|,
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|)
expr_stmt|;
name|supply_gregset
argument_list|(
name|gregset
argument_list|)
expr_stmt|;
name|target_store_registers
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
name|PS_OK
return|;
block|}
end_function

begin_function
name|ps_err_e
name|ps_lgetfpregs
parameter_list|(
name|struct
name|ps_prochandle
modifier|*
name|ph
parameter_list|,
name|lwpid_t
name|lwpid
parameter_list|,
name|prfpregset_t
modifier|*
name|fpregset
parameter_list|)
block|{
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|old_chain
operator|=
name|save_inferior_ptid
argument_list|()
expr_stmt|;
name|inferior_ptid
operator|=
name|BUILD_LWP
argument_list|(
name|lwpid
argument_list|,
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|)
expr_stmt|;
name|target_fetch_registers
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fill_fpregset
argument_list|(
name|fpregset
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
name|PS_OK
return|;
block|}
end_function

begin_function
name|ps_err_e
name|ps_lsetfpregs
parameter_list|(
name|struct
name|ps_prochandle
modifier|*
name|ph
parameter_list|,
name|lwpid_t
name|lwpid
parameter_list|,
specifier|const
name|prfpregset_t
modifier|*
name|fpregset
parameter_list|)
block|{
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|old_chain
operator|=
name|save_inferior_ptid
argument_list|()
expr_stmt|;
name|inferior_ptid
operator|=
name|BUILD_LWP
argument_list|(
name|lwpid
argument_list|,
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|)
expr_stmt|;
name|supply_fpregset
argument_list|(
name|fpregset
argument_list|)
expr_stmt|;
name|target_store_registers
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
name|PS_OK
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|PT_GETXMMREGS
end_ifdef

begin_function
name|ps_err_e
name|ps_lgetxmmregs
parameter_list|(
name|struct
name|ps_prochandle
modifier|*
name|ph
parameter_list|,
name|lwpid_t
name|lwpid
parameter_list|,
name|char
modifier|*
name|xmmregs
parameter_list|)
block|{
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|old_chain
operator|=
name|save_inferior_ptid
argument_list|()
expr_stmt|;
name|inferior_ptid
operator|=
name|BUILD_LWP
argument_list|(
name|lwpid
argument_list|,
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|)
expr_stmt|;
name|target_fetch_registers
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|i387_fill_fxsave
argument_list|(
name|xmmregs
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
name|PS_OK
return|;
block|}
end_function

begin_function
name|ps_err_e
name|ps_lsetxmmregs
parameter_list|(
name|struct
name|ps_prochandle
modifier|*
name|ph
parameter_list|,
name|lwpid_t
name|lwpid
parameter_list|,
specifier|const
name|char
modifier|*
name|xmmregs
parameter_list|)
block|{
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|old_chain
operator|=
name|save_inferior_ptid
argument_list|()
expr_stmt|;
name|inferior_ptid
operator|=
name|BUILD_LWP
argument_list|(
name|lwpid
argument_list|,
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|)
expr_stmt|;
name|i387_supply_fxsave
argument_list|(
name|current_regcache
argument_list|,
operator|-
literal|1
argument_list|,
name|xmmregs
argument_list|)
expr_stmt|;
name|target_store_registers
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
name|PS_OK
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|ps_err_e
name|ps_lstop
parameter_list|(
name|struct
name|ps_prochandle
modifier|*
name|ph
parameter_list|,
name|lwpid_t
name|lwpid
parameter_list|)
block|{
if|if
condition|(
name|ptrace
argument_list|(
name|PT_SUSPEND
argument_list|,
name|lwpid
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
name|PS_ERR
return|;
return|return
name|PS_OK
return|;
block|}
end_function

begin_function
name|ps_err_e
name|ps_lcontinue
parameter_list|(
name|struct
name|ps_prochandle
modifier|*
name|ph
parameter_list|,
name|lwpid_t
name|lwpid
parameter_list|)
block|{
if|if
condition|(
name|ptrace
argument_list|(
name|PT_RESUME
argument_list|,
name|lwpid
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
name|PS_ERR
return|;
return|return
name|PS_OK
return|;
block|}
end_function

begin_function
name|ps_err_e
name|ps_linfo
parameter_list|(
name|struct
name|ps_prochandle
modifier|*
name|ph
parameter_list|,
name|lwpid_t
name|lwpid
parameter_list|,
name|void
modifier|*
name|info
parameter_list|)
block|{
if|if
condition|(
name|fbsd_thread_core
condition|)
block|{
comment|/* XXX should verify lwpid and make a pseudo lwp info */
name|memset
argument_list|(
name|info
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ptrace_lwpinfo
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|PS_OK
return|;
block|}
if|if
condition|(
name|ptrace
argument_list|(
name|PT_LWPINFO
argument_list|,
name|lwpid
argument_list|,
name|info
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ptrace_lwpinfo
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
name|PS_ERR
return|;
return|return
name|PS_OK
return|;
block|}
end_function

end_unit

