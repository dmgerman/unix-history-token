begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * This code is derived from software copyrighted by the Free Software  * Foundation.  *  * Modified 1991 by Donn Seeley at UUNET Technologies, Inc.  * Modified 1990 by Van Jacobson at Lawrence Berkeley Laboratory.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)readline.c	6.4 (Berkeley) 5/8/91"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/* readline.c -- a general facility for reading lines of input    with emacs style editing and completion. */
end_comment

begin_comment
comment|/* Copyright (C) 1987,1989 Free Software Foundation, Inc.     This file contains the Readline Library (the Library), a set of    routines for providing Emacs style line input to programs that ask    for it.     The Library is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 1, or (at your option)    any later version.     The Library is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     The GNU General Public License is often shipped with GNU software, and    is generally kept in a file called COPYING or LICENSE.  If you do not    have a copy of the license, write to the Free Software Foundation,    675 Mass Ave, Cambridge, MA 02139, USA. */
end_comment

begin_comment
comment|/* Remove these declarations when we have a complete libgnu.a. */
end_comment

begin_define
define|#
directive|define
name|STATIC_MALLOC
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|STATIC_MALLOC
end_ifndef

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|xmalloc
argument_list|()
decl_stmt|,
modifier|*
name|xrealloc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|char
modifier|*
name|xmalloc
argument_list|()
decl_stmt|,
modifier|*
name|xrealloc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_define
define|#
directive|define
name|alloca
value|__builtin_alloca
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|defined
argument_list|(
name|sparc
argument_list|)
operator|&&
name|defined
argument_list|(
name|sun
argument_list|)
end_if

begin_include
include|#
directive|include
file|<alloca.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|NEW_TTY_DRIVER
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SYSV
argument_list|)
operator|||
name|defined
argument_list|(
name|hpux
argument_list|)
end_if

begin_undef
undef|#
directive|undef
name|NEW_TTY_DRIVER
end_undef

begin_include
include|#
directive|include
file|<termio.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_comment
comment|/* These next are for filename completion.  Perhaps this belongs    in a different place. */
end_comment

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SYSV
end_ifdef

begin_decl_stmt
name|struct
name|passwd
modifier|*
name|getpwuid
argument_list|()
decl_stmt|,
modifier|*
name|getpwent
argument_list|()
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|HACK_TERMCAP_MOTION
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|SYSV
end_ifndef

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* SYSV */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|hpux
end_ifdef

begin_include
include|#
directive|include
file|<ndir.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_define
define|#
directive|define
name|direct
value|dirent
end_define

begin_define
define|#
directive|define
name|d_namlen
value|d_reclen
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* hpux */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYSV */
end_comment

begin_comment
comment|/* Some standard library routines. */
end_comment

begin_include
include|#
directive|include
file|"readline.h"
end_include

begin_include
include|#
directive|include
file|"history.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|digit
end_ifndef

begin_define
define|#
directive|define
name|digit
parameter_list|(
name|c
parameter_list|)
value|((c)>= '0'&& (c)<= '9')
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|isletter
end_ifndef

begin_define
define|#
directive|define
name|isletter
parameter_list|(
name|c
parameter_list|)
value|(((c)>= 'A'&& (c)<= 'Z') || ((c)>= 'a'&& (c)<= 'z'))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|digit_value
end_ifndef

begin_define
define|#
directive|define
name|digit_value
parameter_list|(
name|c
parameter_list|)
value|((c) - '0')
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|member
end_ifndef

begin_function_decl
name|char
modifier|*
name|index
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|member
parameter_list|(
name|c
parameter_list|,
name|s
parameter_list|)
value|((c) ? index ((s), (c)) : 0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|isident
end_ifndef

begin_define
define|#
directive|define
name|isident
parameter_list|(
name|c
parameter_list|)
value|((isletter(c) || digit(c) || c == '_'))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|exchange
end_ifndef

begin_define
define|#
directive|define
name|exchange
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|{int temp = x; x = y; y = temp;}
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
specifier|static
name|update_line
argument_list|()
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|void
name|output_character_function
parameter_list|()
function_decl|;
end_function_decl

begin_expr_stmt
specifier|static
name|delete_chars
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|start_insert
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|end_insert
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* This typedef is equivalant to the one for Function; it allows us    to say SigHandler *foo = signal (SIGKILL, SIG_IGN); */
end_comment

begin_typedef
typedef|typedef
name|void
name|SigHandler
parameter_list|()
function_decl|;
end_typedef

begin_ifdef
ifdef|#
directive|ifdef
name|SIGWINCH
end_ifdef

begin_function_decl
specifier|static
name|void
name|rl_handle_sigwinch
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|SigHandler
modifier|*
name|old_sigwinch
init|=
operator|(
name|SigHandler
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* If on, then readline handles signals in a way that doesn't screw. */
end_comment

begin_comment
comment|/* #define HANDLE_SIGNALS */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SYSV
argument_list|)
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|HANDLE_SIGNALS
end_ifdef

begin_undef
undef|#
directive|undef
name|HANDLE_SIGNALS
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Stupid comparison routine for qsort () ing strings. */
end_comment

begin_function
specifier|static
name|int
name|compare_strings
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
name|char
modifier|*
modifier|*
name|s1
decl_stmt|,
decl|*
modifier|*
name|s2
decl_stmt|;
end_function

begin_block
block|{
return|return
operator|(
name|strcmp
argument_list|(
operator|*
name|s1
argument_list|,
operator|*
name|s2
argument_list|)
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Line editing input utility		    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* A pointer to the keymap that is currently in use.    By default, it is the standard emacs keymap. */
end_comment

begin_decl_stmt
name|Keymap
name|keymap
init|=
name|emacs_standard_keymap
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|vi_mode
value|0
end_define

begin_define
define|#
directive|define
name|emacs_mode
value|1
end_define

begin_comment
comment|/* The current style of editing. */
end_comment

begin_decl_stmt
name|int
name|rl_editing_mode
init|=
name|emacs_mode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero if the previous command was a kill command. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|last_command_was_kill
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The current value of the numeric argument specified by the user. */
end_comment

begin_decl_stmt
name|int
name|rl_numeric_arg
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero if an argument was typed. */
end_comment

begin_decl_stmt
name|int
name|rl_explicit_arg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Temporary value used while generating the argument. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|arg_sign
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means we have been called at least once before. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|rl_initialized
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If non-zero, this program is running in an EMACS buffer. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|running_in_emacs
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The current offset in the current input line. */
end_comment

begin_decl_stmt
name|int
name|rl_point
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Mark in the current input line. */
end_comment

begin_decl_stmt
name|int
name|rl_mark
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Length of the current input line. */
end_comment

begin_decl_stmt
name|int
name|rl_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Make this non-zero to return the current input_line. */
end_comment

begin_decl_stmt
name|int
name|rl_done
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The last function executed by readline. */
end_comment

begin_decl_stmt
name|Function
modifier|*
name|rl_last_func
init|=
operator|(
name|Function
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Top level environment for readline_internal (). */
end_comment

begin_decl_stmt
specifier|static
name|jmp_buf
name|readline_top_level
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The streams we interact with. */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|in_stream
decl_stmt|,
modifier|*
name|out_stream
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The names of the streams that we do input and output to. */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|rl_instream
init|=
name|stdin
decl_stmt|,
modifier|*
name|rl_outstream
init|=
name|stdout
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means echo characters as they are read. */
end_comment

begin_decl_stmt
name|int
name|readline_echoing_p
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current prompt. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|rl_prompt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of characters read in order to type this complete command. */
end_comment

begin_decl_stmt
name|int
name|rl_key_sequence_length
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If non-zero, then this is the address of a function to call just    before readline_internal () prints the first prompt. */
end_comment

begin_decl_stmt
name|Function
modifier|*
name|rl_startup_hook
init|=
operator|(
name|Function
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* What we use internally.  You should always refer to RL_LINE_BUFFER. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|the_line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The character that can generate an EOF.  Really read from    the terminal driver... just defaulted here. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|eof_char
init|=
name|CTRL
argument_list|(
literal|'D'
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero makes this the next keystroke to read. */
end_comment

begin_decl_stmt
name|int
name|rl_pending_input
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to a useful terminal name. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|rl_terminal_name
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Line buffer and maintenence. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|rl_line_buffer
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rl_line_buffer_len
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DEFAULT_BUFFER_SIZE
value|256
end_define

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Top Level Functions			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Read a line of input.  Prompt with PROMPT.  A NULL PROMPT means    none.  A return value of NULL means that EOF was encountered. */
end_comment

begin_function
name|char
modifier|*
name|readline
parameter_list|(
name|prompt
parameter_list|)
name|char
modifier|*
name|prompt
decl_stmt|;
block|{
specifier|static
name|rl_prep_terminal
argument_list|()
operator|,
name|rl_deprep_terminal
argument_list|()
expr_stmt|;
name|char
modifier|*
name|readline_internal
parameter_list|()
function_decl|;
name|char
modifier|*
name|value
decl_stmt|;
name|rl_prompt
operator|=
name|prompt
expr_stmt|;
comment|/* If we are at EOF return a NULL string. */
if|if
condition|(
name|rl_pending_input
operator|==
name|EOF
condition|)
block|{
name|rl_pending_input
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
name|rl_initialize
argument_list|()
expr_stmt|;
name|rl_prep_terminal
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGWINCH
name|old_sigwinch
operator|=
operator|(
name|SigHandler
operator|*
operator|)
name|signal
argument_list|(
name|SIGWINCH
argument_list|,
name|rl_handle_sigwinch
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HANDLE_SIGNALS
name|rl_set_signals
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|value
operator|=
name|readline_internal
argument_list|()
expr_stmt|;
name|rl_deprep_terminal
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGWINCH
name|signal
argument_list|(
name|SIGWINCH
argument_list|,
name|old_sigwinch
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HANDLE_SIGNALS
name|rl_clear_signals
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Read a line of input from the global rl_instream, doing output on    the global rl_outstream.    If rl_prompt is non-null, then that is our prompt. */
end_comment

begin_function
name|char
modifier|*
name|readline_internal
parameter_list|()
block|{
name|int
name|lastc
decl_stmt|,
name|c
decl_stmt|,
name|eof_found
decl_stmt|;
name|in_stream
operator|=
name|rl_instream
expr_stmt|;
name|out_stream
operator|=
name|rl_outstream
expr_stmt|;
name|lastc
operator|=
name|eof_found
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rl_startup_hook
condition|)
call|(
modifier|*
name|rl_startup_hook
call|)
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|readline_echoing_p
condition|)
block|{
if|if
condition|(
name|rl_prompt
condition|)
block|{
name|fprintf
argument_list|(
name|out_stream
argument_list|,
literal|"%s"
argument_list|,
name|rl_prompt
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|out_stream
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|rl_on_new_line
argument_list|()
expr_stmt|;
name|rl_redisplay
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|VI_MODE
if|if
condition|(
name|rl_editing_mode
operator|==
name|vi_mode
condition|)
name|rl_vi_insertion_mode
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* VI_MODE */
block|}
while|while
condition|(
operator|!
name|rl_done
condition|)
block|{
name|int
name|lk
init|=
name|last_command_was_kill
decl_stmt|;
name|int
name|code
init|=
name|setjmp
argument_list|(
name|readline_top_level
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
condition|)
name|rl_redisplay
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|rl_pending_input
condition|)
block|{
comment|/* Then initialize the argument and number of keys read. */
name|rl_init_argument
argument_list|()
expr_stmt|;
name|rl_key_sequence_length
operator|=
literal|0
expr_stmt|;
block|}
name|c
operator|=
name|rl_read_key
argument_list|()
expr_stmt|;
comment|/* EOF typed to a non-blank line is a<NL>. */
if|if
condition|(
name|c
operator|==
name|EOF
operator|&&
name|rl_end
condition|)
name|c
operator|=
name|NEWLINE
expr_stmt|;
comment|/* The character eof_char typed to blank line, and not as the 	 previous character is interpreted as EOF. */
if|if
condition|(
operator|(
operator|(
name|c
operator|==
name|eof_char
operator|&&
name|lastc
operator|!=
name|c
operator|)
operator|||
name|c
operator|==
name|EOF
operator|)
operator|&&
operator|!
name|rl_end
condition|)
block|{
name|eof_found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|lastc
operator|=
name|c
expr_stmt|;
name|rl_dispatch
argument_list|(
name|c
argument_list|,
name|keymap
argument_list|)
expr_stmt|;
comment|/* If there was no change in last_command_was_kill, then no kill 	 has taken place.  Note that if input is pending we are reading 	 a prefix command, so nothing has changed yet. */
if|if
condition|(
operator|!
name|rl_pending_input
condition|)
block|{
if|if
condition|(
name|lk
operator|==
name|last_command_was_kill
condition|)
name|last_command_was_kill
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|VI_MODE
comment|/* In vi mode, when you exit insert mode, the cursor moves back 	 over the previous character.  We explicitly check for that here. */
if|if
condition|(
name|rl_editing_mode
operator|==
name|vi_mode
operator|&&
name|keymap
operator|==
name|vi_movement_keymap
condition|)
name|rl_vi_check
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|rl_done
condition|)
name|rl_redisplay
argument_list|()
expr_stmt|;
block|}
comment|/* Restore the original of this history line, iff the line that we      are editing was originally in the history, AND the line has changed. */
block|{
name|HIST_ENTRY
modifier|*
name|entry
init|=
name|current_history
argument_list|()
decl_stmt|;
if|if
condition|(
name|entry
operator|&&
name|rl_undo_list
condition|)
block|{
name|char
modifier|*
name|temp
init|=
name|savestring
argument_list|(
name|the_line
argument_list|)
decl_stmt|;
name|rl_revert_line
argument_list|()
expr_stmt|;
name|entry
operator|=
name|replace_history_entry
argument_list|(
name|where_history
argument_list|()
argument_list|,
name|the_line
argument_list|,
operator|(
name|HIST_ENTRY
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|free_history_entry
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|the_line
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* At any rate, it is highly likely that this line has an undo list.  Get      rid of it now. */
if|if
condition|(
name|rl_undo_list
condition|)
name|free_undo_list
argument_list|()
expr_stmt|;
if|if
condition|(
name|eof_found
condition|)
return|return
operator|(
name|char
operator|*
operator|)
name|NULL
return|;
else|else
return|return
operator|(
name|savestring
argument_list|(
name|the_line
argument_list|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Variables for keyboard macros.  */
end_comment

begin_comment
comment|/* The currently executing macro string.  If this is non-zero,    then it is a malloc ()'ed string where input is coming from. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|executing_macro
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The offset in the above string to the next character to be read. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|executing_macro_index
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means to save keys that we dispatch on in a kbd macro. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|defining_kbd_macro
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The current macro string being built.  Characters get stuffed    in here by add_macro_char (). */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|current_macro
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The size of the buffer allocated to current_macro. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|current_macro_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The index at which characters are being added to current_macro. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|current_macro_index
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A structure used to save nested macro strings.    It is a linked list of string/index for each saved macro. */
end_comment

begin_struct
struct|struct
name|saved_macro
block|{
name|struct
name|saved_macro
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|index
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The list of saved macros. */
end_comment

begin_decl_stmt
name|struct
name|saved_macro
modifier|*
name|macro_list
init|=
operator|(
expr|struct
name|saved_macro
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*					        		    */
end_comment

begin_comment
comment|/*			   Signal Handling                          */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SIGWINCH
end_ifdef

begin_function
specifier|static
name|void
name|rl_handle_sigwinch
parameter_list|(
name|sig
parameter_list|,
name|code
parameter_list|,
name|scp
parameter_list|)
name|int
name|sig
decl_stmt|,
name|code
decl_stmt|;
name|struct
name|sigcontext
modifier|*
name|scp
decl_stmt|;
block|{
name|char
modifier|*
name|term
init|=
name|rl_terminal_name
decl_stmt|,
modifier|*
name|getenv
argument_list|()
decl_stmt|;
if|if
condition|(
name|readline_echoing_p
condition|)
block|{
if|if
condition|(
operator|!
name|term
condition|)
name|term
operator|=
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|term
condition|)
name|term
operator|=
literal|"dumb"
expr_stmt|;
name|rl_reset_terminal
argument_list|(
name|term
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NEVER
name|crlf
argument_list|()
expr_stmt|;
name|rl_forced_update_display
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|old_sigwinch
operator|&&
name|old_sigwinch
operator|!=
operator|(
name|SigHandler
operator|*
operator|)
name|SIG_IGN
operator|&&
name|old_sigwinch
operator|!=
operator|(
name|SigHandler
operator|*
operator|)
name|SIG_DFL
condition|)
call|(
modifier|*
name|old_sigwinch
call|)
argument_list|(
name|sig
argument_list|,
name|code
argument_list|,
name|scp
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SIGWINCH */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HANDLE_SIGNALS
end_ifdef

begin_comment
comment|/* Interrupt handling. */
end_comment

begin_decl_stmt
specifier|static
name|SigHandler
modifier|*
name|old_int
init|=
operator|(
name|SigHandler
operator|*
operator|)
name|NULL
decl_stmt|,
modifier|*
name|old_tstp
init|=
operator|(
name|SigHandler
operator|*
operator|)
name|NULL
decl_stmt|,
modifier|*
name|old_ttou
init|=
operator|(
name|SigHandler
operator|*
operator|)
name|NULL
decl_stmt|,
modifier|*
name|old_ttin
init|=
operator|(
name|SigHandler
operator|*
operator|)
name|NULL
decl_stmt|,
modifier|*
name|old_cont
init|=
operator|(
name|SigHandler
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Handle an interrupt character. */
end_comment

begin_function
specifier|static
name|void
name|rl_signal_handler
parameter_list|(
name|sig
parameter_list|,
name|code
parameter_list|,
name|scp
parameter_list|)
name|int
name|sig
decl_stmt|,
name|code
decl_stmt|;
name|struct
name|sigcontext
modifier|*
name|scp
decl_stmt|;
block|{
specifier|static
name|rl_prep_terminal
argument_list|()
operator|,
name|rl_deprep_terminal
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|sig
condition|)
block|{
case|case
name|SIGINT
case|:
name|free_undo_list
argument_list|()
expr_stmt|;
name|rl_clear_message
argument_list|()
expr_stmt|;
name|rl_init_argument
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGWINCH
name|signal
argument_list|(
name|SIGWINCH
argument_list|,
name|old_sigwinch
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGTSTP
case|case
name|SIGTSTP
case|:
case|case
name|SIGTTOU
case|:
case|case
name|SIGTTIN
case|:
endif|#
directive|endif
name|rl_clean_up_for_exit
argument_list|()
expr_stmt|;
name|rl_deprep_terminal
argument_list|()
expr_stmt|;
name|rl_clear_signals
argument_list|()
expr_stmt|;
name|rl_pending_input
operator|=
literal|0
expr_stmt|;
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|sig
argument_list|)
expr_stmt|;
name|sigsetmask
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|rl_prep_terminal
argument_list|()
expr_stmt|;
name|rl_set_signals
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_macro
name|rl_set_signals
argument_list|()
end_macro

begin_block
block|{
name|old_int
operator|=
operator|(
name|SigHandler
operator|*
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|rl_signal_handler
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_int
operator|==
operator|(
name|SigHandler
operator|*
operator|)
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGTSTP
name|old_tstp
operator|=
operator|(
name|SigHandler
operator|*
operator|)
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|rl_signal_handler
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_tstp
operator|==
operator|(
name|SigHandler
operator|*
operator|)
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGTTOU
name|old_ttou
operator|=
operator|(
name|SigHandler
operator|*
operator|)
name|signal
argument_list|(
name|SIGTTOU
argument_list|,
name|rl_signal_handler
argument_list|)
expr_stmt|;
name|old_ttin
operator|=
operator|(
name|SigHandler
operator|*
operator|)
name|signal
argument_list|(
name|SIGTTIN
argument_list|,
name|rl_signal_handler
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|rl_clear_signals
argument_list|()
end_macro

begin_block
block|{
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|old_int
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGTSTP
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|old_tstp
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGTTOU
name|signal
argument_list|(
name|SIGTTOU
argument_list|,
name|old_ttou
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTTIN
argument_list|,
name|old_ttin
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HANDLE_SIGNALS */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Character Input Buffering       	    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* If the terminal was in xoff state when we got to it, then xon_char    contains the character that is supposed to start it again. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|xon_char
decl_stmt|,
name|xoff_state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pop_index
init|=
literal|0
decl_stmt|,
name|push_index
init|=
literal|0
decl_stmt|,
name|ibuffer_len
init|=
literal|511
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|ibuffer
index|[
literal|512
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-null means it is a pointer to a function to run while waiting for    character input. */
end_comment

begin_decl_stmt
name|Function
modifier|*
name|rl_event_hook
init|=
operator|(
name|Function
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|any_typein
value|(push_index != pop_index)
end_define

begin_comment
comment|/* Add KEY to the buffer of characters to be read. */
end_comment

begin_macro
name|rl_stuff_char
argument_list|(
argument|key
argument_list|)
end_macro

begin_decl_stmt
name|int
name|key
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|key
operator|==
name|EOF
condition|)
block|{
name|key
operator|=
name|NEWLINE
expr_stmt|;
name|rl_pending_input
operator|=
name|EOF
expr_stmt|;
block|}
name|ibuffer
index|[
name|push_index
operator|++
index|]
operator|=
name|key
expr_stmt|;
if|if
condition|(
name|push_index
operator|>=
name|ibuffer_len
condition|)
name|push_index
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Return the amount of space available in the    buffer for stuffing characters. */
end_comment

begin_function
name|int
name|ibuffer_space
parameter_list|()
block|{
if|if
condition|(
name|pop_index
operator|>
name|push_index
condition|)
return|return
operator|(
name|pop_index
operator|-
name|push_index
operator|)
return|;
else|else
return|return
operator|(
name|ibuffer_len
operator|-
operator|(
name|push_index
operator|-
name|pop_index
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Get a key from the buffer of characters to be read.    Result is KEY if there was a key, or -2 if there wasn't. */
end_comment

begin_function
name|int
name|rl_get_char
parameter_list|()
block|{
name|int
name|key
decl_stmt|;
if|if
condition|(
name|push_index
operator|==
name|pop_index
condition|)
return|return
operator|(
operator|-
literal|2
operator|)
return|;
name|key
operator|=
name|ibuffer
index|[
name|pop_index
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|pop_index
operator|>=
name|ibuffer_len
condition|)
name|pop_index
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|key
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Stuff KEY into the *front* of the input buffer.    Returns non-zero if successful, zero if there is    no space left in the buffer. */
end_comment

begin_function
name|int
name|rl_unget_char
parameter_list|(
name|key
parameter_list|)
name|int
name|key
decl_stmt|;
block|{
if|if
condition|(
name|ibuffer_space
argument_list|()
condition|)
block|{
name|pop_index
operator|--
expr_stmt|;
if|if
condition|(
name|pop_index
operator|<
literal|0
condition|)
name|pop_index
operator|=
name|ibuffer_len
operator|-
literal|1
expr_stmt|;
name|ibuffer
index|[
name|pop_index
index|]
operator|=
name|key
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|rl_getc
parameter_list|(
name|stream
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|int
name|result
decl_stmt|;
name|int
name|nchar
decl_stmt|;
name|int
name|tty
init|=
name|fileno
argument_list|(
name|stream
argument_list|)
decl_stmt|;
name|char
name|buf
index|[
literal|512
index|]
decl_stmt|;
comment|/* XXX - must be at least as large as ibuffer */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|tty
argument_list|,
name|FIONREAD
argument_list|,
operator|&
name|nchar
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|nchar
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|nchar
operator|<=
literal|0
condition|)
name|nchar
operator|=
literal|1
expr_stmt|;
name|result
operator|=
name|ibuffer_space
argument_list|()
expr_stmt|;
if|if
condition|(
name|nchar
operator|>
name|result
condition|)
name|nchar
operator|=
name|result
expr_stmt|;
name|result
operator|=
name|read
argument_list|(
name|tty
argument_list|,
name|buf
argument_list|,
name|nchar
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|>
literal|0
condition|)
block|{
specifier|register
name|char
modifier|*
name|cp
init|=
name|buf
decl_stmt|;
while|while
condition|(
operator|--
name|result
operator|>=
literal|0
condition|)
name|rl_stuff_char
argument_list|(
operator|*
name|cp
operator|++
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
block|{
name|rl_stuff_char
argument_list|(
name|EOF
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Read a key, including pending input. */
end_comment

begin_function
name|int
name|rl_read_key
parameter_list|()
block|{
name|int
name|c
decl_stmt|;
name|rl_key_sequence_length
operator|++
expr_stmt|;
if|if
condition|(
name|rl_pending_input
condition|)
block|{
name|c
operator|=
name|rl_pending_input
expr_stmt|;
name|rl_pending_input
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
specifier|static
name|int
name|next_macro_key
parameter_list|()
function_decl|;
comment|/* If input is coming from a macro, then use that. */
if|if
condition|(
name|c
operator|=
name|next_macro_key
argument_list|()
condition|)
return|return
operator|(
name|c
operator|)
return|;
while|while
condition|(
operator|(
name|c
operator|=
name|rl_get_char
argument_list|()
operator|)
operator|==
operator|-
literal|2
condition|)
block|{
if|if
condition|(
name|rl_event_hook
condition|)
block|{
call|(
modifier|*
name|rl_event_hook
call|)
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|rl_get_char
argument_list|()
operator|)
operator|!=
operator|-
literal|2
condition|)
return|return
operator|(
name|c
operator|)
return|;
block|}
name|rl_getc
argument_list|(
name|in_stream
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|TIOCSTART
comment|/* Ugh.  But I can't think of a better way. */
if|if
condition|(
name|xoff_state
operator|&&
name|c
operator|==
name|xon_char
condition|)
block|{
name|ioctl
argument_list|(
name|fileno
argument_list|(
name|in_stream
argument_list|)
argument_list|,
name|TIOCSTART
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|xoff_state
operator|=
literal|0
expr_stmt|;
return|return
name|rl_read_key
argument_list|()
return|;
block|}
endif|#
directive|endif
comment|/* TIOCSTART */
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Do the command associated with KEY in MAP.    If the associated command is really a keymap, then read    another key, and dispatch into that map. */
end_comment

begin_expr_stmt
name|rl_dispatch
argument_list|(
name|key
argument_list|,
name|map
argument_list|)
specifier|register
name|int
name|key
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|Keymap
name|map
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|defining_kbd_macro
condition|)
block|{
specifier|static
name|add_macro_char
argument_list|()
expr_stmt|;
name|add_macro_char
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|key
operator|>
literal|127
operator|&&
name|key
operator|<
literal|256
condition|)
block|{
if|if
condition|(
name|map
index|[
name|ESC
index|]
operator|.
name|type
operator|==
name|ISKMAP
condition|)
block|{
name|map
operator|=
operator|(
name|Keymap
operator|)
name|map
index|[
name|ESC
index|]
operator|.
name|function
expr_stmt|;
name|key
operator|-=
literal|128
expr_stmt|;
name|rl_dispatch
argument_list|(
name|key
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
else|else
name|ding
argument_list|()
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|map
index|[
name|key
index|]
operator|.
name|type
condition|)
block|{
case|case
name|ISFUNC
case|:
block|{
name|Function
modifier|*
name|func
init|=
name|map
index|[
name|key
index|]
operator|.
name|function
decl_stmt|;
if|if
condition|(
name|func
operator|!=
operator|(
name|Function
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* Special case rl_do_lowercase_version (). */
if|if
condition|(
name|func
operator|==
name|rl_do_lowercase_version
condition|)
block|{
name|rl_dispatch
argument_list|(
name|to_lower
argument_list|(
name|key
argument_list|)
argument_list|,
name|map
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
operator|*
name|map
index|[
name|key
index|]
operator|.
name|function
operator|)
operator|(
name|rl_numeric_arg
operator|*
name|arg_sign
operator|,
name|key
operator|)
expr_stmt|;
block|}
else|else
block|{
name|ding
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
break|break;
case|case
name|ISKMAP
case|:
if|if
condition|(
name|map
index|[
name|key
index|]
operator|.
name|function
operator|!=
operator|(
name|Function
operator|*
operator|)
name|NULL
condition|)
block|{
name|int
name|newkey
decl_stmt|;
name|rl_key_sequence_length
operator|++
expr_stmt|;
name|newkey
operator|=
name|rl_read_key
argument_list|()
expr_stmt|;
name|rl_dispatch
argument_list|(
name|newkey
argument_list|,
operator|(
name|Keymap
operator|)
name|map
index|[
name|key
index|]
operator|.
name|function
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ding
argument_list|()
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|ISMACR
case|:
if|if
condition|(
name|map
index|[
name|key
index|]
operator|.
name|function
operator|!=
operator|(
name|Function
operator|*
operator|)
name|NULL
condition|)
block|{
specifier|static
name|with_macro_input
argument_list|()
expr_stmt|;
name|char
modifier|*
name|macro
init|=
name|savestring
argument_list|(
operator|(
name|char
operator|*
operator|)
name|map
index|[
name|key
index|]
operator|.
name|function
argument_list|)
decl_stmt|;
name|with_macro_input
argument_list|(
name|macro
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
block|}
comment|/* If we have input pending, then the last command was a prefix      command.  Don't change the state of rl_last_func. */
if|if
condition|(
operator|!
name|rl_pending_input
condition|)
name|rl_last_func
operator|=
name|map
index|[
name|key
index|]
operator|.
name|function
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Hacking Keyboard Macros 		    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Set up to read subsequent input from STRING.    STRING is free ()'ed when we are done with it. */
end_comment

begin_expr_stmt
specifier|static
name|with_macro_input
argument_list|(
argument|string
argument_list|)
name|char
operator|*
name|string
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|static
name|push_executing_macro
argument_list|()
expr_stmt|;
name|push_executing_macro
argument_list|()
expr_stmt|;
name|executing_macro
operator|=
name|string
expr_stmt|;
name|executing_macro_index
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Return the next character available from a macro, or 0 if    there are no macro characters. */
end_comment

begin_function
specifier|static
name|int
name|next_macro_key
parameter_list|()
block|{
if|if
condition|(
operator|!
name|executing_macro
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|executing_macro
index|[
name|executing_macro_index
index|]
condition|)
block|{
specifier|static
name|pop_executing_macro
argument_list|()
expr_stmt|;
name|pop_executing_macro
argument_list|()
expr_stmt|;
return|return
operator|(
name|next_macro_key
argument_list|()
operator|)
return|;
block|}
return|return
operator|(
name|executing_macro
index|[
name|executing_macro_index
operator|++
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Save the currently executing macro on a stack of saved macros. */
end_comment

begin_expr_stmt
specifier|static
name|push_executing_macro
argument_list|()
block|{   struct
name|saved_macro
operator|*
name|saver
block|;
name|saver
operator|=
operator|(
expr|struct
name|saved_macro
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|saved_macro
argument_list|)
argument_list|)
block|;
name|saver
operator|->
name|next
operator|=
name|macro_list
block|;
name|saver
operator|->
name|index
operator|=
name|executing_macro_index
block|;
name|saver
operator|->
name|string
operator|=
name|executing_macro
block|;
name|macro_list
operator|=
name|saver
block|; }
comment|/* Discard the current macro, replacing it with the one    on the top of the stack of saved macros. */
specifier|static
name|pop_executing_macro
argument_list|()
block|{
if|if
condition|(
name|executing_macro
condition|)
name|free
argument_list|(
name|executing_macro
argument_list|)
expr_stmt|;
name|executing_macro
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|executing_macro_index
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|macro_list
condition|)
block|{
name|struct
name|saved_macro
modifier|*
name|disposer
init|=
name|macro_list
decl_stmt|;
name|executing_macro
operator|=
name|macro_list
operator|->
name|string
expr_stmt|;
name|executing_macro_index
operator|=
name|macro_list
operator|->
name|index
expr_stmt|;
name|macro_list
operator|=
name|macro_list
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|disposer
argument_list|)
expr_stmt|;
block|}
end_if

begin_comment
unit|}
comment|/* Add a character to the macro being built. */
end_comment

begin_macro
unit|static
name|add_macro_char
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|int
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|current_macro_index
operator|+
literal|1
operator|>=
name|current_macro_size
condition|)
block|{
if|if
condition|(
operator|!
name|current_macro
condition|)
name|current_macro
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|current_macro_size
operator|=
literal|25
argument_list|)
expr_stmt|;
else|else
name|current_macro
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|current_macro
argument_list|,
name|current_macro_size
operator|+=
literal|25
argument_list|)
expr_stmt|;
block|}
name|current_macro
index|[
name|current_macro_index
operator|++
index|]
operator|=
name|c
expr_stmt|;
name|current_macro
index|[
name|current_macro_index
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Begin defining a keyboard macro.    Keystrokes are recorded as they are executed.    End the definition with rl_end_kbd_macro ().    If a numeric argument was explicitly typed, then append this    definition to the end of the existing macro, and start by    re-executing the existing macro. */
end_comment

begin_macro
name|rl_start_kbd_macro
argument_list|(
argument|ignore1
argument_list|,
argument|ignore2
argument_list|)
end_macro

begin_decl_stmt
name|int
name|ignore1
decl_stmt|,
name|ignore2
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|defining_kbd_macro
condition|)
name|rl_abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|rl_explicit_arg
condition|)
block|{
if|if
condition|(
name|current_macro
condition|)
name|with_macro_input
argument_list|(
name|savestring
argument_list|(
name|current_macro
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|current_macro_index
operator|=
literal|0
expr_stmt|;
name|defining_kbd_macro
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Stop defining a keyboard macro.    A numeric argument says to execute the macro right now,    that many times, counting the definition as the first time. */
end_comment

begin_macro
name|rl_end_kbd_macro
argument_list|(
argument|count
argument_list|,
argument|ignore
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|,
name|ignore
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|defining_kbd_macro
condition|)
name|rl_abort
argument_list|()
expr_stmt|;
name|current_macro_index
operator|-=
operator|(
name|rl_key_sequence_length
operator|-
literal|1
operator|)
expr_stmt|;
name|current_macro
index|[
name|current_macro_index
index|]
operator|=
literal|'\0'
expr_stmt|;
name|defining_kbd_macro
operator|=
literal|0
expr_stmt|;
name|rl_call_last_kbd_macro
argument_list|(
operator|--
name|count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Execute the most recently defined keyboard macro.    COUNT says how many times to execute it. */
end_comment

begin_macro
name|rl_call_last_kbd_macro
argument_list|(
argument|count
argument_list|,
argument|ignore
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|,
name|ignore
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|current_macro
condition|)
name|rl_abort
argument_list|()
expr_stmt|;
while|while
condition|(
name|count
operator|--
condition|)
name|with_macro_input
argument_list|(
name|savestring
argument_list|(
name|current_macro
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Non-zero means do not parse any lines other than comments and    parser directives. */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|parsing_conditionalized_out
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Initializations 			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Initliaze readline (and terminal if not already). */
end_comment

begin_macro
name|rl_initialize
argument_list|()
end_macro

begin_block
block|{
specifier|extern
name|char
modifier|*
name|rl_display_prompt
decl_stmt|;
comment|/* If we have never been called before, initialize the      terminal and data structures. */
if|if
condition|(
operator|!
name|rl_initialized
condition|)
block|{
name|readline_initialize_everything
argument_list|()
expr_stmt|;
name|rl_initialized
operator|++
expr_stmt|;
block|}
comment|/* Initalize the current line information. */
name|rl_point
operator|=
name|rl_end
operator|=
literal|0
expr_stmt|;
name|the_line
operator|=
name|rl_line_buffer
expr_stmt|;
name|the_line
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* We aren't done yet.  We haven't even gotten started yet! */
name|rl_done
operator|=
literal|0
expr_stmt|;
comment|/* Tell the history routines what is going on. */
name|start_using_history
argument_list|()
expr_stmt|;
comment|/* Make the display buffer match the state of the line. */
block|{
specifier|extern
name|char
modifier|*
name|rl_display_prompt
decl_stmt|;
specifier|extern
name|int
name|forced_display
decl_stmt|;
name|rl_on_new_line
argument_list|()
expr_stmt|;
name|rl_display_prompt
operator|=
name|rl_prompt
condition|?
name|rl_prompt
else|:
literal|""
expr_stmt|;
name|forced_display
operator|=
literal|1
expr_stmt|;
block|}
comment|/* No such function typed yet. */
name|rl_last_func
operator|=
operator|(
name|Function
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/* Parsing of key-bindings begins in an enabled state. */
block|{
name|parsing_conditionalized_out
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Initialize the entire state of the world. */
end_comment

begin_macro
name|readline_initialize_everything
argument_list|()
end_macro

begin_block
block|{
comment|/* Find out if we are running in Emacs. */
name|running_in_emacs
operator|=
operator|(
name|char
operator|*
operator|)
name|getenv
argument_list|(
literal|"EMACS"
argument_list|)
expr_stmt|;
comment|/* Allocate data structures. */
if|if
condition|(
operator|!
name|rl_line_buffer
condition|)
name|rl_line_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|rl_line_buffer_len
operator|=
name|DEFAULT_BUFFER_SIZE
argument_list|)
expr_stmt|;
comment|/* Initialize the terminal interface. */
name|init_terminal_io
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* Bind tty characters to readline functions. */
name|readline_default_bindings
argument_list|()
expr_stmt|;
comment|/* Initialize the function names. */
name|rl_initialize_funmap
argument_list|()
expr_stmt|;
comment|/* Read in the init file. */
name|rl_read_init_file
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* If the completion parser's default word break characters haven't      been set yet, then do so now. */
block|{
specifier|extern
name|char
modifier|*
name|rl_completer_word_break_characters
decl_stmt|;
specifier|extern
name|char
modifier|*
name|rl_basic_word_break_characters
decl_stmt|;
if|if
condition|(
name|rl_completer_word_break_characters
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|rl_completer_word_break_characters
operator|=
name|rl_basic_word_break_characters
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* If this system allows us to look at the values of the regular    input editing characters, then bind them to their readline    equivalents. */
end_comment

begin_macro
name|readline_default_bindings
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|TIOCGETP
name|struct
name|sgttyb
name|ttybuff
decl_stmt|;
name|int
name|tty
init|=
name|fileno
argument_list|(
name|rl_instream
argument_list|)
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCGETP
argument_list|,
operator|&
name|ttybuff
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|int
name|erase
init|=
name|ttybuff
operator|.
name|sg_erase
decl_stmt|,
name|kill
init|=
name|ttybuff
operator|.
name|sg_kill
decl_stmt|;
if|if
condition|(
name|erase
operator|!=
operator|-
literal|1
operator|&&
name|keymap
index|[
name|erase
index|]
operator|.
name|type
operator|==
name|ISFUNC
condition|)
name|keymap
index|[
name|erase
index|]
operator|.
name|function
operator|=
name|rl_rubout
expr_stmt|;
if|if
condition|(
name|kill
operator|!=
operator|-
literal|1
operator|&&
name|keymap
index|[
name|kill
index|]
operator|.
name|type
operator|==
name|ISFUNC
condition|)
name|keymap
index|[
name|kill
index|]
operator|.
name|function
operator|=
name|rl_unix_line_discard
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TIOCGLTC
block|{
name|struct
name|ltchars
name|lt
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCGLTC
argument_list|,
operator|&
name|lt
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|int
name|erase
init|=
name|lt
operator|.
name|t_werasc
decl_stmt|,
name|nextc
init|=
name|lt
operator|.
name|t_lnextc
decl_stmt|;
if|if
condition|(
name|erase
operator|!=
operator|-
literal|1
operator|&&
name|keymap
index|[
name|erase
index|]
operator|.
name|type
operator|==
name|ISFUNC
condition|)
name|keymap
index|[
name|erase
index|]
operator|.
name|function
operator|=
name|rl_unix_word_rubout
expr_stmt|;
if|if
condition|(
name|nextc
operator|!=
operator|-
literal|1
operator|&&
name|keymap
index|[
name|nextc
index|]
operator|.
name|type
operator|==
name|ISFUNC
condition|)
name|keymap
index|[
name|nextc
index|]
operator|.
name|function
operator|=
name|rl_quoted_insert
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* TIOCGLTC */
endif|#
directive|endif
comment|/*  TIOCGETP */
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Numeric Arguments			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Handle C-u style numeric args, as well as M--, and M-digits. */
end_comment

begin_comment
comment|/* Add the current digit to the argument in progress. */
end_comment

begin_macro
name|rl_digit_argument
argument_list|(
argument|ignore
argument_list|,
argument|key
argument_list|)
end_macro

begin_decl_stmt
name|int
name|ignore
decl_stmt|,
name|key
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|rl_pending_input
operator|=
name|key
expr_stmt|;
name|rl_digit_loop
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* What to do when you abort reading an argument. */
end_comment

begin_macro
name|rl_discard_argument
argument_list|()
end_macro

begin_block
block|{
name|ding
argument_list|()
expr_stmt|;
name|rl_clear_message
argument_list|()
expr_stmt|;
name|rl_init_argument
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Create a default argument. */
end_comment

begin_macro
name|rl_init_argument
argument_list|()
end_macro

begin_block
block|{
name|rl_numeric_arg
operator|=
name|arg_sign
operator|=
literal|1
expr_stmt|;
name|rl_explicit_arg
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/* C-u, universal argument.  Multiply the current argument by 4.    Read a key.  If the key has nothing to do with arguments, then    dispatch on it.  If the key is the abort character then abort. */
end_comment

begin_macro
name|rl_universal_argument
argument_list|()
end_macro

begin_block
block|{
name|rl_numeric_arg
operator|*=
literal|4
expr_stmt|;
name|rl_digit_loop
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|rl_digit_loop
argument_list|()
end_macro

begin_block
block|{
name|int
name|key
decl_stmt|,
name|c
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|rl_message
argument_list|(
literal|"(arg: %d) "
argument_list|,
name|arg_sign
operator|*
name|rl_numeric_arg
argument_list|)
expr_stmt|;
name|key
operator|=
name|c
operator|=
name|rl_read_key
argument_list|()
expr_stmt|;
if|if
condition|(
name|keymap
index|[
name|c
index|]
operator|.
name|type
operator|==
name|ISFUNC
operator|&&
name|keymap
index|[
name|c
index|]
operator|.
name|function
operator|==
name|rl_universal_argument
condition|)
block|{
name|rl_numeric_arg
operator|*=
literal|4
expr_stmt|;
continue|continue;
block|}
name|c
operator|=
name|UNMETA
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|numeric
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|rl_explicit_arg
condition|)
name|rl_numeric_arg
operator|=
operator|(
name|rl_numeric_arg
operator|*
literal|10
operator|)
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
else|else
name|rl_numeric_arg
operator|=
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
name|rl_explicit_arg
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|c
operator|==
literal|'-'
operator|&&
operator|!
name|rl_explicit_arg
condition|)
block|{
name|rl_numeric_arg
operator|=
literal|1
expr_stmt|;
name|arg_sign
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|rl_clear_message
argument_list|()
expr_stmt|;
name|rl_dispatch
argument_list|(
name|key
argument_list|,
name|keymap
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Display stuff				    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* This is the stuff that is hard for me.  I never seem to write good    display routines in C.  Let's see how I do this time. */
end_comment

begin_comment
comment|/* (PWP) Well... Good for a simple line updater, but totally ignores    the problems of input lines longer than the screen width.     update_line and the code that calls it makes a multiple line,    automatically wrapping line update.  Carefull attention needs    to be paid to the vertical position variables.     handling of terminals with autowrap on (incl. DEC braindamage)    could be improved a bit.  Right now I just cheat and decrement    screenwidth by one. */
end_comment

begin_comment
comment|/* Keep two buffers; one which reflects the current contents of the    screen, and the other to draw what we think the new contents should    be.  Then compare the buffers, and make whatever changes to the    screen itself that we should.  Finally, make the buffer that we    just drew into be the one which reflects the current contents of the    screen, and place the cursor where it belongs.     Commands that want to can fix the display themselves, and then let    this function know that the display has been fixed by setting the    RL_DISPLAY_FIXED variable.  This is good for efficiency. */
end_comment

begin_comment
comment|/* Termcap variables: */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|term_up
decl_stmt|,
modifier|*
name|term_dc
decl_stmt|,
modifier|*
name|term_cr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|screenheight
decl_stmt|,
name|screenwidth
decl_stmt|,
name|terminal_can_insert
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* What YOU turn on when you have handled all redisplay yourself. */
end_comment

begin_decl_stmt
name|int
name|rl_display_fixed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The visible cursor position.  If you print some text, adjust this. */
end_comment

begin_decl_stmt
name|int
name|last_c_pos
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|last_v_pos
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The last left edge of text that was displayed.  This is used when    doing horizontal scrolling.  It shifts in thirds of a screenwidth. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|last_lmargin
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The line display buffers.  One is the line currently displayed on    the screen.  The other is the line about to be displayed. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|visible_line
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|invisible_line
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of lines currently on screen minus 1. */
end_comment

begin_decl_stmt
name|int
name|vis_botlin
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A buffer for `modeline' messages. */
end_comment

begin_decl_stmt
name|char
name|msg_buf
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero forces the redisplay even if we thought it was unnecessary. */
end_comment

begin_decl_stmt
name|int
name|forced_display
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The stuff that gets printed out before the actual text of the line.    This is usually pointing to rl_prompt. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|rl_display_prompt
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default and initial buffer size.  Can grow. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|line_size
init|=
literal|1024
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means to always use horizontal scrolling in line display. */
end_comment

begin_decl_stmt
name|int
name|horizontal_scroll_mode
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* I really disagree with this, but my boss (among others) insists that we    support compilers that don't work.  I don't think we are gaining by doing    so; what is the advantage in producing better code if we can't use it? */
end_comment

begin_comment
comment|/* The following two declarations belong inside the    function block, not here. */
end_comment

begin_function_decl
specifier|static
name|void
name|move_cursor_relative
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|output_some_chars
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Basic redisplay algorithm. */
end_comment

begin_macro
name|rl_redisplay
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|in
decl_stmt|,
name|out
decl_stmt|,
name|c
decl_stmt|,
name|linenum
decl_stmt|;
specifier|register
name|char
modifier|*
name|line
init|=
name|invisible_line
decl_stmt|;
name|int
name|c_pos
init|=
literal|0
decl_stmt|;
name|int
name|inv_botlin
init|=
literal|0
decl_stmt|;
comment|/* Number of lines in newly drawn buffer. */
specifier|extern
name|int
name|readline_echoing_p
decl_stmt|;
if|if
condition|(
operator|!
name|readline_echoing_p
condition|)
return|return;
if|if
condition|(
operator|!
name|rl_display_prompt
condition|)
name|rl_display_prompt
operator|=
literal|""
expr_stmt|;
if|if
condition|(
operator|!
name|invisible_line
condition|)
block|{
name|visible_line
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|line_size
argument_list|)
expr_stmt|;
name|invisible_line
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|line_size
argument_list|)
expr_stmt|;
name|line
operator|=
name|invisible_line
expr_stmt|;
for|for
control|(
name|in
operator|=
literal|0
init|;
name|in
operator|<
name|line_size
condition|;
name|in
operator|++
control|)
block|{
name|visible_line
index|[
name|in
index|]
operator|=
literal|0
expr_stmt|;
name|invisible_line
index|[
name|in
index|]
operator|=
literal|1
expr_stmt|;
block|}
name|rl_on_new_line
argument_list|()
expr_stmt|;
block|}
comment|/* Draw the line into the buffer. */
name|c_pos
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Mark the line as modified or not.  We only do this for history      lines. */
name|out
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|current_history
argument_list|()
operator|&&
name|rl_undo_list
condition|)
block|{
name|line
index|[
name|out
operator|++
index|]
operator|=
literal|'*'
expr_stmt|;
name|line
index|[
name|out
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* If someone thought that the redisplay was handled, but the currently      visible line has a different modification state than the one about      to become visible, then correct the callers misconception. */
if|if
condition|(
name|visible_line
index|[
literal|0
index|]
operator|!=
name|invisible_line
index|[
literal|0
index|]
condition|)
name|rl_display_fixed
operator|=
literal|0
expr_stmt|;
name|strncpy
argument_list|(
name|line
operator|+
name|out
argument_list|,
name|rl_display_prompt
argument_list|,
name|strlen
argument_list|(
name|rl_display_prompt
argument_list|)
argument_list|)
expr_stmt|;
name|out
operator|+=
name|strlen
argument_list|(
name|rl_display_prompt
argument_list|)
expr_stmt|;
name|line
index|[
name|out
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|in
operator|=
literal|0
init|;
name|in
operator|<
name|rl_end
condition|;
name|in
operator|++
control|)
block|{
name|c
operator|=
name|the_line
index|[
name|in
index|]
expr_stmt|;
if|if
condition|(
name|out
operator|+
literal|1
operator|>=
name|line_size
condition|)
block|{
name|line_size
operator|*=
literal|2
expr_stmt|;
name|visible_line
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|visible_line
argument_list|,
name|line_size
argument_list|)
expr_stmt|;
name|invisible_line
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|invisible_line
argument_list|,
name|line_size
argument_list|)
expr_stmt|;
name|line
operator|=
name|invisible_line
expr_stmt|;
block|}
if|if
condition|(
name|in
operator|==
name|rl_point
condition|)
name|c_pos
operator|=
name|out
expr_stmt|;
if|if
condition|(
name|c
operator|>
literal|127
condition|)
block|{
name|line
index|[
name|out
operator|++
index|]
operator|=
literal|'M'
expr_stmt|;
name|line
index|[
name|out
operator|++
index|]
operator|=
literal|'-'
expr_stmt|;
name|line
index|[
name|out
operator|++
index|]
operator|=
name|c
operator|-
literal|128
expr_stmt|;
block|}
define|#
directive|define
name|DISPLAY_TABS
ifdef|#
directive|ifdef
name|DISPLAY_TABS
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
block|{
specifier|register
name|int
name|newout
init|=
operator|(
name|out
operator||
operator|(
name|int
operator|)
literal|7
operator|)
operator|+
literal|1
decl_stmt|;
while|while
condition|(
name|out
operator|<
name|newout
condition|)
name|line
index|[
name|out
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
block|}
endif|#
directive|endif
elseif|else
if|if
condition|(
name|c
operator|<
literal|32
condition|)
block|{
name|line
index|[
name|out
operator|++
index|]
operator|=
literal|'C'
expr_stmt|;
name|line
index|[
name|out
operator|++
index|]
operator|=
literal|'-'
expr_stmt|;
name|line
index|[
name|out
operator|++
index|]
operator|=
name|c
operator|+
literal|64
expr_stmt|;
block|}
else|else
name|line
index|[
name|out
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
name|line
index|[
name|out
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|c_pos
operator|<
literal|0
condition|)
name|c_pos
operator|=
name|out
expr_stmt|;
comment|/* PWP: now is when things get a bit hairy.  The visible and invisible      line buffers are really multiple lines, which would wrap every      (screenwidth - 1) characters.  Go through each in turn, finding      the changed region and updating it.  The line order is top to bottom. */
comment|/* If we can move the cursor up and down, then use multiple lines,      otherwise, let long lines display in a single terminal line, and      horizontally scroll it. */
if|if
condition|(
operator|!
name|horizontal_scroll_mode
operator|&&
name|term_up
operator|&&
operator|*
name|term_up
condition|)
block|{
name|int
name|total_screen_chars
init|=
operator|(
name|screenwidth
operator|*
name|screenheight
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|rl_display_fixed
operator|||
name|forced_display
condition|)
block|{
name|forced_display
operator|=
literal|0
expr_stmt|;
comment|/* If we have more than a screenful of material to display, then 	     only display a screenful.  We should display the last screen, 	     not the first.  I'll fix this in a minute. */
if|if
condition|(
name|out
operator|>=
name|total_screen_chars
condition|)
name|out
operator|=
name|total_screen_chars
operator|-
literal|1
expr_stmt|;
comment|/* Number of screen lines to display. */
name|inv_botlin
operator|=
name|out
operator|/
name|screenwidth
expr_stmt|;
comment|/* For each line in the buffer, do the updating display. */
for|for
control|(
name|linenum
operator|=
literal|0
init|;
name|linenum
operator|<=
name|inv_botlin
condition|;
name|linenum
operator|++
control|)
name|update_line
argument_list|(
name|linenum
operator|>
name|vis_botlin
condition|?
literal|""
else|:
operator|&
name|visible_line
index|[
name|linenum
operator|*
name|screenwidth
index|]
argument_list|,
operator|&
name|invisible_line
index|[
name|linenum
operator|*
name|screenwidth
index|]
argument_list|,
name|linenum
argument_list|)
expr_stmt|;
comment|/* We may have deleted some lines.  If so, clear the left over 	     blank ones at the bottom out. */
if|if
condition|(
name|vis_botlin
operator|>
name|inv_botlin
condition|)
block|{
name|char
modifier|*
name|tt
decl_stmt|;
for|for
control|(
init|;
name|linenum
operator|<=
name|vis_botlin
condition|;
name|linenum
operator|++
control|)
block|{
name|tt
operator|=
operator|&
name|visible_line
index|[
name|linenum
operator|*
name|screenwidth
index|]
expr_stmt|;
name|move_vert
argument_list|(
name|linenum
argument_list|)
expr_stmt|;
name|move_cursor_relative
argument_list|(
literal|0
argument_list|,
name|tt
argument_list|)
expr_stmt|;
name|clear_to_eol
argument_list|(
operator|(
name|linenum
operator|==
name|vis_botlin
operator|)
condition|?
name|strlen
argument_list|(
name|tt
argument_list|)
else|:
name|screenwidth
argument_list|)
expr_stmt|;
block|}
block|}
name|vis_botlin
operator|=
name|inv_botlin
expr_stmt|;
comment|/* Move the cursor where it should be. */
name|move_vert
argument_list|(
name|c_pos
operator|/
name|screenwidth
argument_list|)
expr_stmt|;
name|move_cursor_relative
argument_list|(
name|c_pos
operator|%
name|screenwidth
argument_list|,
operator|&
name|invisible_line
index|[
operator|(
name|c_pos
operator|/
name|screenwidth
operator|)
operator|*
name|screenwidth
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/* Do horizontal scrolling. */
block|{
name|int
name|lmargin
decl_stmt|;
comment|/* Always at top line. */
name|last_v_pos
operator|=
literal|0
expr_stmt|;
comment|/* If the display position of the cursor would be off the edge 	 of the screen, start the display of this line at an offset that 	 leaves the cursor on the screen. */
if|if
condition|(
name|c_pos
operator|-
name|last_lmargin
operator|>
name|screenwidth
operator|-
literal|2
condition|)
name|lmargin
operator|=
operator|(
name|c_pos
operator|/
operator|(
name|screenwidth
operator|/
literal|3
operator|)
operator|-
literal|2
operator|)
operator|*
operator|(
name|screenwidth
operator|/
literal|3
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c_pos
operator|-
name|last_lmargin
operator|<
literal|1
condition|)
name|lmargin
operator|=
operator|(
operator|(
name|c_pos
operator|-
literal|1
operator|)
operator|/
operator|(
name|screenwidth
operator|/
literal|3
operator|)
operator|)
operator|*
operator|(
name|screenwidth
operator|/
literal|3
operator|)
expr_stmt|;
else|else
name|lmargin
operator|=
name|last_lmargin
expr_stmt|;
comment|/* If the first character on the screen isn't the first character 	 in the display line, indicate this with a special character. */
if|if
condition|(
name|lmargin
operator|>
literal|0
condition|)
name|line
index|[
name|lmargin
index|]
operator|=
literal|'<'
expr_stmt|;
if|if
condition|(
name|lmargin
operator|+
name|screenwidth
operator|<
name|out
condition|)
name|line
index|[
name|lmargin
operator|+
name|screenwidth
operator|-
literal|1
index|]
operator|=
literal|'>'
expr_stmt|;
if|if
condition|(
operator|!
name|rl_display_fixed
operator|||
name|forced_display
operator|||
name|lmargin
operator|!=
name|last_lmargin
condition|)
block|{
name|forced_display
operator|=
literal|0
expr_stmt|;
name|update_line
argument_list|(
operator|&
name|visible_line
index|[
name|last_lmargin
index|]
argument_list|,
operator|&
name|invisible_line
index|[
name|lmargin
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|move_cursor_relative
argument_list|(
name|c_pos
operator|-
name|lmargin
argument_list|,
operator|&
name|invisible_line
index|[
name|lmargin
index|]
argument_list|)
expr_stmt|;
name|last_lmargin
operator|=
name|lmargin
expr_stmt|;
block|}
block|}
name|fflush
argument_list|(
name|out_stream
argument_list|)
expr_stmt|;
comment|/* Swap visible and non-visible lines. */
block|{
name|char
modifier|*
name|temp
init|=
name|visible_line
decl_stmt|;
name|visible_line
operator|=
name|invisible_line
expr_stmt|;
name|invisible_line
operator|=
name|temp
expr_stmt|;
name|rl_display_fixed
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* PWP: update_line() is based on finding the middle difference of each    line on the screen; vis:  			     /old first difference 	/beginning of line   |              /old last same       /old EOL 	v		     v              v                    v old:	eddie> Oh, my little gruntle-buggy is to me, as lurgid as new:	eddie> Oh, my little buggy says to me, as lurgid as 	^		     ^        ^			   ^ 	\beginning of line   |        \new last same	   \new end of line 			     \new first difference     All are character pointers for the sake of speed.  Special cases for    no differences, as well as for end of line additions must be handeled.     Could be made even smarter, but this works well enough */
end_comment

begin_expr_stmt
specifier|static
name|update_line
argument_list|(
name|old
argument_list|,
name|new
argument_list|,
name|current_line
argument_list|)
specifier|register
name|char
operator|*
name|old
operator|,
operator|*
name|new
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|current_line
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|ofd
decl_stmt|,
modifier|*
name|ols
decl_stmt|,
modifier|*
name|oe
decl_stmt|,
modifier|*
name|nfd
decl_stmt|,
modifier|*
name|nls
decl_stmt|,
modifier|*
name|ne
decl_stmt|;
name|int
name|lendiff
decl_stmt|,
name|wsatend
decl_stmt|;
comment|/* Find first difference. */
for|for
control|(
name|ofd
operator|=
name|old
operator|,
name|nfd
operator|=
name|new
init|;
operator|(
name|ofd
operator|-
name|old
operator|<
name|screenwidth
operator|)
operator|&&
operator|*
name|ofd
operator|&&
operator|(
operator|*
name|ofd
operator|==
operator|*
name|nfd
operator|)
condition|;
name|ofd
operator|++
operator|,
name|nfd
operator|++
control|)
empty_stmt|;
comment|/* Move to the end of the screen line. */
for|for
control|(
name|oe
operator|=
name|ofd
init|;
operator|(
operator|(
name|oe
operator|-
name|old
operator|)
operator|<
name|screenwidth
operator|)
operator|&&
operator|*
name|oe
condition|;
name|oe
operator|++
control|)
empty_stmt|;
for|for
control|(
name|ne
operator|=
name|nfd
init|;
operator|(
operator|(
name|ne
operator|-
name|new
operator|)
operator|<
name|screenwidth
operator|)
operator|&&
operator|*
name|ne
condition|;
name|ne
operator|++
control|)
empty_stmt|;
comment|/* If no difference, continue to next line. */
if|if
condition|(
name|ofd
operator|==
name|oe
operator|&&
name|nfd
operator|==
name|ne
condition|)
return|return;
name|wsatend
operator|=
literal|1
expr_stmt|;
comment|/* flag for trailing whitespace */
name|ols
operator|=
name|oe
operator|-
literal|1
expr_stmt|;
comment|/* find last same */
name|nls
operator|=
name|ne
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|ols
operator|==
operator|*
name|nls
operator|)
operator|&&
operator|(
name|ols
operator|>
name|ofd
operator|)
operator|&&
operator|(
name|nls
operator|>
name|nfd
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|ols
operator|!=
literal|' '
condition|)
name|wsatend
operator|=
literal|0
expr_stmt|;
name|ols
operator|--
expr_stmt|;
name|nls
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|wsatend
condition|)
block|{
name|ols
operator|=
name|oe
expr_stmt|;
name|nls
operator|=
name|ne
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|ols
operator|!=
operator|*
name|nls
condition|)
block|{
if|if
condition|(
operator|*
name|ols
condition|)
comment|/* don't step past the NUL */
name|ols
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|nls
condition|)
name|nls
operator|++
expr_stmt|;
block|}
name|move_vert
argument_list|(
name|current_line
argument_list|)
expr_stmt|;
name|move_cursor_relative
argument_list|(
name|ofd
operator|-
name|old
argument_list|,
name|old
argument_list|)
expr_stmt|;
comment|/* if (len (new)> len (old)) */
name|lendiff
operator|=
operator|(
name|nls
operator|-
name|nfd
operator|)
operator|-
operator|(
name|ols
operator|-
name|ofd
operator|)
expr_stmt|;
comment|/* Insert (diff(len(old),len(new)) ch */
if|if
condition|(
name|lendiff
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|terminal_can_insert
condition|)
block|{
specifier|extern
name|char
modifier|*
name|term_IC
decl_stmt|;
comment|/* Sometimes it is cheaper to print the characters rather than 	     use the terminal's capabilities. */
if|if
condition|(
operator|(
literal|2
operator|*
operator|(
name|ne
operator|-
name|nfd
operator|)
operator|)
operator|<
name|lendiff
operator|&&
operator|(
operator|!
name|term_IC
operator|||
operator|!
operator|*
name|term_IC
operator|)
condition|)
block|{
name|output_some_chars
argument_list|(
name|nfd
argument_list|,
operator|(
name|ne
operator|-
name|nfd
operator|)
argument_list|)
expr_stmt|;
name|last_c_pos
operator|+=
operator|(
name|ne
operator|-
name|nfd
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|ols
condition|)
block|{
name|start_insert
argument_list|(
name|lendiff
argument_list|)
expr_stmt|;
name|output_some_chars
argument_list|(
name|nfd
argument_list|,
name|lendiff
argument_list|)
expr_stmt|;
name|last_c_pos
operator|+=
name|lendiff
expr_stmt|;
name|end_insert
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* At the end of a line the characters do not have to 		     be "inserted".  They can just be placed on the screen. */
name|output_some_chars
argument_list|(
name|nfd
argument_list|,
name|lendiff
argument_list|)
expr_stmt|;
name|last_c_pos
operator|+=
name|lendiff
expr_stmt|;
block|}
comment|/* Copy (new) chars to screen from first diff to last match. */
if|if
condition|(
operator|(
operator|(
name|nls
operator|-
name|nfd
operator|)
operator|-
name|lendiff
operator|)
operator|>
literal|0
condition|)
block|{
name|output_some_chars
argument_list|(
operator|&
name|nfd
index|[
name|lendiff
index|]
argument_list|,
operator|(
operator|(
name|nls
operator|-
name|nfd
operator|)
operator|-
name|lendiff
operator|)
argument_list|)
expr_stmt|;
name|last_c_pos
operator|+=
operator|(
operator|(
name|nls
operator|-
name|nfd
operator|)
operator|-
name|lendiff
operator|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* cannot insert chars, write to EOL */
name|output_some_chars
argument_list|(
name|nfd
argument_list|,
operator|(
name|ne
operator|-
name|nfd
operator|)
argument_list|)
expr_stmt|;
name|last_c_pos
operator|+=
operator|(
name|ne
operator|-
name|nfd
operator|)
expr_stmt|;
block|}
block|}
else|else
comment|/* Delete characters from line. */
block|{
comment|/* If possible and inexpensive to use terminal deletion, then do so. */
if|if
condition|(
name|term_dc
operator|&&
operator|(
literal|2
operator|*
operator|(
name|ne
operator|-
name|nfd
operator|)
operator|)
operator|>=
operator|(
operator|-
name|lendiff
operator|)
condition|)
block|{
if|if
condition|(
name|lendiff
condition|)
name|delete_chars
argument_list|(
operator|-
name|lendiff
argument_list|)
expr_stmt|;
comment|/* delete (diff) characters */
comment|/* Copy (new) chars to screen from first diff to last match */
if|if
condition|(
operator|(
name|nls
operator|-
name|nfd
operator|)
operator|>
literal|0
condition|)
block|{
name|output_some_chars
argument_list|(
name|nfd
argument_list|,
operator|(
name|nls
operator|-
name|nfd
operator|)
argument_list|)
expr_stmt|;
name|last_c_pos
operator|+=
operator|(
name|nls
operator|-
name|nfd
operator|)
expr_stmt|;
block|}
block|}
comment|/* Otherwise, print over the existing material. */
else|else
block|{
name|output_some_chars
argument_list|(
name|nfd
argument_list|,
operator|(
name|ne
operator|-
name|nfd
operator|)
argument_list|)
expr_stmt|;
name|last_c_pos
operator|+=
operator|(
name|ne
operator|-
name|nfd
operator|)
expr_stmt|;
name|clear_to_eol
argument_list|(
operator|(
name|oe
operator|-
name|old
operator|)
operator|-
operator|(
name|ne
operator|-
name|new
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/* (PWP) tell the update routines that we have moved onto a    new (empty) line. */
end_comment

begin_macro
name|rl_on_new_line
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|visible_line
condition|)
name|visible_line
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|last_c_pos
operator|=
name|last_v_pos
operator|=
literal|0
expr_stmt|;
name|vis_botlin
operator|=
name|last_lmargin
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Actually update the display, period. */
end_comment

begin_macro
name|rl_forced_update_display
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|visible_line
condition|)
block|{
specifier|register
name|char
modifier|*
name|temp
init|=
name|visible_line
decl_stmt|;
while|while
condition|(
operator|*
name|temp
condition|)
operator|*
name|temp
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
name|rl_on_new_line
argument_list|()
expr_stmt|;
name|forced_display
operator|++
expr_stmt|;
name|rl_redisplay
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Move the cursor from last_c_pos to NEW, which are buffer indices.    DATA is the contents of the screen line of interest; i.e., where    the movement is being done. */
end_comment

begin_function
specifier|static
name|void
name|move_cursor_relative
parameter_list|(
name|new
parameter_list|,
name|data
parameter_list|)
name|int
name|new
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|static
name|void
name|output_character_function
parameter_list|()
function_decl|;
comment|/* It may be faster to output a CR, and then move forwards instead      of moving backwards. */
if|if
condition|(
name|new
operator|+
literal|1
operator|<
name|last_c_pos
operator|-
name|new
condition|)
block|{
name|tputs
argument_list|(
name|term_cr
argument_list|,
literal|1
argument_list|,
name|output_character_function
argument_list|)
expr_stmt|;
name|last_c_pos
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|last_c_pos
operator|==
name|new
condition|)
return|return;
if|if
condition|(
name|last_c_pos
operator|<
name|new
condition|)
block|{
comment|/* Move the cursor forward.  We do it by printing the command 	 to move the cursor forward if there is one, else print that 	 portion of the output buffer again.  Which is cheaper? */
comment|/* The above comment is left here for posterity.  It is faster 	 to print one character (non-control) than to print a control 	 sequence telling the terminal to move forward one character. 	 That kind of control is for people who don't know what the 	 data is underneath the cursor. */
ifdef|#
directive|ifdef
name|HACK_TERMCAP_MOTION
specifier|extern
name|char
modifier|*
name|term_forward_char
decl_stmt|;
if|if
condition|(
name|term_forward_char
condition|)
for|for
control|(
name|i
operator|=
name|last_c_pos
init|;
name|i
operator|<
name|new
condition|;
name|i
operator|++
control|)
name|tputs
argument_list|(
name|term_forward_char
argument_list|,
literal|1
argument_list|,
name|output_character_function
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
name|last_c_pos
init|;
name|i
operator|<
name|new
condition|;
name|i
operator|++
control|)
name|putc
argument_list|(
name|data
index|[
name|i
index|]
argument_list|,
name|out_stream
argument_list|)
expr_stmt|;
else|#
directive|else
for|for
control|(
name|i
operator|=
name|last_c_pos
init|;
name|i
operator|<
name|new
condition|;
name|i
operator|++
control|)
name|putc
argument_list|(
name|data
index|[
name|i
index|]
argument_list|,
name|out_stream
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HACK_TERMCAP_MOTION */
block|}
else|else
name|backspace
argument_list|(
name|last_c_pos
operator|-
name|new
argument_list|)
expr_stmt|;
name|last_c_pos
operator|=
name|new
expr_stmt|;
block|}
end_function

begin_comment
comment|/* PWP: move the cursor up or down. */
end_comment

begin_macro
name|move_vert
argument_list|(
argument|to
argument_list|)
end_macro

begin_decl_stmt
name|int
name|to
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|void
name|output_character_function
parameter_list|()
function_decl|;
specifier|register
name|int
name|delta
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|last_v_pos
operator|==
name|to
condition|)
return|return;
if|if
condition|(
name|to
operator|>
name|screenheight
condition|)
return|return;
if|if
condition|(
operator|(
name|delta
operator|=
name|to
operator|-
name|last_v_pos
operator|)
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|delta
condition|;
name|i
operator|++
control|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|out_stream
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|term_cr
argument_list|,
literal|1
argument_list|,
name|output_character_function
argument_list|)
expr_stmt|;
name|last_c_pos
operator|=
literal|0
expr_stmt|;
comment|/* because crlf() will do \r\n */
block|}
else|else
block|{
comment|/* delta< 0 */
if|if
condition|(
name|term_up
operator|&&
operator|*
name|term_up
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|-
name|delta
condition|;
name|i
operator|++
control|)
name|tputs
argument_list|(
name|term_up
argument_list|,
literal|1
argument_list|,
name|output_character_function
argument_list|)
expr_stmt|;
block|}
name|last_v_pos
operator|=
name|to
expr_stmt|;
comment|/* now to is here */
block|}
end_block

begin_comment
comment|/* Physically print C on out_stream.  This is for functions which know    how to optimize the display. */
end_comment

begin_macro
name|rl_show_char
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|int
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|c
operator|>
literal|127
condition|)
block|{
name|fprintf
argument_list|(
name|out_stream
argument_list|,
literal|"M-"
argument_list|)
expr_stmt|;
name|c
operator|-=
literal|128
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DISPLAY_TABS
if|if
condition|(
name|c
operator|<
literal|32
operator|&&
name|c
operator|!=
literal|'\t'
condition|)
else|#
directive|else
if|if
condition|(
name|c
operator|<
literal|32
condition|)
endif|#
directive|endif
block|{
name|c
operator|+=
literal|64
expr_stmt|;
block|}
name|putc
argument_list|(
name|c
argument_list|,
name|out_stream
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|out_stream
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|DISPLAY_TABS
end_ifdef

begin_function
name|int
name|rl_character_len
parameter_list|(
name|c
parameter_list|,
name|pos
parameter_list|)
specifier|register
name|int
name|c
decl_stmt|,
name|pos
decl_stmt|;
block|{
if|if
condition|(
name|c
operator|<
literal|' '
operator|||
name|c
operator|>
literal|126
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
return|return
operator|(
operator|(
operator|(
name|pos
operator||
operator|(
name|int
operator|)
literal|7
operator|)
operator|+
literal|1
operator|)
operator|-
name|pos
operator|)
return|;
else|else
return|return
operator|(
literal|3
operator|)
return|;
block|}
else|else
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
name|int
name|rl_character_len
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
if|if
condition|(
name|c
operator|<
literal|' '
operator|||
name|c
operator|>
literal|126
condition|)
return|return
operator|(
literal|3
operator|)
return|;
else|else
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DISPLAY_TAB */
end_comment

begin_comment
comment|/* How to print things in the "echo-area".  The prompt is treated as a    mini-modeline. */
end_comment

begin_macro
name|rl_message
argument_list|(
argument|string
argument_list|,
argument|arg1
argument_list|,
argument|arg2
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|sprintf
argument_list|(
name|msg_buf
argument_list|,
name|string
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
name|rl_display_prompt
operator|=
name|msg_buf
expr_stmt|;
name|rl_redisplay
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* How to clear things from the "echo-area". */
end_comment

begin_macro
name|rl_clear_message
argument_list|()
end_macro

begin_block
block|{
name|rl_display_prompt
operator|=
name|rl_prompt
expr_stmt|;
name|rl_redisplay
argument_list|()
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Terminal and Termcap			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|term_buffer
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|term_string_buffer
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means this terminal can't really do anything. */
end_comment

begin_decl_stmt
name|int
name|dumb_term
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|PC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|BC
decl_stmt|,
modifier|*
name|UP
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Some strings to control terminal actions.  These are output by tputs (). */
end_comment

begin_decl_stmt
name|char
modifier|*
name|term_goto
decl_stmt|,
modifier|*
name|term_clreol
decl_stmt|,
modifier|*
name|term_cr
decl_stmt|,
modifier|*
name|term_clrpag
decl_stmt|,
modifier|*
name|term_backspace
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|screenwidth
decl_stmt|,
name|screenheight
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero if we determine that the terminal can do character insertion. */
end_comment

begin_decl_stmt
name|int
name|terminal_can_insert
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* How to insert characters. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|term_im
decl_stmt|,
modifier|*
name|term_ei
decl_stmt|,
modifier|*
name|term_ic
decl_stmt|,
modifier|*
name|term_ip
decl_stmt|,
modifier|*
name|term_IC
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* How to delete characters. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|term_dc
decl_stmt|,
modifier|*
name|term_DC
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HACK_TERMCAP_MOTION
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|term_forward_char
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HACK_TERMCAP_MOTION */
end_comment

begin_comment
comment|/* How to go up a line. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|term_up
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Re-initialize the terminal considering that the TERM/TERMCAP variable    has changed. */
end_comment

begin_macro
name|rl_reset_terminal
argument_list|(
argument|terminal_name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|terminal_name
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|init_terminal_io
argument_list|(
name|terminal_name
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|init_terminal_io
argument_list|(
argument|terminal_name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|terminal_name
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|term
init|=
operator|(
name|terminal_name
condition|?
name|terminal_name
else|:
operator|(
name|char
operator|*
operator|)
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
operator|)
decl_stmt|;
name|char
modifier|*
name|tgetstr
argument_list|()
decl_stmt|,
modifier|*
name|buffer
decl_stmt|;
if|if
condition|(
operator|!
name|term_string_buffer
condition|)
name|term_string_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|2048
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|term_buffer
condition|)
name|term_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|2048
argument_list|)
expr_stmt|;
name|buffer
operator|=
name|term_string_buffer
expr_stmt|;
name|term_clrpag
operator|=
name|term_cr
operator|=
name|term_clreol
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|term
condition|)
name|term
operator|=
literal|"dumb"
expr_stmt|;
if|if
condition|(
name|tgetent
argument_list|(
name|term_buffer
argument_list|,
name|term
argument_list|)
operator|<
literal|0
condition|)
block|{
name|dumb_term
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|BC
operator|=
name|tgetstr
argument_list|(
literal|"pc"
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
name|PC
operator|=
name|buffer
condition|?
operator|*
name|buffer
else|:
literal|0
expr_stmt|;
name|term_backspace
operator|=
name|tgetstr
argument_list|(
literal|"le"
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
name|term_cr
operator|=
name|tgetstr
argument_list|(
literal|"cr"
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
name|term_clreol
operator|=
name|tgetstr
argument_list|(
literal|"ce"
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
name|term_clrpag
operator|=
name|tgetstr
argument_list|(
literal|"cl"
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|term_cr
condition|)
name|term_cr
operator|=
literal|"\r"
expr_stmt|;
ifdef|#
directive|ifdef
name|HACK_TERMCAP_MOTION
name|term_forward_char
operator|=
name|tgetstr
argument_list|(
literal|"nd"
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HACK_TERMCAP_MOTION */
name|screenwidth
operator|=
name|tgetnum
argument_list|(
literal|"co"
argument_list|)
expr_stmt|;
if|if
condition|(
name|screenwidth
operator|<=
literal|0
condition|)
name|screenwidth
operator|=
literal|80
expr_stmt|;
name|screenwidth
operator|--
expr_stmt|;
comment|/* PWP: avoid autowrap bugs */
name|screenheight
operator|=
name|tgetnum
argument_list|(
literal|"li"
argument_list|)
expr_stmt|;
if|if
condition|(
name|screenheight
operator|<=
literal|0
condition|)
name|screenheight
operator|=
literal|24
expr_stmt|;
name|term_im
operator|=
name|tgetstr
argument_list|(
literal|"im"
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
name|term_ei
operator|=
name|tgetstr
argument_list|(
literal|"ei"
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
name|term_IC
operator|=
name|tgetstr
argument_list|(
literal|"IC"
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
name|term_ic
operator|=
name|tgetstr
argument_list|(
literal|"ic"
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
name|term_ip
operator|=
name|tgetstr
argument_list|(
literal|"ip"
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
name|term_IC
operator|=
name|tgetstr
argument_list|(
literal|"IC"
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
comment|/* "An application program can assume that the terminal can do       character insertion if *any one of* the capabilities `IC',       `im', `ic' or `ip' is provided." */
ifdef|#
directive|ifdef
name|notdef
comment|/* XXX Circumvent broken code. */
name|terminal_can_insert
operator|=
operator|(
name|term_IC
operator|||
name|term_im
operator|||
name|term_ic
operator|||
name|term_ip
operator|)
expr_stmt|;
endif|#
directive|endif
name|term_up
operator|=
name|tgetstr
argument_list|(
literal|"up"
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
name|term_dc
operator|=
name|tgetstr
argument_list|(
literal|"dc"
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
name|term_DC
operator|=
name|tgetstr
argument_list|(
literal|"DC"
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* A function for the use of tputs () */
end_comment

begin_function
specifier|static
name|void
name|output_character_function
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
name|putc
argument_list|(
name|c
argument_list|,
name|out_stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write COUNT characters from STRING to the output stream. */
end_comment

begin_function
specifier|static
name|void
name|output_some_chars
parameter_list|(
name|string
parameter_list|,
name|count
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|count
decl_stmt|;
block|{
name|fwrite
argument_list|(
name|string
argument_list|,
literal|1
argument_list|,
name|count
argument_list|,
name|out_stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Delete COUNT characters from the display line. */
end_comment

begin_expr_stmt
specifier|static
name|delete_chars
argument_list|(
argument|count
argument_list|)
name|int
name|count
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|count
operator|>
name|screenwidth
condition|)
return|return;
if|if
condition|(
name|term_DC
operator|&&
operator|*
name|term_DC
condition|)
block|{
name|char
modifier|*
name|tgoto
argument_list|()
decl_stmt|,
modifier|*
name|buffer
decl_stmt|;
name|buffer
operator|=
name|tgoto
argument_list|(
name|term_DC
argument_list|,
literal|0
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|buffer
argument_list|,
literal|1
argument_list|,
name|output_character_function
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|term_dc
operator|&&
operator|*
name|term_dc
condition|)
while|while
condition|(
name|count
operator|--
condition|)
name|tputs
argument_list|(
name|term_dc
argument_list|,
literal|1
argument_list|,
name|output_character_function
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Prepare to insert by inserting COUNT blank spaces. */
end_comment

begin_expr_stmt
specifier|static
name|start_insert
argument_list|(
argument|count
argument_list|)
name|int
name|count
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|term_im
operator|&&
operator|*
name|term_im
condition|)
name|tputs
argument_list|(
name|term_im
argument_list|,
literal|1
argument_list|,
name|output_character_function
argument_list|)
expr_stmt|;
if|if
condition|(
name|term_IC
operator|&&
operator|*
name|term_IC
operator|&&
operator|(
name|count
operator|>
literal|1
operator|||
operator|!
name|term_ic
operator|||
operator|!
operator|*
name|term_ic
operator|)
condition|)
block|{
name|char
modifier|*
name|tgoto
argument_list|()
decl_stmt|,
modifier|*
name|buffer
decl_stmt|;
name|buffer
operator|=
name|tgoto
argument_list|(
name|term_IC
argument_list|,
literal|0
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|buffer
argument_list|,
literal|1
argument_list|,
name|output_character_function
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|term_ic
operator|&&
operator|*
name|term_ic
condition|)
while|while
condition|(
name|count
operator|--
condition|)
name|tputs
argument_list|(
name|term_ic
argument_list|,
literal|1
argument_list|,
name|output_character_function
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* We are finished doing our insertion.  Send ending string. */
end_comment

begin_expr_stmt
specifier|static
name|end_insert
argument_list|()
block|{
if|if
condition|(
name|term_ei
operator|&&
operator|*
name|term_ei
condition|)
name|tputs
argument_list|(
name|term_ei
argument_list|,
literal|1
argument_list|,
name|output_character_function
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_comment
comment|/* Move the cursor back. */
end_comment

begin_macro
name|backspace
argument_list|(
argument|count
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|term_backspace
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
name|tputs
argument_list|(
name|term_backspace
argument_list|,
literal|1
argument_list|,
name|output_character_function
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
name|putc
argument_list|(
literal|'\b'
argument_list|,
name|out_stream
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Move to the start of the next line. */
end_comment

begin_macro
name|crlf
argument_list|()
end_macro

begin_block
block|{
name|tputs
argument_list|(
name|term_cr
argument_list|,
literal|1
argument_list|,
name|output_character_function
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|out_stream
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Clear to the end of the line.  COUNT is the minimum    number of character spaces to clear, */
end_comment

begin_macro
name|clear_to_eol
argument_list|(
argument|count
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|term_clreol
condition|)
block|{
name|tputs
argument_list|(
name|term_clreol
argument_list|,
literal|1
argument_list|,
name|output_character_function
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Do one more character space. */
name|count
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|out_stream
argument_list|)
expr_stmt|;
name|backspace
argument_list|(
name|count
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*		      Saving and Restoring the TTY	    	    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NEW_TTY_DRIVER
end_ifdef

begin_comment
comment|/* Standard flags, including ECHO. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|original_tty_flags
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Local mode flags, like LPASS8. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|local_mode_flags
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Terminal characters.  This has C-s and C-q in it. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|tchars
name|original_tchars
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Local special characters.  This has the interrupt characters in it. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ltchars
name|original_ltchars
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We use this to get and set the tty_flags. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sgttyb
name|the_ttybuff
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Put the terminal in CBREAK mode so that we can detect key presses. */
end_comment

begin_expr_stmt
specifier|static
name|rl_prep_terminal
argument_list|()
block|{
name|int
name|tty
operator|=
name|fileno
argument_list|(
name|rl_instream
argument_list|)
block|;
comment|/* We always get the latest tty values.  Maybe stty changed them. */
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCGETP
argument_list|,
operator|&
name|the_ttybuff
argument_list|)
block|;
name|original_tty_flags
operator|=
name|the_ttybuff
operator|.
name|sg_flags
block|;
name|readline_echoing_p
operator|=
operator|(
name|original_tty_flags
operator|&
name|ECHO
operator|)
block|;
comment|/* If this terminal doesn't care how the 8th bit is used,      then we can use it for the meta-key.      We check by seeing if BOTH odd and even parity are allowed. */
if|if
condition|(
operator|(
name|the_ttybuff
operator|.
name|sg_flags
operator|&
operator|(
name|ODDP
operator||
name|EVENP
operator|)
operator|)
operator|==
operator|(
name|ODDP
operator||
name|EVENP
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|PASS8
name|the_ttybuff
operator|.
name|sg_flags
operator||=
name|PASS8
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|TIOCLGET
argument_list|)
operator|&&
name|defined
argument_list|(
name|LPASS8
argument_list|)
block|{
name|int
name|flags
decl_stmt|;
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCLGET
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
name|local_mode_flags
operator|=
name|flags
expr_stmt|;
name|flags
operator||=
name|LPASS8
expr_stmt|;
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCLSET
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
unit|}
ifdef|#
directive|ifdef
name|TIOCGETC
end_ifdef

begin_decl_stmt
unit|{
name|struct
name|tchars
name|temp
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCGETC
argument_list|,
operator|&
name|original_tchars
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|bcopy
argument_list|(
operator|&
name|original_tchars
argument_list|,
operator|&
name|temp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tchars
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Get rid of C-s and C-q.        We remember the value of startc (C-q) so that if the terminal is in        xoff state, the user can xon it by pressing that character. */
end_comment

begin_expr_stmt
name|xon_char
operator|=
name|temp
operator|.
name|t_startc
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|temp
operator|.
name|t_stopc
operator|=
operator|-
literal|1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|temp
operator|.
name|t_startc
operator|=
operator|-
literal|1
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* If there is an XON character, bind it to restart the output. */
end_comment

begin_if
if|if
condition|(
name|xon_char
operator|!=
operator|-
literal|1
condition|)
name|rl_bind_key
argument_list|(
name|xon_char
argument_list|,
name|rl_restart_output
argument_list|)
expr_stmt|;
end_if

begin_comment
comment|/* If there is an EOF char, bind eof_char to it. */
end_comment

begin_if
if|if
condition|(
name|temp
operator|.
name|t_eofc
operator|!=
operator|-
literal|1
condition|)
name|eof_char
operator|=
name|temp
operator|.
name|t_eofc
expr_stmt|;
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|NEVER
end_ifdef

begin_comment
comment|/* Get rid of C-\ and C-c. */
end_comment

begin_expr_stmt
name|temp
operator|.
name|t_intrc
operator|=
name|temp
operator|.
name|t_quitc
operator|=
operator|-
literal|1
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCSETC
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_comment
comment|/* TIOCGETC */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TIOCGLTC
end_ifdef

begin_decl_stmt
unit|{
name|struct
name|ltchars
name|temp
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCGLTC
argument_list|,
operator|&
name|original_ltchars
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|bcopy
argument_list|(
operator|&
name|original_ltchars
argument_list|,
operator|&
name|temp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ltchars
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Make the interrupt keys go away.  Just enough to make people happy. */
end_comment

begin_expr_stmt
name|temp
operator|.
name|t_dsuspc
operator|=
operator|-
literal|1
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* C-y */
end_comment

begin_expr_stmt
name|temp
operator|.
name|t_lnextc
operator|=
operator|-
literal|1
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* C-v */
end_comment

begin_expr_stmt
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCSLTC
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_comment
comment|/* TIOCGLTC */
end_comment

begin_expr_stmt
unit|the_ttybuff
operator|.
name|sg_flags
operator|&=
operator|~
name|ECHO
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|the_ttybuff
operator|.
name|sg_flags
operator||=
name|CBREAK
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCSETN
argument_list|,
operator|&
name|the_ttybuff
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/* Restore the terminal to its original state. */
end_comment

begin_macro
unit|static
name|rl_deprep_terminal
argument_list|()
end_macro

begin_block
block|{
name|int
name|tty
init|=
name|fileno
argument_list|(
name|rl_instream
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TIOCLGET
argument_list|)
operator|&&
name|defined
argument_list|(
name|LPASS8
argument_list|)
if|if
condition|(
operator|(
name|the_ttybuff
operator|.
name|sg_flags
operator|&
operator|(
name|ODDP
operator||
name|EVENP
operator|)
operator|)
operator|==
operator|(
name|ODDP
operator||
name|EVENP
operator|)
condition|)
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCLSET
argument_list|,
operator|&
name|local_mode_flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TIOCSLTC
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCSLTC
argument_list|,
operator|&
name|original_ltchars
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TIOCSETC
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCSETC
argument_list|,
operator|&
name|original_tchars
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|the_ttybuff
operator|.
name|sg_flags
operator|=
name|original_tty_flags
expr_stmt|;
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCSETN
argument_list|,
operator|&
name|the_ttybuff
argument_list|)
expr_stmt|;
name|readline_echoing_p
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !defined (NEW_TTY_DRIVER) */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|termio
name|otio
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|rl_prep_terminal
argument_list|()
block|{
name|int
name|tty
operator|=
name|fileno
argument_list|(
name|rl_instream
argument_list|)
block|;   struct
name|termio
name|tio
block|;
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TCGETA
argument_list|,
operator|&
name|tio
argument_list|)
block|;
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TCGETA
argument_list|,
operator|&
name|otio
argument_list|)
block|;
name|readline_echoing_p
operator|=
operator|(
name|tio
operator|.
name|c_lflag
operator|&
name|ECHO
operator|)
block|;
name|tio
operator|.
name|c_lflag
operator|&=
operator|~
operator|(
name|ICANON
operator||
name|ECHO
operator|)
block|;
name|tio
operator|.
name|c_iflag
operator|&=
operator|~
operator|(
name|IXON
operator||
name|ISTRIP
operator||
name|INPCK
operator|)
block|;
ifndef|#
directive|ifndef
name|HANDLE_SIGNALS
name|tio
operator|.
name|c_lflag
operator|&=
operator|~
name|ISIG
block|;
endif|#
directive|endif
name|tio
operator|.
name|c_cc
index|[
name|VEOF
index|]
operator|=
literal|1
block|;
comment|/* really: MIN */
name|tio
operator|.
name|c_cc
index|[
name|VEOL
index|]
operator|=
literal|0
block|;
comment|/* really: TIME */
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TCSETAW
argument_list|,
operator|&
name|tio
argument_list|)
block|; }
specifier|static
name|rl_deprep_terminal
argument_list|()
block|{
name|int
name|tty
operator|=
name|fileno
argument_list|(
name|rl_instream
argument_list|)
block|;
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TCSETAW
argument_list|,
operator|&
name|otio
argument_list|)
block|; }
endif|#
directive|endif
comment|/* NEW_TTY_DRIVER */
comment|/* **************************************************************** */
comment|/*								    */
comment|/*			Utility Functions			    */
comment|/*								    */
comment|/* **************************************************************** */
comment|/* Return 0 if C is not a member of the class of characters that belong    in words, or 1 if it is. */
name|int
name|allow_pathname_alphabetic_chars
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|pathname_alphabetic_chars
init|=
literal|"/-_=~.#$"
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|alphabetic
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
if|if
condition|(
name|pure_alphabetic
argument_list|(
name|c
argument_list|)
operator|||
operator|(
name|numeric
argument_list|(
name|c
argument_list|)
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|allow_pathname_alphabetic_chars
condition|)
return|return
operator|(
operator|(
name|int
operator|)
name|rindex
argument_list|(
name|pathname_alphabetic_chars
argument_list|,
name|c
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if C is a numeric character. */
end_comment

begin_function
name|int
name|numeric
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
return|return
operator|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Ring the terminal bell. */
end_comment

begin_function
name|int
name|ding
parameter_list|()
block|{
if|if
condition|(
name|readline_echoing_p
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\007"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* How to abort things. */
end_comment

begin_macro
name|rl_abort
argument_list|()
end_macro

begin_block
block|{
name|ding
argument_list|()
expr_stmt|;
name|rl_clear_message
argument_list|()
expr_stmt|;
name|rl_init_argument
argument_list|()
expr_stmt|;
name|rl_pending_input
operator|=
literal|0
expr_stmt|;
name|defining_kbd_macro
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|executing_macro
condition|)
name|pop_executing_macro
argument_list|()
expr_stmt|;
name|longjmp
argument_list|(
name|readline_top_level
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Return a copy of the string between FROM and TO.    FROM is inclusive, TO is not. */
end_comment

begin_function
name|char
modifier|*
name|rl_copy
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|)
name|int
name|from
decl_stmt|,
name|to
decl_stmt|;
block|{
specifier|register
name|int
name|length
decl_stmt|;
name|char
modifier|*
name|copy
decl_stmt|;
comment|/* Fix it if the caller is confused. */
if|if
condition|(
name|from
operator|>
name|to
condition|)
block|{
name|int
name|t
init|=
name|from
decl_stmt|;
name|from
operator|=
name|to
expr_stmt|;
name|to
operator|=
name|t
expr_stmt|;
block|}
name|length
operator|=
name|to
operator|-
name|from
expr_stmt|;
name|copy
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
name|length
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|copy
argument_list|,
name|the_line
operator|+
name|from
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|copy
index|[
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|copy
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Insert and Delete			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Insert a string of text into the line at point.  This is the only    way that you should do insertion.  rl_insert () calls this    function. */
end_comment

begin_macro
name|rl_insert_text
argument_list|(
argument|string
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|int
name|doing_an_undo
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|l
init|=
name|strlen
argument_list|(
name|string
argument_list|)
decl_stmt|;
while|while
condition|(
name|rl_end
operator|+
name|l
operator|>=
name|rl_line_buffer_len
condition|)
block|{
name|rl_line_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|rl_line_buffer
argument_list|,
name|rl_line_buffer_len
operator|+=
name|DEFAULT_BUFFER_SIZE
argument_list|)
expr_stmt|;
name|the_line
operator|=
name|rl_line_buffer
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|rl_end
init|;
name|i
operator|>=
name|rl_point
condition|;
name|i
operator|--
control|)
name|the_line
index|[
name|i
operator|+
name|l
index|]
operator|=
name|the_line
index|[
name|i
index|]
expr_stmt|;
name|strncpy
argument_list|(
name|the_line
operator|+
name|rl_point
argument_list|,
name|string
argument_list|,
name|l
argument_list|)
expr_stmt|;
comment|/* Remember how to undo this if we aren't undoing something. */
if|if
condition|(
operator|!
name|doing_an_undo
condition|)
block|{
comment|/* If possible and desirable, concatenate the undos. */
if|if
condition|(
operator|(
name|strlen
argument_list|(
name|string
argument_list|)
operator|==
literal|1
operator|)
operator|&&
name|rl_undo_list
operator|&&
operator|(
name|rl_undo_list
operator|->
name|what
operator|==
name|UNDO_INSERT
operator|)
operator|&&
operator|(
name|rl_undo_list
operator|->
name|end
operator|==
name|rl_point
operator|)
operator|&&
operator|(
name|rl_undo_list
operator|->
name|end
operator|-
name|rl_undo_list
operator|->
name|start
operator|<
literal|20
operator|)
condition|)
name|rl_undo_list
operator|->
name|end
operator|++
expr_stmt|;
else|else
name|rl_add_undo
argument_list|(
name|UNDO_INSERT
argument_list|,
name|rl_point
argument_list|,
name|rl_point
operator|+
name|l
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
name|rl_point
operator|+=
name|l
expr_stmt|;
name|rl_end
operator|+=
name|l
expr_stmt|;
name|the_line
index|[
name|rl_end
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Delete the string between FROM and TO.  FROM is    inclusive, TO is not. */
end_comment

begin_macro
name|rl_delete_text
argument_list|(
argument|from
argument_list|,
argument|to
argument_list|)
end_macro

begin_decl_stmt
name|int
name|from
decl_stmt|,
name|to
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|int
name|doing_an_undo
decl_stmt|;
specifier|register
name|char
modifier|*
name|text
decl_stmt|;
comment|/* Fix it if the caller is confused. */
if|if
condition|(
name|from
operator|>
name|to
condition|)
block|{
name|int
name|t
init|=
name|from
decl_stmt|;
name|from
operator|=
name|to
expr_stmt|;
name|to
operator|=
name|t
expr_stmt|;
block|}
name|text
operator|=
name|rl_copy
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|the_line
operator|+
name|from
argument_list|,
name|the_line
operator|+
name|to
argument_list|,
name|rl_end
operator|-
name|to
argument_list|)
expr_stmt|;
comment|/* Remember how to undo this delete. */
if|if
condition|(
operator|!
name|doing_an_undo
condition|)
name|rl_add_undo
argument_list|(
name|UNDO_DELETE
argument_list|,
name|from
argument_list|,
name|to
argument_list|,
name|text
argument_list|)
expr_stmt|;
else|else
name|free
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|rl_end
operator|-=
operator|(
name|to
operator|-
name|from
operator|)
expr_stmt|;
name|the_line
index|[
name|rl_end
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Readline character functions		    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* This is not a gap editor, just a stupid line input routine.  No hair    is involved in writing any of the functions, and none should be. */
end_comment

begin_comment
comment|/* Note that:     rl_end is the place in the string that we would place '\0';    i.e., it is always safe to place '\0' there.     rl_point is the place in the string where the cursor is.  Sometimes    this is the same as rl_end.     Any command that is called interactively receives two arguments.    The first is a count: the numeric arg pased to this command.    The second is the key which invoked this command. */
end_comment

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Movement Commands			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Note that if you `optimize' the display for these functions, you cannot    use said functions in other functions which do not do optimizing display.    I.e., you will have to update the data base for rl_redisplay, and you    might as well let rl_redisplay do that job. */
end_comment

begin_comment
comment|/* Move forward COUNT characters. */
end_comment

begin_macro
name|rl_forward
argument_list|(
argument|count
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|count
operator|<
literal|0
condition|)
name|rl_backward
argument_list|(
operator|-
name|count
argument_list|)
expr_stmt|;
else|else
while|while
condition|(
name|count
condition|)
block|{
ifdef|#
directive|ifdef
name|VI_MODE
if|if
condition|(
name|rl_point
operator|==
operator|(
name|rl_end
operator|-
operator|(
name|rl_editing_mode
operator|==
name|vi_mode
operator|)
operator|)
condition|)
else|#
directive|else
if|if
condition|(
name|rl_point
operator|==
name|rl_end
condition|)
endif|#
directive|endif
block|{
name|ding
argument_list|()
expr_stmt|;
return|return;
block|}
else|else
name|rl_point
operator|++
expr_stmt|;
operator|--
name|count
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Move backward COUNT characters. */
end_comment

begin_macro
name|rl_backward
argument_list|(
argument|count
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|count
operator|<
literal|0
condition|)
name|rl_forward
argument_list|(
operator|-
name|count
argument_list|)
expr_stmt|;
else|else
while|while
condition|(
name|count
condition|)
block|{
if|if
condition|(
operator|!
name|rl_point
condition|)
block|{
name|ding
argument_list|()
expr_stmt|;
return|return;
block|}
else|else
operator|--
name|rl_point
expr_stmt|;
operator|--
name|count
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Move to the beginning of the line. */
end_comment

begin_macro
name|rl_beg_of_line
argument_list|()
end_macro

begin_block
block|{
name|rl_point
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Move to the end of the line. */
end_comment

begin_macro
name|rl_end_of_line
argument_list|()
end_macro

begin_block
block|{
name|rl_point
operator|=
name|rl_end
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Move forward a word.  We do what Emacs does. */
end_comment

begin_macro
name|rl_forward_word
argument_list|(
argument|count
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|c
decl_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
name|rl_backward_word
argument_list|(
operator|-
name|count
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|count
condition|)
block|{
if|if
condition|(
name|rl_point
operator|==
name|rl_end
condition|)
return|return;
comment|/* If we are not in a word, move forward until we are in one. 	 Then, move forward until we hit a non-alphabetic character. */
name|c
operator|=
name|the_line
index|[
name|rl_point
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|alphabetic
argument_list|(
name|c
argument_list|)
condition|)
block|{
while|while
condition|(
operator|++
name|rl_point
operator|<
name|rl_end
condition|)
block|{
name|c
operator|=
name|the_line
index|[
name|rl_point
index|]
expr_stmt|;
if|if
condition|(
name|alphabetic
argument_list|(
name|c
argument_list|)
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|rl_point
operator|==
name|rl_end
condition|)
return|return;
while|while
condition|(
operator|++
name|rl_point
operator|<
name|rl_end
condition|)
block|{
name|c
operator|=
name|the_line
index|[
name|rl_point
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|alphabetic
argument_list|(
name|c
argument_list|)
condition|)
break|break;
block|}
operator|--
name|count
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Move backward a word.  We do what Emacs does. */
end_comment

begin_macro
name|rl_backward_word
argument_list|(
argument|count
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|c
decl_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
name|rl_forward_word
argument_list|(
operator|-
name|count
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|count
condition|)
block|{
if|if
condition|(
operator|!
name|rl_point
condition|)
return|return;
comment|/* Like rl_forward_word (), except that we look at the characters 	 just before point. */
name|c
operator|=
name|the_line
index|[
name|rl_point
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|alphabetic
argument_list|(
name|c
argument_list|)
condition|)
block|{
while|while
condition|(
operator|--
name|rl_point
condition|)
block|{
name|c
operator|=
name|the_line
index|[
name|rl_point
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|alphabetic
argument_list|(
name|c
argument_list|)
condition|)
break|break;
block|}
block|}
while|while
condition|(
name|rl_point
condition|)
block|{
name|c
operator|=
name|the_line
index|[
name|rl_point
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|alphabetic
argument_list|(
name|c
argument_list|)
condition|)
break|break;
else|else
operator|--
name|rl_point
expr_stmt|;
block|}
operator|--
name|count
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Clear the current line.  Numeric argument to C-l does this. */
end_comment

begin_macro
name|rl_refresh_line
argument_list|()
end_macro

begin_block
block|{
name|int
name|curr_line
init|=
name|last_c_pos
operator|/
name|screenwidth
decl_stmt|;
name|move_vert
argument_list|(
name|curr_line
argument_list|)
expr_stmt|;
name|move_cursor_relative
argument_list|(
literal|0
argument_list|,
name|the_line
argument_list|)
expr_stmt|;
comment|/* XXX is this right */
name|rl_forced_update_display
argument_list|()
expr_stmt|;
name|rl_display_fixed
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_comment
comment|/* C-l typed to a line without quoting clears the screen, and then reprints    the prompt and the current input line.  Given a numeric arg, redraw only    the current line. */
end_comment

begin_macro
name|rl_clear_screen
argument_list|()
end_macro

begin_block
block|{
specifier|extern
name|char
modifier|*
name|term_clrpag
decl_stmt|;
specifier|static
name|void
name|output_character_function
parameter_list|()
function_decl|;
if|if
condition|(
name|rl_explicit_arg
condition|)
block|{
name|rl_refresh_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|term_clrpag
condition|)
name|tputs
argument_list|(
name|term_clrpag
argument_list|,
literal|1
argument_list|,
name|output_character_function
argument_list|)
expr_stmt|;
else|else
name|crlf
argument_list|()
expr_stmt|;
name|rl_forced_update_display
argument_list|()
expr_stmt|;
name|rl_display_fixed
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Text commands				    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Insert the character C at the current location, moving point forward. */
end_comment

begin_macro
name|rl_insert
argument_list|(
argument|count
argument_list|,
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|,
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
if|if
condition|(
name|count
operator|<=
literal|0
condition|)
return|return;
comment|/* If we can optimize, then do it.  But don't let people crash      readline because of extra large arguments. */
if|if
condition|(
name|count
operator|>
literal|1
operator|&&
name|count
operator|<
literal|1024
condition|)
block|{
name|string
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|1
operator|+
name|count
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
name|string
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
name|string
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|rl_insert_text
argument_list|(
name|string
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|count
operator|>
literal|1024
condition|)
block|{
name|int
name|descreaser
decl_stmt|;
name|string
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|1024
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|1024
condition|;
name|i
operator|++
control|)
name|string
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
while|while
condition|(
name|count
condition|)
block|{
name|descreaser
operator|=
operator|(
name|count
operator|>
literal|1024
condition|?
literal|1024
else|:
name|count
operator|)
expr_stmt|;
name|string
index|[
name|descreaser
index|]
operator|=
literal|'\0'
expr_stmt|;
name|rl_insert_text
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|count
operator|-=
name|descreaser
expr_stmt|;
block|}
return|return;
block|}
comment|/* We are inserting a single character.      If there is pending input, then make a string of all of the      pending characters that are bound to rl_insert, and insert      them all. */
if|if
condition|(
name|any_typein
condition|)
block|{
name|int
name|slen
decl_stmt|,
name|key
init|=
literal|0
decl_stmt|,
name|t
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|string
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|ibuffer_len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|string
index|[
name|i
operator|++
index|]
operator|=
name|c
expr_stmt|;
while|while
condition|(
operator|(
name|key
operator|=
name|rl_get_char
argument_list|()
operator|)
operator|!=
operator|-
literal|2
operator|&&
operator|(
name|keymap
index|[
name|key
index|]
operator|.
name|type
operator|==
name|ISFUNC
operator|&&
name|keymap
index|[
name|key
index|]
operator|.
name|function
operator|==
name|rl_insert
operator|)
condition|)
name|string
index|[
name|i
operator|++
index|]
operator|=
name|key
expr_stmt|;
if|if
condition|(
name|key
operator|!=
operator|-
literal|2
condition|)
name|rl_unget_char
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|string
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|rl_insert_text
argument_list|(
name|string
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|/* Inserting a single character. */
name|string
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|string
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|string
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|rl_insert_text
argument_list|(
name|string
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Insert the next typed character verbatim. */
end_comment

begin_macro
name|rl_quoted_insert
argument_list|(
argument|count
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|c
init|=
name|rl_read_key
argument_list|(
name|in_stream
argument_list|)
decl_stmt|;
name|rl_insert
argument_list|(
name|count
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Insert a tab character. */
end_comment

begin_macro
name|rl_tab_insert
argument_list|(
argument|count
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|rl_insert
argument_list|(
name|count
argument_list|,
literal|'\t'
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|VI_MODE
end_ifdef

begin_comment
comment|/* Non-zero means enter insertion mode. */
end_comment

begin_expr_stmt
specifier|static
name|vi_doing_insert
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* What to do when a NEWLINE is pressed.  We accept the whole line.    KEY is the key that invoked this command.  I guess it could have    meaning in the future. */
end_comment

begin_macro
name|rl_newline
argument_list|(
argument|count
argument_list|,
argument|key
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|rl_done
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|VI_MODE
block|{
if|if
condition|(
name|vi_doing_insert
condition|)
block|{
name|rl_end_undo_group
argument_list|()
expr_stmt|;
name|vi_doing_insert
operator|=
literal|0
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* VI_MODE */
if|if
condition|(
name|readline_echoing_p
condition|)
block|{
name|move_vert
argument_list|(
name|vis_botlin
argument_list|)
expr_stmt|;
name|vis_botlin
operator|=
literal|0
expr_stmt|;
name|crlf
argument_list|()
expr_stmt|;
name|fflush
argument_list|(
name|out_stream
argument_list|)
expr_stmt|;
name|rl_display_fixed
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|rl_clean_up_for_exit
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|readline_echoing_p
condition|)
block|{
name|move_vert
argument_list|(
name|vis_botlin
argument_list|)
expr_stmt|;
name|vis_botlin
operator|=
literal|0
expr_stmt|;
name|fflush
argument_list|(
name|out_stream
argument_list|)
expr_stmt|;
name|rl_restart_output
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* What to do for some uppercase characters, like meta characters,    and some characters appearing in emacs_ctlx_keymap.  This function    is just a stub, you bind keys to it and the code in rl_dispatch ()    is special cased. */
end_comment

begin_macro
name|rl_do_lowercase_version
argument_list|(
argument|ignore1
argument_list|,
argument|ignore2
argument_list|)
end_macro

begin_decl_stmt
name|int
name|ignore1
decl_stmt|,
name|ignore2
decl_stmt|;
end_decl_stmt

begin_block
block|{ }
end_block

begin_comment
comment|/* Rubout the character behind point. */
end_comment

begin_macro
name|rl_rubout
argument_list|(
argument|count
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
name|rl_delete
argument_list|(
operator|-
name|count
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|rl_point
condition|)
block|{
name|ding
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|count
operator|>
literal|1
condition|)
block|{
name|int
name|orig_point
init|=
name|rl_point
decl_stmt|;
name|rl_backward
argument_list|(
name|count
argument_list|)
expr_stmt|;
name|rl_kill_text
argument_list|(
name|orig_point
argument_list|,
name|rl_point
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|c
init|=
name|the_line
index|[
operator|--
name|rl_point
index|]
decl_stmt|;
name|rl_delete_text
argument_list|(
name|rl_point
argument_list|,
name|rl_point
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rl_point
operator|==
name|rl_end
operator|&&
name|alphabetic
argument_list|(
name|c
argument_list|)
operator|&&
name|last_c_pos
condition|)
block|{
name|backspace
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|' '
argument_list|,
name|out_stream
argument_list|)
expr_stmt|;
name|backspace
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|last_c_pos
operator|--
expr_stmt|;
name|rl_display_fixed
operator|++
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/* Delete the character under the cursor.  Given a numeric argument,    kill that many characters instead. */
end_comment

begin_macro
name|rl_delete
argument_list|(
argument|count
argument_list|,
argument|invoking_key
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
name|rl_rubout
argument_list|(
operator|-
name|count
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rl_point
operator|==
name|rl_end
condition|)
block|{
name|ding
argument_list|()
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|VI_MODE
if|if
condition|(
operator|(
name|count
operator|>
literal|1
operator|)
operator|||
operator|(
operator|(
name|count
operator|==
literal|1
operator|)
operator|&&
operator|(
name|rl_editing_mode
operator|==
name|vi_mode
operator|)
operator|)
condition|)
else|#
directive|else
if|if
condition|(
name|count
operator|>
literal|1
condition|)
endif|#
directive|endif
block|{
name|int
name|orig_point
init|=
name|rl_point
decl_stmt|;
while|while
condition|(
name|count
operator|&&
operator|(
name|rl_point
operator|<
name|rl_end
operator|)
condition|)
block|{
name|rl_point
operator|++
expr_stmt|;
name|count
operator|--
expr_stmt|;
block|}
name|rl_kill_text
argument_list|(
name|orig_point
argument_list|,
name|rl_point
argument_list|)
expr_stmt|;
name|rl_point
operator|=
name|orig_point
expr_stmt|;
block|}
else|else
name|rl_delete_text
argument_list|(
name|rl_point
argument_list|,
name|rl_point
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Kill commands				    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* The next two functions mimic unix line editing behaviour, except they    save the deleted text on the kill ring.  This is safer than not saving    it, and since we have a ring, nobody should get screwed. */
end_comment

begin_comment
comment|/* This does what C-w does in Unix.  We can't prevent people from    using behaviour that they expect. */
end_comment

begin_macro
name|rl_unix_word_rubout
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
operator|!
name|rl_point
condition|)
name|ding
argument_list|()
expr_stmt|;
else|else
block|{
name|int
name|orig_point
init|=
name|rl_point
decl_stmt|;
while|while
condition|(
name|rl_point
operator|&&
name|whitespace
argument_list|(
name|the_line
index|[
name|rl_point
operator|-
literal|1
index|]
argument_list|)
condition|)
name|rl_point
operator|--
expr_stmt|;
while|while
condition|(
name|rl_point
operator|&&
operator|!
name|whitespace
argument_list|(
name|the_line
index|[
name|rl_point
operator|-
literal|1
index|]
argument_list|)
condition|)
name|rl_point
operator|--
expr_stmt|;
name|rl_kill_text
argument_list|(
name|rl_point
argument_list|,
name|orig_point
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Here is C-u doing what Unix does.  You don't *have* to use these    key-bindings.  We have a choice of killing the entire line, or    killing from where we are to the start of the line.  We choose the    latter, because if you are a Unix weenie, then you haven't backspaced    into the line at all, and if you aren't, then you know what you are    doing. */
end_comment

begin_macro
name|rl_unix_line_discard
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
operator|!
name|rl_point
condition|)
name|ding
argument_list|()
expr_stmt|;
else|else
block|{
name|rl_kill_text
argument_list|(
name|rl_point
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rl_point
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Commands For Typos			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Random and interesting things in here.  */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Changing Case				    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* The three kinds of things that we know how to do. */
end_comment

begin_define
define|#
directive|define
name|UpCase
value|1
end_define

begin_define
define|#
directive|define
name|DownCase
value|2
end_define

begin_define
define|#
directive|define
name|CapCase
value|3
end_define

begin_comment
comment|/* Uppercase the word at point. */
end_comment

begin_macro
name|rl_upcase_word
argument_list|(
argument|count
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|rl_change_case
argument_list|(
name|count
argument_list|,
name|UpCase
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Lowercase the word at point. */
end_comment

begin_macro
name|rl_downcase_word
argument_list|(
argument|count
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|rl_change_case
argument_list|(
name|count
argument_list|,
name|DownCase
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Upcase the first letter, downcase the rest. */
end_comment

begin_macro
name|rl_capitalize_word
argument_list|(
argument|count
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|rl_change_case
argument_list|(
name|count
argument_list|,
name|CapCase
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* The meaty function.    Change the case of COUNT words, performing OP on them.    OP is one of UpCase, DownCase, or CapCase.    If a negative argument is given, leave point where it started,    otherwise, leave it where it moves to. */
end_comment

begin_macro
name|rl_change_case
argument_list|(
argument|count
argument_list|,
argument|op
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|,
name|op
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|start
init|=
name|rl_point
decl_stmt|,
name|end
decl_stmt|;
name|int
name|state
init|=
literal|0
decl_stmt|;
name|rl_forward_word
argument_list|(
name|count
argument_list|)
expr_stmt|;
name|end
operator|=
name|rl_point
expr_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
name|int
name|temp
init|=
name|start
decl_stmt|;
name|start
operator|=
name|end
expr_stmt|;
name|end
operator|=
name|temp
expr_stmt|;
block|}
comment|/* We are going to modify some text, so let's prepare to undo it. */
name|rl_modifying
argument_list|(
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|start
operator|<
name|end
condition|;
name|start
operator|++
control|)
block|{
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|UpCase
case|:
name|the_line
index|[
name|start
index|]
operator|=
name|to_upper
argument_list|(
name|the_line
index|[
name|start
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|DownCase
case|:
name|the_line
index|[
name|start
index|]
operator|=
name|to_lower
argument_list|(
name|the_line
index|[
name|start
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|CapCase
case|:
if|if
condition|(
name|state
operator|==
literal|0
condition|)
block|{
name|the_line
index|[
name|start
index|]
operator|=
name|to_upper
argument_list|(
name|the_line
index|[
name|start
index|]
argument_list|)
expr_stmt|;
name|state
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|the_line
index|[
name|start
index|]
operator|=
name|to_lower
argument_list|(
name|the_line
index|[
name|start
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|pure_alphabetic
argument_list|(
name|the_line
index|[
name|start
index|]
argument_list|)
condition|)
name|state
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
name|rl_point
operator|=
name|end
expr_stmt|;
block|}
end_block

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Transposition				    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Transpose the words at point. */
end_comment

begin_macro
name|rl_transpose_words
argument_list|(
argument|count
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|word1
decl_stmt|,
modifier|*
name|word2
decl_stmt|;
name|int
name|w1_beg
decl_stmt|,
name|w1_end
decl_stmt|,
name|w2_beg
decl_stmt|,
name|w2_end
decl_stmt|;
name|int
name|orig_point
init|=
name|rl_point
decl_stmt|;
if|if
condition|(
operator|!
name|count
condition|)
return|return;
comment|/* Find the two words. */
name|rl_forward_word
argument_list|(
name|count
argument_list|)
expr_stmt|;
name|w2_end
operator|=
name|rl_point
expr_stmt|;
name|rl_backward_word
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|w2_beg
operator|=
name|rl_point
expr_stmt|;
name|rl_backward_word
argument_list|(
name|count
argument_list|)
expr_stmt|;
name|w1_beg
operator|=
name|rl_point
expr_stmt|;
name|rl_forward_word
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|w1_end
operator|=
name|rl_point
expr_stmt|;
comment|/* Do some check to make sure that there really are two words. */
if|if
condition|(
operator|(
name|w1_beg
operator|==
name|w2_beg
operator|)
operator|||
operator|(
name|w2_beg
operator|<
name|w1_end
operator|)
condition|)
block|{
name|ding
argument_list|()
expr_stmt|;
name|rl_point
operator|=
name|orig_point
expr_stmt|;
return|return;
block|}
comment|/* Get the text of the words. */
name|word1
operator|=
name|rl_copy
argument_list|(
name|w1_beg
argument_list|,
name|w1_end
argument_list|)
expr_stmt|;
name|word2
operator|=
name|rl_copy
argument_list|(
name|w2_beg
argument_list|,
name|w2_end
argument_list|)
expr_stmt|;
comment|/* We are about to do many insertions and deletions.  Remember them      as one operation. */
name|rl_begin_undo_group
argument_list|()
expr_stmt|;
comment|/* Do the stuff at word2 first, so that we don't have to worry      about word1 moving. */
name|rl_point
operator|=
name|w2_beg
expr_stmt|;
name|rl_delete_text
argument_list|(
name|w2_beg
argument_list|,
name|w2_end
argument_list|)
expr_stmt|;
name|rl_insert_text
argument_list|(
name|word1
argument_list|)
expr_stmt|;
name|rl_point
operator|=
name|w1_beg
expr_stmt|;
name|rl_delete_text
argument_list|(
name|w1_beg
argument_list|,
name|w1_end
argument_list|)
expr_stmt|;
name|rl_insert_text
argument_list|(
name|word2
argument_list|)
expr_stmt|;
comment|/* This is exactly correct since the text before this point has not      changed in length. */
name|rl_point
operator|=
name|w2_end
expr_stmt|;
comment|/* I think that does it. */
name|rl_end_undo_group
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|word1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|word2
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Transpose the characters at point.  If point is at the end of the line,    then transpose the characters before point. */
end_comment

begin_macro
name|rl_transpose_chars
argument_list|(
argument|count
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|count
condition|)
return|return;
if|if
condition|(
operator|!
name|rl_point
operator|||
name|rl_end
operator|<
literal|2
condition|)
block|{
name|ding
argument_list|()
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|count
condition|)
block|{
if|if
condition|(
name|rl_point
operator|==
name|rl_end
condition|)
block|{
name|int
name|t
init|=
name|the_line
index|[
name|rl_point
operator|-
literal|1
index|]
decl_stmt|;
name|the_line
index|[
name|rl_point
operator|-
literal|1
index|]
operator|=
name|the_line
index|[
name|rl_point
operator|-
literal|2
index|]
expr_stmt|;
name|the_line
index|[
name|rl_point
operator|-
literal|2
index|]
operator|=
name|t
expr_stmt|;
block|}
else|else
block|{
name|int
name|t
init|=
name|the_line
index|[
name|rl_point
index|]
decl_stmt|;
name|the_line
index|[
name|rl_point
index|]
operator|=
name|the_line
index|[
name|rl_point
operator|-
literal|1
index|]
expr_stmt|;
name|the_line
index|[
name|rl_point
operator|-
literal|1
index|]
operator|=
name|t
expr_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
operator|&&
name|rl_point
condition|)
name|rl_point
operator|--
expr_stmt|;
else|else
name|rl_point
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|<
literal|0
condition|)
name|count
operator|++
expr_stmt|;
else|else
name|count
operator|--
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Bogus Flow Control      		    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_macro
name|rl_restart_output
argument_list|(
argument|count
argument_list|,
argument|key
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|fildes
init|=
name|fileno
argument_list|(
name|stdin
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|TIOCSTART
name|ioctl
argument_list|(
name|fildes
argument_list|,
name|TIOCSTART
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TIOCSTART */
block|}
end_block

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*	Completion matching, from readline's point of view.	    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Pointer to the generator function for completion_matches ().    NULL means to use filename_entry_function (), the default filename    completer. */
end_comment

begin_decl_stmt
name|Function
modifier|*
name|rl_completion_entry_function
init|=
operator|(
name|Function
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to alternative function to create matches.    Function is called with TEXT, START, and END.    START and END are indices in RL_LINE_BUFFER saying what the boundaries    of TEXT are.    If this function exists and returns NULL then call the value of    rl_completion_entry_function to try to match, otherwise use the    array of strings returned. */
end_comment

begin_decl_stmt
name|Function
modifier|*
name|rl_attempted_completion_function
init|=
operator|(
name|Function
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Complete the word at or before point.  You have supplied the function    that does the initial simple matching selection algorithm (see    completion_matches ()).  The default is to do filename completion. */
end_comment

begin_macro
name|rl_complete
argument_list|(
argument|ignore
argument_list|,
argument|invoking_key
argument_list|)
end_macro

begin_decl_stmt
name|int
name|ignore
decl_stmt|,
name|invoking_key
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|rl_complete_internal
argument_list|(
name|TAB
argument_list|)
expr_stmt|;
if|if
condition|(
name|running_in_emacs
condition|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|the_line
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* List the possible completions.  See description of rl_complete (). */
end_comment

begin_macro
name|rl_possible_completions
argument_list|()
end_macro

begin_block
block|{
name|rl_complete_internal
argument_list|(
literal|'?'
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* The user must press "y" or "n". Non-zero return means "y" pressed. */
end_comment

begin_macro
name|get_y_or_n
argument_list|()
end_macro

begin_block
block|{
name|int
name|c
decl_stmt|;
name|loop
label|:
name|c
operator|=
name|rl_read_key
argument_list|(
name|in_stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'y'
operator|||
name|c
operator|==
literal|'Y'
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|c
operator|==
literal|'n'
operator|||
name|c
operator|==
literal|'N'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|c
operator|==
name|ABORT_CHAR
condition|)
name|rl_abort
argument_list|()
expr_stmt|;
name|ding
argument_list|()
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
end_block

begin_comment
comment|/* Up to this many items will be displayed in response to a    possible-completions call.  After that, we ask the user if    she is sure she wants to see them all. */
end_comment

begin_decl_stmt
name|int
name|rl_completion_query_items
init|=
literal|100
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The basic list of characters that signal a break between words for the    completer routine.  The contents of this variable is what breaks words    in the shell, i.e. " \t\n\"\\'`@$><=" */
end_comment

begin_decl_stmt
name|char
modifier|*
name|rl_basic_word_break_characters
init|=
literal|" \t\n\"\\'`@$><="
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The list of characters that signal a break between words for    rl_complete_internal.  The default list is the contents of    rl_basic_word_break_characters.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|rl_completer_word_break_characters
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of characters that are word break characters, but should be left    in TEXT when it is passed to the completion function.  The shell uses    this to help determine what kind of completing to do. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|rl_special_prefixes
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If non-zero, then disallow duplicates in the matches. */
end_comment

begin_decl_stmt
name|int
name|rl_ignore_completion_duplicates
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means that the results of the matches are to be treated    as filenames.  This is ALWAYS zero on entry, and can only be changed    within a completion entry finder function. */
end_comment

begin_decl_stmt
name|int
name|rl_filename_completion_desired
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Complete the word at or before point.    WHAT_TO_DO says what to do with the completion.    `?' means list the possible completions.    TAB means do standard completion.    `*' means insert all of the possible completions. */
end_comment

begin_macro
name|rl_complete_internal
argument_list|(
argument|what_to_do
argument_list|)
end_macro

begin_decl_stmt
name|int
name|what_to_do
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|filename_completion_function
parameter_list|()
function_decl|;
name|char
modifier|*
modifier|*
name|completion_matches
argument_list|()
decl_stmt|,
modifier|*
modifier|*
name|matches
decl_stmt|;
name|Function
modifier|*
name|our_func
decl_stmt|;
name|int
name|start
decl_stmt|,
name|end
decl_stmt|,
name|delimiter
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|text
decl_stmt|;
if|if
condition|(
name|rl_completion_entry_function
condition|)
name|our_func
operator|=
name|rl_completion_entry_function
expr_stmt|;
else|else
name|our_func
operator|=
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|filename_completion_function
expr_stmt|;
comment|/* Only the completion entry function can change this. */
name|rl_filename_completion_desired
operator|=
literal|0
expr_stmt|;
comment|/* We now look backwards for the start of a filename/variable word. */
name|end
operator|=
name|rl_point
expr_stmt|;
if|if
condition|(
name|rl_point
condition|)
block|{
while|while
condition|(
operator|--
name|rl_point
operator|&&
operator|!
name|rindex
argument_list|(
name|rl_completer_word_break_characters
argument_list|,
name|the_line
index|[
name|rl_point
index|]
argument_list|)
condition|)
empty_stmt|;
comment|/* If we are at a word break, then advance past it. */
if|if
condition|(
name|rindex
argument_list|(
name|rl_completer_word_break_characters
argument_list|,
operator|(
name|the_line
index|[
name|rl_point
index|]
operator|)
argument_list|)
condition|)
block|{
comment|/* If the character that caused the word break was a quoting 	     character, then remember it as the delimiter. */
if|if
condition|(
name|rindex
argument_list|(
literal|"\"'"
argument_list|,
name|the_line
index|[
name|rl_point
index|]
argument_list|)
operator|&&
operator|(
name|end
operator|-
name|rl_point
operator|)
operator|>
literal|1
condition|)
name|delimiter
operator|=
name|the_line
index|[
name|rl_point
index|]
expr_stmt|;
comment|/* If the character isn't needed to determine something special 	     about what kind of completion to perform, then advance past it. */
if|if
condition|(
operator|!
name|rl_special_prefixes
operator|||
operator|!
name|rindex
argument_list|(
name|rl_special_prefixes
argument_list|,
name|the_line
index|[
name|rl_point
index|]
argument_list|)
condition|)
name|rl_point
operator|++
expr_stmt|;
block|}
block|}
name|start
operator|=
name|rl_point
expr_stmt|;
name|rl_point
operator|=
name|end
expr_stmt|;
name|text
operator|=
name|rl_copy
argument_list|(
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
comment|/* If the user wants to TRY to complete, but then wants to give      up and use the default completion function, they set the      variable rl_attempted_completion_function. */
if|if
condition|(
name|rl_attempted_completion_function
condition|)
block|{
name|matches
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
call|(
modifier|*
name|rl_attempted_completion_function
call|)
argument_list|(
name|text
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|matches
condition|)
goto|goto
name|after_usual_completion
goto|;
block|}
name|matches
operator|=
name|completion_matches
argument_list|(
name|text
argument_list|,
name|our_func
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|after_usual_completion
label|:
name|free
argument_list|(
name|text
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|matches
condition|)
name|ding
argument_list|()
expr_stmt|;
else|else
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|some_matches
label|:
comment|/* It seems to me that in all the cases we handle we would like 	 to ignore duplicate possiblilities.  Scan for the text to 	 insert being identical to the other completions. */
if|if
condition|(
name|rl_ignore_completion_duplicates
condition|)
block|{
name|char
modifier|*
name|lowest_common
decl_stmt|;
name|int
name|j
decl_stmt|,
name|newlen
init|=
literal|0
decl_stmt|;
comment|/* Sort the items. */
comment|/* It is safe to sort this array, because the lowest common 	     denominator found in matches[0] will remain in place. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|matches
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
empty_stmt|;
name|qsort
argument_list|(
name|matches
argument_list|,
name|i
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|,
name|compare_strings
argument_list|)
expr_stmt|;
comment|/* Remember the lowest common denimator for it may be unique. */
name|lowest_common
operator|=
name|savestring
argument_list|(
name|matches
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|matches
index|[
name|i
operator|+
literal|1
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|matches
index|[
name|i
index|]
argument_list|,
name|matches
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|matches
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|matches
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|*
operator|)
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|newlen
operator|++
expr_stmt|;
block|}
comment|/* We have marked all the dead slots with (char *)-1. 	     Copy all the non-dead entries into a new array. */
block|{
name|char
modifier|*
modifier|*
name|temp_array
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
operator|(
literal|3
operator|+
name|newlen
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|j
operator|=
literal|1
init|;
name|matches
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|matches
index|[
name|i
index|]
operator|!=
operator|(
name|char
operator|*
operator|)
operator|-
literal|1
condition|)
name|temp_array
index|[
name|j
operator|++
index|]
operator|=
name|matches
index|[
name|i
index|]
expr_stmt|;
name|temp_array
index|[
name|j
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
name|matches
index|[
literal|0
index|]
operator|!=
operator|(
name|char
operator|*
operator|)
operator|-
literal|1
condition|)
name|free
argument_list|(
name|matches
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|matches
argument_list|)
expr_stmt|;
name|matches
operator|=
name|temp_array
expr_stmt|;
block|}
comment|/* Place the lowest common denominator back in [0]. */
name|matches
index|[
literal|0
index|]
operator|=
name|lowest_common
expr_stmt|;
comment|/* If there is one string left, and it is identical to the 	     lowest common denominator, then the LCD is the string to 	     insert. */
if|if
condition|(
name|j
operator|==
literal|2
operator|&&
name|strcmp
argument_list|(
name|matches
index|[
literal|0
index|]
argument_list|,
name|matches
index|[
literal|1
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|matches
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|matches
index|[
literal|1
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|what_to_do
condition|)
block|{
case|case
name|TAB
case|:
name|rl_delete_text
argument_list|(
name|start
argument_list|,
name|rl_point
argument_list|)
expr_stmt|;
name|rl_point
operator|=
name|start
expr_stmt|;
name|rl_insert_text
argument_list|(
name|matches
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* If there are more matches, ring the bell to indicate. 	     If this was the only match, and we are hacking files, 	     check the file to see if it was a directory.  If so, 	     add a '/' to the name.  If not, and we are at the end 	     of the line, then add a space. */
if|if
condition|(
name|matches
index|[
literal|1
index|]
condition|)
block|{
name|ding
argument_list|()
expr_stmt|;
comment|/* There are other matches remaining. */
block|}
else|else
block|{
name|char
name|temp_string
index|[
literal|2
index|]
decl_stmt|;
name|temp_string
index|[
literal|0
index|]
operator|=
name|delimiter
condition|?
name|delimiter
else|:
literal|' '
expr_stmt|;
name|temp_string
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|rl_filename_completion_desired
condition|)
block|{
name|struct
name|stat
name|finfo
decl_stmt|;
name|char
modifier|*
name|tilde_expand
parameter_list|()
function_decl|;
name|char
modifier|*
name|filename
init|=
name|tilde_expand
argument_list|(
name|matches
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|stat
argument_list|(
name|filename
argument_list|,
operator|&
name|finfo
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|finfo
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFDIR
operator|)
condition|)
block|{
if|if
condition|(
name|the_line
index|[
name|rl_point
index|]
operator|!=
literal|'/'
condition|)
name|rl_insert_text
argument_list|(
literal|"/"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|rl_point
operator|==
name|rl_end
condition|)
name|rl_insert_text
argument_list|(
name|temp_string
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|rl_point
operator|==
name|rl_end
condition|)
name|rl_insert_text
argument_list|(
name|temp_string
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'*'
case|:
block|{
name|int
name|i
init|=
literal|1
decl_stmt|;
name|rl_delete_text
argument_list|(
name|start
argument_list|,
name|rl_point
argument_list|)
expr_stmt|;
name|rl_point
operator|=
name|start
expr_stmt|;
name|rl_begin_undo_group
argument_list|()
expr_stmt|;
if|if
condition|(
name|matches
index|[
literal|1
index|]
condition|)
block|{
while|while
condition|(
name|matches
index|[
name|i
index|]
condition|)
block|{
name|rl_insert_text
argument_list|(
name|matches
index|[
name|i
operator|++
index|]
argument_list|)
expr_stmt|;
name|rl_insert_text
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|rl_insert_text
argument_list|(
name|matches
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|rl_insert_text
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
name|rl_end_undo_group
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|'?'
case|:
block|{
name|int
name|len
decl_stmt|,
name|count
decl_stmt|,
name|limit
decl_stmt|,
name|max
init|=
literal|0
decl_stmt|;
name|int
name|j
decl_stmt|,
name|k
decl_stmt|,
name|l
decl_stmt|;
comment|/* Handle simple case first.  What if there is only one answer? */
if|if
condition|(
operator|!
name|matches
index|[
literal|1
index|]
condition|)
block|{
name|char
modifier|*
name|temp
decl_stmt|;
if|if
condition|(
name|rl_filename_completion_desired
condition|)
name|temp
operator|=
name|rindex
argument_list|(
name|matches
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
else|else
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|temp
condition|)
name|temp
operator|=
name|matches
index|[
literal|0
index|]
expr_stmt|;
else|else
name|temp
operator|++
expr_stmt|;
name|crlf
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|out_stream
argument_list|,
literal|"%s"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|crlf
argument_list|()
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
comment|/* There is more than one answer.  Find out how many there are, 	       and find out what the maximum printed length of a single entry 	       is. */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|matches
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|temp
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
comment|/* If we are hacking filenames, then only count the characters 		   after the last slash in the pathname. */
if|if
condition|(
name|rl_filename_completion_desired
condition|)
name|temp
operator|=
name|rindex
argument_list|(
name|matches
index|[
name|i
index|]
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
else|else
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|temp
condition|)
name|temp
operator|=
name|matches
index|[
name|i
index|]
expr_stmt|;
else|else
name|temp
operator|++
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|temp
argument_list|)
operator|>
name|max
condition|)
name|max
operator|=
name|strlen
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
name|len
operator|=
name|i
expr_stmt|;
comment|/* If there are many items, then ask the user if she 	       really wants to see them all. */
if|if
condition|(
name|len
operator|>=
name|rl_completion_query_items
condition|)
block|{
name|crlf
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|out_stream
argument_list|,
literal|"There are %d possibilities.  Do you really"
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|crlf
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|out_stream
argument_list|,
literal|"wish to see them all? (y or n)"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|out_stream
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|get_y_or_n
argument_list|()
condition|)
block|{
name|crlf
argument_list|()
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
block|}
comment|/* How many items of MAX length can we fit in the screen window? */
name|max
operator|+=
literal|2
expr_stmt|;
name|limit
operator|=
name|screenwidth
operator|/
name|max
expr_stmt|;
if|if
condition|(
name|limit
operator|!=
literal|1
operator|&&
operator|(
name|limit
operator|*
name|max
operator|==
name|screenwidth
operator|)
condition|)
name|limit
operator|--
expr_stmt|;
comment|/* How many iterations of the printing loop? */
name|count
operator|=
operator|(
name|len
operator|+
operator|(
name|limit
operator|-
literal|1
operator|)
operator|)
operator|/
name|limit
expr_stmt|;
comment|/* Watch out for special case.  If LEN is less than LIMIT, then 	       just do the inner printing loop. */
if|if
condition|(
name|len
operator|<
name|limit
condition|)
name|count
operator|=
literal|1
expr_stmt|;
comment|/* Sort the items if they are not already sorted. */
if|if
condition|(
operator|!
name|rl_ignore_completion_duplicates
condition|)
block|{
name|qsort
argument_list|(
name|matches
argument_list|,
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|,
name|compare_strings
argument_list|)
expr_stmt|;
block|}
comment|/* Print the sorted items, up-and-down alphabetically, like 	       ls might. */
name|crlf
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|count
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|l
operator|=
name|i
init|;
name|j
operator|<
name|limit
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|l
operator|>
name|len
operator|||
operator|!
name|matches
index|[
name|l
index|]
condition|)
block|{
break|break;
block|}
else|else
block|{
name|char
modifier|*
name|temp
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
if|if
condition|(
name|rl_filename_completion_desired
condition|)
name|temp
operator|=
name|rindex
argument_list|(
name|matches
index|[
name|l
index|]
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
else|else
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|temp
condition|)
name|temp
operator|=
name|matches
index|[
name|l
index|]
expr_stmt|;
else|else
name|temp
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|out_stream
argument_list|,
literal|"%s"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|max
operator|-
name|strlen
argument_list|(
name|temp
argument_list|)
condition|;
name|k
operator|++
control|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|out_stream
argument_list|)
expr_stmt|;
block|}
name|l
operator|+=
name|count
expr_stmt|;
block|}
name|crlf
argument_list|()
expr_stmt|;
block|}
name|restart
label|:
name|rl_on_new_line
argument_list|()
expr_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|matches
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|matches
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|matches
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* A completion function for usernames.    TEXT contains a partial username preceded by a random    character (usually `~').  */
end_comment

begin_function
name|char
modifier|*
name|username_completion_function
parameter_list|(
name|text
parameter_list|,
name|state
parameter_list|)
name|int
name|state
decl_stmt|;
name|char
modifier|*
name|text
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|username
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
specifier|static
name|struct
name|passwd
modifier|*
name|entry
decl_stmt|;
specifier|static
name|int
name|namelen
decl_stmt|;
if|if
condition|(
operator|!
name|state
condition|)
block|{
if|if
condition|(
name|username
condition|)
name|free
argument_list|(
name|username
argument_list|)
expr_stmt|;
name|username
operator|=
name|savestring
argument_list|(
operator|&
name|text
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|namelen
operator|=
name|strlen
argument_list|(
name|username
argument_list|)
expr_stmt|;
name|setpwent
argument_list|()
expr_stmt|;
block|}
while|while
condition|(
name|entry
operator|=
name|getpwent
argument_list|()
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|username
argument_list|,
name|entry
operator|->
name|pw_name
argument_list|,
name|namelen
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|entry
condition|)
block|{
name|endpwent
argument_list|()
expr_stmt|;
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
else|else
block|{
name|char
modifier|*
name|value
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|2
operator|+
name|strlen
argument_list|(
name|entry
operator|->
name|pw_name
argument_list|)
argument_list|)
decl_stmt|;
operator|*
name|value
operator|=
operator|*
name|text
expr_stmt|;
name|strcpy
argument_list|(
name|value
operator|+
literal|1
argument_list|,
name|entry
operator|->
name|pw_name
argument_list|)
expr_stmt|;
name|rl_filename_completion_desired
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|value
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* If non-null, this contains the address of a function to call if the    standard meaning for expanding a tilde fails.  The function is called    with the text (sans tilde, as in "foo"), and returns a malloc()'ed string    which is the expansion, or a NULL pointer if there is no expansion. */
end_comment

begin_decl_stmt
name|Function
modifier|*
name|rl_tilde_expander
init|=
operator|(
name|Function
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Expand FILENAME if it begins with a tilde.  This always returns    a new string. */
end_comment

begin_function
name|char
modifier|*
name|tilde_expand
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|char
modifier|*
name|dirname
init|=
name|filename
condition|?
name|savestring
argument_list|(
name|filename
argument_list|)
else|:
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
if|if
condition|(
name|dirname
operator|&&
operator|*
name|dirname
operator|==
literal|'~'
condition|)
block|{
name|char
modifier|*
name|temp_name
decl_stmt|;
if|if
condition|(
operator|!
name|dirname
index|[
literal|1
index|]
operator|||
name|dirname
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
comment|/* Prepend $HOME to the rest of the string. */
name|char
modifier|*
name|temp_home
init|=
operator|(
name|char
operator|*
operator|)
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
decl_stmt|;
name|temp_name
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|1
operator|+
name|strlen
argument_list|(
operator|&
name|dirname
index|[
literal|1
index|]
argument_list|)
operator|+
operator|(
name|temp_home
condition|?
name|strlen
argument_list|(
name|temp_home
argument_list|)
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|temp_name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|temp_home
condition|)
name|strcpy
argument_list|(
name|temp_name
argument_list|,
name|temp_home
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp_name
argument_list|,
operator|&
name|dirname
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dirname
argument_list|)
expr_stmt|;
name|dirname
operator|=
name|savestring
argument_list|(
name|temp_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|passwd
modifier|*
name|getpwnam
argument_list|()
decl_stmt|,
modifier|*
name|user_entry
decl_stmt|;
name|char
modifier|*
name|username
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|257
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|c
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|c
operator|=
name|dirname
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|c
operator|==
literal|'/'
condition|)
break|break;
else|else
name|username
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|c
expr_stmt|;
block|}
name|username
index|[
name|i
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|user_entry
operator|=
name|getpwnam
argument_list|(
name|username
argument_list|)
operator|)
condition|)
block|{
comment|/* If the calling program has a special syntax for 		 expanding tildes, and we couldn't find a standard 		 expansion, then let them try. */
if|if
condition|(
name|rl_tilde_expander
condition|)
block|{
name|char
modifier|*
name|expansion
decl_stmt|;
name|expansion
operator|=
operator|(
name|char
operator|*
operator|)
call|(
modifier|*
name|rl_tilde_expander
call|)
argument_list|(
name|username
argument_list|)
expr_stmt|;
if|if
condition|(
name|expansion
condition|)
block|{
name|temp_name
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|1
operator|+
name|strlen
argument_list|(
name|expansion
argument_list|)
operator|+
name|strlen
argument_list|(
operator|&
name|dirname
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|temp_name
argument_list|,
name|expansion
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp_name
argument_list|,
operator|&
name|dirname
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|expansion
argument_list|)
expr_stmt|;
goto|goto
name|return_name
goto|;
block|}
block|}
comment|/* 	       * We shouldn't report errors. 	       */
block|}
else|else
block|{
name|temp_name
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|1
operator|+
name|strlen
argument_list|(
name|user_entry
operator|->
name|pw_dir
argument_list|)
operator|+
name|strlen
argument_list|(
operator|&
name|dirname
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|temp_name
argument_list|,
name|user_entry
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp_name
argument_list|,
operator|&
name|dirname
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|return_name
label|:
name|free
argument_list|(
name|dirname
argument_list|)
expr_stmt|;
name|dirname
operator|=
name|savestring
argument_list|(
name|temp_name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|dirname
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Undo, and Undoing			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Non-zero tells rl_delete_text and rl_insert_text to not add to    the undo list. */
end_comment

begin_decl_stmt
name|int
name|doing_an_undo
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The current undo list for THE_LINE. */
end_comment

begin_decl_stmt
name|UNDO_LIST
modifier|*
name|rl_undo_list
init|=
operator|(
name|UNDO_LIST
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Remember how to undo something.  Concatenate some undos if that    seems right. */
end_comment

begin_expr_stmt
name|rl_add_undo
argument_list|(
name|what
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|text
argument_list|)
expr|enum
name|undo_code
name|what
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|start
decl_stmt|,
name|end
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|text
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|UNDO_LIST
modifier|*
name|temp
init|=
operator|(
name|UNDO_LIST
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|UNDO_LIST
argument_list|)
argument_list|)
decl_stmt|;
name|temp
operator|->
name|what
operator|=
name|what
expr_stmt|;
name|temp
operator|->
name|start
operator|=
name|start
expr_stmt|;
name|temp
operator|->
name|end
operator|=
name|end
expr_stmt|;
name|temp
operator|->
name|text
operator|=
name|text
expr_stmt|;
name|temp
operator|->
name|next
operator|=
name|rl_undo_list
expr_stmt|;
name|rl_undo_list
operator|=
name|temp
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Free the existing undo list. */
end_comment

begin_macro
name|free_undo_list
argument_list|()
end_macro

begin_block
block|{
while|while
condition|(
name|rl_undo_list
condition|)
block|{
name|UNDO_LIST
modifier|*
name|release
init|=
name|rl_undo_list
decl_stmt|;
name|rl_undo_list
operator|=
name|rl_undo_list
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|release
operator|->
name|what
operator|==
name|UNDO_DELETE
condition|)
name|free
argument_list|(
name|release
operator|->
name|text
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|release
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Undo the next thing in the list.  Return 0 if there    is nothing to undo, or non-zero if there was. */
end_comment

begin_function
name|int
name|rl_do_undo
parameter_list|()
block|{
name|UNDO_LIST
modifier|*
name|release
decl_stmt|;
name|int
name|waiting_for_begin
init|=
literal|0
decl_stmt|;
name|undo_thing
label|:
if|if
condition|(
operator|!
name|rl_undo_list
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|doing_an_undo
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|rl_undo_list
operator|->
name|what
condition|)
block|{
comment|/* Undoing deletes means inserting some text. */
case|case
name|UNDO_DELETE
case|:
name|rl_point
operator|=
name|rl_undo_list
operator|->
name|start
expr_stmt|;
name|rl_insert_text
argument_list|(
name|rl_undo_list
operator|->
name|text
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rl_undo_list
operator|->
name|text
argument_list|)
expr_stmt|;
break|break;
comment|/* Undoing inserts means deleting some text. */
case|case
name|UNDO_INSERT
case|:
name|rl_delete_text
argument_list|(
name|rl_undo_list
operator|->
name|start
argument_list|,
name|rl_undo_list
operator|->
name|end
argument_list|)
expr_stmt|;
name|rl_point
operator|=
name|rl_undo_list
operator|->
name|start
expr_stmt|;
break|break;
comment|/* Undoing an END means undoing everything 'til we get to        a BEGIN. */
case|case
name|UNDO_END
case|:
name|waiting_for_begin
operator|++
expr_stmt|;
break|break;
comment|/* Undoing a BEGIN means that we are done with this group. */
case|case
name|UNDO_BEGIN
case|:
if|if
condition|(
name|waiting_for_begin
condition|)
name|waiting_for_begin
operator|--
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
break|break;
block|}
name|doing_an_undo
operator|=
literal|0
expr_stmt|;
name|release
operator|=
name|rl_undo_list
expr_stmt|;
name|rl_undo_list
operator|=
name|rl_undo_list
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|release
argument_list|)
expr_stmt|;
if|if
condition|(
name|waiting_for_begin
condition|)
goto|goto
name|undo_thing
goto|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Begin a group.  Subsequent undos are undone as an atomic operation. */
end_comment

begin_macro
name|rl_begin_undo_group
argument_list|()
end_macro

begin_block
block|{
name|rl_add_undo
argument_list|(
name|UNDO_BEGIN
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* End an undo group started with rl_begin_undo_group (). */
end_comment

begin_macro
name|rl_end_undo_group
argument_list|()
end_macro

begin_block
block|{
name|rl_add_undo
argument_list|(
name|UNDO_END
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Save an undo entry for the text from START to END. */
end_comment

begin_macro
name|rl_modifying
argument_list|(
argument|start
argument_list|,
argument|end
argument_list|)
end_macro

begin_decl_stmt
name|int
name|start
decl_stmt|,
name|end
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|start
operator|>
name|end
condition|)
block|{
name|int
name|t
init|=
name|start
decl_stmt|;
name|start
operator|=
name|end
expr_stmt|;
name|end
operator|=
name|t
expr_stmt|;
block|}
if|if
condition|(
name|start
operator|!=
name|end
condition|)
block|{
name|char
modifier|*
name|temp
init|=
name|rl_copy
argument_list|(
name|start
argument_list|,
name|end
argument_list|)
decl_stmt|;
name|rl_begin_undo_group
argument_list|()
expr_stmt|;
name|rl_add_undo
argument_list|(
name|UNDO_DELETE
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|rl_add_undo
argument_list|(
name|UNDO_INSERT
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|rl_end_undo_group
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Revert the current line to its previous state. */
end_comment

begin_macro
name|rl_revert_line
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
operator|!
name|rl_undo_list
condition|)
name|ding
argument_list|()
expr_stmt|;
else|else
block|{
while|while
condition|(
name|rl_undo_list
condition|)
name|rl_do_undo
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Do some undoing of things that were done. */
end_comment

begin_macro
name|rl_undo_command
argument_list|(
argument|count
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|count
operator|<
literal|0
condition|)
return|return;
comment|/* Nothing to do. */
while|while
condition|(
name|count
condition|)
block|{
if|if
condition|(
name|rl_do_undo
argument_list|()
condition|)
block|{
name|count
operator|--
expr_stmt|;
block|}
else|else
block|{
name|ding
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			History Utilities			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* We already have a history library, and that is what we use to control    the history features of readline.  However, this is our local interface    to the history mechanism. */
end_comment

begin_comment
comment|/* While we are editing the history, this is the saved    version of the original line. */
end_comment

begin_decl_stmt
name|HIST_ENTRY
modifier|*
name|saved_line_for_history
init|=
operator|(
name|HIST_ENTRY
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set the history pointer back to the last entry in the history. */
end_comment

begin_macro
name|start_using_history
argument_list|()
end_macro

begin_block
block|{
name|using_history
argument_list|()
expr_stmt|;
if|if
condition|(
name|saved_line_for_history
condition|)
name|free_history_entry
argument_list|(
name|saved_line_for_history
argument_list|)
expr_stmt|;
name|saved_line_for_history
operator|=
operator|(
name|HIST_ENTRY
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Free the contents (and containing structure) of a HIST_ENTRY. */
end_comment

begin_macro
name|free_history_entry
argument_list|(
argument|entry
argument_list|)
end_macro

begin_decl_stmt
name|HIST_ENTRY
modifier|*
name|entry
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|entry
condition|)
return|return;
if|if
condition|(
name|entry
operator|->
name|line
condition|)
name|free
argument_list|(
name|entry
operator|->
name|line
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Perhaps put back the current line if it has changed. */
end_comment

begin_macro
name|maybe_replace_line
argument_list|()
end_macro

begin_block
block|{
name|HIST_ENTRY
modifier|*
name|temp
init|=
name|current_history
argument_list|()
decl_stmt|;
comment|/* If the current line has changed, save the changes. */
if|if
condition|(
name|temp
operator|&&
operator|(
operator|(
name|UNDO_LIST
operator|*
operator|)
operator|(
name|temp
operator|->
name|data
operator|)
operator|!=
name|rl_undo_list
operator|)
condition|)
block|{
name|temp
operator|=
name|replace_history_entry
argument_list|(
name|where_history
argument_list|()
argument_list|,
name|the_line
argument_list|,
name|rl_undo_list
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
operator|->
name|line
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Put back the saved_line_for_history if there is one. */
end_comment

begin_macro
name|maybe_unsave_line
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|saved_line_for_history
condition|)
block|{
name|strcpy
argument_list|(
name|the_line
argument_list|,
name|saved_line_for_history
operator|->
name|line
argument_list|)
expr_stmt|;
name|rl_undo_list
operator|=
operator|(
name|UNDO_LIST
operator|*
operator|)
name|saved_line_for_history
operator|->
name|data
expr_stmt|;
name|free_history_entry
argument_list|(
name|saved_line_for_history
argument_list|)
expr_stmt|;
name|saved_line_for_history
operator|=
operator|(
name|HIST_ENTRY
operator|*
operator|)
name|NULL
expr_stmt|;
name|rl_end
operator|=
name|rl_point
operator|=
name|strlen
argument_list|(
name|the_line
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ding
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Save the current line in saved_line_for_history. */
end_comment

begin_macro
name|maybe_save_line
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
operator|!
name|saved_line_for_history
condition|)
block|{
name|saved_line_for_history
operator|=
operator|(
name|HIST_ENTRY
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|HIST_ENTRY
argument_list|)
argument_list|)
expr_stmt|;
name|saved_line_for_history
operator|->
name|line
operator|=
name|savestring
argument_list|(
name|the_line
argument_list|)
expr_stmt|;
name|saved_line_for_history
operator|->
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|rl_undo_list
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			History Commands			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Meta-< goes to the start of the history. */
end_comment

begin_macro
name|rl_beginning_of_history
argument_list|()
end_macro

begin_block
block|{
name|rl_get_previous_history
argument_list|(
literal|1
operator|+
name|where_history
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Meta-> goes to the end of the history.  (The current line). */
end_comment

begin_macro
name|rl_end_of_history
argument_list|()
end_macro

begin_block
block|{
name|maybe_replace_line
argument_list|()
expr_stmt|;
name|using_history
argument_list|()
expr_stmt|;
name|maybe_unsave_line
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Move down to the next history line. */
end_comment

begin_macro
name|rl_get_next_history
argument_list|(
argument|count
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|HIST_ENTRY
modifier|*
name|temp
init|=
operator|(
name|HIST_ENTRY
operator|*
operator|)
name|NULL
decl_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
name|rl_get_previous_history
argument_list|(
operator|-
name|count
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|count
condition|)
return|return;
name|maybe_replace_line
argument_list|()
expr_stmt|;
while|while
condition|(
name|count
condition|)
block|{
name|temp
operator|=
name|next_history
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|temp
condition|)
break|break;
operator|--
name|count
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|temp
condition|)
name|maybe_unsave_line
argument_list|()
expr_stmt|;
else|else
block|{
name|strcpy
argument_list|(
name|the_line
argument_list|,
name|temp
operator|->
name|line
argument_list|)
expr_stmt|;
name|rl_undo_list
operator|=
operator|(
name|UNDO_LIST
operator|*
operator|)
name|temp
operator|->
name|data
expr_stmt|;
name|rl_end
operator|=
name|rl_point
operator|=
name|strlen
argument_list|(
name|the_line
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Get the previous item out of our interactive history, making it the current    line.  If there is no previous history, just ding. */
end_comment

begin_macro
name|rl_get_previous_history
argument_list|(
argument|count
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|HIST_ENTRY
modifier|*
name|old_temp
init|=
operator|(
name|HIST_ENTRY
operator|*
operator|)
name|NULL
decl_stmt|;
name|HIST_ENTRY
modifier|*
name|temp
init|=
operator|(
name|HIST_ENTRY
operator|*
operator|)
name|NULL
decl_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
name|rl_get_next_history
argument_list|(
operator|-
name|count
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|count
condition|)
return|return;
comment|/* If we don't have a line saved, then save this one. */
name|maybe_save_line
argument_list|()
expr_stmt|;
comment|/* If the current line has changed, save the changes. */
name|maybe_replace_line
argument_list|()
expr_stmt|;
while|while
condition|(
name|count
condition|)
block|{
name|temp
operator|=
name|previous_history
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|temp
condition|)
break|break;
else|else
name|old_temp
operator|=
name|temp
expr_stmt|;
operator|--
name|count
expr_stmt|;
block|}
comment|/* If there was a large argument, and we moved back to the start of the      history, that is not an error.  So use the last value found. */
if|if
condition|(
operator|!
name|temp
operator|&&
name|old_temp
condition|)
name|temp
operator|=
name|old_temp
expr_stmt|;
if|if
condition|(
operator|!
name|temp
condition|)
name|ding
argument_list|()
expr_stmt|;
else|else
block|{
name|strcpy
argument_list|(
name|the_line
argument_list|,
name|temp
operator|->
name|line
argument_list|)
expr_stmt|;
name|rl_undo_list
operator|=
operator|(
name|UNDO_LIST
operator|*
operator|)
name|temp
operator|->
name|data
expr_stmt|;
name|rl_end
operator|=
name|rl_point
operator|=
name|strlen
argument_list|(
name|the_line
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VI_MODE
if|if
condition|(
name|rl_editing_mode
operator|==
name|vi_mode
condition|)
name|rl_point
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* VI_MODE */
block|}
block|}
end_block

begin_comment
comment|/* There is a command in ksh which yanks into this line, the last word    of the previous line.  Here it is.  We left it on M-. */
end_comment

begin_macro
name|rl_yank_previous_last_arg
argument_list|(
argument|ignore
argument_list|)
end_macro

begin_decl_stmt
name|int
name|ignore
decl_stmt|;
end_decl_stmt

begin_block
block|{ }
end_block

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			I-Search and Searching			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Search backwards through the history looking for a string which is typed    interactively.  Start with the current line. */
end_comment

begin_macro
name|rl_reverse_search_history
argument_list|(
argument|sign
argument_list|,
argument|key
argument_list|)
end_macro

begin_decl_stmt
name|int
name|sign
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|key
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|rl_search_history
argument_list|(
operator|-
name|sign
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Search forwards through the history looking for a string which is typed    interactively.  Start with the current line. */
end_comment

begin_macro
name|rl_forward_search_history
argument_list|(
argument|sign
argument_list|,
argument|key
argument_list|)
end_macro

begin_decl_stmt
name|int
name|sign
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|key
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|rl_search_history
argument_list|(
name|sign
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Display the current state of the search in the echo-area.    SEARCH_STRING contains the string that is being searched for,    DIRECTION is zero for forward, or 1 for reverse,    WHERE is the history list number of the current line.  If it is    -1, then this line is the starting one. */
end_comment

begin_macro
name|rl_display_search
argument_list|(
argument|search_string
argument_list|,
argument|reverse_p
argument_list|,
argument|where
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|search_string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|reverse_p
decl_stmt|,
name|where
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|message
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
name|message
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|1
operator|+
operator|(
name|search_string
condition|?
name|strlen
argument_list|(
name|search_string
argument_list|)
else|:
literal|0
operator|)
operator|+
literal|30
argument_list|)
expr_stmt|;
operator|*
name|message
operator|=
literal|'\0'
expr_stmt|;
ifdef|#
directive|ifdef
name|NEVER
if|if
condition|(
name|where
operator|!=
operator|-
literal|1
condition|)
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"[%d]"
argument_list|,
name|where
operator|+
name|history_base
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|strcat
argument_list|(
name|message
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
if|if
condition|(
name|reverse_p
condition|)
name|strcat
argument_list|(
name|message
argument_list|,
literal|"reverse-"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|message
argument_list|,
literal|"i-search)`"
argument_list|)
expr_stmt|;
if|if
condition|(
name|search_string
condition|)
name|strcat
argument_list|(
name|message
argument_list|,
name|search_string
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|message
argument_list|,
literal|"': "
argument_list|)
expr_stmt|;
name|rl_message
argument_list|(
name|message
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rl_redisplay
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Search through the history looking for an interactively typed string.    This is analogous to i-search.  We start the search in the current line.    DIRECTION is which direction to search;> 0 means forward,< 0 means    backwards. */
end_comment

begin_macro
name|rl_search_history
argument_list|(
argument|direction
argument_list|,
argument|invoking_key
argument_list|)
end_macro

begin_decl_stmt
name|int
name|direction
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|invoking_key
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* The string that the user types in to search for. */
name|char
modifier|*
name|search_string
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|128
argument_list|)
decl_stmt|;
comment|/* The current length of SEARCH_STRING. */
name|int
name|search_string_index
decl_stmt|;
comment|/* The list of lines to search through. */
name|char
modifier|*
modifier|*
name|lines
decl_stmt|;
comment|/* The length of LINES. */
name|int
name|hlen
decl_stmt|;
comment|/* Where we get LINES from. */
name|HIST_ENTRY
modifier|*
modifier|*
name|hlist
init|=
name|history_list
argument_list|()
decl_stmt|;
name|int
name|orig_point
init|=
name|rl_point
decl_stmt|;
name|int
name|orig_line
init|=
name|where_history
argument_list|()
decl_stmt|;
name|int
name|last_found_line
init|=
name|orig_line
decl_stmt|;
name|int
name|c
decl_stmt|,
name|done
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|i
init|=
literal|0
decl_stmt|;
comment|/* The line currently being searched. */
name|char
modifier|*
name|sline
decl_stmt|;
comment|/* Offset in that line. */
name|int
name|index
decl_stmt|;
comment|/* Non-zero if we are doing a reverse search. */
name|int
name|reverse
init|=
operator|(
name|direction
operator|<
literal|0
operator|)
decl_stmt|;
comment|/* Create an arrary of pointers to the lines that we want to search. */
name|maybe_replace_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|hlist
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|hlist
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
empty_stmt|;
comment|/* Allocate space for this many lines, +1 for the current input line,      and remember those lines. */
name|lines
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|alloca
argument_list|(
operator|(
literal|1
operator|+
operator|(
name|hlen
operator|=
name|i
operator|)
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hlen
condition|;
name|i
operator|++
control|)
name|lines
index|[
name|i
index|]
operator|=
name|hlist
index|[
name|i
index|]
operator|->
name|line
expr_stmt|;
if|if
condition|(
name|saved_line_for_history
condition|)
name|lines
index|[
name|i
index|]
operator|=
name|saved_line_for_history
operator|->
name|line
expr_stmt|;
else|else
block|{
comment|/* So I have to type it in this way instead. */
name|lines
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|1
operator|+
name|strlen
argument_list|(
name|the_line
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|lines
index|[
name|i
index|]
argument_list|,
operator|&
name|the_line
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|hlen
operator|++
expr_stmt|;
comment|/* The line where we start the search. */
name|i
operator|=
name|orig_line
expr_stmt|;
comment|/* Initialize search parameters. */
operator|*
name|search_string
operator|=
literal|'\0'
expr_stmt|;
name|search_string_index
operator|=
literal|0
expr_stmt|;
name|rl_display_search
argument_list|(
name|search_string
argument_list|,
name|reverse
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sline
operator|=
name|the_line
expr_stmt|;
name|index
operator|=
name|rl_point
expr_stmt|;
while|while
condition|(
operator|!
name|done
condition|)
block|{
name|c
operator|=
name|rl_read_key
argument_list|(
name|in_stream
argument_list|)
expr_stmt|;
comment|/* Hack C to Do What I Mean. */
block|{
name|Function
modifier|*
name|f
init|=
operator|(
name|Function
operator|*
operator|)
name|NULL
decl_stmt|;
if|if
condition|(
name|keymap
index|[
name|c
index|]
operator|.
name|type
operator|==
name|ISFUNC
condition|)
name|f
operator|=
name|keymap
index|[
name|c
index|]
operator|.
name|function
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|rl_reverse_search_history
condition|)
name|c
operator|=
name|reverse
condition|?
operator|-
literal|1
else|:
operator|-
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|f
operator|==
name|rl_forward_search_history
condition|)
name|c
operator|=
operator|!
name|reverse
condition|?
operator|-
literal|1
else|:
operator|-
literal|2
expr_stmt|;
block|}
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|ESC
case|:
name|done
operator|=
literal|1
expr_stmt|;
continue|continue;
comment|/* case invoking_key: */
case|case
operator|-
literal|1
case|:
goto|goto
name|search_again
goto|;
comment|/* switch directions */
case|case
operator|-
literal|2
case|:
name|direction
operator|=
operator|-
name|direction
expr_stmt|;
name|reverse
operator|=
operator|(
name|direction
operator|<
literal|0
operator|)
expr_stmt|;
goto|goto
name|do_search
goto|;
case|case
name|CTRL
argument_list|(
literal|'G'
argument_list|)
case|:
name|strcpy
argument_list|(
name|the_line
argument_list|,
name|lines
index|[
name|orig_line
index|]
argument_list|)
expr_stmt|;
name|rl_point
operator|=
name|orig_point
expr_stmt|;
name|rl_end
operator|=
name|strlen
argument_list|(
name|the_line
argument_list|)
expr_stmt|;
name|rl_clear_message
argument_list|()
expr_stmt|;
return|return;
default|default:
if|if
condition|(
name|c
operator|<
literal|32
operator|||
name|c
operator|>
literal|126
condition|)
block|{
name|rl_execute_next
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|done
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|search_string
index|[
name|search_string_index
operator|++
index|]
operator|=
name|c
expr_stmt|;
name|search_string
index|[
name|search_string_index
index|]
operator|=
literal|'\0'
expr_stmt|;
goto|goto
name|do_search
goto|;
name|search_again
label|:
if|if
condition|(
operator|!
name|search_string_index
condition|)
continue|continue;
else|else
block|{
if|if
condition|(
name|reverse
condition|)
operator|--
name|index
expr_stmt|;
elseif|else
if|if
condition|(
name|index
operator|!=
name|strlen
argument_list|(
name|sline
argument_list|)
condition|)
operator|++
name|index
expr_stmt|;
else|else
name|ding
argument_list|()
expr_stmt|;
block|}
name|do_search
label|:
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|reverse
condition|)
block|{
while|while
condition|(
name|index
operator|>=
literal|0
condition|)
if|if
condition|(
name|strncmp
argument_list|(
name|search_string
argument_list|,
name|sline
operator|+
name|index
argument_list|,
name|search_string_index
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|string_found
goto|;
else|else
name|index
operator|--
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|int
name|limit
init|=
operator|(
name|strlen
argument_list|(
name|sline
argument_list|)
operator|-
name|search_string_index
operator|)
operator|+
literal|1
decl_stmt|;
while|while
condition|(
name|index
operator|<
name|limit
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|search_string
argument_list|,
name|sline
operator|+
name|index
argument_list|,
name|search_string_index
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|string_found
goto|;
name|index
operator|++
expr_stmt|;
block|}
block|}
name|next_line
label|:
name|i
operator|+=
name|direction
expr_stmt|;
comment|/* At limit for direction? */
if|if
condition|(
operator|(
name|reverse
operator|&&
name|i
operator|<
literal|0
operator|)
operator|||
operator|(
operator|!
name|reverse
operator|&&
name|i
operator|==
name|hlen
operator|)
condition|)
goto|goto
name|search_failed
goto|;
name|sline
operator|=
name|lines
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|reverse
condition|)
name|index
operator|=
name|strlen
argument_list|(
name|sline
argument_list|)
expr_stmt|;
else|else
name|index
operator|=
literal|0
expr_stmt|;
comment|/* If the search string is longer than the current 		     line, no match. */
if|if
condition|(
name|search_string_index
operator|>
name|strlen
argument_list|(
name|sline
argument_list|)
condition|)
goto|goto
name|next_line
goto|;
comment|/* Start actually searching. */
if|if
condition|(
name|reverse
condition|)
name|index
operator|-=
name|search_string_index
expr_stmt|;
block|}
name|search_failed
label|:
comment|/* We cannot find the search string.  Ding the bell. */
name|ding
argument_list|()
expr_stmt|;
name|i
operator|=
name|last_found_line
expr_stmt|;
break|break;
name|string_found
label|:
comment|/* We have found the search string.  Just display it.  But don't 		 actually move there in the history list until the user accepts 		 the location. */
name|strcpy
argument_list|(
name|the_line
argument_list|,
name|lines
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|rl_point
operator|=
name|index
expr_stmt|;
name|rl_end
operator|=
name|strlen
argument_list|(
name|the_line
argument_list|)
expr_stmt|;
name|last_found_line
operator|=
name|i
expr_stmt|;
name|rl_display_search
argument_list|(
name|search_string
argument_list|,
name|reverse
argument_list|,
operator|(
name|i
operator|==
name|orig_line
operator|)
condition|?
operator|-
literal|1
else|:
name|i
argument_list|)
expr_stmt|;
block|}
block|}
continue|continue;
block|}
comment|/* The user has won.  They found the string that they wanted.  Now all      we have to do is place them there. */
block|{
name|int
name|now
init|=
name|last_found_line
decl_stmt|;
comment|/* First put back the original state. */
name|strcpy
argument_list|(
name|the_line
argument_list|,
name|lines
index|[
name|orig_line
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|now
operator|<
name|orig_line
condition|)
name|rl_get_previous_history
argument_list|(
name|orig_line
operator|-
name|now
argument_list|)
expr_stmt|;
else|else
name|rl_get_next_history
argument_list|(
name|now
operator|-
name|orig_line
argument_list|)
expr_stmt|;
name|rl_point
operator|=
name|index
expr_stmt|;
name|rl_clear_message
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Make C be the next command to be executed. */
end_comment

begin_macro
name|rl_execute_next
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|int
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|rl_pending_input
operator|=
name|c
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Killing Mechanism			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* What we assume for a max number of kills. */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_MAX_KILLS
value|10
end_define

begin_comment
comment|/* The real variable to look at to find out when to flush kills. */
end_comment

begin_decl_stmt
name|int
name|rl_max_kills
init|=
name|DEFAULT_MAX_KILLS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Where to store killed text. */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|rl_kill_ring
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Where we are in the kill ring. */
end_comment

begin_decl_stmt
name|int
name|rl_kill_index
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* How many slots we have in the kill ring. */
end_comment

begin_decl_stmt
name|int
name|rl_kill_ring_length
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* How to say that you only want to save a certain amount    of kill material. */
end_comment

begin_macro
name|rl_set_retained_kills
argument_list|(
argument|num
argument_list|)
end_macro

begin_decl_stmt
name|int
name|num
decl_stmt|;
end_decl_stmt

begin_block
block|{}
end_block

begin_comment
comment|/* The way to kill something.  This appends or prepends to the last    kill, if the last command was a kill command.  if FROM is less    than TO, then the text is appended, otherwise prepended.  If the    last command was not a kill command, then a new slot is made for    this kill. */
end_comment

begin_macro
name|rl_kill_text
argument_list|(
argument|from
argument_list|,
argument|to
argument_list|)
end_macro

begin_decl_stmt
name|int
name|from
decl_stmt|,
name|to
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|slot
decl_stmt|;
name|char
modifier|*
name|text
init|=
name|rl_copy
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
decl_stmt|;
comment|/* Is there anything to kill? */
if|if
condition|(
name|from
operator|==
name|to
condition|)
block|{
name|free
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|last_command_was_kill
operator|++
expr_stmt|;
return|return;
block|}
comment|/* Delete the copied text from the line. */
name|rl_delete_text
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
comment|/* First, find the slot to work with. */
if|if
condition|(
operator|!
name|last_command_was_kill
condition|)
block|{
comment|/* Get a new slot.  */
if|if
condition|(
operator|!
name|rl_kill_ring
condition|)
block|{
comment|/* If we don't have any defined, then make one. */
name|rl_kill_ring
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
operator|(
name|rl_kill_ring_length
operator|=
literal|1
operator|)
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|slot
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* We have to add a new slot on the end, unless we have exceeded 	 the max limit for remembering kills. */
name|slot
operator|=
name|rl_kill_ring_length
expr_stmt|;
if|if
condition|(
name|slot
operator|==
name|rl_max_kills
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|free
argument_list|(
name|rl_kill_ring
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|slot
condition|;
name|i
operator|++
control|)
name|rl_kill_ring
index|[
name|i
index|]
operator|=
name|rl_kill_ring
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
name|rl_kill_ring
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|rl_kill_ring
argument_list|,
operator|(
operator|(
name|slot
operator|=
operator|(
name|rl_kill_ring_length
operator|+=
literal|1
operator|)
operator|)
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|slot
operator|--
expr_stmt|;
block|}
else|else
block|{
name|slot
operator|=
name|rl_kill_ring_length
operator|-
literal|1
expr_stmt|;
block|}
comment|/* If the last command was a kill, prepend or append. */
if|if
condition|(
name|last_command_was_kill
condition|)
block|{
name|char
modifier|*
name|old
init|=
name|rl_kill_ring
index|[
name|slot
index|]
decl_stmt|;
name|char
modifier|*
name|new
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
name|strlen
argument_list|(
name|old
argument_list|)
operator|+
name|strlen
argument_list|(
name|text
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|from
operator|<
name|to
condition|)
block|{
name|strcpy
argument_list|(
name|new
argument_list|,
name|old
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|new
argument_list|,
name|text
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strcpy
argument_list|(
name|new
argument_list|,
name|text
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|new
argument_list|,
name|old
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|old
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|rl_kill_ring
index|[
name|slot
index|]
operator|=
name|new
expr_stmt|;
block|}
else|else
block|{
name|rl_kill_ring
index|[
name|slot
index|]
operator|=
name|text
expr_stmt|;
block|}
name|rl_kill_index
operator|=
name|slot
expr_stmt|;
name|last_command_was_kill
operator|++
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Now REMEMBER!  In order to do prepending or appending correctly, kill    commands always make rl_point's original position be the FROM argument,    and rl_point's extent be the TO argument. */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Killing Commands			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Delete the word at point, saving the text in the kill ring. */
end_comment

begin_macro
name|rl_kill_word
argument_list|(
argument|count
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|orig_point
init|=
name|rl_point
decl_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
name|rl_backward_kill_word
argument_list|(
operator|-
name|count
argument_list|)
expr_stmt|;
else|else
block|{
name|rl_forward_word
argument_list|(
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|rl_point
operator|!=
name|orig_point
condition|)
name|rl_kill_text
argument_list|(
name|orig_point
argument_list|,
name|rl_point
argument_list|)
expr_stmt|;
name|rl_point
operator|=
name|orig_point
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Rubout the word before point, placing it on the kill ring. */
end_comment

begin_macro
name|rl_backward_kill_word
argument_list|(
argument|count
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|orig_point
init|=
name|rl_point
decl_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
name|rl_kill_word
argument_list|(
operator|-
name|count
argument_list|)
expr_stmt|;
else|else
block|{
name|rl_backward_word
argument_list|(
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|rl_point
operator|!=
name|orig_point
condition|)
name|rl_kill_text
argument_list|(
name|orig_point
argument_list|,
name|rl_point
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Kill from here to the end of the line.  If DIRECTION is negative, kill    back to the line start instead. */
end_comment

begin_macro
name|rl_kill_line
argument_list|(
argument|direction
argument_list|)
end_macro

begin_decl_stmt
name|int
name|direction
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|orig_point
init|=
name|rl_point
decl_stmt|;
if|if
condition|(
name|direction
operator|<
literal|0
condition|)
name|rl_backward_kill_line
argument_list|(
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
name|rl_end_of_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|orig_point
operator|!=
name|rl_point
condition|)
name|rl_kill_text
argument_list|(
name|orig_point
argument_list|,
name|rl_point
argument_list|)
expr_stmt|;
name|rl_point
operator|=
name|orig_point
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Kill backwards to the start of the line.  If DIRECTION is negative, kill    forwards to the line end instead. */
end_comment

begin_macro
name|rl_backward_kill_line
argument_list|(
argument|direction
argument_list|)
end_macro

begin_decl_stmt
name|int
name|direction
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|orig_point
init|=
name|rl_point
decl_stmt|;
if|if
condition|(
name|direction
operator|<
literal|0
condition|)
name|rl_kill_line
argument_list|(
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|rl_point
condition|)
name|ding
argument_list|()
expr_stmt|;
else|else
block|{
name|rl_beg_of_line
argument_list|()
expr_stmt|;
name|rl_kill_text
argument_list|(
name|orig_point
argument_list|,
name|rl_point
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/* Yank back the last killed text.  This ignores arguments. */
end_comment

begin_macro
name|rl_yank
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
operator|!
name|rl_kill_ring
condition|)
name|rl_abort
argument_list|()
expr_stmt|;
name|rl_insert_text
argument_list|(
name|rl_kill_ring
index|[
name|rl_kill_index
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* If the last command was yank, or yank_pop, and the text just    before point is identical to the current kill item, then    delete that text from the line, rotate the index down, and    yank back some other text. */
end_comment

begin_macro
name|rl_yank_pop
argument_list|()
end_macro

begin_block
block|{
name|int
name|l
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|rl_last_func
operator|!=
name|rl_yank_pop
operator|)
operator|&&
operator|(
name|rl_last_func
operator|!=
name|rl_yank
operator|)
operator|)
operator|||
operator|!
name|rl_kill_ring
condition|)
block|{
name|rl_abort
argument_list|()
expr_stmt|;
block|}
name|l
operator|=
name|strlen
argument_list|(
name|rl_kill_ring
index|[
name|rl_kill_index
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|rl_point
operator|-
name|l
operator|)
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|the_line
operator|+
operator|(
name|rl_point
operator|-
name|l
operator|)
argument_list|,
name|rl_kill_ring
index|[
name|rl_kill_index
index|]
argument_list|,
name|l
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|rl_delete_text
argument_list|(
operator|(
name|rl_point
operator|-
name|l
operator|)
argument_list|,
name|rl_point
argument_list|)
expr_stmt|;
name|rl_point
operator|-=
name|l
expr_stmt|;
name|rl_kill_index
operator|--
expr_stmt|;
if|if
condition|(
name|rl_kill_index
operator|<
literal|0
condition|)
name|rl_kill_index
operator|=
name|rl_kill_ring_length
operator|-
literal|1
expr_stmt|;
name|rl_yank
argument_list|()
expr_stmt|;
block|}
else|else
name|rl_abort
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Yank the COUNTth argument from the previous history line. */
end_comment

begin_macro
name|rl_yank_nth_arg
argument_list|(
argument|count
argument_list|,
argument|ignore
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|HIST_ENTRY
modifier|*
name|entry
init|=
name|previous_history
argument_list|()
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|;
if|if
condition|(
name|entry
condition|)
name|next_history
argument_list|()
expr_stmt|;
else|else
block|{
name|ding
argument_list|()
expr_stmt|;
return|return;
block|}
name|arg
operator|=
name|history_arg_extract
argument_list|(
name|count
argument_list|,
name|count
argument_list|,
name|entry
operator|->
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|arg
operator|||
operator|!
operator|*
name|arg
condition|)
block|{
name|ding
argument_list|()
expr_stmt|;
return|return;
block|}
name|rl_begin_undo_group
argument_list|()
expr_stmt|;
if|if
condition|(
name|rl_point
operator|&&
name|the_line
index|[
name|rl_point
operator|-
literal|1
index|]
operator|!=
literal|' '
condition|)
name|rl_insert_text
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|rl_insert_text
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|rl_end_undo_group
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Vi Mode. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|VI_MODE
end_ifdef

begin_include
include|#
directive|include
file|"vi_mode.c"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VI_MODE */
end_comment

begin_comment
comment|/* How to toggle back and forth between editing modes. */
end_comment

begin_macro
name|rl_vi_editing_mode
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|VI_MODE
name|rl_editing_mode
operator|=
name|vi_mode
expr_stmt|;
name|rl_vi_insertion_mode
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* VI_MODE */
block|}
end_block

begin_macro
name|rl_emacs_editing_mode
argument_list|()
end_macro

begin_block
block|{
name|rl_editing_mode
operator|=
name|emacs_mode
expr_stmt|;
name|keymap
operator|=
name|emacs_standard_keymap
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			     Completion				    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Non-zero means that case is not significant in completion. */
end_comment

begin_decl_stmt
name|int
name|completion_case_fold
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return an array of (char *) which is a list of completions for TEXT.    If there are no completions, return a NULL pointer.    The first entry in the returned array is the substitution for TEXT.     The remaining entries are the possible completions.    The array is terminated with a NULL pointer.     ENTRY_FUNCTION is a function of two args, and returns a (char *).      The first argument is TEXT.      The second is a state argument; it should be zero on the first call, and      non-zero on subsequent calls.  It returns a NULL pointer to the caller      when there are no more matches.  */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|completion_matches
parameter_list|(
name|text
parameter_list|,
name|entry_function
parameter_list|)
name|char
modifier|*
name|text
decl_stmt|;
function|char *
parameter_list|(
function|*entry_function
end_function

begin_expr_stmt
unit|)
operator|(
operator|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* Number of slots in match_list. */
name|int
name|match_list_size
decl_stmt|;
comment|/* The list of matches. */
name|char
modifier|*
modifier|*
name|match_list
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
operator|(
name|match_list_size
operator|=
literal|10
operator|)
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Number of matches actually found. */
name|int
name|matches
init|=
literal|0
decl_stmt|;
comment|/* Temporary string binder. */
name|char
modifier|*
name|string
decl_stmt|;
name|match_list
index|[
literal|1
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
while|while
condition|(
name|string
operator|=
call|(
modifier|*
name|entry_function
call|)
argument_list|(
name|text
argument_list|,
name|matches
argument_list|)
condition|)
block|{
if|if
condition|(
name|matches
operator|+
literal|1
operator|==
name|match_list_size
condition|)
name|match_list
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|match_list
argument_list|,
operator|(
operator|(
name|match_list_size
operator|+=
literal|10
operator|)
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|match_list
index|[
operator|++
name|matches
index|]
operator|=
name|string
expr_stmt|;
name|match_list
index|[
name|matches
operator|+
literal|1
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
comment|/* If there were any matches, then look through them finding out the      lowest common denominator.  That then becomes match_list[0]. */
if|if
condition|(
name|matches
condition|)
block|{
specifier|register
name|int
name|i
init|=
literal|1
decl_stmt|;
name|int
name|low
init|=
literal|100000
decl_stmt|;
comment|/* Count of max-matched characters. */
comment|/* If only one match, just use that. */
if|if
condition|(
name|matches
operator|==
literal|1
condition|)
block|{
name|match_list
index|[
literal|0
index|]
operator|=
name|match_list
index|[
literal|1
index|]
expr_stmt|;
name|match_list
index|[
literal|1
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* Otherwise, compare each member of the list with 	     the next, finding out where they stop matching. */
while|while
condition|(
name|i
operator|<
name|matches
condition|)
block|{
specifier|register
name|int
name|c1
decl_stmt|,
name|c2
decl_stmt|,
name|si
decl_stmt|;
if|if
condition|(
name|completion_case_fold
condition|)
block|{
for|for
control|(
name|si
operator|=
literal|0
init|;
operator|(
name|c1
operator|=
name|to_lower
argument_list|(
name|match_list
index|[
name|i
index|]
index|[
name|si
index|]
argument_list|)
operator|)
operator|&&
operator|(
name|c2
operator|=
name|to_lower
argument_list|(
name|match_list
index|[
name|i
operator|+
literal|1
index|]
index|[
name|si
index|]
argument_list|)
operator|)
condition|;
name|si
operator|++
control|)
if|if
condition|(
name|c1
operator|!=
name|c2
condition|)
break|break;
block|}
else|else
block|{
for|for
control|(
name|si
operator|=
literal|0
init|;
operator|(
name|c1
operator|=
name|match_list
index|[
name|i
index|]
index|[
name|si
index|]
operator|)
operator|&&
operator|(
name|c2
operator|=
name|match_list
index|[
name|i
operator|+
literal|1
index|]
index|[
name|si
index|]
operator|)
condition|;
name|si
operator|++
control|)
if|if
condition|(
name|c1
operator|!=
name|c2
condition|)
break|break;
block|}
if|if
condition|(
name|low
operator|>
name|si
condition|)
name|low
operator|=
name|si
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|match_list
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|low
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|match_list
index|[
literal|0
index|]
argument_list|,
name|match_list
index|[
literal|1
index|]
argument_list|,
name|low
argument_list|)
expr_stmt|;
name|match_list
index|[
literal|0
index|]
index|[
name|low
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
else|else
comment|/* There were no matches. */
block|{
name|free
argument_list|(
name|match_list
argument_list|)
expr_stmt|;
name|match_list
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|match_list
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Okay, now we write the entry_function for filename completion.  In the    general case.  Note that completion in the shell is a little different    because of all the pathnames that must be followed when looking up the    completion for a command. */
end_comment

begin_function
name|char
modifier|*
name|filename_completion_function
parameter_list|(
name|text
parameter_list|,
name|state
parameter_list|)
name|int
name|state
decl_stmt|;
name|char
modifier|*
name|text
decl_stmt|;
block|{
specifier|static
name|DIR
modifier|*
name|directory
decl_stmt|;
specifier|static
name|char
modifier|*
name|filename
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
specifier|static
name|char
modifier|*
name|dirname
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
specifier|static
name|char
modifier|*
name|users_dirname
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
specifier|static
name|int
name|filename_len
decl_stmt|;
name|struct
name|direct
modifier|*
name|entry
init|=
operator|(
expr|struct
name|direct
operator|*
operator|)
name|NULL
decl_stmt|;
comment|/* If we don't have any state, then do some initialization. */
if|if
condition|(
operator|!
name|state
condition|)
block|{
name|char
modifier|*
name|temp
decl_stmt|;
if|if
condition|(
name|dirname
condition|)
name|free
argument_list|(
name|dirname
argument_list|)
expr_stmt|;
if|if
condition|(
name|filename
condition|)
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|users_dirname
condition|)
name|free
argument_list|(
name|users_dirname
argument_list|)
expr_stmt|;
name|filename
operator|=
name|savestring
argument_list|(
name|text
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|text
condition|)
name|text
operator|=
literal|"."
expr_stmt|;
name|dirname
operator|=
name|savestring
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|temp
operator|=
name|rindex
argument_list|(
name|dirname
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
block|{
name|strcpy
argument_list|(
name|filename
argument_list|,
operator|++
name|temp
argument_list|)
expr_stmt|;
operator|*
name|temp
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
name|strcpy
argument_list|(
name|dirname
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
comment|/* We aren't done yet.  We also support the "~user" syntax. */
comment|/* Save the version of the directory that the user typed. */
name|users_dirname
operator|=
name|savestring
argument_list|(
name|dirname
argument_list|)
expr_stmt|;
block|{
name|char
modifier|*
name|tilde_expand
argument_list|()
decl_stmt|,
modifier|*
name|temp_dirname
init|=
name|tilde_expand
argument_list|(
name|dirname
argument_list|)
decl_stmt|;
name|free
argument_list|(
name|dirname
argument_list|)
expr_stmt|;
name|dirname
operator|=
name|temp_dirname
expr_stmt|;
ifdef|#
directive|ifdef
name|SHELL
block|{
specifier|extern
name|int
name|follow_symbolic_links
decl_stmt|;
name|char
modifier|*
name|make_absolute
parameter_list|()
function_decl|;
if|if
condition|(
name|follow_symbolic_links
operator|&&
operator|(
name|strcmp
argument_list|(
name|dirname
argument_list|,
literal|"."
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|temp_dirname
operator|=
name|make_absolute
argument_list|(
name|dirname
argument_list|,
name|get_working_directory
argument_list|(
literal|""
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp_dirname
condition|)
block|{
name|free
argument_list|(
name|dirname
argument_list|)
expr_stmt|;
name|dirname
operator|=
name|temp_dirname
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* SHELL */
block|}
name|directory
operator|=
name|opendir
argument_list|(
name|dirname
argument_list|)
expr_stmt|;
name|filename_len
operator|=
name|strlen
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|rl_filename_completion_desired
operator|=
literal|1
expr_stmt|;
block|}
comment|/* At this point we should entertain the possibility of hacking wildcarded      filenames, like /usr/man*\/te<TAB>.  If the directory name contains      globbing characters, then build an array of directories to glob on, and      glob on the first one. */
comment|/* Now that we have some state, we can read the directory. */
while|while
condition|(
name|directory
operator|&&
operator|(
name|entry
operator|=
name|readdir
argument_list|(
name|directory
argument_list|)
operator|)
condition|)
block|{
comment|/* Special case for no filename. 	 All entries except "." and ".." match. */
if|if
condition|(
operator|!
name|filename_len
condition|)
block|{
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|entry
operator|->
name|d_name
argument_list|,
literal|"."
argument_list|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|entry
operator|->
name|d_name
argument_list|,
literal|".."
argument_list|)
operator|!=
literal|0
operator|)
condition|)
break|break;
block|}
else|else
block|{
comment|/* Otherwise, if these match upto the length of filename, then 	     it is a match. */
ifdef|#
directive|ifdef
name|TMB_SYSV
if|if
condition|(
operator|(
name|strlen
argument_list|(
name|entry
operator|->
name|d_name
argument_list|)
operator|>=
name|filename_len
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|filename
argument_list|,
name|entry
operator|->
name|d_name
argument_list|,
name|filename_len
argument_list|)
operator|==
literal|0
operator|)
condition|)
else|#
directive|else
if|if
condition|(
operator|(
name|entry
operator|->
name|d_namlen
operator|>=
name|filename_len
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|filename
argument_list|,
name|entry
operator|->
name|d_name
argument_list|,
name|filename_len
argument_list|)
operator|==
literal|0
operator|)
condition|)
endif|#
directive|endif
comment|/* TMB_SYSV */
block|{
break|break;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|entry
condition|)
block|{
if|if
condition|(
name|directory
condition|)
block|{
name|closedir
argument_list|(
name|directory
argument_list|)
expr_stmt|;
name|directory
operator|=
operator|(
name|DIR
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|char
operator|*
operator|)
name|NULL
return|;
block|}
else|else
block|{
name|char
modifier|*
name|temp
decl_stmt|;
if|if
condition|(
name|dirname
operator|&&
operator|(
name|strcmp
argument_list|(
name|dirname
argument_list|,
literal|"."
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|TMB_SYSV
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
name|strlen
argument_list|(
name|users_dirname
argument_list|)
operator|+
name|strlen
argument_list|(
name|entry
operator|->
name|d_name
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
name|strlen
argument_list|(
name|users_dirname
argument_list|)
operator|+
name|entry
operator|->
name|d_namlen
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TMB_SYSV */
name|strcpy
argument_list|(
name|temp
argument_list|,
name|users_dirname
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp
argument_list|,
name|entry
operator|->
name|d_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|=
operator|(
name|savestring
argument_list|(
name|entry
operator|->
name|d_name
argument_list|)
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|temp
operator|)
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Binding keys				    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* rl_add_defun (char *name, Function *function, int key)    Add NAME to the list of named functions.  Make FUNCTION    be the function that gets called.    If KEY is not -1, then bind it. */
end_comment

begin_macro
name|rl_add_defun
argument_list|(
argument|name
argument_list|,
argument|function
argument_list|,
argument|key
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Function
modifier|*
name|function
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|key
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|key
operator|!=
operator|-
literal|1
condition|)
name|rl_bind_key
argument_list|(
name|key
argument_list|,
name|function
argument_list|)
expr_stmt|;
name|rl_add_funmap_entry
argument_list|(
name|name
argument_list|,
name|function
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Bind KEY to FUNCTION.  Returns non-zero if KEY is out of range. */
end_comment

begin_function
name|int
name|rl_bind_key
parameter_list|(
name|key
parameter_list|,
name|function
parameter_list|)
name|int
name|key
decl_stmt|;
name|Function
modifier|*
name|function
decl_stmt|;
block|{
if|if
condition|(
name|key
operator|<
literal|0
condition|)
return|return
operator|(
name|key
operator|)
return|;
if|if
condition|(
name|key
operator|>
literal|127
operator|&&
name|key
operator|<
literal|256
condition|)
block|{
if|if
condition|(
name|keymap
index|[
name|ESC
index|]
operator|.
name|type
operator|==
name|ISKMAP
condition|)
block|{
name|Keymap
name|escmap
init|=
operator|(
name|Keymap
operator|)
name|keymap
index|[
name|ESC
index|]
operator|.
name|function
decl_stmt|;
name|key
operator|-=
literal|128
expr_stmt|;
name|escmap
index|[
name|key
index|]
operator|.
name|type
operator|=
name|ISFUNC
expr_stmt|;
name|escmap
index|[
name|key
index|]
operator|.
name|function
operator|=
name|function
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|key
operator|)
return|;
block|}
name|keymap
index|[
name|key
index|]
operator|.
name|type
operator|=
name|ISFUNC
expr_stmt|;
name|keymap
index|[
name|key
index|]
operator|.
name|function
operator|=
name|function
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Bind KEY to FUNCTION in MAP.  Returns non-zero in case of invalid    KEY. */
end_comment

begin_function
name|int
name|rl_bind_key_in_map
parameter_list|(
name|key
parameter_list|,
name|function
parameter_list|,
name|map
parameter_list|)
name|int
name|key
decl_stmt|;
name|Function
modifier|*
name|function
decl_stmt|;
name|Keymap
name|map
decl_stmt|;
block|{
name|int
name|result
decl_stmt|;
name|Keymap
name|oldmap
init|=
name|keymap
decl_stmt|;
name|keymap
operator|=
name|map
expr_stmt|;
name|result
operator|=
name|rl_bind_key
argument_list|(
name|key
argument_list|,
name|function
argument_list|)
expr_stmt|;
name|keymap
operator|=
name|oldmap
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Make KEY do nothing in the currently selected keymap.    Returns non-zero in case of error. */
end_comment

begin_function
name|int
name|rl_unbind_key
parameter_list|(
name|key
parameter_list|)
name|int
name|key
decl_stmt|;
block|{
return|return
operator|(
name|rl_bind_key
argument_list|(
name|key
argument_list|,
operator|(
name|Function
operator|*
operator|)
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Make KEY do nothing in MAP.    Returns non-zero in case of error. */
end_comment

begin_function
name|int
name|rl_unbind_key_in_map
parameter_list|(
name|key
parameter_list|,
name|map
parameter_list|)
name|int
name|key
decl_stmt|;
name|Keymap
name|map
decl_stmt|;
block|{
return|return
operator|(
name|rl_bind_key_in_map
argument_list|(
name|key
argument_list|,
operator|(
name|Function
operator|*
operator|)
name|NULL
argument_list|,
name|map
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Bind the key sequence represented by the string KEYSEQ to    FUNCTION.  This makes new keymaps as necessary.  The initial    place to do bindings is in MAP. */
end_comment

begin_macro
name|rl_set_key
argument_list|(
argument|keyseq
argument_list|,
argument|function
argument_list|,
argument|map
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|keyseq
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Function
modifier|*
name|function
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Keymap
name|map
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|rl_generic_bind
argument_list|(
name|ISFUNC
argument_list|,
name|keyseq
argument_list|,
name|function
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Bind the key sequence represented by the string KEYSEQ to    the string of characters MACRO.  This makes new keymaps as    necessary.  The initial place to do bindings is in MAP. */
end_comment

begin_macro
name|rl_macro_bind
argument_list|(
argument|keyseq
argument_list|,
argument|macro
argument_list|,
argument|map
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|keyseq
decl_stmt|,
modifier|*
name|macro
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Keymap
name|map
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|macro_keys
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|2
operator|*
operator|(
name|strlen
argument_list|(
name|macro
argument_list|)
operator|)
argument_list|)
decl_stmt|;
name|int
name|macro_keys_len
decl_stmt|;
if|if
condition|(
name|rl_translate_keyseq
argument_list|(
name|macro
argument_list|,
name|macro_keys
argument_list|,
operator|&
name|macro_keys_len
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|macro_keys
argument_list|)
expr_stmt|;
return|return;
block|}
name|rl_generic_bind
argument_list|(
name|ISMACR
argument_list|,
name|keyseq
argument_list|,
name|macro_keys
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Bind the key sequence represented by the string KEYSEQ to    the arbitrary pointer DATA.  TYPE says what kind of data is    pointed to by DATA, right now this can be a function (ISFUNC),    a macro (ISMACR), or a keymap (ISKMAP).  This makes new keymaps    as necessary.  The initial place to do bindings is in MAP. */
end_comment

begin_macro
name|rl_generic_bind
argument_list|(
argument|type
argument_list|,
argument|keyseq
argument_list|,
argument|data
argument_list|,
argument|map
argument_list|)
end_macro

begin_decl_stmt
name|int
name|type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|keyseq
decl_stmt|,
modifier|*
name|data
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Keymap
name|map
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|keys
decl_stmt|;
name|int
name|keys_len
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|start
decl_stmt|;
comment|/* If no keys to bind to, exit right away. */
if|if
condition|(
operator|!
name|keyseq
operator|||
operator|!
operator|*
name|keyseq
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|ISMACR
condition|)
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return;
block|}
name|keys
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|1
operator|+
operator|(
literal|2
operator|*
name|strlen
argument_list|(
name|keyseq
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Translate the ASCII representation of KEYSEQ into an array      of characters.  Stuff the characters into ARRAY, and the      length of ARRAY into LENGTH. */
if|if
condition|(
name|rl_translate_keyseq
argument_list|(
name|keyseq
argument_list|,
name|keys
argument_list|,
operator|&
name|keys_len
argument_list|)
condition|)
return|return;
comment|/* Handle mapping of the ESC Key in vi mode */
name|start
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|VI_MODE
if|if
condition|(
operator|(
name|rl_editing_mode
operator|==
name|vi_mode
operator|)
operator|&&
operator|(
name|keys
index|[
literal|0
index|]
operator|==
name|ESC
operator|)
condition|)
block|{
name|start
operator|++
expr_stmt|;
name|map
operator|=
name|vi_movement_keymap
expr_stmt|;
if|if
condition|(
name|keys
index|[
literal|1
index|]
operator|==
name|ESC
condition|)
block|{
specifier|extern
name|KEYMAP_ENTRY_ARRAY
name|vi_escape_keymap
decl_stmt|;
name|start
operator|++
expr_stmt|;
name|map
operator|=
name|vi_escape_keymap
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* Bind keys, making new keymaps as necessary. */
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<
name|keys_len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|+
literal|1
operator|<
name|keys_len
condition|)
block|{
if|if
condition|(
name|map
index|[
name|keys
index|[
name|i
index|]
index|]
operator|.
name|type
operator|!=
name|ISKMAP
condition|)
block|{
if|if
condition|(
name|map
index|[
name|i
index|]
operator|.
name|type
operator|==
name|ISMACR
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|map
index|[
name|i
index|]
operator|.
name|function
argument_list|)
expr_stmt|;
name|map
index|[
name|keys
index|[
name|i
index|]
index|]
operator|.
name|type
operator|=
name|ISKMAP
expr_stmt|;
name|map
index|[
name|keys
index|[
name|i
index|]
index|]
operator|.
name|function
operator|=
operator|(
name|Function
operator|*
operator|)
name|rl_make_bare_keymap
argument_list|()
expr_stmt|;
block|}
name|map
operator|=
operator|(
name|Keymap
operator|)
name|map
index|[
name|keys
index|[
name|i
index|]
index|]
operator|.
name|function
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|map
index|[
name|keys
index|[
name|i
index|]
index|]
operator|.
name|type
operator|==
name|ISMACR
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|map
index|[
name|keys
index|[
name|i
index|]
index|]
operator|.
name|function
argument_list|)
expr_stmt|;
name|map
index|[
name|keys
index|[
name|i
index|]
index|]
operator|.
name|function
operator|=
operator|(
name|Function
operator|*
operator|)
name|data
expr_stmt|;
name|map
index|[
name|keys
index|[
name|i
index|]
index|]
operator|.
name|type
operator|=
name|type
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/* Translate the ASCII representation of SEQ, stuffing the    values into ARRAY, an array of characters.  LEN gets the    final length of ARRAY.  Return non-zero if there was an    error parsing SEQ. */
end_comment

begin_macro
name|rl_translate_keyseq
argument_list|(
argument|seq
argument_list|,
argument|array
argument_list|,
argument|len
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|seq
decl_stmt|,
modifier|*
name|array
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|c
decl_stmt|,
name|l
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|c
operator|=
name|seq
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|c
operator|=
name|seq
index|[
operator|++
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|c
condition|)
break|break;
if|if
condition|(
operator|(
operator|(
name|c
operator|==
literal|'C'
operator|||
name|c
operator|==
literal|'M'
operator|)
operator|&&
name|seq
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|'-'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'e'
operator|)
condition|)
block|{
comment|/* Handle special case of backwards define. */
if|if
condition|(
name|strncmp
argument_list|(
operator|&
name|seq
index|[
name|i
index|]
argument_list|,
literal|"C-\\M-"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|array
index|[
name|l
operator|++
index|]
operator|=
name|ESC
expr_stmt|;
name|i
operator|+=
literal|5
expr_stmt|;
name|array
index|[
name|l
operator|++
index|]
operator|=
name|CTRL
argument_list|(
name|to_upper
argument_list|(
name|seq
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|seq
index|[
name|i
index|]
condition|)
name|i
operator|--
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'M'
case|:
name|i
operator|++
expr_stmt|;
name|array
index|[
name|l
operator|++
index|]
operator|=
name|ESC
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|i
operator|+=
literal|2
expr_stmt|;
name|array
index|[
name|l
operator|++
index|]
operator|=
name|CTRL
argument_list|(
name|to_upper
argument_list|(
name|seq
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|array
index|[
name|l
operator|++
index|]
operator|=
name|ESC
expr_stmt|;
block|}
continue|continue;
block|}
block|}
name|array
index|[
name|l
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
name|array
index|[
name|l
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|len
operator|=
name|l
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Return a pointer to the function that STRING represents.    If STRING doesn't have a matching function, then a NULL pointer    is returned. */
end_comment

begin_function
name|Function
modifier|*
name|rl_named_function
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|static
name|int
name|stricmp
parameter_list|()
function_decl|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|funmap
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|stricmp
argument_list|(
name|funmap
index|[
name|i
index|]
operator|->
name|name
argument_list|,
name|string
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|funmap
index|[
name|i
index|]
operator|->
name|function
operator|)
return|;
return|return
operator|(
operator|(
name|Function
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* The last key bindings file read. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|last_readline_init_file
init|=
literal|"~/.inputrc"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Re-read the current keybindings file. */
end_comment

begin_macro
name|rl_re_read_init_file
argument_list|(
argument|count
argument_list|,
argument|ignore
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|,
name|ignore
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|rl_read_init_file
argument_list|(
name|last_readline_init_file
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Do key bindings from a file.  If FILENAME is NULL it defaults    to `~/.inputrc'.  If the file existed and could be opened and    read, 0 is returned, otherwise errno is returned. */
end_comment

begin_function
name|int
name|rl_read_init_file
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|int
name|line_size
decl_stmt|,
name|line_index
decl_stmt|;
name|char
modifier|*
name|line
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|line_size
operator|=
literal|100
argument_list|)
decl_stmt|;
name|char
modifier|*
name|openname
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|c
decl_stmt|;
comment|/* Default the filename. */
if|if
condition|(
operator|!
name|filename
condition|)
name|filename
operator|=
literal|"~/.inputrc"
expr_stmt|;
name|openname
operator|=
name|tilde_expand
argument_list|(
name|filename
argument_list|)
expr_stmt|;
comment|/* Open the file. */
name|file
operator|=
name|fopen
argument_list|(
name|openname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|openname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|file
condition|)
return|return
operator|(
name|errno
operator|)
return|;
name|last_readline_init_file
operator|=
name|filename
expr_stmt|;
comment|/* Loop reading lines from the file.  Lines that start with `#' are      comments, all other lines are commands for readline initialization. */
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|file
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
comment|/* If comment, flush to EOL. */
if|if
condition|(
name|c
operator|==
literal|'#'
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|file
argument_list|)
operator|)
operator|!=
name|EOF
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
empty_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
goto|goto
name|function_exit
goto|;
continue|continue;
block|}
comment|/* Otherwise, this is the start of a line.  Read the 	 line from the file. */
name|line_index
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|c
operator|!=
name|EOF
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
block|{
name|line
index|[
name|line_index
operator|++
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|line_index
operator|==
name|line_size
condition|)
name|line
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|line
argument_list|,
name|line_size
operator|+=
literal|100
argument_list|)
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
name|line
index|[
name|line_index
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Parse the line. */
name|rl_parse_and_bind
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
name|function_exit
label|:
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
comment|/* Close up the file and exit. */
name|fclose
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Parser Directives       		    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Conditionals. */
end_comment

begin_comment
comment|/* Calling programs set this to have their argv[0]. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|rl_readline_name
init|=
literal|"other"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stack of previous values of parsing_conditionalized_out. */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|char
modifier|*
name|if_stack
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|if_stack_depth
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|if_stack_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Push parsing_conditionalized_out, and set parser state based on ARGS. */
end_comment

begin_macro
name|parser_if
argument_list|(
argument|args
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|args
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|static
name|int
name|stricmp
parameter_list|()
function_decl|;
comment|/* Push parser state. */
if|if
condition|(
name|if_stack_depth
operator|+
literal|1
operator|>=
name|if_stack_size
condition|)
block|{
if|if
condition|(
operator|!
name|if_stack
condition|)
name|if_stack
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|if_stack_size
operator|=
literal|20
argument_list|)
expr_stmt|;
else|else
name|if_stack
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|if_stack
argument_list|,
name|if_stack_size
operator|+=
literal|20
argument_list|)
expr_stmt|;
block|}
name|if_stack
index|[
name|if_stack_depth
operator|++
index|]
operator|=
name|parsing_conditionalized_out
expr_stmt|;
comment|/* We only check to see if the first word in ARGS is the same as the      value stored in rl_readline_name. */
comment|/* Isolate first argument. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|args
index|[
name|i
index|]
operator|&&
operator|!
name|whitespace
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|args
index|[
name|i
index|]
condition|)
name|args
index|[
name|i
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|stricmp
argument_list|(
name|args
argument_list|,
name|rl_readline_name
argument_list|)
operator|==
literal|0
condition|)
name|parsing_conditionalized_out
operator|=
literal|0
expr_stmt|;
else|else
name|parsing_conditionalized_out
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Invert the current parser state if there is anything on the stack. */
end_comment

begin_macro
name|parser_else
argument_list|(
argument|args
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|args
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|if_stack_depth
condition|)
name|parsing_conditionalized_out
operator|=
operator|!
name|parsing_conditionalized_out
expr_stmt|;
else|else
block|{
comment|/* *** What, no error message? *** */
block|}
block|}
end_block

begin_comment
comment|/* Terminate a conditional, popping the value of    parsing_conditionalized_out from the stack. */
end_comment

begin_macro
name|parser_endif
argument_list|(
argument|args
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|args
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|if_stack_depth
condition|)
name|parsing_conditionalized_out
operator|=
name|if_stack
index|[
operator|--
name|if_stack_depth
index|]
expr_stmt|;
else|else
block|{
comment|/* *** What, no error message? *** */
block|}
block|}
end_block

begin_comment
comment|/* Associate textual names with actual functions. */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|Function
modifier|*
name|function
decl_stmt|;
block|}
name|parser_directives
index|[]
init|=
block|{
block|{
literal|"if"
block|,
name|parser_if
block|}
block|,
block|{
literal|"endif"
block|,
name|parser_endif
block|}
block|,
block|{
literal|"else"
block|,
name|parser_else
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|0x0
block|,
operator|(
name|Function
operator|*
operator|)
literal|0x0
block|}
block|}
struct|;
end_struct

begin_comment
comment|/* Handle a parser directive.  STATEMENT is the line of the directive    without any leading `$'. */
end_comment

begin_function
specifier|static
name|int
name|handle_parser_directive
parameter_list|(
name|statement
parameter_list|)
name|char
modifier|*
name|statement
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|directive
decl_stmt|,
modifier|*
name|args
decl_stmt|;
specifier|static
name|int
name|stricmp
parameter_list|()
function_decl|;
comment|/* Isolate the actual directive. */
comment|/* Skip whitespace. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|whitespace
argument_list|(
name|statement
index|[
name|i
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
name|directive
operator|=
operator|&
name|statement
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
init|;
name|statement
index|[
name|i
index|]
operator|&&
operator|!
name|whitespace
argument_list|(
name|statement
index|[
name|i
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|statement
index|[
name|i
index|]
condition|)
name|statement
index|[
name|i
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
init|;
name|statement
index|[
name|i
index|]
operator|&&
name|whitespace
argument_list|(
name|statement
index|[
name|i
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
name|args
operator|=
operator|&
name|statement
index|[
name|i
index|]
expr_stmt|;
comment|/* Lookup the command, and act on it. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|parser_directives
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|stricmp
argument_list|(
name|directive
argument_list|,
name|parser_directives
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
operator|*
name|parser_directives
index|[
name|i
index|]
operator|.
name|function
operator|)
operator|(
name|args
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* *** Should an error message be output? */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Read the binding command from STRING and perform it.    A key binding command looks like: Keyname: function-name\0,    a variable binding command looks like: set variable value.    A new-style keybinding looks like "\C-x\C-x": exchange-point-and-mark. */
end_comment

begin_macro
name|rl_parse_and_bind
argument_list|(
argument|string
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|char
modifier|*
name|possible_control_prefixes
index|[]
decl_stmt|,
modifier|*
name|possible_meta_prefixes
index|[]
decl_stmt|;
name|char
modifier|*
name|funname
decl_stmt|,
modifier|*
name|kname
decl_stmt|;
specifier|static
name|int
name|substring_member_of_array
argument_list|()
decl_stmt|,
name|stricmp
argument_list|()
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|int
name|key
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|string
operator|||
operator|!
operator|*
name|string
operator|||
operator|*
name|string
operator|==
literal|'#'
condition|)
return|return;
comment|/* If this is a parser directive, act on it. */
if|if
condition|(
operator|*
name|string
operator|==
literal|'$'
condition|)
block|{
name|handle_parser_directive
argument_list|(
operator|&
name|string
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If we are supposed to be skipping parsing right now, then do it. */
if|if
condition|(
name|parsing_conditionalized_out
condition|)
return|return;
name|i
operator|=
literal|0
expr_stmt|;
comment|/* If this keyname is a complex key expression surrounded by quotes,      advance to after the matching close quote. */
if|if
condition|(
operator|*
name|string
operator|==
literal|'"'
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|c
operator|=
name|string
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|c
operator|==
literal|'"'
operator|&&
name|string
index|[
name|i
operator|-
literal|1
index|]
operator|!=
literal|'\\'
condition|)
break|break;
block|}
block|}
comment|/* Advance to the colon (:) or whitespace which separates the two objects. */
for|for
control|(
init|;
operator|(
name|c
operator|=
name|string
index|[
name|i
index|]
operator|)
operator|&&
name|c
operator|!=
literal|':'
operator|&&
name|c
operator|!=
literal|' '
operator|&&
name|c
operator|!=
literal|'\t'
condition|;
name|i
operator|++
control|)
empty_stmt|;
comment|/* Mark the end of the command (or keyname). */
if|if
condition|(
name|string
index|[
name|i
index|]
condition|)
name|string
index|[
name|i
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* If this is a command to set a variable, then do that. */
if|if
condition|(
name|stricmp
argument_list|(
name|string
argument_list|,
literal|"set"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|var
init|=
name|string
operator|+
name|i
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
comment|/* Make VAR point to start of variable name. */
while|while
condition|(
operator|*
name|var
operator|&&
name|whitespace
argument_list|(
operator|*
name|var
argument_list|)
condition|)
name|var
operator|++
expr_stmt|;
comment|/* Make value point to start of value string. */
name|value
operator|=
name|var
expr_stmt|;
while|while
condition|(
operator|*
name|value
operator|&&
operator|!
name|whitespace
argument_list|(
operator|*
name|value
argument_list|)
condition|)
name|value
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|value
condition|)
operator|*
name|value
operator|++
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
operator|*
name|value
operator|&&
name|whitespace
argument_list|(
operator|*
name|value
argument_list|)
condition|)
name|value
operator|++
expr_stmt|;
name|rl_variable_bind
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Skip any whitespace between keyname and funname. */
for|for
control|(
init|;
name|string
index|[
name|i
index|]
operator|&&
name|whitespace
argument_list|(
name|string
index|[
name|i
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
name|funname
operator|=
operator|&
name|string
index|[
name|i
index|]
expr_stmt|;
comment|/* Now isolate funname.      For straight function names just look for whitespace, since      that will signify the end of the string.  But this could be a      macro definition.  In that case, the string is quoted, so skip      to the matching delimiter. */
if|if
condition|(
operator|*
name|funname
operator|==
literal|'\''
operator|||
operator|*
name|funname
operator|==
literal|'"'
condition|)
block|{
name|int
name|delimiter
init|=
name|string
index|[
name|i
operator|++
index|]
decl_stmt|;
for|for
control|(
init|;
name|c
operator|=
name|string
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|c
operator|==
name|delimiter
operator|&&
name|string
index|[
name|i
operator|-
literal|1
index|]
operator|!=
literal|'\\'
condition|)
break|break;
block|}
if|if
condition|(
name|c
condition|)
name|i
operator|++
expr_stmt|;
block|}
comment|/* Advance to the end of the string.  */
for|for
control|(
init|;
name|string
index|[
name|i
index|]
operator|&&
operator|!
name|whitespace
argument_list|(
name|string
index|[
name|i
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
comment|/* No extra whitespace at the end of the string. */
name|string
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* If this is a new-style key-binding, then do the binding with      rl_set_key ().  Otherwise, let the older code deal with it. */
if|if
condition|(
operator|*
name|string
operator|==
literal|'"'
condition|)
block|{
name|char
modifier|*
name|seq
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|1
operator|+
name|strlen
argument_list|(
name|string
argument_list|)
argument_list|)
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|,
name|k
init|=
literal|0
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|string
index|[
name|j
index|]
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|string
index|[
name|j
index|]
operator|==
literal|'"'
operator|&&
name|string
index|[
name|j
operator|-
literal|1
index|]
operator|!=
literal|'\\'
condition|)
break|break;
name|seq
index|[
name|k
operator|++
index|]
operator|=
name|string
index|[
name|j
index|]
expr_stmt|;
block|}
name|seq
index|[
name|k
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Binding macro? */
if|if
condition|(
operator|*
name|funname
operator|==
literal|'\''
operator|||
operator|*
name|funname
operator|==
literal|'"'
condition|)
block|{
name|j
operator|=
name|strlen
argument_list|(
name|funname
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|&&
name|funname
index|[
name|j
operator|-
literal|1
index|]
operator|==
operator|*
name|funname
condition|)
name|funname
index|[
name|j
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|rl_macro_bind
argument_list|(
name|seq
argument_list|,
operator|&
name|funname
index|[
literal|1
index|]
argument_list|,
name|keymap
argument_list|)
expr_stmt|;
block|}
else|else
name|rl_set_key
argument_list|(
name|seq
argument_list|,
name|rl_named_function
argument_list|(
name|funname
argument_list|)
argument_list|,
name|keymap
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Get the actual character we want to deal with. */
name|kname
operator|=
name|rindex
argument_list|(
name|string
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|kname
condition|)
name|kname
operator|=
name|string
expr_stmt|;
else|else
name|kname
operator|++
expr_stmt|;
name|key
operator|=
name|glean_key_from_name
argument_list|(
name|kname
argument_list|)
expr_stmt|;
comment|/* Add in control and meta bits. */
if|if
condition|(
name|substring_member_of_array
argument_list|(
name|string
argument_list|,
name|possible_control_prefixes
argument_list|)
condition|)
name|key
operator|=
name|CTRL
argument_list|(
name|to_upper
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|substring_member_of_array
argument_list|(
name|string
argument_list|,
name|possible_meta_prefixes
argument_list|)
condition|)
name|key
operator|=
name|META
argument_list|(
name|key
argument_list|)
expr_stmt|;
comment|/* Temporary.  Handle old-style keyname with macro-binding. */
if|if
condition|(
operator|*
name|funname
operator|==
literal|'\''
operator|||
operator|*
name|funname
operator|==
literal|'"'
condition|)
block|{
name|char
name|seq
index|[
literal|2
index|]
decl_stmt|;
name|int
name|fl
init|=
name|strlen
argument_list|(
name|funname
argument_list|)
decl_stmt|;
name|seq
index|[
literal|0
index|]
operator|=
name|key
expr_stmt|;
name|seq
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|fl
operator|&&
name|funname
index|[
name|fl
operator|-
literal|1
index|]
operator|==
operator|*
name|funname
condition|)
name|funname
index|[
name|fl
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|rl_macro_bind
argument_list|(
name|seq
argument_list|,
operator|&
name|funname
index|[
literal|1
index|]
argument_list|,
name|keymap
argument_list|)
expr_stmt|;
block|}
else|else
name|rl_bind_key
argument_list|(
name|key
argument_list|,
name|rl_named_function
argument_list|(
name|funname
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|rl_variable_bind
argument_list|(
argument|name
argument_list|,
argument|value
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|value
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|int
name|strnicmp
argument_list|()
decl_stmt|,
name|stricmp
argument_list|()
decl_stmt|;
if|if
condition|(
name|stricmp
argument_list|(
name|name
argument_list|,
literal|"editing-mode"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|strnicmp
argument_list|(
name|value
argument_list|,
literal|"vi"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|VI_MODE
name|keymap
operator|=
name|vi_insertion_keymap
expr_stmt|;
name|rl_editing_mode
operator|=
name|vi_mode
expr_stmt|;
endif|#
directive|endif
comment|/* VI_MODE */
block|}
elseif|else
if|if
condition|(
name|strnicmp
argument_list|(
name|value
argument_list|,
literal|"emacs"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|keymap
operator|=
name|emacs_standard_keymap
expr_stmt|;
name|rl_editing_mode
operator|=
name|emacs_mode
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|stricmp
argument_list|(
name|name
argument_list|,
literal|"horizontal-scroll-mode"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|*
name|value
operator|||
name|stricmp
argument_list|(
name|value
argument_list|,
literal|"On"
argument_list|)
operator|==
literal|0
condition|)
name|horizontal_scroll_mode
operator|=
literal|1
expr_stmt|;
else|else
name|horizontal_scroll_mode
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Return the character which matches NAME.    For example, `Space' returns ' '. */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|value
decl_stmt|;
block|}
name|assoc_list
typedef|;
end_typedef

begin_decl_stmt
name|assoc_list
name|name_key_alist
index|[]
init|=
block|{
block|{
literal|"Space"
block|,
literal|' '
block|}
block|,
block|{
literal|"SPC"
block|,
literal|' '
block|}
block|,
block|{
literal|"Rubout"
block|,
literal|0x7f
block|}
block|,
block|{
literal|"DEL"
block|,
literal|0x7f
block|}
block|,
block|{
literal|"Tab"
block|,
literal|0x09
block|}
block|,
block|{
literal|"Newline"
block|,
literal|'\n'
block|}
block|,
block|{
literal|"Return"
block|,
literal|'\r'
block|}
block|,
block|{
literal|"RET"
block|,
literal|'\r'
block|}
block|,
block|{
literal|"LFD"
block|,
literal|'\n'
block|}
block|,
block|{
literal|"Escape"
block|,
literal|'\033'
block|}
block|,
block|{
literal|"ESC"
block|,
literal|'\033'
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|0x0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|glean_key_from_name
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|static
name|int
name|stricmp
parameter_list|()
function_decl|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|name_key_alist
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|stricmp
argument_list|(
name|name
argument_list|,
name|name_key_alist
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|name_key_alist
index|[
name|i
index|]
operator|.
name|value
operator|)
return|;
return|return
operator|(
operator|*
name|name
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			String Utility Functions		    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Return non-zero if any members of ARRAY are a substring in STRING. */
end_comment

begin_function
specifier|static
name|int
name|substring_member_of_array
parameter_list|(
name|string
parameter_list|,
name|array
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|,
decl|*
modifier|*
name|array
decl_stmt|;
end_function

begin_block
block|{
specifier|static
name|char
modifier|*
name|strindex
parameter_list|()
function_decl|;
while|while
condition|(
operator|*
name|array
condition|)
block|{
if|if
condition|(
name|strindex
argument_list|(
name|string
argument_list|,
operator|*
name|array
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|array
operator|++
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Whoops, Unix doesn't have strnicmp. */
end_comment

begin_comment
comment|/* Compare at most COUNT characters from string1 to string2.  Case    doesn't matter. */
end_comment

begin_function
specifier|static
name|int
name|strnicmp
parameter_list|(
name|string1
parameter_list|,
name|string2
parameter_list|,
name|count
parameter_list|)
name|char
modifier|*
name|string1
decl_stmt|,
decl|*
name|string2
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|char
name|ch1
decl_stmt|,
name|ch2
decl_stmt|;
while|while
condition|(
name|count
condition|)
block|{
name|ch1
operator|=
operator|*
name|string1
operator|++
expr_stmt|;
name|ch2
operator|=
operator|*
name|string2
operator|++
expr_stmt|;
if|if
condition|(
name|to_upper
argument_list|(
name|ch1
argument_list|)
operator|==
name|to_upper
argument_list|(
name|ch2
argument_list|)
condition|)
name|count
operator|--
expr_stmt|;
else|else
break|break;
block|}
return|return
operator|(
name|count
operator|)
return|;
block|}
end_block

begin_comment
comment|/* strcmp (), but caseless. */
end_comment

begin_function
specifier|static
name|int
name|stricmp
parameter_list|(
name|string1
parameter_list|,
name|string2
parameter_list|)
name|char
modifier|*
name|string1
decl_stmt|,
decl|*
name|string2
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|char
name|ch1
decl_stmt|,
name|ch2
decl_stmt|;
while|while
condition|(
operator|*
name|string1
operator|&&
operator|*
name|string2
condition|)
block|{
name|ch1
operator|=
operator|*
name|string1
operator|++
expr_stmt|;
name|ch2
operator|=
operator|*
name|string2
operator|++
expr_stmt|;
if|if
condition|(
name|to_upper
argument_list|(
name|ch1
argument_list|)
operator|!=
name|to_upper
argument_list|(
name|ch2
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
operator|*
name|string1
operator||
operator|*
name|string2
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Determine if s2 occurs in s1.  If so, return a pointer to the    match in s1.  The compare is case insensitive. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|strindex
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
specifier|register
name|char
modifier|*
name|s1
decl_stmt|,
decl|*
name|s2
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|l
init|=
name|strlen
argument_list|(
name|s2
argument_list|)
decl_stmt|;
specifier|register
name|int
name|len
init|=
name|strlen
argument_list|(
name|s1
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|len
operator|-
name|i
operator|)
operator|>=
name|l
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strnicmp
argument_list|(
operator|&
name|s1
index|[
name|i
index|]
argument_list|,
name|s2
argument_list|,
name|l
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|s1
operator|+
name|i
operator|)
return|;
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|STATIC_MALLOC
end_ifdef

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			xmalloc and xrealloc ()		     	    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|xmalloc
parameter_list|(
name|bytes
parameter_list|)
name|int
name|bytes
decl_stmt|;
block|{
specifier|static
name|memory_error_and_abort
argument_list|()
expr_stmt|;
name|char
modifier|*
name|temp
init|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|bytes
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|temp
condition|)
name|memory_error_and_abort
argument_list|()
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|xrealloc
parameter_list|(
name|pointer
parameter_list|,
name|bytes
parameter_list|)
name|char
modifier|*
name|pointer
decl_stmt|;
name|int
name|bytes
decl_stmt|;
block|{
specifier|static
name|memory_error_and_abort
argument_list|()
expr_stmt|;
name|char
modifier|*
name|temp
init|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
name|pointer
argument_list|,
name|bytes
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|temp
condition|)
name|memory_error_and_abort
argument_list|()
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|memory_error_and_abort
argument_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"readline: Out of virtual memory!\n"
argument_list|)
block|;
name|abort
argument_list|()
block|; }
endif|#
directive|endif
comment|/* STATIC_MALLOC */
comment|/* **************************************************************** */
comment|/*								    */
comment|/*			Testing Readline			    */
comment|/*								    */
comment|/* **************************************************************** */
ifdef|#
directive|ifdef
name|TEST
expr|main
operator|(
operator|)
block|{
name|HIST_ENTRY
operator|*
operator|*
name|history_list
argument_list|()
block|;
name|char
operator|*
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
block|;
name|char
operator|*
name|prompt
operator|=
literal|"readline% "
block|;
name|int
name|done
operator|=
literal|0
block|;
while|while
condition|(
operator|!
name|done
condition|)
block|{
name|temp
operator|=
name|readline
argument_list|(
name|prompt
argument_list|)
expr_stmt|;
comment|/* Test for EOF. */
if|if
condition|(
operator|!
name|temp
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* If there is anything on the line, print it and remember it. */
if|if
condition|(
operator|*
name|temp
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\r\n"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|add_history
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_comment
comment|/* Check for `command' that we handle. */
end_comment

begin_if
if|if
condition|(
name|strcmp
argument_list|(
name|temp
argument_list|,
literal|"quit"
argument_list|)
operator|==
literal|0
condition|)
name|done
operator|=
literal|1
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|strcmp
argument_list|(
name|temp
argument_list|,
literal|"list"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|HIST_ENTRY
modifier|*
modifier|*
name|list
init|=
name|history_list
argument_list|()
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|list
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|list
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d: %s\r\n"
argument_list|,
name|i
argument_list|,
name|list
index|[
name|i
index|]
operator|->
name|line
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|list
index|[
name|i
index|]
operator|->
name|line
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
block|}
end_if

begin_expr_stmt
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
unit|} }
endif|#
directive|endif
end_endif

begin_comment
comment|/* TEST */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  * Local variables:  * compile-command: "gcc -g -traditional -I. -I.. -DTEST -o readline readline.c keymaps.o funmap.o history.o -ltermcap"  * end:  */
end_comment

end_unit

