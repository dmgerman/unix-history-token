begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* History.c -- standalone history library */
end_comment

begin_comment
comment|/* Copyright (C) 1989 Free Software Foundation, Inc.     This file contains the GNU History Library (the Library), a set of    routines for managing the text of previously typed lines.     The Library is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 1, or (at your option)    any later version.     The Library is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     The GNU General Public License is often shipped with GNU software, and    is generally kept in a file called COPYING or LICENSE.  If you do not    have a copy of the license, write to the Free Software Foundation,    675 Mass Ave, Cambridge, MA 02139, USA. */
end_comment

begin_comment
comment|/* The goal is to make the implementation transparent, so that you    don't have to know what data types are used, just what functions    you can call.  I think I have done that. */
end_comment

begin_comment
comment|/* Remove these declarations when we have a complete libgnu.a. */
end_comment

begin_define
define|#
directive|define
name|STATIC_MALLOC
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|STATIC_MALLOC
end_ifndef

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|xmalloc
argument_list|()
decl_stmt|,
modifier|*
name|xrealloc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|char
modifier|*
name|xmalloc
argument_list|()
decl_stmt|,
modifier|*
name|xrealloc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_define
define|#
directive|define
name|alloca
value|__builtin_alloca
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|defined
argument_list|(
name|sparc
argument_list|)
operator|&&
name|defined
argument_list|(
name|sun
argument_list|)
end_if

begin_include
include|#
directive|include
file|<alloca.h>
end_include

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|extern
name|char
modifier|*
name|alloca
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"history.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|savestring
end_ifndef

begin_define
define|#
directive|define
name|savestring
parameter_list|(
name|x
parameter_list|)
value|(char *)strcpy (xmalloc (1 + strlen (x)), (x))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|whitespace
end_ifndef

begin_define
define|#
directive|define
name|whitespace
parameter_list|(
name|c
parameter_list|)
value|(((c) == ' ') || ((c) == '\t'))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|digit
end_ifndef

begin_define
define|#
directive|define
name|digit
parameter_list|(
name|c
parameter_list|)
value|((c)>= '0'&& (c)<= '9')
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|member
end_ifndef

begin_define
define|#
directive|define
name|member
parameter_list|(
name|c
parameter_list|,
name|s
parameter_list|)
value|((c) ? index ((s), (c)) : 0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			History functions			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* An array of HIST_ENTRY.  This is where we store the history. */
end_comment

begin_decl_stmt
specifier|static
name|HIST_ENTRY
modifier|*
modifier|*
name|the_history
init|=
operator|(
name|HIST_ENTRY
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means that we have enforced a limit on the amount of    history that we save. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|history_stifled
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If HISTORY_STIFLED is non-zero, then this is the maximum number of    entries to remember. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_input_history
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The current location of the interactive history pointer.  Just makes    life easier for outside callers. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|history_offset
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of strings currently stored in the input_history list. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|history_length
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The current number of slots allocated to the input_history. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|history_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of slots to increase the_history by. */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_HISTORY_GROW_SIZE
value|50
end_define

begin_comment
comment|/* The character that represents the start of a history expansion    request.  This is usually `!'. */
end_comment

begin_decl_stmt
name|char
name|history_expansion_char
init|=
literal|'!'
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The character that invokes word substitution if found at the start of    a line.  This is usually `^'. */
end_comment

begin_decl_stmt
name|char
name|history_subst_char
init|=
literal|'^'
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* During tokenization, if this character is seen as the first character    of a word, then it, and all subsequent characters upto a newline are    ignored.  For a Bourne shell, this should be '#'.  Bash special cases    the interactive comment character to not be a comment delimiter. */
end_comment

begin_decl_stmt
name|char
name|history_comment_char
init|=
literal|'\0'
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The list of characters which inhibit the expansion of text if found    immediately following history_expansion_char. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|history_no_expand_chars
init|=
literal|" \t\n\r="
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The logical `base' of the history array.  It defaults to 1. */
end_comment

begin_decl_stmt
name|int
name|history_base
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Begin a session in which the history functions might be used.  This    initializes interactive variables. */
end_comment

begin_function
name|void
name|using_history
parameter_list|()
block|{
name|history_offset
operator|=
name|history_length
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Place STRING at the end of the history list.  The data field    is  set to NULL. */
end_comment

begin_function
name|void
name|add_history
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|HIST_ENTRY
modifier|*
name|temp
decl_stmt|;
if|if
condition|(
name|history_stifled
operator|&&
operator|(
name|history_length
operator|==
name|max_input_history
operator|)
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* If the history is stifled, and history_length is zero,        and it equals max_input_history, we don't save items. */
if|if
condition|(
operator|!
name|history_length
condition|)
return|return;
comment|/* If there is something in the slot, then remove it. */
if|if
condition|(
name|the_history
index|[
literal|0
index|]
condition|)
block|{
name|free
argument_list|(
name|the_history
index|[
literal|0
index|]
operator|->
name|line
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|the_history
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|history_length
condition|;
name|i
operator|++
control|)
name|the_history
index|[
name|i
index|]
operator|=
name|the_history
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|history_base
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|history_size
condition|)
block|{
name|the_history
operator|=
operator|(
name|HIST_ENTRY
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|history_size
operator|=
name|DEFAULT_HISTORY_GROW_SIZE
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|HIST_ENTRY
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|history_length
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|history_length
operator|==
operator|(
name|history_size
operator|-
literal|1
operator|)
condition|)
block|{
name|the_history
operator|=
operator|(
name|HIST_ENTRY
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|the_history
argument_list|,
operator|(
operator|(
name|history_size
operator|+=
name|DEFAULT_HISTORY_GROW_SIZE
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|HIST_ENTRY
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
name|history_length
operator|++
expr_stmt|;
block|}
block|}
name|temp
operator|=
operator|(
name|HIST_ENTRY
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|HIST_ENTRY
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|->
name|line
operator|=
name|savestring
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|temp
operator|->
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|the_history
index|[
name|history_length
index|]
operator|=
operator|(
name|HIST_ENTRY
operator|*
operator|)
name|NULL
expr_stmt|;
name|the_history
index|[
name|history_length
operator|-
literal|1
index|]
operator|=
name|temp
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make the history entry at WHICH have LINE and DATA.  This returns    the old entry so you can dispose of the data.  In the case of an    invalid WHICH, a NULL pointer is returned. */
end_comment

begin_function
name|HIST_ENTRY
modifier|*
name|replace_history_entry
parameter_list|(
name|which
parameter_list|,
name|line
parameter_list|,
name|data
parameter_list|)
name|int
name|which
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
block|{
name|HIST_ENTRY
modifier|*
name|temp
init|=
operator|(
name|HIST_ENTRY
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|HIST_ENTRY
argument_list|)
argument_list|)
decl_stmt|;
name|HIST_ENTRY
modifier|*
name|old_value
decl_stmt|;
if|if
condition|(
name|which
operator|>=
name|history_length
condition|)
return|return
operator|(
operator|(
name|HIST_ENTRY
operator|*
operator|)
name|NULL
operator|)
return|;
name|old_value
operator|=
name|the_history
index|[
name|which
index|]
expr_stmt|;
name|temp
operator|->
name|line
operator|=
name|savestring
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|temp
operator|->
name|data
operator|=
name|data
expr_stmt|;
name|the_history
index|[
name|which
index|]
operator|=
name|temp
expr_stmt|;
return|return
operator|(
name|old_value
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns the magic number which says what history element we are    looking at now.  In this implementation, it returns history_offset. */
end_comment

begin_function
name|int
name|where_history
parameter_list|()
block|{
return|return
operator|(
name|history_offset
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Search the history for STRING, starting at history_offset.    If DIRECTION< 0, then the search is through previous entries,    else through subsequent.  If the string is found, then    current_history () is the history entry, and the value of this function    is the offset in the line of that history entry that the string was    found in.  Otherwise, nothing is changed, and a -1 is returned. */
end_comment

begin_function
name|int
name|history_search
parameter_list|(
name|string
parameter_list|,
name|direction
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|direction
decl_stmt|;
block|{
specifier|register
name|int
name|i
init|=
name|history_offset
decl_stmt|;
specifier|register
name|int
name|reverse
init|=
operator|(
name|direction
operator|<
literal|0
operator|)
decl_stmt|;
specifier|register
name|char
modifier|*
name|line
decl_stmt|;
specifier|register
name|int
name|index
decl_stmt|;
name|int
name|string_len
init|=
name|strlen
argument_list|(
name|string
argument_list|)
decl_stmt|;
comment|/* Take care of trivial cases first. */
if|if
condition|(
operator|!
name|history_length
operator|||
operator|(
name|i
operator|==
name|history_length
operator|)
operator|&&
operator|!
name|reverse
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|reverse
operator|&&
operator|(
name|i
operator|==
name|history_length
operator|)
condition|)
name|i
operator|--
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Search each line in the history list for STRING. */
comment|/* At limit for direction? */
if|if
condition|(
operator|(
name|reverse
operator|&&
name|i
operator|<
literal|0
operator|)
operator|||
operator|(
operator|!
name|reverse
operator|&&
name|i
operator|==
name|history_length
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|line
operator|=
name|the_history
index|[
name|i
index|]
operator|->
name|line
expr_stmt|;
name|index
operator|=
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
comment|/* If STRING is longer than line, no match. */
if|if
condition|(
name|string_len
operator|>
name|index
condition|)
goto|goto
name|next_line
goto|;
comment|/* Do the actual search. */
if|if
condition|(
name|reverse
condition|)
block|{
name|index
operator|-=
name|string_len
expr_stmt|;
while|while
condition|(
name|index
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|string
argument_list|,
name|line
operator|+
name|index
argument_list|,
name|string_len
argument_list|)
operator|==
literal|0
condition|)
block|{
name|history_offset
operator|=
name|i
expr_stmt|;
return|return
operator|(
name|index
operator|)
return|;
block|}
name|index
operator|--
expr_stmt|;
block|}
block|}
else|else
block|{
specifier|register
name|int
name|limit
init|=
operator|(
name|string_len
operator|-
name|index
operator|)
operator|+
literal|1
decl_stmt|;
name|index
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|index
operator|<
name|limit
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|string
argument_list|,
name|line
operator|+
name|index
argument_list|,
name|string_len
argument_list|)
operator|==
literal|0
condition|)
block|{
name|history_offset
operator|=
name|i
expr_stmt|;
return|return
operator|(
name|index
operator|)
return|;
block|}
name|index
operator|++
expr_stmt|;
block|}
block|}
name|next_line
label|:
if|if
condition|(
name|reverse
condition|)
name|i
operator|--
expr_stmt|;
else|else
name|i
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Remove history element WHICH from the history.  The removed    element is returned to you so you can free the line, data,    and containing structure. */
end_comment

begin_function
name|HIST_ENTRY
modifier|*
name|remove_history
parameter_list|(
name|which
parameter_list|)
name|int
name|which
decl_stmt|;
block|{
name|HIST_ENTRY
modifier|*
name|return_value
decl_stmt|;
if|if
condition|(
name|which
operator|>=
name|history_length
operator|||
operator|!
name|history_length
condition|)
name|return_value
operator|=
operator|(
name|HIST_ENTRY
operator|*
operator|)
name|NULL
expr_stmt|;
else|else
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|return_value
operator|=
name|the_history
index|[
name|which
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|which
init|;
name|i
operator|<
name|history_length
condition|;
name|i
operator|++
control|)
name|the_history
index|[
name|i
index|]
operator|=
name|the_history
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|history_length
operator|--
expr_stmt|;
block|}
return|return
operator|(
name|return_value
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Stifle the history list, remembering only MAX number of lines. */
end_comment

begin_function
name|void
name|stifle_history
parameter_list|(
name|max
parameter_list|)
name|int
name|max
decl_stmt|;
block|{
if|if
condition|(
name|history_length
operator|>
name|max
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* This loses because we cannot free the data. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|history_length
operator|-
name|max
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|free
argument_list|(
name|the_history
index|[
name|i
index|]
operator|->
name|line
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|the_history
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|history_base
operator|=
name|i
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|i
operator|=
name|history_length
operator|-
name|max
init|;
name|j
operator|<
name|max
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
name|the_history
index|[
name|j
index|]
operator|=
name|the_history
index|[
name|i
index|]
expr_stmt|;
name|the_history
index|[
name|j
index|]
operator|=
operator|(
name|HIST_ENTRY
operator|*
operator|)
name|NULL
expr_stmt|;
name|history_length
operator|=
name|j
expr_stmt|;
block|}
name|history_stifled
operator|=
literal|1
expr_stmt|;
name|max_input_history
operator|=
name|max
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Stop stifling the history.  This returns the previous amount the history  was stifled by.  The value is positive if the history was stifled, negative  if it wasn't. */
end_comment

begin_function
name|int
name|unstifle_history
parameter_list|()
block|{
name|int
name|result
init|=
name|max_input_history
decl_stmt|;
if|if
condition|(
name|history_stifled
condition|)
block|{
name|result
operator|=
operator|-
name|result
expr_stmt|;
name|history_stifled
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the string that should be used in the place of this    filename.  This only matters when you don't specify the    filename to read_history (), or write_history (). */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|history_filename
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|char
modifier|*
name|return_val
init|=
name|filename
condition|?
name|savestring
argument_list|(
name|filename
argument_list|)
else|:
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|return_val
condition|)
block|{
name|char
modifier|*
name|home
init|=
operator|(
name|char
operator|*
operator|)
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|home
condition|)
name|home
operator|=
literal|"."
expr_stmt|;
name|return_val
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|2
operator|+
name|strlen
argument_list|(
name|home
argument_list|)
operator|+
name|strlen
argument_list|(
literal|".history"
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|return_val
argument_list|,
name|home
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|return_val
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|return_val
argument_list|,
literal|".history"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|return_val
operator|)
return|;
block|}
end_function

begin_comment
comment|/* What to use until the line gets too big. */
end_comment

begin_define
define|#
directive|define
name|TYPICAL_LINE_SIZE
value|2048
end_define

begin_comment
comment|/* Add the contents of FILENAME to the history list, a line at a time.    If FILENAME is NULL, then read from ~/.history.  Returns 0 if    successful, or errno if not. */
end_comment

begin_function
name|int
name|read_history
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|char
modifier|*
name|input
init|=
name|history_filename
argument_list|(
name|filename
argument_list|)
decl_stmt|;
name|FILE
modifier|*
name|file
init|=
name|fopen
argument_list|(
name|input
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
name|char
modifier|*
name|line
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|TYPICAL_LINE_SIZE
argument_list|)
decl_stmt|;
name|int
name|line_size
init|=
name|TYPICAL_LINE_SIZE
decl_stmt|;
name|int
name|done
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|file
condition|)
block|{
specifier|extern
name|int
name|errno
decl_stmt|;
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
return|return
operator|(
name|errno
operator|)
return|;
block|}
while|while
condition|(
operator|!
name|done
condition|)
block|{
name|int
name|c
decl_stmt|;
name|int
name|i
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|done
operator|=
operator|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|file
argument_list|)
operator|)
operator|==
name|EOF
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
break|break;
name|line
index|[
name|i
operator|++
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|line_size
condition|)
name|line
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|line
argument_list|,
name|line_size
operator|+=
name|TYPICAL_LINE_SIZE
argument_list|)
expr_stmt|;
block|}
name|line
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|line
index|[
literal|0
index|]
condition|)
name|add_history
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Overwrite FILENAME with the current history.  If FILENAME is NULL,    then write the history list to ~/.history.  Values returned    are as in read_history ().*/
end_comment

begin_function
name|int
name|write_history
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
specifier|extern
name|int
name|errno
decl_stmt|;
name|char
modifier|*
name|output
init|=
name|history_filename
argument_list|(
name|filename
argument_list|)
decl_stmt|;
name|FILE
modifier|*
name|file
init|=
name|fopen
argument_list|(
name|output
argument_list|,
literal|"w"
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|file
condition|)
return|return
operator|(
name|errno
operator|)
return|;
if|if
condition|(
operator|!
name|history_length
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|history_length
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s\n"
argument_list|,
name|the_history
index|[
name|i
index|]
operator|->
name|line
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the history entry at the current position, as determined by    history_offset.  If there is no entry there, return a NULL pointer. */
end_comment

begin_function
name|HIST_ENTRY
modifier|*
name|current_history
parameter_list|()
block|{
if|if
condition|(
operator|(
name|history_offset
operator|==
name|history_length
operator|)
operator|||
operator|!
name|the_history
condition|)
return|return
operator|(
operator|(
name|HIST_ENTRY
operator|*
operator|)
name|NULL
operator|)
return|;
else|else
return|return
operator|(
name|the_history
index|[
name|history_offset
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Back up history_offset to the previous history entry, and return    a pointer to that entry.  If there is no previous entry then return    a NULL pointer. */
end_comment

begin_function
name|HIST_ENTRY
modifier|*
name|previous_history
parameter_list|()
block|{
if|if
condition|(
operator|!
name|history_offset
condition|)
return|return
operator|(
operator|(
name|HIST_ENTRY
operator|*
operator|)
name|NULL
operator|)
return|;
else|else
return|return
operator|(
name|the_history
index|[
operator|--
name|history_offset
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Move history_offset forward to the next history entry, and return    a pointer to that entry.  If there is no next entry then return a    NULL pointer. */
end_comment

begin_function
name|HIST_ENTRY
modifier|*
name|next_history
parameter_list|()
block|{
if|if
condition|(
name|history_offset
operator|==
name|history_length
condition|)
return|return
operator|(
operator|(
name|HIST_ENTRY
operator|*
operator|)
name|NULL
operator|)
return|;
else|else
return|return
operator|(
name|the_history
index|[
operator|++
name|history_offset
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the current history array.  The caller has to be carefull, since this    is the actual array of data, and could be bashed or made corrupt easily.    The array is terminated with a NULL pointer. */
end_comment

begin_function
name|HIST_ENTRY
modifier|*
modifier|*
name|history_list
parameter_list|()
block|{
return|return
operator|(
name|the_history
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the history entry which is logically at OFFSET in the history array.    OFFSET is relative to history_base. */
end_comment

begin_function
name|HIST_ENTRY
modifier|*
name|history_get
parameter_list|(
name|offset
parameter_list|)
name|int
name|offset
decl_stmt|;
block|{
name|int
name|index
init|=
name|offset
operator|-
name|history_base
decl_stmt|;
if|if
condition|(
name|index
operator|>=
name|history_length
operator|||
name|index
operator|<
literal|0
operator|||
operator|!
name|the_history
condition|)
return|return
operator|(
operator|(
name|HIST_ENTRY
operator|*
operator|)
name|NULL
operator|)
return|;
return|return
operator|(
name|the_history
index|[
name|index
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Search for STRING in the history list.  DIR is< 0 for searching    backwards.  POS is an absolute index into the history list at    which point to begin searching. */
end_comment

begin_function
name|int
name|history_search_pos
parameter_list|(
name|string
parameter_list|,
name|dir
parameter_list|,
name|pos
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|dir
decl_stmt|,
name|pos
decl_stmt|;
block|{
name|int
name|ret
decl_stmt|,
name|old
init|=
name|where_history
argument_list|()
decl_stmt|;
name|history_set_pos
argument_list|(
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|history_search
argument_list|(
name|string
argument_list|,
name|dir
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|history_set_pos
argument_list|(
name|old
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ret
operator|=
name|where_history
argument_list|()
expr_stmt|;
name|history_set_pos
argument_list|(
name|old
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Make the current history item be the one at POS, an absolute index.    Returns zero if POS is out of range, else non-zero. */
end_comment

begin_function
name|int
name|history_set_pos
parameter_list|(
name|pos
parameter_list|)
name|int
name|pos
decl_stmt|;
block|{
if|if
condition|(
name|pos
operator|>
name|history_length
operator|||
name|pos
operator|<
literal|0
operator|||
operator|!
name|the_history
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|history_offset
operator|=
name|pos
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			History Expansion			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Hairy history expansion on text, not tokens.  This is of general    use, and thus belongs in this library. */
end_comment

begin_comment
comment|/* The last string searched for in a !?string? search. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|search_string
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return the event specified at TEXT + OFFSET modifying OFFSET to    point to after the event specifier.  Just a pointer to the history    line is returned; NULL is returned in the event of a bad specifier.    You pass STRING with *INDEX equal to the history_expansion_char that    begins this specification.    DELIMITING_QUOTE is a character that is allowed to end the string    specification for what to search for in addition to the normal    characters `:', ` ', `\t', `\n', and sometimes `?'.    So you might call this function like:    line = get_history_event ("!echo:p",&index, 0);  */
end_comment

begin_function
name|char
modifier|*
name|get_history_event
parameter_list|(
name|string
parameter_list|,
name|caller_index
parameter_list|,
name|delimiting_quote
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
modifier|*
name|caller_index
decl_stmt|;
name|int
name|delimiting_quote
decl_stmt|;
block|{
specifier|register
name|int
name|i
init|=
operator|*
name|caller_index
decl_stmt|;
name|int
name|which
decl_stmt|,
name|sign
init|=
literal|1
decl_stmt|;
name|HIST_ENTRY
modifier|*
name|entry
decl_stmt|;
comment|/* The event can be specified in a number of ways.       !!   the previous command      !n   command line N      !-n  current command-line minus N      !str the most recent command starting with STR      !?str[?] 	  the most recent command containing STR       All values N are determined via HISTORY_BASE. */
if|if
condition|(
name|string
index|[
name|i
index|]
operator|!=
name|history_expansion_char
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
comment|/* Move on to the specification. */
name|i
operator|++
expr_stmt|;
comment|/* Handle !! case. */
if|if
condition|(
name|string
index|[
name|i
index|]
operator|==
name|history_expansion_char
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|which
operator|=
name|history_base
operator|+
operator|(
name|history_length
operator|-
literal|1
operator|)
expr_stmt|;
operator|*
name|caller_index
operator|=
name|i
expr_stmt|;
goto|goto
name|get_which
goto|;
block|}
comment|/* Hack case of numeric line specification. */
name|read_which
label|:
if|if
condition|(
name|string
index|[
name|i
index|]
operator|==
literal|'-'
condition|)
block|{
name|sign
operator|=
operator|-
literal|1
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|digit
argument_list|(
name|string
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|int
name|start
init|=
name|i
decl_stmt|;
comment|/* Get the extent of the digits. */
for|for
control|(
init|;
name|digit
argument_list|(
name|string
index|[
name|i
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
comment|/* Get the digit value. */
name|sscanf
argument_list|(
name|string
operator|+
name|start
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|which
argument_list|)
expr_stmt|;
operator|*
name|caller_index
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|sign
operator|<
literal|0
condition|)
name|which
operator|=
operator|(
name|history_length
operator|+
name|history_base
operator|)
operator|-
name|which
expr_stmt|;
name|get_which
label|:
if|if
condition|(
name|entry
operator|=
name|history_get
argument_list|(
name|which
argument_list|)
condition|)
return|return
operator|(
name|entry
operator|->
name|line
operator|)
return|;
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
comment|/* This must be something to search for.  If the spec begins with      a '?', then the string may be anywhere on the line.  Otherwise,      the string must be found at the start of a line. */
block|{
name|int
name|index
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|;
name|int
name|substring_okay
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|string
index|[
name|i
index|]
operator|==
literal|'?'
condition|)
block|{
name|substring_okay
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
for|for
control|(
name|index
operator|=
name|i
init|;
name|string
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|whitespace
argument_list|(
name|string
index|[
name|i
index|]
argument_list|)
operator|||
name|string
index|[
name|i
index|]
operator|==
literal|'\n'
operator|||
name|string
index|[
name|i
index|]
operator|==
literal|':'
operator|||
operator|(
name|substring_okay
operator|&&
name|string
index|[
name|i
index|]
operator|==
literal|'?'
operator|)
operator|||
name|string
index|[
name|i
index|]
operator|==
name|delimiting_quote
condition|)
break|break;
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|1
operator|+
operator|(
name|i
operator|-
name|index
operator|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|temp
argument_list|,
operator|&
name|string
index|[
name|index
index|]
argument_list|,
operator|(
name|i
operator|-
name|index
operator|)
argument_list|)
expr_stmt|;
name|temp
index|[
name|i
operator|-
name|index
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|string
index|[
name|i
index|]
operator|==
literal|'?'
condition|)
name|i
operator|++
expr_stmt|;
operator|*
name|caller_index
operator|=
name|i
expr_stmt|;
name|search_again
label|:
name|index
operator|=
name|history_search
argument_list|(
name|temp
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|<
literal|0
condition|)
name|search_lost
label|:
block|{
name|history_offset
operator|=
name|history_length
expr_stmt|;
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|index
operator|==
literal|0
operator|||
name|substring_okay
operator|||
operator|(
name|strncmp
argument_list|(
name|temp
argument_list|,
name|the_history
index|[
name|history_offset
index|]
operator|->
name|line
argument_list|,
name|strlen
argument_list|(
name|temp
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|search_won
label|:
name|entry
operator|=
name|current_history
argument_list|()
expr_stmt|;
name|history_offset
operator|=
name|history_length
expr_stmt|;
comment|/* If this was a substring search, then remember the string that 	   we matched for word substitution. */
if|if
condition|(
name|substring_okay
condition|)
block|{
if|if
condition|(
name|search_string
condition|)
name|free
argument_list|(
name|search_string
argument_list|)
expr_stmt|;
name|search_string
operator|=
name|savestring
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|entry
operator|->
name|line
operator|)
return|;
block|}
if|if
condition|(
name|history_offset
condition|)
name|history_offset
operator|--
expr_stmt|;
else|else
goto|goto
name|search_lost
goto|;
goto|goto
name|search_again
goto|;
block|}
block|}
end_function

begin_comment
comment|/* Expand the string STRING, placing the result into OUTPUT, a pointer    to a string.  Returns:     0) If no expansions took place (or, if the only change in       the text was the de-slashifying of the history expansion       character)    1) If expansions did take place   -1) If there was an error in expansion.    If an error ocurred in expansion, then OUTPUT contains a descriptive   error message. */
end_comment

begin_function
name|int
name|history_expand
parameter_list|(
name|string
parameter_list|,
name|output
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|char
modifier|*
modifier|*
name|output
decl_stmt|;
block|{
specifier|register
name|int
name|j
decl_stmt|,
name|l
init|=
name|strlen
argument_list|(
name|string
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|word_spec_error
init|=
literal|0
decl_stmt|;
name|int
name|cc
decl_stmt|,
name|modified
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|word_spec
decl_stmt|,
modifier|*
name|event
decl_stmt|;
name|int
name|starting_index
decl_stmt|,
name|only_printing
init|=
literal|0
decl_stmt|,
name|substitute_globally
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|get_history_word_specifier
argument_list|()
decl_stmt|,
modifier|*
name|rindex
argument_list|()
decl_stmt|;
comment|/* The output string, and its length. */
name|int
name|len
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|result
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
comment|/* Used in add_string; */
name|char
modifier|*
name|temp
decl_stmt|,
name|tt
index|[
literal|2
index|]
decl_stmt|,
name|tbl
index|[
literal|3
index|]
decl_stmt|;
comment|/* Prepare the buffer for printing error messages. */
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|len
operator|=
literal|255
argument_list|)
expr_stmt|;
name|result
index|[
literal|0
index|]
operator|=
name|tt
index|[
literal|1
index|]
operator|=
name|tbl
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|tbl
index|[
literal|0
index|]
operator|=
literal|'\\'
expr_stmt|;
name|tbl
index|[
literal|1
index|]
operator|=
name|history_expansion_char
expr_stmt|;
comment|/* Grovel the string.  Only backslash can quote the history escape      character.  We also handle arg specifiers. */
comment|/* Before we grovel forever, see if the history_expansion_char appears      anywhere within the text. */
comment|/* The quick substitution character is a history expansion all right.  That      is to say, "^this^that^" is equivalent to "!!:s^this^that^", and in fact,      that is the substitution that we do. */
if|if
condition|(
name|string
index|[
literal|0
index|]
operator|==
name|history_subst_char
condition|)
block|{
name|char
modifier|*
name|format_string
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|10
operator|+
name|strlen
argument_list|(
name|string
argument_list|)
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|format_string
argument_list|,
literal|"%c%c:s%s"
argument_list|,
name|history_expansion_char
argument_list|,
name|history_expansion_char
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|string
operator|=
name|format_string
expr_stmt|;
name|l
operator|+=
literal|4
expr_stmt|;
goto|goto
name|grovel
goto|;
block|}
comment|/* If not quick substitution, still maybe have to do expansion. */
comment|/* `!' followed by one of the characters in history_no_expand_chars      is NOT an expansion. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|string
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|string
index|[
name|i
index|]
operator|==
name|history_expansion_char
condition|)
if|if
condition|(
operator|!
name|string
index|[
name|i
operator|+
literal|1
index|]
operator|||
name|member
argument_list|(
name|string
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
name|history_no_expand_chars
argument_list|)
condition|)
continue|continue;
else|else
goto|goto
name|grovel
goto|;
name|free
argument_list|(
name|result
argument_list|)
expr_stmt|;
operator|*
name|output
operator|=
name|savestring
argument_list|(
name|string
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|grovel
label|:
for|for
control|(
name|i
operator|=
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|l
condition|;
name|i
operator|++
control|)
block|{
name|int
name|tchar
init|=
name|string
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|tchar
operator|==
name|history_expansion_char
condition|)
name|tchar
operator|=
operator|-
literal|3
expr_stmt|;
switch|switch
condition|(
name|tchar
condition|)
block|{
case|case
literal|'\\'
case|:
if|if
condition|(
name|string
index|[
name|i
operator|+
literal|1
index|]
operator|==
name|history_expansion_char
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|temp
operator|=
name|tbl
expr_stmt|;
goto|goto
name|do_add
goto|;
block|}
else|else
goto|goto
name|add_char
goto|;
comment|/* case history_expansion_char: */
case|case
operator|-
literal|3
case|:
name|starting_index
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|cc
operator|=
name|string
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
comment|/* If the history_expansion_char is followed by one of the 	     characters in history_no_expand_chars, then it is not a 	     candidate for expansion of any kind. */
if|if
condition|(
name|member
argument_list|(
name|cc
argument_list|,
name|history_no_expand_chars
argument_list|)
condition|)
goto|goto
name|add_char
goto|;
comment|/* There is something that is listed as a `word specifier' in csh 	     documentation which means `the expanded text to this point'. 	     That is not a word specifier, it is an event specifier. */
if|if
condition|(
name|cc
operator|==
literal|'#'
condition|)
goto|goto
name|hack_pound_sign
goto|;
comment|/* If it is followed by something that starts a word specifier, 	     then !! is implied as the event specifier. */
if|if
condition|(
name|member
argument_list|(
name|cc
argument_list|,
literal|":$*%^"
argument_list|)
condition|)
block|{
name|char
name|fake_s
index|[
literal|2
index|]
decl_stmt|;
name|int
name|fake_i
init|=
literal|0
decl_stmt|;
name|i
operator|++
expr_stmt|;
name|fake_s
index|[
literal|0
index|]
operator|=
name|fake_s
index|[
literal|1
index|]
operator|=
name|history_expansion_char
expr_stmt|;
name|fake_s
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|event
operator|=
name|get_history_event
argument_list|(
name|fake_s
argument_list|,
operator|&
name|fake_i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|quoted_search_delimiter
init|=
literal|0
decl_stmt|;
comment|/* If the character before this `!' is a double or single 		 quote, then this expansion takes place inside of the 		 quoted string.  If we have to search for some text ("!foo"), 		 allow the delimiter to end the search string. */
if|if
condition|(
name|i
operator|&&
operator|(
name|string
index|[
name|i
operator|-
literal|1
index|]
operator|==
literal|'\''
operator|||
name|string
index|[
name|i
operator|-
literal|1
index|]
operator|==
literal|'"'
operator|)
condition|)
name|quoted_search_delimiter
operator|=
name|string
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|event
operator|=
name|get_history_event
argument_list|(
name|string
argument_list|,
operator|&
name|i
argument_list|,
name|quoted_search_delimiter
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|event
condition|)
name|event_not_found
label|:
block|{
name|int
name|l
init|=
literal|1
operator|+
operator|(
name|i
operator|-
name|starting_index
operator|)
decl_stmt|;
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|1
operator|+
name|l
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|temp
argument_list|,
name|string
operator|+
name|starting_index
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|temp
index|[
name|l
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|sprintf
argument_list|(
name|result
argument_list|,
literal|"%s: %s."
argument_list|,
name|temp
argument_list|,
name|word_spec_error
condition|?
literal|"Bad word specifier"
else|:
literal|"Event not found"
argument_list|)
expr_stmt|;
name|error_exit
label|:
operator|*
name|output
operator|=
name|result
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* If a word specifier is found, then do what that requires. */
name|starting_index
operator|=
name|i
expr_stmt|;
name|word_spec
operator|=
name|get_history_word_specifier
argument_list|(
name|string
argument_list|,
name|event
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
comment|/* There is no such thing as a `malformed word specifier'.  However, 	     it is possible for a specifier that has no match.  In that case, 	     we complain. */
if|if
condition|(
name|word_spec
operator|==
operator|(
name|char
operator|*
operator|)
operator|-
literal|1
condition|)
name|bad_word_spec
label|:
block|{
name|word_spec_error
operator|++
expr_stmt|;
goto|goto
name|event_not_found
goto|;
block|}
comment|/* If no word specifier, than the thing of interest was the event. */
if|if
condition|(
operator|!
name|word_spec
condition|)
name|temp
operator|=
name|event
expr_stmt|;
else|else
block|{
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|1
operator|+
name|strlen
argument_list|(
name|word_spec
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|temp
argument_list|,
name|word_spec
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|word_spec
argument_list|)
expr_stmt|;
block|}
comment|/* Perhaps there are other modifiers involved.  Do what they say. */
name|hack_specials
label|:
if|if
condition|(
name|string
index|[
name|i
index|]
operator|==
literal|':'
condition|)
block|{
name|char
modifier|*
name|tstr
decl_stmt|;
switch|switch
condition|(
name|string
index|[
name|i
operator|+
literal|1
index|]
condition|)
block|{
comment|/* :p means make this the last executed line.  So we 		     return an error state after adding this line to the 		     history. */
case|case
literal|'p'
case|:
name|only_printing
operator|++
expr_stmt|;
goto|goto
name|next_special
goto|;
comment|/* :t discards all but the last part of the pathname. */
case|case
literal|'t'
case|:
name|tstr
operator|=
name|rindex
argument_list|(
name|temp
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|tstr
condition|)
name|temp
operator|=
operator|++
name|tstr
expr_stmt|;
goto|goto
name|next_special
goto|;
comment|/* :h discards the last part of a pathname. */
case|case
literal|'h'
case|:
name|tstr
operator|=
name|rindex
argument_list|(
name|temp
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|tstr
condition|)
operator|*
name|tstr
operator|=
literal|'\0'
expr_stmt|;
goto|goto
name|next_special
goto|;
comment|/* :r discards the suffix. */
case|case
literal|'r'
case|:
name|tstr
operator|=
name|rindex
argument_list|(
name|temp
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|tstr
condition|)
operator|*
name|tstr
operator|=
literal|'\0'
expr_stmt|;
goto|goto
name|next_special
goto|;
comment|/* :e discards everything but the suffix. */
case|case
literal|'e'
case|:
name|tstr
operator|=
name|rindex
argument_list|(
name|temp
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|tstr
condition|)
name|temp
operator|=
name|tstr
expr_stmt|;
goto|goto
name|next_special
goto|;
comment|/* :s/this/that substitutes `this' for `that'. */
comment|/* :gs/this/that substitutes `this' for `that' globally. */
case|case
literal|'g'
case|:
if|if
condition|(
name|string
index|[
name|i
operator|+
literal|2
index|]
operator|==
literal|'s'
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|substitute_globally
operator|=
literal|1
expr_stmt|;
goto|goto
name|substitute
goto|;
block|}
else|else
case|case
literal|'s'
case|:
name|substitute
label|:
block|{
name|char
modifier|*
name|this
decl_stmt|,
modifier|*
name|that
decl_stmt|,
modifier|*
name|new_event
decl_stmt|;
name|int
name|delimiter
init|=
literal|0
decl_stmt|;
name|int
name|si
decl_stmt|,
name|l_this
decl_stmt|,
name|l_that
decl_stmt|,
name|l_temp
init|=
name|strlen
argument_list|(
name|temp
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|+
literal|2
operator|<
name|strlen
argument_list|(
name|string
argument_list|)
condition|)
name|delimiter
operator|=
name|string
index|[
name|i
operator|+
literal|2
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|delimiter
condition|)
break|break;
name|i
operator|+=
literal|3
expr_stmt|;
comment|/* Get THIS. */
for|for
control|(
name|si
operator|=
name|i
init|;
name|string
index|[
name|si
index|]
operator|&&
name|string
index|[
name|si
index|]
operator|!=
name|delimiter
condition|;
name|si
operator|++
control|)
empty_stmt|;
name|l_this
operator|=
operator|(
name|si
operator|-
name|i
operator|)
expr_stmt|;
name|this
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|1
operator|+
name|l_this
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|this
argument_list|,
name|string
operator|+
name|i
argument_list|,
name|l_this
argument_list|)
expr_stmt|;
name|this
index|[
name|l_this
index|]
operator|=
literal|'\0'
expr_stmt|;
name|i
operator|=
name|si
expr_stmt|;
if|if
condition|(
name|string
index|[
name|si
index|]
condition|)
name|i
operator|++
expr_stmt|;
comment|/* Get THAT. */
for|for
control|(
name|si
operator|=
name|i
init|;
name|string
index|[
name|si
index|]
operator|&&
name|string
index|[
name|si
index|]
operator|!=
name|delimiter
condition|;
name|si
operator|++
control|)
empty_stmt|;
name|l_that
operator|=
operator|(
name|si
operator|-
name|i
operator|)
expr_stmt|;
name|that
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|1
operator|+
name|l_that
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|that
argument_list|,
name|string
operator|+
name|i
argument_list|,
name|l_that
argument_list|)
expr_stmt|;
name|that
index|[
name|l_that
index|]
operator|=
literal|'\0'
expr_stmt|;
name|i
operator|=
name|si
expr_stmt|;
if|if
condition|(
name|string
index|[
name|si
index|]
condition|)
name|i
operator|++
expr_stmt|;
comment|/* Ignore impossible cases. */
if|if
condition|(
name|l_this
operator|>
name|l_temp
condition|)
goto|goto
name|cant_substitute
goto|;
comment|/* Find the first occurrence of THIS in TEMP. */
name|si
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
operator|(
name|si
operator|+
name|l_this
operator|)
operator|<=
name|l_temp
condition|;
name|si
operator|++
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|temp
operator|+
name|si
argument_list|,
name|this
argument_list|,
name|l_this
argument_list|)
operator|==
literal|0
condition|)
block|{
name|new_event
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|1
operator|+
operator|(
name|l_that
operator|-
name|l_this
operator|)
operator|+
name|l_temp
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|new_event
argument_list|,
name|temp
argument_list|,
name|si
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|new_event
operator|+
name|si
argument_list|,
name|that
argument_list|,
name|l_that
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|new_event
operator|+
name|si
operator|+
name|l_that
argument_list|,
name|temp
operator|+
name|si
operator|+
name|l_this
argument_list|,
name|l_temp
operator|-
operator|(
name|si
operator|+
name|l_this
operator|)
argument_list|)
expr_stmt|;
name|new_event
index|[
operator|(
name|l_that
operator|-
name|l_this
operator|)
operator|+
name|l_temp
index|]
operator|=
literal|'\0'
expr_stmt|;
name|temp
operator|=
name|new_event
expr_stmt|;
if|if
condition|(
name|substitute_globally
condition|)
block|{
name|si
operator|+=
name|l_that
expr_stmt|;
name|l_temp
operator|=
name|strlen
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|substitute_globally
operator|++
expr_stmt|;
continue|continue;
block|}
goto|goto
name|hack_specials
goto|;
block|}
name|cant_substitute
label|:
if|if
condition|(
name|substitute_globally
operator|>
literal|1
condition|)
block|{
name|substitute_globally
operator|=
literal|0
expr_stmt|;
goto|goto
name|hack_specials
goto|;
block|}
goto|goto
name|event_not_found
goto|;
block|}
comment|/* :# is the line so far.  Note that we have to 		     alloca () it since RESULT could be realloc ()'ed 		     below in add_string. */
case|case
literal|'#'
case|:
name|hack_pound_sign
label|:
if|if
condition|(
name|result
condition|)
block|{
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|1
operator|+
name|strlen
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|temp
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
else|else
name|temp
operator|=
literal|""
expr_stmt|;
name|next_special
label|:
name|i
operator|+=
literal|2
expr_stmt|;
goto|goto
name|hack_specials
goto|;
block|}
block|}
comment|/* Believe it or not, we have to back the pointer up by one. */
operator|--
name|i
expr_stmt|;
goto|goto
name|add_string
goto|;
comment|/* A regular character.  Just add it to the output string. */
default|default:
name|add_char
label|:
name|tt
index|[
literal|0
index|]
operator|=
name|string
index|[
name|i
index|]
expr_stmt|;
name|temp
operator|=
name|tt
expr_stmt|;
goto|goto
name|do_add
goto|;
name|add_string
label|:
name|modified
operator|++
expr_stmt|;
name|do_add
label|:
name|j
operator|+=
name|strlen
argument_list|(
name|temp
argument_list|)
expr_stmt|;
while|while
condition|(
name|j
operator|>
name|len
condition|)
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|result
argument_list|,
operator|(
name|len
operator|+=
literal|255
operator|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|result
operator|+
operator|(
name|j
operator|-
name|strlen
argument_list|(
name|temp
argument_list|)
operator|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|output
operator|=
name|result
expr_stmt|;
if|if
condition|(
name|only_printing
condition|)
block|{
name|add_history
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|modified
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return a consed string which is the word specified in SPEC, and found    in FROM.  NULL is returned if there is no spec.  -1 is returned if    the word specified cannot be found.  CALLER_INDEX is the offset in    SPEC to start looking; it is updated to point to just after the last    character parsed. */
end_comment

begin_function
name|char
modifier|*
name|get_history_word_specifier
parameter_list|(
name|spec
parameter_list|,
name|from
parameter_list|,
name|caller_index
parameter_list|)
name|char
modifier|*
name|spec
decl_stmt|,
decl|*
name|from
decl_stmt|;
end_function

begin_decl_stmt
name|int
modifier|*
name|caller_index
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
init|=
operator|*
name|caller_index
decl_stmt|;
name|int
name|first
decl_stmt|,
name|last
decl_stmt|;
name|int
name|expecting_word_spec
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|history_arg_extract
parameter_list|()
function_decl|;
comment|/* The range of words to return doesn't exist yet. */
name|first
operator|=
name|last
operator|=
literal|0
expr_stmt|;
comment|/* If we found a colon, then this *must* be a word specification.  If      it isn't, then it is an error. */
if|if
condition|(
name|spec
index|[
name|i
index|]
operator|==
literal|':'
condition|)
name|i
operator|++
operator|,
name|expecting_word_spec
operator|++
expr_stmt|;
comment|/* Handle special cases first. */
comment|/* `%' is the word last searched for. */
if|if
condition|(
name|spec
index|[
name|i
index|]
operator|==
literal|'%'
condition|)
block|{
operator|*
name|caller_index
operator|=
name|i
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|search_string
condition|)
return|return
operator|(
name|savestring
argument_list|(
name|search_string
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|savestring
argument_list|(
literal|""
argument_list|)
operator|)
return|;
block|}
comment|/* `*' matches all of the arguments, but not the command. */
if|if
condition|(
name|spec
index|[
name|i
index|]
operator|==
literal|'*'
condition|)
block|{
operator|*
name|caller_index
operator|=
name|i
operator|+
literal|1
expr_stmt|;
return|return
operator|(
name|history_arg_extract
argument_list|(
literal|1
argument_list|,
literal|'$'
argument_list|,
name|from
argument_list|)
operator|)
return|;
block|}
comment|/* `$' is last arg. */
if|if
condition|(
name|spec
index|[
name|i
index|]
operator|==
literal|'$'
condition|)
block|{
operator|*
name|caller_index
operator|=
name|i
operator|+
literal|1
expr_stmt|;
return|return
operator|(
name|history_arg_extract
argument_list|(
literal|'$'
argument_list|,
literal|'$'
argument_list|,
name|from
argument_list|)
operator|)
return|;
block|}
comment|/* Try to get FIRST and LAST figured out. */
if|if
condition|(
name|spec
index|[
name|i
index|]
operator|==
literal|'-'
operator|||
name|spec
index|[
name|i
index|]
operator|==
literal|'^'
condition|)
block|{
name|first
operator|=
literal|1
expr_stmt|;
goto|goto
name|get_last
goto|;
block|}
name|get_first
label|:
if|if
condition|(
name|digit
argument_list|(
name|spec
index|[
name|i
index|]
argument_list|)
operator|&&
name|expecting_word_spec
condition|)
block|{
name|sscanf
argument_list|(
name|spec
operator|+
name|i
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|first
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|digit
argument_list|(
name|spec
index|[
name|i
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
block|}
else|else
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
name|get_last
label|:
if|if
condition|(
name|spec
index|[
name|i
index|]
operator|==
literal|'^'
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|last
operator|=
literal|1
expr_stmt|;
goto|goto
name|get_args
goto|;
block|}
if|if
condition|(
name|spec
index|[
name|i
index|]
operator|!=
literal|'-'
condition|)
block|{
name|last
operator|=
name|first
expr_stmt|;
goto|goto
name|get_args
goto|;
block|}
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|digit
argument_list|(
name|spec
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|sscanf
argument_list|(
name|spec
operator|+
name|i
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|last
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|digit
argument_list|(
name|spec
index|[
name|i
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|spec
index|[
name|i
index|]
operator|==
literal|'$'
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|last
operator|=
literal|'$'
expr_stmt|;
block|}
name|get_args
label|:
block|{
name|char
modifier|*
name|result
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
operator|*
name|caller_index
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|last
operator|>=
name|first
condition|)
name|result
operator|=
name|history_arg_extract
argument_list|(
name|first
argument_list|,
name|last
argument_list|,
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
return|return
operator|(
name|result
operator|)
return|;
else|else
return|return
operator|(
operator|(
name|char
operator|*
operator|)
operator|-
literal|1
operator|)
return|;
block|}
block|}
end_block

begin_comment
comment|/* Extract the args specified, starting at FIRST, and ending at LAST.    The args are taken from STRING. */
end_comment

begin_function
name|char
modifier|*
name|history_arg_extract
parameter_list|(
name|first
parameter_list|,
name|last
parameter_list|,
name|string
parameter_list|)
name|int
name|first
decl_stmt|,
name|last
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
name|char
modifier|*
name|result
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
name|int
name|size
init|=
literal|0
decl_stmt|,
name|offset
init|=
literal|0
decl_stmt|;
name|char
modifier|*
modifier|*
name|history_tokenize
argument_list|()
decl_stmt|,
modifier|*
modifier|*
name|list
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|list
operator|=
name|history_tokenize
argument_list|(
name|string
argument_list|)
operator|)
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
for|for
control|(
name|len
operator|=
literal|0
init|;
name|list
index|[
name|len
index|]
condition|;
name|len
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|last
operator|==
literal|'$'
condition|)
name|last
operator|=
name|len
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|first
operator|==
literal|'$'
condition|)
name|first
operator|=
name|len
operator|-
literal|1
expr_stmt|;
name|last
operator|++
expr_stmt|;
if|if
condition|(
name|first
operator|>
name|len
operator|||
name|last
operator|>
name|len
condition|)
name|result
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|i
operator|=
name|first
init|;
name|i
operator|<
name|last
condition|;
name|i
operator|++
control|)
block|{
name|int
name|l
init|=
name|strlen
argument_list|(
name|list
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|size
operator|=
operator|(
literal|2
operator|+
name|l
operator|)
operator|)
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|result
argument_list|,
operator|(
name|size
operator|+=
operator|(
literal|2
operator|+
name|l
operator|)
operator|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|result
operator|+
name|offset
argument_list|,
name|list
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|l
expr_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|<
name|last
condition|)
block|{
name|strcpy
argument_list|(
name|result
operator|+
name|offset
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|offset
operator|++
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|list
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|list
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|slashify_in_quotes
value|"\\`\"$"
end_define

begin_comment
comment|/* Return an array of tokens, much as the shell might.  The tokens are    parsed out of STRING. */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|history_tokenize
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|result
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|start
decl_stmt|,
name|result_index
decl_stmt|,
name|size
decl_stmt|;
name|int
name|len
decl_stmt|;
name|i
operator|=
name|result_index
operator|=
name|size
operator|=
literal|0
expr_stmt|;
comment|/* Get a token, and stuff it into RESULT.  The tokens are split      exactly where the shell would split them. */
name|get_token
label|:
comment|/* Skip leading whitespace. */
for|for
control|(
init|;
name|string
index|[
name|i
index|]
operator|&&
name|whitespace
argument_list|(
name|string
index|[
name|i
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
name|start
operator|=
name|i
expr_stmt|;
if|if
condition|(
operator|!
name|string
index|[
name|i
index|]
operator|||
name|string
index|[
name|i
index|]
operator|==
name|history_comment_char
condition|)
return|return
operator|(
name|result
operator|)
return|;
if|if
condition|(
name|member
argument_list|(
name|string
index|[
name|i
index|]
argument_list|,
literal|"()\n"
argument_list|)
condition|)
block|{
name|i
operator|++
expr_stmt|;
goto|goto
name|got_token
goto|;
block|}
if|if
condition|(
name|member
argument_list|(
name|string
index|[
name|i
index|]
argument_list|,
literal|"<>;&|"
argument_list|)
condition|)
block|{
name|int
name|peek
init|=
name|string
index|[
name|i
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|peek
operator|==
name|string
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|peek
operator|==
literal|'<'
condition|)
block|{
if|if
condition|(
name|string
index|[
literal|1
operator|+
literal|2
index|]
operator|==
literal|'-'
condition|)
name|i
operator|++
expr_stmt|;
name|i
operator|+=
literal|2
expr_stmt|;
goto|goto
name|got_token
goto|;
block|}
if|if
condition|(
name|member
argument_list|(
name|peek
argument_list|,
literal|">:&|"
argument_list|)
condition|)
block|{
name|i
operator|+=
literal|2
expr_stmt|;
goto|goto
name|got_token
goto|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|peek
operator|==
literal|'&'
operator|&&
operator|(
name|string
index|[
name|i
index|]
operator|==
literal|'>'
operator|||
name|string
index|[
name|i
index|]
operator|==
literal|'<'
operator|)
operator|)
operator|||
operator|(
operator|(
name|peek
operator|==
literal|'>'
operator|)
operator|&&
operator|(
name|string
index|[
name|i
index|]
operator|==
literal|'&'
operator|)
operator|)
condition|)
block|{
name|i
operator|+=
literal|2
expr_stmt|;
goto|goto
name|got_token
goto|;
block|}
block|}
name|i
operator|++
expr_stmt|;
goto|goto
name|got_token
goto|;
block|}
comment|/* Get word from string + i; */
block|{
name|int
name|delimiter
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|member
argument_list|(
name|string
index|[
name|i
index|]
argument_list|,
literal|"\"'`"
argument_list|)
condition|)
name|delimiter
operator|=
name|string
index|[
name|i
operator|++
index|]
expr_stmt|;
for|for
control|(
init|;
name|string
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|string
index|[
name|i
index|]
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
name|string
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
name|i
operator|++
expr_stmt|;
continue|continue;
block|}
else|else
block|{
if|if
condition|(
name|delimiter
operator|!=
literal|'\''
condition|)
if|if
condition|(
operator|(
name|delimiter
operator|!=
literal|'"'
operator|)
operator|||
operator|(
name|member
argument_list|(
name|string
index|[
name|i
index|]
argument_list|,
name|slashify_in_quotes
argument_list|)
operator|)
condition|)
block|{
name|i
operator|++
expr_stmt|;
continue|continue;
block|}
block|}
block|}
if|if
condition|(
name|delimiter
operator|&&
name|string
index|[
name|i
index|]
operator|==
name|delimiter
condition|)
block|{
name|delimiter
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|delimiter
operator|&&
operator|(
name|member
argument_list|(
name|string
index|[
name|i
index|]
argument_list|,
literal|" \t\n;&()|<>"
argument_list|)
operator|)
condition|)
goto|goto
name|got_token
goto|;
if|if
condition|(
operator|!
name|delimiter
operator|&&
name|member
argument_list|(
name|string
index|[
name|i
index|]
argument_list|,
literal|"\"'`"
argument_list|)
condition|)
block|{
name|delimiter
operator|=
name|string
index|[
name|i
index|]
expr_stmt|;
continue|continue;
block|}
block|}
name|got_token
label|:
name|len
operator|=
name|i
operator|-
name|start
expr_stmt|;
if|if
condition|(
name|result_index
operator|+
literal|2
operator|>=
name|size
condition|)
block|{
if|if
condition|(
operator|!
name|size
condition|)
name|result
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|size
operator|=
literal|10
operator|)
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|result
argument_list|,
operator|(
operator|(
name|size
operator|+=
literal|10
operator|)
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
name|result
index|[
name|result_index
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
name|len
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|result
index|[
name|result_index
index|]
argument_list|,
name|string
operator|+
name|start
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|result
index|[
name|result_index
index|]
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|result_index
operator|++
expr_stmt|;
name|result
index|[
name|result_index
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|string
index|[
name|i
index|]
condition|)
goto|goto
name|get_token
goto|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|STATIC_MALLOC
end_ifdef

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			xmalloc and xrealloc ()		     	    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|xmalloc
parameter_list|(
name|bytes
parameter_list|)
name|int
name|bytes
decl_stmt|;
block|{
specifier|static
name|memory_error_and_abort
argument_list|()
expr_stmt|;
name|char
modifier|*
name|temp
init|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|bytes
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|temp
condition|)
name|memory_error_and_abort
argument_list|()
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|xrealloc
parameter_list|(
name|pointer
parameter_list|,
name|bytes
parameter_list|)
name|char
modifier|*
name|pointer
decl_stmt|;
name|int
name|bytes
decl_stmt|;
block|{
specifier|static
name|memory_error_and_abort
argument_list|()
expr_stmt|;
name|char
modifier|*
name|temp
init|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
name|pointer
argument_list|,
name|bytes
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|temp
condition|)
name|memory_error_and_abort
argument_list|()
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|memory_error_and_abort
argument_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"history: Out of virtual memory!\n"
argument_list|)
block|;
name|abort
argument_list|()
block|; }
endif|#
directive|endif
comment|/* STATIC_MALLOC */
comment|/* **************************************************************** */
comment|/*								    */
comment|/*				Test Code			    */
comment|/*								    */
comment|/* **************************************************************** */
ifdef|#
directive|ifdef
name|TEST
expr|main
operator|(
operator|)
block|{
name|char
name|line
index|[
literal|1024
index|]
block|,
operator|*
name|t
block|;
name|int
name|done
operator|=
literal|0
block|;
name|line
index|[
literal|0
index|]
operator|=
literal|0
block|;
while|while
condition|(
operator|!
name|done
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"history%% "
argument_list|)
expr_stmt|;
name|t
operator|=
name|gets
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
condition|)
name|strcpy
argument_list|(
name|line
argument_list|,
literal|"quit"
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
index|[
literal|0
index|]
condition|)
block|{
name|char
modifier|*
name|expansion
decl_stmt|;
name|int
name|result
decl_stmt|;
name|using_history
argument_list|()
expr_stmt|;
name|result
operator|=
name|history_expand
argument_list|(
name|line
argument_list|,
operator|&
name|expansion
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|line
argument_list|,
name|expansion
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|expansion
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
continue|continue;
name|add_history
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_if
if|if
condition|(
name|strcmp
argument_list|(
name|line
argument_list|,
literal|"quit"
argument_list|)
operator|==
literal|0
condition|)
name|done
operator|=
literal|1
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|strcmp
argument_list|(
name|line
argument_list|,
literal|"save"
argument_list|)
operator|==
literal|0
condition|)
name|write_history
argument_list|(
literal|0
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|strcmp
argument_list|(
name|line
argument_list|,
literal|"read"
argument_list|)
operator|==
literal|0
condition|)
name|read_history
argument_list|(
literal|0
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|strcmp
argument_list|(
name|line
argument_list|,
literal|"list"
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|register
name|HIST_ENTRY
modifier|*
modifier|*
name|the_list
init|=
name|history_list
argument_list|()
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|the_list
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|the_list
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%d: %s\n"
argument_list|,
name|i
operator|+
name|history_base
argument_list|,
name|the_list
index|[
name|i
index|]
operator|->
name|line
argument_list|)
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
name|strncmp
argument_list|(
name|line
argument_list|,
literal|"delete"
argument_list|,
name|strlen
argument_list|(
literal|"delete"
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|which
decl_stmt|;
if|if
condition|(
operator|(
name|sscanf
argument_list|(
name|line
operator|+
name|strlen
argument_list|(
literal|"delete"
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|which
argument_list|)
operator|)
operator|==
literal|1
condition|)
block|{
name|HIST_ENTRY
modifier|*
name|entry
init|=
name|remove_history
argument_list|(
name|which
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|entry
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No such entry %d\n"
argument_list|,
name|which
argument_list|)
expr_stmt|;
else|else
block|{
name|free
argument_list|(
name|entry
operator|->
name|line
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"non-numeric arg given to `delete'\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_if

begin_endif
unit|} }
endif|#
directive|endif
end_endif

begin_comment
comment|/* TEST */
end_comment

begin_escape
end_escape

begin_comment
comment|/* * Local variables: * compile-command: "gcc -g -DTEST -o history history.c" * end: */
end_comment

end_unit

