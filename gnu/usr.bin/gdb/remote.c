begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1991 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Van Jacobson and Steven McCanne of Lawrence Berkeley Laboratory.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $Header: /home/cvs/386BSD/src/usr.bin/gdb/remote.c,v 1.1.1.1 1993/06/12 14:52:22 rgrimes Exp $;  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)remote.c	6.5 (Berkeley) 5/8/91"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"wait.h"
end_include

begin_include
include|#
directive|include
file|"kgdb_proto.h"
end_include

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|kiodebug
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|icache
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|kernel_debugging
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|remote_cache_valid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|remote_instub
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|remote_signal
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|remote_debug
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_msg
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|remote_mtu
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
function_decl|(
modifier|*
name|send_msg
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
function_decl|(
modifier|*
name|recv_msg
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
name|closelink
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|u_char
modifier|*
name|inbuffer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
modifier|*
name|outbuffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Statistics.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|remote_ierrs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|remote_oerrs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|remote_seqerrs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|remote_spurious
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|PUTCMD
parameter_list|(
name|cmd
parameter_list|)
value|m_xchg(cmd, (u_char *)0, 0, (u_char *)0, (int *)0)
end_define

begin_comment
comment|/*  * Send an outbound message to the remote machine and read the reply.  * Either or both message buffers may be NULL.  */
end_comment

begin_function
specifier|static
name|int
name|m_xchg
parameter_list|(
name|type
parameter_list|,
name|out
parameter_list|,
name|outlen
parameter_list|,
name|in
parameter_list|,
name|inlen
parameter_list|)
name|int
name|type
decl_stmt|;
name|u_char
modifier|*
name|out
decl_stmt|;
name|int
name|outlen
decl_stmt|;
name|u_char
modifier|*
name|in
decl_stmt|;
name|int
modifier|*
name|inlen
decl_stmt|;
block|{
specifier|register
name|int
name|err
decl_stmt|,
argument_list|(
operator|*
name|send
argument_list|)
argument_list|()
init|=
name|send_msg
decl_stmt|,
argument_list|(
operator|*
name|recv
argument_list|)
argument_list|()
init|=
name|recv_msg
decl_stmt|;
name|int
name|ack
decl_stmt|;
specifier|static
name|int
name|seqbit
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|remote_instub
condition|)
block|{
name|remote_instub
operator|=
literal|1
expr_stmt|;
name|PUTCMD
argument_list|(
name|KGDB_EXEC
argument_list|)
expr_stmt|;
block|}
name|seqbit
operator|^=
name|KGDB_SEQ
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|err
operator|=
call|(
modifier|*
name|send
call|)
argument_list|(
name|type
operator||
name|seqbit
argument_list|,
name|out
argument_list|,
name|outlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
operator|++
name|remote_oerrs
expr_stmt|;
if|if
condition|(
name|kiodebug
condition|)
name|remote_debug
argument_list|(
literal|"send error %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|kiodebug
condition|)
name|print_msg
argument_list|(
name|type
operator||
name|seqbit
argument_list|,
name|out
argument_list|,
name|outlen
argument_list|,
literal|'O'
argument_list|)
expr_stmt|;
name|recv
label|:
name|err
operator|=
call|(
modifier|*
name|recv
call|)
argument_list|(
operator|&
name|ack
argument_list|,
name|in
argument_list|,
name|inlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
operator|++
name|remote_ierrs
expr_stmt|;
if|if
condition|(
name|kiodebug
condition|)
name|remote_debug
argument_list|(
literal|"recv error %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|remote_cache_valid
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|kiodebug
condition|)
name|print_msg
argument_list|(
name|ack
argument_list|,
name|in
argument_list|,
name|inlen
condition|?
operator|*
name|inlen
else|:
literal|0
argument_list|,
literal|'I'
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
continue|continue;
if|if
condition|(
operator|(
name|ack
operator|&
name|KGDB_ACK
operator|)
operator|==
literal|0
operator|||
name|KGDB_CMD
argument_list|(
name|ack
argument_list|)
operator|!=
name|KGDB_CMD
argument_list|(
name|type
argument_list|)
condition|)
block|{
operator|++
name|remote_spurious
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|ack
operator|&
name|KGDB_SEQ
operator|)
operator|^
name|seqbit
condition|)
block|{
operator|++
name|remote_seqerrs
expr_stmt|;
goto|goto
name|recv
goto|;
block|}
return|return
name|ack
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Wait for the specified message type.  Discard anything else.  * (this is used by 'remote-signal' to help us resync with other side.)  */
end_comment

begin_function
specifier|static
name|void
name|m_recv
parameter_list|(
name|type
parameter_list|,
name|in
parameter_list|,
name|inlen
parameter_list|)
name|int
name|type
decl_stmt|;
name|u_char
modifier|*
name|in
decl_stmt|;
name|int
modifier|*
name|inlen
decl_stmt|;
block|{
name|int
name|reply
decl_stmt|,
name|err
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|err
operator|=
call|(
modifier|*
name|recv_msg
call|)
argument_list|(
operator|&
name|reply
argument_list|,
name|in
argument_list|,
name|inlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
operator|++
name|remote_ierrs
expr_stmt|;
if|if
condition|(
name|kiodebug
condition|)
name|remote_debug
argument_list|(
literal|"recv error %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|kiodebug
condition|)
name|print_msg
argument_list|(
name|reply
argument_list|,
name|in
argument_list|,
name|inlen
condition|?
operator|*
name|inlen
else|:
literal|0
argument_list|,
literal|'I'
argument_list|)
expr_stmt|;
if|if
condition|(
name|KGDB_CMD
argument_list|(
name|reply
argument_list|)
operator|==
name|type
condition|)
return|return;
operator|++
name|remote_spurious
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Send a message.  Do not wait for *any* response from the other side.  * Some other thread of control will pick up the ack that will be generated.  */
end_comment

begin_function
specifier|static
name|void
name|m_send
parameter_list|(
name|type
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|)
name|int
name|type
decl_stmt|;
name|u_char
modifier|*
name|buf
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|int
name|err
decl_stmt|;
if|if
condition|(
operator|!
name|remote_instub
condition|)
block|{
name|remote_instub
operator|=
literal|1
expr_stmt|;
name|PUTCMD
argument_list|(
name|KGDB_EXEC
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
call|(
modifier|*
name|send_msg
call|)
argument_list|(
name|type
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
operator|++
name|remote_ierrs
expr_stmt|;
if|if
condition|(
name|kiodebug
condition|)
name|remote_debug
argument_list|(
literal|"[send error %d] "
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|kiodebug
condition|)
name|print_msg
argument_list|(
name|type
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
literal|'O'
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Open a connection to a remote debugger.    * NAME is the filename used for communication.    */
end_comment

begin_function
name|void
name|remote_open
parameter_list|(
name|name
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|int
name|bufsize
decl_stmt|;
name|remote_debugging
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sl_open
argument_list|(
name|name
argument_list|,
operator|&
name|send_msg
argument_list|,
operator|&
name|recv_msg
argument_list|,
operator|&
name|closelink
argument_list|,
operator|&
name|remote_mtu
argument_list|,
operator|&
name|bufsize
argument_list|)
condition|)
return|return;
if|if
condition|(
name|from_tty
condition|)
name|printf
argument_list|(
literal|"Remote debugging using %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|remote_debugging
operator|=
literal|1
expr_stmt|;
name|remote_cache_valid
operator|=
literal|0
expr_stmt|;
name|inbuffer
operator|=
operator|(
name|u_char
operator|*
operator|)
name|malloc
argument_list|(
name|bufsize
argument_list|)
expr_stmt|;
name|outbuffer
operator|=
operator|(
name|u_char
operator|*
operator|)
name|malloc
argument_list|(
name|bufsize
argument_list|)
expr_stmt|;
name|remote_signal
argument_list|()
expr_stmt|;
name|remote_ierrs
operator|=
literal|0
expr_stmt|;
name|remote_oerrs
operator|=
literal|0
expr_stmt|;
name|remote_spurious
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Close the open connection to the remote debugger. Use this when you want  * to detach and do something else with your gdb.    */
end_comment

begin_function
name|void
name|remote_close
parameter_list|(
name|from_tty
parameter_list|)
name|int
name|from_tty
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|remote_debugging
condition|)
name|error
argument_list|(
literal|"remote debugging not enabled"
argument_list|)
expr_stmt|;
name|remote_debugging
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Take remote machine out of debug mode. 	 */
operator|(
name|void
operator|)
name|PUTCMD
argument_list|(
name|KGDB_KILL
argument_list|)
expr_stmt|;
call|(
modifier|*
name|closelink
call|)
argument_list|()
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
name|printf
argument_list|(
literal|"Ending remote debugging\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|inbuffer
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|outbuffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Tell the remote machine to resume.  */
end_comment

begin_function
name|int
name|remote_resume
parameter_list|(
name|step
parameter_list|,
name|signal
parameter_list|)
name|int
name|step
decl_stmt|,
name|signal
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|step
condition|)
block|{
operator|(
name|void
operator|)
name|PUTCMD
argument_list|(
name|KGDB_CONT
argument_list|)
expr_stmt|;
name|remote_instub
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|NO_SINGLE_STEP
name|single_step
argument_list|(
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|PUTCMD
argument_list|(
name|KGDB_STEP
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/*  * Wait until the remote machine stops, then return, storing status in STATUS  * just as `wait' would.  */
end_comment

begin_function
name|int
name|remote_wait
parameter_list|(
name|status
parameter_list|)
name|WAITTYPE
modifier|*
name|status
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
name|WSETEXIT
argument_list|(
operator|(
operator|*
name|status
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * When the machine stops, it will send us a KGDB_SIGNAL message, 	 * so we wait for one of these. 	 */
name|m_recv
argument_list|(
name|KGDB_SIGNAL
argument_list|,
name|inbuffer
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|WSETSTOP
argument_list|(
operator|(
operator|*
name|status
operator|)
argument_list|,
name|inbuffer
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Register context as of last remote_fetch_registers().  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|reg_cache
index|[
name|REGISTER_BYTES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Read the remote registers into the block REGS.  */
end_comment

begin_function
name|void
name|remote_fetch_registers
parameter_list|(
name|regs
parameter_list|)
name|char
modifier|*
name|regs
decl_stmt|;
block|{
name|int
name|regno
decl_stmt|,
name|len
decl_stmt|,
name|rlen
decl_stmt|,
name|ack
decl_stmt|;
name|u_char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|ep
decl_stmt|;
name|regno
operator|=
operator|-
literal|1
expr_stmt|;
do|do
block|{
name|outbuffer
index|[
literal|0
index|]
operator|=
name|regno
operator|+
literal|1
expr_stmt|;
name|ack
operator|=
name|m_xchg
argument_list|(
name|remote_cache_valid
condition|?
name|KGDB_REG_R
operator||
name|KGDB_DELTA
else|:
name|KGDB_REG_R
argument_list|,
name|outbuffer
argument_list|,
literal|1
argument_list|,
name|inbuffer
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|cp
operator|=
name|inbuffer
expr_stmt|;
name|ep
operator|=
name|cp
operator|+
name|len
expr_stmt|;
while|while
condition|(
name|cp
operator|<
name|ep
condition|)
block|{
name|regno
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|rlen
operator|=
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|,
operator|&
name|reg_cache
index|[
name|REGISTER_BYTE
argument_list|(
name|regno
argument_list|)
index|]
argument_list|,
name|rlen
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|rlen
expr_stmt|;
block|}
block|}
do|while
condition|(
name|ack
operator|&
name|KGDB_MORE
condition|)
do|;
name|remote_cache_valid
operator|=
literal|1
expr_stmt|;
name|bcopy
argument_list|(
name|reg_cache
argument_list|,
name|regs
argument_list|,
name|REGISTER_BYTES
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Store the remote registers from the contents of the block REGS.  */
end_comment

begin_function
name|void
name|remote_store_registers
parameter_list|(
name|regs
parameter_list|)
name|char
modifier|*
name|regs
decl_stmt|;
block|{
name|u_char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|ep
decl_stmt|;
name|int
name|regno
decl_stmt|,
name|off
decl_stmt|,
name|rlen
decl_stmt|;
name|cp
operator|=
name|outbuffer
expr_stmt|;
name|ep
operator|=
name|cp
operator|+
name|remote_mtu
expr_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|NUM_REGS
condition|;
operator|++
name|regno
control|)
block|{
name|off
operator|=
name|REGISTER_BYTE
argument_list|(
name|regno
argument_list|)
expr_stmt|;
name|rlen
operator|=
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|remote_cache_valid
operator|||
name|bcmp
argument_list|(
operator|&
name|regs
index|[
name|off
index|]
argument_list|,
operator|&
name|reg_cache
index|[
name|off
index|]
argument_list|,
name|rlen
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|cp
operator|+
name|rlen
operator|+
literal|1
operator|>=
name|ep
condition|)
block|{
operator|(
name|void
operator|)
name|m_xchg
argument_list|(
name|KGDB_REG_W
argument_list|,
name|outbuffer
argument_list|,
name|cp
operator|-
name|outbuffer
argument_list|,
operator|(
name|u_char
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|cp
operator|=
name|outbuffer
expr_stmt|;
block|}
operator|*
name|cp
operator|++
operator|=
name|regno
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|regs
index|[
name|off
index|]
argument_list|,
name|cp
argument_list|,
name|rlen
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|rlen
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cp
operator|!=
name|outbuffer
condition|)
operator|(
name|void
operator|)
name|m_xchg
argument_list|(
name|KGDB_REG_W
argument_list|,
name|outbuffer
argument_list|,
name|cp
operator|-
name|outbuffer
argument_list|,
operator|(
name|u_char
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|regs
argument_list|,
name|reg_cache
argument_list|,
name|REGISTER_BYTES
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Store a chunk of memory into the remote host.  * 'remote_addr' is the address in the remote memory space.  * 'cp' is the address of the buffer in our space, and 'len' is  * the number of bytes.  Returns an errno status.  */
end_comment

begin_function
name|int
name|remote_write_inferior_memory
parameter_list|(
name|remote_addr
parameter_list|,
name|cp
parameter_list|,
name|len
parameter_list|)
name|CORE_ADDR
name|remote_addr
decl_stmt|;
name|u_char
modifier|*
name|cp
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|int
name|cnt
decl_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|cnt
operator|=
name|min
argument_list|(
name|len
argument_list|,
name|remote_mtu
operator|-
literal|4
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|remote_addr
argument_list|,
name|outbuffer
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|cp
argument_list|,
name|outbuffer
operator|+
literal|4
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|m_xchg
argument_list|(
name|KGDB_MEM_W
argument_list|,
name|outbuffer
argument_list|,
name|cnt
operator|+
literal|4
argument_list|,
name|inbuffer
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|inbuffer
index|[
literal|0
index|]
condition|)
return|return
name|inbuffer
index|[
literal|0
index|]
return|;
name|remote_addr
operator|+=
name|cnt
expr_stmt|;
name|cp
operator|+=
name|cnt
expr_stmt|;
name|len
operator|-=
name|cnt
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Read memory data directly from the remote machine.  * 'remote_addr' is the address in the remote memory space.  * 'cp' is the address of the buffer in our space, and 'len' is  * the number of bytes.  Returns an errno status.  */
end_comment

begin_function
specifier|static
name|int
name|remote_read_memory
parameter_list|(
name|remote_addr
parameter_list|,
name|cp
parameter_list|,
name|len
parameter_list|)
name|CORE_ADDR
name|remote_addr
decl_stmt|;
name|u_char
modifier|*
name|cp
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|int
name|cnt
decl_stmt|,
name|inlen
decl_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|cnt
operator|=
name|min
argument_list|(
name|len
argument_list|,
name|remote_mtu
operator|-
literal|1
argument_list|)
expr_stmt|;
name|outbuffer
index|[
literal|0
index|]
operator|=
name|cnt
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|remote_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|outbuffer
index|[
literal|1
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|m_xchg
argument_list|(
name|KGDB_MEM_R
argument_list|,
name|outbuffer
argument_list|,
literal|5
argument_list|,
name|inbuffer
argument_list|,
operator|&
name|inlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|inbuffer
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
return|return
name|inbuffer
index|[
literal|0
index|]
return|;
if|if
condition|(
name|cnt
operator|!=
name|inlen
operator|-
literal|1
condition|)
comment|/* XXX */
name|error
argument_list|(
literal|"remote_read_memory() request botched"
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|inbuffer
index|[
literal|1
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
name|remote_addr
operator|+=
name|cnt
expr_stmt|;
name|cp
operator|+=
name|cnt
expr_stmt|;
name|len
operator|-=
name|cnt
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|remote_read_inferior_memory
parameter_list|(
name|remote_addr
parameter_list|,
name|cp
parameter_list|,
name|len
parameter_list|)
name|CORE_ADDR
name|remote_addr
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|int
name|stat
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|icache
condition|)
block|{
specifier|extern
name|CORE_ADDR
name|text_start
decl_stmt|,
name|text_end
decl_stmt|;
name|CORE_ADDR
name|xferend
init|=
name|remote_addr
operator|+
name|len
decl_stmt|;
if|if
condition|(
name|remote_addr
operator|<
name|text_end
operator|&&
name|text_start
operator|<
name|xferend
condition|)
block|{
comment|/* 			 * at least part of this xfer is in the text 			 * space -- xfer the overlap from the exec file. 			 */
if|if
condition|(
name|remote_addr
operator|>=
name|text_start
operator|&&
name|xferend
operator|<
name|text_end
condition|)
return|return
operator|(
name|xfer_core_file
argument_list|(
name|remote_addr
argument_list|,
name|cp
argument_list|,
name|len
argument_list|)
operator|)
return|;
if|if
condition|(
name|remote_addr
operator|>=
name|text_start
condition|)
block|{
name|int
name|i
init|=
name|text_end
operator|-
name|remote_addr
decl_stmt|;
if|if
condition|(
name|stat
operator|=
name|xfer_core_file
argument_list|(
name|remote_addr
argument_list|,
name|cp
argument_list|,
name|i
argument_list|)
condition|)
return|return
operator|(
name|stat
operator|)
return|;
name|remote_addr
operator|+=
name|i
expr_stmt|;
name|cp
operator|+=
name|i
expr_stmt|;
name|len
operator|-=
name|i
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xferend
operator|<=
name|text_end
condition|)
block|{
name|int
name|i
init|=
name|xferend
operator|-
name|text_start
decl_stmt|;
name|len
operator|=
name|text_start
operator|-
name|remote_addr
expr_stmt|;
if|if
condition|(
name|stat
operator|=
name|xfer_core_file
argument_list|(
name|text_start
argument_list|,
name|cp
operator|+
name|len
argument_list|,
name|i
argument_list|)
condition|)
return|return
operator|(
name|stat
operator|)
return|;
block|}
block|}
block|}
return|return
name|remote_read_memory
argument_list|(
name|remote_addr
argument_list|,
name|cp
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Signal the remote machine.  The remote end might be idle or it might  * already be in debug mode -- we need to handle both case.  Thus, we use  * the framing character as the wakeup byte, and send a SIGNAL packet.  * If the remote host is idle, the framing character will wake it up.  * If it is in the kgdb stub, then we will get a SIGNAL reply.  */
end_comment

begin_function
specifier|static
name|void
name|remote_signal
parameter_list|()
block|{
if|if
condition|(
operator|!
name|remote_debugging
condition|)
name|printf
argument_list|(
literal|"Remote debugging not enabled.\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|remote_instub
operator|=
literal|0
expr_stmt|;
name|m_send
argument_list|(
name|KGDB_SIGNAL
argument_list|,
operator|(
name|u_char
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|remote_signal_command
parameter_list|()
block|{
specifier|extern
name|int
name|stop_after_attach
decl_stmt|;
if|if
condition|(
operator|!
name|remote_debugging
condition|)
name|error
argument_list|(
literal|"Not debugging remote."
argument_list|)
expr_stmt|;
name|remote_cache_valid
operator|=
literal|0
expr_stmt|;
name|remote_signal
argument_list|()
expr_stmt|;
name|restart_remote
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print a message for debugging.  */
end_comment

begin_function
specifier|static
name|void
name|print_msg
parameter_list|(
name|type
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|,
name|dir
parameter_list|)
name|int
name|type
decl_stmt|;
name|u_char
modifier|*
name|buf
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|dir
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
switch|switch
condition|(
name|KGDB_CMD
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|KGDB_MEM_R
case|:
name|s
operator|=
literal|"memr"
expr_stmt|;
break|break;
case|case
name|KGDB_MEM_W
case|:
name|s
operator|=
literal|"memw"
expr_stmt|;
break|break;
case|case
name|KGDB_REG_R
case|:
name|s
operator|=
literal|"regr"
expr_stmt|;
break|break;
case|case
name|KGDB_REG_W
case|:
name|s
operator|=
literal|"regw"
expr_stmt|;
break|break;
case|case
name|KGDB_CONT
case|:
name|s
operator|=
literal|"cont"
expr_stmt|;
break|break;
case|case
name|KGDB_STEP
case|:
name|s
operator|=
literal|"step"
expr_stmt|;
break|break;
case|case
name|KGDB_KILL
case|:
name|s
operator|=
literal|"kill"
expr_stmt|;
break|break;
case|case
name|KGDB_SIGNAL
case|:
name|s
operator|=
literal|"sig "
expr_stmt|;
break|break;
case|case
name|KGDB_EXEC
case|:
name|s
operator|=
literal|"exec"
expr_stmt|;
break|break;
default|default:
name|s
operator|=
literal|"unk "
expr_stmt|;
break|break;
block|}
name|remote_debug
argument_list|(
literal|"%c %c%c%c%c %s (%02x): "
argument_list|,
name|dir
argument_list|,
operator|(
name|type
operator|&
name|KGDB_ACK
operator|)
condition|?
literal|'A'
else|:
literal|'.'
argument_list|,
operator|(
name|type
operator|&
name|KGDB_DELTA
operator|)
condition|?
literal|'D'
else|:
literal|'.'
argument_list|,
operator|(
name|type
operator|&
name|KGDB_MORE
operator|)
condition|?
literal|'M'
else|:
literal|'.'
argument_list|,
operator|(
name|type
operator|&
name|KGDB_SEQ
operator|)
condition|?
literal|'-'
else|:
literal|'+'
argument_list|,
name|s
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
name|remote_debug
argument_list|(
literal|"%02x"
argument_list|,
name|buf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|remote_debug
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_remote_text_refs_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|icache
operator|=
operator|!
name|parse_binary_operation
argument_list|(
literal|"set remote-text-refs"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|remote_debug_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|kiodebug
operator|!=
literal|0
operator|&&
name|kiodebug
operator|!=
name|stderr
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|kiodebug
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|==
literal|0
condition|)
block|{
name|kiodebug
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"Remote debugging off.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|arg
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
name|kiodebug
operator|=
name|stderr
expr_stmt|;
name|name
operator|=
literal|"stderr"
expr_stmt|;
block|}
else|else
block|{
name|kiodebug
operator|=
name|fopen
argument_list|(
name|arg
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|kiodebug
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Cannot open '%s'.\n"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return;
block|}
name|name
operator|=
name|arg
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"Remote debugging output routed to %s.\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|remote_info
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"Using %s for text references.\n"
argument_list|,
name|icache
condition|?
literal|"local executable"
else|:
literal|"remote"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Protocol debugging is %s.\n"
argument_list|,
name|kiodebug
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d spurious input messages.\n"
argument_list|,
name|remote_spurious
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d input errors; %d output errors; %d sequence errors.\n"
argument_list|,
name|remote_ierrs
argument_list|,
name|remote_oerrs
argument_list|,
name|remote_seqerrs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* VARARGS */
end_comment

begin_function
specifier|static
name|void
name|remote_debug
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|cp
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vfprintf
argument_list|(
name|kiodebug
argument_list|,
name|cp
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|kiodebug
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|extern
name|struct
name|cmd_list_element
modifier|*
name|setlist
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|_initialize_remote
parameter_list|()
block|{
name|add_com
argument_list|(
literal|"remote-signal"
argument_list|,
name|class_run
argument_list|,
name|remote_signal_command
argument_list|,
literal|"If remote debugging, send interrupt signal to remote."
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"remote-text-refs"
argument_list|,
name|class_support
argument_list|,
name|set_remote_text_refs_command
argument_list|,
literal|"Enable/disable use of local executable for text segment references.\n\ If on, all memory read/writes go to remote.\n\ If off, text segment reads use the local executable."
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"remote-debug"
argument_list|,
name|class_run
argument_list|,
name|remote_debug_command
argument_list|,
literal|"With a file name argument, enables output of remote protocol debugging\n\ messages to said file.  If file is `-', stderr is used.\n\ With no argument, remote debugging is disabled."
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"remote"
argument_list|,
name|remote_info
argument_list|,
literal|"Show current settings of remote debugging options."
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

