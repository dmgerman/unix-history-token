begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Low level interface to ptrace, for the remote server for GDB.    Copyright 1995, 1996, 1998, 1999, 2000, 2001, 2002, 2003, 2004    Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"server.h"
end_include

begin_include
include|#
directive|include
file|"linux-low.h"
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_comment
comment|/* ``all_threads'' is keyed by the LWP ID - it should be the thread ID instead,    however.  This requires changing the ID in place when we go from !using_threads    to using_threads, immediately.     ``all_processes'' is keyed by the process ID - which on Linux is (presently)    the same as the LWP ID.  */
end_comment

begin_decl_stmt
name|struct
name|inferior_list
name|all_processes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* FIXME this is a bit of a hack, and could be removed.  */
end_comment

begin_decl_stmt
name|int
name|stopping_threads
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* FIXME make into a target method?  */
end_comment

begin_decl_stmt
name|int
name|using_threads
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|linux_resume_one_process
parameter_list|(
name|struct
name|inferior_list_entry
modifier|*
name|entry
parameter_list|,
name|int
name|step
parameter_list|,
name|int
name|signal
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|linux_resume
parameter_list|(
name|struct
name|thread_resume
modifier|*
name|resume_info
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stop_all_processes
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|linux_wait_for_event
parameter_list|(
name|struct
name|thread_info
modifier|*
name|child
parameter_list|)
function_decl|;
end_function_decl

begin_struct
struct|struct
name|pending_signals
block|{
name|int
name|signal
decl_stmt|;
name|struct
name|pending_signals
modifier|*
name|prev
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|PTRACE_ARG3_TYPE
value|long
end_define

begin_define
define|#
directive|define
name|PTRACE_XFER_TYPE
value|long
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LINUX_REGSETS
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|use_regsets_p
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|debug_threads
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|pid_of
parameter_list|(
name|proc
parameter_list|)
value|((proc)->head.id)
end_define

begin_comment
comment|/* FIXME: Delete eventually.  */
end_comment

begin_define
define|#
directive|define
name|inferior_pid
value|(pid_of (get_thread_process (current_inferior)))
end_define

begin_comment
comment|/* This function should only be called if the process got a SIGTRAP.    The SIGTRAP could mean several things.     On i386, where decr_pc_after_break is non-zero:    If we were single-stepping this process using PTRACE_SINGLESTEP,    we will get only the one SIGTRAP (even if the instruction we    stepped over was a breakpoint).  The value of $eip will be the    next instruction.    If we continue the process using PTRACE_CONT, we will get a    SIGTRAP when we hit a breakpoint.  The value of $eip will be    the instruction after the breakpoint (i.e. needs to be    decremented).  If we report the SIGTRAP to GDB, we must also    report the undecremented PC.  If we cancel the SIGTRAP, we    must resume at the decremented PC.     (Presumably, not yet tested) On a non-decr_pc_after_break machine    with hardware or kernel single-step:    If we single-step over a breakpoint instruction, our PC will    point at the following instruction.  If we continue and hit a    breakpoint instruction, our PC will point at the breakpoint    instruction.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|get_stop_pc
parameter_list|(
name|void
parameter_list|)
block|{
name|CORE_ADDR
name|stop_pc
init|=
call|(
modifier|*
name|the_low_target
operator|.
name|get_pc
call|)
argument_list|()
decl_stmt|;
if|if
condition|(
name|get_thread_process
argument_list|(
name|current_inferior
argument_list|)
operator|->
name|stepping
condition|)
return|return
name|stop_pc
return|;
else|else
return|return
name|stop_pc
operator|-
name|the_low_target
operator|.
name|decr_pc_after_break
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|add_process
parameter_list|(
name|int
name|pid
parameter_list|)
block|{
name|struct
name|process_info
modifier|*
name|process
decl_stmt|;
name|process
operator|=
operator|(
expr|struct
name|process_info
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|process
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|process
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|process
argument_list|)
argument_list|)
expr_stmt|;
name|process
operator|->
name|head
operator|.
name|id
operator|=
name|pid
expr_stmt|;
comment|/* Default to tid == lwpid == pid.  */
name|process
operator|->
name|tid
operator|=
name|pid
expr_stmt|;
name|process
operator|->
name|lwpid
operator|=
name|pid
expr_stmt|;
name|add_inferior_to_list
argument_list|(
operator|&
name|all_processes
argument_list|,
operator|&
name|process
operator|->
name|head
argument_list|)
expr_stmt|;
return|return
name|process
return|;
block|}
end_function

begin_comment
comment|/* Start an inferior process and returns its pid.    ALLARGS is a vector of program-name and args. */
end_comment

begin_function
specifier|static
name|int
name|linux_create_inferior
parameter_list|(
name|char
modifier|*
name|program
parameter_list|,
name|char
modifier|*
modifier|*
name|allargs
parameter_list|)
block|{
name|void
modifier|*
name|new_process
decl_stmt|;
name|int
name|pid
decl_stmt|;
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
literal|"fork"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
name|ptrace
argument_list|(
name|PTRACE_TRACEME
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|__SIGRTMIN
operator|+
literal|1
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|setpgid
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|execv
argument_list|(
name|program
argument_list|,
name|allargs
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot exec %s: %s.\n"
argument_list|,
name|program
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|0177
argument_list|)
expr_stmt|;
block|}
name|new_process
operator|=
name|add_process
argument_list|(
name|pid
argument_list|)
expr_stmt|;
name|add_thread
argument_list|(
name|pid
argument_list|,
name|new_process
argument_list|)
expr_stmt|;
return|return
name|pid
return|;
block|}
end_function

begin_comment
comment|/* Attach to an inferior process.  */
end_comment

begin_function
name|void
name|linux_attach_lwp
parameter_list|(
name|int
name|pid
parameter_list|,
name|int
name|tid
parameter_list|)
block|{
name|struct
name|process_info
modifier|*
name|new_process
decl_stmt|;
if|if
condition|(
name|ptrace
argument_list|(
name|PTRACE_ATTACH
argument_list|,
name|pid
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot attach to process %d: %s (%d)\n"
argument_list|,
name|pid
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
comment|/* If we fail to attach to an LWP, just return.  */
if|if
condition|(
operator|!
name|using_threads
condition|)
name|_exit
argument_list|(
literal|0177
argument_list|)
expr_stmt|;
return|return;
block|}
name|new_process
operator|=
operator|(
expr|struct
name|process_info
operator|*
operator|)
name|add_process
argument_list|(
name|pid
argument_list|)
expr_stmt|;
name|add_thread
argument_list|(
name|tid
argument_list|,
name|new_process
argument_list|)
expr_stmt|;
comment|/* The next time we wait for this LWP we'll see a SIGSTOP as PTRACE_ATTACH      brings it to a halt.  We should ignore that SIGSTOP and resume the process      (unless this is the first process, in which case the flag will be cleared      in linux_attach).       On the other hand, if we are currently trying to stop all threads, we      should treat the new thread as if we had sent it a SIGSTOP.  This works      because we are guaranteed that add_process added us to the end of the      list, and so the new thread has not yet reached wait_for_sigstop (but      will).  */
if|if
condition|(
operator|!
name|stopping_threads
condition|)
name|new_process
operator|->
name|stop_expected
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|int
name|linux_attach
parameter_list|(
name|int
name|pid
parameter_list|)
block|{
name|struct
name|process_info
modifier|*
name|process
decl_stmt|;
name|linux_attach_lwp
argument_list|(
name|pid
argument_list|,
name|pid
argument_list|)
expr_stmt|;
comment|/* Don't ignore the initial SIGSTOP if we just attached to this process.  */
name|process
operator|=
operator|(
expr|struct
name|process_info
operator|*
operator|)
name|find_inferior_id
argument_list|(
operator|&
name|all_processes
argument_list|,
name|pid
argument_list|)
expr_stmt|;
name|process
operator|->
name|stop_expected
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Kill the inferior process.  Make us have no inferior.  */
end_comment

begin_function
specifier|static
name|void
name|linux_kill_one_process
parameter_list|(
name|struct
name|inferior_list_entry
modifier|*
name|entry
parameter_list|)
block|{
name|struct
name|thread_info
modifier|*
name|thread
init|=
operator|(
expr|struct
name|thread_info
operator|*
operator|)
name|entry
decl_stmt|;
name|struct
name|process_info
modifier|*
name|process
init|=
name|get_thread_process
argument_list|(
name|thread
argument_list|)
decl_stmt|;
name|int
name|wstat
decl_stmt|;
do|do
block|{
name|ptrace
argument_list|(
name|PTRACE_KILL
argument_list|,
name|pid_of
argument_list|(
name|process
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Make sure it died.  The loop is most likely unnecessary.  */
name|wstat
operator|=
name|linux_wait_for_event
argument_list|(
name|thread
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|WIFSTOPPED
argument_list|(
name|wstat
argument_list|)
condition|)
do|;
block|}
end_function

begin_function
specifier|static
name|void
name|linux_kill
parameter_list|(
name|void
parameter_list|)
block|{
name|for_each_inferior
argument_list|(
operator|&
name|all_threads
argument_list|,
name|linux_kill_one_process
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|linux_detach_one_process
parameter_list|(
name|struct
name|inferior_list_entry
modifier|*
name|entry
parameter_list|)
block|{
name|struct
name|thread_info
modifier|*
name|thread
init|=
operator|(
expr|struct
name|thread_info
operator|*
operator|)
name|entry
decl_stmt|;
name|struct
name|process_info
modifier|*
name|process
init|=
name|get_thread_process
argument_list|(
name|thread
argument_list|)
decl_stmt|;
name|ptrace
argument_list|(
name|PTRACE_DETACH
argument_list|,
name|pid_of
argument_list|(
name|process
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|linux_detach
parameter_list|(
name|void
parameter_list|)
block|{
name|for_each_inferior
argument_list|(
operator|&
name|all_threads
argument_list|,
name|linux_detach_one_process
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return nonzero if the given thread is still alive.  */
end_comment

begin_function
specifier|static
name|int
name|linux_thread_alive
parameter_list|(
name|int
name|tid
parameter_list|)
block|{
if|if
condition|(
name|find_inferior_id
argument_list|(
operator|&
name|all_threads
argument_list|,
name|tid
argument_list|)
operator|!=
name|NULL
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if this process stopped at a breakpoint which    no longer appears to be inserted.  Also adjust the PC    appropriately to resume where the breakpoint used to be.  */
end_comment

begin_function
specifier|static
name|int
name|check_removed_breakpoint
parameter_list|(
name|struct
name|process_info
modifier|*
name|event_child
parameter_list|)
block|{
name|CORE_ADDR
name|stop_pc
decl_stmt|;
name|struct
name|thread_info
modifier|*
name|saved_inferior
decl_stmt|;
if|if
condition|(
name|event_child
operator|->
name|pending_is_breakpoint
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|debug_threads
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Checking for breakpoint.\n"
argument_list|)
expr_stmt|;
name|saved_inferior
operator|=
name|current_inferior
expr_stmt|;
name|current_inferior
operator|=
name|get_process_thread
argument_list|(
name|event_child
argument_list|)
expr_stmt|;
name|stop_pc
operator|=
name|get_stop_pc
argument_list|()
expr_stmt|;
comment|/* If the PC has changed since we stopped, then we shouldn't do      anything.  This happens if, for instance, GDB handled the      decr_pc_after_break subtraction itself.  */
if|if
condition|(
name|stop_pc
operator|!=
name|event_child
operator|->
name|pending_stop_pc
condition|)
block|{
if|if
condition|(
name|debug_threads
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Ignoring, PC was changed.\n"
argument_list|)
expr_stmt|;
name|event_child
operator|->
name|pending_is_breakpoint
operator|=
literal|0
expr_stmt|;
name|current_inferior
operator|=
name|saved_inferior
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* If the breakpoint is still there, we will report hitting it.  */
if|if
condition|(
call|(
modifier|*
name|the_low_target
operator|.
name|breakpoint_at
call|)
argument_list|(
name|stop_pc
argument_list|)
condition|)
block|{
if|if
condition|(
name|debug_threads
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Ignoring, breakpoint is still present.\n"
argument_list|)
expr_stmt|;
name|current_inferior
operator|=
name|saved_inferior
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|debug_threads
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Removed breakpoint.\n"
argument_list|)
expr_stmt|;
comment|/* For decr_pc_after_break targets, here is where we perform the      decrement.  We go immediately from this function to resuming,      and can not safely call get_stop_pc () again.  */
if|if
condition|(
name|the_low_target
operator|.
name|set_pc
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|the_low_target
operator|.
name|set_pc
call|)
argument_list|(
name|stop_pc
argument_list|)
expr_stmt|;
comment|/* We consumed the pending SIGTRAP.  */
name|event_child
operator|->
name|pending_is_breakpoint
operator|=
literal|0
expr_stmt|;
name|event_child
operator|->
name|status_pending_p
operator|=
literal|0
expr_stmt|;
name|event_child
operator|->
name|status_pending
operator|=
literal|0
expr_stmt|;
name|current_inferior
operator|=
name|saved_inferior
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if this process has an interesting status pending.  This function    may silently resume an inferior process.  */
end_comment

begin_function
specifier|static
name|int
name|status_pending_p
parameter_list|(
name|struct
name|inferior_list_entry
modifier|*
name|entry
parameter_list|,
name|void
modifier|*
name|dummy
parameter_list|)
block|{
name|struct
name|process_info
modifier|*
name|process
init|=
operator|(
expr|struct
name|process_info
operator|*
operator|)
name|entry
decl_stmt|;
if|if
condition|(
name|process
operator|->
name|status_pending_p
condition|)
if|if
condition|(
name|check_removed_breakpoint
argument_list|(
name|process
argument_list|)
condition|)
block|{
comment|/* This thread was stopped at a breakpoint, and the breakpoint 	   is now gone.  We were told to continue (or step...) all threads, 	   so GDB isn't trying to single-step past this breakpoint. 	   So instead of reporting the old SIGTRAP, pretend we got to 	   the breakpoint just after it was removed instead of just 	   before; resume the process.  */
name|linux_resume_one_process
argument_list|(
operator|&
name|process
operator|->
name|head
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|process
operator|->
name|status_pending_p
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|linux_wait_for_process
parameter_list|(
name|struct
name|process_info
modifier|*
modifier|*
name|childp
parameter_list|,
name|int
modifier|*
name|wstatp
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|int
name|to_wait_for
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
operator|*
name|childp
operator|!=
name|NULL
condition|)
name|to_wait_for
operator|=
operator|(
operator|*
name|childp
operator|)
operator|->
name|lwpid
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|ret
operator|=
name|waitpid
argument_list|(
name|to_wait_for
argument_list|,
name|wstatp
argument_list|,
name|WNOHANG
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ECHILD
condition|)
name|perror_with_name
argument_list|(
literal|"waitpid"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ret
operator|>
literal|0
condition|)
break|break;
name|ret
operator|=
name|waitpid
argument_list|(
name|to_wait_for
argument_list|,
name|wstatp
argument_list|,
name|WNOHANG
operator||
name|__WCLONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ECHILD
condition|)
name|perror_with_name
argument_list|(
literal|"waitpid (WCLONE)"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ret
operator|>
literal|0
condition|)
break|break;
name|usleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|debug_threads
operator|&&
operator|(
operator|!
name|WIFSTOPPED
argument_list|(
operator|*
name|wstatp
argument_list|)
operator|||
operator|(
name|WSTOPSIG
argument_list|(
operator|*
name|wstatp
argument_list|)
operator|!=
literal|32
operator|&&
name|WSTOPSIG
argument_list|(
operator|*
name|wstatp
argument_list|)
operator|!=
literal|33
operator|)
operator|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Got an event from %d (%x)\n"
argument_list|,
name|ret
argument_list|,
operator|*
name|wstatp
argument_list|)
expr_stmt|;
if|if
condition|(
name|to_wait_for
operator|==
operator|-
literal|1
condition|)
operator|*
name|childp
operator|=
operator|(
expr|struct
name|process_info
operator|*
operator|)
name|find_inferior_id
argument_list|(
operator|&
name|all_processes
argument_list|,
name|ret
argument_list|)
expr_stmt|;
operator|(
operator|*
name|childp
operator|)
operator|->
name|stopped
operator|=
literal|1
expr_stmt|;
operator|(
operator|*
name|childp
operator|)
operator|->
name|pending_is_breakpoint
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|debug_threads
operator|&&
name|WIFSTOPPED
argument_list|(
operator|*
name|wstatp
argument_list|)
condition|)
block|{
name|current_inferior
operator|=
operator|(
expr|struct
name|thread_info
operator|*
operator|)
name|find_inferior_id
argument_list|(
operator|&
name|all_threads
argument_list|,
operator|(
operator|*
name|childp
operator|)
operator|->
name|tid
argument_list|)
expr_stmt|;
comment|/* For testing only; i386_stop_pc prints out a diagnostic.  */
if|if
condition|(
name|the_low_target
operator|.
name|get_pc
operator|!=
name|NULL
condition|)
name|get_stop_pc
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|linux_wait_for_event
parameter_list|(
name|struct
name|thread_info
modifier|*
name|child
parameter_list|)
block|{
name|CORE_ADDR
name|stop_pc
decl_stmt|;
name|struct
name|process_info
modifier|*
name|event_child
decl_stmt|;
name|int
name|wstat
decl_stmt|;
comment|/* Check for a process with a pending status.  */
comment|/* It is possible that the user changed the pending task's registers since      it stopped.  We correctly handle the change of PC if we hit a breakpoint      (in check_removed_breakpoint); signals should be reported anyway.  */
if|if
condition|(
name|child
operator|==
name|NULL
condition|)
block|{
name|event_child
operator|=
operator|(
expr|struct
name|process_info
operator|*
operator|)
name|find_inferior
argument_list|(
operator|&
name|all_processes
argument_list|,
name|status_pending_p
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_threads
operator|&&
name|event_child
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Got a pending child %d\n"
argument_list|,
name|event_child
operator|->
name|lwpid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|event_child
operator|=
name|get_thread_process
argument_list|(
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|event_child
operator|->
name|status_pending_p
operator|&&
name|check_removed_breakpoint
argument_list|(
name|event_child
argument_list|)
condition|)
name|event_child
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|event_child
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|event_child
operator|->
name|status_pending_p
condition|)
block|{
if|if
condition|(
name|debug_threads
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Got an event from pending child %d (%04x)\n"
argument_list|,
name|event_child
operator|->
name|lwpid
argument_list|,
name|event_child
operator|->
name|status_pending
argument_list|)
expr_stmt|;
name|wstat
operator|=
name|event_child
operator|->
name|status_pending
expr_stmt|;
name|event_child
operator|->
name|status_pending_p
operator|=
literal|0
expr_stmt|;
name|event_child
operator|->
name|status_pending
operator|=
literal|0
expr_stmt|;
name|current_inferior
operator|=
name|get_process_thread
argument_list|(
name|event_child
argument_list|)
expr_stmt|;
return|return
name|wstat
return|;
block|}
block|}
comment|/* We only enter this loop if no process has a pending wait status.  Thus      any action taken in response to a wait status inside this loop is      responding as soon as we detect the status, not after any pending      events.  */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|child
operator|==
name|NULL
condition|)
name|event_child
operator|=
name|NULL
expr_stmt|;
else|else
name|event_child
operator|=
name|get_thread_process
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|linux_wait_for_process
argument_list|(
operator|&
name|event_child
argument_list|,
operator|&
name|wstat
argument_list|)
expr_stmt|;
if|if
condition|(
name|event_child
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"event from unknown child"
argument_list|)
expr_stmt|;
name|current_inferior
operator|=
operator|(
expr|struct
name|thread_info
operator|*
operator|)
name|find_inferior_id
argument_list|(
operator|&
name|all_threads
argument_list|,
name|event_child
operator|->
name|tid
argument_list|)
expr_stmt|;
if|if
condition|(
name|using_threads
condition|)
block|{
comment|/* Check for thread exit.  */
if|if
condition|(
operator|!
name|WIFSTOPPED
argument_list|(
name|wstat
argument_list|)
condition|)
block|{
if|if
condition|(
name|debug_threads
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Thread %d (LWP %d) exiting\n"
argument_list|,
name|event_child
operator|->
name|tid
argument_list|,
name|event_child
operator|->
name|head
operator|.
name|id
argument_list|)
expr_stmt|;
comment|/* If the last thread is exiting, just return.  */
if|if
condition|(
name|all_threads
operator|.
name|head
operator|==
name|all_threads
operator|.
name|tail
condition|)
return|return
name|wstat
return|;
name|dead_thread_notify
argument_list|(
name|event_child
operator|->
name|tid
argument_list|)
expr_stmt|;
name|remove_inferior
argument_list|(
operator|&
name|all_processes
argument_list|,
operator|&
name|event_child
operator|->
name|head
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|event_child
argument_list|)
expr_stmt|;
name|remove_thread
argument_list|(
name|current_inferior
argument_list|)
expr_stmt|;
name|current_inferior
operator|=
operator|(
expr|struct
name|thread_info
operator|*
operator|)
name|all_threads
operator|.
name|head
expr_stmt|;
comment|/* If we were waiting for this particular child to do something... 		 well, it did something.  */
if|if
condition|(
name|child
operator|!=
name|NULL
condition|)
return|return
name|wstat
return|;
comment|/* Wait for a more interesting event.  */
continue|continue;
block|}
if|if
condition|(
name|WIFSTOPPED
argument_list|(
name|wstat
argument_list|)
operator|&&
name|WSTOPSIG
argument_list|(
name|wstat
argument_list|)
operator|==
name|SIGSTOP
operator|&&
name|event_child
operator|->
name|stop_expected
condition|)
block|{
if|if
condition|(
name|debug_threads
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Expected stop.\n"
argument_list|)
expr_stmt|;
name|event_child
operator|->
name|stop_expected
operator|=
literal|0
expr_stmt|;
name|linux_resume_one_process
argument_list|(
operator|&
name|event_child
operator|->
name|head
argument_list|,
name|event_child
operator|->
name|stepping
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* FIXME drow/2002-06-09: Get signal numbers from the inferior's 	     thread library?  */
if|if
condition|(
name|WIFSTOPPED
argument_list|(
name|wstat
argument_list|)
operator|&&
operator|(
name|WSTOPSIG
argument_list|(
name|wstat
argument_list|)
operator|==
name|__SIGRTMIN
operator|||
name|WSTOPSIG
argument_list|(
name|wstat
argument_list|)
operator|==
name|__SIGRTMIN
operator|+
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|debug_threads
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Ignored signal %d for %d (LWP %d).\n"
argument_list|,
name|WSTOPSIG
argument_list|(
name|wstat
argument_list|)
argument_list|,
name|event_child
operator|->
name|tid
argument_list|,
name|event_child
operator|->
name|head
operator|.
name|id
argument_list|)
expr_stmt|;
name|linux_resume_one_process
argument_list|(
operator|&
name|event_child
operator|->
name|head
argument_list|,
name|event_child
operator|->
name|stepping
argument_list|,
name|WSTOPSIG
argument_list|(
name|wstat
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* If this event was not handled above, and is not a SIGTRAP, report 	 it.  */
if|if
condition|(
operator|!
name|WIFSTOPPED
argument_list|(
name|wstat
argument_list|)
operator|||
name|WSTOPSIG
argument_list|(
name|wstat
argument_list|)
operator|!=
name|SIGTRAP
condition|)
return|return
name|wstat
return|;
comment|/* If this target does not support breakpoints, we simply report the 	 SIGTRAP; it's of no concern to us.  */
if|if
condition|(
name|the_low_target
operator|.
name|get_pc
operator|==
name|NULL
condition|)
return|return
name|wstat
return|;
name|stop_pc
operator|=
name|get_stop_pc
argument_list|()
expr_stmt|;
comment|/* bp_reinsert will only be set if we were single-stepping. 	 Notice that we will resume the process after hitting 	 a gdbserver breakpoint; single-stepping to/over one 	 is not supported (yet).  */
if|if
condition|(
name|event_child
operator|->
name|bp_reinsert
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|debug_threads
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Reinserted breakpoint.\n"
argument_list|)
expr_stmt|;
name|reinsert_breakpoint
argument_list|(
name|event_child
operator|->
name|bp_reinsert
argument_list|)
expr_stmt|;
name|event_child
operator|->
name|bp_reinsert
operator|=
literal|0
expr_stmt|;
comment|/* Clear the single-stepping flag and SIGTRAP as we resume.  */
name|linux_resume_one_process
argument_list|(
operator|&
name|event_child
operator|->
name|head
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|debug_threads
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Hit a (non-reinsert) breakpoint.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|check_breakpoints
argument_list|(
name|stop_pc
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* We hit one of our own breakpoints.  We mark it as a pending 	     breakpoint, so that check_removed_breakpoint () will do the PC 	     adjustment for us at the appropriate time.  */
name|event_child
operator|->
name|pending_is_breakpoint
operator|=
literal|1
expr_stmt|;
name|event_child
operator|->
name|pending_stop_pc
operator|=
name|stop_pc
expr_stmt|;
comment|/* Now we need to put the breakpoint back.  We continue in the event 	     loop instead of simply replacing the breakpoint right away, 	     in order to not lose signals sent to the thread that hit the 	     breakpoint.  Unfortunately this increases the window where another 	     thread could sneak past the removed breakpoint.  For the current 	     use of server-side breakpoints (thread creation) this is 	     acceptable; but it needs to be considered before this breakpoint 	     mechanism can be used in more general ways.  For some breakpoints 	     it may be necessary to stop all other threads, but that should 	     be avoided where possible.  	     If breakpoint_reinsert_addr is NULL, that means that we can 	     use PTRACE_SINGLESTEP on this platform.  Uninsert the breakpoint, 	     mark it for reinsertion, and single-step.  	     Otherwise, call the target function to figure out where we need 	     our temporary breakpoint, create it, and continue executing this 	     process.  */
if|if
condition|(
name|the_low_target
operator|.
name|breakpoint_reinsert_addr
operator|==
name|NULL
condition|)
block|{
name|event_child
operator|->
name|bp_reinsert
operator|=
name|stop_pc
expr_stmt|;
name|uninsert_breakpoint
argument_list|(
name|stop_pc
argument_list|)
expr_stmt|;
name|linux_resume_one_process
argument_list|(
operator|&
name|event_child
operator|->
name|head
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|reinsert_breakpoint_by_bp
argument_list|(
name|stop_pc
argument_list|,
call|(
modifier|*
name|the_low_target
operator|.
name|breakpoint_reinsert_addr
call|)
argument_list|()
argument_list|)
expr_stmt|;
name|linux_resume_one_process
argument_list|(
operator|&
name|event_child
operator|->
name|head
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* If we were single-stepping, we definitely want to report the 	 SIGTRAP.  The single-step operation has completed, so also          clear the stepping flag; in general this does not matter, 	 because the SIGTRAP will be reported to the client, which 	 will give us a new action for this thread, but clear it for 	 consistency anyway.  It's safe to clear the stepping flag          because the only consumer of get_stop_pc () after this point 	 is check_removed_breakpoint, and pending_is_breakpoint is not 	 set.  It might be wiser to use a step_completed flag instead.  */
if|if
condition|(
name|event_child
operator|->
name|stepping
condition|)
block|{
name|event_child
operator|->
name|stepping
operator|=
literal|0
expr_stmt|;
return|return
name|wstat
return|;
block|}
comment|/* A SIGTRAP that we can't explain.  It may have been a breakpoint. 	 Check if it is a breakpoint, and if so mark the process information 	 accordingly.  This will handle both the necessary fiddling with the 	 PC on decr_pc_after_break targets and suppressing extra threads 	 hitting a breakpoint if two hit it at once and then GDB removes it 	 after the first is reported.  Arguably it would be better to report 	 multiple threads hitting breakpoints simultaneously, but the current 	 remote protocol does not allow this.  */
if|if
condition|(
call|(
modifier|*
name|the_low_target
operator|.
name|breakpoint_at
call|)
argument_list|(
name|stop_pc
argument_list|)
condition|)
block|{
name|event_child
operator|->
name|pending_is_breakpoint
operator|=
literal|1
expr_stmt|;
name|event_child
operator|->
name|pending_stop_pc
operator|=
name|stop_pc
expr_stmt|;
block|}
return|return
name|wstat
return|;
block|}
comment|/* NOTREACHED */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Wait for process, returns status.  */
end_comment

begin_function
specifier|static
name|unsigned
name|char
name|linux_wait
parameter_list|(
name|char
modifier|*
name|status
parameter_list|)
block|{
name|int
name|w
decl_stmt|;
name|struct
name|thread_info
modifier|*
name|child
init|=
name|NULL
decl_stmt|;
name|retry
label|:
comment|/* If we were only supposed to resume one thread, only wait for      that thread - if it's still alive.  If it died, however - which      can happen if we're coming from the thread death case below -      then we need to make sure we restart the other threads.  We could      pick a thread at random or restart all; restarting all is less      arbitrary.  */
if|if
condition|(
name|cont_thread
operator|>
literal|0
condition|)
block|{
name|child
operator|=
operator|(
expr|struct
name|thread_info
operator|*
operator|)
name|find_inferior_id
argument_list|(
operator|&
name|all_threads
argument_list|,
name|cont_thread
argument_list|)
expr_stmt|;
comment|/* No stepping, no signal - unless one is pending already, of course.  */
if|if
condition|(
name|child
operator|==
name|NULL
condition|)
block|{
name|struct
name|thread_resume
name|resume_info
decl_stmt|;
name|resume_info
operator|.
name|thread
operator|=
operator|-
literal|1
expr_stmt|;
name|resume_info
operator|.
name|step
operator|=
name|resume_info
operator|.
name|sig
operator|=
name|resume_info
operator|.
name|leave_stopped
operator|=
literal|0
expr_stmt|;
name|linux_resume
argument_list|(
operator|&
name|resume_info
argument_list|)
expr_stmt|;
block|}
block|}
name|enable_async_io
argument_list|()
expr_stmt|;
name|unblock_async_io
argument_list|()
expr_stmt|;
name|w
operator|=
name|linux_wait_for_event
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|stop_all_processes
argument_list|()
expr_stmt|;
name|disable_async_io
argument_list|()
expr_stmt|;
comment|/* If we are waiting for a particular child, and it exited,      linux_wait_for_event will return its exit status.  Similarly if      the last child exited.  If this is not the last child, however,      do not report it as exited until there is a 'thread exited' response      available in the remote protocol.  Instead, just wait for another event.      This should be safe, because if the thread crashed we will already      have reported the termination signal to GDB; that should stop any      in-progress stepping operations, etc.       Report the exit status of the last thread to exit.  This matches      LinuxThreads' behavior.  */
if|if
condition|(
name|all_threads
operator|.
name|head
operator|==
name|all_threads
operator|.
name|tail
condition|)
block|{
if|if
condition|(
name|WIFEXITED
argument_list|(
name|w
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nChild exited with retcode = %x \n"
argument_list|,
name|WEXITSTATUS
argument_list|(
name|w
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|status
operator|=
literal|'W'
expr_stmt|;
name|clear_inferiors
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|all_processes
operator|.
name|head
argument_list|)
expr_stmt|;
name|all_processes
operator|.
name|head
operator|=
name|all_processes
operator|.
name|tail
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
operator|(
name|unsigned
name|char
operator|)
name|WEXITSTATUS
argument_list|(
name|w
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|WIFSTOPPED
argument_list|(
name|w
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nChild terminated with signal = %x \n"
argument_list|,
name|WTERMSIG
argument_list|(
name|w
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|status
operator|=
literal|'X'
expr_stmt|;
name|clear_inferiors
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|all_processes
operator|.
name|head
argument_list|)
expr_stmt|;
name|all_processes
operator|.
name|head
operator|=
name|all_processes
operator|.
name|tail
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
operator|(
name|unsigned
name|char
operator|)
name|WTERMSIG
argument_list|(
name|w
argument_list|)
operator|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|WIFSTOPPED
argument_list|(
name|w
argument_list|)
condition|)
goto|goto
name|retry
goto|;
block|}
operator|*
name|status
operator|=
literal|'T'
expr_stmt|;
return|return
operator|(
operator|(
name|unsigned
name|char
operator|)
name|WSTOPSIG
argument_list|(
name|w
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|send_sigstop
parameter_list|(
name|struct
name|inferior_list_entry
modifier|*
name|entry
parameter_list|)
block|{
name|struct
name|process_info
modifier|*
name|process
init|=
operator|(
expr|struct
name|process_info
operator|*
operator|)
name|entry
decl_stmt|;
if|if
condition|(
name|process
operator|->
name|stopped
condition|)
return|return;
comment|/* If we already have a pending stop signal for this process, don't      send another.  */
if|if
condition|(
name|process
operator|->
name|stop_expected
condition|)
block|{
name|process
operator|->
name|stop_expected
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|debug_threads
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Sending sigstop to process %d\n"
argument_list|,
name|process
operator|->
name|head
operator|.
name|id
argument_list|)
expr_stmt|;
name|kill
argument_list|(
name|process
operator|->
name|head
operator|.
name|id
argument_list|,
name|SIGSTOP
argument_list|)
expr_stmt|;
name|process
operator|->
name|sigstop_sent
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wait_for_sigstop
parameter_list|(
name|struct
name|inferior_list_entry
modifier|*
name|entry
parameter_list|)
block|{
name|struct
name|process_info
modifier|*
name|process
init|=
operator|(
expr|struct
name|process_info
operator|*
operator|)
name|entry
decl_stmt|;
name|struct
name|thread_info
modifier|*
name|saved_inferior
decl_stmt|,
modifier|*
name|thread
decl_stmt|;
name|int
name|wstat
decl_stmt|,
name|saved_tid
decl_stmt|;
if|if
condition|(
name|process
operator|->
name|stopped
condition|)
return|return;
name|saved_inferior
operator|=
name|current_inferior
expr_stmt|;
name|saved_tid
operator|=
operator|(
operator|(
expr|struct
name|inferior_list_entry
operator|*
operator|)
name|saved_inferior
operator|)
operator|->
name|id
expr_stmt|;
name|thread
operator|=
operator|(
expr|struct
name|thread_info
operator|*
operator|)
name|find_inferior_id
argument_list|(
operator|&
name|all_threads
argument_list|,
name|process
operator|->
name|tid
argument_list|)
expr_stmt|;
name|wstat
operator|=
name|linux_wait_for_event
argument_list|(
name|thread
argument_list|)
expr_stmt|;
comment|/* If we stopped with a non-SIGSTOP signal, save it for later      and record the pending SIGSTOP.  If the process exited, just      return.  */
if|if
condition|(
name|WIFSTOPPED
argument_list|(
name|wstat
argument_list|)
operator|&&
name|WSTOPSIG
argument_list|(
name|wstat
argument_list|)
operator|!=
name|SIGSTOP
condition|)
block|{
if|if
condition|(
name|debug_threads
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Stopped with non-sigstop signal\n"
argument_list|)
expr_stmt|;
name|process
operator|->
name|status_pending_p
operator|=
literal|1
expr_stmt|;
name|process
operator|->
name|status_pending
operator|=
name|wstat
expr_stmt|;
name|process
operator|->
name|stop_expected
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|linux_thread_alive
argument_list|(
name|saved_tid
argument_list|)
condition|)
name|current_inferior
operator|=
name|saved_inferior
expr_stmt|;
else|else
block|{
if|if
condition|(
name|debug_threads
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Previously current thread died.\n"
argument_list|)
expr_stmt|;
comment|/* Set a valid thread as current.  */
name|set_desired_inferior
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|stop_all_processes
parameter_list|(
name|void
parameter_list|)
block|{
name|stopping_threads
operator|=
literal|1
expr_stmt|;
name|for_each_inferior
argument_list|(
operator|&
name|all_processes
argument_list|,
name|send_sigstop
argument_list|)
expr_stmt|;
name|for_each_inferior
argument_list|(
operator|&
name|all_processes
argument_list|,
name|wait_for_sigstop
argument_list|)
expr_stmt|;
name|stopping_threads
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Resume execution of the inferior process.    If STEP is nonzero, single-step it.    If SIGNAL is nonzero, give it that signal.  */
end_comment

begin_function
specifier|static
name|void
name|linux_resume_one_process
parameter_list|(
name|struct
name|inferior_list_entry
modifier|*
name|entry
parameter_list|,
name|int
name|step
parameter_list|,
name|int
name|signal
parameter_list|)
block|{
name|struct
name|process_info
modifier|*
name|process
init|=
operator|(
expr|struct
name|process_info
operator|*
operator|)
name|entry
decl_stmt|;
name|struct
name|thread_info
modifier|*
name|saved_inferior
decl_stmt|;
if|if
condition|(
name|process
operator|->
name|stopped
operator|==
literal|0
condition|)
return|return;
comment|/* If we have pending signals or status, and a new signal, enqueue the      signal.  Also enqueue the signal if we are waiting to reinsert a      breakpoint; it will be picked up again below.  */
if|if
condition|(
name|signal
operator|!=
literal|0
operator|&&
operator|(
name|process
operator|->
name|status_pending_p
operator|||
name|process
operator|->
name|pending_signals
operator|!=
name|NULL
operator|||
name|process
operator|->
name|bp_reinsert
operator|!=
literal|0
operator|)
condition|)
block|{
name|struct
name|pending_signals
modifier|*
name|p_sig
decl_stmt|;
name|p_sig
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|p_sig
argument_list|)
argument_list|)
expr_stmt|;
name|p_sig
operator|->
name|prev
operator|=
name|process
operator|->
name|pending_signals
expr_stmt|;
name|p_sig
operator|->
name|signal
operator|=
name|signal
expr_stmt|;
name|process
operator|->
name|pending_signals
operator|=
name|p_sig
expr_stmt|;
block|}
if|if
condition|(
name|process
operator|->
name|status_pending_p
operator|&&
operator|!
name|check_removed_breakpoint
argument_list|(
name|process
argument_list|)
condition|)
return|return;
name|saved_inferior
operator|=
name|current_inferior
expr_stmt|;
name|current_inferior
operator|=
name|get_process_thread
argument_list|(
name|process
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_threads
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Resuming process %d (%s, signal %d, stop %s)\n"
argument_list|,
name|inferior_pid
argument_list|,
name|step
condition|?
literal|"step"
else|:
literal|"continue"
argument_list|,
name|signal
argument_list|,
name|process
operator|->
name|stop_expected
condition|?
literal|"expected"
else|:
literal|"not expected"
argument_list|)
expr_stmt|;
comment|/* This bit needs some thinking about.  If we get a signal that      we must report while a single-step reinsert is still pending,      we often end up resuming the thread.  It might be better to      (ew) allow a stack of pending events; then we could be sure that      the reinsert happened right away and not lose any signals.       Making this stack would also shrink the window in which breakpoints are      uninserted (see comment in linux_wait_for_process) but not enough for      complete correctness, so it won't solve that problem.  It may be      worthwhile just to solve this one, however.  */
if|if
condition|(
name|process
operator|->
name|bp_reinsert
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|debug_threads
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  pending reinsert at %08lx"
argument_list|,
operator|(
name|long
operator|)
name|process
operator|->
name|bp_reinsert
argument_list|)
expr_stmt|;
if|if
condition|(
name|step
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"BAD - reinserting but not stepping.\n"
argument_list|)
expr_stmt|;
name|step
operator|=
literal|1
expr_stmt|;
comment|/* Postpone any pending signal.  It was enqueued above.  */
name|signal
operator|=
literal|0
expr_stmt|;
block|}
name|check_removed_breakpoint
argument_list|(
name|process
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_threads
operator|&&
name|the_low_target
operator|.
name|get_pc
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  "
argument_list|)
expr_stmt|;
call|(
name|long
call|)
argument_list|(
operator|*
name|the_low_target
operator|.
name|get_pc
argument_list|)
argument_list|()
expr_stmt|;
block|}
comment|/* If we have pending signals, consume one unless we are trying to reinsert      a breakpoint.  */
if|if
condition|(
name|process
operator|->
name|pending_signals
operator|!=
name|NULL
operator|&&
name|process
operator|->
name|bp_reinsert
operator|==
literal|0
condition|)
block|{
name|struct
name|pending_signals
modifier|*
modifier|*
name|p_sig
decl_stmt|;
name|p_sig
operator|=
operator|&
name|process
operator|->
name|pending_signals
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|p_sig
operator|)
operator|->
name|prev
operator|!=
name|NULL
condition|)
name|p_sig
operator|=
operator|&
operator|(
operator|*
name|p_sig
operator|)
operator|->
name|prev
expr_stmt|;
name|signal
operator|=
operator|(
operator|*
name|p_sig
operator|)
operator|->
name|signal
expr_stmt|;
name|free
argument_list|(
operator|*
name|p_sig
argument_list|)
expr_stmt|;
operator|*
name|p_sig
operator|=
name|NULL
expr_stmt|;
block|}
name|regcache_invalidate_one
argument_list|(
operator|(
expr|struct
name|inferior_list_entry
operator|*
operator|)
name|get_process_thread
argument_list|(
name|process
argument_list|)
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|process
operator|->
name|stopped
operator|=
literal|0
expr_stmt|;
name|process
operator|->
name|stepping
operator|=
name|step
expr_stmt|;
name|ptrace
argument_list|(
name|step
condition|?
name|PTRACE_SINGLESTEP
else|:
name|PTRACE_CONT
argument_list|,
name|process
operator|->
name|lwpid
argument_list|,
literal|0
argument_list|,
name|signal
argument_list|)
expr_stmt|;
name|current_inferior
operator|=
name|saved_inferior
expr_stmt|;
if|if
condition|(
name|errno
condition|)
name|perror_with_name
argument_list|(
literal|"ptrace"
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|thread_resume
modifier|*
name|resume_ptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This function is called once per thread.  We look up the thread    in RESUME_PTR, and mark the thread with a pointer to the appropriate    resume request.     This algorithm is O(threads * resume elements), but resume elements    is small (and will remain small at least until GDB supports thread    suspension).  */
end_comment

begin_function
specifier|static
name|void
name|linux_set_resume_request
parameter_list|(
name|struct
name|inferior_list_entry
modifier|*
name|entry
parameter_list|)
block|{
name|struct
name|process_info
modifier|*
name|process
decl_stmt|;
name|struct
name|thread_info
modifier|*
name|thread
decl_stmt|;
name|int
name|ndx
decl_stmt|;
name|thread
operator|=
operator|(
expr|struct
name|thread_info
operator|*
operator|)
name|entry
expr_stmt|;
name|process
operator|=
name|get_thread_process
argument_list|(
name|thread
argument_list|)
expr_stmt|;
name|ndx
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|resume_ptr
index|[
name|ndx
index|]
operator|.
name|thread
operator|!=
operator|-
literal|1
operator|&&
name|resume_ptr
index|[
name|ndx
index|]
operator|.
name|thread
operator|!=
name|entry
operator|->
name|id
condition|)
name|ndx
operator|++
expr_stmt|;
name|process
operator|->
name|resume
operator|=
operator|&
name|resume_ptr
index|[
name|ndx
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function is called once per thread.  We check the thread's resume    request, which will tell us whether to resume, step, or leave the thread    stopped; and what signal, if any, it should be sent.  For threads which    we aren't explicitly told otherwise, we preserve the stepping flag; this    is used for stepping over gdbserver-placed breakpoints.  */
end_comment

begin_function
specifier|static
name|void
name|linux_continue_one_thread
parameter_list|(
name|struct
name|inferior_list_entry
modifier|*
name|entry
parameter_list|)
block|{
name|struct
name|process_info
modifier|*
name|process
decl_stmt|;
name|struct
name|thread_info
modifier|*
name|thread
decl_stmt|;
name|int
name|step
decl_stmt|;
name|thread
operator|=
operator|(
expr|struct
name|thread_info
operator|*
operator|)
name|entry
expr_stmt|;
name|process
operator|=
name|get_thread_process
argument_list|(
name|thread
argument_list|)
expr_stmt|;
if|if
condition|(
name|process
operator|->
name|resume
operator|->
name|leave_stopped
condition|)
return|return;
if|if
condition|(
name|process
operator|->
name|resume
operator|->
name|thread
operator|==
operator|-
literal|1
condition|)
name|step
operator|=
name|process
operator|->
name|stepping
operator|||
name|process
operator|->
name|resume
operator|->
name|step
expr_stmt|;
else|else
name|step
operator|=
name|process
operator|->
name|resume
operator|->
name|step
expr_stmt|;
name|linux_resume_one_process
argument_list|(
operator|&
name|process
operator|->
name|head
argument_list|,
name|step
argument_list|,
name|process
operator|->
name|resume
operator|->
name|sig
argument_list|)
expr_stmt|;
name|process
operator|->
name|resume
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function is called once per thread.  We check the thread's resume    request, which will tell us whether to resume, step, or leave the thread    stopped; and what signal, if any, it should be sent.  We queue any needed    signals, since we won't actually resume.  We already have a pending event    to report, so we don't need to preserve any step requests; they should    be re-issued if necessary.  */
end_comment

begin_function
specifier|static
name|void
name|linux_queue_one_thread
parameter_list|(
name|struct
name|inferior_list_entry
modifier|*
name|entry
parameter_list|)
block|{
name|struct
name|process_info
modifier|*
name|process
decl_stmt|;
name|struct
name|thread_info
modifier|*
name|thread
decl_stmt|;
name|thread
operator|=
operator|(
expr|struct
name|thread_info
operator|*
operator|)
name|entry
expr_stmt|;
name|process
operator|=
name|get_thread_process
argument_list|(
name|thread
argument_list|)
expr_stmt|;
if|if
condition|(
name|process
operator|->
name|resume
operator|->
name|leave_stopped
condition|)
return|return;
comment|/* If we have a new signal, enqueue the signal.  */
if|if
condition|(
name|process
operator|->
name|resume
operator|->
name|sig
operator|!=
literal|0
condition|)
block|{
name|struct
name|pending_signals
modifier|*
name|p_sig
decl_stmt|;
name|p_sig
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|p_sig
argument_list|)
argument_list|)
expr_stmt|;
name|p_sig
operator|->
name|prev
operator|=
name|process
operator|->
name|pending_signals
expr_stmt|;
name|p_sig
operator|->
name|signal
operator|=
name|process
operator|->
name|resume
operator|->
name|sig
expr_stmt|;
name|process
operator|->
name|pending_signals
operator|=
name|p_sig
expr_stmt|;
block|}
name|process
operator|->
name|resume
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set DUMMY if this process has an interesting status pending.  */
end_comment

begin_function
specifier|static
name|int
name|resume_status_pending_p
parameter_list|(
name|struct
name|inferior_list_entry
modifier|*
name|entry
parameter_list|,
name|void
modifier|*
name|flag_p
parameter_list|)
block|{
name|struct
name|process_info
modifier|*
name|process
init|=
operator|(
expr|struct
name|process_info
operator|*
operator|)
name|entry
decl_stmt|;
comment|/* Processes which will not be resumed are not interesting, because      we might not wait for them next time through linux_wait.  */
if|if
condition|(
name|process
operator|->
name|resume
operator|->
name|leave_stopped
condition|)
return|return
literal|0
return|;
comment|/* If this thread has a removed breakpoint, we won't have any      events to report later, so check now.  check_removed_breakpoint      may clear status_pending_p.  We avoid calling check_removed_breakpoint      for any thread that we are not otherwise going to resume - this      lets us preserve stopped status when two threads hit a breakpoint.      GDB removes the breakpoint to single-step a particular thread      past it, then re-inserts it and resumes all threads.  We want      to report the second thread without resuming it in the interim.  */
if|if
condition|(
name|process
operator|->
name|status_pending_p
condition|)
name|check_removed_breakpoint
argument_list|(
name|process
argument_list|)
expr_stmt|;
if|if
condition|(
name|process
operator|->
name|status_pending_p
condition|)
operator|*
operator|(
name|int
operator|*
operator|)
name|flag_p
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|linux_resume
parameter_list|(
name|struct
name|thread_resume
modifier|*
name|resume_info
parameter_list|)
block|{
name|int
name|pending_flag
decl_stmt|;
comment|/* Yes, the use of a global here is rather ugly.  */
name|resume_ptr
operator|=
name|resume_info
expr_stmt|;
name|for_each_inferior
argument_list|(
operator|&
name|all_threads
argument_list|,
name|linux_set_resume_request
argument_list|)
expr_stmt|;
comment|/* If there is a thread which would otherwise be resumed, which      has a pending status, then don't resume any threads - we can just      report the pending status.  Make sure to queue any signals      that would otherwise be sent.  */
name|pending_flag
operator|=
literal|0
expr_stmt|;
name|find_inferior
argument_list|(
operator|&
name|all_processes
argument_list|,
name|resume_status_pending_p
argument_list|,
operator|&
name|pending_flag
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_threads
condition|)
block|{
if|if
condition|(
name|pending_flag
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Not resuming, pending status\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Resuming, no pending status\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pending_flag
condition|)
name|for_each_inferior
argument_list|(
operator|&
name|all_threads
argument_list|,
name|linux_queue_one_thread
argument_list|)
expr_stmt|;
else|else
block|{
name|block_async_io
argument_list|()
expr_stmt|;
name|enable_async_io
argument_list|()
expr_stmt|;
name|for_each_inferior
argument_list|(
operator|&
name|all_threads
argument_list|,
name|linux_continue_one_thread
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LINUX_USRREGS
end_ifdef

begin_function
name|int
name|register_addr
parameter_list|(
name|int
name|regnum
parameter_list|)
block|{
name|int
name|addr
decl_stmt|;
if|if
condition|(
name|regnum
operator|<
literal|0
operator|||
name|regnum
operator|>=
name|the_low_target
operator|.
name|num_regs
condition|)
name|error
argument_list|(
literal|"Invalid register number %d."
argument_list|,
name|regnum
argument_list|)
expr_stmt|;
name|addr
operator|=
name|the_low_target
operator|.
name|regmap
index|[
name|regnum
index|]
expr_stmt|;
return|return
name|addr
return|;
block|}
end_function

begin_comment
comment|/* Fetch one register.  */
end_comment

begin_function
specifier|static
name|void
name|fetch_register
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
name|CORE_ADDR
name|regaddr
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
if|if
condition|(
name|regno
operator|>=
name|the_low_target
operator|.
name|num_regs
condition|)
return|return;
if|if
condition|(
call|(
modifier|*
name|the_low_target
operator|.
name|cannot_fetch_register
call|)
argument_list|(
name|regno
argument_list|)
condition|)
return|return;
name|regaddr
operator|=
name|register_addr
argument_list|(
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|regaddr
operator|==
operator|-
literal|1
condition|)
return|return;
name|buf
operator|=
name|alloca
argument_list|(
name|register_size
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|register_size
argument_list|(
name|regno
argument_list|)
condition|;
name|i
operator|+=
sizeof|sizeof
argument_list|(
name|PTRACE_XFER_TYPE
argument_list|)
control|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
name|PTRACE_XFER_TYPE
operator|*
operator|)
operator|(
name|buf
operator|+
name|i
operator|)
operator|=
name|ptrace
argument_list|(
name|PTRACE_PEEKUSER
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|regaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|regaddr
operator|+=
sizeof|sizeof
argument_list|(
name|PTRACE_XFER_TYPE
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
block|{
comment|/* Warning, not error, in case we are attached; sometimes the 	     kernel doesn't let us at the registers.  */
name|char
modifier|*
name|err
init|=
name|strerror
argument_list|(
name|errno
argument_list|)
decl_stmt|;
name|char
modifier|*
name|msg
init|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|err
argument_list|)
operator|+
literal|128
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"reading register %d: %s"
argument_list|,
name|regno
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
block|}
name|supply_register
argument_list|(
name|regno
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|error_exit
label|:
empty_stmt|;
block|}
end_function

begin_comment
comment|/* Fetch all registers, or just one, from the child process.  */
end_comment

begin_function
specifier|static
name|void
name|usr_fetch_inferior_registers
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
if|if
condition|(
name|regno
operator|==
operator|-
literal|1
operator|||
name|regno
operator|==
literal|0
condition|)
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|the_low_target
operator|.
name|num_regs
condition|;
name|regno
operator|++
control|)
name|fetch_register
argument_list|(
name|regno
argument_list|)
expr_stmt|;
else|else
name|fetch_register
argument_list|(
name|regno
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Store our register values back into the inferior.    If REGNO is -1, do this for all registers.    Otherwise, REGNO specifies which register (so we can save time).  */
end_comment

begin_function
specifier|static
name|void
name|usr_store_inferior_registers
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
name|CORE_ADDR
name|regaddr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
if|if
condition|(
name|regno
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|regno
operator|>=
name|the_low_target
operator|.
name|num_regs
condition|)
return|return;
if|if
condition|(
call|(
modifier|*
name|the_low_target
operator|.
name|cannot_store_register
call|)
argument_list|(
name|regno
argument_list|)
operator|==
literal|1
condition|)
return|return;
name|regaddr
operator|=
name|register_addr
argument_list|(
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|regaddr
operator|==
operator|-
literal|1
condition|)
return|return;
name|errno
operator|=
literal|0
expr_stmt|;
name|buf
operator|=
name|alloca
argument_list|(
name|register_size
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
name|collect_register
argument_list|(
name|regno
argument_list|,
name|buf
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|register_size
argument_list|(
name|regno
argument_list|)
condition|;
name|i
operator|+=
sizeof|sizeof
argument_list|(
name|PTRACE_XFER_TYPE
argument_list|)
control|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|ptrace
argument_list|(
name|PTRACE_POKEUSER
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|regaddr
argument_list|,
operator|*
operator|(
name|PTRACE_XFER_TYPE
operator|*
operator|)
operator|(
name|buf
operator|+
name|i
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
call|(
modifier|*
name|the_low_target
operator|.
name|cannot_store_register
call|)
argument_list|(
name|regno
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|err
init|=
name|strerror
argument_list|(
name|errno
argument_list|)
decl_stmt|;
name|char
modifier|*
name|msg
init|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|err
argument_list|)
operator|+
literal|128
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"writing register %d: %s"
argument_list|,
name|regno
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|regaddr
operator|+=
sizeof|sizeof
argument_list|(
name|PTRACE_XFER_TYPE
argument_list|)
expr_stmt|;
block|}
block|}
else|else
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|the_low_target
operator|.
name|num_regs
condition|;
name|regno
operator|++
control|)
name|usr_store_inferior_registers
argument_list|(
name|regno
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_LINUX_USRREGS */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LINUX_REGSETS
end_ifdef

begin_function
specifier|static
name|int
name|regsets_fetch_inferior_registers
parameter_list|()
block|{
name|struct
name|regset_info
modifier|*
name|regset
decl_stmt|;
name|regset
operator|=
name|target_regsets
expr_stmt|;
while|while
condition|(
name|regset
operator|->
name|size
operator|>=
literal|0
condition|)
block|{
name|void
modifier|*
name|buf
decl_stmt|;
name|int
name|res
decl_stmt|;
if|if
condition|(
name|regset
operator|->
name|size
operator|==
literal|0
condition|)
block|{
name|regset
operator|++
expr_stmt|;
continue|continue;
block|}
name|buf
operator|=
name|malloc
argument_list|(
name|regset
operator|->
name|size
argument_list|)
expr_stmt|;
name|res
operator|=
name|ptrace
argument_list|(
name|regset
operator|->
name|get_request
argument_list|,
name|inferior_pid
argument_list|,
literal|0
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EIO
condition|)
block|{
comment|/* If we get EIO on the first regset, do not try regsets again. 		 If we get EIO on a later regset, disable that regset.  */
if|if
condition|(
name|regset
operator|==
name|target_regsets
condition|)
block|{
name|use_regsets_p
operator|=
literal|0
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
name|regset
operator|->
name|size
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
block|}
else|else
block|{
name|char
name|s
index|[
literal|256
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"ptrace(regsets_fetch_inferior_registers) PID=%d"
argument_list|,
name|inferior_pid
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
name|regset
operator|->
name|store_function
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|regset
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|regsets_store_inferior_registers
parameter_list|()
block|{
name|struct
name|regset_info
modifier|*
name|regset
decl_stmt|;
name|regset
operator|=
name|target_regsets
expr_stmt|;
while|while
condition|(
name|regset
operator|->
name|size
operator|>=
literal|0
condition|)
block|{
name|void
modifier|*
name|buf
decl_stmt|;
name|int
name|res
decl_stmt|;
if|if
condition|(
name|regset
operator|->
name|size
operator|==
literal|0
condition|)
block|{
name|regset
operator|++
expr_stmt|;
continue|continue;
block|}
name|buf
operator|=
name|malloc
argument_list|(
name|regset
operator|->
name|size
argument_list|)
expr_stmt|;
name|regset
operator|->
name|fill_function
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|res
operator|=
name|ptrace
argument_list|(
name|regset
operator|->
name|set_request
argument_list|,
name|inferior_pid
argument_list|,
literal|0
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EIO
condition|)
block|{
comment|/* If we get EIO on the first regset, do not try regsets again. 		 If we get EIO on a later regset, disable that regset.  */
if|if
condition|(
name|regset
operator|==
name|target_regsets
condition|)
block|{
name|use_regsets_p
operator|=
literal|0
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
name|regset
operator|->
name|size
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
block|}
else|else
block|{
name|perror
argument_list|(
literal|"Warning: ptrace(regsets_store_inferior_registers)"
argument_list|)
expr_stmt|;
block|}
block|}
name|regset
operator|++
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_LINUX_REGSETS */
end_comment

begin_function
name|void
name|linux_fetch_registers
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_LINUX_REGSETS
if|if
condition|(
name|use_regsets_p
condition|)
block|{
if|if
condition|(
name|regsets_fetch_inferior_registers
argument_list|()
operator|==
literal|0
condition|)
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_LINUX_USRREGS
name|usr_fetch_inferior_registers
argument_list|(
name|regno
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|linux_store_registers
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_LINUX_REGSETS
if|if
condition|(
name|use_regsets_p
condition|)
block|{
if|if
condition|(
name|regsets_store_inferior_registers
argument_list|()
operator|==
literal|0
condition|)
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_LINUX_USRREGS
name|usr_store_inferior_registers
argument_list|(
name|regno
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Copy LEN bytes from inferior's memory starting at MEMADDR    to debugger memory starting at MYADDR.  */
end_comment

begin_function
specifier|static
name|int
name|linux_read_memory
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Round starting address down to longword boundary.  */
specifier|register
name|CORE_ADDR
name|addr
init|=
name|memaddr
operator|&
operator|-
operator|(
name|CORE_ADDR
operator|)
sizeof|sizeof
argument_list|(
name|PTRACE_XFER_TYPE
argument_list|)
decl_stmt|;
comment|/* Round ending address up; get number of longwords that makes.  */
specifier|register
name|int
name|count
init|=
operator|(
operator|(
operator|(
name|memaddr
operator|+
name|len
operator|)
operator|-
name|addr
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|PTRACE_XFER_TYPE
argument_list|)
operator|-
literal|1
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|PTRACE_XFER_TYPE
argument_list|)
decl_stmt|;
comment|/* Allocate buffer of that many longwords.  */
specifier|register
name|PTRACE_XFER_TYPE
modifier|*
name|buffer
init|=
operator|(
name|PTRACE_XFER_TYPE
operator|*
operator|)
name|alloca
argument_list|(
name|count
operator|*
sizeof|sizeof
argument_list|(
name|PTRACE_XFER_TYPE
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Read all the longwords */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|addr
operator|+=
sizeof|sizeof
argument_list|(
name|PTRACE_XFER_TYPE
argument_list|)
control|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|buffer
index|[
name|i
index|]
operator|=
name|ptrace
argument_list|(
name|PTRACE_PEEKTEXT
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
return|return
name|errno
return|;
block|}
comment|/* Copy appropriate bytes out of the buffer.  */
name|memcpy
argument_list|(
name|myaddr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buffer
operator|+
operator|(
name|memaddr
operator|&
operator|(
sizeof|sizeof
argument_list|(
name|PTRACE_XFER_TYPE
argument_list|)
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Copy LEN bytes of data from debugger memory at MYADDR    to inferior's memory at MEMADDR.    On failure (cannot write the inferior)    returns the value of errno.  */
end_comment

begin_function
specifier|static
name|int
name|linux_write_memory
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
specifier|const
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Round starting address down to longword boundary.  */
specifier|register
name|CORE_ADDR
name|addr
init|=
name|memaddr
operator|&
operator|-
operator|(
name|CORE_ADDR
operator|)
sizeof|sizeof
argument_list|(
name|PTRACE_XFER_TYPE
argument_list|)
decl_stmt|;
comment|/* Round ending address up; get number of longwords that makes.  */
specifier|register
name|int
name|count
init|=
operator|(
operator|(
operator|(
name|memaddr
operator|+
name|len
operator|)
operator|-
name|addr
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|PTRACE_XFER_TYPE
argument_list|)
operator|-
literal|1
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|PTRACE_XFER_TYPE
argument_list|)
decl_stmt|;
comment|/* Allocate buffer of that many longwords.  */
specifier|register
name|PTRACE_XFER_TYPE
modifier|*
name|buffer
init|=
operator|(
name|PTRACE_XFER_TYPE
operator|*
operator|)
name|alloca
argument_list|(
name|count
operator|*
sizeof|sizeof
argument_list|(
name|PTRACE_XFER_TYPE
argument_list|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|errno
decl_stmt|;
if|if
condition|(
name|debug_threads
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Writing %02x to %08lx\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|myaddr
index|[
literal|0
index|]
argument_list|,
operator|(
name|long
operator|)
name|memaddr
argument_list|)
expr_stmt|;
block|}
comment|/* Fill start and end extra bytes of buffer with existing memory data.  */
name|buffer
index|[
literal|0
index|]
operator|=
name|ptrace
argument_list|(
name|PTRACE_PEEKTEXT
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|1
condition|)
block|{
name|buffer
index|[
name|count
operator|-
literal|1
index|]
operator|=
name|ptrace
argument_list|(
name|PTRACE_PEEKTEXT
argument_list|,
name|inferior_pid
argument_list|,
call|(
name|PTRACE_ARG3_TYPE
call|)
argument_list|(
name|addr
operator|+
operator|(
name|count
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|PTRACE_XFER_TYPE
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Copy data to be written over corresponding part of buffer */
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buffer
operator|+
operator|(
name|memaddr
operator|&
operator|(
sizeof|sizeof
argument_list|(
name|PTRACE_XFER_TYPE
argument_list|)
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Write the entire buffer.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|addr
operator|+=
sizeof|sizeof
argument_list|(
name|PTRACE_XFER_TYPE
argument_list|)
control|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|ptrace
argument_list|(
name|PTRACE_POKETEXT
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|addr
argument_list|,
name|buffer
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
return|return
name|errno
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|linux_look_up_symbols
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USE_THREAD_DB
if|if
condition|(
name|using_threads
condition|)
return|return;
name|using_threads
operator|=
name|thread_db_init
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|linux_send_signal
parameter_list|(
name|int
name|signum
parameter_list|)
block|{
specifier|extern
name|int
name|signal_pid
decl_stmt|;
if|if
condition|(
name|cont_thread
operator|>
literal|0
condition|)
block|{
name|struct
name|process_info
modifier|*
name|process
decl_stmt|;
name|process
operator|=
name|get_thread_process
argument_list|(
name|current_inferior
argument_list|)
expr_stmt|;
name|kill
argument_list|(
name|process
operator|->
name|lwpid
argument_list|,
name|signum
argument_list|)
expr_stmt|;
block|}
else|else
name|kill
argument_list|(
name|signal_pid
argument_list|,
name|signum
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy LEN bytes from inferior's auxiliary vector starting at OFFSET    to debugger memory starting at MYADDR.  */
end_comment

begin_function
specifier|static
name|int
name|linux_read_auxv
parameter_list|(
name|CORE_ADDR
name|offset
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|,
name|unsigned
name|int
name|len
parameter_list|)
block|{
name|char
name|filename
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|n
decl_stmt|;
name|snprintf
argument_list|(
name|filename
argument_list|,
sizeof|sizeof
name|filename
argument_list|,
literal|"/proc/%d/auxv"
argument_list|,
name|inferior_pid
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|offset
operator|!=
operator|(
name|CORE_ADDR
operator|)
literal|0
operator|&&
name|lseek
argument_list|(
name|fd
argument_list|,
operator|(
name|off_t
operator|)
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
operator|(
name|off_t
operator|)
name|offset
condition|)
name|n
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|n
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|struct
name|target_ops
name|linux_target_ops
init|=
block|{
name|linux_create_inferior
block|,
name|linux_attach
block|,
name|linux_kill
block|,
name|linux_detach
block|,
name|linux_thread_alive
block|,
name|linux_resume
block|,
name|linux_wait
block|,
name|linux_fetch_registers
block|,
name|linux_store_registers
block|,
name|linux_read_memory
block|,
name|linux_write_memory
block|,
name|linux_look_up_symbols
block|,
name|linux_send_signal
block|,
name|linux_read_auxv
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|linux_init_signals
parameter_list|()
block|{
comment|/* FIXME drow/2002-06-09: As above, we should check with LinuxThreads      to find what the cancel signal actually is.  */
name|signal
argument_list|(
name|__SIGRTMIN
operator|+
literal|1
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|initialize_low
parameter_list|(
name|void
parameter_list|)
block|{
name|using_threads
operator|=
literal|0
expr_stmt|;
name|set_target_ops
argument_list|(
operator|&
name|linux_target_ops
argument_list|)
expr_stmt|;
name|set_breakpoint_data
argument_list|(
name|the_low_target
operator|.
name|breakpoint
argument_list|,
name|the_low_target
operator|.
name|breakpoint_len
argument_list|)
expr_stmt|;
name|init_registers
argument_list|()
expr_stmt|;
name|linux_init_signals
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

