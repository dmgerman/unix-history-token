begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* FreeBSD/ARM specific low level interface, for the remote server for GDB.    Copyright 1995, 1996, 1998, 1999, 2000, 2001, 2002, 2003, 2004    Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"server.h"
end_include

begin_include
include|#
directive|include
file|"fbsd-low.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_REG_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/reg.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/procfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_define
define|#
directive|define
name|arm_num_regs
value|26
end_define

begin_decl_stmt
specifier|static
name|int
name|arm_regmap
index|[]
init|=
block|{
literal|0
block|,
literal|4
block|,
literal|8
block|,
literal|12
block|,
literal|16
block|,
literal|20
block|,
literal|24
block|,
literal|28
block|,
literal|32
block|,
literal|36
block|,
literal|40
block|,
literal|44
block|,
literal|48
block|,
literal|52
block|,
literal|56
block|,
literal|60
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|64
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|arm_cannot_store_register
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
return|return
operator|(
name|regno
operator|>=
name|arm_num_regs
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|arm_cannot_fetch_register
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
return|return
operator|(
name|regno
operator|>=
name|arm_num_regs
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|extern
name|int
name|debug_threads
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|CORE_ADDR
name|arm_get_pc
parameter_list|()
block|{
name|unsigned
name|long
name|pc
decl_stmt|;
name|collect_register_by_name
argument_list|(
literal|"pc"
argument_list|,
operator|&
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_threads
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"stop pc is %08lx\n"
argument_list|,
name|pc
argument_list|)
expr_stmt|;
return|return
name|pc
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|arm_set_pc
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
name|unsigned
name|long
name|newpc
init|=
name|pc
decl_stmt|;
name|supply_register_by_name
argument_list|(
literal|"pc"
argument_list|,
operator|&
name|newpc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Correct in either endianness.  We do not support Thumb yet.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|long
name|arm_breakpoint
init|=
literal|0xef9f0001
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|arm_breakpoint_len
value|4
end_define

begin_function
specifier|static
name|int
name|arm_breakpoint_at
parameter_list|(
name|CORE_ADDR
name|where
parameter_list|)
block|{
name|unsigned
name|long
name|insn
decl_stmt|;
call|(
modifier|*
name|the_target
operator|->
name|read_memory
call|)
argument_list|(
name|where
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|insn
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|arm_breakpoint
condition|)
return|return
literal|1
return|;
comment|/* If necessary, recognize more trap instructions here.  GDB only uses the      one.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* We only place breakpoints in empty marker functions, and thread locking    is outside of the function.  So rather than importing software single-step,    we can just run until exit.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|arm_reinsert_addr
parameter_list|()
block|{
name|unsigned
name|long
name|pc
decl_stmt|;
name|collect_register_by_name
argument_list|(
literal|"lr"
argument_list|,
operator|&
name|pc
argument_list|)
expr_stmt|;
return|return
name|pc
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|arm_fill_gregset
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|arm_num_regs
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|arm_regmap
index|[
name|i
index|]
operator|!=
operator|-
literal|1
condition|)
name|collect_register
argument_list|(
name|i
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
name|buf
operator|)
operator|+
name|arm_regmap
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arm_store_gregset
parameter_list|(
specifier|const
name|void
modifier|*
name|buf
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|arm_num_regs
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|arm_regmap
index|[
name|i
index|]
operator|!=
operator|-
literal|1
condition|)
name|supply_register
argument_list|(
name|i
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
name|buf
operator|)
operator|+
name|arm_regmap
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|struct
name|regset_info
name|target_regsets
index|[]
init|=
block|{
block|{
name|PT_GETREGS
block|,
name|PT_SETREGS
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|reg
argument_list|)
block|,
name|GENERAL_REGS
block|,
name|arm_fill_gregset
block|,
name|arm_store_gregset
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|fbsd_target_ops
name|the_low_target
init|=
block|{
name|arm_num_regs
block|,
name|arm_regmap
block|,
name|arm_cannot_fetch_register
block|,
name|arm_cannot_store_register
block|,
name|arm_get_pc
block|,
name|arm_set_pc
block|,
operator|(
specifier|const
name|char
operator|*
operator|)
operator|&
name|arm_breakpoint
block|,
name|arm_breakpoint_len
block|,
name|arm_reinsert_addr
block|,
literal|0
block|,
name|arm_breakpoint_at
block|, }
decl_stmt|;
end_decl_stmt

end_unit

