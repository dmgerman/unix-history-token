begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Object file "section" support for the BFD library.    Copyright (C) 1990, 1991, 1992, 1993 Free Software Foundation, Inc.    Written by Cygnus Support.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* SECTION 	Sections  	Sections are supported in BFD in<<section.c>>.  	The raw data contained within a BFD is maintained through the 	section abstraction.  A single BFD may have any number of 	sections, and keeps hold of them by pointing to the first, 	each one points to the next in the list.  @menu @* Section Input:: @* Section Output:: @* typedef asection:: @* section prototypes:: @end menu  INODE Section Input, Section Output, Sections, Sections SUBSECTION 	Section Input  	When a BFD is opened for reading, the section structures are 	created and attached to the BFD.  	Each section has a name which describes the section in the 	outside world - for example,<<a.out>> would contain at least 	three sections, called<<.text>>,<<.data>> and<<.bss>>.   	Names need not be unique; for example a COFF file may have several 	sections named .data.  	Sometimes a BFD will contain more than the 'natural' number of 	sections. A back end may attach other sections containing 	constructor data, or an application may add a section (using 	bfd_make_section) to the sections attached to an already open 	BFD. For example, the linker creates a supernumary section<<COMMON>> for each input file's BFD to hold information about 	common storage.  	The raw data is not necessarily read in at the same time as 	the section descriptor is created. Some targets may leave the 	data in place until a<<bfd_get_section_contents>> call is 	made. Other back ends may read in all the data at once - For 	example; an S-record file has to be read once to determine the 	size of the data. An IEEE-695 file doesn't contain raw data in 	sections, but data and relocation expressions intermixed, so 	the data area has to be parsed to get out the data and 	relocations.  INODE Section Output, typedef asection, Section Input, Sections  SUBSECTION 	Section Output  	To write a new object style BFD, the various sections to be 	written have to be created. They are attached to the BFD in 	the same way as input sections, data is written to the 	sections using<<bfd_set_section_contents>>.    	Any program that creates or combines sections (e.g., the assembler 	and linker) must use the fields<<output_section>> and<<output_offset>> to indicate the file sections to which each 	section must be written.  (If the section is being created from 	scratch,<<output_section>> should probably point to the section 	itself, and<<output_offset>> should probably be zero.)  	The data to be written comes from input sections attached to 	the output sections.  The output section structure can be 	considered a filter for the input section, the output section 	determines the vma of the output data and the name, but the 	input section determines the offset into the output section of 	the data to be written.  	E.g., to create a section "O", starting at 0x100, 0x123 long, 	containing two subsections, "A" at offset 0x0 (ie at vma 	0x100) and "B" at offset 0x20 (ie at vma 0x120) the structures 	would look like:  |   section name          "A" |     output_offset   0x00 |     size            0x20 |     output_section ----------->  section name    "O" |                             |    vma             0x100 |   section name          "B" |    size            0x123 |     output_offset   0x20    | |     size            0x103   | |     output_section  --------|   SUBSECTION 	Seglets  	The data within a section is stored in a<<seglet>>.  These 	are much like the fixups in<<gas>>.  The seglet abstraction 	allows the a section to grow and shrink within itself.  	A seglet knows how big it is, and which is the next seglet and 	where the raw data for it is, and also points to a list of 	relocations which apply to it.  	The seglet is used by the linker to perform relaxing on final 	code.  The application creates code which is as big as 	necessary to make it work without relaxing, and the user can 	select whether to relax.  Sometimes relaxing takes a lot of 	time.  The linker runs around the relocations to see if any 	are attached to data which can be shrunk, if so it does it on 	a seglet by seglet basis.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_comment
comment|/* DOCDD INODE typedef asection, section prototypes, Section Output, Sections SUBSECTION 	typedef asection  	The shape of a section struct:  CODE_FRAGMENT . .typedef struct sec  .{ .        {* The name of the section, the name isn't a copy, the pointer is .        the same as that passed to bfd_make_section. *} . .    CONST char *name; . .        {* Which section is it 0.nth      *} . .   int index;                       . .        {* The next section in the list belonging to the BFD, or NULL. *} . .    struct sec *next; . .        {* The field flags contains attributes of the section. Some of .           flags are read in from the object file, and some are .           synthesized from other information.  *}          . .    flagword flags; . .#define SEC_NO_FLAGS   0x000 . .        {* Tells the OS to allocate space for this section when loaded. .           This would clear for a section containing debug information .           only. *} .#define SEC_ALLOC      0x001 .           .        {* Tells the OS to load the section from the file when loading. .           This would be clear for a .bss section *} .#define SEC_LOAD       0x002 . .        {* The section contains data still to be relocated, so there will .           be some relocation information too. *} .#define SEC_RELOC      0x004 . .#if 0   {* Obsolete ? *} .#define SEC_BALIGN     0x008 .#endif . .        {* A signal to the OS that the section contains read only .          data. *} .#define SEC_READONLY   0x010 . .        {* The section contains code only. *} .#define SEC_CODE       0x020 . .        {* The section contains data only. *} .#define SEC_DATA       0x040 . .        {* The section will reside in ROM. *} .#define SEC_ROM        0x080 . .        {* The section contains constructor information. This section .           type is used by the linker to create lists of constructors and .           destructors used by<<g++>>. When a back end sees a symbol .           which should be used in a constructor list, it creates a new .           section for the type of name (eg<<__CTOR_LIST__>>), attaches .           the symbol to it and builds a relocation. To build the lists .           of constructors, all the linker has to do is catenate all the .           sections called<<__CTOR_LIST__>> and relocte the data .           contained within - exactly the operations it would peform on .           standard data. *} .#define SEC_CONSTRUCTOR 0x100 . .        {* The section is a constuctor, and should be placed at the .          end of the text, data, or bss section(?). *} .#define SEC_CONSTRUCTOR_TEXT 0x1100 .#define SEC_CONSTRUCTOR_DATA 0x2100 .#define SEC_CONSTRUCTOR_BSS  0x3100 . .        {* The section has contents - a data section could be .<<SEC_ALLOC>> |<<SEC_HAS_CONTENTS>>, a debug section could be .<<SEC_HAS_CONTENTS>> *} .#define SEC_HAS_CONTENTS 0x200 . .        {* An instruction to the linker not to output sections .          containing this flag even if they have information which .          would normally be written. *} .#define SEC_NEVER_LOAD 0x400 . .        {* The section is a shared library section.  The linker must leave .           these completely alone, as the vma and size are used when .           the executable is loaded. *} .#define SEC_SHARED_LIBRARY 0x800 . .        {* The section is a common section (symbols may be defined .           multiple times, the value of a symbol is the amount of .           space it requires, and the largest symbol value is the one .           used).  Most targets have exactly one of these (which we .	    translate to bfd_com_section), but ECOFF has two. *} .#define SEC_IS_COMMON 0x8000 . .        {* The section contains only debugging information.  For .           example, this is set for ELF .debug and .stab sections. .           strip tests this flag to see if a section can be .           discarded. *} .#define SEC_DEBUGGING 0x10000 . .	{*  End of section flags.  *} . .       {*  The virtual memory address of the section - where it will be .           at run time.  The symbols are relocated against this.  The .	    user_set_vma flag is maintained by bfd; if it's not set, the .	    backend can assign addresses (for example, in<<a.out>>, where .	    the default address for<<.data>> is dependent on the specific .	    target and various flags).  *} . .   bfd_vma vma; .   boolean user_set_vma; . .       {*  The load address of the section - where it would be in a .           rom image, really only used for writing section header .	    information. *} . .   bfd_vma lma; . .        {* The size of the section in bytes, as it will be output. .           contains a value even if the section has no contents (eg, the .           size of<<.bss>>). This will be filled in after relocation *} . .   bfd_size_type _cooked_size;     . .        {* The size on disk of the section in bytes originally.  Normally this .	    value is the same as the size, but if some relaxing has .	    been done, then this value will be bigger.  *} . .   bfd_size_type _raw_size;     . .        {* If this section is going to be output, then this value is the .           offset into the output section of the first byte in the input .           section. Eg, if this was going to start at the 100th byte in .           the output section, this value would be 100. *} . .   bfd_vma output_offset; . .        {* The output section through which to map on output. *} . .   struct sec *output_section; . .        {* The alignment requirement of the section, as an exponent - eg .           3 aligns to 2^3 (or 8) *} . .   unsigned int alignment_power; . .        {* If an input section, a pointer to a vector of relocation .           records for the data in this section. *} . .   struct reloc_cache_entry *relocation; . .        {* If an output section, a pointer to a vector of pointers to .           relocation records for the data in this section. *} . .   struct reloc_cache_entry **orelocation; . .        {* The number of relocation records in one of the above  *} . .   unsigned reloc_count; . .        {* Information below is back end specific - and not always used .           or updated.  *} . .        {* File position of section data    *} . .   file_ptr filepos;       .         .        {* File position of relocation info *} . .   file_ptr rel_filepos; . .        {* File position of line data       *} . .   file_ptr line_filepos; . .        {* Pointer to data for applications *} . .   PTR userdata; . .   struct lang_output_section *otheruserdata; . .        {* Attached line number information *} . .   alent *lineno; .         .        {* Number of line number records   *} . .   unsigned int lineno_count; . .        {* When a section is being output, this value changes as more .           linenumbers are written out *} . .   file_ptr moving_line_filepos; . .        {* what the section number is in the target world  *} . .   int target_index; . .   PTR used_by_bfd; . .        {* If this is a constructor section then here is a list of the .           relocations created to relocate items within it. *} . .   struct relent_chain *constructor_chain; . .        {* The BFD which owns the section. *} . .   bfd *owner; . .   boolean reloc_done; .	 {* A symbol which points at this section only *} .   struct symbol_cache_entry *symbol;   .   struct symbol_cache_entry **symbol_ptr_ptr; . .   struct bfd_seclet *seclets_head; .   struct bfd_seclet *seclets_tail; .} asection ; . . .    {* These sections are global, and are managed by BFD.  The application .       and target back end are not permitted to change the values in .	these sections.  *} .#define BFD_ABS_SECTION_NAME "*ABS*" .#define BFD_UND_SECTION_NAME "*UND*" .#define BFD_COM_SECTION_NAME "*COM*" .#define BFD_IND_SECTION_NAME "*IND*" . .    {* the absolute section *} .extern asection bfd_abs_section; .    {* Pointer to the undefined section *} .extern asection bfd_und_section; .    {* Pointer to the common section *} .extern asection bfd_com_section; .    {* Pointer to the indirect section *} .extern asection bfd_ind_section; . .extern struct symbol_cache_entry *bfd_abs_symbol; .extern struct symbol_cache_entry *bfd_com_symbol; .extern struct symbol_cache_entry *bfd_und_symbol; .extern struct symbol_cache_entry *bfd_ind_symbol; .#define bfd_get_section_size_before_reloc(section) \ .     (section->reloc_done ? (abort(),1): (section)->_raw_size) .#define bfd_get_section_size_after_reloc(section) \ .     ((section->reloc_done) ? (section)->_cooked_size: (abort(),1)) */
end_comment

begin_comment
comment|/* These symbols are global, not specific to any BFD.  Therefore, anything    that tries to change them is broken, and should be repaired.  */
end_comment

begin_decl_stmt
specifier|static
name|CONST
name|asymbol
name|global_syms
index|[]
init|=
block|{
comment|/* the_bfd, name, value, attr, section [, udata] */
block|{
literal|0
block|,
name|BFD_COM_SECTION_NAME
block|,
literal|0
block|,
name|BSF_SECTION_SYM
block|,
operator|&
name|bfd_com_section
block|}
block|,
block|{
literal|0
block|,
name|BFD_UND_SECTION_NAME
block|,
literal|0
block|,
name|BSF_SECTION_SYM
block|,
operator|&
name|bfd_und_section
block|}
block|,
block|{
literal|0
block|,
name|BFD_ABS_SECTION_NAME
block|,
literal|0
block|,
name|BSF_SECTION_SYM
block|,
operator|&
name|bfd_abs_section
block|}
block|,
block|{
literal|0
block|,
name|BFD_IND_SECTION_NAME
block|,
literal|0
block|,
name|BSF_SECTION_SYM
block|,
operator|&
name|bfd_ind_section
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|STD_SECTION
parameter_list|(
name|SEC
parameter_list|,
name|FLAGS
parameter_list|,
name|SYM
parameter_list|,
name|NAME
parameter_list|,
name|IDX
parameter_list|)
define|\
value|asymbol *SYM = (asymbol *)&global_syms[IDX]; \   asection SEC = { NAME, 0, 0, FLAGS, 0, 0, (boolean) 0, 0, 0, 0,&SEC,\ 		    0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, (boolean) 0, \ 		     (asymbol *)&global_syms[IDX],&SYM, }
end_define

begin_expr_stmt
name|STD_SECTION
argument_list|(
name|bfd_com_section
argument_list|,
name|SEC_IS_COMMON
argument_list|,
name|bfd_com_symbol
argument_list|,
name|BFD_COM_SECTION_NAME
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|STD_SECTION
argument_list|(
name|bfd_und_section
argument_list|,
literal|0
argument_list|,
name|bfd_und_symbol
argument_list|,
name|BFD_UND_SECTION_NAME
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|STD_SECTION
argument_list|(
name|bfd_abs_section
argument_list|,
literal|0
argument_list|,
name|bfd_abs_symbol
argument_list|,
name|BFD_ABS_SECTION_NAME
argument_list|,
literal|2
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|STD_SECTION
argument_list|(
name|bfd_ind_section
argument_list|,
literal|0
argument_list|,
name|bfd_ind_symbol
argument_list|,
name|BFD_IND_SECTION_NAME
argument_list|,
literal|3
argument_list|)
expr_stmt|;
end_expr_stmt

begin_undef
undef|#
directive|undef
name|STD_SECTION
end_undef

begin_comment
comment|/* DOCDD INODE section prototypes,  , typedef asection, Sections SUBSECTION 	section prototypes  These are the functions exported by the section handling part of<<libbfd>. */
end_comment

begin_comment
comment|/* FUNCTION  	bfd_get_section_by_name  SYNOPSIS 	asection *bfd_get_section_by_name(bfd *abfd, CONST char *name);  DESCRIPTION 	Runs through the provided @var{abfd} and returns the one of the<<asection>>s who's name matches that provided, otherwise NULL. 	@xref{Sections}, for more information.  	This should only be used in special cases; the normal way to process 	all sections of a given name is to use bfd_map_over_sections and 	strcmp on the name (or better yet, base it on the section flags 	or something else) for each section. */
end_comment

begin_decl_stmt
name|asection
modifier|*
name|DEFUN
argument_list|(
name|bfd_get_section_by_name
argument_list|,
operator|(
name|abfd
operator|,
name|name
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|CONST
name|char
operator|*
name|name
argument_list|)
block|{
name|asection
modifier|*
name|sect
decl_stmt|;
for|for
control|(
name|sect
operator|=
name|abfd
operator|->
name|sections
init|;
name|sect
operator|!=
name|NULL
condition|;
name|sect
operator|=
name|sect
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|sect
operator|->
name|name
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|sect
return|;
return|return
name|NULL
return|;
block|}
end_decl_stmt

begin_comment
comment|/* FUNCTION 	bfd_make_section_old_way  SYNOPSIS 	asection *bfd_make_section_old_way(bfd *, CONST char *name);  DESCRIPTION 	This function creates a new empty section called @var{name} 	and attaches it to the end of the chain of sections for the 	BFD supplied. An attempt to create a section with a name which 	is already in use, returns its pointer without changing the 	section chain.  	It has the funny name since this is the way it used to be 	before is was rewritten...  	Possible errors are: 	o invalid_operation - 	If output has already started for this BFD. 	o no_memory - 	If obstack alloc fails.  */
end_comment

begin_decl_stmt
name|asection
modifier|*
name|DEFUN
argument_list|(
name|bfd_make_section_old_way
argument_list|,
operator|(
name|abfd
operator|,
name|name
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|CONST
name|char
operator|*
name|name
argument_list|)
block|{
name|asection
modifier|*
name|sec
init|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|sec
operator|==
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|)
block|{
name|sec
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
return|return
name|sec
return|;
block|}
end_decl_stmt

begin_comment
comment|/* FUNCTION 	bfd_make_section_anyway  SYNOPSIS 	asection *bfd_make_section_anyway(bfd *, CONST char *name);  DESCRIPTION    Create a new empty section called @var{name} and attach it to the end of    the chain of sections for @var{abfd}.  Create a new section even if there    is already a section with that name.       Returns NULL and sets bfd_error on error; possible errors are:    o invalid_operation - If output has already started for @var{abfd}.    o no_memory - If obstack alloc fails. */
end_comment

begin_function
name|sec_ptr
name|bfd_make_section_anyway
parameter_list|(
name|abfd
parameter_list|,
name|name
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|CONST
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|asection
modifier|*
name|newsect
decl_stmt|;
name|asection
modifier|*
modifier|*
name|prev
init|=
operator|&
name|abfd
operator|->
name|sections
decl_stmt|;
name|asection
modifier|*
name|sect
init|=
name|abfd
operator|->
name|sections
decl_stmt|;
if|if
condition|(
name|abfd
operator|->
name|output_has_begun
condition|)
block|{
name|bfd_error
operator|=
name|invalid_operation
expr_stmt|;
return|return
name|NULL
return|;
block|}
while|while
condition|(
name|sect
condition|)
block|{
name|prev
operator|=
operator|&
name|sect
operator|->
name|next
expr_stmt|;
name|sect
operator|=
name|sect
operator|->
name|next
expr_stmt|;
block|}
name|newsect
operator|=
operator|(
name|asection
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|asection
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newsect
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|newsect
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|newsect
operator|->
name|index
operator|=
name|abfd
operator|->
name|section_count
operator|++
expr_stmt|;
name|newsect
operator|->
name|flags
operator|=
name|SEC_NO_FLAGS
expr_stmt|;
name|newsect
operator|->
name|userdata
operator|=
literal|0
expr_stmt|;
name|newsect
operator|->
name|next
operator|=
operator|(
name|asection
operator|*
operator|)
name|NULL
expr_stmt|;
name|newsect
operator|->
name|relocation
operator|=
operator|(
name|arelent
operator|*
operator|)
name|NULL
expr_stmt|;
name|newsect
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
name|newsect
operator|->
name|line_filepos
operator|=
literal|0
expr_stmt|;
name|newsect
operator|->
name|owner
operator|=
name|abfd
expr_stmt|;
comment|/* Create a symbol whos only job is to point to this section. This is      useful for things like relocs which are relative to the base of a      section.  */
name|newsect
operator|->
name|symbol
operator|=
name|bfd_make_empty_symbol
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|newsect
operator|->
name|symbol
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|newsect
operator|->
name|symbol
operator|->
name|value
operator|=
literal|0
expr_stmt|;
name|newsect
operator|->
name|symbol
operator|->
name|section
operator|=
name|newsect
expr_stmt|;
name|newsect
operator|->
name|symbol
operator|->
name|flags
operator|=
name|BSF_SECTION_SYM
expr_stmt|;
name|newsect
operator|->
name|symbol_ptr_ptr
operator|=
operator|&
name|newsect
operator|->
name|symbol
expr_stmt|;
if|if
condition|(
name|BFD_SEND
argument_list|(
name|abfd
argument_list|,
name|_new_section_hook
argument_list|,
operator|(
name|abfd
operator|,
name|newsect
operator|)
argument_list|)
operator|!=
name|true
condition|)
block|{
name|free
argument_list|(
name|newsect
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|*
name|prev
operator|=
name|newsect
expr_stmt|;
return|return
name|newsect
return|;
block|}
end_function

begin_comment
comment|/* FUNCTION 	bfd_make_section  SYNOPSIS 	asection *bfd_make_section(bfd *, CONST char *name);  DESCRIPTION    Like bfd_make_section_anyway, but return NULL (without setting    bfd_error) without changing the section chain if there is already a    section named @var{name}.  If there is an error, return NULL and set    bfd_error. */
end_comment

begin_decl_stmt
name|sec_ptr
name|DEFUN
argument_list|(
name|bfd_make_section
argument_list|,
operator|(
name|abfd
operator|,
name|name
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|CONST
name|char
operator|*
name|name
argument_list|)
block|{
name|asection
modifier|*
name|sect
init|=
name|abfd
operator|->
name|sections
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|BFD_ABS_SECTION_NAME
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
operator|&
name|bfd_abs_section
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|BFD_COM_SECTION_NAME
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
operator|&
name|bfd_com_section
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|BFD_UND_SECTION_NAME
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
operator|&
name|bfd_und_section
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|BFD_IND_SECTION_NAME
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
operator|&
name|bfd_ind_section
return|;
block|}
while|while
condition|(
name|sect
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|sect
operator|->
name|name
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|NULL
return|;
name|sect
operator|=
name|sect
operator|->
name|next
expr_stmt|;
block|}
comment|/* The name is not already used; go ahead and make a new section.  */
return|return
name|bfd_make_section_anyway
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/* FUNCTION 	bfd_set_section_flags  SYNOPSIS 	boolean bfd_set_section_flags(bfd *, asection *, flagword);  DESCRIPTION 	Attempts to set the attributes of the section named in the BFD 	supplied to the value. Returns true on success, false on 	error. Possible error returns are:  	o invalid operation - 	The section cannot have one or more of the attributes 	requested. For example, a .bss section in<<a.out>> may not 	have the<<SEC_HAS_CONTENTS>> field set.  */
end_comment

begin_decl_stmt
name|boolean
name|DEFUN
argument_list|(
name|bfd_set_section_flags
argument_list|,
operator|(
name|abfd
operator|,
name|section
operator|,
name|flags
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|sec_ptr
name|section
name|AND
name|flagword
name|flags
argument_list|)
block|{
if|#
directive|if
literal|0
comment|/* If you try to copy a text section from an input file (where it      has the SEC_CODE flag set) to an output file, this loses big if      the bfd_applicable_section_flags (abfd) doesn't have the SEC_CODE      set - which it doesn't, at least not for a.out.  FIXME */
block|if ((flags& bfd_applicable_section_flags (abfd)) != flags) {     bfd_error = invalid_operation;     return false;   }
endif|#
directive|endif
name|section
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
return|return
name|true
return|;
block|}
end_decl_stmt

begin_comment
comment|/* FUNCTION 	bfd_map_over_sections  SYNOPSIS 	void bfd_map_over_sections(bfd *abfd, 				   void (*func)(bfd *abfd, 						asection *sect, 						PTR obj), 				   PTR obj);  DESCRIPTION 	Calls the provided function @var{func} for each section 	attached to the BFD @var{abfd}, passing @var{obj} as an 	argument. The function will be called as if by   |	func(abfd, the_section, obj);  	This is the prefered method for iterating over sections, an 	alternative would be to use a loop:  |	   section *p; |	   for (p = abfd->sections; p != NULL; p = p->next) |	      func(abfd, p, ...)   */
end_comment

begin_comment
comment|/*VARARGS2*/
end_comment

begin_decl_stmt
name|void
name|DEFUN
argument_list|(
name|bfd_map_over_sections
argument_list|,
operator|(
name|abfd
operator|,
name|operation
operator|,
name|user_storage
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|void
argument_list|(
argument|*operation
argument_list|)
name|PARAMS
argument_list|(
argument|(bfd *abfd, asection *sect, PTR obj)
argument_list|)
name|AND
name|PTR
name|user_storage
argument_list|)
block|{
name|asection
modifier|*
name|sect
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|sect
operator|=
name|abfd
operator|->
name|sections
init|;
name|sect
operator|!=
name|NULL
condition|;
name|i
operator|++
operator|,
name|sect
operator|=
name|sect
operator|->
name|next
control|)
call|(
modifier|*
name|operation
call|)
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|,
name|user_storage
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|abfd
operator|->
name|section_count
condition|)
comment|/* Debugging */
name|abort
argument_list|()
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* FUNCTION 	bfd_set_section_size  SYNOPSIS 	boolean bfd_set_section_size(bfd *, asection *, bfd_size_type val);  DESCRIPTION 	Sets @var{section} to the size @var{val}. If the operation is 	ok, then<<true>> is returned, else<<false>>.   	Possible error returns: 	o invalid_operation - 	Writing has started to the BFD, so setting the size is invalid  */
end_comment

begin_decl_stmt
name|boolean
name|DEFUN
argument_list|(
name|bfd_set_section_size
argument_list|,
operator|(
name|abfd
operator|,
name|ptr
operator|,
name|val
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|sec_ptr
name|ptr
name|AND
name|bfd_size_type
name|val
argument_list|)
block|{
comment|/* Once you've started writing to any section you cannot create or change      the size of any others. */
if|if
condition|(
name|abfd
operator|->
name|output_has_begun
condition|)
block|{
name|bfd_error
operator|=
name|invalid_operation
expr_stmt|;
return|return
name|false
return|;
block|}
name|ptr
operator|->
name|_cooked_size
operator|=
name|val
expr_stmt|;
name|ptr
operator|->
name|_raw_size
operator|=
name|val
expr_stmt|;
return|return
name|true
return|;
block|}
end_decl_stmt

begin_comment
comment|/* FUNCTION 	bfd_set_section_contents  SYNOPSIS 	boolean bfd_set_section_contents          (bfd *abfd,                  asection *section,          PTR data,          file_ptr offset,          bfd_size_type count);   DESCRIPTION 	Sets the contents of the section @var{section} in BFD 	@var{abfd} to the data starting in memory at @var{data}. The 	data is written to the output section starting at offset 	@var{offset} for @var{count} bytes.     	Normally<<true>> is returned, else<<false>>. Possible error 	returns are: 	o no_contents - 	The output section does not have the<<SEC_HAS_CONTENTS>> 	attribute, so nothing can be written to it. 	o and some more too  	This routine is front end to the back end function<<_bfd_set_section_contents>>.   */
end_comment

begin_define
define|#
directive|define
name|bfd_get_section_size_now
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|)
define|\
value|(sec->reloc_done \  ? bfd_get_section_size_after_reloc (sec) \  : bfd_get_section_size_before_reloc (sec))
end_define

begin_decl_stmt
name|boolean
name|DEFUN
argument_list|(
name|bfd_set_section_contents
argument_list|,
operator|(
name|abfd
operator|,
name|section
operator|,
name|location
operator|,
name|offset
operator|,
name|count
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|sec_ptr
name|section
name|AND
name|PTR
name|location
name|AND
name|file_ptr
name|offset
name|AND
name|bfd_size_type
name|count
argument_list|)
block|{
name|bfd_size_type
name|sz
decl_stmt|;
if|if
condition|(
operator|!
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
operator|&
name|SEC_HAS_CONTENTS
condition|)
block|{
name|bfd_error
operator|=
name|no_contents
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
block|{
name|bad_val
label|:
name|bfd_error
operator|=
name|bad_value
expr_stmt|;
return|return
name|false
return|;
block|}
name|sz
operator|=
name|bfd_get_section_size_now
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|>
name|sz
operator|||
name|count
operator|>
name|sz
operator|||
name|offset
operator|+
name|count
operator|>
name|sz
condition|)
goto|goto
name|bad_val
goto|;
switch|switch
condition|(
name|abfd
operator|->
name|direction
condition|)
block|{
case|case
name|read_direction
case|:
case|case
name|no_direction
case|:
name|bfd_error
operator|=
name|invalid_operation
expr_stmt|;
return|return
name|false
return|;
case|case
name|write_direction
case|:
break|break;
case|case
name|both_direction
case|:
comment|/* File is opened for update. `output_has_begun' some time ago when 	   the file was created.  Do not recompute sections sizes or alignments 	   in _bfd_set_section_content.  */
name|abfd
operator|->
name|output_has_begun
operator|=
name|true
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|BFD_SEND
argument_list|(
name|abfd
argument_list|,
name|_bfd_set_section_contents
argument_list|,
operator|(
name|abfd
operator|,
name|section
operator|,
name|location
operator|,
name|offset
operator|,
name|count
operator|)
argument_list|)
condition|)
block|{
name|abfd
operator|->
name|output_has_begun
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_decl_stmt

begin_comment
comment|/* FUNCTION 	bfd_get_section_contents  SYNOPSIS 	boolean bfd_get_section_contents          (bfd *abfd, asection *section, PTR location,          file_ptr offset, bfd_size_type count);  DESCRIPTION 	This function reads data from @var{section} in BFD @var{abfd} 	into memory starting at @var{location}. The data is read at an 	offset of @var{offset} from the start of the input section, 	and is read for @var{count} bytes.  	If the contents of a constuctor with the<<SEC_CONSTUCTOR>> 	flag set are requested, then the @var{location} is filled with 	zeroes. If no errors occur,<<true>> is returned, else<<false>>.    */
end_comment

begin_decl_stmt
name|boolean
name|DEFUN
argument_list|(
name|bfd_get_section_contents
argument_list|,
operator|(
name|abfd
operator|,
name|section
operator|,
name|location
operator|,
name|offset
operator|,
name|count
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|sec_ptr
name|section
name|AND
name|PTR
name|location
name|AND
name|file_ptr
name|offset
name|AND
name|bfd_size_type
name|count
argument_list|)
block|{
name|bfd_size_type
name|sz
decl_stmt|;
if|if
condition|(
name|section
operator|->
name|flags
operator|&
name|SEC_CONSTRUCTOR
condition|)
block|{
name|memset
argument_list|(
name|location
argument_list|,
literal|0
argument_list|,
operator|(
name|unsigned
operator|)
name|count
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
block|{
name|bad_val
label|:
name|bfd_error
operator|=
name|bad_value
expr_stmt|;
return|return
name|false
return|;
block|}
name|sz
operator|=
name|bfd_get_section_size_now
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|>
name|sz
operator|||
name|count
operator|>
name|sz
operator|||
name|offset
operator|+
name|count
operator|>
name|sz
condition|)
goto|goto
name|bad_val
goto|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
comment|/* Don't bother.  */
return|return
name|true
return|;
return|return
name|BFD_SEND
argument_list|(
name|abfd
argument_list|,
name|_bfd_get_section_contents
argument_list|,
operator|(
name|abfd
operator|,
name|section
operator|,
name|location
operator|,
name|offset
operator|,
name|count
operator|)
argument_list|)
return|;
block|}
end_decl_stmt

end_unit

