begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BFD library support routines for constructors    Copyright (C) 1990, 91, 92, 93, 94 Free Software Foundation, Inc.     Hacked by Steve Chamberlain of Cygnus Support. With some help from    Judy Chamberlain too.   This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* SECTION 	Constructors  	Classes in C++ have @dfn{constructors} and @dfn{destructors}.  These 	are functions which are called automatically by the language 	whenever data of a class is created or destroyed.  Class data 	which is static may also be have a type which requires 	`construction'; the contructor must be called before the data 	can be referenced, so the contructor must be called before the 	program begins.  	The common solution to this problem is for the compiler to 	call a magic function as the first statement before<<main>>. 	This magic function (often called<<__main>>) runs around 	calling the constructors for all the things needing it.  	With COFF, the compiler has a bargain with the linker et al. 	All constructors are given strange names; for example,<<__GLOBAL__$I$foo>> might be the label of a contructor for 	the class @var{foo}.  The solution on unfortunate systems 	(most System V machines) is to perform a partial link on all 	the<<.o>> files, do an<<nm>> on the result, run<<awk>> or some 	such over the result looking for strange<<__GLOBAL__$>> 	symbols, generate a C program from this, compile it, and link 	with the partially linked input. This process is usually 	called<<collect>>.  	Some versions of<<a.out>> use something called the<<set_vector>> mechanism.  The constructor symbols are output 	from the compiler with a special stab code saying that they 	are constructors, and the linker can deal with them directly.  	BFD allows applications (i.e., the linker) to deal with 	constructor information independently of their external 	implementation by providing a set of entry points for the 	indiviual object back ends to call to maintain a database 	of the contructor information.  The application can 	interrogate the database to find out what it wants.  The 	construction data essential for the linker to be able to 	perform its job are:  	o asymbol - 	The asymbol of the contructor entry point contains all the 	information necessary to call the function.  	o table id - 	The type of symbol, i.e., is it a constructor, a destructor or 	something else someone dreamed up to make our lives difficult.  	The constructor module takes this information and builds extra 	sections attached to the BFDs which own the entry points.  It 	creates these sections as if they were tables of pointers to 	the entry points, and builds relocation entries to go with 	them so that the tables can be relocated along with the data 	they reference.  	These sections are marked with a special bit 	(<<SEC_CONSTRUCTOR>>), which the linker notices and does with 	what it wants.  */
end_comment

begin_include
include|#
directive|include
file|<bfd.h>
end_include

begin_include
include|#
directive|include
file|<sysdep.h>
end_include

begin_include
include|#
directive|include
file|<libbfd.h>
end_include

begin_comment
comment|/* INTERNAL_FUNCTION 	bfd_constructor_entry  SYNOPSIS 	boolean bfd_constructor_entry(bfd *abfd, 		asymbol **symbol_ptr_ptr, 		CONST char*type);   DESCRIPTION 	@var{symbol_ptr_ptr} describes the 	function to be called; @var{type} descibes the xtor type, 	e.g., something like "CTOR" or "DTOR" would be fine.  @var{abfd} 	is the BFD which owns the function.  Create a section 	called "CTOR" or "DTOR" or whatever if the BFD doesn't already 	have one, and grow a relocation table for the entry points as 	they accumulate.  	Return<<true>> if successful,<<false>> if out of memory.  */
end_comment

begin_function
name|boolean
name|bfd_constructor_entry
parameter_list|(
name|abfd
parameter_list|,
name|symbol_ptr_ptr
parameter_list|,
name|type
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbol_ptr_ptr
decl_stmt|;
name|CONST
name|char
modifier|*
name|type
decl_stmt|;
block|{
comment|/* Look up the section we're using to store the table in */
name|asection
modifier|*
name|rel_section
init|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|rel_section
operator|==
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|)
block|{
name|rel_section
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|rel_section
operator|->
name|flags
operator|=
name|SEC_CONSTRUCTOR
expr_stmt|;
name|rel_section
operator|->
name|alignment_power
operator|=
literal|2
expr_stmt|;
block|}
comment|/* Create a relocation into the section which references the entry        point */
block|{
name|arelent_chain
modifier|*
name|reloc
init|=
operator|(
name|arelent_chain
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|arelent_chain
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|reloc
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/*       reloc->relent.section = (asection *)NULL;*/
name|reloc
operator|->
name|relent
operator|.
name|addend
operator|=
literal|0
expr_stmt|;
name|reloc
operator|->
name|relent
operator|.
name|sym_ptr_ptr
operator|=
name|symbol_ptr_ptr
expr_stmt|;
name|reloc
operator|->
name|next
operator|=
name|rel_section
operator|->
name|constructor_chain
expr_stmt|;
name|rel_section
operator|->
name|constructor_chain
operator|=
name|reloc
expr_stmt|;
name|reloc
operator|->
name|relent
operator|.
name|address
operator|=
name|rel_section
operator|->
name|_cooked_size
expr_stmt|;
comment|/* ask the cpu which howto to use */
name|reloc
operator|->
name|relent
operator|.
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|abfd
argument_list|,
name|BFD_RELOC_CTOR
argument_list|)
expr_stmt|;
name|rel_section
operator|->
name|_cooked_size
operator|+=
sizeof|sizeof
argument_list|(
name|int
operator|*
argument_list|)
expr_stmt|;
name|rel_section
operator|->
name|reloc_count
operator|++
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

end_unit

