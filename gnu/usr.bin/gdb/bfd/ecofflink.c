begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Routines to link ECOFF debugging information.    Copyright 1993 Free Software Foundation, Inc.    Written by Ian Lance Taylor, Cygnus Support,<ian@cygnus.com>.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"coff/internal.h"
end_include

begin_include
include|#
directive|include
file|"coff/sym.h"
end_include

begin_include
include|#
directive|include
file|"coff/symconst.h"
end_include

begin_include
include|#
directive|include
file|"coff/ecoff.h"
end_include

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|boolean
name|ecoff_add_bytes
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
name|buf
operator|,
name|char
operator|*
operator|*
name|bufend
operator|,
name|size_t
name|need
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|string_hash_newfunc
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|,
expr|struct
name|bfd_hash_table
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ecoff_align_debug
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
expr|struct
name|ecoff_debug_info
operator|*
name|debug
operator|,
specifier|const
expr|struct
name|ecoff_debug_swap
operator|*
name|swap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ecoff_write_symhdr
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|ecoff_debug_info
operator|*
operator|,
specifier|const
expr|struct
name|ecoff_debug_swap
operator|*
operator|,
name|file_ptr
name|where
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Obstack allocation and deallocation routines.  */
end_comment

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|malloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_escape
end_escape

begin_comment
comment|/* The minimum amount of data to allocate.  */
end_comment

begin_define
define|#
directive|define
name|ALLOC_SIZE
value|(4064)
end_define

begin_comment
comment|/* Add bytes to a buffer.  Return success.  */
end_comment

begin_function
specifier|static
name|boolean
name|ecoff_add_bytes
parameter_list|(
name|buf
parameter_list|,
name|bufend
parameter_list|,
name|need
parameter_list|)
name|char
modifier|*
modifier|*
name|buf
decl_stmt|;
name|char
modifier|*
modifier|*
name|bufend
decl_stmt|;
name|size_t
name|need
decl_stmt|;
block|{
name|size_t
name|have
decl_stmt|;
name|size_t
name|want
decl_stmt|;
name|char
modifier|*
name|newbuf
decl_stmt|;
name|have
operator|=
operator|*
name|bufend
operator|-
operator|*
name|buf
expr_stmt|;
if|if
condition|(
name|have
operator|>
name|need
condition|)
name|want
operator|=
name|ALLOC_SIZE
expr_stmt|;
else|else
block|{
name|want
operator|=
name|need
operator|-
name|have
expr_stmt|;
if|if
condition|(
name|want
operator|<
name|ALLOC_SIZE
condition|)
name|want
operator|=
name|ALLOC_SIZE
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|buf
operator|==
name|NULL
condition|)
name|newbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|have
operator|+
name|want
argument_list|)
expr_stmt|;
else|else
name|newbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
operator|*
name|buf
argument_list|,
name|have
operator|+
name|want
argument_list|)
expr_stmt|;
if|if
condition|(
name|newbuf
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
operator|*
name|buf
operator|=
name|newbuf
expr_stmt|;
operator|*
name|bufend
operator|=
operator|*
name|buf
operator|+
name|have
operator|+
name|want
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* We keep a hash table which maps strings to numbers.  We use it to    map FDR names to indices in the output file, and to map local    strings when combining stabs debugging information.  */
end_comment

begin_struct
struct|struct
name|string_hash_entry
block|{
name|struct
name|bfd_hash_entry
name|root
decl_stmt|;
comment|/* FDR index or string table offset.  */
name|long
name|val
decl_stmt|;
comment|/* Next entry in string table.  */
name|struct
name|string_hash_entry
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|string_hash_table
block|{
name|struct
name|bfd_hash_table
name|table
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Routine to create an entry in a string hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|string_hash_newfunc
parameter_list|(
name|entry
parameter_list|,
name|table
parameter_list|,
name|string
parameter_list|)
name|struct
name|bfd_hash_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|bfd_hash_table
modifier|*
name|table
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|struct
name|string_hash_entry
modifier|*
name|ret
init|=
operator|(
expr|struct
name|string_hash_entry
operator|*
operator|)
name|entry
decl_stmt|;
comment|/* Allocate the structure if it has not already been allocated by a      subclass.  */
if|if
condition|(
name|ret
operator|==
operator|(
expr|struct
name|string_hash_entry
operator|*
operator|)
name|NULL
condition|)
name|ret
operator|=
operator|(
operator|(
expr|struct
name|string_hash_entry
operator|*
operator|)
name|bfd_hash_allocate
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|string_hash_entry
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|(
expr|struct
name|string_hash_entry
operator|*
operator|)
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Call the allocation method of the superclass.  */
name|ret
operator|=
operator|(
operator|(
expr|struct
name|string_hash_entry
operator|*
operator|)
name|bfd_hash_newfunc
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
argument_list|,
name|table
argument_list|,
name|string
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
comment|/* Initialize the local fields.  */
name|ret
operator|->
name|val
operator|=
operator|-
literal|1
expr_stmt|;
name|ret
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Look up an entry in an string hash table.  */
end_comment

begin_define
define|#
directive|define
name|string_hash_lookup
parameter_list|(
name|t
parameter_list|,
name|string
parameter_list|,
name|create
parameter_list|,
name|copy
parameter_list|)
define|\
value|((struct string_hash_entry *) \    bfd_hash_lookup (&(t)->table, (string), (create), (copy)))
end_define

begin_comment
comment|/* We can't afford to read in all the debugging information when we do    a link.  Instead, we build a list of these structures to show how    different parts of the input file map to the output file.  */
end_comment

begin_struct
struct|struct
name|shuffle
block|{
comment|/* The next entry in this linked list.  */
name|struct
name|shuffle
modifier|*
name|next
decl_stmt|;
comment|/* The length of the information.  */
name|unsigned
name|long
name|size
decl_stmt|;
comment|/* Whether this information comes from a file or not.  */
name|boolean
name|filep
decl_stmt|;
union|union
block|{
struct|struct
block|{
comment|/* The BFD the data comes from.  */
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
comment|/* The offset within input_bfd.  */
name|file_ptr
name|offset
decl_stmt|;
block|}
name|file
struct|;
comment|/* The data to be written out.  */
name|PTR
name|memory
decl_stmt|;
block|}
name|u
union|;
block|}
struct|;
end_struct

begin_comment
comment|/* This structure holds information across calls to    bfd_ecoff_debug_accumulate.  */
end_comment

begin_struct
struct|struct
name|accumulate
block|{
comment|/* The FDR hash table.  */
name|struct
name|string_hash_table
name|fdr_hash
decl_stmt|;
comment|/* The strings hash table.  */
name|struct
name|string_hash_table
name|str_hash
decl_stmt|;
comment|/* Linked lists describing how to shuffle the input debug      information into the output file.  We keep a pointer to both the      head and the tail.  */
name|struct
name|shuffle
modifier|*
name|line
decl_stmt|;
name|struct
name|shuffle
modifier|*
name|line_end
decl_stmt|;
name|struct
name|shuffle
modifier|*
name|pdr
decl_stmt|;
name|struct
name|shuffle
modifier|*
name|pdr_end
decl_stmt|;
name|struct
name|shuffle
modifier|*
name|sym
decl_stmt|;
name|struct
name|shuffle
modifier|*
name|sym_end
decl_stmt|;
name|struct
name|shuffle
modifier|*
name|opt
decl_stmt|;
name|struct
name|shuffle
modifier|*
name|opt_end
decl_stmt|;
name|struct
name|shuffle
modifier|*
name|aux
decl_stmt|;
name|struct
name|shuffle
modifier|*
name|aux_end
decl_stmt|;
name|struct
name|shuffle
modifier|*
name|ss
decl_stmt|;
name|struct
name|shuffle
modifier|*
name|ss_end
decl_stmt|;
name|struct
name|string_hash_entry
modifier|*
name|ss_hash
decl_stmt|;
name|struct
name|string_hash_entry
modifier|*
name|ss_hash_end
decl_stmt|;
name|struct
name|shuffle
modifier|*
name|fdr
decl_stmt|;
name|struct
name|shuffle
modifier|*
name|fdr_end
decl_stmt|;
name|struct
name|shuffle
modifier|*
name|rfd
decl_stmt|;
name|struct
name|shuffle
modifier|*
name|rfd_end
decl_stmt|;
comment|/* The size of the largest file shuffle.  */
name|unsigned
name|long
name|largest_file_shuffle
decl_stmt|;
comment|/* An obstack for debugging information.  */
name|struct
name|obstack
name|memory
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Add a file entry to a shuffle list.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|add_file_shuffle
name|PARAMS
argument_list|(
operator|(
expr|struct
name|accumulate
operator|*
operator|,
expr|struct
name|shuffle
operator|*
operator|*
operator|,
expr|struct
name|shuffle
operator|*
operator|*
operator|,
name|bfd
operator|*
operator|,
name|file_ptr
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|boolean
name|add_file_shuffle
parameter_list|(
name|ainfo
parameter_list|,
name|head
parameter_list|,
name|tail
parameter_list|,
name|input_bfd
parameter_list|,
name|offset
parameter_list|,
name|size
parameter_list|)
name|struct
name|accumulate
modifier|*
name|ainfo
decl_stmt|;
name|struct
name|shuffle
modifier|*
modifier|*
name|head
decl_stmt|;
name|struct
name|shuffle
modifier|*
modifier|*
name|tail
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|file_ptr
name|offset
decl_stmt|;
name|unsigned
name|long
name|size
decl_stmt|;
block|{
name|struct
name|shuffle
modifier|*
name|n
decl_stmt|;
if|if
condition|(
operator|*
name|tail
operator|!=
operator|(
expr|struct
name|shuffle
operator|*
operator|)
name|NULL
operator|&&
operator|(
operator|*
name|tail
operator|)
operator|->
name|filep
operator|&&
operator|(
operator|*
name|tail
operator|)
operator|->
name|u
operator|.
name|file
operator|.
name|input_bfd
operator|==
name|input_bfd
operator|&&
operator|(
operator|*
name|tail
operator|)
operator|->
name|u
operator|.
name|file
operator|.
name|offset
operator|+
operator|(
operator|*
name|tail
operator|)
operator|->
name|size
operator|==
name|offset
condition|)
block|{
comment|/* Just merge this entry onto the existing one.  */
operator|(
operator|*
name|tail
operator|)
operator|->
name|size
operator|+=
name|size
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|tail
operator|)
operator|->
name|size
operator|>
name|ainfo
operator|->
name|largest_file_shuffle
condition|)
name|ainfo
operator|->
name|largest_file_shuffle
operator|=
operator|(
operator|*
name|tail
operator|)
operator|->
name|size
expr_stmt|;
return|return
name|true
return|;
block|}
name|n
operator|=
operator|(
expr|struct
name|shuffle
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|ainfo
operator|->
name|memory
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|shuffle
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|n
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|n
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|n
operator|->
name|filep
operator|=
name|true
expr_stmt|;
name|n
operator|->
name|u
operator|.
name|file
operator|.
name|input_bfd
operator|=
name|input_bfd
expr_stmt|;
name|n
operator|->
name|u
operator|.
name|file
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
if|if
condition|(
operator|*
name|head
operator|==
operator|(
expr|struct
name|shuffle
operator|*
operator|)
name|NULL
condition|)
operator|*
name|head
operator|=
name|n
expr_stmt|;
if|if
condition|(
operator|*
name|tail
operator|!=
operator|(
expr|struct
name|shuffle
operator|*
operator|)
name|NULL
condition|)
operator|(
operator|*
name|tail
operator|)
operator|->
name|next
operator|=
name|n
expr_stmt|;
operator|*
name|tail
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|ainfo
operator|->
name|largest_file_shuffle
condition|)
name|ainfo
operator|->
name|largest_file_shuffle
operator|=
name|size
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Add a memory entry to a shuffle list.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|add_memory_shuffle
name|PARAMS
argument_list|(
operator|(
expr|struct
name|accumulate
operator|*
operator|,
expr|struct
name|shuffle
operator|*
operator|*
name|head
operator|,
expr|struct
name|shuffle
operator|*
operator|*
name|tail
operator|,
name|bfd_byte
operator|*
name|data
operator|,
name|unsigned
name|long
name|size
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|boolean
name|add_memory_shuffle
parameter_list|(
name|ainfo
parameter_list|,
name|head
parameter_list|,
name|tail
parameter_list|,
name|data
parameter_list|,
name|size
parameter_list|)
name|struct
name|accumulate
modifier|*
name|ainfo
decl_stmt|;
name|struct
name|shuffle
modifier|*
modifier|*
name|head
decl_stmt|;
name|struct
name|shuffle
modifier|*
modifier|*
name|tail
decl_stmt|;
name|bfd_byte
modifier|*
name|data
decl_stmt|;
name|unsigned
name|long
name|size
decl_stmt|;
block|{
name|struct
name|shuffle
modifier|*
name|n
decl_stmt|;
name|n
operator|=
operator|(
expr|struct
name|shuffle
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|ainfo
operator|->
name|memory
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|shuffle
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|n
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|n
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|n
operator|->
name|filep
operator|=
name|false
expr_stmt|;
name|n
operator|->
name|u
operator|.
name|memory
operator|=
operator|(
name|PTR
operator|)
name|data
expr_stmt|;
if|if
condition|(
operator|*
name|head
operator|==
operator|(
expr|struct
name|shuffle
operator|*
operator|)
name|NULL
condition|)
operator|*
name|head
operator|=
name|n
expr_stmt|;
if|if
condition|(
operator|*
name|tail
operator|!=
operator|(
expr|struct
name|shuffle
operator|*
operator|)
name|NULL
condition|)
operator|(
operator|*
name|tail
operator|)
operator|->
name|next
operator|=
name|n
expr_stmt|;
operator|*
name|tail
operator|=
name|n
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Initialize the FDR hash table.  This returns a handle which is then    passed in to bfd_ecoff_debug_accumulate, et. al.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|PTR
name|bfd_ecoff_debug_init
parameter_list|(
name|output_bfd
parameter_list|,
name|output_debug
parameter_list|,
name|output_swap
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|ecoff_debug_info
modifier|*
name|output_debug
decl_stmt|;
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|output_swap
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|struct
name|accumulate
modifier|*
name|ainfo
decl_stmt|;
name|ainfo
operator|=
operator|(
expr|struct
name|accumulate
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|accumulate
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ainfo
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
name|bfd_hash_table_init_n
argument_list|(
operator|&
name|ainfo
operator|->
name|fdr_hash
operator|.
name|table
argument_list|,
name|string_hash_newfunc
argument_list|,
literal|1021
argument_list|)
condition|)
return|return
name|NULL
return|;
name|ainfo
operator|->
name|line
operator|=
name|NULL
expr_stmt|;
name|ainfo
operator|->
name|line_end
operator|=
name|NULL
expr_stmt|;
name|ainfo
operator|->
name|pdr
operator|=
name|NULL
expr_stmt|;
name|ainfo
operator|->
name|pdr_end
operator|=
name|NULL
expr_stmt|;
name|ainfo
operator|->
name|sym
operator|=
name|NULL
expr_stmt|;
name|ainfo
operator|->
name|sym_end
operator|=
name|NULL
expr_stmt|;
name|ainfo
operator|->
name|opt
operator|=
name|NULL
expr_stmt|;
name|ainfo
operator|->
name|opt_end
operator|=
name|NULL
expr_stmt|;
name|ainfo
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
name|ainfo
operator|->
name|aux_end
operator|=
name|NULL
expr_stmt|;
name|ainfo
operator|->
name|ss
operator|=
name|NULL
expr_stmt|;
name|ainfo
operator|->
name|ss_end
operator|=
name|NULL
expr_stmt|;
name|ainfo
operator|->
name|ss_hash
operator|=
name|NULL
expr_stmt|;
name|ainfo
operator|->
name|ss_hash_end
operator|=
name|NULL
expr_stmt|;
name|ainfo
operator|->
name|fdr
operator|=
name|NULL
expr_stmt|;
name|ainfo
operator|->
name|fdr_end
operator|=
name|NULL
expr_stmt|;
name|ainfo
operator|->
name|rfd
operator|=
name|NULL
expr_stmt|;
name|ainfo
operator|->
name|rfd_end
operator|=
name|NULL
expr_stmt|;
name|ainfo
operator|->
name|largest_file_shuffle
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|relocateable
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_hash_table_init
argument_list|(
operator|&
name|ainfo
operator|->
name|str_hash
operator|.
name|table
argument_list|,
name|string_hash_newfunc
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* The first entry in the string table is the empty string.  */
name|output_debug
operator|->
name|symbolic_header
operator|.
name|issMax
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|obstack_begin
argument_list|(
operator|&
name|ainfo
operator|->
name|memory
argument_list|,
literal|4050
argument_list|)
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
operator|(
name|PTR
operator|)
name|ainfo
return|;
block|}
end_function

begin_comment
comment|/* Free the accumulated debugging information.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|bfd_ecoff_debug_free
parameter_list|(
name|handle
parameter_list|,
name|output_bfd
parameter_list|,
name|output_debug
parameter_list|,
name|output_swap
parameter_list|,
name|info
parameter_list|)
name|PTR
name|handle
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|ecoff_debug_info
modifier|*
name|output_debug
decl_stmt|;
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|output_swap
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|struct
name|accumulate
modifier|*
name|ainfo
init|=
operator|(
expr|struct
name|accumulate
operator|*
operator|)
name|handle
decl_stmt|;
name|bfd_hash_table_free
argument_list|(
operator|&
name|ainfo
operator|->
name|fdr_hash
operator|.
name|table
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|relocateable
condition|)
name|bfd_hash_table_free
argument_list|(
operator|&
name|ainfo
operator|->
name|str_hash
operator|.
name|table
argument_list|)
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|ainfo
operator|->
name|memory
argument_list|,
operator|(
name|PTR
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ainfo
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Accumulate the debugging information from INPUT_BFD into    OUTPUT_BFD.  The INPUT_DEBUG argument points to some ECOFF    debugging information which we want to link into the information    pointed to by the OUTPUT_DEBUG argument.  OUTPUT_SWAP and    INPUT_SWAP point to the swapping information needed.  INFO is the    linker information structure.  HANDLE is returned by    bfd_ecoff_debug_init.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|boolean
name|bfd_ecoff_debug_accumulate
parameter_list|(
name|handle
parameter_list|,
name|output_bfd
parameter_list|,
name|output_debug
parameter_list|,
name|output_swap
parameter_list|,
name|input_bfd
parameter_list|,
name|input_debug
parameter_list|,
name|input_swap
parameter_list|,
name|info
parameter_list|)
name|PTR
name|handle
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|ecoff_debug_info
modifier|*
name|output_debug
decl_stmt|;
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|output_swap
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|struct
name|ecoff_debug_info
modifier|*
name|input_debug
decl_stmt|;
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|input_swap
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|struct
name|accumulate
modifier|*
name|ainfo
init|=
operator|(
expr|struct
name|accumulate
operator|*
operator|)
name|handle
decl_stmt|;
name|void
argument_list|(
argument|* const swap_sym_in
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|SYMR
operator|*
operator|)
argument_list|)
operator|=
name|input_swap
operator|->
name|swap_sym_in
expr_stmt|;
name|void
argument_list|(
argument|* const swap_rfd_in
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|RFDT
operator|*
operator|)
argument_list|)
operator|=
name|input_swap
operator|->
name|swap_rfd_in
expr_stmt|;
name|void
argument_list|(
argument|* const swap_sym_out
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|SYMR
operator|*
operator|,
name|PTR
operator|)
argument_list|)
operator|=
name|output_swap
operator|->
name|swap_sym_out
expr_stmt|;
name|void
argument_list|(
argument|* const swap_fdr_out
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|FDR
operator|*
operator|,
name|PTR
operator|)
argument_list|)
operator|=
name|output_swap
operator|->
name|swap_fdr_out
expr_stmt|;
name|void
argument_list|(
argument|* const swap_rfd_out
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|RFDT
operator|*
operator|,
name|PTR
operator|)
argument_list|)
operator|=
name|output_swap
operator|->
name|swap_rfd_out
expr_stmt|;
name|bfd_size_type
name|external_pdr_size
init|=
name|output_swap
operator|->
name|external_pdr_size
decl_stmt|;
name|bfd_size_type
name|external_sym_size
init|=
name|output_swap
operator|->
name|external_sym_size
decl_stmt|;
name|bfd_size_type
name|external_opt_size
init|=
name|output_swap
operator|->
name|external_opt_size
decl_stmt|;
name|bfd_size_type
name|external_fdr_size
init|=
name|output_swap
operator|->
name|external_fdr_size
decl_stmt|;
name|bfd_size_type
name|external_rfd_size
init|=
name|output_swap
operator|->
name|external_rfd_size
decl_stmt|;
name|HDRR
modifier|*
specifier|const
name|output_symhdr
init|=
operator|&
name|output_debug
operator|->
name|symbolic_header
decl_stmt|;
name|HDRR
modifier|*
specifier|const
name|input_symhdr
init|=
operator|&
name|input_debug
operator|->
name|symbolic_header
decl_stmt|;
name|bfd_vma
name|section_adjust
index|[
name|scMax
index|]
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd_byte
modifier|*
name|fdr_start
decl_stmt|;
name|bfd_byte
modifier|*
name|fdr_ptr
decl_stmt|;
name|bfd_byte
modifier|*
name|fdr_end
decl_stmt|;
name|bfd_size_type
name|fdr_add
decl_stmt|;
name|unsigned
name|int
name|copied
decl_stmt|;
name|RFDT
name|i
decl_stmt|;
name|unsigned
name|long
name|sz
decl_stmt|;
name|bfd_byte
modifier|*
name|rfd_out
decl_stmt|;
name|bfd_byte
modifier|*
name|rfd_in
decl_stmt|;
name|bfd_byte
modifier|*
name|rfd_end
decl_stmt|;
name|long
name|newrfdbase
init|=
literal|0
decl_stmt|;
name|long
name|oldrfdbase
init|=
literal|0
decl_stmt|;
name|bfd_byte
modifier|*
name|fdr_out
decl_stmt|;
comment|/* Use section_adjust to hold the value to add to a symbol in a      particular section.  */
name|memset
argument_list|(
operator|(
name|PTR
operator|)
name|section_adjust
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|section_adjust
argument_list|)
expr_stmt|;
define|#
directive|define
name|SET
parameter_list|(
name|name
parameter_list|,
name|indx
parameter_list|)
define|\
value|sec = bfd_get_section_by_name (input_bfd, name); \   if (sec != NULL) \     section_adjust[indx] = (sec->output_section->vma \ 			    + sec->output_offset \ 			    - sec->vma);
name|SET
argument_list|(
literal|".text"
argument_list|,
name|scText
argument_list|)
expr_stmt|;
name|SET
argument_list|(
literal|".data"
argument_list|,
name|scData
argument_list|)
expr_stmt|;
name|SET
argument_list|(
literal|".bss"
argument_list|,
name|scBss
argument_list|)
expr_stmt|;
name|SET
argument_list|(
literal|".sdata"
argument_list|,
name|scSData
argument_list|)
expr_stmt|;
name|SET
argument_list|(
literal|".sbss"
argument_list|,
name|scSBss
argument_list|)
expr_stmt|;
comment|/* scRdata section may be either .rdata or .rodata.  */
name|SET
argument_list|(
literal|".rdata"
argument_list|,
name|scRData
argument_list|)
expr_stmt|;
name|SET
argument_list|(
literal|".rodata"
argument_list|,
name|scRData
argument_list|)
expr_stmt|;
name|SET
argument_list|(
literal|".init"
argument_list|,
name|scInit
argument_list|)
expr_stmt|;
name|SET
argument_list|(
literal|".fini"
argument_list|,
name|scFini
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|SET
comment|/* Find all the debugging information based on the FDR's.  We need      to handle them whether they are swapped or not.  */
if|if
condition|(
name|input_debug
operator|->
name|fdr
operator|!=
operator|(
name|FDR
operator|*
operator|)
name|NULL
condition|)
block|{
name|fdr_start
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|input_debug
operator|->
name|fdr
expr_stmt|;
name|fdr_add
operator|=
sizeof|sizeof
argument_list|(
name|FDR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fdr_start
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|input_debug
operator|->
name|external_fdr
expr_stmt|;
name|fdr_add
operator|=
name|input_swap
operator|->
name|external_fdr_size
expr_stmt|;
block|}
name|fdr_end
operator|=
name|fdr_start
operator|+
name|input_symhdr
operator|->
name|ifdMax
operator|*
name|fdr_add
expr_stmt|;
name|input_debug
operator|->
name|ifdmap
operator|=
operator|(
name|RFDT
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|input_symhdr
operator|->
name|ifdMax
operator|*
sizeof|sizeof
argument_list|(
name|RFDT
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|sz
operator|=
operator|(
name|input_symhdr
operator|->
name|crfd
operator|+
name|input_symhdr
operator|->
name|ifdMax
operator|)
operator|*
name|external_rfd_size
expr_stmt|;
name|rfd_out
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|ainfo
operator|->
name|memory
argument_list|,
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|input_debug
operator|->
name|ifdmap
operator|||
operator|!
name|rfd_out
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|add_memory_shuffle
argument_list|(
name|ainfo
argument_list|,
operator|&
name|ainfo
operator|->
name|rfd
argument_list|,
operator|&
name|ainfo
operator|->
name|rfd_end
argument_list|,
name|rfd_out
argument_list|,
name|sz
argument_list|)
condition|)
return|return
name|false
return|;
name|copied
operator|=
literal|0
expr_stmt|;
comment|/* Look through the FDR's to see which ones we are going to include      in the final output.  We do not want duplicate FDR information      for header files, because ECOFF debugging is often very large.      When we find an FDR with no line information which can be merged,      we look it up in a hash table to ensure that we only include it      once.  We keep a table mapping FDR numbers to the final number      they get with the BFD, so that we can refer to it when we write      out the external symbols.  */
for|for
control|(
name|fdr_ptr
operator|=
name|fdr_start
operator|,
name|i
operator|=
literal|0
init|;
name|fdr_ptr
operator|<
name|fdr_end
condition|;
name|fdr_ptr
operator|+=
name|fdr_add
operator|,
name|i
operator|++
operator|,
name|rfd_out
operator|+=
name|external_rfd_size
control|)
block|{
name|FDR
name|fdr
decl_stmt|;
if|if
condition|(
name|input_debug
operator|->
name|fdr
operator|!=
operator|(
name|FDR
operator|*
operator|)
name|NULL
condition|)
name|fdr
operator|=
operator|*
operator|(
name|FDR
operator|*
operator|)
name|fdr_ptr
expr_stmt|;
else|else
call|(
modifier|*
name|input_swap
operator|->
name|swap_fdr_in
call|)
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|PTR
operator|)
name|fdr_ptr
argument_list|,
operator|&
name|fdr
argument_list|)
expr_stmt|;
comment|/* See if this FDR can be merged with an existing one.  */
if|if
condition|(
name|fdr
operator|.
name|cbLine
operator|==
literal|0
operator|&&
name|fdr
operator|.
name|rss
operator|!=
operator|-
literal|1
operator|&&
name|fdr
operator|.
name|fMerge
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|lookup
decl_stmt|;
name|struct
name|string_hash_entry
modifier|*
name|fh
decl_stmt|;
comment|/* We look up a string formed from the file name and the 	     number of symbols.  Sometimes an include file will 	     conditionally define a typedef or something based on the 	     order of include files.  Using the number of symbols as a 	     hash reduces the chance that we will merge symbol 	     information that should not be merged.  */
name|name
operator|=
name|input_debug
operator|->
name|ss
operator|+
name|fdr
operator|.
name|issBase
operator|+
name|fdr
operator|.
name|rss
expr_stmt|;
name|lookup
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|20
argument_list|)
expr_stmt|;
if|if
condition|(
name|lookup
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|sprintf
argument_list|(
name|lookup
argument_list|,
literal|"%s %lx"
argument_list|,
name|name
argument_list|,
name|fdr
operator|.
name|csym
argument_list|)
expr_stmt|;
name|fh
operator|=
name|string_hash_lookup
argument_list|(
operator|&
name|ainfo
operator|->
name|fdr_hash
argument_list|,
name|lookup
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lookup
argument_list|)
expr_stmt|;
if|if
condition|(
name|fh
operator|==
operator|(
expr|struct
name|string_hash_entry
operator|*
operator|)
name|NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
name|fh
operator|->
name|val
operator|!=
operator|-
literal|1
condition|)
block|{
name|input_debug
operator|->
name|ifdmap
index|[
name|i
index|]
operator|=
name|fh
operator|->
name|val
expr_stmt|;
call|(
modifier|*
name|swap_rfd_out
call|)
argument_list|(
name|output_bfd
argument_list|,
name|input_debug
operator|->
name|ifdmap
operator|+
name|i
argument_list|,
operator|(
name|PTR
operator|)
name|rfd_out
argument_list|)
expr_stmt|;
comment|/* Don't copy this FDR.  */
continue|continue;
block|}
name|fh
operator|->
name|val
operator|=
name|output_symhdr
operator|->
name|ifdMax
operator|+
name|copied
expr_stmt|;
block|}
name|input_debug
operator|->
name|ifdmap
index|[
name|i
index|]
operator|=
name|output_symhdr
operator|->
name|ifdMax
operator|+
name|copied
expr_stmt|;
call|(
modifier|*
name|swap_rfd_out
call|)
argument_list|(
name|output_bfd
argument_list|,
name|input_debug
operator|->
name|ifdmap
operator|+
name|i
argument_list|,
operator|(
name|PTR
operator|)
name|rfd_out
argument_list|)
expr_stmt|;
operator|++
name|copied
expr_stmt|;
block|}
name|newrfdbase
operator|=
name|output_symhdr
operator|->
name|crfd
expr_stmt|;
name|output_symhdr
operator|->
name|crfd
operator|+=
name|input_symhdr
operator|->
name|ifdMax
expr_stmt|;
comment|/* Copy over any existing RFD's.  RFD's are only created by the      linker, so this will only happen for input files which are the      result of a partial link.  */
name|rfd_in
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|input_debug
operator|->
name|external_rfd
expr_stmt|;
name|rfd_end
operator|=
name|rfd_in
operator|+
name|input_symhdr
operator|->
name|crfd
operator|*
name|input_swap
operator|->
name|external_rfd_size
expr_stmt|;
for|for
control|(
init|;
name|rfd_in
operator|<
name|rfd_end
condition|;
name|rfd_in
operator|+=
name|input_swap
operator|->
name|external_rfd_size
control|)
block|{
name|RFDT
name|rfd
decl_stmt|;
call|(
modifier|*
name|swap_rfd_in
call|)
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|PTR
operator|)
name|rfd_in
argument_list|,
operator|&
name|rfd
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|rfd
operator|>=
literal|0
operator|&&
name|rfd
operator|<
name|input_symhdr
operator|->
name|ifdMax
argument_list|)
expr_stmt|;
name|rfd
operator|=
name|input_debug
operator|->
name|ifdmap
index|[
name|rfd
index|]
expr_stmt|;
call|(
modifier|*
name|swap_rfd_out
call|)
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rfd
argument_list|,
operator|(
name|PTR
operator|)
name|rfd_out
argument_list|)
expr_stmt|;
name|rfd_out
operator|+=
name|external_rfd_size
expr_stmt|;
block|}
name|oldrfdbase
operator|=
name|output_symhdr
operator|->
name|crfd
expr_stmt|;
name|output_symhdr
operator|->
name|crfd
operator|+=
name|input_symhdr
operator|->
name|crfd
expr_stmt|;
comment|/* Look through the FDR's and copy over all associated debugging      information.  */
name|sz
operator|=
name|copied
operator|*
name|external_fdr_size
expr_stmt|;
name|fdr_out
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|ainfo
operator|->
name|memory
argument_list|,
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fdr_out
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|add_memory_shuffle
argument_list|(
name|ainfo
argument_list|,
operator|&
name|ainfo
operator|->
name|fdr
argument_list|,
operator|&
name|ainfo
operator|->
name|fdr_end
argument_list|,
name|fdr_out
argument_list|,
name|sz
argument_list|)
condition|)
return|return
name|false
return|;
for|for
control|(
name|fdr_ptr
operator|=
name|fdr_start
operator|,
name|i
operator|=
literal|0
init|;
name|fdr_ptr
operator|<
name|fdr_end
condition|;
name|fdr_ptr
operator|+=
name|fdr_add
operator|,
name|i
operator|++
control|)
block|{
name|FDR
name|fdr
decl_stmt|;
name|bfd_vma
name|fdr_adr
decl_stmt|;
name|bfd_byte
modifier|*
name|sym_out
decl_stmt|;
name|bfd_byte
modifier|*
name|lraw_src
decl_stmt|;
name|bfd_byte
modifier|*
name|lraw_end
decl_stmt|;
name|boolean
name|fgotfilename
decl_stmt|;
if|if
condition|(
name|input_debug
operator|->
name|ifdmap
index|[
name|i
index|]
operator|<
name|output_symhdr
operator|->
name|ifdMax
condition|)
block|{
comment|/* We are not copying this FDR.  */
continue|continue;
block|}
if|if
condition|(
name|input_debug
operator|->
name|fdr
operator|!=
operator|(
name|FDR
operator|*
operator|)
name|NULL
condition|)
name|fdr
operator|=
operator|*
operator|(
name|FDR
operator|*
operator|)
name|fdr_ptr
expr_stmt|;
else|else
call|(
modifier|*
name|input_swap
operator|->
name|swap_fdr_in
call|)
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|PTR
operator|)
name|fdr_ptr
argument_list|,
operator|&
name|fdr
argument_list|)
expr_stmt|;
name|fdr_adr
operator|=
name|fdr
operator|.
name|adr
expr_stmt|;
comment|/* Adjust the FDR address for any changes that may have been 	 made by relaxing.  */
if|if
condition|(
name|input_debug
operator|->
name|adjust
operator|!=
operator|(
expr|struct
name|ecoff_value_adjust
operator|*
operator|)
name|NULL
condition|)
block|{
name|struct
name|ecoff_value_adjust
modifier|*
name|adjust
decl_stmt|;
for|for
control|(
name|adjust
operator|=
name|input_debug
operator|->
name|adjust
init|;
name|adjust
operator|!=
operator|(
expr|struct
name|ecoff_value_adjust
operator|*
operator|)
name|NULL
condition|;
name|adjust
operator|=
name|adjust
operator|->
name|next
control|)
if|if
condition|(
name|fdr_adr
operator|>=
name|adjust
operator|->
name|start
operator|&&
name|fdr_adr
operator|<
name|adjust
operator|->
name|end
condition|)
name|fdr
operator|.
name|adr
operator|+=
name|adjust
operator|->
name|adjust
expr_stmt|;
block|}
comment|/* FIXME: It is conceivable that this FDR points to the .init or 	 .fini section, in which case this will not do the right 	 thing.  */
name|fdr
operator|.
name|adr
operator|+=
name|section_adjust
index|[
name|scText
index|]
expr_stmt|;
comment|/* Swap in the local symbols, adjust their values, and swap them 	 out again.  */
name|fgotfilename
operator|=
name|false
expr_stmt|;
name|sz
operator|=
name|fdr
operator|.
name|csym
operator|*
name|external_sym_size
expr_stmt|;
name|sym_out
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|ainfo
operator|->
name|memory
argument_list|,
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sym_out
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|add_memory_shuffle
argument_list|(
name|ainfo
argument_list|,
operator|&
name|ainfo
operator|->
name|sym
argument_list|,
operator|&
name|ainfo
operator|->
name|sym_end
argument_list|,
name|sym_out
argument_list|,
name|sz
argument_list|)
condition|)
return|return
name|false
return|;
name|lraw_src
operator|=
operator|(
operator|(
name|bfd_byte
operator|*
operator|)
name|input_debug
operator|->
name|external_sym
operator|+
name|fdr
operator|.
name|isymBase
operator|*
name|input_swap
operator|->
name|external_sym_size
operator|)
expr_stmt|;
name|lraw_end
operator|=
name|lraw_src
operator|+
name|fdr
operator|.
name|csym
operator|*
name|input_swap
operator|->
name|external_sym_size
expr_stmt|;
for|for
control|(
init|;
name|lraw_src
operator|<
name|lraw_end
condition|;
name|lraw_src
operator|+=
name|input_swap
operator|->
name|external_sym_size
control|)
block|{
name|SYMR
name|internal_sym
decl_stmt|;
call|(
modifier|*
name|swap_sym_in
call|)
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|PTR
operator|)
name|lraw_src
argument_list|,
operator|&
name|internal_sym
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|internal_sym
operator|.
name|sc
operator|!=
name|scCommon
operator|&&
name|internal_sym
operator|.
name|sc
operator|!=
name|scSCommon
argument_list|)
expr_stmt|;
comment|/* Adjust the symbol value if appropriate.  */
switch|switch
condition|(
name|internal_sym
operator|.
name|st
condition|)
block|{
case|case
name|stNil
case|:
if|if
condition|(
name|ECOFF_IS_STAB
argument_list|(
operator|&
name|internal_sym
argument_list|)
condition|)
break|break;
comment|/* Fall through.  */
case|case
name|stGlobal
case|:
case|case
name|stStatic
case|:
case|case
name|stLabel
case|:
case|case
name|stProc
case|:
case|case
name|stStaticProc
case|:
if|if
condition|(
name|input_debug
operator|->
name|adjust
operator|!=
operator|(
expr|struct
name|ecoff_value_adjust
operator|*
operator|)
name|NULL
condition|)
block|{
name|bfd_vma
name|value
decl_stmt|;
name|struct
name|ecoff_value_adjust
modifier|*
name|adjust
decl_stmt|;
name|value
operator|=
name|internal_sym
operator|.
name|value
expr_stmt|;
for|for
control|(
name|adjust
operator|=
name|input_debug
operator|->
name|adjust
init|;
name|adjust
operator|!=
operator|(
expr|struct
name|ecoff_value_adjust
operator|*
operator|)
name|NULL
condition|;
name|adjust
operator|=
name|adjust
operator|->
name|next
control|)
if|if
condition|(
name|value
operator|>=
name|adjust
operator|->
name|start
operator|&&
name|value
operator|<
name|adjust
operator|->
name|end
condition|)
name|internal_sym
operator|.
name|value
operator|+=
name|adjust
operator|->
name|adjust
expr_stmt|;
block|}
name|internal_sym
operator|.
name|value
operator|+=
name|section_adjust
index|[
name|internal_sym
operator|.
name|sc
index|]
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* If we are doing a final link, we hash all the strings in 	     the local symbol table together.  This reduces the amount 	     of space required by debugging information.  We don't do 	     this when performing a relocateable link because it would 	     prevent us from easily merging different FDR's.  */
if|if
condition|(
operator|!
name|info
operator|->
name|relocateable
condition|)
block|{
name|boolean
name|ffilename
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
operator|!
name|fgotfilename
operator|&&
name|internal_sym
operator|.
name|iss
operator|==
name|fdr
operator|.
name|rss
condition|)
name|ffilename
operator|=
name|true
expr_stmt|;
else|else
name|ffilename
operator|=
name|false
expr_stmt|;
comment|/* Hash the name into the string table.  */
name|name
operator|=
name|input_debug
operator|->
name|ss
operator|+
name|fdr
operator|.
name|issBase
operator|+
name|internal_sym
operator|.
name|iss
expr_stmt|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'\0'
condition|)
name|internal_sym
operator|.
name|iss
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|struct
name|string_hash_entry
modifier|*
name|sh
decl_stmt|;
name|sh
operator|=
name|string_hash_lookup
argument_list|(
operator|&
name|ainfo
operator|->
name|str_hash
argument_list|,
name|name
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|sh
operator|==
operator|(
expr|struct
name|string_hash_entry
operator|*
operator|)
name|NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
name|sh
operator|->
name|val
operator|==
operator|-
literal|1
condition|)
block|{
name|sh
operator|->
name|val
operator|=
name|output_symhdr
operator|->
name|issMax
expr_stmt|;
name|output_symhdr
operator|->
name|issMax
operator|+=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|ainfo
operator|->
name|ss_hash
operator|==
operator|(
expr|struct
name|string_hash_entry
operator|*
operator|)
name|NULL
condition|)
name|ainfo
operator|->
name|ss_hash
operator|=
name|sh
expr_stmt|;
if|if
condition|(
name|ainfo
operator|->
name|ss_hash_end
operator|!=
operator|(
expr|struct
name|string_hash_entry
operator|*
operator|)
name|NULL
condition|)
name|ainfo
operator|->
name|ss_hash_end
operator|->
name|next
operator|=
name|sh
expr_stmt|;
name|ainfo
operator|->
name|ss_hash_end
operator|=
name|sh
expr_stmt|;
block|}
name|internal_sym
operator|.
name|iss
operator|=
name|sh
operator|->
name|val
expr_stmt|;
block|}
if|if
condition|(
name|ffilename
condition|)
block|{
name|fdr
operator|.
name|rss
operator|=
name|internal_sym
operator|.
name|iss
expr_stmt|;
name|fgotfilename
operator|=
name|true
expr_stmt|;
block|}
block|}
call|(
modifier|*
name|swap_sym_out
call|)
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|internal_sym
argument_list|,
name|sym_out
argument_list|)
expr_stmt|;
name|sym_out
operator|+=
name|external_sym_size
expr_stmt|;
block|}
name|fdr
operator|.
name|isymBase
operator|=
name|output_symhdr
operator|->
name|isymMax
expr_stmt|;
name|output_symhdr
operator|->
name|isymMax
operator|+=
name|fdr
operator|.
name|csym
expr_stmt|;
comment|/* Copy the information that does not need swapping.  */
comment|/* FIXME: If we are relaxing, we need to adjust the line 	 numbers.  Frankly, forget it.  Anybody using stabs debugging 	 information will not use this line number information, and 	 stabs are adjusted correctly.  */
if|if
condition|(
name|fdr
operator|.
name|cbLine
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|add_file_shuffle
argument_list|(
name|ainfo
argument_list|,
operator|&
name|ainfo
operator|->
name|line
argument_list|,
operator|&
name|ainfo
operator|->
name|line_end
argument_list|,
name|input_bfd
argument_list|,
name|input_symhdr
operator|->
name|cbLineOffset
operator|+
name|fdr
operator|.
name|cbLineOffset
argument_list|,
name|fdr
operator|.
name|cbLine
argument_list|)
condition|)
return|return
name|false
return|;
name|fdr
operator|.
name|ilineBase
operator|=
name|output_symhdr
operator|->
name|ilineMax
expr_stmt|;
name|fdr
operator|.
name|cbLineOffset
operator|=
name|output_symhdr
operator|->
name|cbLine
expr_stmt|;
name|output_symhdr
operator|->
name|ilineMax
operator|+=
name|fdr
operator|.
name|cline
expr_stmt|;
name|output_symhdr
operator|->
name|cbLine
operator|+=
name|fdr
operator|.
name|cbLine
expr_stmt|;
block|}
if|if
condition|(
name|fdr
operator|.
name|caux
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|add_file_shuffle
argument_list|(
name|ainfo
argument_list|,
operator|&
name|ainfo
operator|->
name|aux
argument_list|,
operator|&
name|ainfo
operator|->
name|aux_end
argument_list|,
name|input_bfd
argument_list|,
operator|(
name|input_symhdr
operator|->
name|cbAuxOffset
operator|+
name|fdr
operator|.
name|iauxBase
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|aux_ext
argument_list|)
operator|)
argument_list|,
name|fdr
operator|.
name|caux
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|aux_ext
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
name|fdr
operator|.
name|iauxBase
operator|=
name|output_symhdr
operator|->
name|iauxMax
expr_stmt|;
name|output_symhdr
operator|->
name|iauxMax
operator|+=
name|fdr
operator|.
name|caux
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|info
operator|->
name|relocateable
condition|)
block|{
comment|/* When are are hashing strings, we lie about the number of 	     strings attached to each FDR.  We need to set cbSs 	     because some versions of dbx apparently use it to decide 	     how much of the string table to read in.  */
name|fdr
operator|.
name|issBase
operator|=
literal|0
expr_stmt|;
name|fdr
operator|.
name|cbSs
operator|=
name|output_symhdr
operator|->
name|issMax
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fdr
operator|.
name|cbSs
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|add_file_shuffle
argument_list|(
name|ainfo
argument_list|,
operator|&
name|ainfo
operator|->
name|ss
argument_list|,
operator|&
name|ainfo
operator|->
name|ss_end
argument_list|,
name|input_bfd
argument_list|,
name|input_symhdr
operator|->
name|cbSsOffset
operator|+
name|fdr
operator|.
name|issBase
argument_list|,
name|fdr
operator|.
name|cbSs
argument_list|)
condition|)
return|return
name|false
return|;
name|fdr
operator|.
name|issBase
operator|=
name|output_symhdr
operator|->
name|issMax
expr_stmt|;
name|output_symhdr
operator|->
name|issMax
operator|+=
name|fdr
operator|.
name|cbSs
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|output_bfd
operator|->
name|xvec
operator|->
name|header_byteorder_big_p
operator|==
name|input_bfd
operator|->
name|xvec
operator|->
name|header_byteorder_big_p
operator|)
operator|&&
name|input_debug
operator|->
name|adjust
operator|==
operator|(
expr|struct
name|ecoff_value_adjust
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* The two BFD's have the same endianness, and we don't have 	     to adjust the PDR addresses, so simply copying the 	     information will suffice.  */
name|BFD_ASSERT
argument_list|(
name|external_pdr_size
operator|==
name|input_swap
operator|->
name|external_pdr_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdr
operator|.
name|cpd
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|add_file_shuffle
argument_list|(
name|ainfo
argument_list|,
operator|&
name|ainfo
operator|->
name|pdr
argument_list|,
operator|&
name|ainfo
operator|->
name|pdr_end
argument_list|,
name|input_bfd
argument_list|,
operator|(
name|input_symhdr
operator|->
name|cbPdOffset
operator|+
name|fdr
operator|.
name|ipdFirst
operator|*
name|external_pdr_size
operator|)
argument_list|,
name|fdr
operator|.
name|cpd
operator|*
name|external_pdr_size
argument_list|)
condition|)
return|return
name|false
return|;
block|}
name|BFD_ASSERT
argument_list|(
name|external_opt_size
operator|==
name|input_swap
operator|->
name|external_opt_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdr
operator|.
name|copt
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|add_file_shuffle
argument_list|(
name|ainfo
argument_list|,
operator|&
name|ainfo
operator|->
name|opt
argument_list|,
operator|&
name|ainfo
operator|->
name|opt_end
argument_list|,
name|input_bfd
argument_list|,
operator|(
name|input_symhdr
operator|->
name|cbOptOffset
operator|+
name|fdr
operator|.
name|ioptBase
operator|*
name|external_opt_size
operator|)
argument_list|,
name|fdr
operator|.
name|copt
operator|*
name|external_opt_size
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
else|else
block|{
name|bfd_size_type
name|outsz
decl_stmt|,
name|insz
decl_stmt|;
name|bfd_byte
modifier|*
name|in
decl_stmt|;
name|bfd_byte
modifier|*
name|end
decl_stmt|;
name|bfd_byte
modifier|*
name|out
decl_stmt|;
comment|/* The two BFD's have different endianness, so we must swap 	     everything in and out.  This code would always work, but 	     it would be unnecessarily slow in the normal case.  */
name|outsz
operator|=
name|external_pdr_size
expr_stmt|;
name|insz
operator|=
name|input_swap
operator|->
name|external_pdr_size
expr_stmt|;
name|in
operator|=
operator|(
operator|(
name|bfd_byte
operator|*
operator|)
name|input_debug
operator|->
name|external_pdr
operator|+
name|fdr
operator|.
name|ipdFirst
operator|*
name|insz
operator|)
expr_stmt|;
name|end
operator|=
name|in
operator|+
name|fdr
operator|.
name|cpd
operator|*
name|insz
expr_stmt|;
name|sz
operator|=
name|fdr
operator|.
name|cpd
operator|*
name|outsz
expr_stmt|;
name|out
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|ainfo
operator|->
name|memory
argument_list|,
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|out
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|add_memory_shuffle
argument_list|(
name|ainfo
argument_list|,
operator|&
name|ainfo
operator|->
name|pdr
argument_list|,
operator|&
name|ainfo
operator|->
name|pdr_end
argument_list|,
name|out
argument_list|,
name|sz
argument_list|)
condition|)
return|return
name|false
return|;
for|for
control|(
init|;
name|in
operator|<
name|end
condition|;
name|in
operator|+=
name|insz
operator|,
name|out
operator|+=
name|outsz
control|)
block|{
name|PDR
name|pdr
decl_stmt|;
call|(
modifier|*
name|input_swap
operator|->
name|swap_pdr_in
call|)
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|PTR
operator|)
name|in
argument_list|,
operator|&
name|pdr
argument_list|)
expr_stmt|;
comment|/* If we have been relaxing, we may have to adjust the 		 address.  */
if|if
condition|(
name|input_debug
operator|->
name|adjust
operator|!=
operator|(
expr|struct
name|ecoff_value_adjust
operator|*
operator|)
name|NULL
condition|)
block|{
name|bfd_vma
name|adr
decl_stmt|;
name|struct
name|ecoff_value_adjust
modifier|*
name|adjust
decl_stmt|;
name|adr
operator|=
name|fdr_adr
operator|+
name|pdr
operator|.
name|adr
expr_stmt|;
for|for
control|(
name|adjust
operator|=
name|input_debug
operator|->
name|adjust
init|;
name|adjust
operator|!=
operator|(
expr|struct
name|ecoff_value_adjust
operator|*
operator|)
name|NULL
condition|;
name|adjust
operator|=
name|adjust
operator|->
name|next
control|)
if|if
condition|(
name|adr
operator|>=
name|adjust
operator|->
name|start
operator|&&
name|adr
operator|<
name|adjust
operator|->
name|end
condition|)
name|pdr
operator|.
name|adr
operator|+=
name|adjust
operator|->
name|adjust
expr_stmt|;
block|}
call|(
modifier|*
name|output_swap
operator|->
name|swap_pdr_out
call|)
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|pdr
argument_list|,
operator|(
name|PTR
operator|)
name|out
argument_list|)
expr_stmt|;
block|}
comment|/* Swap over the optimization information.  */
name|outsz
operator|=
name|external_opt_size
expr_stmt|;
name|insz
operator|=
name|input_swap
operator|->
name|external_opt_size
expr_stmt|;
name|in
operator|=
operator|(
operator|(
name|bfd_byte
operator|*
operator|)
name|input_debug
operator|->
name|external_opt
operator|+
name|fdr
operator|.
name|ioptBase
operator|*
name|insz
operator|)
expr_stmt|;
name|end
operator|=
name|in
operator|+
name|fdr
operator|.
name|copt
operator|*
name|insz
expr_stmt|;
name|sz
operator|=
name|fdr
operator|.
name|copt
operator|*
name|outsz
expr_stmt|;
name|out
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|ainfo
operator|->
name|memory
argument_list|,
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|out
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|add_memory_shuffle
argument_list|(
name|ainfo
argument_list|,
operator|&
name|ainfo
operator|->
name|opt
argument_list|,
operator|&
name|ainfo
operator|->
name|opt_end
argument_list|,
name|out
argument_list|,
name|sz
argument_list|)
condition|)
return|return
name|false
return|;
for|for
control|(
init|;
name|in
operator|<
name|end
condition|;
name|in
operator|+=
name|insz
operator|,
name|out
operator|+=
name|outsz
control|)
block|{
name|OPTR
name|opt
decl_stmt|;
call|(
modifier|*
name|input_swap
operator|->
name|swap_opt_in
call|)
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|PTR
operator|)
name|in
argument_list|,
operator|&
name|opt
argument_list|)
expr_stmt|;
call|(
modifier|*
name|output_swap
operator|->
name|swap_opt_out
call|)
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|opt
argument_list|,
operator|(
name|PTR
operator|)
name|out
argument_list|)
expr_stmt|;
block|}
block|}
name|fdr
operator|.
name|ipdFirst
operator|=
name|output_symhdr
operator|->
name|ipdMax
expr_stmt|;
name|output_symhdr
operator|->
name|ipdMax
operator|+=
name|fdr
operator|.
name|cpd
expr_stmt|;
name|fdr
operator|.
name|ioptBase
operator|=
name|output_symhdr
operator|->
name|ioptMax
expr_stmt|;
name|output_symhdr
operator|->
name|ioptMax
operator|+=
name|fdr
operator|.
name|copt
expr_stmt|;
if|if
condition|(
name|fdr
operator|.
name|crfd
operator|<=
literal|0
condition|)
block|{
comment|/* Point this FDR at the table of RFD's we created.  */
name|fdr
operator|.
name|rfdBase
operator|=
name|newrfdbase
expr_stmt|;
name|fdr
operator|.
name|crfd
operator|=
name|input_symhdr
operator|->
name|ifdMax
expr_stmt|;
block|}
else|else
block|{
comment|/* Point this FDR at the remapped RFD's.  */
name|fdr
operator|.
name|rfdBase
operator|+=
name|oldrfdbase
expr_stmt|;
block|}
call|(
modifier|*
name|swap_fdr_out
call|)
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|fdr
argument_list|,
name|fdr_out
argument_list|)
expr_stmt|;
name|fdr_out
operator|+=
name|external_fdr_size
expr_stmt|;
operator|++
name|output_symhdr
operator|->
name|ifdMax
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Add a string to the debugging information we are accumulating.    Return the offset from the fdr string base.  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|ecoff_add_string
name|PARAMS
argument_list|(
operator|(
expr|struct
name|accumulate
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|ecoff_debug_info
operator|*
operator|,
name|FDR
operator|*
name|fdr
operator|,
specifier|const
name|char
operator|*
name|string
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|long
name|ecoff_add_string
parameter_list|(
name|ainfo
parameter_list|,
name|info
parameter_list|,
name|debug
parameter_list|,
name|fdr
parameter_list|,
name|string
parameter_list|)
name|struct
name|accumulate
modifier|*
name|ainfo
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|ecoff_debug_info
modifier|*
name|debug
decl_stmt|;
name|FDR
modifier|*
name|fdr
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|HDRR
modifier|*
name|symhdr
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|bfd_size_type
name|ret
decl_stmt|;
name|symhdr
operator|=
operator|&
name|debug
operator|->
name|symbolic_header
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|relocateable
condition|)
block|{
if|if
condition|(
operator|!
name|add_memory_shuffle
argument_list|(
name|ainfo
argument_list|,
operator|&
name|ainfo
operator|->
name|ss
argument_list|,
operator|&
name|ainfo
operator|->
name|ss_end
argument_list|,
operator|(
name|PTR
operator|)
name|string
argument_list|,
name|len
operator|+
literal|1
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|ret
operator|=
name|symhdr
operator|->
name|issMax
expr_stmt|;
name|symhdr
operator|->
name|issMax
operator|+=
name|len
operator|+
literal|1
expr_stmt|;
name|fdr
operator|->
name|cbSs
operator|+=
name|len
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|struct
name|string_hash_entry
modifier|*
name|sh
decl_stmt|;
name|sh
operator|=
name|string_hash_lookup
argument_list|(
operator|&
name|ainfo
operator|->
name|str_hash
argument_list|,
name|string
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|sh
operator|==
operator|(
expr|struct
name|string_hash_entry
operator|*
operator|)
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|sh
operator|->
name|val
operator|==
operator|-
literal|1
condition|)
block|{
name|sh
operator|->
name|val
operator|=
name|symhdr
operator|->
name|issMax
expr_stmt|;
name|symhdr
operator|->
name|issMax
operator|+=
name|len
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|ainfo
operator|->
name|ss_hash
operator|==
operator|(
expr|struct
name|string_hash_entry
operator|*
operator|)
name|NULL
condition|)
name|ainfo
operator|->
name|ss_hash
operator|=
name|sh
expr_stmt|;
if|if
condition|(
name|ainfo
operator|->
name|ss_hash_end
operator|!=
operator|(
expr|struct
name|string_hash_entry
operator|*
operator|)
name|NULL
condition|)
name|ainfo
operator|->
name|ss_hash_end
operator|->
name|next
operator|=
name|sh
expr_stmt|;
name|ainfo
operator|->
name|ss_hash_end
operator|=
name|sh
expr_stmt|;
block|}
name|ret
operator|=
name|sh
operator|->
name|val
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Add debugging information from a non-ECOFF file.  */
end_comment

begin_function
name|boolean
name|bfd_ecoff_debug_accumulate_other
parameter_list|(
name|handle
parameter_list|,
name|output_bfd
parameter_list|,
name|output_debug
parameter_list|,
name|output_swap
parameter_list|,
name|input_bfd
parameter_list|,
name|info
parameter_list|)
name|PTR
name|handle
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|ecoff_debug_info
modifier|*
name|output_debug
decl_stmt|;
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|output_swap
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|struct
name|accumulate
modifier|*
name|ainfo
init|=
operator|(
expr|struct
name|accumulate
operator|*
operator|)
name|handle
decl_stmt|;
name|void
argument_list|(
argument|* const swap_sym_out
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|SYMR
operator|*
operator|,
name|PTR
operator|)
argument_list|)
operator|=
name|output_swap
operator|->
name|swap_sym_out
expr_stmt|;
name|HDRR
modifier|*
name|output_symhdr
init|=
operator|&
name|output_debug
operator|->
name|symbolic_header
decl_stmt|;
name|FDR
name|fdr
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|sym_ptr
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|sym_end
decl_stmt|;
name|long
name|symsize
decl_stmt|;
name|long
name|symcount
decl_stmt|;
name|PTR
name|external_fdr
decl_stmt|;
name|memset
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|fdr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|fdr
argument_list|)
expr_stmt|;
name|sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|input_bfd
argument_list|,
literal|".text"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|!=
name|NULL
condition|)
name|fdr
operator|.
name|adr
operator|=
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
expr_stmt|;
else|else
block|{
comment|/* FIXME: What about .init or .fini?  */
name|fdr
operator|.
name|adr
operator|=
literal|0
expr_stmt|;
block|}
name|fdr
operator|.
name|issBase
operator|=
name|output_symhdr
operator|->
name|issMax
expr_stmt|;
name|fdr
operator|.
name|cbSs
operator|=
literal|0
expr_stmt|;
name|fdr
operator|.
name|rss
operator|=
name|ecoff_add_string
argument_list|(
name|ainfo
argument_list|,
name|info
argument_list|,
name|output_debug
argument_list|,
operator|&
name|fdr
argument_list|,
name|bfd_get_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdr
operator|.
name|rss
operator|==
operator|-
literal|1
condition|)
return|return
name|false
return|;
name|fdr
operator|.
name|isymBase
operator|=
name|output_symhdr
operator|->
name|isymMax
expr_stmt|;
comment|/* Get the local symbols from the input BFD.  */
name|symsize
operator|=
name|bfd_get_symtab_upper_bound
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|symsize
operator|<
literal|0
condition|)
return|return
name|false
return|;
name|symbols
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|output_bfd
argument_list|,
name|symsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbols
operator|==
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|symcount
operator|=
name|bfd_canonicalize_symtab
argument_list|(
name|input_bfd
argument_list|,
name|symbols
argument_list|)
expr_stmt|;
if|if
condition|(
name|symcount
operator|<
literal|0
condition|)
return|return
name|false
return|;
name|sym_end
operator|=
name|symbols
operator|+
name|symcount
expr_stmt|;
comment|/* Handle the local symbols.  Any external symbols are handled      separately.  */
name|fdr
operator|.
name|csym
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|sym_ptr
operator|=
name|symbols
init|;
name|sym_ptr
operator|!=
name|sym_end
condition|;
name|sym_ptr
operator|++
control|)
block|{
name|SYMR
name|internal_sym
decl_stmt|;
name|PTR
name|external_sym
decl_stmt|;
if|if
condition|(
operator|(
operator|(
operator|*
name|sym_ptr
operator|)
operator|->
name|flags
operator|&
name|BSF_EXPORT
operator|)
operator|!=
literal|0
condition|)
continue|continue;
name|memset
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|internal_sym
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|internal_sym
argument_list|)
expr_stmt|;
name|internal_sym
operator|.
name|iss
operator|=
name|ecoff_add_string
argument_list|(
name|ainfo
argument_list|,
name|info
argument_list|,
name|output_debug
argument_list|,
operator|&
name|fdr
argument_list|,
operator|(
operator|*
name|sym_ptr
operator|)
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_sym
operator|.
name|iss
operator|==
operator|-
literal|1
condition|)
return|return
name|false
return|;
if|if
condition|(
name|bfd_is_com_section
argument_list|(
operator|(
operator|*
name|sym_ptr
operator|)
operator|->
name|section
argument_list|)
operator|||
name|bfd_is_und_section
argument_list|(
operator|(
operator|*
name|sym_ptr
operator|)
operator|->
name|section
argument_list|)
condition|)
name|internal_sym
operator|.
name|value
operator|=
operator|(
operator|*
name|sym_ptr
operator|)
operator|->
name|value
expr_stmt|;
else|else
name|internal_sym
operator|.
name|value
operator|=
operator|(
operator|(
operator|*
name|sym_ptr
operator|)
operator|->
name|value
operator|+
operator|(
operator|*
name|sym_ptr
operator|)
operator|->
name|section
operator|->
name|output_offset
operator|+
operator|(
operator|*
name|sym_ptr
operator|)
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
name|internal_sym
operator|.
name|st
operator|=
name|stNil
expr_stmt|;
name|internal_sym
operator|.
name|sc
operator|=
name|scUndefined
expr_stmt|;
name|internal_sym
operator|.
name|index
operator|=
name|indexNil
expr_stmt|;
name|external_sym
operator|=
operator|(
name|PTR
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|ainfo
operator|->
name|memory
argument_list|,
name|output_swap
operator|->
name|external_sym_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|external_sym
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
call|(
modifier|*
name|swap_sym_out
call|)
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|internal_sym
argument_list|,
name|external_sym
argument_list|)
expr_stmt|;
name|add_memory_shuffle
argument_list|(
name|ainfo
argument_list|,
operator|&
name|ainfo
operator|->
name|sym
argument_list|,
operator|&
name|ainfo
operator|->
name|sym_end
argument_list|,
name|external_sym
argument_list|,
name|output_swap
operator|->
name|external_sym_size
argument_list|)
expr_stmt|;
operator|++
name|fdr
operator|.
name|csym
expr_stmt|;
operator|++
name|output_symhdr
operator|->
name|isymMax
expr_stmt|;
block|}
name|bfd_release
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|PTR
operator|)
name|symbols
argument_list|)
expr_stmt|;
comment|/* Leave everything else in the FDR zeroed out.  This will cause      the lang field to be langC.  The fBigendian field will      indicate little endian format, but it doesn't matter because      it only applies to aux fields and there are none.  */
name|external_fdr
operator|=
operator|(
name|PTR
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|ainfo
operator|->
name|memory
argument_list|,
name|output_swap
operator|->
name|external_fdr_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|external_fdr
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
call|(
modifier|*
name|output_swap
operator|->
name|swap_fdr_out
call|)
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|fdr
argument_list|,
name|external_fdr
argument_list|)
expr_stmt|;
name|add_memory_shuffle
argument_list|(
name|ainfo
argument_list|,
operator|&
name|ainfo
operator|->
name|fdr
argument_list|,
operator|&
name|ainfo
operator|->
name|fdr_end
argument_list|,
name|external_fdr
argument_list|,
name|output_swap
operator|->
name|external_fdr_size
argument_list|)
expr_stmt|;
operator|++
name|output_symhdr
operator|->
name|ifdMax
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Set up ECOFF debugging information for the external symbols.    FIXME: This is done using a memory buffer, but it should be    probably be changed to use a shuffle structure.  The assembler uses    this interface, so that must be changed to do something else.  */
end_comment

begin_function_decl
name|boolean
name|bfd_ecoff_debug_externals
parameter_list|(
name|abfd
parameter_list|,
name|debug
parameter_list|,
name|swap
parameter_list|,
name|relocateable
parameter_list|,
name|get_extr
parameter_list|,
name|set_index
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|ecoff_debug_info
modifier|*
name|debug
decl_stmt|;
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|swap
decl_stmt|;
name|boolean
name|relocateable
decl_stmt|;
function_decl|boolean
parameter_list|(
function_decl|*get_extr
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|asymbol
operator|*
operator|,
name|EXTR
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|void
argument_list|(
argument|*set_index
argument_list|)
end_macro

begin_expr_stmt
name|PARAMS
argument_list|(
operator|(
name|asymbol
operator|*
operator|,
name|bfd_size_type
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|HDRR
modifier|*
specifier|const
name|symhdr
init|=
operator|&
name|debug
operator|->
name|symbolic_header
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|sym_ptr_ptr
decl_stmt|;
name|size_t
name|c
decl_stmt|;
name|sym_ptr_ptr
operator|=
name|bfd_get_outsymbols
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym_ptr_ptr
operator|==
name|NULL
condition|)
return|return
name|true
return|;
for|for
control|(
name|c
operator|=
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
init|;
name|c
operator|>
literal|0
condition|;
name|c
operator|--
operator|,
name|sym_ptr_ptr
operator|++
control|)
block|{
name|asymbol
modifier|*
name|sym_ptr
decl_stmt|;
name|EXTR
name|esym
decl_stmt|;
name|sym_ptr
operator|=
operator|*
name|sym_ptr_ptr
expr_stmt|;
comment|/* Get the external symbol information.  */
if|if
condition|(
call|(
modifier|*
name|get_extr
call|)
argument_list|(
name|sym_ptr
argument_list|,
operator|&
name|esym
argument_list|)
operator|==
name|false
condition|)
continue|continue;
comment|/* If we're producing an executable, move common symbols into 	 bss.  */
if|if
condition|(
name|relocateable
operator|==
name|false
condition|)
block|{
if|if
condition|(
name|esym
operator|.
name|asym
operator|.
name|sc
operator|==
name|scCommon
condition|)
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scBss
expr_stmt|;
elseif|else
if|if
condition|(
name|esym
operator|.
name|asym
operator|.
name|sc
operator|==
name|scSCommon
condition|)
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scSBss
expr_stmt|;
block|}
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|sym_ptr
operator|->
name|section
argument_list|)
operator|||
name|bfd_is_und_section
argument_list|(
name|sym_ptr
operator|->
name|section
argument_list|)
operator|||
name|sym_ptr
operator|->
name|section
operator|->
name|output_section
operator|==
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* FIXME: gas does not keep the value of a small undefined 	     symbol in the symbol itself, because of relocation 	     problems.  */
if|if
condition|(
name|esym
operator|.
name|asym
operator|.
name|sc
operator|!=
name|scSUndefined
operator|||
name|esym
operator|.
name|asym
operator|.
name|value
operator|==
literal|0
operator|||
name|sym_ptr
operator|->
name|value
operator|!=
literal|0
condition|)
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
name|sym_ptr
operator|->
name|value
expr_stmt|;
block|}
else|else
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
operator|(
name|sym_ptr
operator|->
name|value
operator|+
name|sym_ptr
operator|->
name|section
operator|->
name|output_offset
operator|+
name|sym_ptr
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
if|if
condition|(
name|set_index
condition|)
call|(
modifier|*
name|set_index
call|)
argument_list|(
name|sym_ptr
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|symhdr
operator|->
name|iextMax
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_ecoff_debug_one_external
argument_list|(
name|abfd
argument_list|,
name|debug
argument_list|,
name|swap
argument_list|,
name|sym_ptr
operator|->
name|name
argument_list|,
operator|&
name|esym
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_block

begin_comment
comment|/* Add a single external symbol to the debugging information.  */
end_comment

begin_function
name|boolean
name|bfd_ecoff_debug_one_external
parameter_list|(
name|abfd
parameter_list|,
name|debug
parameter_list|,
name|swap
parameter_list|,
name|name
parameter_list|,
name|esym
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|ecoff_debug_info
modifier|*
name|debug
decl_stmt|;
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|swap
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|EXTR
modifier|*
name|esym
decl_stmt|;
block|{
specifier|const
name|bfd_size_type
name|external_ext_size
init|=
name|swap
operator|->
name|external_ext_size
decl_stmt|;
name|void
argument_list|(
argument|* const swap_ext_out
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|EXTR
operator|*
operator|,
name|PTR
operator|)
argument_list|)
operator|=
name|swap
operator|->
name|swap_ext_out
expr_stmt|;
name|HDRR
modifier|*
specifier|const
name|symhdr
init|=
operator|&
name|debug
operator|->
name|symbolic_header
decl_stmt|;
name|size_t
name|namelen
decl_stmt|;
name|namelen
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|->
name|ssext_end
operator|-
name|debug
operator|->
name|ssext
operator|<
name|symhdr
operator|->
name|issExtMax
operator|+
name|namelen
operator|+
literal|1
condition|)
block|{
if|if
condition|(
name|ecoff_add_bytes
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|debug
operator|->
name|ssext
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|debug
operator|->
name|ssext_end
argument_list|,
name|symhdr
operator|->
name|issExtMax
operator|+
name|namelen
operator|+
literal|1
argument_list|)
operator|==
name|false
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
operator|(
name|char
operator|*
operator|)
name|debug
operator|->
name|external_ext_end
operator|-
operator|(
name|char
operator|*
operator|)
name|debug
operator|->
name|external_ext
operator|<
operator|(
name|symhdr
operator|->
name|iextMax
operator|+
literal|1
operator|)
operator|*
name|external_ext_size
condition|)
block|{
if|if
condition|(
name|ecoff_add_bytes
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|debug
operator|->
name|external_ext
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|debug
operator|->
name|external_ext_end
argument_list|,
operator|(
name|symhdr
operator|->
name|iextMax
operator|+
literal|1
operator|)
operator|*
name|external_ext_size
argument_list|)
operator|==
name|false
condition|)
return|return
name|false
return|;
block|}
name|esym
operator|->
name|asym
operator|.
name|iss
operator|=
name|symhdr
operator|->
name|issExtMax
expr_stmt|;
call|(
modifier|*
name|swap_ext_out
call|)
argument_list|(
name|abfd
argument_list|,
name|esym
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
name|debug
operator|->
name|external_ext
operator|+
name|symhdr
operator|->
name|iextMax
operator|*
name|swap
operator|->
name|external_ext_size
operator|)
argument_list|)
expr_stmt|;
operator|++
name|symhdr
operator|->
name|iextMax
expr_stmt|;
name|strcpy
argument_list|(
name|debug
operator|->
name|ssext
operator|+
name|symhdr
operator|->
name|issExtMax
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|symhdr
operator|->
name|issExtMax
operator|+=
name|namelen
operator|+
literal|1
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Align the ECOFF debugging information.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|ecoff_align_debug
parameter_list|(
name|abfd
parameter_list|,
name|debug
parameter_list|,
name|swap
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|ecoff_debug_info
modifier|*
name|debug
decl_stmt|;
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|swap
decl_stmt|;
block|{
name|HDRR
modifier|*
specifier|const
name|symhdr
init|=
operator|&
name|debug
operator|->
name|symbolic_header
decl_stmt|;
name|bfd_size_type
name|debug_align
decl_stmt|,
name|aux_align
decl_stmt|,
name|rfd_align
decl_stmt|;
name|size_t
name|add
decl_stmt|;
comment|/* Adjust the counts so that structures are aligned.  */
name|debug_align
operator|=
name|swap
operator|->
name|debug_align
expr_stmt|;
name|aux_align
operator|=
name|debug_align
operator|/
sizeof|sizeof
argument_list|(
expr|union
name|aux_ext
argument_list|)
expr_stmt|;
name|rfd_align
operator|=
name|debug_align
operator|/
name|swap
operator|->
name|external_rfd_size
expr_stmt|;
name|add
operator|=
name|debug_align
operator|-
operator|(
name|symhdr
operator|->
name|cbLine
operator|&
operator|(
name|debug_align
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|add
operator|!=
name|debug_align
condition|)
block|{
if|if
condition|(
name|debug
operator|->
name|line
operator|!=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|NULL
condition|)
name|memset
argument_list|(
call|(
name|PTR
call|)
argument_list|(
name|debug
operator|->
name|line
operator|+
name|symhdr
operator|->
name|cbLine
argument_list|)
argument_list|,
literal|0
argument_list|,
name|add
argument_list|)
expr_stmt|;
name|symhdr
operator|->
name|cbLine
operator|+=
name|add
expr_stmt|;
block|}
name|add
operator|=
name|debug_align
operator|-
operator|(
name|symhdr
operator|->
name|issMax
operator|&
operator|(
name|debug_align
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|add
operator|!=
name|debug_align
condition|)
block|{
if|if
condition|(
name|debug
operator|->
name|ss
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|memset
argument_list|(
call|(
name|PTR
call|)
argument_list|(
name|debug
operator|->
name|ss
operator|+
name|symhdr
operator|->
name|issMax
argument_list|)
argument_list|,
literal|0
argument_list|,
name|add
argument_list|)
expr_stmt|;
name|symhdr
operator|->
name|issMax
operator|+=
name|add
expr_stmt|;
block|}
name|add
operator|=
name|debug_align
operator|-
operator|(
name|symhdr
operator|->
name|issExtMax
operator|&
operator|(
name|debug_align
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|add
operator|!=
name|debug_align
condition|)
block|{
if|if
condition|(
name|debug
operator|->
name|ssext
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|memset
argument_list|(
call|(
name|PTR
call|)
argument_list|(
name|debug
operator|->
name|ssext
operator|+
name|symhdr
operator|->
name|issExtMax
argument_list|)
argument_list|,
literal|0
argument_list|,
name|add
argument_list|)
expr_stmt|;
name|symhdr
operator|->
name|issExtMax
operator|+=
name|add
expr_stmt|;
block|}
name|add
operator|=
name|aux_align
operator|-
operator|(
name|symhdr
operator|->
name|iauxMax
operator|&
operator|(
name|aux_align
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|add
operator|!=
name|aux_align
condition|)
block|{
if|if
condition|(
name|debug
operator|->
name|external_aux
operator|!=
operator|(
expr|union
name|aux_ext
operator|*
operator|)
name|NULL
condition|)
name|memset
argument_list|(
call|(
name|PTR
call|)
argument_list|(
name|debug
operator|->
name|external_aux
operator|+
name|symhdr
operator|->
name|iauxMax
argument_list|)
argument_list|,
literal|0
argument_list|,
name|add
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|aux_ext
argument_list|)
argument_list|)
expr_stmt|;
name|symhdr
operator|->
name|iauxMax
operator|+=
name|add
expr_stmt|;
block|}
name|add
operator|=
name|rfd_align
operator|-
operator|(
name|symhdr
operator|->
name|crfd
operator|&
operator|(
name|rfd_align
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|add
operator|!=
name|rfd_align
condition|)
block|{
if|if
condition|(
name|debug
operator|->
name|external_rfd
operator|!=
operator|(
name|PTR
operator|)
name|NULL
condition|)
name|memset
argument_list|(
call|(
name|PTR
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|debug
operator|->
name|external_rfd
operator|+
name|symhdr
operator|->
name|crfd
operator|*
name|swap
operator|->
name|external_rfd_size
argument_list|)
argument_list|,
literal|0
argument_list|,
name|add
operator|*
name|swap
operator|->
name|external_rfd_size
argument_list|)
expr_stmt|;
name|symhdr
operator|->
name|crfd
operator|+=
name|add
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return the size required by the ECOFF debugging information.  */
end_comment

begin_function
name|bfd_size_type
name|bfd_ecoff_debug_size
parameter_list|(
name|abfd
parameter_list|,
name|debug
parameter_list|,
name|swap
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|ecoff_debug_info
modifier|*
name|debug
decl_stmt|;
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|swap
decl_stmt|;
block|{
name|bfd_size_type
name|tot
decl_stmt|;
name|ecoff_align_debug
argument_list|(
name|abfd
argument_list|,
name|debug
argument_list|,
name|swap
argument_list|)
expr_stmt|;
name|tot
operator|=
name|swap
operator|->
name|external_hdr_size
expr_stmt|;
define|#
directive|define
name|ADD
parameter_list|(
name|count
parameter_list|,
name|size
parameter_list|)
define|\
value|tot += debug->symbolic_header.count * size
name|ADD
argument_list|(
name|cbLine
argument_list|,
expr|sizeof
operator|(
name|unsigned
name|char
operator|)
argument_list|)
expr_stmt|;
name|ADD
argument_list|(
name|idnMax
argument_list|,
name|swap
operator|->
name|external_dnr_size
argument_list|)
expr_stmt|;
name|ADD
argument_list|(
name|ipdMax
argument_list|,
name|swap
operator|->
name|external_pdr_size
argument_list|)
expr_stmt|;
name|ADD
argument_list|(
name|isymMax
argument_list|,
name|swap
operator|->
name|external_sym_size
argument_list|)
expr_stmt|;
name|ADD
argument_list|(
name|ioptMax
argument_list|,
name|swap
operator|->
name|external_opt_size
argument_list|)
expr_stmt|;
name|ADD
argument_list|(
name|iauxMax
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|aux_ext
argument_list|)
argument_list|)
expr_stmt|;
name|ADD
argument_list|(
name|issMax
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|ADD
argument_list|(
name|issExtMax
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|ADD
argument_list|(
name|ifdMax
argument_list|,
name|swap
operator|->
name|external_fdr_size
argument_list|)
expr_stmt|;
name|ADD
argument_list|(
name|crfd
argument_list|,
name|swap
operator|->
name|external_rfd_size
argument_list|)
expr_stmt|;
name|ADD
argument_list|(
name|iextMax
argument_list|,
name|swap
operator|->
name|external_ext_size
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|ADD
return|return
name|tot
return|;
block|}
end_function

begin_comment
comment|/* Write out the ECOFF symbolic header, given the file position it is    going to be placed at.  This assumes that the counts are set    correctly.  */
end_comment

begin_function
specifier|static
name|boolean
name|ecoff_write_symhdr
parameter_list|(
name|abfd
parameter_list|,
name|debug
parameter_list|,
name|swap
parameter_list|,
name|where
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|ecoff_debug_info
modifier|*
name|debug
decl_stmt|;
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|swap
decl_stmt|;
name|file_ptr
name|where
decl_stmt|;
block|{
name|HDRR
modifier|*
specifier|const
name|symhdr
init|=
operator|&
name|debug
operator|->
name|symbolic_header
decl_stmt|;
name|char
modifier|*
name|buff
init|=
name|NULL
decl_stmt|;
name|ecoff_align_debug
argument_list|(
name|abfd
argument_list|,
name|debug
argument_list|,
name|swap
argument_list|)
expr_stmt|;
comment|/* Go to the right location in the file.  */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|where
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
name|where
operator|+=
name|swap
operator|->
name|external_hdr_size
expr_stmt|;
name|symhdr
operator|->
name|magic
operator|=
name|swap
operator|->
name|sym_magic
expr_stmt|;
comment|/* Fill in the file offsets.  */
define|#
directive|define
name|SET
parameter_list|(
name|offset
parameter_list|,
name|count
parameter_list|,
name|size
parameter_list|)
define|\
value|if (symhdr->count == 0) \     symhdr->offset = 0; \   else \     { \       symhdr->offset = where; \       where += symhdr->count * size; \     }
name|SET
argument_list|(
name|cbLineOffset
argument_list|,
name|cbLine
argument_list|,
expr|sizeof
operator|(
name|unsigned
name|char
operator|)
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|cbDnOffset
argument_list|,
name|idnMax
argument_list|,
name|swap
operator|->
name|external_dnr_size
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|cbPdOffset
argument_list|,
name|ipdMax
argument_list|,
name|swap
operator|->
name|external_pdr_size
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|cbSymOffset
argument_list|,
name|isymMax
argument_list|,
name|swap
operator|->
name|external_sym_size
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|cbOptOffset
argument_list|,
name|ioptMax
argument_list|,
name|swap
operator|->
name|external_opt_size
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|cbAuxOffset
argument_list|,
name|iauxMax
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|aux_ext
argument_list|)
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|cbSsOffset
argument_list|,
name|issMax
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|cbSsExtOffset
argument_list|,
name|issExtMax
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|cbFdOffset
argument_list|,
name|ifdMax
argument_list|,
name|swap
operator|->
name|external_fdr_size
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|cbRfdOffset
argument_list|,
name|crfd
argument_list|,
name|swap
operator|->
name|external_rfd_size
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|cbExtOffset
argument_list|,
name|iextMax
argument_list|,
name|swap
operator|->
name|external_ext_size
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|SET
name|buff
operator|=
operator|(
name|PTR
operator|)
name|malloc
argument_list|(
name|swap
operator|->
name|external_hdr_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|buff
operator|==
name|NULL
operator|&&
name|swap
operator|->
name|external_hdr_size
operator|!=
literal|0
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
call|(
modifier|*
name|swap
operator|->
name|swap_hdr_out
call|)
argument_list|(
name|abfd
argument_list|,
name|symhdr
argument_list|,
name|buff
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
name|buff
argument_list|,
literal|1
argument_list|,
name|swap
operator|->
name|external_hdr_size
argument_list|,
name|abfd
argument_list|)
operator|!=
name|swap
operator|->
name|external_hdr_size
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|buff
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|buff
argument_list|)
expr_stmt|;
return|return
name|true
return|;
name|error_return
label|:
if|if
condition|(
name|buff
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|buff
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Write out the ECOFF debugging information.  This function assumes    that the information (the pointers and counts) in *DEBUG have been    set correctly.  WHERE is the position in the file to write the    information to.  This function fills in the file offsets in the    symbolic header.  */
end_comment

begin_function
name|boolean
name|bfd_ecoff_write_debug
parameter_list|(
name|abfd
parameter_list|,
name|debug
parameter_list|,
name|swap
parameter_list|,
name|where
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|ecoff_debug_info
modifier|*
name|debug
decl_stmt|;
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|swap
decl_stmt|;
name|file_ptr
name|where
decl_stmt|;
block|{
name|HDRR
modifier|*
specifier|const
name|symhdr
init|=
operator|&
name|debug
operator|->
name|symbolic_header
decl_stmt|;
if|if
condition|(
operator|!
name|ecoff_write_symhdr
argument_list|(
name|abfd
argument_list|,
name|debug
argument_list|,
name|swap
argument_list|,
name|where
argument_list|)
condition|)
return|return
name|false
return|;
define|#
directive|define
name|WRITE
parameter_list|(
name|ptr
parameter_list|,
name|count
parameter_list|,
name|size
parameter_list|,
name|offset
parameter_list|)
define|\
value|BFD_ASSERT (symhdr->offset == 0 || bfd_tell (abfd) == symhdr->offset); \   if (bfd_write ((PTR) debug->ptr, size, symhdr->count, abfd) \       != size * symhdr->count) \     return false;
name|WRITE
argument_list|(
name|line
argument_list|,
name|cbLine
argument_list|,
expr|sizeof
operator|(
name|unsigned
name|char
operator|)
argument_list|,
name|cbLineOffset
argument_list|)
expr_stmt|;
name|WRITE
argument_list|(
name|external_dnr
argument_list|,
name|idnMax
argument_list|,
name|swap
operator|->
name|external_dnr_size
argument_list|,
name|cbDnOffset
argument_list|)
expr_stmt|;
name|WRITE
argument_list|(
name|external_pdr
argument_list|,
name|ipdMax
argument_list|,
name|swap
operator|->
name|external_pdr_size
argument_list|,
name|cbPdOffset
argument_list|)
expr_stmt|;
name|WRITE
argument_list|(
name|external_sym
argument_list|,
name|isymMax
argument_list|,
name|swap
operator|->
name|external_sym_size
argument_list|,
name|cbSymOffset
argument_list|)
expr_stmt|;
name|WRITE
argument_list|(
name|external_opt
argument_list|,
name|ioptMax
argument_list|,
name|swap
operator|->
name|external_opt_size
argument_list|,
name|cbOptOffset
argument_list|)
expr_stmt|;
name|WRITE
argument_list|(
name|external_aux
argument_list|,
name|iauxMax
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|aux_ext
argument_list|)
argument_list|,
name|cbAuxOffset
argument_list|)
expr_stmt|;
name|WRITE
argument_list|(
name|ss
argument_list|,
name|issMax
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|cbSsOffset
argument_list|)
expr_stmt|;
name|WRITE
argument_list|(
name|ssext
argument_list|,
name|issExtMax
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|cbSsExtOffset
argument_list|)
expr_stmt|;
name|WRITE
argument_list|(
name|external_fdr
argument_list|,
name|ifdMax
argument_list|,
name|swap
operator|->
name|external_fdr_size
argument_list|,
name|cbFdOffset
argument_list|)
expr_stmt|;
name|WRITE
argument_list|(
name|external_rfd
argument_list|,
name|crfd
argument_list|,
name|swap
operator|->
name|external_rfd_size
argument_list|,
name|cbRfdOffset
argument_list|)
expr_stmt|;
name|WRITE
argument_list|(
name|external_ext
argument_list|,
name|iextMax
argument_list|,
name|swap
operator|->
name|external_ext_size
argument_list|,
name|cbExtOffset
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|WRITE
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Write out a shuffle list.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|ecoff_write_shuffle
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
expr|struct
name|ecoff_debug_swap
operator|*
operator|,
expr|struct
name|shuffle
operator|*
operator|,
name|PTR
name|space
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|boolean
name|ecoff_write_shuffle
parameter_list|(
name|abfd
parameter_list|,
name|swap
parameter_list|,
name|shuffle
parameter_list|,
name|space
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|swap
decl_stmt|;
name|struct
name|shuffle
modifier|*
name|shuffle
decl_stmt|;
name|PTR
name|space
decl_stmt|;
block|{
specifier|register
name|struct
name|shuffle
modifier|*
name|l
decl_stmt|;
name|unsigned
name|long
name|total
decl_stmt|;
name|total
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|l
operator|=
name|shuffle
init|;
name|l
operator|!=
operator|(
expr|struct
name|shuffle
operator|*
operator|)
name|NULL
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|l
operator|->
name|filep
condition|)
block|{
if|if
condition|(
name|bfd_write
argument_list|(
name|l
operator|->
name|u
operator|.
name|memory
argument_list|,
literal|1
argument_list|,
name|l
operator|->
name|size
argument_list|,
name|abfd
argument_list|)
operator|!=
name|l
operator|->
name|size
condition|)
return|return
name|false
return|;
block|}
else|else
block|{
if|if
condition|(
name|bfd_seek
argument_list|(
name|l
operator|->
name|u
operator|.
name|file
operator|.
name|input_bfd
argument_list|,
name|l
operator|->
name|u
operator|.
name|file
operator|.
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_read
argument_list|(
name|space
argument_list|,
literal|1
argument_list|,
name|l
operator|->
name|size
argument_list|,
name|l
operator|->
name|u
operator|.
name|file
operator|.
name|input_bfd
argument_list|)
operator|!=
name|l
operator|->
name|size
operator|||
name|bfd_write
argument_list|(
name|space
argument_list|,
literal|1
argument_list|,
name|l
operator|->
name|size
argument_list|,
name|abfd
argument_list|)
operator|!=
name|l
operator|->
name|size
condition|)
return|return
name|false
return|;
block|}
name|total
operator|+=
name|l
operator|->
name|size
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|total
operator|&
operator|(
name|swap
operator|->
name|debug_align
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
name|bfd_byte
modifier|*
name|s
decl_stmt|;
name|i
operator|=
name|swap
operator|->
name|debug_align
operator|-
operator|(
name|total
operator|&
operator|(
name|swap
operator|->
name|debug_align
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|s
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|malloc
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|&&
name|i
operator|!=
literal|0
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|memset
argument_list|(
operator|(
name|PTR
operator|)
name|s
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|s
argument_list|,
literal|1
argument_list|,
name|i
argument_list|,
name|abfd
argument_list|)
operator|!=
name|i
condition|)
block|{
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Write out debugging information using accumulated linker    information.  */
end_comment

begin_function
name|boolean
name|bfd_ecoff_write_accumulated_debug
parameter_list|(
name|handle
parameter_list|,
name|abfd
parameter_list|,
name|debug
parameter_list|,
name|swap
parameter_list|,
name|info
parameter_list|,
name|where
parameter_list|)
name|PTR
name|handle
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|ecoff_debug_info
modifier|*
name|debug
decl_stmt|;
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|swap
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|file_ptr
name|where
decl_stmt|;
block|{
name|struct
name|accumulate
modifier|*
name|ainfo
init|=
operator|(
expr|struct
name|accumulate
operator|*
operator|)
name|handle
decl_stmt|;
name|PTR
name|space
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|ecoff_write_symhdr
argument_list|(
name|abfd
argument_list|,
name|debug
argument_list|,
name|swap
argument_list|,
name|where
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
name|space
operator|=
operator|(
name|PTR
operator|)
name|malloc
argument_list|(
name|ainfo
operator|->
name|largest_file_shuffle
argument_list|)
expr_stmt|;
if|if
condition|(
name|space
operator|==
name|NULL
operator|&&
name|ainfo
operator|->
name|largest_file_shuffle
operator|!=
literal|0
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
if|if
condition|(
operator|!
name|ecoff_write_shuffle
argument_list|(
name|abfd
argument_list|,
name|swap
argument_list|,
name|ainfo
operator|->
name|line
argument_list|,
name|space
argument_list|)
operator|||
operator|!
name|ecoff_write_shuffle
argument_list|(
name|abfd
argument_list|,
name|swap
argument_list|,
name|ainfo
operator|->
name|pdr
argument_list|,
name|space
argument_list|)
operator|||
operator|!
name|ecoff_write_shuffle
argument_list|(
name|abfd
argument_list|,
name|swap
argument_list|,
name|ainfo
operator|->
name|sym
argument_list|,
name|space
argument_list|)
operator|||
operator|!
name|ecoff_write_shuffle
argument_list|(
name|abfd
argument_list|,
name|swap
argument_list|,
name|ainfo
operator|->
name|opt
argument_list|,
name|space
argument_list|)
operator|||
operator|!
name|ecoff_write_shuffle
argument_list|(
name|abfd
argument_list|,
name|swap
argument_list|,
name|ainfo
operator|->
name|aux
argument_list|,
name|space
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* The string table is written out from the hash table if this is a      final link.  */
if|if
condition|(
name|info
operator|->
name|relocateable
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|ainfo
operator|->
name|ss_hash
operator|==
operator|(
expr|struct
name|string_hash_entry
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ecoff_write_shuffle
argument_list|(
name|abfd
argument_list|,
name|swap
argument_list|,
name|ainfo
operator|->
name|ss
argument_list|,
name|space
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
else|else
block|{
name|unsigned
name|long
name|total
decl_stmt|;
name|bfd_byte
name|null
decl_stmt|;
name|struct
name|string_hash_entry
modifier|*
name|sh
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|ainfo
operator|->
name|ss
operator|==
operator|(
expr|struct
name|shuffle
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|null
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|null
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|1
condition|)
goto|goto
name|error_return
goto|;
name|total
operator|=
literal|1
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|ainfo
operator|->
name|ss_hash
operator|==
name|NULL
operator|||
name|ainfo
operator|->
name|ss_hash
operator|->
name|val
operator|==
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|sh
operator|=
name|ainfo
operator|->
name|ss_hash
init|;
name|sh
operator|!=
operator|(
expr|struct
name|string_hash_entry
operator|*
operator|)
name|NULL
condition|;
name|sh
operator|=
name|sh
operator|->
name|next
control|)
block|{
name|size_t
name|len
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|sh
operator|->
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|sh
operator|->
name|root
operator|.
name|string
argument_list|,
literal|1
argument_list|,
name|len
operator|+
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
name|len
operator|+
literal|1
condition|)
goto|goto
name|error_return
goto|;
name|total
operator|+=
name|len
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|total
operator|&
operator|(
name|swap
operator|->
name|debug_align
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
name|bfd_byte
modifier|*
name|s
decl_stmt|;
name|i
operator|=
name|swap
operator|->
name|debug_align
operator|-
operator|(
name|total
operator|&
operator|(
name|swap
operator|->
name|debug_align
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|s
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|malloc
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|&&
name|i
operator|!=
literal|0
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
name|memset
argument_list|(
operator|(
name|PTR
operator|)
name|s
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|s
argument_list|,
literal|1
argument_list|,
name|i
argument_list|,
name|abfd
argument_list|)
operator|!=
name|i
condition|)
block|{
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* The external strings and symbol are not converted over to using      shuffles.  FIXME: They probably should be.  */
if|if
condition|(
name|bfd_write
argument_list|(
name|debug
operator|->
name|ssext
argument_list|,
literal|1
argument_list|,
name|debug
operator|->
name|symbolic_header
operator|.
name|issExtMax
argument_list|,
name|abfd
argument_list|)
operator|!=
name|debug
operator|->
name|symbolic_header
operator|.
name|issExtMax
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
operator|(
name|debug
operator|->
name|symbolic_header
operator|.
name|issExtMax
operator|&
operator|(
name|swap
operator|->
name|debug_align
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
name|bfd_byte
modifier|*
name|s
decl_stmt|;
name|i
operator|=
operator|(
name|swap
operator|->
name|debug_align
operator|-
operator|(
name|debug
operator|->
name|symbolic_header
operator|.
name|issExtMax
operator|&
operator|(
name|swap
operator|->
name|debug_align
operator|-
literal|1
operator|)
operator|)
operator|)
expr_stmt|;
name|s
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|malloc
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|&&
name|i
operator|!=
literal|0
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
name|memset
argument_list|(
operator|(
name|PTR
operator|)
name|s
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|s
argument_list|,
literal|1
argument_list|,
name|i
argument_list|,
name|abfd
argument_list|)
operator|!=
name|i
condition|)
block|{
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ecoff_write_shuffle
argument_list|(
name|abfd
argument_list|,
name|swap
argument_list|,
name|ainfo
operator|->
name|fdr
argument_list|,
name|space
argument_list|)
operator|||
operator|!
name|ecoff_write_shuffle
argument_list|(
name|abfd
argument_list|,
name|swap
argument_list|,
name|ainfo
operator|->
name|rfd
argument_list|,
name|space
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
name|BFD_ASSERT
argument_list|(
name|debug
operator|->
name|symbolic_header
operator|.
name|cbExtOffset
operator|==
literal|0
operator|||
name|debug
operator|->
name|symbolic_header
operator|.
name|cbExtOffset
operator|==
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
name|debug
operator|->
name|external_ext
argument_list|,
name|swap
operator|->
name|external_ext_size
argument_list|,
name|debug
operator|->
name|symbolic_header
operator|.
name|iextMax
argument_list|,
name|abfd
argument_list|)
operator|!=
name|debug
operator|->
name|symbolic_header
operator|.
name|iextMax
operator|*
name|swap
operator|->
name|external_ext_size
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|space
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|space
argument_list|)
expr_stmt|;
return|return
name|true
return|;
name|error_return
label|:
if|if
condition|(
name|space
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|space
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

end_unit

