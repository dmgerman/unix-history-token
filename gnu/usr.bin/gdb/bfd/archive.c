begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BFD back-end for archive files (libraries).    Copyright 1990, 1991, 1992, 1993 Free Software Foundation, Inc.    Written by Cygnus Support.  Mostly Gumby Henkel-Wallace's fault.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* @setfilename archive-info SECTION 	Archives  DESCRIPTION 	Archives are supported in BFD in<<archive.c>>.  	An archive (or library) is just another BFD.  It has a symbol 	table, although there's not much a user program will do with it.  	The big difference between an archive BFD and an ordinary BFD 	is that the archive doesn't have sections.  Instead it has a 	chain of BFDs considered its contents.  These BFDs can be 	manipulated just like any other.  The BFDs contained in an 	archive opened for reading will all be opened for reading; you 	may put either input or output BFDs into an archive opened for 	output; it will be handled correctly when the archive is closed.  	Use<<bfd_openr_next_archived_file>> to step through all 	the contents of an archive opened for input.  It's not 	required that you read the entire archive if you don't want 	to!  Read it until you find what you want.  	Archive contents of output BFDs are chained through the<<next>> pointer in a BFD.  The first one is findable through 	the<<archive_head>> slot of the archive.  Set it with<<set_archive_head>> (q.v.).  A given BFD may be in only one 	open output archive at a time.  	As expected, the BFD archive code is more general than the 	archive code of any given environment.  BFD archives may 	contain files of different formats (e.g., a.out and coff) and 	even different architectures.  You may even place archives 	recursively into archives!  	This can cause unexpected confusion, since some archive 	formats are more expressive than others.  For instance, Intel 	COFF archives can preserve long filenames; Sun a.out archives 	cannot.  If you move a file from the first to the second 	format and back again, the filename may be truncated. 	Likewise, different a.out environments have different 	conventions as to how they truncate filenames, whether they 	preserve directory names in filenames, etc.  When 	interoperating with native tools, be sure your files are 	homogeneous.  	Beware: most of these formats do not react well to the 	presence of spaces in filenames.  We do the best we can, but 	can't always handle this due to restrctions in the format of 	archives.  Many unix utilities are braindead in regards to 	spaces and such in filenames anyway, so this shouldn't be much 	of a restriction. */
end_comment

begin_comment
comment|/* Assumes:    o - all archive elements start on an even boundary, newline padded;    o - all arch headers are char *;    o - all arch headers are the same size (across architectures). */
end_comment

begin_comment
comment|/* Some formats provide a way to cram a long filename into the short    (16 chars) space provided by a bsd archive.  The trick is: make a    special "file" in the front of the archive, sort of like the SYMDEF    entry.  If the filename is too long to fit, put it in the extended    name table, and use its index as the filename.  To prevent    confusion prepend the index with a space.  This means you can't    have filenames that start with a space, but then again, many unix    utilities can't handle that anyway.     This scheme unfortunately requires that you stand on your head in    order to write an archive since you need to put a magic file at the    front, and need to touch every entry to do so.  C'est la vie.     We support two variants of this idea:    The SVR4 format (extended name table is named "//"),    and an extended pseudo-BSD variant (extended name table is named    "ARFILENAMES/").  The origin of the latter format is uncertain.     BSD 4.4 uses a third scheme:  It writes a long filename    directly after the header.  This allows 'ar q' to work.    We current can read BSD 4.4 archives, but not write them. */
end_comment

begin_comment
comment|/* Summary of archive member names:   Symbol table (must be first):  "__.SYMDEF       " - Symbol table, Berkeley style, produced by ranlib.  "/               " - Symbol table, system 5 style.   Long name table (must be before regular file members):  "//              " - Long name table, System 5 R4 style.  "ARFILENAMES/    " - Long name table, non-standard extended BSD (not BSD 4.4).   Regular file members with short names:  "filename.o/     " - Regular file, System 5 style (embedded spaces ok).  "filename.o      " - Regular file, Berkeley style (no embedded spaces).   Regular files with long names (or embedded spaces, for BSD variants):  "/18             " - SVR4 style, name at offset 18 in name table.  "#1/23           " - Long name (or embedded paces) 23 characters long, 		      BSD 4.4 style, full name follows header. 		      Implemented for reading, not writing.  " 18             " - Long name 18 characters long, extended pseudo-BSD.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"aout/ar.h"
end_include

begin_include
include|#
directive|include
file|"aout/ranlib.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|/* For memchr, strrchr and friends */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|errno
end_ifndef

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|GNU960
end_ifdef

begin_define
define|#
directive|define
name|BFD_GNU960_ARMAG
parameter_list|(
name|abfd
parameter_list|)
value|(BFD_COFF_FILE_P((abfd)) ? ARMAG : ARMAGB)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Can't define this in hosts/*.h, because (e.g. in gprof) the hosts file    is included, then obstack.h, which thinks if offsetof is defined, it    doesn't need to include stddef.h.  */
end_comment

begin_comment
comment|/* Define offsetof for those systems which lack it */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|offsetof
argument_list|)
end_if

begin_define
define|#
directive|define
name|offsetof
parameter_list|(
name|TYPE
parameter_list|,
name|MEMBER
parameter_list|)
value|((unsigned long)&((TYPE *)0)->MEMBER)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* We keep a cache of archive filepointers to archive elements to    speed up searching the archive by filepos.  We only add an entry to    the cache when we actually read one.  We also don't sort the cache;    it's generally short enough to search linearly.    Note that the pointers here point to the front of the ar_hdr, not    to the front of the contents! */
end_comment

begin_struct
struct|struct
name|ar_cache
block|{
name|file_ptr
name|ptr
decl_stmt|;
name|bfd
modifier|*
name|arelt
decl_stmt|;
name|struct
name|ar_cache
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|ar_padchar
parameter_list|(
name|abfd
parameter_list|)
value|((abfd)->xvec->ar_pad_char)
end_define

begin_define
define|#
directive|define
name|ar_maxnamelen
parameter_list|(
name|abfd
parameter_list|)
value|((abfd)->xvec->ar_max_namelen)
end_define

begin_define
define|#
directive|define
name|arch_eltdata
parameter_list|(
name|bfd
parameter_list|)
value|((struct areltdata *)((bfd)->arelt_data))
end_define

begin_define
define|#
directive|define
name|arch_hdr
parameter_list|(
name|bfd
parameter_list|)
value|((struct ar_hdr *)arch_eltdata(bfd)->arch_header)
end_define

begin_comment
comment|/* Forward declarations of functions */
end_comment

begin_decl_stmt
name|boolean
name|compute_and_write_armap
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|arch
operator|,
name|unsigned
name|int
name|elength
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|bsd_update_armap_timestamp
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|arch
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
name|boolean
name|_bfd_generic_mkarchive
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|abfd
operator|->
name|tdata
operator|.
name|aout_ar_data
operator|=
operator|(
expr|struct
name|artdata
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|artdata
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
name|false
return|;
block|}
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|cache
operator|=
literal|0
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* FUNCTION 	bfd_get_next_mapent  SYNOPSIS 	symindex bfd_get_next_mapent(bfd *, symindex previous, carsym ** sym);  DESCRIPTION 	This function steps through an archive's symbol table (if it 	has one).  Successively updates<<sym>> with the next symbol's 	information, returning that symbol's (internal) index into the 	symbol table.  	Supply BFD_NO_MORE_SYMBOLS as the<<previous>> entry to get 	the first one; returns BFD_NO_MORE_SYMBOLS when you're already 	got the last one.  	A<<carsym>> is a canonical archive symbol.  The only 	user-visible element is its name, a null-terminated string. */
end_comment

begin_decl_stmt
name|symindex
name|DEFUN
argument_list|(
name|bfd_get_next_mapent
argument_list|,
operator|(
name|abfd
operator|,
name|prev
operator|,
name|entry
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|symindex
name|prev
name|AND
name|carsym
operator|*
operator|*
name|entry
argument_list|)
block|{
if|if
condition|(
operator|!
name|bfd_has_map
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
name|bfd_error
operator|=
name|invalid_operation
expr_stmt|;
return|return
name|BFD_NO_MORE_SYMBOLS
return|;
block|}
if|if
condition|(
name|prev
operator|==
name|BFD_NO_MORE_SYMBOLS
condition|)
name|prev
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|++
name|prev
operator|>=
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symdef_count
condition|)
return|return
name|BFD_NO_MORE_SYMBOLS
return|;
operator|*
name|entry
operator|=
operator|(
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symdefs
operator|+
name|prev
operator|)
expr_stmt|;
return|return
name|prev
return|;
block|}
end_decl_stmt

begin_comment
comment|/* To be called by backends only */
end_comment

begin_function
name|bfd
modifier|*
name|_bfd_create_empty_archive_element_shell
parameter_list|(
name|obfd
parameter_list|)
name|bfd
modifier|*
name|obfd
decl_stmt|;
block|{
name|bfd
modifier|*
name|nbfd
decl_stmt|;
name|nbfd
operator|=
name|new_bfd_contained_in
argument_list|(
name|obfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbfd
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|nbfd
return|;
block|}
end_function

begin_comment
comment|/* FUNCTION 	bfd_set_archive_head  SYNOPSIS 	boolean bfd_set_archive_head(bfd *output, bfd *new_head);  DESCRIPTION 	Used whilst processing archives. Sets the head of the chain of 	BFDs contained in an archive to @var{new_head}.  */
end_comment

begin_decl_stmt
name|boolean
name|DEFUN
argument_list|(
name|bfd_set_archive_head
argument_list|,
operator|(
name|output_archive
operator|,
name|new_head
operator|)
argument_list|,
name|bfd
operator|*
name|output_archive
name|AND
name|bfd
operator|*
name|new_head
argument_list|)
block|{
name|output_archive
operator|->
name|archive_head
operator|=
name|new_head
expr_stmt|;
return|return
name|true
return|;
block|}
end_decl_stmt

begin_function
name|bfd
modifier|*
name|look_for_bfd_in_cache
parameter_list|(
name|arch_bfd
parameter_list|,
name|filepos
parameter_list|)
name|bfd
modifier|*
name|arch_bfd
decl_stmt|;
name|file_ptr
name|filepos
decl_stmt|;
block|{
name|struct
name|ar_cache
modifier|*
name|current
decl_stmt|;
for|for
control|(
name|current
operator|=
name|bfd_ardata
argument_list|(
name|arch_bfd
argument_list|)
operator|->
name|cache
init|;
name|current
operator|!=
name|NULL
condition|;
name|current
operator|=
name|current
operator|->
name|next
control|)
if|if
condition|(
name|current
operator|->
name|ptr
operator|==
name|filepos
condition|)
return|return
name|current
operator|->
name|arelt
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Kind of stupid to call cons for each one, but we don't do too many */
end_comment

begin_function
name|boolean
name|add_bfd_to_cache
parameter_list|(
name|arch_bfd
parameter_list|,
name|filepos
parameter_list|,
name|new_elt
parameter_list|)
name|bfd
modifier|*
name|arch_bfd
decl_stmt|,
decl|*
name|new_elt
decl_stmt|;
end_function

begin_decl_stmt
name|file_ptr
name|filepos
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|ar_cache
modifier|*
name|new_cache
init|=
operator|(
expr|struct
name|ar_cache
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|arch_bfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ar_cache
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|new_cache
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
name|false
return|;
block|}
name|new_cache
operator|->
name|ptr
operator|=
name|filepos
expr_stmt|;
name|new_cache
operator|->
name|arelt
operator|=
name|new_elt
expr_stmt|;
name|new_cache
operator|->
name|next
operator|=
operator|(
expr|struct
name|ar_cache
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
name|bfd_ardata
argument_list|(
name|arch_bfd
argument_list|)
operator|->
name|cache
operator|==
name|NULL
condition|)
name|bfd_ardata
argument_list|(
name|arch_bfd
argument_list|)
operator|->
name|cache
operator|=
name|new_cache
expr_stmt|;
else|else
block|{
name|struct
name|ar_cache
modifier|*
name|current
init|=
name|bfd_ardata
argument_list|(
name|arch_bfd
argument_list|)
operator|->
name|cache
decl_stmt|;
for|for
control|(
init|;
name|current
operator|->
name|next
operator|!=
name|NULL
condition|;
name|current
operator|=
name|current
operator|->
name|next
control|)
empty_stmt|;
name|current
operator|->
name|next
operator|=
name|new_cache
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* The name begins with space.  Hence the rest of the name is an index into    the string table. */
end_comment

begin_function
name|char
modifier|*
name|get_extended_arelt_filename
parameter_list|(
name|arch
parameter_list|,
name|name
parameter_list|)
name|bfd
modifier|*
name|arch
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|unsigned
name|long
name|index
init|=
literal|0
decl_stmt|;
comment|/* Should extract string so that I can guarantee not to overflow into      the next region, but I'm too lazy. */
name|errno
operator|=
literal|0
expr_stmt|;
comment|/* Skip first char, which is '/' in SVR4 or ' ' in some other variants. */
name|index
operator|=
name|strtol
argument_list|(
name|name
operator|+
literal|1
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
block|{
name|bfd_error
operator|=
name|malformed_archive
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|bfd_ardata
argument_list|(
name|arch
argument_list|)
operator|->
name|extended_names
operator|+
name|index
return|;
block|}
end_function

begin_comment
comment|/* This functions reads an arch header and returns an areltdata pointer, or    NULL on error.     Presumes the file pointer is already in the right place (ie pointing    to the ar_hdr in the file).   Moves the file pointer; on success it    should be pointing to the front of the file contents; on failure it    could have been moved arbitrarily. */
end_comment

begin_function
name|struct
name|areltdata
modifier|*
name|snarf_ar_hdr
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|errno
specifier|extern
name|int
name|errno
decl_stmt|;
endif|#
directive|endif
name|struct
name|ar_hdr
name|hdr
decl_stmt|;
name|char
modifier|*
name|hdrp
init|=
operator|(
name|char
operator|*
operator|)
operator|&
name|hdr
decl_stmt|;
name|unsigned
name|int
name|parsed_size
decl_stmt|;
name|struct
name|areltdata
modifier|*
name|ared
decl_stmt|;
name|char
modifier|*
name|filename
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|namelen
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|allocsize
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|areltdata
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
decl_stmt|;
name|char
modifier|*
name|allocptr
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|hdrp
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
condition|)
block|{
name|bfd_error
operator|=
name|no_more_archived_files
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
operator|(
name|hdr
operator|.
name|ar_fmag
operator|)
argument_list|,
name|ARFMAG
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|bfd_error
operator|=
name|malformed_archive
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|errno
operator|=
literal|0
expr_stmt|;
name|parsed_size
operator|=
name|strtol
argument_list|(
name|hdr
operator|.
name|ar_size
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
block|{
name|bfd_error
operator|=
name|malformed_archive
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* extract the filename from the archive - there are two ways to        specify an extendend name table, either the first char of the        name is a space, or it's a slash.  */
if|if
condition|(
operator|(
name|hdr
operator|.
name|ar_name
index|[
literal|0
index|]
operator|==
literal|'/'
operator|||
operator|(
name|hdr
operator|.
name|ar_name
index|[
literal|0
index|]
operator|==
literal|' '
operator|&&
name|memchr
argument_list|(
name|hdr
operator|.
name|ar_name
argument_list|,
literal|'/'
argument_list|,
name|ar_maxnamelen
argument_list|(
name|abfd
argument_list|)
argument_list|)
operator|==
name|NULL
operator|)
operator|)
operator|&&
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|extended_names
operator|!=
name|NULL
condition|)
block|{
name|filename
operator|=
name|get_extended_arelt_filename
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|.
name|ar_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|filename
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|malformed_archive
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
comment|/* BSD4.4-style long filename.        Only implemented for reading, so far! */
elseif|else
if|if
condition|(
name|hdr
operator|.
name|ar_name
index|[
literal|0
index|]
operator|==
literal|'#'
operator|&&
name|hdr
operator|.
name|ar_name
index|[
literal|1
index|]
operator|==
literal|'1'
operator|&&
name|hdr
operator|.
name|ar_name
index|[
literal|2
index|]
operator|==
literal|'/'
operator|&&
name|isdigit
argument_list|(
name|hdr
operator|.
name|ar_name
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
comment|/* BSD-4.4 extended name */
name|namelen
operator|=
name|atoi
argument_list|(
operator|&
name|hdr
operator|.
name|ar_name
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|allocsize
operator|+=
name|namelen
operator|+
literal|1
expr_stmt|;
name|parsed_size
operator|-=
name|namelen
expr_stmt|;
name|allocptr
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|allocsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|allocptr
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|filename
operator|=
name|allocptr
operator|+
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|areltdata
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|bfd_read
argument_list|(
name|filename
argument_list|,
literal|1
argument_list|,
name|namelen
argument_list|,
name|abfd
argument_list|)
operator|!=
name|namelen
condition|)
block|{
name|bfd_error
operator|=
name|no_more_archived_files
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|filename
index|[
name|namelen
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
comment|/* We judge the end of the name by looking for '/' or ' '. 	       Note:  The SYSV format (terminated by '/') allows embedded 	       spaces, so only look for ' ' if we don't find '/'. */
name|namelen
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|hdr
operator|.
name|ar_name
index|[
name|namelen
index|]
operator|!=
literal|'\0'
operator|&&
name|hdr
operator|.
name|ar_name
index|[
name|namelen
index|]
operator|!=
literal|'/'
condition|)
block|{
name|namelen
operator|++
expr_stmt|;
if|if
condition|(
name|namelen
operator|==
operator|(
name|unsigned
operator|)
name|ar_maxnamelen
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
name|namelen
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|hdr
operator|.
name|ar_name
index|[
name|namelen
index|]
operator|!=
literal|' '
operator|&&
name|namelen
operator|<
operator|(
name|unsigned
operator|)
name|ar_maxnamelen
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
name|namelen
operator|++
expr_stmt|;
block|}
break|break;
block|}
block|}
name|allocsize
operator|+=
name|namelen
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|allocptr
condition|)
block|{
name|allocptr
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|allocsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|allocptr
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
name|ared
operator|=
operator|(
expr|struct
name|areltdata
operator|*
operator|)
name|allocptr
expr_stmt|;
name|ared
operator|->
name|arch_header
operator|=
name|allocptr
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|areltdata
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ared
operator|->
name|arch_header
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|ared
operator|->
name|parsed_size
operator|=
name|parsed_size
expr_stmt|;
if|if
condition|(
name|filename
operator|!=
name|NULL
condition|)
name|ared
operator|->
name|filename
operator|=
name|filename
expr_stmt|;
else|else
block|{
name|ared
operator|->
name|filename
operator|=
name|allocptr
operator|+
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|areltdata
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|namelen
condition|)
name|memcpy
argument_list|(
name|ared
operator|->
name|filename
argument_list|,
name|hdr
operator|.
name|ar_name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
name|ared
operator|->
name|filename
index|[
name|namelen
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
name|ared
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This is an internal function; it's mainly used when indexing    through the archive symbol table, but also used to get the next    element, since it handles the bookkeeping so nicely for us. */
end_comment

begin_function
name|bfd
modifier|*
name|get_elt_at_filepos
parameter_list|(
name|archive
parameter_list|,
name|filepos
parameter_list|)
name|bfd
modifier|*
name|archive
decl_stmt|;
name|file_ptr
name|filepos
decl_stmt|;
block|{
name|struct
name|areltdata
modifier|*
name|new_areldata
decl_stmt|;
name|bfd
modifier|*
name|n_nfd
decl_stmt|;
name|n_nfd
operator|=
name|look_for_bfd_in_cache
argument_list|(
name|archive
argument_list|,
name|filepos
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_nfd
condition|)
return|return
name|n_nfd
return|;
if|if
condition|(
literal|0
operator|>
name|bfd_seek
argument_list|(
name|archive
argument_list|,
name|filepos
argument_list|,
name|SEEK_SET
argument_list|)
condition|)
block|{
name|bfd_error
operator|=
name|system_call_error
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|(
name|new_areldata
operator|=
name|snarf_ar_hdr
argument_list|(
name|archive
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|n_nfd
operator|=
name|_bfd_create_empty_archive_element_shell
argument_list|(
name|archive
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_nfd
operator|==
name|NULL
condition|)
block|{
name|bfd_release
argument_list|(
name|archive
argument_list|,
operator|(
name|PTR
operator|)
name|new_areldata
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|n_nfd
operator|->
name|origin
operator|=
name|bfd_tell
argument_list|(
name|archive
argument_list|)
expr_stmt|;
name|n_nfd
operator|->
name|arelt_data
operator|=
operator|(
name|PTR
operator|)
name|new_areldata
expr_stmt|;
name|n_nfd
operator|->
name|filename
operator|=
name|new_areldata
operator|->
name|filename
expr_stmt|;
if|if
condition|(
name|add_bfd_to_cache
argument_list|(
name|archive
argument_list|,
name|filepos
argument_list|,
name|n_nfd
argument_list|)
condition|)
return|return
name|n_nfd
return|;
comment|/* huh? */
name|bfd_release
argument_list|(
name|archive
argument_list|,
operator|(
name|PTR
operator|)
name|n_nfd
argument_list|)
expr_stmt|;
name|bfd_release
argument_list|(
name|archive
argument_list|,
operator|(
name|PTR
operator|)
name|new_areldata
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* FUNCTION 	bfd_get_elt_at_index  SYNOPSIS 	bfd *bfd_get_elt_at_index(bfd * archive, int index);  DESCRIPTION 	Return the bfd which is referenced by the symbol indexed by<<index>>.<<index>> should have been returned by<<bfd_get_next_mapent>> (q.v.).  */
end_comment

begin_decl_stmt
name|bfd
modifier|*
name|DEFUN
argument_list|(
name|bfd_get_elt_at_index
argument_list|,
operator|(
name|abfd
operator|,
name|index
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|int
name|index
argument_list|)
block|{
name|bfd
modifier|*
name|result
init|=
name|get_elt_at_filepos
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symdefs
operator|+
name|index
operator|)
operator|->
name|file_offset
argument_list|)
decl_stmt|;
return|return
name|result
return|;
block|}
end_decl_stmt

begin_comment
comment|/* FUNCTION 	bfd_openr_next_archived_file  SYNOPSIS 	bfd* bfd_openr_next_archived_file(bfd *archive, bfd *previous);  DESCRIPTION 	Initially provided a BFD containing an archive and NULL, opens 	an inpout BFD on the first contained element and returns that. 	Subsequent calls to bfd_openr_next_archived_file should pass 	the archive and the previous return value to return a created 	BFD to the next contained element. NULL is returned when there 	are no more.  */
end_comment

begin_function
name|bfd
modifier|*
name|bfd_openr_next_archived_file
parameter_list|(
name|archive
parameter_list|,
name|last_file
parameter_list|)
name|bfd
modifier|*
name|archive
decl_stmt|;
name|bfd
modifier|*
name|last_file
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|bfd_get_format
argument_list|(
name|archive
argument_list|)
operator|!=
name|bfd_archive
operator|)
operator|||
operator|(
name|archive
operator|->
name|direction
operator|==
name|write_direction
operator|)
condition|)
block|{
name|bfd_error
operator|=
name|invalid_operation
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|BFD_SEND
argument_list|(
name|archive
argument_list|,
name|openr_next_archived_file
argument_list|,
operator|(
name|archive
operator|,
name|last_file
operator|)
argument_list|)
return|;
block|}
end_function

begin_function
name|bfd
modifier|*
name|bfd_generic_openr_next_archived_file
parameter_list|(
name|archive
parameter_list|,
name|last_file
parameter_list|)
name|bfd
modifier|*
name|archive
decl_stmt|;
name|bfd
modifier|*
name|last_file
decl_stmt|;
block|{
name|file_ptr
name|filestart
decl_stmt|;
if|if
condition|(
operator|!
name|last_file
condition|)
name|filestart
operator|=
name|bfd_ardata
argument_list|(
name|archive
argument_list|)
operator|->
name|first_file_filepos
expr_stmt|;
else|else
block|{
name|unsigned
name|int
name|size
init|=
name|arelt_size
argument_list|(
name|last_file
argument_list|)
decl_stmt|;
comment|/* Pad to an even boundary...         Note that last_file->origin can be odd in the case of        BSD-4.4-style element with a long odd size. */
name|filestart
operator|=
name|last_file
operator|->
name|origin
operator|+
name|size
expr_stmt|;
name|filestart
operator|+=
name|filestart
operator|%
literal|2
expr_stmt|;
block|}
return|return
name|get_elt_at_filepos
argument_list|(
name|archive
argument_list|,
name|filestart
argument_list|)
return|;
block|}
end_function

begin_function
name|bfd_target
modifier|*
name|bfd_generic_archive_p
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|char
name|armag
index|[
name|SARMAG
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|armag
argument_list|,
literal|1
argument_list|,
name|SARMAG
argument_list|,
name|abfd
argument_list|)
operator|!=
name|SARMAG
condition|)
block|{
name|bfd_error
operator|=
name|wrong_format
expr_stmt|;
return|return
literal|0
return|;
block|}
ifdef|#
directive|ifdef
name|GNU960
if|if
condition|(
name|strncmp
argument_list|(
name|armag
argument_list|,
name|BFD_GNU960_ARMAG
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|SARMAG
argument_list|)
condition|)
return|return
literal|0
return|;
else|#
directive|else
if|if
condition|(
name|strncmp
argument_list|(
name|armag
argument_list|,
name|ARMAG
argument_list|,
name|SARMAG
argument_list|)
operator|&&
name|strncmp
argument_list|(
name|armag
argument_list|,
name|ARMAGB
argument_list|,
name|SARMAG
argument_list|)
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* We are setting bfd_ardata(abfd) here, but since bfd_ardata      involves a cast, we can't do it as the left operand of assignment. */
name|abfd
operator|->
name|tdata
operator|.
name|aout_ar_data
operator|=
operator|(
expr|struct
name|artdata
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|artdata
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
literal|0
return|;
block|}
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|first_file_filepos
operator|=
name|SARMAG
expr_stmt|;
if|if
condition|(
operator|!
name|BFD_SEND
argument_list|(
name|abfd
argument_list|,
name|_bfd_slurp_armap
argument_list|,
operator|(
name|abfd
operator|)
argument_list|)
condition|)
block|{
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|aout_ar_data
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|BFD_SEND
argument_list|(
name|abfd
argument_list|,
name|_bfd_slurp_extended_name_table
argument_list|,
operator|(
name|abfd
operator|)
argument_list|)
condition|)
block|{
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|aout_ar_data
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|abfd
operator|->
name|xvec
return|;
block|}
end_function

begin_comment
comment|/* Returns false on error, true otherwise */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|DEFUN
argument_list|(
name|do_slurp_bsd_armap
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|struct
name|areltdata
modifier|*
name|mapdata
decl_stmt|;
name|unsigned
name|int
name|counter
init|=
literal|0
decl_stmt|;
name|int
modifier|*
name|raw_armap
decl_stmt|,
modifier|*
name|rbase
decl_stmt|;
name|struct
name|artdata
modifier|*
name|ardata
init|=
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|char
modifier|*
name|stringbase
decl_stmt|;
name|unsigned
name|int
name|parsed_size
decl_stmt|;
name|mapdata
operator|=
name|snarf_ar_hdr
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|mapdata
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|parsed_size
operator|=
name|mapdata
operator|->
name|parsed_size
expr_stmt|;
name|bfd_release
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|mapdata
argument_list|)
expr_stmt|;
comment|/* Don't need it any more. */
name|raw_armap
operator|=
operator|(
name|int
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|parsed_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|raw_armap
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|raw_armap
argument_list|,
literal|1
argument_list|,
name|parsed_size
argument_list|,
name|abfd
argument_list|)
operator|!=
name|parsed_size
condition|)
block|{
name|bfd_error
operator|=
name|malformed_archive
expr_stmt|;
name|byebye
label|:
name|bfd_release
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|raw_armap
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|ardata
operator|->
name|symdef_count
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|raw_armap
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|symdef
argument_list|)
expr_stmt|;
if|if
condition|(
name|ardata
operator|->
name|symdef_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|symdef
argument_list|)
operator|>
name|parsed_size
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|raw_armap
argument_list|)
condition|)
block|{
comment|/* Probably we're using the wrong byte ordering.  */
name|bfd_error
operator|=
name|wrong_format
expr_stmt|;
goto|goto
name|byebye
goto|;
block|}
name|ardata
operator|->
name|cache
operator|=
literal|0
expr_stmt|;
name|rbase
operator|=
name|raw_armap
operator|+
literal|1
expr_stmt|;
name|ardata
operator|->
name|symdefs
operator|=
operator|(
name|carsym
operator|*
operator|)
name|rbase
expr_stmt|;
name|stringbase
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
name|ardata
operator|->
name|symdefs
operator|+
name|ardata
operator|->
name|symdef_count
operator|)
operator|)
operator|+
literal|4
expr_stmt|;
for|for
control|(
init|;
name|counter
operator|<
name|ardata
operator|->
name|symdef_count
condition|;
name|counter
operator|++
control|)
block|{
name|struct
name|symdef
modifier|*
name|sym
init|=
operator|(
operator|(
expr|struct
name|symdef
operator|*
operator|)
name|rbase
operator|)
operator|+
name|counter
decl_stmt|;
name|sym
operator|->
name|s
operator|.
name|name
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
call|(
name|PTR
call|)
argument_list|(
operator|&
operator|(
name|sym
operator|->
name|s
operator|.
name|string_offset
operator|)
argument_list|)
argument_list|)
operator|+
name|stringbase
expr_stmt|;
name|sym
operator|->
name|file_offset
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
call|(
name|PTR
call|)
argument_list|(
operator|&
operator|(
name|sym
operator|->
name|file_offset
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ardata
operator|->
name|first_file_filepos
operator|=
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* Pad to an even boundary if you have to */
name|ardata
operator|->
name|first_file_filepos
operator|+=
operator|(
name|ardata
operator|->
name|first_file_filepos
operator|)
operator|%
literal|2
expr_stmt|;
comment|/* FIXME, we should provide some way to free raw_ardata when      we are done using the strings from it.  For now, it seems      to be allocated on an obstack anyway... */
name|bfd_has_map
argument_list|(
name|abfd
argument_list|)
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Returns false on error, true otherwise */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|DEFUN
argument_list|(
name|do_slurp_coff_armap
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|struct
name|areltdata
modifier|*
name|mapdata
decl_stmt|;
name|int
modifier|*
name|raw_armap
decl_stmt|,
modifier|*
name|rawptr
decl_stmt|;
name|struct
name|artdata
modifier|*
name|ardata
init|=
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|char
modifier|*
name|stringbase
decl_stmt|;
name|unsigned
name|int
name|stringsize
decl_stmt|;
name|unsigned
name|int
name|parsed_size
decl_stmt|;
name|carsym
modifier|*
name|carsyms
decl_stmt|;
name|unsigned
name|int
name|nsymz
decl_stmt|;
comment|/* Number of symbols in armap. */
name|bfd_vma
argument_list|(
argument|*swap
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd_byte
operator|*
operator|)
argument_list|)
expr_stmt|;
name|char
name|int_buf
index|[
sizeof|sizeof
argument_list|(
name|long
argument_list|)
index|]
decl_stmt|;
name|unsigned
name|int
name|carsym_size
decl_stmt|,
name|ptrsize
decl_stmt|,
name|i
decl_stmt|;
name|mapdata
operator|=
name|snarf_ar_hdr
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|mapdata
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|parsed_size
operator|=
name|mapdata
operator|->
name|parsed_size
expr_stmt|;
name|bfd_release
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|mapdata
argument_list|)
expr_stmt|;
comment|/* Don't need it any more. */
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|int_buf
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|4
condition|)
block|{
name|bfd_error
operator|=
name|malformed_archive
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* It seems that all numeric information in a coff archive is always      in big endian format, nomatter the host or target. */
name|swap
operator|=
name|bfd_getb32
expr_stmt|;
name|nsymz
operator|=
name|bfd_getb32
argument_list|(
operator|(
name|PTR
operator|)
name|int_buf
argument_list|)
expr_stmt|;
name|stringsize
operator|=
name|parsed_size
operator|-
operator|(
literal|4
operator|*
name|nsymz
operator|)
operator|-
literal|4
expr_stmt|;
if|#
directive|if
literal|1
comment|/* ... except that some archive formats are broken, and it may be our      fault - the i960 little endian coff sometimes has big and sometimes      little, because our tools changed.  Here's a horrible hack to clean      up the crap.  */
if|if
condition|(
name|stringsize
operator|>
literal|0xfffff
condition|)
block|{
comment|/* This looks dangerous, let's do it the other way around */
name|nsymz
operator|=
name|bfd_getl32
argument_list|(
operator|(
name|PTR
operator|)
name|int_buf
argument_list|)
expr_stmt|;
name|stringsize
operator|=
name|parsed_size
operator|-
operator|(
literal|4
operator|*
name|nsymz
operator|)
operator|-
literal|4
expr_stmt|;
name|swap
operator|=
name|bfd_getl32
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* The coff armap must be read sequentially.  So we construct a bsd-style      one in core all at once, for simplicity. */
name|carsym_size
operator|=
operator|(
name|nsymz
operator|*
sizeof|sizeof
argument_list|(
name|carsym
argument_list|)
operator|)
expr_stmt|;
name|ptrsize
operator|=
operator|(
literal|4
operator|*
name|nsymz
operator|)
expr_stmt|;
name|ardata
operator|->
name|symdefs
operator|=
operator|(
name|carsym
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|carsym_size
operator|+
name|stringsize
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ardata
operator|->
name|symdefs
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
name|false
return|;
block|}
name|carsyms
operator|=
name|ardata
operator|->
name|symdefs
expr_stmt|;
name|stringbase
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|ardata
operator|->
name|symdefs
operator|)
operator|+
name|carsym_size
expr_stmt|;
comment|/* Allocate and read in the raw offsets. */
name|raw_armap
operator|=
operator|(
name|int
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|ptrsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|raw_armap
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
goto|goto
name|release_symdefs
goto|;
block|}
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|raw_armap
argument_list|,
literal|1
argument_list|,
name|ptrsize
argument_list|,
name|abfd
argument_list|)
operator|!=
name|ptrsize
operator|||
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|stringbase
argument_list|,
literal|1
argument_list|,
name|stringsize
argument_list|,
name|abfd
argument_list|)
operator|!=
name|stringsize
condition|)
block|{
name|bfd_error
operator|=
name|malformed_archive
expr_stmt|;
goto|goto
name|release_raw_armap
goto|;
block|}
comment|/* OK, build the carsyms */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsymz
condition|;
name|i
operator|++
control|)
block|{
name|rawptr
operator|=
name|raw_armap
operator|+
name|i
expr_stmt|;
name|carsyms
operator|->
name|file_offset
operator|=
name|swap
argument_list|(
operator|(
name|PTR
operator|)
name|rawptr
argument_list|)
expr_stmt|;
name|carsyms
operator|->
name|name
operator|=
name|stringbase
expr_stmt|;
while|while
condition|(
operator|*
name|stringbase
operator|++
condition|)
empty_stmt|;
name|carsyms
operator|++
expr_stmt|;
block|}
operator|*
name|stringbase
operator|=
literal|0
expr_stmt|;
name|ardata
operator|->
name|symdef_count
operator|=
name|nsymz
expr_stmt|;
name|ardata
operator|->
name|first_file_filepos
operator|=
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* Pad to an even boundary if you have to */
name|ardata
operator|->
name|first_file_filepos
operator|+=
operator|(
name|ardata
operator|->
name|first_file_filepos
operator|)
operator|%
literal|2
expr_stmt|;
name|bfd_has_map
argument_list|(
name|abfd
argument_list|)
operator|=
name|true
expr_stmt|;
name|bfd_release
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|raw_armap
argument_list|)
expr_stmt|;
return|return
name|true
return|;
name|release_raw_armap
label|:
name|bfd_release
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|raw_armap
argument_list|)
expr_stmt|;
name|release_symdefs
label|:
name|bfd_release
argument_list|(
name|abfd
argument_list|,
call|(
name|PTR
call|)
argument_list|(
name|ardata
argument_list|)
operator|->
name|symdefs
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_decl_stmt

begin_comment
comment|/* This routine can handle either coff-style or bsd-style armaps.    Returns false on error, true otherwise */
end_comment

begin_function
name|boolean
name|bfd_slurp_armap
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|char
name|nextname
index|[
literal|17
index|]
decl_stmt|;
name|int
name|i
init|=
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|nextname
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|abfd
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return
name|true
return|;
if|if
condition|(
name|i
operator|!=
literal|16
condition|)
return|return
name|false
return|;
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
operator|-
literal|16
argument_list|,
name|SEEK_CUR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|nextname
argument_list|,
literal|"__.SYMDEF       "
argument_list|,
literal|16
argument_list|)
condition|)
return|return
name|do_slurp_bsd_armap
argument_list|(
name|abfd
argument_list|)
return|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|nextname
argument_list|,
literal|"/               "
argument_list|,
literal|16
argument_list|)
condition|)
return|return
name|do_slurp_coff_armap
argument_list|(
name|abfd
argument_list|)
return|;
name|bfd_has_map
argument_list|(
name|abfd
argument_list|)
operator|=
name|false
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Returns false on error, true otherwise */
end_comment

begin_comment
comment|/* flavor 2 of a bsd armap, similar to bfd_slurp_bsd_armap except the    header is in a slightly different order and the map name is '/'.     This flavour is used by hp300hpux. */
end_comment

begin_function
name|boolean
name|bfd_slurp_bsd_armap_f2
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|struct
name|areltdata
modifier|*
name|mapdata
decl_stmt|;
name|char
name|nextname
index|[
literal|17
index|]
decl_stmt|;
name|unsigned
name|int
name|counter
init|=
literal|0
decl_stmt|;
name|int
modifier|*
name|raw_armap
decl_stmt|,
modifier|*
name|rbase
decl_stmt|;
name|struct
name|artdata
modifier|*
name|ardata
init|=
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|char
modifier|*
name|stringbase
decl_stmt|;
name|unsigned
name|int
name|stringsize
decl_stmt|;
name|int
name|i
init|=
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|nextname
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|abfd
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return
name|true
return|;
if|if
condition|(
name|i
operator|!=
literal|16
condition|)
return|return
name|false
return|;
comment|/* The archive has at least 16 bytes in it */
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|-
literal|16L
argument_list|,
name|SEEK_CUR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|nextname
argument_list|,
literal|"__.SYMDEF       "
argument_list|,
literal|16
argument_list|)
condition|)
return|return
name|do_slurp_bsd_armap
argument_list|(
name|abfd
argument_list|)
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|nextname
argument_list|,
literal|"/               "
argument_list|,
literal|16
argument_list|)
condition|)
block|{
name|bfd_has_map
argument_list|(
name|abfd
argument_list|)
operator|=
name|false
expr_stmt|;
return|return
name|true
return|;
block|}
name|mapdata
operator|=
name|snarf_ar_hdr
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|mapdata
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|raw_armap
operator|=
operator|(
name|int
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|mapdata
operator|->
name|parsed_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|raw_armap
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
name|byebye
label|:
name|bfd_release
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|mapdata
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|raw_armap
argument_list|,
literal|1
argument_list|,
name|mapdata
operator|->
name|parsed_size
argument_list|,
name|abfd
argument_list|)
operator|!=
name|mapdata
operator|->
name|parsed_size
condition|)
block|{
name|bfd_error
operator|=
name|malformed_archive
expr_stmt|;
name|byebyebye
label|:
name|bfd_release
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|raw_armap
argument_list|)
expr_stmt|;
goto|goto
name|byebye
goto|;
block|}
name|ardata
operator|->
name|symdef_count
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|raw_armap
argument_list|)
expr_stmt|;
if|if
condition|(
name|ardata
operator|->
name|symdef_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|symdef
argument_list|)
operator|>
name|mapdata
operator|->
name|parsed_size
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|raw_armap
argument_list|)
condition|)
block|{
comment|/* Probably we're using the wrong byte ordering.  */
name|bfd_error
operator|=
name|wrong_format
expr_stmt|;
goto|goto
name|byebyebye
goto|;
block|}
name|ardata
operator|->
name|cache
operator|=
literal|0
expr_stmt|;
name|stringsize
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
call|(
name|PTR
call|)
argument_list|(
operator|(
operator|(
name|char
operator|*
operator|)
name|raw_armap
operator|)
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* skip sym count and string sz */
name|rbase
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|raw_armap
operator|)
operator|+
literal|6
operator|)
expr_stmt|;
name|stringbase
operator|=
operator|(
name|char
operator|*
operator|)
name|rbase
expr_stmt|;
name|ardata
operator|->
name|symdefs
operator|=
operator|(
name|carsym
operator|*
operator|)
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|rbase
operator|)
operator|+
name|stringsize
operator|)
expr_stmt|;
for|for
control|(
init|;
name|counter
operator|<
name|ardata
operator|->
name|symdef_count
condition|;
name|counter
operator|++
control|)
block|{
name|struct
name|symdef
modifier|*
name|sym
init|=
operator|(
operator|(
expr|struct
name|symdef
operator|*
operator|)
name|ardata
operator|->
name|symdefs
operator|)
operator|+
name|counter
decl_stmt|;
name|sym
operator|->
name|s
operator|.
name|name
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
call|(
name|PTR
call|)
argument_list|(
operator|&
operator|(
name|sym
operator|->
name|s
operator|.
name|string_offset
operator|)
argument_list|)
argument_list|)
operator|+
name|stringbase
expr_stmt|;
name|sym
operator|->
name|file_offset
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
call|(
name|PTR
call|)
argument_list|(
operator|&
operator|(
name|sym
operator|->
name|file_offset
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ardata
operator|->
name|first_file_filepos
operator|=
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* Pad to an even boundary if you have to */
name|ardata
operator|->
name|first_file_filepos
operator|+=
operator|(
name|ardata
operator|->
name|first_file_filepos
operator|)
operator|%
literal|2
expr_stmt|;
comment|/* FIXME, we should provide some way to free raw_ardata when      we are done using the strings from it.  For now, it seems      to be allocated on an obstack anyway... */
name|bfd_has_map
argument_list|(
name|abfd
argument_list|)
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/** Extended name table.    Normally archives support only 14-character filenames.    Intel has extended the format: longer names are stored in a special   element (the first in the archive, or second if there is an armap);   the name in the ar_hdr is replaced by<space><index into filename   element>.  Index is the P.R. of an int (decimal).  Data General have   extended the format by using the prefix // for the special element */
end_comment

begin_comment
comment|/* Returns false on error, true otherwise */
end_comment

begin_function
name|boolean
name|_bfd_slurp_extended_name_table
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|char
name|nextname
index|[
literal|17
index|]
decl_stmt|;
name|struct
name|areltdata
modifier|*
name|namedata
decl_stmt|;
comment|/* FIXME:  Formatting sucks here, and in case of failure of BFD_READ,      we probably don't want to return true.  */
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|nextname
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|abfd
argument_list|)
operator|==
literal|16
condition|)
block|{
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
operator|-
literal|16
argument_list|,
name|SEEK_CUR
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|nextname
argument_list|,
literal|"ARFILENAMES/    "
argument_list|,
literal|16
argument_list|)
operator|!=
literal|0
operator|&&
name|strncmp
argument_list|(
name|nextname
argument_list|,
literal|"//              "
argument_list|,
literal|16
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|extended_names
operator|=
name|NULL
expr_stmt|;
return|return
name|true
return|;
block|}
name|namedata
operator|=
name|snarf_ar_hdr
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|namedata
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|extended_names
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|namedata
operator|->
name|parsed_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|extended_names
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
name|byebye
label|:
name|bfd_release
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|namedata
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|extended_names
argument_list|,
literal|1
argument_list|,
name|namedata
operator|->
name|parsed_size
argument_list|,
name|abfd
argument_list|)
operator|!=
name|namedata
operator|->
name|parsed_size
condition|)
block|{
name|bfd_error
operator|=
name|malformed_archive
expr_stmt|;
name|bfd_release
argument_list|(
name|abfd
argument_list|,
call|(
name|PTR
call|)
argument_list|(
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|extended_names
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|extended_names
operator|=
name|NULL
expr_stmt|;
goto|goto
name|byebye
goto|;
block|}
comment|/* Since the archive is supposed to be printable if it contains        text, the entries in the list are newline-padded, not null        padded. In SVR4-style archives, the names also have a        trailing '/'.  We'll fix both problems here..  */
block|{
name|char
modifier|*
name|temp
init|=
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|extended_names
decl_stmt|;
name|char
modifier|*
name|limit
init|=
name|temp
operator|+
name|namedata
operator|->
name|parsed_size
decl_stmt|;
for|for
control|(
init|;
name|temp
operator|<
name|limit
condition|;
operator|++
name|temp
control|)
if|if
condition|(
operator|*
name|temp
operator|==
literal|'\n'
condition|)
name|temp
index|[
name|temp
index|[
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|?
operator|-
literal|1
else|:
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* Pad to an even boundary if you have to */
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|first_file_filepos
operator|=
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|first_file_filepos
operator|+=
operator|(
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|first_file_filepos
operator|)
operator|%
literal|2
expr_stmt|;
comment|/* FIXME, we can't release namedata here because it was allocated        below extended_names on the obstack... */
comment|/* bfd_release (abfd, namedata); */
block|}
return|return
name|true
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_comment
comment|/* Return a copy of the stuff in the filename between any :]> and a    semicolon */
end_comment

begin_decl_stmt
specifier|static
name|CONST
name|char
modifier|*
name|DEFUN
argument_list|(
name|normalize
argument_list|,
operator|(
name|file
operator|)
argument_list|,
name|CONST
name|char
operator|*
name|file
argument_list|)
block|{
name|CONST
name|char
modifier|*
name|first
decl_stmt|;
name|CONST
name|char
modifier|*
name|last
decl_stmt|;
name|char
modifier|*
name|copy
decl_stmt|;
name|first
operator|=
name|file
operator|+
name|strlen
argument_list|(
name|file
argument_list|)
operator|-
literal|1
expr_stmt|;
name|last
operator|=
name|first
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|first
operator|!=
name|file
condition|)
block|{
if|if
condition|(
operator|*
name|first
operator|==
literal|';'
condition|)
name|last
operator|=
name|first
expr_stmt|;
if|if
condition|(
operator|*
name|first
operator|==
literal|':'
operator|||
operator|*
name|first
operator|==
literal|']'
operator|||
operator|*
name|first
operator|==
literal|'>'
condition|)
block|{
name|first
operator|++
expr_stmt|;
break|break;
block|}
name|first
operator|--
expr_stmt|;
block|}
name|copy
operator|=
name|bfd_xmalloc
argument_list|(
name|last
operator|-
name|first
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|copy
argument_list|,
name|first
argument_list|,
name|last
operator|-
name|first
argument_list|)
expr_stmt|;
name|copy
index|[
name|last
operator|-
name|first
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|copy
return|;
block|}
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|CONST
name|char
modifier|*
name|DEFUN
argument_list|(
name|normalize
argument_list|,
operator|(
name|file
operator|)
argument_list|,
name|CONST
name|char
operator|*
name|file
argument_list|)
block|{
name|CONST
name|char
modifier|*
name|filename
init|=
name|strrchr
argument_list|(
name|file
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
if|if
condition|(
name|filename
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|filename
operator|++
expr_stmt|;
block|}
else|else
block|{
name|filename
operator|=
name|file
expr_stmt|;
block|}
return|return
name|filename
return|;
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Follows archive_head and produces an extended name table if necessary.    Returns (in tabloc) a pointer to an extended name table, and in tablen    the length of the table.  If it makes an entry it clobbers the filename    so that the element may be written without further massage.    Returns true if it ran successfully, false if something went wrong.    A successful return may still involve a zero-length tablen!    */
end_comment

begin_decl_stmt
name|boolean
name|DEFUN
argument_list|(
name|bfd_construct_extended_name_table
argument_list|,
operator|(
name|abfd
operator|,
name|tabloc
operator|,
name|tablen
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|char
operator|*
operator|*
name|tabloc
name|AND
name|unsigned
name|int
operator|*
name|tablen
argument_list|)
block|{
name|unsigned
name|int
name|maxname
init|=
name|abfd
operator|->
name|xvec
operator|->
name|ar_max_namelen
decl_stmt|;
name|unsigned
name|int
name|total_namelen
init|=
literal|0
decl_stmt|;
name|bfd
modifier|*
name|current
decl_stmt|;
name|char
modifier|*
name|strptr
decl_stmt|;
operator|*
name|tablen
operator|=
literal|0
expr_stmt|;
comment|/* Figure out how long the table should be */
for|for
control|(
name|current
operator|=
name|abfd
operator|->
name|archive_head
init|;
name|current
operator|!=
name|NULL
condition|;
name|current
operator|=
name|current
operator|->
name|next
control|)
block|{
name|unsigned
name|int
name|thislen
init|=
name|strlen
argument_list|(
name|normalize
argument_list|(
name|current
operator|->
name|filename
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|thislen
operator|>
name|maxname
condition|)
name|total_namelen
operator|+=
name|thislen
operator|+
literal|1
expr_stmt|;
comment|/* leave room for \n */
block|}
if|if
condition|(
name|total_namelen
operator|==
literal|0
condition|)
return|return
name|true
return|;
operator|*
name|tabloc
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|total_namelen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|tabloc
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
name|false
return|;
block|}
operator|*
name|tablen
operator|=
name|total_namelen
expr_stmt|;
name|strptr
operator|=
operator|*
name|tabloc
expr_stmt|;
for|for
control|(
name|current
operator|=
name|abfd
operator|->
name|archive_head
init|;
name|current
operator|!=
name|NULL
condition|;
name|current
operator|=
name|current
operator|->
name|next
control|)
block|{
name|CONST
name|char
modifier|*
name|normal
init|=
name|normalize
argument_list|(
name|current
operator|->
name|filename
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|thislen
init|=
name|strlen
argument_list|(
name|normal
argument_list|)
decl_stmt|;
if|if
condition|(
name|thislen
operator|>
name|maxname
condition|)
block|{
comment|/* Works for now; may need to be re-engineered if we encounter an oddball 	 archive format and want to generalise this hack. */
name|struct
name|ar_hdr
modifier|*
name|hdr
init|=
name|arch_hdr
argument_list|(
name|current
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|strptr
argument_list|,
name|normal
argument_list|)
expr_stmt|;
name|strptr
index|[
name|thislen
index|]
operator|=
literal|'\n'
expr_stmt|;
name|hdr
operator|->
name|ar_name
index|[
literal|0
index|]
operator|=
literal|' '
expr_stmt|;
comment|/* We know there will always be enough room (one of the few cases 	 where you may safely use sprintf). */
name|sprintf
argument_list|(
operator|(
name|hdr
operator|->
name|ar_name
operator|)
operator|+
literal|1
argument_list|,
literal|"%-d"
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|strptr
operator|-
operator|*
name|tabloc
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Kinda Kludgy.   We should just use the returned value of sprintf 	 but not all implementations get this right */
block|{
name|char
modifier|*
name|temp
init|=
name|hdr
operator|->
name|ar_name
operator|+
literal|2
decl_stmt|;
for|for
control|(
init|;
name|temp
operator|<
name|hdr
operator|->
name|ar_name
operator|+
name|maxname
condition|;
name|temp
operator|++
control|)
if|if
condition|(
operator|*
name|temp
operator|==
literal|'\0'
condition|)
operator|*
name|temp
operator|=
literal|' '
expr_stmt|;
block|}
name|strptr
operator|+=
name|thislen
operator|+
literal|1
expr_stmt|;
block|}
block|}
return|return
name|true
return|;
block|}
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/** A couple of functions for creating ar_hdrs */
end_comment

begin_comment
comment|/* Takes a filename, returns an arelt_data for it, or NULL if it can't make one.    The filename must refer to a filename in the filesystem.    The filename field of the ar_hdr will NOT be initialized */
end_comment

begin_decl_stmt
name|struct
name|areltdata
modifier|*
name|DEFUN
argument_list|(
name|bfd_ar_hdr_from_filesystem
argument_list|,
operator|(
name|abfd
operator|,
name|filename
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|CONST
name|char
operator|*
name|filename
argument_list|)
block|{
name|struct
name|stat
name|status
decl_stmt|;
name|struct
name|areltdata
modifier|*
name|ared
decl_stmt|;
name|struct
name|ar_hdr
modifier|*
name|hdr
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|,
modifier|*
name|temp1
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|filename
argument_list|,
operator|&
name|status
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|bfd_error
operator|=
name|system_call_error
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ared
operator|=
operator|(
expr|struct
name|areltdata
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|areltdata
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ared
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|hdr
operator|=
operator|(
expr|struct
name|ar_hdr
operator|*
operator|)
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|ared
operator|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|areltdata
argument_list|)
operator|)
expr_stmt|;
comment|/* ar headers are space padded, not null padded! */
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|hdr
expr_stmt|;
name|temp1
operator|=
name|temp
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
operator|-
literal|2
expr_stmt|;
for|for
control|(
init|;
name|temp
operator|<
name|temp1
condition|;
operator|*
operator|(
name|temp
operator|++
operator|)
operator|=
literal|' '
control|)
empty_stmt|;
name|strncpy
argument_list|(
name|hdr
operator|->
name|ar_fmag
argument_list|,
name|ARFMAG
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Goddamned sprintf doesn't permit MAXIMUM field lengths */
name|sprintf
argument_list|(
operator|(
name|hdr
operator|->
name|ar_date
operator|)
argument_list|,
literal|"%-12ld"
argument_list|,
name|status
operator|.
name|st_mtime
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
operator|(
name|hdr
operator|->
name|ar_uid
operator|)
argument_list|,
literal|"%d"
argument_list|,
name|status
operator|.
name|st_uid
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
operator|(
name|hdr
operator|->
name|ar_gid
operator|)
argument_list|,
literal|"%d"
argument_list|,
name|status
operator|.
name|st_gid
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
operator|(
name|hdr
operator|->
name|ar_mode
operator|)
argument_list|,
literal|"%-8o"
argument_list|,
operator|(
name|unsigned
operator|)
name|status
operator|.
name|st_mode
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
operator|(
name|hdr
operator|->
name|ar_size
operator|)
argument_list|,
literal|"%-10ld"
argument_list|,
name|status
operator|.
name|st_size
argument_list|)
expr_stmt|;
comment|/* Correct for a lossage in sprintf whereby it null-terminates.  I cannot      understand how these C losers could design such a ramshackle bunch of      IO operations */
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|hdr
expr_stmt|;
name|temp1
operator|=
name|temp
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
operator|-
literal|2
expr_stmt|;
for|for
control|(
init|;
name|temp
operator|<
name|temp1
condition|;
name|temp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|temp
operator|==
literal|'\0'
condition|)
operator|*
name|temp
operator|=
literal|' '
expr_stmt|;
block|}
name|strncpy
argument_list|(
name|hdr
operator|->
name|ar_fmag
argument_list|,
name|ARFMAG
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|ared
operator|->
name|parsed_size
operator|=
name|status
operator|.
name|st_size
expr_stmt|;
name|ared
operator|->
name|arch_header
operator|=
operator|(
name|char
operator|*
operator|)
name|hdr
expr_stmt|;
return|return
name|ared
return|;
block|}
end_decl_stmt

begin_comment
comment|/* This is magic required by the "ar" program.  Since it's     undocumented, it's undocumented.   You may think that it would     take a strong stomach to write this, and it does, but it takes     even a stronger stomach to try to code around such a thing! */
end_comment

begin_decl_stmt
name|struct
name|ar_hdr
modifier|*
name|DEFUN
argument_list|(
name|bfd_special_undocumented_glue
argument_list|,
operator|(
name|abfd
operator|,
name|filename
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|char
operator|*
name|filename
argument_list|)
block|{
name|struct
name|areltdata
modifier|*
name|ar_elt
init|=
name|bfd_ar_hdr_from_filesystem
argument_list|(
name|abfd
argument_list|,
name|filename
argument_list|)
decl_stmt|;
if|if
condition|(
name|ar_elt
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
return|return
operator|(
expr|struct
name|ar_hdr
operator|*
operator|)
name|ar_elt
operator|->
name|arch_header
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Analogous to stat call */
end_comment

begin_function
name|int
name|bfd_generic_stat_arch_elt
parameter_list|(
name|abfd
parameter_list|,
name|buf
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|stat
modifier|*
name|buf
decl_stmt|;
block|{
name|struct
name|ar_hdr
modifier|*
name|hdr
decl_stmt|;
name|char
modifier|*
name|aloser
decl_stmt|;
if|if
condition|(
name|abfd
operator|->
name|arelt_data
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|invalid_operation
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|hdr
operator|=
name|arch_hdr
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
define|#
directive|define
name|foo
parameter_list|(
name|arelt
parameter_list|,
name|stelt
parameter_list|,
name|size
parameter_list|)
define|\
value|buf->stelt = strtol (hdr->arelt,&aloser, size); \   if (aloser == hdr->arelt) return -1;
name|foo
argument_list|(
name|ar_date
argument_list|,
name|st_mtime
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|foo
argument_list|(
name|ar_uid
argument_list|,
name|st_uid
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|foo
argument_list|(
name|ar_gid
argument_list|,
name|st_gid
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|foo
argument_list|(
name|ar_mode
argument_list|,
name|st_mode
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|buf
operator|->
name|st_size
operator|=
name|arch_eltdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|parsed_size
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|bfd_dont_truncate_arname
parameter_list|(
name|abfd
parameter_list|,
name|pathname
parameter_list|,
name|arhdr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|CONST
name|char
modifier|*
name|pathname
decl_stmt|;
name|char
modifier|*
name|arhdr
decl_stmt|;
block|{
comment|/* FIXME: This interacts unpleasantly with ar's quick-append option.      Fortunately ic960 users will never use that option.  Fixing this      is very hard; fortunately I know how to do it and will do so once      intel's release is out the door. */
name|struct
name|ar_hdr
modifier|*
name|hdr
init|=
operator|(
expr|struct
name|ar_hdr
operator|*
operator|)
name|arhdr
decl_stmt|;
name|int
name|length
decl_stmt|;
name|CONST
name|char
modifier|*
name|filename
init|=
name|normalize
argument_list|(
name|pathname
argument_list|)
decl_stmt|;
name|int
name|maxlen
init|=
name|ar_maxnamelen
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|length
operator|=
name|strlen
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|<=
name|maxlen
condition|)
name|memcpy
argument_list|(
name|hdr
operator|->
name|ar_name
argument_list|,
name|filename
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|<
name|maxlen
condition|)
operator|(
name|hdr
operator|->
name|ar_name
operator|)
index|[
name|length
index|]
operator|=
name|ar_padchar
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|bfd_bsd_truncate_arname
parameter_list|(
name|abfd
parameter_list|,
name|pathname
parameter_list|,
name|arhdr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|CONST
name|char
modifier|*
name|pathname
decl_stmt|;
name|char
modifier|*
name|arhdr
decl_stmt|;
block|{
name|struct
name|ar_hdr
modifier|*
name|hdr
init|=
operator|(
expr|struct
name|ar_hdr
operator|*
operator|)
name|arhdr
decl_stmt|;
name|int
name|length
decl_stmt|;
name|CONST
name|char
modifier|*
name|filename
init|=
name|strrchr
argument_list|(
name|pathname
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
name|int
name|maxlen
init|=
name|ar_maxnamelen
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
if|if
condition|(
name|filename
operator|==
name|NULL
condition|)
name|filename
operator|=
name|pathname
expr_stmt|;
else|else
operator|++
name|filename
expr_stmt|;
name|length
operator|=
name|strlen
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|<=
name|maxlen
condition|)
name|memcpy
argument_list|(
name|hdr
operator|->
name|ar_name
argument_list|,
name|filename
argument_list|,
name|length
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* pathname: meet procrustes */
name|memcpy
argument_list|(
name|hdr
operator|->
name|ar_name
argument_list|,
name|filename
argument_list|,
name|maxlen
argument_list|)
expr_stmt|;
name|length
operator|=
name|maxlen
expr_stmt|;
block|}
if|if
condition|(
name|length
operator|<
name|maxlen
condition|)
operator|(
name|hdr
operator|->
name|ar_name
operator|)
index|[
name|length
index|]
operator|=
name|ar_padchar
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Store name into ar header.  Truncates the name to fit.    1> strip pathname to be just the basename.    2> if it's short enuf to fit, stuff it in.    3> If it doesn't end with .o, truncate it to fit    4> truncate it before the .o, append .o, stuff THAT in. */
end_comment

begin_comment
comment|/* This is what gnu ar does.  It's better but incompatible with the bsd ar. */
end_comment

begin_function
name|void
name|bfd_gnu_truncate_arname
parameter_list|(
name|abfd
parameter_list|,
name|pathname
parameter_list|,
name|arhdr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|CONST
name|char
modifier|*
name|pathname
decl_stmt|;
name|char
modifier|*
name|arhdr
decl_stmt|;
block|{
name|struct
name|ar_hdr
modifier|*
name|hdr
init|=
operator|(
expr|struct
name|ar_hdr
operator|*
operator|)
name|arhdr
decl_stmt|;
name|int
name|length
decl_stmt|;
name|CONST
name|char
modifier|*
name|filename
init|=
name|strrchr
argument_list|(
name|pathname
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
name|int
name|maxlen
init|=
name|ar_maxnamelen
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
if|if
condition|(
name|filename
operator|==
name|NULL
condition|)
name|filename
operator|=
name|pathname
expr_stmt|;
else|else
operator|++
name|filename
expr_stmt|;
name|length
operator|=
name|strlen
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|<=
name|maxlen
condition|)
name|memcpy
argument_list|(
name|hdr
operator|->
name|ar_name
argument_list|,
name|filename
argument_list|,
name|length
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* pathname: meet procrustes */
name|memcpy
argument_list|(
name|hdr
operator|->
name|ar_name
argument_list|,
name|filename
argument_list|,
name|maxlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|filename
index|[
name|length
operator|-
literal|2
index|]
operator|==
literal|'.'
operator|)
operator|&&
operator|(
name|filename
index|[
name|length
operator|-
literal|1
index|]
operator|==
literal|'o'
operator|)
condition|)
block|{
name|hdr
operator|->
name|ar_name
index|[
name|maxlen
operator|-
literal|2
index|]
operator|=
literal|'.'
expr_stmt|;
name|hdr
operator|->
name|ar_name
index|[
name|maxlen
operator|-
literal|1
index|]
operator|=
literal|'o'
expr_stmt|;
block|}
name|length
operator|=
name|maxlen
expr_stmt|;
block|}
if|if
condition|(
name|length
operator|<
literal|16
condition|)
operator|(
name|hdr
operator|->
name|ar_name
operator|)
index|[
name|length
index|]
operator|=
name|ar_padchar
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The BFD is open for write and has its format set to bfd_archive */
end_comment

begin_function
name|boolean
name|_bfd_write_archive_contents
parameter_list|(
name|arch
parameter_list|)
name|bfd
modifier|*
name|arch
decl_stmt|;
block|{
name|bfd
modifier|*
name|current
decl_stmt|;
name|char
modifier|*
name|etable
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|elength
init|=
literal|0
decl_stmt|;
name|boolean
name|makemap
init|=
name|bfd_has_map
argument_list|(
name|arch
argument_list|)
decl_stmt|;
name|boolean
name|hasobjects
init|=
name|false
decl_stmt|;
comment|/* if no .o's, don't bother to make a map */
name|unsigned
name|int
name|i
decl_stmt|;
name|int
name|tries
decl_stmt|;
comment|/* Verify the viability of all entries; if any of them live in the      filesystem (as opposed to living in an archive open for input)      then construct a fresh ar_hdr for them.      */
for|for
control|(
name|current
operator|=
name|arch
operator|->
name|archive_head
init|;
name|current
condition|;
name|current
operator|=
name|current
operator|->
name|next
control|)
block|{
if|if
condition|(
name|bfd_write_p
argument_list|(
name|current
argument_list|)
condition|)
block|{
name|bfd_error
operator|=
name|invalid_operation
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|current
operator|->
name|arelt_data
condition|)
block|{
name|current
operator|->
name|arelt_data
operator|=
operator|(
name|PTR
operator|)
name|bfd_ar_hdr_from_filesystem
argument_list|(
name|arch
argument_list|,
name|current
operator|->
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|current
operator|->
name|arelt_data
condition|)
return|return
name|false
return|;
comment|/* Put in the file name */
name|BFD_SEND
argument_list|(
name|arch
argument_list|,
name|_bfd_truncate_arname
argument_list|,
operator|(
name|arch
operator|,
name|current
operator|->
name|filename
operator|,
operator|(
name|char
operator|*
operator|)
name|arch_hdr
argument_list|(
name|current
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|makemap
condition|)
block|{
comment|/* don't bother if we won't make a map! */
if|if
condition|(
operator|(
name|bfd_check_format
argument_list|(
name|current
argument_list|,
name|bfd_object
argument_list|)
operator|)
if|#
directive|if
literal|0
comment|/* FIXME -- these are not set correctly */
condition|&& ((bfd_get_file_flags (current)& HAS_SYMS))
endif|#
directive|endif
condition|)
name|hasobjects
operator|=
name|true
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|bfd_construct_extended_name_table
argument_list|(
name|arch
argument_list|,
operator|&
name|etable
argument_list|,
operator|&
name|elength
argument_list|)
condition|)
return|return
name|false
return|;
name|bfd_seek
argument_list|(
name|arch
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GNU960
name|bfd_write
argument_list|(
name|BFD_GNU960_ARMAG
argument_list|(
name|arch
argument_list|)
argument_list|,
literal|1
argument_list|,
name|SARMAG
argument_list|,
name|arch
argument_list|)
expr_stmt|;
else|#
directive|else
name|bfd_write
argument_list|(
name|ARMAG
argument_list|,
literal|1
argument_list|,
name|SARMAG
argument_list|,
name|arch
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|makemap
operator|&&
name|hasobjects
condition|)
block|{
if|if
condition|(
name|compute_and_write_armap
argument_list|(
name|arch
argument_list|,
name|elength
argument_list|)
operator|!=
name|true
condition|)
block|{
return|return
name|false
return|;
block|}
block|}
if|if
condition|(
name|elength
operator|!=
literal|0
condition|)
block|{
name|struct
name|ar_hdr
name|hdr
decl_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|hdr
operator|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
operator|&
operator|(
name|hdr
operator|.
name|ar_name
index|[
literal|0
index|]
operator|)
argument_list|,
literal|"ARFILENAMES/"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
operator|&
operator|(
name|hdr
operator|.
name|ar_size
index|[
literal|0
index|]
operator|)
argument_list|,
literal|"%-10d"
argument_list|,
operator|(
name|int
operator|)
name|elength
argument_list|)
expr_stmt|;
name|hdr
operator|.
name|ar_fmag
index|[
literal|0
index|]
operator|=
literal|'`'
expr_stmt|;
name|hdr
operator|.
name|ar_fmag
index|[
literal|1
index|]
operator|=
literal|'\n'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|hdr
operator|)
operator|)
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|hdr
operator|)
operator|)
index|[
name|i
index|]
operator|)
operator|=
literal|' '
expr_stmt|;
name|bfd_write
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|hdr
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
argument_list|,
name|arch
argument_list|)
expr_stmt|;
name|bfd_write
argument_list|(
name|etable
argument_list|,
literal|1
argument_list|,
name|elength
argument_list|,
name|arch
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|elength
operator|%
literal|2
operator|)
operator|==
literal|1
condition|)
name|bfd_write
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|arch
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|current
operator|=
name|arch
operator|->
name|archive_head
init|;
name|current
condition|;
name|current
operator|=
name|current
operator|->
name|next
control|)
block|{
name|char
name|buffer
index|[
name|DEFAULT_BUFFERSIZE
index|]
decl_stmt|;
name|unsigned
name|int
name|remaining
init|=
name|arelt_size
argument_list|(
name|current
argument_list|)
decl_stmt|;
name|struct
name|ar_hdr
modifier|*
name|hdr
init|=
name|arch_hdr
argument_list|(
name|current
argument_list|)
decl_stmt|;
comment|/* write ar header */
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|char
operator|*
operator|)
name|hdr
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
argument_list|,
name|arch
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
condition|)
block|{
name|syserr
label|:
name|bfd_error
operator|=
name|system_call_error
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|bfd_seek
argument_list|(
name|current
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|syserr
goto|;
while|while
condition|(
name|remaining
condition|)
block|{
name|unsigned
name|int
name|amt
init|=
name|DEFAULT_BUFFERSIZE
decl_stmt|;
if|if
condition|(
name|amt
operator|>
name|remaining
condition|)
block|{
name|amt
operator|=
name|remaining
expr_stmt|;
block|}
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bfd_read
argument_list|(
name|buffer
argument_list|,
name|amt
argument_list|,
literal|1
argument_list|,
name|current
argument_list|)
operator|!=
name|amt
condition|)
block|{
if|if
condition|(
name|errno
condition|)
goto|goto
name|syserr
goto|;
comment|/* Looks like a truncated archive. */
name|bfd_error
operator|=
name|malformed_archive
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|bfd_write
argument_list|(
name|buffer
argument_list|,
name|amt
argument_list|,
literal|1
argument_list|,
name|arch
argument_list|)
operator|!=
name|amt
condition|)
goto|goto
name|syserr
goto|;
name|remaining
operator|-=
name|amt
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|arelt_size
argument_list|(
name|current
argument_list|)
operator|%
literal|2
operator|)
operator|==
literal|1
condition|)
name|bfd_write
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|arch
argument_list|)
expr_stmt|;
block|}
comment|/* Verify the timestamp in the archive file.  If it would      not be accepted by the linker, rewrite it until it would be.      If anything odd happens, break out and just return.       (The Berkeley linker checks the timestamp and refuses to read the      table-of-contents if it is>60 seconds less than the file's      modified-time.  That painful hack requires this painful hack.  */
name|tries
operator|=
literal|1
expr_stmt|;
do|do
block|{
comment|/* FIXME!  This kludge is to avoid adding a member to the xvec,        while generating a small patch for Adobe.  FIXME!  The        update_armap_timestamp function call should be in the xvec,        thus:  		if (bfd_update_armap_timestamp (arch) == true) break;                      ^         Instead, we check whether in a BSD archive, and call directly. */
if|if
condition|(
name|arch
operator|->
name|xvec
operator|->
name|write_armap
operator|!=
name|bsd_write_armap
condition|)
break|break;
if|if
condition|(
name|bsd_update_armap_timestamp
argument_list|(
name|arch
argument_list|)
operator|==
name|true
condition|)
comment|/* FIXME!!!  Vector it */
break|break;
if|if
condition|(
name|tries
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Warning: writing archive was slow: rewriting timestamp\n"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|tries
operator|<
literal|6
condition|)
do|;
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Note that the namidx for the first symbol is 0 */
end_comment

begin_function
name|boolean
name|compute_and_write_armap
parameter_list|(
name|arch
parameter_list|,
name|elength
parameter_list|)
name|bfd
modifier|*
name|arch
decl_stmt|;
name|unsigned
name|int
name|elength
decl_stmt|;
block|{
name|bfd
modifier|*
name|current
decl_stmt|;
name|file_ptr
name|elt_no
init|=
literal|0
decl_stmt|;
name|struct
name|orl
modifier|*
name|map
decl_stmt|;
name|int
name|orl_max
init|=
literal|15000
decl_stmt|;
comment|/* fine initial default */
name|int
name|orl_count
init|=
literal|0
decl_stmt|;
name|int
name|stridx
init|=
literal|0
decl_stmt|;
comment|/* string index */
comment|/* Dunno if this is the best place for this info... */
if|if
condition|(
name|elength
operator|!=
literal|0
condition|)
name|elength
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
expr_stmt|;
name|elength
operator|+=
name|elength
operator|%
literal|2
expr_stmt|;
name|map
operator|=
operator|(
expr|struct
name|orl
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|arch
argument_list|,
name|orl_max
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|orl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* Drop all the files called __.SYMDEF, we're going to make our        own */
while|while
condition|(
name|arch
operator|->
name|archive_head
operator|&&
name|strcmp
argument_list|(
name|arch
operator|->
name|archive_head
operator|->
name|filename
argument_list|,
literal|"__.SYMDEF"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|arch
operator|->
name|archive_head
operator|=
name|arch
operator|->
name|archive_head
operator|->
name|next
expr_stmt|;
block|}
comment|/* Map over each element */
for|for
control|(
name|current
operator|=
name|arch
operator|->
name|archive_head
init|;
name|current
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|;
name|current
operator|=
name|current
operator|->
name|next
operator|,
name|elt_no
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|bfd_check_format
argument_list|(
name|current
argument_list|,
name|bfd_object
argument_list|)
operator|==
name|true
operator|)
operator|&&
operator|(
operator|(
name|bfd_get_file_flags
argument_list|(
name|current
argument_list|)
operator|&
name|HAS_SYMS
operator|)
operator|)
condition|)
block|{
name|asymbol
modifier|*
modifier|*
name|syms
decl_stmt|;
name|unsigned
name|int
name|storage
decl_stmt|;
name|unsigned
name|int
name|symcount
decl_stmt|;
name|unsigned
name|int
name|src_count
decl_stmt|;
name|storage
operator|=
name|get_symtab_upper_bound
argument_list|(
name|current
argument_list|)
expr_stmt|;
if|if
condition|(
name|storage
operator|!=
literal|0
condition|)
block|{
name|syms
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|arch
argument_list|,
name|storage
argument_list|)
expr_stmt|;
if|if
condition|(
name|syms
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
comment|/* FIXME -- memory leak */
return|return
name|false
return|;
block|}
name|symcount
operator|=
name|bfd_canonicalize_symtab
argument_list|(
name|current
argument_list|,
name|syms
argument_list|)
expr_stmt|;
comment|/* Now map over all the symbols, picking out the ones we want */
for|for
control|(
name|src_count
operator|=
literal|0
init|;
name|src_count
operator|<
name|symcount
condition|;
name|src_count
operator|++
control|)
block|{
name|flagword
name|flags
init|=
operator|(
name|syms
index|[
name|src_count
index|]
operator|)
operator|->
name|flags
decl_stmt|;
name|asection
modifier|*
name|sec
init|=
name|syms
index|[
name|src_count
index|]
operator|->
name|section
decl_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|BSF_GLOBAL
operator|||
name|flags
operator|&
name|BSF_WEAK
operator|||
name|flags
operator|&
name|BSF_INDIRECT
operator|||
name|bfd_is_com_section
argument_list|(
name|sec
argument_list|)
operator|)
operator|&&
operator|(
name|sec
operator|!=
operator|&
name|bfd_und_section
operator|)
condition|)
block|{
comment|/* This symbol will go into the archive header */
if|if
condition|(
name|orl_count
operator|==
name|orl_max
condition|)
block|{
name|orl_max
operator|*=
literal|2
expr_stmt|;
name|map
operator|=
operator|(
expr|struct
name|orl
operator|*
operator|)
name|bfd_realloc
argument_list|(
name|arch
argument_list|,
operator|(
name|char
operator|*
operator|)
name|map
argument_list|,
name|orl_max
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|orl
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|(
name|map
index|[
name|orl_count
index|]
operator|)
operator|.
name|name
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
operator|(
operator|(
name|syms
index|[
name|src_count
index|]
operator|)
operator|->
name|name
operator|)
expr_stmt|;
operator|(
name|map
index|[
name|orl_count
index|]
operator|)
operator|.
name|pos
operator|=
operator|(
name|file_ptr
operator|)
name|current
expr_stmt|;
operator|(
name|map
index|[
name|orl_count
index|]
operator|)
operator|.
name|namidx
operator|=
name|stridx
expr_stmt|;
name|stridx
operator|+=
name|strlen
argument_list|(
operator|(
name|syms
index|[
name|src_count
index|]
operator|)
operator|->
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
operator|++
name|orl_count
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/* OK, now we have collected all the data, let's write them out */
if|if
condition|(
operator|!
name|BFD_SEND
argument_list|(
name|arch
argument_list|,
name|write_armap
argument_list|,
operator|(
name|arch
operator|,
name|elength
operator|,
name|map
operator|,
name|orl_count
operator|,
name|stridx
operator|)
argument_list|)
condition|)
block|{
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
name|boolean
name|bsd_write_armap
parameter_list|(
name|arch
parameter_list|,
name|elength
parameter_list|,
name|map
parameter_list|,
name|orl_count
parameter_list|,
name|stridx
parameter_list|)
name|bfd
modifier|*
name|arch
decl_stmt|;
name|unsigned
name|int
name|elength
decl_stmt|;
name|struct
name|orl
modifier|*
name|map
decl_stmt|;
name|unsigned
name|int
name|orl_count
decl_stmt|;
name|int
name|stridx
decl_stmt|;
block|{
name|int
name|padit
init|=
name|stridx
operator|&
literal|1
decl_stmt|;
name|unsigned
name|int
name|ranlibsize
init|=
name|orl_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ranlib
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|stringsize
init|=
name|stridx
operator|+
name|padit
decl_stmt|;
comment|/* Include 8 bytes to store ranlibsize and stringsize in output. */
name|unsigned
name|int
name|mapsize
init|=
name|ranlibsize
operator|+
name|stringsize
operator|+
literal|8
decl_stmt|;
name|file_ptr
name|firstreal
decl_stmt|;
name|bfd
modifier|*
name|current
init|=
name|arch
operator|->
name|archive_head
decl_stmt|;
name|bfd
modifier|*
name|last_elt
init|=
name|current
decl_stmt|;
comment|/* last element arch seen */
name|int
name|temp
decl_stmt|;
name|int
name|count
decl_stmt|;
name|struct
name|ar_hdr
name|hdr
decl_stmt|;
name|struct
name|stat
name|statbuf
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|firstreal
operator|=
name|mapsize
operator|+
name|elength
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
operator|+
name|SARMAG
expr_stmt|;
name|stat
argument_list|(
name|arch
operator|->
name|filename
argument_list|,
operator|&
name|statbuf
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|hdr
operator|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|hdr
operator|.
name|ar_name
argument_list|,
name|RANLIBMAG
argument_list|)
expr_stmt|;
comment|/* Remember the timestamp, to keep it holy.  But fudge it a little.  */
name|bfd_ardata
argument_list|(
name|arch
argument_list|)
operator|->
name|armap_timestamp
operator|=
name|statbuf
operator|.
name|st_mtime
operator|+
name|ARMAP_TIME_OFFSET
expr_stmt|;
name|bfd_ardata
argument_list|(
name|arch
argument_list|)
operator|->
name|armap_datepos
operator|=
name|SARMAG
operator|+
name|offsetof
argument_list|(
expr|struct
name|ar_hdr
argument_list|,
name|ar_date
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|hdr
operator|.
name|ar_date
argument_list|,
literal|"%ld"
argument_list|,
name|bfd_ardata
argument_list|(
name|arch
argument_list|)
operator|->
name|armap_timestamp
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|hdr
operator|.
name|ar_uid
argument_list|,
literal|"%d"
argument_list|,
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|hdr
operator|.
name|ar_gid
argument_list|,
literal|"%d"
argument_list|,
name|getgid
argument_list|()
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|hdr
operator|.
name|ar_size
argument_list|,
literal|"%-10d"
argument_list|,
operator|(
name|int
operator|)
name|mapsize
argument_list|)
expr_stmt|;
name|hdr
operator|.
name|ar_fmag
index|[
literal|0
index|]
operator|=
literal|'`'
expr_stmt|;
name|hdr
operator|.
name|ar_fmag
index|[
literal|1
index|]
operator|=
literal|'\n'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|hdr
operator|)
operator|)
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|hdr
operator|)
operator|)
index|[
name|i
index|]
operator|)
operator|=
literal|' '
expr_stmt|;
name|bfd_write
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|hdr
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
argument_list|,
name|arch
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|arch
argument_list|,
operator|(
name|bfd_vma
operator|)
name|ranlibsize
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|temp
argument_list|)
expr_stmt|;
name|bfd_write
argument_list|(
operator|&
name|temp
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
argument_list|,
name|arch
argument_list|)
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|orl_count
condition|;
name|count
operator|++
control|)
block|{
name|struct
name|symdef
name|outs
decl_stmt|;
name|struct
name|symdef
modifier|*
name|outp
init|=
operator|&
name|outs
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|bfd
operator|*
operator|)
operator|(
name|map
index|[
name|count
index|]
operator|)
operator|.
name|pos
operator|)
operator|!=
name|last_elt
condition|)
block|{
do|do
block|{
name|firstreal
operator|+=
name|arelt_size
argument_list|(
name|current
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
expr_stmt|;
name|firstreal
operator|+=
name|firstreal
operator|%
literal|2
expr_stmt|;
name|current
operator|=
name|current
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|current
operator|!=
operator|(
name|bfd
operator|*
operator|)
operator|(
name|map
index|[
name|count
index|]
operator|)
operator|.
name|pos
condition|)
do|;
block|}
comment|/* if new archive element */
name|last_elt
operator|=
name|current
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|arch
argument_list|,
operator|(
operator|(
name|map
index|[
name|count
index|]
operator|)
operator|.
name|namidx
operator|)
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|outs
operator|.
name|s
operator|.
name|string_offset
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|arch
argument_list|,
name|firstreal
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|outs
operator|.
name|file_offset
argument_list|)
expr_stmt|;
name|bfd_write
argument_list|(
operator|(
name|char
operator|*
operator|)
name|outp
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|outs
argument_list|)
argument_list|,
name|arch
argument_list|)
expr_stmt|;
block|}
comment|/* now write the strings themselves */
name|bfd_h_put_32
argument_list|(
name|arch
argument_list|,
name|stringsize
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|temp
argument_list|)
expr_stmt|;
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|temp
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
argument_list|,
name|arch
argument_list|)
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|orl_count
condition|;
name|count
operator|++
control|)
name|bfd_write
argument_list|(
operator|*
operator|(
operator|(
name|map
index|[
name|count
index|]
operator|)
operator|.
name|name
operator|)
argument_list|,
literal|1
argument_list|,
name|strlen
argument_list|(
operator|*
operator|(
operator|(
name|map
index|[
name|count
index|]
operator|)
operator|.
name|name
operator|)
argument_list|)
operator|+
literal|1
argument_list|,
name|arch
argument_list|)
expr_stmt|;
comment|/* The spec sez this should be a newline.  But in order to be      bug-compatible for sun's ar we use a null. */
if|if
condition|(
name|padit
condition|)
name|bfd_write
argument_list|(
literal|"\0"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|arch
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* At the end of archive file handling, update the timestamp in the    file, so the linker will accept it.       Return true if the timestamp was OK, or an unusual problem happened.    Return false if we updated the timestamp.  */
end_comment

begin_function
specifier|static
name|boolean
name|bsd_update_armap_timestamp
parameter_list|(
name|arch
parameter_list|)
name|bfd
modifier|*
name|arch
decl_stmt|;
block|{
name|struct
name|stat
name|archstat
decl_stmt|;
name|struct
name|ar_hdr
name|hdr
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Flush writes, get last-write timestamp from file, and compare it      to the timestamp IN the file.  */
name|bfd_flush
argument_list|(
name|arch
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_stat
argument_list|(
name|arch
argument_list|,
operator|&
name|archstat
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"Reading archive file mod timestamp"
argument_list|)
expr_stmt|;
return|return
name|true
return|;
comment|/* Can't read mod time for some reason */
block|}
if|if
condition|(
name|archstat
operator|.
name|st_mtime
operator|<=
name|bfd_ardata
argument_list|(
name|arch
argument_list|)
operator|->
name|armap_timestamp
condition|)
return|return
name|true
return|;
comment|/* OK by the linker's rules */
comment|/* Update the timestamp.  */
name|bfd_ardata
argument_list|(
name|arch
argument_list|)
operator|->
name|armap_timestamp
operator|=
name|archstat
operator|.
name|st_mtime
operator|+
name|ARMAP_TIME_OFFSET
expr_stmt|;
comment|/* Prepare an ASCII version suitable for writing.  */
name|memset
argument_list|(
name|hdr
operator|.
name|ar_date
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
operator|.
name|ar_date
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|hdr
operator|.
name|ar_date
argument_list|,
literal|"%ld"
argument_list|,
name|bfd_ardata
argument_list|(
name|arch
argument_list|)
operator|->
name|armap_timestamp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|hdr
operator|.
name|ar_date
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|hdr
operator|.
name|ar_date
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
operator|(
name|hdr
operator|.
name|ar_date
operator|)
index|[
name|i
index|]
operator|=
literal|' '
expr_stmt|;
comment|/* Write it into the file.  */
name|bfd_seek
argument_list|(
name|arch
argument_list|,
name|bfd_ardata
argument_list|(
name|arch
argument_list|)
operator|->
name|armap_datepos
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
name|hdr
operator|.
name|ar_date
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
operator|.
name|ar_date
argument_list|)
argument_list|,
literal|1
argument_list|,
name|arch
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|hdr
operator|.
name|ar_date
argument_list|)
condition|)
block|{
name|perror
argument_list|(
literal|"Writing updated armap timestamp"
argument_list|)
expr_stmt|;
return|return
name|true
return|;
comment|/* Some error while writing */
block|}
return|return
name|false
return|;
comment|/* We updated the timestamp successfully.  */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A coff armap looks like :  lARMAG  struct ar_hdr with name = '/'   number of symbols  offset of file for symbol 0  offset of file for symbol 1   offset of file for symbol n-1  symbol name 0  symbol name 1	    symbol name n-1  */
end_comment

begin_function
name|boolean
name|coff_write_armap
parameter_list|(
name|arch
parameter_list|,
name|elength
parameter_list|,
name|map
parameter_list|,
name|symbol_count
parameter_list|,
name|stridx
parameter_list|)
name|bfd
modifier|*
name|arch
decl_stmt|;
name|unsigned
name|int
name|elength
decl_stmt|;
name|struct
name|orl
modifier|*
name|map
decl_stmt|;
name|unsigned
name|int
name|symbol_count
decl_stmt|;
name|int
name|stridx
decl_stmt|;
block|{
comment|/* The size of the ranlib is the number of exported symbols in the        archive * the number of bytes in a int, + an int for the count */
name|unsigned
name|int
name|ranlibsize
init|=
operator|(
name|symbol_count
operator|*
literal|4
operator|)
operator|+
literal|4
decl_stmt|;
name|unsigned
name|int
name|stringsize
init|=
name|stridx
decl_stmt|;
name|unsigned
name|int
name|mapsize
init|=
name|stringsize
operator|+
name|ranlibsize
decl_stmt|;
name|file_ptr
name|archive_member_file_ptr
decl_stmt|;
name|bfd
modifier|*
name|current
init|=
name|arch
operator|->
name|archive_head
decl_stmt|;
name|int
name|count
decl_stmt|;
name|struct
name|ar_hdr
name|hdr
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|int
name|padit
init|=
name|mapsize
operator|&
literal|1
decl_stmt|;
if|if
condition|(
name|padit
condition|)
name|mapsize
operator|++
expr_stmt|;
comment|/* work out where the first object file will go in the archive */
name|archive_member_file_ptr
operator|=
name|mapsize
operator|+
name|elength
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
operator|+
name|SARMAG
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|hdr
operator|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|hdr
operator|.
name|ar_name
index|[
literal|0
index|]
operator|=
literal|'/'
expr_stmt|;
name|sprintf
argument_list|(
name|hdr
operator|.
name|ar_size
argument_list|,
literal|"%-10d"
argument_list|,
operator|(
name|int
operator|)
name|mapsize
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|hdr
operator|.
name|ar_date
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|time
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This, at least, is what Intel coff sets the values to.: */
name|sprintf
argument_list|(
operator|(
name|hdr
operator|.
name|ar_uid
operator|)
argument_list|,
literal|"%d"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
operator|(
name|hdr
operator|.
name|ar_gid
operator|)
argument_list|,
literal|"%d"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
operator|(
name|hdr
operator|.
name|ar_mode
operator|)
argument_list|,
literal|"%-7o"
argument_list|,
operator|(
name|unsigned
operator|)
literal|0
argument_list|)
expr_stmt|;
name|hdr
operator|.
name|ar_fmag
index|[
literal|0
index|]
operator|=
literal|'`'
expr_stmt|;
name|hdr
operator|.
name|ar_fmag
index|[
literal|1
index|]
operator|=
literal|'\n'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|hdr
operator|)
operator|)
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|hdr
operator|)
operator|)
index|[
name|i
index|]
operator|)
operator|=
literal|' '
expr_stmt|;
comment|/* Write the ar header for this item and the number of symbols */
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|hdr
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
argument_list|,
name|arch
argument_list|)
expr_stmt|;
name|bfd_write_bigendian_4byte_int
argument_list|(
name|arch
argument_list|,
name|symbol_count
argument_list|)
expr_stmt|;
comment|/* Two passes, first write the file offsets for each symbol -        remembering that each offset is on a two byte boundary.  */
comment|/* Write out the file offset for the file associated with each        symbol, and remember to keep the offsets padded out.  */
name|current
operator|=
name|arch
operator|->
name|archive_head
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|current
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
operator|&&
name|count
operator|<
name|symbol_count
condition|)
block|{
comment|/* For each symbol which is used defined in this object, write out 	   the object file's address in the archive */
while|while
condition|(
operator|(
operator|(
name|bfd
operator|*
operator|)
operator|(
name|map
index|[
name|count
index|]
operator|)
operator|.
name|pos
operator|)
operator|==
name|current
condition|)
block|{
name|bfd_write_bigendian_4byte_int
argument_list|(
name|arch
argument_list|,
name|archive_member_file_ptr
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
comment|/* Add size of this archive entry */
name|archive_member_file_ptr
operator|+=
name|arelt_size
argument_list|(
name|current
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
expr_stmt|;
comment|/* remember aboout the even alignment */
name|archive_member_file_ptr
operator|+=
name|archive_member_file_ptr
operator|%
literal|2
expr_stmt|;
name|current
operator|=
name|current
operator|->
name|next
expr_stmt|;
block|}
comment|/* now write the strings themselves */
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|symbol_count
condition|;
name|count
operator|++
control|)
block|{
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
operator|*
operator|(
operator|(
name|map
index|[
name|count
index|]
operator|)
operator|.
name|name
operator|)
argument_list|,
literal|1
argument_list|,
name|strlen
argument_list|(
operator|*
operator|(
operator|(
name|map
index|[
name|count
index|]
operator|)
operator|.
name|name
operator|)
argument_list|)
operator|+
literal|1
argument_list|,
name|arch
argument_list|)
expr_stmt|;
block|}
comment|/* The spec sez this should be a newline.  But in order to be        bug-compatible for arc960 we use a null. */
if|if
condition|(
name|padit
condition|)
name|bfd_write
argument_list|(
literal|"\0"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|arch
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

end_unit

