begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Assorted BFD support routines, only used internally.    Copyright 1990, 91, 92, 93, 94 Free Software Foundation, Inc.    Written by Cygnus Support.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_comment
comment|/* SECTION 	Internal functions  DESCRIPTION 	These routines are used within BFD. 	They are not intended for export, but are documented here for 	completeness. */
end_comment

begin_comment
comment|/* A routine which is used in target vectors for unsupported    operations.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|boolean
name|bfd_false
parameter_list|(
name|ignore
parameter_list|)
name|bfd
modifier|*
name|ignore
decl_stmt|;
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* A routine which is used in target vectors for supported operations    which do not actually do anything.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|boolean
name|bfd_true
parameter_list|(
name|ignore
parameter_list|)
name|bfd
modifier|*
name|ignore
decl_stmt|;
block|{
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* A routine which is used in target vectors for unsupported    operations which return a pointer value.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|PTR
name|bfd_nullvoidptr
parameter_list|(
name|ignore
parameter_list|)
name|bfd
modifier|*
name|ignore
decl_stmt|;
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|bfd_0
parameter_list|(
name|ignore
parameter_list|)
name|bfd
modifier|*
name|ignore
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|unsigned
name|int
name|bfd_0u
parameter_list|(
name|ignore
parameter_list|)
name|bfd
modifier|*
name|ignore
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*ARGUSED*/
end_comment

begin_function
name|long
name|bfd_0l
parameter_list|(
name|ignore
parameter_list|)
name|bfd
modifier|*
name|ignore
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* A routine which is used in target vectors for unsupported    operations which return -1 on error.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|long
name|_bfd_n1
parameter_list|(
name|ignore_abfd
parameter_list|)
name|bfd
modifier|*
name|ignore_abfd
decl_stmt|;
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|bfd_void
parameter_list|(
name|ignore
parameter_list|)
name|bfd
modifier|*
name|ignore
decl_stmt|;
block|{ }
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|boolean
name|_bfd_nocore_core_file_matches_executable_p
parameter_list|(
name|ignore_core_bfd
parameter_list|,
name|ignore_exec_bfd
parameter_list|)
name|bfd
modifier|*
name|ignore_core_bfd
decl_stmt|;
name|bfd
modifier|*
name|ignore_exec_bfd
decl_stmt|;
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Routine to handle core_file_failing_command entry point for targets    without core file support.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|char
modifier|*
name|_bfd_nocore_core_file_failing_command
parameter_list|(
name|ignore_abfd
parameter_list|)
name|bfd
modifier|*
name|ignore_abfd
decl_stmt|;
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Routine to handle core_file_failing_signal entry point for targets    without core file support.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|_bfd_nocore_core_file_failing_signal
parameter_list|(
name|ignore_abfd
parameter_list|)
name|bfd
modifier|*
name|ignore_abfd
decl_stmt|;
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|const
name|bfd_target
modifier|*
name|_bfd_dummy_target
parameter_list|(
name|ignore_abfd
parameter_list|)
name|bfd
modifier|*
name|ignore_abfd
decl_stmt|;
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_ifndef
ifndef|#
directive|ifndef
name|bfd_zmalloc
end_ifndef

begin_comment
comment|/* allocate and clear storage */
end_comment

begin_function
name|char
modifier|*
name|bfd_zmalloc
parameter_list|(
name|size
parameter_list|)
name|bfd_size_type
name|size
decl_stmt|;
block|{
name|char
modifier|*
name|ptr
init|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|size_t
operator|)
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|ptr
operator|&&
name|size
condition|)
name|memset
argument_list|(
name|ptr
argument_list|,
literal|0
argument_list|,
operator|(
name|size_t
operator|)
name|size
argument_list|)
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* bfd_zmalloc */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Some IO code */
end_comment

begin_comment
comment|/* Note that archive entries don't have streams; they share their parent's.    This allows someone to play with the iostream behind BFD's back.     Also, note that the origin pointer points to the beginning of a file's    contents (0 for non-archive elements).  For archive entries this is the    first octet in the file, NOT the beginning of the archive header. */
end_comment

begin_function
specifier|static
name|int
name|real_read
parameter_list|(
name|where
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|,
name|file
parameter_list|)
name|PTR
name|where
decl_stmt|;
name|int
name|a
decl_stmt|;
name|int
name|b
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
return|return
name|fread
argument_list|(
name|where
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|file
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return value is amount read (FIXME: how are errors and end of file dealt    with?  We never call bfd_set_error, which is probably a mistake).  */
end_comment

begin_function
name|bfd_size_type
name|bfd_read
parameter_list|(
name|ptr
parameter_list|,
name|size
parameter_list|,
name|nitems
parameter_list|,
name|abfd
parameter_list|)
name|PTR
name|ptr
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
name|bfd_size_type
name|nitems
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|int
name|nread
decl_stmt|;
name|nread
operator|=
name|real_read
argument_list|(
name|ptr
argument_list|,
literal|1
argument_list|,
call|(
name|int
call|)
argument_list|(
name|size
operator|*
name|nitems
argument_list|)
argument_list|,
name|bfd_cache_lookup
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FILE_OFFSET_IS_CHAR_INDEX
if|if
condition|(
name|nread
operator|>
literal|0
condition|)
name|abfd
operator|->
name|where
operator|+=
name|nread
expr_stmt|;
endif|#
directive|endif
comment|/* Set bfd_error if we did not read as much data as we expected.       If the read failed due to an error set the bfd_error_system_call,      else set bfd_error_file_truncated.       A BFD backend may wish to override bfd_error_file_truncated to      provide something more useful (eg. no_symbols or wrong_format).  */
if|if
condition|(
name|nread
operator|<
call|(
name|int
call|)
argument_list|(
name|size
operator|*
name|nitems
argument_list|)
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|bfd_cache_lookup
argument_list|(
name|abfd
argument_list|)
argument_list|)
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_system_call
argument_list|)
expr_stmt|;
else|else
name|bfd_set_error
argument_list|(
name|bfd_error_file_truncated
argument_list|)
expr_stmt|;
block|}
return|return
name|nread
return|;
block|}
end_function

begin_function
name|bfd_size_type
name|bfd_write
parameter_list|(
name|ptr
parameter_list|,
name|size
parameter_list|,
name|nitems
parameter_list|,
name|abfd
parameter_list|)
name|CONST
name|PTR
name|ptr
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
name|bfd_size_type
name|nitems
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|int
name|nwrote
init|=
name|fwrite
argument_list|(
name|ptr
argument_list|,
literal|1
argument_list|,
call|(
name|int
call|)
argument_list|(
name|size
operator|*
name|nitems
argument_list|)
argument_list|,
name|bfd_cache_lookup
argument_list|(
name|abfd
argument_list|)
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|FILE_OFFSET_IS_CHAR_INDEX
if|if
condition|(
name|nwrote
operator|>
literal|0
condition|)
name|abfd
operator|->
name|where
operator|+=
name|nwrote
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|nwrote
operator|!=
name|size
operator|*
name|nitems
condition|)
block|{
ifdef|#
directive|ifdef
name|ENOSPC
if|if
condition|(
name|nwrote
operator|>=
literal|0
condition|)
name|errno
operator|=
name|ENOSPC
expr_stmt|;
endif|#
directive|endif
name|bfd_set_error
argument_list|(
name|bfd_error_system_call
argument_list|)
expr_stmt|;
block|}
return|return
name|nwrote
return|;
block|}
end_function

begin_comment
comment|/* INTERNAL_FUNCTION 	bfd_write_bigendian_4byte_int  SYNOPSIS 	void bfd_write_bigendian_4byte_int(bfd *abfd,  int i);  DESCRIPTION 	Write a 4 byte integer @var{i} to the output BFD @var{abfd}, in big 	endian order regardless of what else is going on.  This is useful in 	archives.  */
end_comment

begin_function
name|void
name|bfd_write_bigendian_4byte_int
parameter_list|(
name|abfd
parameter_list|,
name|i
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|int
name|i
decl_stmt|;
block|{
name|bfd_byte
name|buffer
index|[
literal|4
index|]
decl_stmt|;
name|bfd_putb32
argument_list|(
name|i
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|buffer
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|4
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|long
name|bfd_tell
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|file_ptr
name|ptr
decl_stmt|;
name|ptr
operator|=
name|ftell
argument_list|(
name|bfd_cache_lookup
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|my_archive
condition|)
name|ptr
operator|-=
name|abfd
operator|->
name|origin
expr_stmt|;
name|abfd
operator|->
name|where
operator|=
name|ptr
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
name|int
name|bfd_flush
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
return|return
name|fflush
argument_list|(
name|bfd_cache_lookup
argument_list|(
name|abfd
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|bfd_stat
parameter_list|(
name|abfd
parameter_list|,
name|statbuf
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|stat
modifier|*
name|statbuf
decl_stmt|;
block|{
return|return
name|fstat
argument_list|(
name|fileno
argument_list|(
name|bfd_cache_lookup
argument_list|(
name|abfd
argument_list|)
argument_list|)
argument_list|,
name|statbuf
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns 0 for success, nonzero for failure (in which case bfd_get_error    can retrieve the error code).  */
end_comment

begin_function
name|int
name|bfd_seek
parameter_list|(
name|abfd
parameter_list|,
name|position
parameter_list|,
name|direction
parameter_list|)
name|bfd
modifier|*
name|CONST
name|abfd
decl_stmt|;
name|CONST
name|file_ptr
name|position
decl_stmt|;
name|CONST
name|int
name|direction
decl_stmt|;
block|{
name|int
name|result
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|file_ptr
name|file_position
decl_stmt|;
comment|/* For the time being, a BFD may not seek to it's end.  The problem      is that we don't easily have a way to recognize the end of an      element in an archive. */
name|BFD_ASSERT
argument_list|(
name|direction
operator|==
name|SEEK_SET
operator|||
name|direction
operator|==
name|SEEK_CUR
argument_list|)
expr_stmt|;
if|if
condition|(
name|direction
operator|==
name|SEEK_CUR
operator|&&
name|position
operator|==
literal|0
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|FILE_OFFSET_IS_CHAR_INDEX
if|if
condition|(
name|abfd
operator|->
name|format
operator|!=
name|bfd_archive
operator|&&
name|abfd
operator|->
name|my_archive
operator|==
literal|0
condition|)
block|{
if|#
directive|if
literal|0
comment|/* Explanation for this code: I'm only about 95+% sure that the above 	 conditions are sufficient and that all i/o calls are properly 	 adjusting the `where' field.  So this is sort of an `assert' 	 that the `where' field is correct.  If we can go a while without 	 tripping the abort, we can probably safely disable this code, 	 so that the real optimizations happen.  */
block|file_ptr where_am_i_now;       where_am_i_now = ftell (bfd_cache_lookup (abfd));       if (abfd->my_archive) 	where_am_i_now -= abfd->origin;       if (where_am_i_now != abfd->where) 	abort ();
endif|#
directive|endif
if|if
condition|(
name|direction
operator|==
name|SEEK_SET
operator|&&
name|position
operator|==
name|abfd
operator|->
name|where
condition|)
return|return
literal|0
return|;
block|}
else|else
block|{
comment|/* We need something smarter to optimize access to archives. 	 Currently, anything inside an archive is read via the file 	 handle for the archive.  Which means that a bfd_seek on one 	 component affects the `current position' in the archive, as 	 well as in any other component.  	 It might be sufficient to put a spike through the cache 	 abstraction, and look to the archive for the file position, 	 but I think we should try for something cleaner.  	 In the meantime, no optimization for archives.  */
block|}
endif|#
directive|endif
name|f
operator|=
name|bfd_cache_lookup
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|file_position
operator|=
name|position
expr_stmt|;
if|if
condition|(
name|direction
operator|==
name|SEEK_SET
operator|&&
name|abfd
operator|->
name|my_archive
operator|!=
name|NULL
condition|)
name|file_position
operator|+=
name|abfd
operator|->
name|origin
expr_stmt|;
name|result
operator|=
name|fseek
argument_list|(
name|f
argument_list|,
name|file_position
argument_list|,
name|direction
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
block|{
comment|/* Force redetermination of `where' field.  */
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_system_call
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|FILE_OFFSET_IS_CHAR_INDEX
comment|/* Adjust `where' field.  */
if|if
condition|(
name|direction
operator|==
name|SEEK_SET
condition|)
name|abfd
operator|->
name|where
operator|=
name|position
expr_stmt|;
else|else
name|abfd
operator|->
name|where
operator|+=
name|position
expr_stmt|;
endif|#
directive|endif
block|}
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/** Make a string table */
end_comment

begin_comment
comment|/*>bfd.h<  Add string to table pointed to by table, at location starting with free_ptr.    resizes the table if necessary (if it's NULL, creates it, ignoring    table_length).  Updates free_ptr, table, table_length */
end_comment

begin_function
name|boolean
name|bfd_add_to_string_table
parameter_list|(
name|table
parameter_list|,
name|new_string
parameter_list|,
name|table_length
parameter_list|,
name|free_ptr
parameter_list|)
name|char
modifier|*
modifier|*
name|table
decl_stmt|;
name|char
modifier|*
name|new_string
decl_stmt|;
name|unsigned
name|int
modifier|*
name|table_length
decl_stmt|;
name|char
modifier|*
modifier|*
name|free_ptr
decl_stmt|;
block|{
name|size_t
name|string_length
init|=
name|strlen
argument_list|(
name|new_string
argument_list|)
operator|+
literal|1
decl_stmt|;
comment|/* include null here */
name|char
modifier|*
name|base
init|=
operator|*
name|table
decl_stmt|;
name|size_t
name|space_length
init|=
operator|*
name|table_length
decl_stmt|;
name|unsigned
name|int
name|offset
init|=
operator|(
name|base
condition|?
operator|*
name|free_ptr
operator|-
name|base
else|:
literal|0
operator|)
decl_stmt|;
if|if
condition|(
name|base
operator|==
name|NULL
condition|)
block|{
comment|/* Avoid a useless regrow if we can (but of course we still        take it next time).  */
name|space_length
operator|=
operator|(
name|string_length
operator|<
name|DEFAULT_STRING_SPACE_SIZE
condition|?
name|DEFAULT_STRING_SPACE_SIZE
else|:
name|string_length
operator|+
literal|1
operator|)
expr_stmt|;
name|base
operator|=
name|bfd_zmalloc
argument_list|(
operator|(
name|bfd_size_type
operator|)
name|space_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
if|if
condition|(
call|(
name|size_t
call|)
argument_list|(
name|offset
operator|+
name|string_length
argument_list|)
operator|>=
name|space_length
condition|)
block|{
comment|/* Make sure we will have enough space */
while|while
condition|(
call|(
name|size_t
call|)
argument_list|(
name|offset
operator|+
name|string_length
argument_list|)
operator|>=
name|space_length
condition|)
name|space_length
operator|+=
name|space_length
operator|/
literal|2
expr_stmt|;
comment|/* grow by 50% */
name|base
operator|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
name|base
argument_list|,
name|space_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
name|memcpy
argument_list|(
name|base
operator|+
name|offset
argument_list|,
name|new_string
argument_list|,
name|string_length
argument_list|)
expr_stmt|;
operator|*
name|table
operator|=
name|base
expr_stmt|;
operator|*
name|table_length
operator|=
name|space_length
expr_stmt|;
operator|*
name|free_ptr
operator|=
name|base
operator|+
name|offset
operator|+
name|string_length
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/** The do-it-yourself (byte) sex-change kit */
end_comment

begin_comment
comment|/* The middle letter e.g. get<b>short indicates Big or Little endian    target machine.  It doesn't matter what the byte order of the host    machine is; these routines work for either.  */
end_comment

begin_comment
comment|/* FIXME: Should these take a count argument?    Answer (gnu@cygnus.com):  No, but perhaps they should be inline                              functions in swap.h #ifdef __GNUC__.                               Gprof them later and find out.  */
end_comment

begin_comment
comment|/* FUNCTION 	bfd_put_size FUNCTION 	bfd_get_size  DESCRIPTION 	These macros as used for reading and writing raw data in 	sections; each access (except for bytes) is vectored through 	the target format of the BFD and mangled accordingly. The 	mangling performs any necessary endian translations and 	removes alignment restrictions.  Note that types accepted and 	returned by these macros are identical so they can be swapped 	around in macros---for example, @file{libaout.h} defines<<GET_WORD>> 	to either<<bfd_get_32>> or<<bfd_get_64>>.  	In the put routines, @var{val} must be a<<bfd_vma>>.  If we are on a 	system without prototypes, the caller is responsible for making 	sure that is true, with a cast if necessary.  We don't cast 	them in the macro definitions because that would prevent<<lint>> 	or<<gcc -Wall>> from detecting sins such as passing a pointer. 	To detect calling these with less than a<<bfd_vma>>, use<<gcc -Wconversion>> on a host with 64 bit<<bfd_vma>>'s.  . .{* Byte swapping macros for user section data.  *} . .#define bfd_put_8(abfd, val, ptr) \ .                (*((unsigned char *)(ptr)) = (unsigned char)(val)) .#define bfd_put_signed_8 \ .		bfd_put_8 .#define bfd_get_8(abfd, ptr) \ .                (*(unsigned char *)(ptr)) .#define bfd_get_signed_8(abfd, ptr) \ .		((*(unsigned char *)(ptr) ^ 0x80) - 0x80) . .#define bfd_put_16(abfd, val, ptr) \ .                BFD_SEND(abfd, bfd_putx16, ((val),(ptr))) .#define bfd_put_signed_16 \ .		 bfd_put_16 .#define bfd_get_16(abfd, ptr) \ .                BFD_SEND(abfd, bfd_getx16, (ptr)) .#define bfd_get_signed_16(abfd, ptr) \ .         	 BFD_SEND (abfd, bfd_getx_signed_16, (ptr)) . .#define bfd_put_32(abfd, val, ptr) \ .                BFD_SEND(abfd, bfd_putx32, ((val),(ptr))) .#define bfd_put_signed_32 \ .		 bfd_put_32 .#define bfd_get_32(abfd, ptr) \ .                BFD_SEND(abfd, bfd_getx32, (ptr)) .#define bfd_get_signed_32(abfd, ptr) \ .		 BFD_SEND(abfd, bfd_getx_signed_32, (ptr)) . .#define bfd_put_64(abfd, val, ptr) \ .                BFD_SEND(abfd, bfd_putx64, ((val), (ptr))) .#define bfd_put_signed_64 \ .		 bfd_put_64 .#define bfd_get_64(abfd, ptr) \ .                BFD_SEND(abfd, bfd_getx64, (ptr)) .#define bfd_get_signed_64(abfd, ptr) \ .		 BFD_SEND(abfd, bfd_getx_signed_64, (ptr)) . */
end_comment

begin_comment
comment|/* FUNCTION 	bfd_h_put_size 	bfd_h_get_size  DESCRIPTION 	These macros have the same function as their<<bfd_get_x>> 	bretheren, except that they are used for removing information 	for the header records of object files. Believe it or not, 	some object files keep their header records in big endian 	order and their data in little endian order. . .{* Byte swapping macros for file header data.  *} . .#define bfd_h_put_8(abfd, val, ptr) \ .		bfd_put_8 (abfd, val, ptr) .#define bfd_h_put_signed_8(abfd, val, ptr) \ .		bfd_put_8 (abfd, val, ptr) .#define bfd_h_get_8(abfd, ptr) \ .		bfd_get_8 (abfd, ptr) .#define bfd_h_get_signed_8(abfd, ptr) \ .		bfd_get_signed_8 (abfd, ptr) . .#define bfd_h_put_16(abfd, val, ptr) \ .                BFD_SEND(abfd, bfd_h_putx16,(val,ptr)) .#define bfd_h_put_signed_16 \ .		 bfd_h_put_16 .#define bfd_h_get_16(abfd, ptr) \ .                BFD_SEND(abfd, bfd_h_getx16,(ptr)) .#define bfd_h_get_signed_16(abfd, ptr) \ .		 BFD_SEND(abfd, bfd_h_getx_signed_16, (ptr)) . .#define bfd_h_put_32(abfd, val, ptr) \ .                BFD_SEND(abfd, bfd_h_putx32,(val,ptr)) .#define bfd_h_put_signed_32 \ .		 bfd_h_put_32 .#define bfd_h_get_32(abfd, ptr) \ .                BFD_SEND(abfd, bfd_h_getx32,(ptr)) .#define bfd_h_get_signed_32(abfd, ptr) \ .		 BFD_SEND(abfd, bfd_h_getx_signed_32, (ptr)) . .#define bfd_h_put_64(abfd, val, ptr) \ .                BFD_SEND(abfd, bfd_h_putx64,(val, ptr)) .#define bfd_h_put_signed_64 \ .		 bfd_h_put_64 .#define bfd_h_get_64(abfd, ptr) \ .                BFD_SEND(abfd, bfd_h_getx64,(ptr)) .#define bfd_h_get_signed_64(abfd, ptr) \ .		 BFD_SEND(abfd, bfd_h_getx_signed_64, (ptr)) . */
end_comment

begin_comment
comment|/* Sign extension to bfd_signed_vma.  */
end_comment

begin_define
define|#
directive|define
name|COERCE16
parameter_list|(
name|x
parameter_list|)
value|(((bfd_signed_vma) (x) ^ 0x8000) - 0x8000)
end_define

begin_define
define|#
directive|define
name|COERCE32
parameter_list|(
name|x
parameter_list|)
value|(((bfd_signed_vma) (x) ^ 0x80000000) - 0x80000000)
end_define

begin_define
define|#
directive|define
name|EIGHT_GAZILLION
value|(((BFD_HOST_64_BIT)0x80000000)<< 32)
end_define

begin_define
define|#
directive|define
name|COERCE64
parameter_list|(
name|x
parameter_list|)
define|\
value|(((bfd_signed_vma) (x) ^ EIGHT_GAZILLION) - EIGHT_GAZILLION)
end_define

begin_function
name|bfd_vma
name|bfd_getb16
parameter_list|(
name|addr
parameter_list|)
specifier|register
specifier|const
name|bfd_byte
modifier|*
name|addr
decl_stmt|;
block|{
return|return
operator|(
name|addr
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|1
index|]
return|;
block|}
end_function

begin_function
name|bfd_vma
name|bfd_getl16
parameter_list|(
name|addr
parameter_list|)
specifier|register
specifier|const
name|bfd_byte
modifier|*
name|addr
decl_stmt|;
block|{
return|return
operator|(
name|addr
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|0
index|]
return|;
block|}
end_function

begin_function
name|bfd_signed_vma
name|bfd_getb_signed_16
parameter_list|(
name|addr
parameter_list|)
specifier|register
specifier|const
name|bfd_byte
modifier|*
name|addr
decl_stmt|;
block|{
return|return
name|COERCE16
argument_list|(
operator|(
name|addr
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|1
index|]
argument_list|)
return|;
block|}
end_function

begin_function
name|bfd_signed_vma
name|bfd_getl_signed_16
parameter_list|(
name|addr
parameter_list|)
specifier|register
specifier|const
name|bfd_byte
modifier|*
name|addr
decl_stmt|;
block|{
return|return
name|COERCE16
argument_list|(
operator|(
name|addr
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|0
index|]
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|bfd_putb16
parameter_list|(
name|data
parameter_list|,
name|addr
parameter_list|)
name|bfd_vma
name|data
decl_stmt|;
specifier|register
name|bfd_byte
modifier|*
name|addr
decl_stmt|;
block|{
name|addr
index|[
literal|0
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|data
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|addr
index|[
literal|1
index|]
operator|=
operator|(
name|bfd_byte
operator|)
name|data
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bfd_putl16
parameter_list|(
name|data
parameter_list|,
name|addr
parameter_list|)
name|bfd_vma
name|data
decl_stmt|;
specifier|register
name|bfd_byte
modifier|*
name|addr
decl_stmt|;
block|{
name|addr
index|[
literal|0
index|]
operator|=
operator|(
name|bfd_byte
operator|)
name|data
expr_stmt|;
name|addr
index|[
literal|1
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|data
operator|>>
literal|8
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|bfd_vma
name|bfd_getb32
parameter_list|(
name|addr
parameter_list|)
specifier|register
specifier|const
name|bfd_byte
modifier|*
name|addr
decl_stmt|;
block|{
return|return
operator|(
operator|(
operator|(
operator|(
operator|(
name|bfd_vma
operator|)
name|addr
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|1
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|2
index|]
operator|)
operator|<<
literal|8
operator||
name|addr
index|[
literal|3
index|]
return|;
block|}
end_function

begin_function
name|bfd_vma
name|bfd_getl32
parameter_list|(
name|addr
parameter_list|)
specifier|register
specifier|const
name|bfd_byte
modifier|*
name|addr
decl_stmt|;
block|{
return|return
operator|(
operator|(
operator|(
operator|(
operator|(
name|bfd_vma
operator|)
name|addr
index|[
literal|3
index|]
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|2
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|1
index|]
operator|)
operator|<<
literal|8
operator||
name|addr
index|[
literal|0
index|]
return|;
block|}
end_function

begin_function
name|bfd_signed_vma
name|bfd_getb_signed_32
parameter_list|(
name|addr
parameter_list|)
specifier|register
specifier|const
name|bfd_byte
modifier|*
name|addr
decl_stmt|;
block|{
return|return
name|COERCE32
argument_list|(
operator|(
operator|(
operator|(
operator|(
operator|(
name|bfd_vma
operator|)
name|addr
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|1
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|2
index|]
operator|)
operator|<<
literal|8
operator||
name|addr
index|[
literal|3
index|]
argument_list|)
return|;
block|}
end_function

begin_function
name|bfd_signed_vma
name|bfd_getl_signed_32
parameter_list|(
name|addr
parameter_list|)
specifier|register
specifier|const
name|bfd_byte
modifier|*
name|addr
decl_stmt|;
block|{
return|return
name|COERCE32
argument_list|(
operator|(
operator|(
operator|(
operator|(
operator|(
name|bfd_vma
operator|)
name|addr
index|[
literal|3
index|]
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|2
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|1
index|]
operator|)
operator|<<
literal|8
operator||
name|addr
index|[
literal|0
index|]
argument_list|)
return|;
block|}
end_function

begin_function
name|bfd_vma
name|bfd_getb64
parameter_list|(
name|addr
parameter_list|)
specifier|register
specifier|const
name|bfd_byte
modifier|*
name|addr
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|BFD64
name|bfd_vma
name|low
decl_stmt|,
name|high
decl_stmt|;
name|high
operator|=
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
name|addr
index|[
literal|0
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|1
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|2
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|3
index|]
operator|)
operator|)
expr_stmt|;
name|low
operator|=
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
name|bfd_vma
operator|)
name|addr
index|[
literal|4
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|5
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|6
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|7
index|]
operator|)
operator|)
expr_stmt|;
return|return
name|high
operator|<<
literal|32
operator||
name|low
return|;
else|#
directive|else
name|BFD_FAIL
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|bfd_vma
name|bfd_getl64
parameter_list|(
name|addr
parameter_list|)
specifier|register
specifier|const
name|bfd_byte
modifier|*
name|addr
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|BFD64
name|bfd_vma
name|low
decl_stmt|,
name|high
decl_stmt|;
name|high
operator|=
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
name|addr
index|[
literal|7
index|]
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|6
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|5
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|4
index|]
operator|)
operator|)
expr_stmt|;
name|low
operator|=
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
name|bfd_vma
operator|)
name|addr
index|[
literal|3
index|]
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|2
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|1
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|0
index|]
operator|)
operator|)
expr_stmt|;
return|return
name|high
operator|<<
literal|32
operator||
name|low
return|;
else|#
directive|else
name|BFD_FAIL
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|bfd_signed_vma
name|bfd_getb_signed_64
parameter_list|(
name|addr
parameter_list|)
specifier|register
specifier|const
name|bfd_byte
modifier|*
name|addr
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|BFD64
name|bfd_vma
name|low
decl_stmt|,
name|high
decl_stmt|;
name|high
operator|=
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
name|addr
index|[
literal|0
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|1
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|2
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|3
index|]
operator|)
operator|)
expr_stmt|;
name|low
operator|=
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
name|bfd_vma
operator|)
name|addr
index|[
literal|4
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|5
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|6
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|7
index|]
operator|)
operator|)
expr_stmt|;
return|return
name|COERCE64
argument_list|(
name|high
operator|<<
literal|32
operator||
name|low
argument_list|)
return|;
else|#
directive|else
name|BFD_FAIL
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|bfd_signed_vma
name|bfd_getl_signed_64
parameter_list|(
name|addr
parameter_list|)
specifier|register
specifier|const
name|bfd_byte
modifier|*
name|addr
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|BFD64
name|bfd_vma
name|low
decl_stmt|,
name|high
decl_stmt|;
name|high
operator|=
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
name|addr
index|[
literal|7
index|]
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|6
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|5
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|4
index|]
operator|)
operator|)
expr_stmt|;
name|low
operator|=
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
name|bfd_vma
operator|)
name|addr
index|[
literal|3
index|]
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|2
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|1
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|0
index|]
operator|)
operator|)
expr_stmt|;
return|return
name|COERCE64
argument_list|(
name|high
operator|<<
literal|32
operator||
name|low
argument_list|)
return|;
else|#
directive|else
name|BFD_FAIL
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|bfd_putb32
parameter_list|(
name|data
parameter_list|,
name|addr
parameter_list|)
name|bfd_vma
name|data
decl_stmt|;
specifier|register
name|bfd_byte
modifier|*
name|addr
decl_stmt|;
block|{
name|addr
index|[
literal|0
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|data
operator|>>
literal|24
argument_list|)
expr_stmt|;
name|addr
index|[
literal|1
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|data
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|addr
index|[
literal|2
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|data
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|addr
index|[
literal|3
index|]
operator|=
operator|(
name|bfd_byte
operator|)
name|data
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bfd_putl32
parameter_list|(
name|data
parameter_list|,
name|addr
parameter_list|)
name|bfd_vma
name|data
decl_stmt|;
specifier|register
name|bfd_byte
modifier|*
name|addr
decl_stmt|;
block|{
name|addr
index|[
literal|0
index|]
operator|=
operator|(
name|bfd_byte
operator|)
name|data
expr_stmt|;
name|addr
index|[
literal|1
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|data
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|addr
index|[
literal|2
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|data
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|addr
index|[
literal|3
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|data
operator|>>
literal|24
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bfd_putb64
parameter_list|(
name|data
parameter_list|,
name|addr
parameter_list|)
name|bfd_vma
name|data
decl_stmt|;
specifier|register
name|bfd_byte
modifier|*
name|addr
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|BFD64
name|addr
index|[
literal|0
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|data
operator|>>
operator|(
literal|7
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
name|addr
index|[
literal|1
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|data
operator|>>
operator|(
literal|6
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
name|addr
index|[
literal|2
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|data
operator|>>
operator|(
literal|5
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
name|addr
index|[
literal|3
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|data
operator|>>
operator|(
literal|4
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
name|addr
index|[
literal|4
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|data
operator|>>
operator|(
literal|3
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
name|addr
index|[
literal|5
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|data
operator|>>
operator|(
literal|2
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
name|addr
index|[
literal|6
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|data
operator|>>
operator|(
literal|1
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
name|addr
index|[
literal|7
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|data
operator|>>
operator|(
literal|0
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|BFD_FAIL
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|bfd_putl64
parameter_list|(
name|data
parameter_list|,
name|addr
parameter_list|)
name|bfd_vma
name|data
decl_stmt|;
specifier|register
name|bfd_byte
modifier|*
name|addr
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|BFD64
name|addr
index|[
literal|7
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|data
operator|>>
operator|(
literal|7
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
name|addr
index|[
literal|6
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|data
operator|>>
operator|(
literal|6
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
name|addr
index|[
literal|5
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|data
operator|>>
operator|(
literal|5
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
name|addr
index|[
literal|4
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|data
operator|>>
operator|(
literal|4
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
name|addr
index|[
literal|3
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|data
operator|>>
operator|(
literal|3
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
name|addr
index|[
literal|2
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|data
operator|>>
operator|(
literal|2
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
name|addr
index|[
literal|1
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|data
operator|>>
operator|(
literal|1
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
name|addr
index|[
literal|0
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|data
operator|>>
operator|(
literal|0
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|BFD_FAIL
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Default implementation */
end_comment

begin_function
name|boolean
name|_bfd_generic_get_section_contents
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|location
parameter_list|,
name|offset
parameter_list|,
name|count
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|sec_ptr
name|section
decl_stmt|;
name|PTR
name|location
decl_stmt|;
name|file_ptr
name|offset
decl_stmt|;
name|bfd_size_type
name|count
decl_stmt|;
block|{
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return
name|true
return|;
if|if
condition|(
call|(
name|bfd_size_type
call|)
argument_list|(
name|offset
operator|+
name|count
argument_list|)
operator|>
name|section
operator|->
name|_raw_size
operator|||
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
call|(
name|file_ptr
call|)
argument_list|(
name|section
operator|->
name|filepos
operator|+
name|offset
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|bfd_read
argument_list|(
name|location
argument_list|,
operator|(
name|bfd_size_type
operator|)
literal|1
argument_list|,
name|count
argument_list|,
name|abfd
argument_list|)
operator|!=
name|count
condition|)
return|return
operator|(
name|false
operator|)
return|;
comment|/* on error */
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_comment
comment|/* This generic function can only be used in implementations where creating    NEW sections is disallowed.  It is useful in patching existing sections    in read-write files, though.  See other set_section_contents functions    to see why it doesn't work for new sections.  */
end_comment

begin_function
name|boolean
name|_bfd_generic_set_section_contents
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|location
parameter_list|,
name|offset
parameter_list|,
name|count
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|sec_ptr
name|section
decl_stmt|;
name|PTR
name|location
decl_stmt|;
name|file_ptr
name|offset
decl_stmt|;
name|bfd_size_type
name|count
decl_stmt|;
block|{
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return
name|true
return|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
call|(
name|file_ptr
call|)
argument_list|(
name|section
operator|->
name|filepos
operator|+
name|offset
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|bfd_write
argument_list|(
name|location
argument_list|,
operator|(
name|bfd_size_type
operator|)
literal|1
argument_list|,
name|count
argument_list|,
name|abfd
argument_list|)
operator|!=
name|count
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* INTERNAL_FUNCTION 	bfd_log2  SYNOPSIS 	unsigned int bfd_log2(bfd_vma x);  DESCRIPTION 	Return the log base 2 of the value supplied, rounded up.  E.g., an 	@var{x} of 1025 returns 11. */
end_comment

begin_function
name|unsigned
name|bfd_log2
parameter_list|(
name|x
parameter_list|)
name|bfd_vma
name|x
decl_stmt|;
block|{
name|unsigned
name|result
init|=
literal|0
decl_stmt|;
while|while
condition|(
call|(
name|bfd_vma
call|)
argument_list|(
literal|1
operator|<<
name|result
argument_list|)
operator|<
name|x
condition|)
name|result
operator|++
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|boolean
name|bfd_generic_is_local_label
parameter_list|(
name|abfd
parameter_list|,
name|sym
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asymbol
modifier|*
name|sym
decl_stmt|;
block|{
name|char
name|locals_prefix
init|=
operator|(
name|bfd_get_symbol_leading_char
argument_list|(
name|abfd
argument_list|)
operator|==
literal|'_'
operator|)
condition|?
literal|'L'
else|:
literal|'.'
decl_stmt|;
return|return
operator|(
name|sym
operator|->
name|name
index|[
literal|0
index|]
operator|==
name|locals_prefix
operator|)
return|;
block|}
end_function

end_unit

