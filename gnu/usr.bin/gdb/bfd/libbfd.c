begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Assorted BFD support routines, only used internally.    Copyright 1990, 1991, 1992 Free Software Foundation, Inc.    Written by Cygnus Support.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_comment
comment|/* SECTION 	libbfd  DESCRIPTION 	This file contains various routines which are used within BFD. 	They are not intended for export, but are documented here for 	completeness. */
end_comment

begin_decl_stmt
name|boolean
name|DEFUN
argument_list|(
name|_bfd_dummy_new_section_hook
argument_list|,
operator|(
name|ignore
operator|,
name|ignore_newsect
operator|)
argument_list|,
name|bfd
operator|*
name|ignore
name|AND
name|asection
operator|*
name|ignore_newsect
argument_list|)
block|{
return|return
name|true
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|boolean
name|DEFUN
argument_list|(
name|bfd_false
argument_list|,
operator|(
name|ignore
operator|)
argument_list|,
name|bfd
operator|*
name|ignore
argument_list|)
block|{
return|return
name|false
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|boolean
name|DEFUN
argument_list|(
name|bfd_true
argument_list|,
operator|(
name|ignore
operator|)
argument_list|,
name|bfd
operator|*
name|ignore
argument_list|)
block|{
return|return
name|true
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|PTR
name|DEFUN
argument_list|(
name|bfd_nullvoidptr
argument_list|,
operator|(
name|ignore
operator|)
argument_list|,
name|bfd
operator|*
name|ignore
argument_list|)
block|{
return|return
operator|(
name|PTR
operator|)
name|NULL
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|int
name|DEFUN
argument_list|(
name|bfd_0
argument_list|,
operator|(
name|ignore
operator|)
argument_list|,
name|bfd
operator|*
name|ignore
argument_list|)
block|{
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
name|DEFUN
argument_list|(
name|bfd_0u
argument_list|,
operator|(
name|ignore
operator|)
argument_list|,
name|bfd
operator|*
name|ignore
argument_list|)
block|{
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|void
name|DEFUN
argument_list|(
name|bfd_void
argument_list|,
operator|(
name|ignore
operator|)
argument_list|,
name|bfd
operator|*
name|ignore
argument_list|)
block|{ }
end_decl_stmt

begin_decl_stmt
name|boolean
name|DEFUN
argument_list|(
name|_bfd_dummy_core_file_matches_executable_p
argument_list|,
operator|(
name|ignore_core_bfd
operator|,
name|ignore_exec_bfd
operator|)
argument_list|,
name|bfd
operator|*
name|ignore_core_bfd
name|AND
name|bfd
operator|*
name|ignore_exec_bfd
argument_list|)
block|{
name|bfd_error
operator|=
name|invalid_operation
expr_stmt|;
return|return
name|false
return|;
block|}
end_decl_stmt

begin_comment
comment|/* of course you can't initialize a function to be the same as another, grr */
end_comment

begin_decl_stmt
name|char
modifier|*
name|DEFUN
argument_list|(
name|_bfd_dummy_core_file_failing_command
argument_list|,
operator|(
name|ignore_abfd
operator|)
argument_list|,
name|bfd
operator|*
name|ignore_abfd
argument_list|)
block|{
return|return
operator|(
name|char
operator|*
operator|)
name|NULL
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|int
name|DEFUN
argument_list|(
name|_bfd_dummy_core_file_failing_signal
argument_list|,
operator|(
name|ignore_abfd
operator|)
argument_list|,
name|bfd
operator|*
name|ignore_abfd
argument_list|)
block|{
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|bfd_target
modifier|*
name|DEFUN
argument_list|(
name|_bfd_dummy_target
argument_list|,
operator|(
name|ignore_abfd
operator|)
argument_list|,
name|bfd
operator|*
name|ignore_abfd
argument_list|)
block|{
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/** zalloc -- allocate and clear storage */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|zalloc
end_ifndef

begin_decl_stmt
name|char
modifier|*
name|DEFUN
argument_list|(
name|zalloc
argument_list|,
operator|(
name|size
operator|)
argument_list|,
name|bfd_size_type
name|size
argument_list|)
block|{
name|char
modifier|*
name|ptr
init|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|size_t
operator|)
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|ptr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|size
operator|!=
literal|0
operator|)
condition|)
name|memset
argument_list|(
name|ptr
argument_list|,
literal|0
argument_list|,
operator|(
name|size_t
operator|)
name|size
argument_list|)
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INTERNAL_FUNCTION 	bfd_xmalloc  SYNOPSIS 	PTR  bfd_xmalloc( bfd_size_type size);  DESCRIPTION 	Like malloc, but exit if no more memory.  */
end_comment

begin_comment
comment|/** There is major inconsistency in how running out of memory is handled.   Some routines return a NULL, and set bfd_error to no_memory.   However, obstack routines can't do this ... */
end_comment

begin_macro
name|DEFUN
argument_list|(
argument|PTR bfd_xmalloc
argument_list|,
argument|(size)
argument_list|,
argument|bfd_size_type size
argument_list|)
end_macro

begin_block
block|{
specifier|static
name|CONST
name|char
name|no_memory_message
index|[]
init|=
literal|"Virtual memory exhausted!\n"
decl_stmt|;
name|PTR
name|ptr
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
name|size
operator|=
literal|1
expr_stmt|;
name|ptr
operator|=
operator|(
name|PTR
operator|)
name|malloc
argument_list|(
operator|(
name|size_t
operator|)
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptr
condition|)
block|{
name|write
argument_list|(
literal|2
argument_list|,
name|no_memory_message
argument_list|,
sizeof|sizeof
argument_list|(
name|no_memory_message
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|ptr
return|;
block|}
end_block

begin_comment
comment|/* INTERNAL_FUNCTION 	bfd_xmalloc_by_size_t  SYNOPSIS 	PTR bfd_xmalloc_by_size_t ( size_t size);  DESCRIPTION 	Like malloc, but exit if no more memory. 	Uses size_t, so it's suitable for use as obstack_chunk_alloc.  */
end_comment

begin_decl_stmt
name|PTR
name|DEFUN
argument_list|(
name|bfd_xmalloc_by_size_t
argument_list|,
operator|(
name|size
operator|)
argument_list|,
name|size_t
name|size
argument_list|)
block|{
return|return
name|bfd_xmalloc
argument_list|(
operator|(
name|bfd_size_type
operator|)
name|size
argument_list|)
return|;
block|}
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Some IO code */
end_comment

begin_comment
comment|/* Note that archive entries don't have streams; they share their parent's.    This allows someone to play with the iostream behind BFD's back.     Also, note that the origin pointer points to the beginning of a file's    contents (0 for non-archive elements).  For archive entries this is the    first octet in the file, NOT the beginning of the archive header. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|DEFUN
argument_list|(
name|real_read
argument_list|,
operator|(
name|where
operator|,
name|a
operator|,
name|b
operator|,
name|file
operator|)
argument_list|,
name|PTR
name|where
name|AND
name|int
name|a
name|AND
name|int
name|b
name|AND
name|FILE
operator|*
name|file
argument_list|)
block|{
return|return
name|fread
argument_list|(
name|where
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|file
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|bfd_size_type
name|DEFUN
argument_list|(
name|bfd_read
argument_list|,
operator|(
name|ptr
operator|,
name|size
operator|,
name|nitems
operator|,
name|abfd
operator|)
argument_list|,
name|PTR
name|ptr
name|AND
name|bfd_size_type
name|size
name|AND
name|bfd_size_type
name|nitems
name|AND
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|int
name|nread
decl_stmt|;
name|nread
operator|=
name|real_read
argument_list|(
name|ptr
argument_list|,
literal|1
argument_list|,
call|(
name|int
call|)
argument_list|(
name|size
operator|*
name|nitems
argument_list|)
argument_list|,
name|bfd_cache_lookup
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FILE_OFFSET_IS_CHAR_INDEX
if|if
condition|(
name|nread
operator|>
literal|0
condition|)
name|abfd
operator|->
name|where
operator|+=
name|nread
expr_stmt|;
endif|#
directive|endif
return|return
name|nread
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|bfd_size_type
name|DEFUN
argument_list|(
name|bfd_write
argument_list|,
operator|(
name|ptr
operator|,
name|size
operator|,
name|nitems
operator|,
name|abfd
operator|)
argument_list|,
name|CONST
name|PTR
name|ptr
name|AND
name|bfd_size_type
name|size
name|AND
name|bfd_size_type
name|nitems
name|AND
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|int
name|nwrote
init|=
name|fwrite
argument_list|(
name|ptr
argument_list|,
literal|1
argument_list|,
call|(
name|int
call|)
argument_list|(
name|size
operator|*
name|nitems
argument_list|)
argument_list|,
name|bfd_cache_lookup
argument_list|(
name|abfd
argument_list|)
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|FILE_OFFSET_IS_CHAR_INDEX
if|if
condition|(
name|nwrote
operator|>
literal|0
condition|)
name|abfd
operator|->
name|where
operator|+=
name|nwrote
expr_stmt|;
endif|#
directive|endif
return|return
name|nwrote
return|;
block|}
end_decl_stmt

begin_comment
comment|/* INTERNAL_FUNCTION 	bfd_write_bigendian_4byte_int  SYNOPSIS 	void bfd_write_bigendian_4byte_int(bfd *abfd,  int i);  DESCRIPTION 	Writes a 4 byte integer to the outputing bfd, in big endian 	mode regardless of what else is going on.  This is useful in 	archives.  */
end_comment

begin_decl_stmt
name|void
name|DEFUN
argument_list|(
name|bfd_write_bigendian_4byte_int
argument_list|,
operator|(
name|abfd
operator|,
name|i
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|int
name|i
argument_list|)
block|{
name|bfd_byte
name|buffer
index|[
literal|4
index|]
decl_stmt|;
name|bfd_putb32
argument_list|(
name|i
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|buffer
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|long
name|DEFUN
argument_list|(
name|bfd_tell
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|file_ptr
name|ptr
decl_stmt|;
name|ptr
operator|=
name|ftell
argument_list|(
name|bfd_cache_lookup
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|my_archive
condition|)
name|ptr
operator|-=
name|abfd
operator|->
name|origin
expr_stmt|;
name|abfd
operator|->
name|where
operator|=
name|ptr
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|int
name|DEFUN
argument_list|(
name|bfd_flush
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
return|return
name|fflush
argument_list|(
name|bfd_cache_lookup
argument_list|(
name|abfd
argument_list|)
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|int
name|DEFUN
argument_list|(
name|bfd_stat
argument_list|,
operator|(
name|abfd
operator|,
name|statbuf
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
expr|struct
name|stat
operator|*
name|statbuf
argument_list|)
block|{
return|return
name|fstat
argument_list|(
name|fileno
argument_list|(
name|bfd_cache_lookup
argument_list|(
name|abfd
argument_list|)
argument_list|)
argument_list|,
name|statbuf
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|int
name|DEFUN
argument_list|(
name|bfd_seek
argument_list|,
operator|(
name|abfd
operator|,
name|position
operator|,
name|direction
operator|)
argument_list|,
name|bfd
operator|*
name|CONST
name|abfd
name|AND
name|CONST
name|file_ptr
name|position
name|AND
name|CONST
name|int
name|direction
argument_list|)
block|{
name|int
name|result
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|file_ptr
name|file_position
decl_stmt|;
comment|/* For the time being, a BFD may not seek to it's end.  The problem      is that we don't easily have a way to recognize the end of an      element in an archive. */
name|BFD_ASSERT
argument_list|(
name|direction
operator|==
name|SEEK_SET
operator|||
name|direction
operator|==
name|SEEK_CUR
argument_list|)
expr_stmt|;
if|if
condition|(
name|direction
operator|==
name|SEEK_CUR
operator|&&
name|position
operator|==
literal|0
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|FILE_OFFSET_IS_CHAR_INDEX
if|if
condition|(
name|abfd
operator|->
name|format
operator|!=
name|bfd_archive
operator|&&
name|abfd
operator|->
name|my_archive
operator|==
literal|0
condition|)
block|{
ifndef|#
directive|ifndef
name|NDEBUG
comment|/* Explanation for this code: I'm only about 95+% sure that the above 	 conditions are sufficient and that all i/o calls are properly 	 adjusting the `where' field.  So this is sort of an `assert' 	 that the `where' field is correct.  If we can go a while without 	 tripping the abort, we can probably safely disable this code, 	 so that the real optimizations happen.  */
name|file_ptr
name|where_am_i_now
decl_stmt|;
name|where_am_i_now
operator|=
name|ftell
argument_list|(
name|bfd_cache_lookup
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|my_archive
condition|)
name|where_am_i_now
operator|-=
name|abfd
operator|->
name|origin
expr_stmt|;
if|if
condition|(
name|where_am_i_now
operator|!=
name|abfd
operator|->
name|where
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|direction
operator|==
name|SEEK_SET
operator|&&
name|position
operator|==
name|abfd
operator|->
name|where
condition|)
return|return
literal|0
return|;
block|}
else|else
block|{
comment|/* We need something smarter to optimize access to archives. 	 Currently, anything inside an archive is read via the file 	 handle for the archive.  Which means that a bfd_seek on one 	 component affects the `current position' in the archive, as 	 well as in any other component.  	 It might be sufficient to put a spike through the cache 	 abstraction, and look to the archive for the file position, 	 but I think we should try for something cleaner.  	 In the meantime, no optimization for archives.  */
block|}
endif|#
directive|endif
name|f
operator|=
name|bfd_cache_lookup
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|file_position
operator|=
name|position
expr_stmt|;
if|if
condition|(
name|direction
operator|==
name|SEEK_SET
operator|&&
name|abfd
operator|->
name|my_archive
operator|!=
name|NULL
condition|)
name|file_position
operator|+=
name|abfd
operator|->
name|origin
expr_stmt|;
name|result
operator|=
name|fseek
argument_list|(
name|f
argument_list|,
name|file_position
argument_list|,
name|direction
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
comment|/* Force redetermination of `where' field.  */
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|FILE_OFFSET_IS_CHAR_INDEX
comment|/* Adjust `where' field.  */
if|if
condition|(
name|direction
operator|==
name|SEEK_SET
condition|)
name|abfd
operator|->
name|where
operator|=
name|position
expr_stmt|;
else|else
name|abfd
operator|->
name|where
operator|+=
name|position
expr_stmt|;
endif|#
directive|endif
block|}
return|return
name|result
return|;
block|}
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/** Make a string table */
end_comment

begin_comment
comment|/*>bfd.h<  Add string to table pointed to by table, at location starting with free_ptr.    resizes the table if necessary (if it's NULL, creates it, ignoring    table_length).  Updates free_ptr, table, table_length */
end_comment

begin_decl_stmt
name|boolean
name|DEFUN
argument_list|(
name|bfd_add_to_string_table
argument_list|,
operator|(
name|table
operator|,
name|new_string
operator|,
name|table_length
operator|,
name|free_ptr
operator|)
argument_list|,
name|char
operator|*
operator|*
name|table
name|AND
name|char
operator|*
name|new_string
name|AND
name|unsigned
name|int
operator|*
name|table_length
name|AND
name|char
operator|*
operator|*
name|free_ptr
argument_list|)
block|{
name|size_t
name|string_length
init|=
name|strlen
argument_list|(
name|new_string
argument_list|)
operator|+
literal|1
decl_stmt|;
comment|/* include null here */
name|char
modifier|*
name|base
init|=
operator|*
name|table
decl_stmt|;
name|size_t
name|space_length
init|=
operator|*
name|table_length
decl_stmt|;
name|unsigned
name|int
name|offset
init|=
operator|(
name|base
condition|?
operator|*
name|free_ptr
operator|-
name|base
else|:
literal|0
operator|)
decl_stmt|;
if|if
condition|(
name|base
operator|==
name|NULL
condition|)
block|{
comment|/* Avoid a useless regrow if we can (but of course we still        take it next time */
name|space_length
operator|=
operator|(
name|string_length
operator|<
name|DEFAULT_STRING_SPACE_SIZE
condition|?
name|DEFAULT_STRING_SPACE_SIZE
else|:
name|string_length
operator|+
literal|1
operator|)
expr_stmt|;
name|base
operator|=
name|zalloc
argument_list|(
operator|(
name|bfd_size_type
operator|)
name|space_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
if|if
condition|(
call|(
name|size_t
call|)
argument_list|(
name|offset
operator|+
name|string_length
argument_list|)
operator|>=
name|space_length
condition|)
block|{
comment|/* Make sure we will have enough space */
while|while
condition|(
call|(
name|size_t
call|)
argument_list|(
name|offset
operator|+
name|string_length
argument_list|)
operator|>=
name|space_length
condition|)
name|space_length
operator|+=
name|space_length
operator|/
literal|2
expr_stmt|;
comment|/* grow by 50% */
name|base
operator|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
name|base
argument_list|,
name|space_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
name|memcpy
argument_list|(
name|base
operator|+
name|offset
argument_list|,
name|new_string
argument_list|,
name|string_length
argument_list|)
expr_stmt|;
operator|*
name|table
operator|=
name|base
expr_stmt|;
operator|*
name|table_length
operator|=
name|space_length
expr_stmt|;
operator|*
name|free_ptr
operator|=
name|base
operator|+
name|offset
operator|+
name|string_length
expr_stmt|;
return|return
name|true
return|;
block|}
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/** The do-it-yourself (byte) sex-change kit */
end_comment

begin_comment
comment|/* The middle letter e.g. get<b>short indicates Big or Little endian    target machine.  It doesn't matter what the byte order of the host    machine is; these routines work for either.  */
end_comment

begin_comment
comment|/* FIXME: Should these take a count argument?    Answer (gnu@cygnus.com):  No, but perhaps they should be inline                              functions in swap.h #ifdef __GNUC__.                               Gprof them later and find out.  */
end_comment

begin_comment
comment|/* FUNCTION 	bfd_put_size FUNCTION 	bfd_get_size  DESCRIPTION 	These macros as used for reading and writing raw data in 	sections; each access (except for bytes) is vectored through 	the target format of the BFD and mangled accordingly. The 	mangling performs any necessary endian translations and 	removes alignment restrictions.  Note that types accepted and 	returned by these macros are identical so they can be swapped 	around in macros--for example libaout.h defines GET_WORD to 	either bfd_get_32 or bfd_get_64.  	In the put routines, val must be a bfd_vma.  If we are on a 	system without prototypes, the caller is responsible for making 	sure that is true, with a cast if necessary.  We don't cast 	them in the macro definitions because that would prevent lint 	or gcc -Wall from detecting sins such as passing a pointer. 	To detect calling these with less than a bfd_vma, use gcc 	-Wconversion on a host with 64 bit bfd_vma's.  . .{* Byte swapping macros for user section data.  *} . .#define bfd_put_8(abfd, val, ptr) \ .                (*((unsigned char *)(ptr)) = (unsigned char)val) .#define bfd_put_signed_8 \ .		bfd_put_8 .#define bfd_get_8(abfd, ptr) \ .                (*(unsigned char *)(ptr)) .#define bfd_get_signed_8(abfd, ptr) \ .		((*(unsigned char *)(ptr) ^ 0x80) - 0x80) . .#define bfd_put_16(abfd, val, ptr) \ .                BFD_SEND(abfd, bfd_putx16, ((val),(ptr))) .#define bfd_put_signed_16 \ .		 bfd_put_16 .#define bfd_get_16(abfd, ptr) \ .                BFD_SEND(abfd, bfd_getx16, (ptr)) .#define bfd_get_signed_16(abfd, ptr) \ .         	 BFD_SEND (abfd, bfd_getx_signed_16, (ptr)) . .#define bfd_put_32(abfd, val, ptr) \ .                BFD_SEND(abfd, bfd_putx32, ((val),(ptr))) .#define bfd_put_signed_32 \ .		 bfd_put_32 .#define bfd_get_32(abfd, ptr) \ .                BFD_SEND(abfd, bfd_getx32, (ptr)) .#define bfd_get_signed_32(abfd, ptr) \ .		 BFD_SEND(abfd, bfd_getx_signed_32, (ptr)) . .#define bfd_put_64(abfd, val, ptr) \ .                BFD_SEND(abfd, bfd_putx64, ((val), (ptr))) .#define bfd_put_signed_64 \ .		 bfd_put_64 .#define bfd_get_64(abfd, ptr) \ .                BFD_SEND(abfd, bfd_getx64, (ptr)) .#define bfd_get_signed_64(abfd, ptr) \ .		 BFD_SEND(abfd, bfd_getx_signed_64, (ptr)) . */
end_comment

begin_comment
comment|/* FUNCTION 	bfd_h_put_size FUNCTION 	bfd_h_get_size  DESCRIPTION 	These macros have the same function as their<<bfd_get_x>> 	bretherin, except that they are used for removing information 	for the header records of object files. Believe it or not, 	some object files keep their header records in big endian 	order, and their data in little endian order. . .{* Byte swapping macros for file header data.  *} . .#define bfd_h_put_8(abfd, val, ptr) \ .		bfd_put_8 (abfd, val, ptr) .#define bfd_h_put_signed_8(abfd, val, ptr) \ .		bfd_put_8 (abfd, val, ptr) .#define bfd_h_get_8(abfd, ptr) \ .		bfd_get_8 (abfd, ptr) .#define bfd_h_get_signed_8(abfd, ptr) \ .		bfd_get_signed_8 (abfd, ptr) . .#define bfd_h_put_16(abfd, val, ptr) \ .                BFD_SEND(abfd, bfd_h_putx16,(val,ptr)) .#define bfd_h_put_signed_16 \ .		 bfd_h_put_16 .#define bfd_h_get_16(abfd, ptr) \ .                BFD_SEND(abfd, bfd_h_getx16,(ptr)) .#define bfd_h_get_signed_16(abfd, ptr) \ .		 BFD_SEND(abfd, bfd_h_getx_signed_16, (ptr)) . .#define bfd_h_put_32(abfd, val, ptr) \ .                BFD_SEND(abfd, bfd_h_putx32,(val,ptr)) .#define bfd_h_put_signed_32 \ .		 bfd_h_put_32 .#define bfd_h_get_32(abfd, ptr) \ .                BFD_SEND(abfd, bfd_h_getx32,(ptr)) .#define bfd_h_get_signed_32(abfd, ptr) \ .		 BFD_SEND(abfd, bfd_h_getx_signed_32, (ptr)) . .#define bfd_h_put_64(abfd, val, ptr) \ .                BFD_SEND(abfd, bfd_h_putx64,(val, ptr)) .#define bfd_h_put_signed_64 \ .		 bfd_h_put_64 .#define bfd_h_get_64(abfd, ptr) \ .                BFD_SEND(abfd, bfd_h_getx64,(ptr)) .#define bfd_h_get_signed_64(abfd, ptr) \ .		 BFD_SEND(abfd, bfd_h_getx_signed_64, (ptr)) . */
end_comment

begin_comment
comment|/* Sign extension to bfd_signed_vma.  */
end_comment

begin_define
define|#
directive|define
name|COERCE16
parameter_list|(
name|x
parameter_list|)
value|(((bfd_signed_vma) (x) ^ 0x8000) - 0x8000)
end_define

begin_define
define|#
directive|define
name|COERCE32
parameter_list|(
name|x
parameter_list|)
value|(((bfd_signed_vma) (x) ^ 0x80000000) - 0x80000000)
end_define

begin_define
define|#
directive|define
name|EIGHT_GAZILLION
value|(((HOST_64_BIT)0x80000000)<< 32)
end_define

begin_define
define|#
directive|define
name|COERCE64
parameter_list|(
name|x
parameter_list|)
define|\
value|(((bfd_signed_vma) (x) ^ EIGHT_GAZILLION) - EIGHT_GAZILLION)
end_define

begin_decl_stmt
name|bfd_vma
name|DEFUN
argument_list|(
name|bfd_getb16
argument_list|,
operator|(
name|addr
operator|)
argument_list|,
specifier|register
name|bfd_byte
operator|*
name|addr
argument_list|)
block|{
return|return
operator|(
name|addr
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|1
index|]
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|bfd_vma
name|DEFUN
argument_list|(
name|bfd_getl16
argument_list|,
operator|(
name|addr
operator|)
argument_list|,
specifier|register
name|bfd_byte
operator|*
name|addr
argument_list|)
block|{
return|return
operator|(
name|addr
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|0
index|]
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|bfd_signed_vma
name|DEFUN
argument_list|(
name|bfd_getb_signed_16
argument_list|,
operator|(
name|addr
operator|)
argument_list|,
specifier|register
name|bfd_byte
operator|*
name|addr
argument_list|)
block|{
return|return
name|COERCE16
argument_list|(
operator|(
name|addr
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|1
index|]
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|bfd_signed_vma
name|DEFUN
argument_list|(
name|bfd_getl_signed_16
argument_list|,
operator|(
name|addr
operator|)
argument_list|,
specifier|register
name|bfd_byte
operator|*
name|addr
argument_list|)
block|{
return|return
name|COERCE16
argument_list|(
operator|(
name|addr
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|0
index|]
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|void
name|DEFUN
argument_list|(
name|bfd_putb16
argument_list|,
operator|(
name|data
operator|,
name|addr
operator|)
argument_list|,
name|bfd_vma
name|data
name|AND
specifier|register
name|bfd_byte
operator|*
name|addr
argument_list|)
block|{
name|addr
index|[
literal|0
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|data
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|addr
index|[
literal|1
index|]
operator|=
operator|(
name|bfd_byte
operator|)
name|data
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|void
name|DEFUN
argument_list|(
name|bfd_putl16
argument_list|,
operator|(
name|data
operator|,
name|addr
operator|)
argument_list|,
name|bfd_vma
name|data
name|AND
specifier|register
name|bfd_byte
operator|*
name|addr
argument_list|)
block|{
name|addr
index|[
literal|0
index|]
operator|=
operator|(
name|bfd_byte
operator|)
name|data
expr_stmt|;
name|addr
index|[
literal|1
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|data
operator|>>
literal|8
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_function
name|bfd_vma
name|bfd_getb32
parameter_list|(
name|addr
parameter_list|)
specifier|register
name|bfd_byte
modifier|*
name|addr
decl_stmt|;
block|{
return|return
operator|(
operator|(
operator|(
operator|(
operator|(
name|bfd_vma
operator|)
name|addr
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|1
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|2
index|]
operator|)
operator|<<
literal|8
operator||
name|addr
index|[
literal|3
index|]
return|;
block|}
end_function

begin_function
name|bfd_vma
name|bfd_getl32
parameter_list|(
name|addr
parameter_list|)
specifier|register
name|bfd_byte
modifier|*
name|addr
decl_stmt|;
block|{
return|return
operator|(
operator|(
operator|(
operator|(
operator|(
name|bfd_vma
operator|)
name|addr
index|[
literal|3
index|]
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|2
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|1
index|]
operator|)
operator|<<
literal|8
operator||
name|addr
index|[
literal|0
index|]
return|;
block|}
end_function

begin_function
name|bfd_signed_vma
name|bfd_getb_signed_32
parameter_list|(
name|addr
parameter_list|)
specifier|register
name|bfd_byte
modifier|*
name|addr
decl_stmt|;
block|{
return|return
name|COERCE32
argument_list|(
operator|(
operator|(
operator|(
operator|(
operator|(
name|bfd_vma
operator|)
name|addr
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|1
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|2
index|]
operator|)
operator|<<
literal|8
operator||
name|addr
index|[
literal|3
index|]
argument_list|)
return|;
block|}
end_function

begin_function
name|bfd_signed_vma
name|bfd_getl_signed_32
parameter_list|(
name|addr
parameter_list|)
specifier|register
name|bfd_byte
modifier|*
name|addr
decl_stmt|;
block|{
return|return
name|COERCE32
argument_list|(
operator|(
operator|(
operator|(
operator|(
operator|(
name|bfd_vma
operator|)
name|addr
index|[
literal|3
index|]
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|2
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|1
index|]
operator|)
operator|<<
literal|8
operator||
name|addr
index|[
literal|0
index|]
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
name|bfd_vma
name|DEFUN
argument_list|(
name|bfd_getb64
argument_list|,
operator|(
name|addr
operator|)
argument_list|,
specifier|register
name|bfd_byte
operator|*
name|addr
argument_list|)
block|{
ifdef|#
directive|ifdef
name|BFD64
name|bfd_vma
name|low
decl_stmt|,
name|high
decl_stmt|;
name|high
operator|=
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
name|addr
index|[
literal|0
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|1
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|2
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|3
index|]
operator|)
operator|)
expr_stmt|;
name|low
operator|=
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
name|bfd_vma
operator|)
name|addr
index|[
literal|4
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|5
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|6
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|7
index|]
operator|)
operator|)
expr_stmt|;
return|return
name|high
operator|<<
literal|32
operator||
name|low
return|;
else|#
directive|else
name|BFD_FAIL
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
endif|#
directive|endif
block|}
end_decl_stmt

begin_decl_stmt
name|bfd_vma
name|DEFUN
argument_list|(
name|bfd_getl64
argument_list|,
operator|(
name|addr
operator|)
argument_list|,
specifier|register
name|bfd_byte
operator|*
name|addr
argument_list|)
block|{
ifdef|#
directive|ifdef
name|BFD64
name|bfd_vma
name|low
decl_stmt|,
name|high
decl_stmt|;
name|high
operator|=
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
name|addr
index|[
literal|7
index|]
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|6
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|5
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|4
index|]
operator|)
operator|)
expr_stmt|;
name|low
operator|=
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
name|bfd_vma
operator|)
name|addr
index|[
literal|3
index|]
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|2
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|1
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|0
index|]
operator|)
operator|)
expr_stmt|;
return|return
name|high
operator|<<
literal|32
operator||
name|low
return|;
else|#
directive|else
name|BFD_FAIL
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
endif|#
directive|endif
block|}
end_decl_stmt

begin_decl_stmt
name|bfd_signed_vma
name|DEFUN
argument_list|(
name|bfd_getb_signed_64
argument_list|,
operator|(
name|addr
operator|)
argument_list|,
specifier|register
name|bfd_byte
operator|*
name|addr
argument_list|)
block|{
ifdef|#
directive|ifdef
name|BFD64
name|bfd_vma
name|low
decl_stmt|,
name|high
decl_stmt|;
name|high
operator|=
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
name|addr
index|[
literal|0
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|1
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|2
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|3
index|]
operator|)
operator|)
expr_stmt|;
name|low
operator|=
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
name|bfd_vma
operator|)
name|addr
index|[
literal|4
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|5
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|6
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|7
index|]
operator|)
operator|)
expr_stmt|;
return|return
name|COERCE64
argument_list|(
name|high
operator|<<
literal|32
operator||
name|low
argument_list|)
return|;
else|#
directive|else
name|BFD_FAIL
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
endif|#
directive|endif
block|}
end_decl_stmt

begin_decl_stmt
name|bfd_signed_vma
name|DEFUN
argument_list|(
name|bfd_getl_signed_64
argument_list|,
operator|(
name|addr
operator|)
argument_list|,
specifier|register
name|bfd_byte
operator|*
name|addr
argument_list|)
block|{
ifdef|#
directive|ifdef
name|BFD64
name|bfd_vma
name|low
decl_stmt|,
name|high
decl_stmt|;
name|high
operator|=
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
name|addr
index|[
literal|7
index|]
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|6
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|5
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|4
index|]
operator|)
operator|)
expr_stmt|;
name|low
operator|=
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
name|bfd_vma
operator|)
name|addr
index|[
literal|3
index|]
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|2
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|1
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|0
index|]
operator|)
operator|)
expr_stmt|;
return|return
name|COERCE64
argument_list|(
name|high
operator|<<
literal|32
operator||
name|low
argument_list|)
return|;
else|#
directive|else
name|BFD_FAIL
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
endif|#
directive|endif
block|}
end_decl_stmt

begin_decl_stmt
name|void
name|DEFUN
argument_list|(
name|bfd_putb32
argument_list|,
operator|(
name|data
operator|,
name|addr
operator|)
argument_list|,
name|bfd_vma
name|data
name|AND
specifier|register
name|bfd_byte
operator|*
name|addr
argument_list|)
block|{
name|addr
index|[
literal|0
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|data
operator|>>
literal|24
argument_list|)
expr_stmt|;
name|addr
index|[
literal|1
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|data
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|addr
index|[
literal|2
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|data
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|addr
index|[
literal|3
index|]
operator|=
operator|(
name|bfd_byte
operator|)
name|data
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|void
name|DEFUN
argument_list|(
name|bfd_putl32
argument_list|,
operator|(
name|data
operator|,
name|addr
operator|)
argument_list|,
name|bfd_vma
name|data
name|AND
specifier|register
name|bfd_byte
operator|*
name|addr
argument_list|)
block|{
name|addr
index|[
literal|0
index|]
operator|=
operator|(
name|bfd_byte
operator|)
name|data
expr_stmt|;
name|addr
index|[
literal|1
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|data
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|addr
index|[
literal|2
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|data
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|addr
index|[
literal|3
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|data
operator|>>
literal|24
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|void
name|DEFUN
argument_list|(
name|bfd_putb64
argument_list|,
operator|(
name|data
operator|,
name|addr
operator|)
argument_list|,
name|bfd_vma
name|data
name|AND
specifier|register
name|bfd_byte
operator|*
name|addr
argument_list|)
block|{
ifdef|#
directive|ifdef
name|BFD64
name|addr
index|[
literal|0
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|data
operator|>>
operator|(
literal|7
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
name|addr
index|[
literal|1
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|data
operator|>>
operator|(
literal|6
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
name|addr
index|[
literal|2
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|data
operator|>>
operator|(
literal|5
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
name|addr
index|[
literal|3
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|data
operator|>>
operator|(
literal|4
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
name|addr
index|[
literal|4
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|data
operator|>>
operator|(
literal|3
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
name|addr
index|[
literal|5
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|data
operator|>>
operator|(
literal|2
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
name|addr
index|[
literal|6
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|data
operator|>>
operator|(
literal|1
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
name|addr
index|[
literal|7
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|data
operator|>>
operator|(
literal|0
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|BFD_FAIL
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_decl_stmt

begin_decl_stmt
name|void
name|DEFUN
argument_list|(
name|bfd_putl64
argument_list|,
operator|(
name|data
operator|,
name|addr
operator|)
argument_list|,
name|bfd_vma
name|data
name|AND
specifier|register
name|bfd_byte
operator|*
name|addr
argument_list|)
block|{
ifdef|#
directive|ifdef
name|BFD64
name|addr
index|[
literal|7
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|data
operator|>>
operator|(
literal|7
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
name|addr
index|[
literal|6
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|data
operator|>>
operator|(
literal|6
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
name|addr
index|[
literal|5
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|data
operator|>>
operator|(
literal|5
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
name|addr
index|[
literal|4
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|data
operator|>>
operator|(
literal|4
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
name|addr
index|[
literal|3
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|data
operator|>>
operator|(
literal|3
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
name|addr
index|[
literal|2
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|data
operator|>>
operator|(
literal|2
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
name|addr
index|[
literal|1
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|data
operator|>>
operator|(
literal|1
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
name|addr
index|[
literal|0
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|data
operator|>>
operator|(
literal|0
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|BFD_FAIL
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Default implementation */
end_comment

begin_decl_stmt
name|boolean
name|DEFUN
argument_list|(
name|bfd_generic_get_section_contents
argument_list|,
operator|(
name|abfd
operator|,
name|section
operator|,
name|location
operator|,
name|offset
operator|,
name|count
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|sec_ptr
name|section
name|AND
name|PTR
name|location
name|AND
name|file_ptr
name|offset
name|AND
name|bfd_size_type
name|count
argument_list|)
block|{
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return
name|true
return|;
if|if
condition|(
call|(
name|bfd_size_type
call|)
argument_list|(
name|offset
operator|+
name|count
argument_list|)
operator|>
name|section
operator|->
name|_raw_size
operator|||
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
call|(
name|file_ptr
call|)
argument_list|(
name|section
operator|->
name|filepos
operator|+
name|offset
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|bfd_read
argument_list|(
name|location
argument_list|,
operator|(
name|bfd_size_type
operator|)
literal|1
argument_list|,
name|count
argument_list|,
name|abfd
argument_list|)
operator|!=
name|count
condition|)
return|return
operator|(
name|false
operator|)
return|;
comment|/* on error */
return|return
operator|(
name|true
operator|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/* This generic function can only be used in implementations where creating    NEW sections is disallowed.  It is useful in patching existing sections    in read-write files, though.  See other set_section_contents functions    to see why it doesn't work for new sections.  */
end_comment

begin_decl_stmt
name|boolean
name|DEFUN
argument_list|(
name|bfd_generic_set_section_contents
argument_list|,
operator|(
name|abfd
operator|,
name|section
operator|,
name|location
operator|,
name|offset
operator|,
name|count
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|sec_ptr
name|section
name|AND
name|PTR
name|location
name|AND
name|file_ptr
name|offset
name|AND
name|bfd_size_type
name|count
argument_list|)
block|{
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return
name|true
return|;
if|if
condition|(
call|(
name|bfd_size_type
call|)
argument_list|(
name|offset
operator|+
name|count
argument_list|)
operator|>
name|bfd_get_section_size_after_reloc
argument_list|(
name|section
argument_list|)
operator|||
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
call|(
name|file_ptr
call|)
argument_list|(
name|section
operator|->
name|filepos
operator|+
name|offset
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|bfd_write
argument_list|(
name|location
argument_list|,
operator|(
name|bfd_size_type
operator|)
literal|1
argument_list|,
name|count
argument_list|,
name|abfd
argument_list|)
operator|!=
name|count
condition|)
return|return
operator|(
name|false
operator|)
return|;
comment|/* on error */
return|return
operator|(
name|true
operator|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/* INTERNAL_FUNCTION 	bfd_log2  DESCRIPTION 	Return the log base 2 of the value supplied, rounded up. eg an 	arg of 1025 would return 11.  SYNOPSIS 	unsigned int bfd_log2(bfd_vma x); */
end_comment

begin_function
name|unsigned
name|bfd_log2
parameter_list|(
name|x
parameter_list|)
name|bfd_vma
name|x
decl_stmt|;
block|{
name|unsigned
name|result
init|=
literal|0
decl_stmt|;
while|while
condition|(
call|(
name|bfd_vma
call|)
argument_list|(
literal|1
operator|<<
name|result
argument_list|)
operator|<
name|x
condition|)
name|result
operator|++
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

end_unit

