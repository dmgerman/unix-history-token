begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Generic target-file-type support for the BFD library.    Copyright 1990, 1991, 1992, 1993 Free Software Foundation, Inc.    Written by Cygnus Support.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_comment
comment|/* SECTION  	Targets  DESCRIPTION 	Each port of BFD to a different machine requries the creation 	of a target back end. All the back end provides to the root 	part of BFD is a structure containing pointers to functions 	which perform certain low level operations on files. BFD 	translates the applications's requests through a pointer into 	calls to the back end routines.   	When a file is opened with<<bfd_openr>>, its format and 	target are unknown. BFD uses various mechanisms to determine 	how to interpret the file. The operations performed are:  	o First a BFD is created by calling the internal routine<<new_bfd>>, then<<bfd_find_target>> is called with the 	target string supplied to<<bfd_openr>> and the new BFD pointer.   	o If a null target string was provided to<<bfd_find_target>>, 	it looks up the environment variable<<GNUTARGET>> and uses 	that as the target string.   	o If the target string is still NULL, or the target string is<<default>>, then the first item in the target vector is used 	as the target type, and<<target_defaulted>> is set to 	cause<<bfd_check_format>> to loop through all the targets. 	@xref{bfd_target}.  @xref{Formats}.  	o Otherwise, the elements in the target vector are inspected 	one by one, until a match on target name is found. When found, 	that is used.   	o Otherwise the error<<invalid_target>> is returned to<<bfd_openr>>.  	o<<bfd_openr>> attempts to open the file using<<bfd_open_file>>, and returns the BFD.  	Once the BFD has been opened and the target selected, the file 	format may be determined. This is done by calling<<bfd_check_format>> on the BFD with a suggested format.  	If<<target_defaulted>> has been set, each possible target 	type is tried to see if it recognizes the specified format.  The 	routine returns<<true>> when the application guesses right. @menu @* bfd_target:: @end menu */
end_comment

begin_comment
comment|/*  INODE 	bfd_target,  , Targets, Targets DOCDD SUBSECTION 	bfd_target  DESCRIPTION 	This structure contains everything that BFD knows about a 	target. It includes things like its byte order, name, what 	routines to call to do various operations, etc.     	Every BFD points to a target structure with its<<xvec>> 	member.   	These macros are used to dispatch to functions through the 	bfd_target vector. They are used in a number of macros further 	down in @file{bfd.h}, and are also used when calling various 	routines by hand inside the BFD implementation.  The "arglist" 	argument must be parenthesized; it contains all the arguments 	to the called function.   	They make the documentation (more) unpleasant to read, so if 	someone wants to fix this and not break the above, please do.  .#define BFD_SEND(bfd, message, arglist) \ .               ((*((bfd)->xvec->message)) arglist)  	For operations which index on the BFD format   .#define BFD_SEND_FMT(bfd, message, arglist) \ .            (((bfd)->xvec->message[(int)((bfd)->format)]) arglist)  	This is the struct which defines the type of BFD this is.  The<<xvec>> member of the struct<<bfd>> itself points here.  Each 	module that implements access to a different target under BFD, 	defines one of these.   	FIXME, these names should be rationalised with the names of 	the entry points which call them. Too bad we can't have one 	macro to define them both!   .typedef struct bfd_target .{  Identifies the kind of target, eg SunOS4, Ultrix, etc.  .  char *name;  The "flavour" of a back end is a general indication about the contents of a file.  .  enum target_flavour { .    bfd_target_unknown_flavour, .    bfd_target_aout_flavour, .    bfd_target_coff_flavour, .    bfd_target_ecoff_flavour, .    bfd_target_elf_flavour, .    bfd_target_ieee_flavour, .    bfd_target_nlm_flavour, .    bfd_target_oasys_flavour, .    bfd_target_tekhex_flavour, .    bfd_target_srec_flavour, .    bfd_target_hppa_flavour} flavour;  The order of bytes within the data area of a file.  .  boolean byteorder_big_p;  The order of bytes within the header parts of a file.  .  boolean header_byteorder_big_p;  This is a mask of all the flags which an executable may have set - from the set<<NO_FLAGS>>,<<HAS_RELOC>>, ...<<D_PAGED>>.  .  flagword object_flags;         This is a mask of all the flags which a section may have set - from the set<<SEC_NO_FLAGS>>,<<SEC_ALLOC>>, ...<<SET_NEVER_LOAD>>.  .  flagword section_flags;  The character normally found at the front of a symbol  (if any), perhaps _.  .  char symbol_leading_char;  The pad character for filenames within an archive header.  .  char ar_pad_char;              The maximum number of characters in an archive header.  .  unsigned short ar_max_namelen;  The minimum alignment restriction for any section.  .  unsigned int align_power_min;  Entries for byte swapping for data. These are different to the other entry points, since they don't take BFD as first arg.  Certain other handlers could do the same.  .  bfd_vma      (*bfd_getx64) PARAMS ((bfd_byte *)); .  bfd_signed_vma (*bfd_getx_signed_64) PARAMS ((bfd_byte *)); .  void         (*bfd_putx64) PARAMS ((bfd_vma, bfd_byte *)); .  bfd_vma      (*bfd_getx32) PARAMS ((bfd_byte *)); .  bfd_signed_vma (*bfd_getx_signed_32) PARAMS ((bfd_byte *)); .  void         (*bfd_putx32) PARAMS ((bfd_vma, bfd_byte *)); .  bfd_vma      (*bfd_getx16) PARAMS ((bfd_byte *)); .  bfd_signed_vma (*bfd_getx_signed_16) PARAMS ((bfd_byte *)); .  void         (*bfd_putx16) PARAMS ((bfd_vma, bfd_byte *));  Byte swapping for the headers  .  bfd_vma      (*bfd_h_getx64) PARAMS ((bfd_byte *)); .  bfd_signed_vma (*bfd_h_getx_signed_64) PARAMS ((bfd_byte *)); .  void         (*bfd_h_putx64) PARAMS ((bfd_vma, bfd_byte *)); .  bfd_vma      (*bfd_h_getx32) PARAMS ((bfd_byte *)); .  bfd_signed_vma (*bfd_h_getx_signed_32) PARAMS ((bfd_byte *)); .  void         (*bfd_h_putx32) PARAMS ((bfd_vma, bfd_byte *)); .  bfd_vma      (*bfd_h_getx16) PARAMS ((bfd_byte *)); .  bfd_signed_vma (*bfd_h_getx_signed_16) PARAMS ((bfd_byte *)); .  void         (*bfd_h_putx16) PARAMS ((bfd_vma, bfd_byte *));  Format dependent routines: these are vectors of entry points within the target vector structure, one for each format to check.  Check the format of a file being read.  Return bfd_target * or zero.   .  struct bfd_target * (*_bfd_check_format[bfd_type_end]) PARAMS ((bfd *));  Set the format of a file being written.    .  boolean             (*_bfd_set_format[bfd_type_end]) PARAMS ((bfd *));  Write cached information into a file being written, at bfd_close.   .  boolean             (*_bfd_write_contents[bfd_type_end]) PARAMS ((bfd *));  The following functions are defined in<<JUMP_TABLE>>. The idea is that the back end writer of<<foo>> names all the routines<<foo_>>@var{entry_point},<<JUMP_TABLE>> will built the entries in this structure in the right order.  Core file entry points  .  char *   (*_core_file_failing_command) PARAMS ((bfd *)); .  int      (*_core_file_failing_signal) PARAMS ((bfd *)); .  boolean  (*_core_file_matches_executable_p) PARAMS ((bfd *, bfd *));  Archive entry points  .  boolean  (*_bfd_slurp_armap) PARAMS ((bfd *)); .  boolean  (*_bfd_slurp_extended_name_table) PARAMS ((bfd *)); .  void     (*_bfd_truncate_arname) PARAMS ((bfd *, CONST char *, char *)); .  boolean  (*write_armap) PARAMS ((bfd *arch,  .                              unsigned int elength, .                              struct orl *map, .                              unsigned int orl_count,  .                              int stridx));  Standard stuff.  .  boolean       (*_close_and_cleanup) PARAMS ((bfd *)); .  boolean       (*_bfd_set_section_contents) PARAMS ((bfd *, sec_ptr, PTR, .                                            file_ptr, bfd_size_type)); .  boolean       (*_bfd_get_section_contents) PARAMS ((bfd *, sec_ptr, PTR,  .                                            file_ptr, bfd_size_type)); .  boolean       (*_new_section_hook) PARAMS ((bfd *, sec_ptr));  Symbols and relocations  .  unsigned int  (*_get_symtab_upper_bound) PARAMS ((bfd *)); .  unsigned int  (*_bfd_canonicalize_symtab) PARAMS ((bfd *, .                                              struct symbol_cache_entry **)); .  unsigned int  (*_get_reloc_upper_bound) PARAMS ((bfd *, sec_ptr)); .  unsigned int  (*_bfd_canonicalize_reloc) PARAMS ((bfd *, sec_ptr, arelent **, .                                              struct symbol_cache_entry **)); .  struct symbol_cache_entry  * .                (*_bfd_make_empty_symbol) PARAMS ((bfd *)); .  void          (*_bfd_print_symbol) PARAMS ((bfd *, PTR, .                                      struct symbol_cache_entry *, .                                      bfd_print_symbol_type)); .#define bfd_print_symbol(b,p,s,e) BFD_SEND(b, _bfd_print_symbol, (b,p,s,e)) .  void          (*_bfd_get_symbol_info) PARAMS ((bfd *, .                                      struct symbol_cache_entry *, .                                      symbol_info *)); .#define bfd_get_symbol_info(b,p,e) BFD_SEND(b, _bfd_get_symbol_info, (b,p,e))  .  alent *    (*_get_lineno) PARAMS ((bfd *, struct symbol_cache_entry *)); . .  boolean    (*_bfd_set_arch_mach) PARAMS ((bfd *, enum bfd_architecture, .                    unsigned long)); . .  bfd *      (*openr_next_archived_file) PARAMS ((bfd *arch, bfd *prev)); .  .  boolean    (*_bfd_find_nearest_line) PARAMS ((bfd *abfd, .                    struct sec *section, struct symbol_cache_entry **symbols, .                    bfd_vma offset, CONST char **file, CONST char **func, .                    unsigned int *line)); .  .  int        (*_bfd_stat_arch_elt) PARAMS ((bfd *, struct stat *)); . .  int        (*_bfd_sizeof_headers) PARAMS ((bfd *, boolean)); . .  void       (*_bfd_debug_info_start) PARAMS ((bfd *)); .  void       (*_bfd_debug_info_end) PARAMS ((bfd *)); .  void       (*_bfd_debug_info_accumulate) PARAMS ((bfd *, struct sec *)); . .  bfd_byte * (*_bfd_get_relocated_section_contents) PARAMS ((bfd *, .                    struct bfd_seclet *, bfd_byte *data, .                    boolean relocateable)); . .  boolean    (*_bfd_relax_section) PARAMS ((bfd *, struct sec *, .                    struct symbol_cache_entry **)); . .  boolean    (*_bfd_seclet_link) PARAMS ((bfd *, PTR data, .                     boolean relocateable));  . {* See documentation on reloc types.  *} . CONST struct reloc_howto_struct * .       (*reloc_type_lookup) PARAMS ((bfd *abfd, .                                     bfd_reloc_code_real_type code)); . . {* Back-door to allow format-aware applications to create debug symbols .    while using BFD for everything else.  Currently used by the assembler .    when creating COFF files.  *} . asymbol *  (*_bfd_make_debug_symbol) PARAMS (( .       bfd *abfd, .       void *ptr, .       unsigned long size));  Data for use by back-end routines, which isn't generic enough to belong in this structure.  . PTR backend_data; .} bfd_target;  */
end_comment

begin_comment
comment|/* All known xvecs (even those that don't compile on all systems).    Alphabetized for easy reference.    They are listed a second time below, since    we can't intermix extern's and initializers.  */
end_comment

begin_decl_stmt
specifier|extern
name|bfd_target
name|a29kcoff_big_vec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_target
name|a_out_adobe_vec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_target
name|aout_mips_big_vec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_target
name|aout_mips_little_vec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_target
name|apollocoff_vec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_target
name|b_out_vec_big_host
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_target
name|b_out_vec_little_host
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_target
name|bfd_elf32_big_generic_vec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_target
name|bfd_elf32_bigmips_vec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_target
name|bfd_elf32_hppa_vec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_target
name|bfd_elf32_i386_vec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_target
name|bfd_elf32_i860_vec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_target
name|bfd_elf32_little_generic_vec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_target
name|bfd_elf32_littlemips_vec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_target
name|bfd_elf32_m68k_vec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_target
name|bfd_elf32_m88k_vec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_target
name|bfd_elf32_sparc_vec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_target
name|bfd_elf64_big_generic_vec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_target
name|bfd_elf64_little_generic_vec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_target
name|demo_64_vec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_target
name|ecoff_big_vec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_target
name|ecoff_little_vec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_target
name|ecoffalpha_little_vec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_target
name|h8300coff_vec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_target
name|h8500coff_vec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_target
name|host_aout_vec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_target
name|hp300bsd_vec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_target
name|hp300hpux_vec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_target
name|hppa_vec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_target
name|i386aout_vec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_target
name|i386bsd_vec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_target
name|netbsd386_vec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_target
name|freebsd386_vec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_target
name|i386coff_vec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_target
name|i386linux_vec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_target
name|i386lynx_aout_vec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_target
name|i386lynx_coff_vec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_target
name|icoff_big_vec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_target
name|icoff_little_vec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_target
name|ieee_vec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_target
name|m68kcoff_vec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_target
name|m68kcoffun_vec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_target
name|m68klynx_aout_vec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_target
name|m68klynx_coff_vec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_target
name|m88kbcs_vec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_target
name|newsos3_vec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_target
name|nlm32_big_generic_vec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_target
name|nlm32_i386_vec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_target
name|nlm32_little_generic_vec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_target
name|nlm64_big_generic_vec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_target
name|nlm64_little_generic_vec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_target
name|oasys_vec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_target
name|rs6000coff_vec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_target
name|shcoff_vec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_target
name|sunos_big_vec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_target
name|tekhex_vec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_target
name|we32kcoff_vec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_target
name|z8kcoff_vec
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* srec is always included.  */
end_comment

begin_decl_stmt
specifier|extern
name|bfd_target
name|srec_vec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_target
name|symbolsrec_vec
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* All of the xvecs for core files.  */
end_comment

begin_decl_stmt
specifier|extern
name|bfd_target
name|aix386_core_vec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_target
name|hpux_core_vec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_target
name|osf_core_vec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_target
name|sco_core_vec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_target
name|trad_core_vec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd_target
modifier|*
name|target_vector
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|SELECT_VECS
name|SELECT_VECS
block|,
else|#
directive|else
comment|/* not SELECT_VECS */
ifdef|#
directive|ifdef
name|DEFAULT_VECTOR
operator|&
name|DEFAULT_VECTOR
block|,
endif|#
directive|endif
comment|/* This list is alphabetized to make it easy to compare 	   with other vector lists -- the decls above and 	   the case statement in configure.in. 	   Vectors that don't compile on all systems, or aren't finished, 	   should have an entry here with #if 0 around it, to show that 	   it wasn't omitted by mistake.  */
operator|&
name|a29kcoff_big_vec
block|,
operator|&
name|a_out_adobe_vec
block|,
if|#
directive|if
literal|0
comment|/* No one seems to use this.  */
block|&aout_mips_big_vec,
endif|#
directive|endif
operator|&
name|aout_mips_little_vec
block|,
operator|&
name|b_out_vec_big_host
block|,
operator|&
name|b_out_vec_little_host
block|,
if|#
directive|if
literal|0
comment|/* No one seems to use this.  */
block|&bfd_elf32_big_generic_vec,&bfd_elf32_bigmips_vec,
endif|#
directive|endif
if|#
directive|if
literal|0
block|&bfd_elf32_hppa_vec,
endif|#
directive|endif
operator|&
name|bfd_elf32_i386_vec
block|,
operator|&
name|bfd_elf32_i860_vec
block|,
if|#
directive|if
literal|0
comment|/* No one seems to use this.  */
block|&bfd_elf32_little_generic_vec,&bfd_elf32_littlemips_vec,
endif|#
directive|endif
operator|&
name|bfd_elf32_m68k_vec
block|,
operator|&
name|bfd_elf32_m88k_vec
block|,
operator|&
name|bfd_elf32_sparc_vec
block|,
ifdef|#
directive|ifdef
name|BFD64
comment|/* No one seems to use this.  */
operator|&
name|bfd_elf64_big_generic_vec
block|,
operator|&
name|bfd_elf64_little_generic_vec
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BFD64
operator|&
name|demo_64_vec
block|,
comment|/* Only compiled if host has long-long support */
endif|#
directive|endif
operator|&
name|ecoff_big_vec
block|,
operator|&
name|ecoff_little_vec
block|,
if|#
directive|if
literal|0
block|&ecoffalpha_little_vec,
endif|#
directive|endif
operator|&
name|h8300coff_vec
block|,
operator|&
name|h8500coff_vec
block|,
if|#
directive|if
literal|0
block|&host_aout_vec,
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/* Clashes with sunos_big_vec magic no.  */
block|&hp300bsd_vec,
endif|#
directive|endif
operator|&
name|hp300hpux_vec
block|,
if|#
directive|if
name|defined
argument_list|(
name|HOST_HPPAHPUX
argument_list|)
operator|||
name|defined
argument_list|(
name|HOST_HPPABSD
argument_list|)
operator|&
name|hppa_vec
block|,
endif|#
directive|endif
operator|&
name|i386aout_vec
block|,
operator|&
name|i386bsd_vec
block|,
operator|&
name|netbsd386_vec
block|,
operator|&
name|freebsd386_vec
block|,
operator|&
name|i386coff_vec
block|,
if|#
directive|if
literal|0
block|&i386linux_vec,
endif|#
directive|endif
operator|&
name|i386lynx_aout_vec
block|,
operator|&
name|i386lynx_coff_vec
block|,
operator|&
name|icoff_big_vec
block|,
operator|&
name|icoff_little_vec
block|,
operator|&
name|ieee_vec
block|,
operator|&
name|m68kcoff_vec
block|,
operator|&
name|m68kcoffun_vec
block|,
operator|&
name|m68klynx_aout_vec
block|,
operator|&
name|m68klynx_coff_vec
block|,
operator|&
name|m88kbcs_vec
block|,
operator|&
name|newsos3_vec
block|,
if|#
directive|if
literal|0
comment|/* No one seems to use this.  */
block|&nlm32_big_generic_vec,
endif|#
directive|endif
operator|&
name|nlm32_i386_vec
block|,
if|#
directive|if
literal|0
comment|/* No one seems to use this.  */
block|&nlm32_little_generic_vec,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BFD64
operator|&
name|nlm64_big_generic_vec
block|,
operator|&
name|nlm64_little_generic_vec
block|,
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/* We have no oasys tools anymore, so we can't test any of this 	   anymore. If you want to test the stuff yourself, go ahead... 	   steve@cygnus.com 	   Worse, since there is no magic number for archives, there 	   can be annoying target mis-matches.  */
block|&oasys_vec,
endif|#
directive|endif
operator|&
name|rs6000coff_vec
block|,
operator|&
name|shcoff_vec
block|,
operator|&
name|sunos_big_vec
block|,
if|#
directive|if
literal|0
block|&tekhex_vec,
endif|#
directive|endif
operator|&
name|we32kcoff_vec
block|,
operator|&
name|z8kcoff_vec
block|,
endif|#
directive|endif
comment|/* not SELECT_VECS */
comment|/* Always support S-records, for convenience.  */
operator|&
name|srec_vec
block|,
operator|&
name|symbolsrec_vec
block|,
comment|/* Add any required traditional-core-file-handler.  */
ifdef|#
directive|ifdef
name|AIX386_CORE
operator|&
name|aix386_core_vec
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HPUX_CORE
operator|&
name|hpux_core_vec
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OSF_CORE
operator|&
name|osf_core_vec
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SCO_CORE
operator|&
name|sco_core_vec
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TRAD_CORE
operator|&
name|trad_core_vec
block|,
endif|#
directive|endif
name|NULL
comment|/* end of list marker */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* default_vector[0] contains either the address of the default vector,    if there is one, or zero if there isn't.  */
end_comment

begin_decl_stmt
name|bfd_target
modifier|*
name|default_vector
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|DEFAULT_VECTOR
operator|&
name|DEFAULT_VECTOR
block|,
endif|#
directive|endif
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* FUNCTION 	bfd_find_target  DESCRIPTION 	Returns a pointer to the transfer vector for the object target 	named target_name.  If target_name is NULL, chooses the one in 	the environment variable GNUTARGET; if that is null or not 	defined thenthe first entry in the target list is chosen. 	Passing in the string "default" or setting the environment 	variable to "default" will cause the first entry in the target 	list to be returned, and "target_defaulted" will be set in the 	BFD.  This causes<<bfd_check_format>> to loop over all the 	targets to find the one that matches the file being read.     SYNOPSIS 	bfd_target *bfd_find_target(CONST char *, bfd *); */
end_comment

begin_decl_stmt
name|bfd_target
modifier|*
name|DEFUN
argument_list|(
name|bfd_find_target
argument_list|,
operator|(
name|target_name
operator|,
name|abfd
operator|)
argument_list|,
name|CONST
name|char
operator|*
name|target_name
name|AND
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|bfd_target
modifier|*
modifier|*
name|target
decl_stmt|;
specifier|extern
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
name|CONST
name|char
modifier|*
name|targname
init|=
operator|(
name|target_name
condition|?
name|target_name
else|:
operator|(
name|CONST
name|char
operator|*
operator|)
name|getenv
argument_list|(
literal|"GNUTARGET"
argument_list|)
operator|)
decl_stmt|;
comment|/* This is safe; the vector cannot be null */
if|if
condition|(
name|targname
operator|==
name|NULL
operator|||
operator|!
name|strcmp
argument_list|(
name|targname
argument_list|,
literal|"default"
argument_list|)
condition|)
block|{
name|abfd
operator|->
name|target_defaulted
operator|=
name|true
expr_stmt|;
return|return
name|abfd
operator|->
name|xvec
operator|=
name|target_vector
index|[
literal|0
index|]
return|;
block|}
name|abfd
operator|->
name|target_defaulted
operator|=
name|false
expr_stmt|;
for|for
control|(
name|target
operator|=
operator|&
name|target_vector
index|[
literal|0
index|]
init|;
operator|*
name|target
operator|!=
name|NULL
condition|;
name|target
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|targname
argument_list|,
operator|(
operator|*
name|target
operator|)
operator|->
name|name
argument_list|)
condition|)
return|return
name|abfd
operator|->
name|xvec
operator|=
operator|*
name|target
return|;
block|}
name|bfd_error
operator|=
name|invalid_target
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_decl_stmt

begin_comment
comment|/* FUNCTION 	bfd_target_list  DESCRIPTION 	This function returns a freshly malloced NULL-terminated 	vector of the names of all the valid BFD targets. Do not 	modify the names   SYNOPSIS 	CONST char **bfd_target_list(void);  */
end_comment

begin_function
name|CONST
name|char
modifier|*
modifier|*
name|DEFUN_VOID
parameter_list|(
name|bfd_target_list
parameter_list|)
block|{
name|int
name|vec_length
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|NATIVE_HPPAHPUX_COMPILER
comment|/* The native compiler on the HP9000/700 has a bug which causes it      to loop endlessly when compiling this file.  This avoids it.  */
specifier|volatile
endif|#
directive|endif
name|bfd_target
modifier|*
modifier|*
name|target
decl_stmt|;
name|CONST
name|char
modifier|*
modifier|*
name|name_list
decl_stmt|,
modifier|*
modifier|*
name|name_ptr
decl_stmt|;
for|for
control|(
name|target
operator|=
operator|&
name|target_vector
index|[
literal|0
index|]
init|;
operator|*
name|target
operator|!=
name|NULL
condition|;
name|target
operator|++
control|)
name|vec_length
operator|++
expr_stmt|;
name|name_ptr
operator|=
name|name_list
operator|=
operator|(
name|CONST
name|char
operator|*
operator|*
operator|)
name|zalloc
argument_list|(
operator|(
name|vec_length
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|name_list
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
name|NULL
return|;
block|}
for|for
control|(
name|target
operator|=
operator|&
name|target_vector
index|[
literal|0
index|]
init|;
operator|*
name|target
operator|!=
name|NULL
condition|;
name|target
operator|++
control|)
operator|*
operator|(
name|name_ptr
operator|++
operator|)
operator|=
operator|(
operator|*
name|target
operator|)
operator|->
name|name
expr_stmt|;
return|return
name|name_list
return|;
block|}
end_function

end_unit

