begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BFD library support routines for architectures.    Copyright (C) 1990-1991 Free Software Foundation, Inc.    Hacked by John Gilmore and Steve Chamberlain of Cygnus Support.   This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/*  SECTION 	Architectures  	BFD's idea of an architecture is implimented in<<archures.c>>. BFD keeps one atom in a BFD describing the 	architecture of the data attached to the BFD;  a pointer to a<<bfd_arch_info_type>>.    	Pointers to structures can be requested independently of a bfd 	so that an architecture's information can be interrogated 	without access to an open bfd.  	The arch information is provided by each architecture package. 	The set of default architectures is selected by the #define<<SELECT_ARCHITECTURES>>.  This is normally set up in the<<config/target.mt>> file of your choice.  If the name is not 	defined, then all the architectures supported are included.   	When BFD starts up, all the architectures are called with an 	initialize method.  It is up to the architecture back end to 	insert as many items into the list of architectures as it wants to; 	generally this would be one for each machine and one for the 	default case (an item with a machine field of 0).  */
end_comment

begin_comment
comment|/*  SUBSECTION 	bfd_architecture  DESCRIPTION 	This enum gives the object file's CPU architecture, in a 	global sense --- i.e., what processor family does it belong to? 	There is another field, which indicates what processor within 	the family is in use.  The machine gives a number which 	distingushes different versions of the architecture, 	containing for example 2 and 3 for Intel i960 KA and i960 KB, 	and 68020 and 68030 for Motorola 68020 and 68030.   .enum bfd_architecture  .{ .  bfd_arch_unknown,   {* File arch not known *} .  bfd_arch_obscure,   {* Arch known, not one of these *} .  bfd_arch_m68k,      {* Motorola 68xxx *} .  bfd_arch_vax,       {* DEC Vax *}    .  bfd_arch_i960,      {* Intel 960 *} .    {* The order of the following is important. .       lower number indicates a machine type that  .       only accepts a subset of the instructions .       available to machines with higher numbers. .       The exception is the "ca", which is .       incompatible with all other machines except  .       "core". *} . .#define bfd_mach_i960_core      1 .#define bfd_mach_i960_ka_sa     2 .#define bfd_mach_i960_kb_sb     3 .#define bfd_mach_i960_mc        4 .#define bfd_mach_i960_xa        5 .#define bfd_mach_i960_ca        6 . .  bfd_arch_a29k,      {* AMD 29000 *} .  bfd_arch_sparc,     {* SPARC *} .  bfd_arch_mips,      {* MIPS Rxxxx *} .  bfd_arch_i386,      {* Intel 386 *} .  bfd_arch_we32k,     {* AT&T WE32xxx *} .  bfd_arch_tahoe,     {* CCI/Harris Tahoe *} .  bfd_arch_i860,      {* Intel 860 *} .  bfd_arch_romp,      {* IBM ROMP PC/RT *} .  bfd_arch_alliant,   {* Alliant *} .  bfd_arch_convex,    {* Convex *} .  bfd_arch_m88k,      {* Motorola 88xxx *} .  bfd_arch_pyramid,   {* Pyramid Technology *} .  bfd_arch_h8300,     {* Hitachi H8/300 *} .#define bfd_mach_h8300   1 .#define bfd_mach_h8300h  2 .  bfd_arch_rs6000,    {* IBM RS/6000 *} .  bfd_arch_hppa,      {* HP PA RISC *} .  bfd_arch_z8k,       {* Zilog Z8000 *} .#define bfd_mach_z8001		1 .#define bfd_mach_z8002		2 .  bfd_arch_h8500,     {* Hitachi H8/500 *} .  bfd_arch_sh,        {* Hitachi SH *} .  bfd_arch_alpha,     {* Dec Alpha *} .  bfd_arch_last .  };   */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_comment
comment|/*  SUBSECTION 	bfd_arch_info  DESCRIPTION 	This structure contains information on architectures for use 	within BFD.  . .typedef struct bfd_arch_info  .{ .  int bits_per_word; .  int bits_per_address; .  int bits_per_byte; .  enum bfd_architecture arch; .  long mach; .  char *arch_name; .  CONST  char *printable_name; .  unsigned int section_align_power; . {* true if this is the default machine for the architecture *} .  boolean the_default;	 .  CONST struct bfd_arch_info * (*compatible) .	PARAMS ((CONST struct bfd_arch_info *a, .	         CONST struct bfd_arch_info *b)); . .  boolean (*scan) PARAMS ((CONST struct bfd_arch_info *, CONST char *)); .  {* How to disassemble an instruction, producing a printable .     representation on a specified stdio stream.  This isn't .     defined for most processors at present, because of the size .     of the additional tables it would drag in, and because gdb .     wants to use a different interface.  *} .  unsigned int (*disassemble) PARAMS ((bfd_vma addr, CONST char *data, .				        PTR stream)); . .  struct bfd_arch_info *next; .} bfd_arch_info_type; */
end_comment

begin_decl_stmt
name|bfd_arch_info_type
modifier|*
name|bfd_arch_info_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* FUNCTION 	bfd_printable_name  SYNOPSIS 	CONST char *bfd_printable_name(bfd *abfd);  DESCRIPTION 	Return a printable string representing the architecture and machine 	from the pointer to the arch info structure   */
end_comment

begin_decl_stmt
name|CONST
name|char
modifier|*
name|DEFUN
argument_list|(
name|bfd_printable_name
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
return|return
name|abfd
operator|->
name|arch_info
operator|->
name|printable_name
return|;
block|}
end_decl_stmt

begin_comment
comment|/* FUNCTION 	bfd_scan_arch  SYNOPSIS 	bfd_arch_info_type *bfd_scan_arch(CONST char *);  DESCRIPTION 	This routine is provided with a string and tries to work out 	if bfd supports any cpu which could be described with the name 	provided.  The routine returns a pointer to an arch_info 	structure if a machine is found, otherwise NULL.  */
end_comment

begin_decl_stmt
name|bfd_arch_info_type
modifier|*
name|DEFUN
argument_list|(
name|bfd_scan_arch
argument_list|,
operator|(
name|string
operator|)
argument_list|,
name|CONST
name|char
operator|*
name|string
argument_list|)
block|{
name|struct
name|bfd_arch_info
modifier|*
name|ap
decl_stmt|;
comment|/* Look through all the installed architectures */
for|for
control|(
name|ap
operator|=
name|bfd_arch_info_list
init|;
name|ap
operator|!=
operator|(
name|bfd_arch_info_type
operator|*
operator|)
name|NULL
condition|;
name|ap
operator|=
name|ap
operator|->
name|next
control|)
block|{
if|if
condition|(
name|ap
operator|->
name|scan
argument_list|(
name|ap
argument_list|,
name|string
argument_list|)
condition|)
return|return
name|ap
return|;
block|}
return|return
operator|(
name|bfd_arch_info_type
operator|*
operator|)
name|NULL
return|;
block|}
end_decl_stmt

begin_comment
comment|/* FUNCTION 	bfd_arch_get_compatible  SYNOPSIS 	CONST bfd_arch_info_type *bfd_arch_get_compatible( 		CONST bfd *abfd, 	        CONST bfd *bbfd);  DESCRIPTION 	This routine is used to determine whether two BFDs' 	architectures and achine types are compatible.  It calculates 	the lowest common denominator between the two architectures 	and machine types implied by the BFDs and returns a pointer to 	an arch_info structure describing the compatible machine. */
end_comment

begin_decl_stmt
name|CONST
name|bfd_arch_info_type
modifier|*
name|DEFUN
argument_list|(
name|bfd_arch_get_compatible
argument_list|,
operator|(
name|abfd
operator|,
name|bbfd
operator|)
argument_list|,
name|CONST
name|bfd
operator|*
name|abfd
name|AND
name|CONST
name|bfd
operator|*
name|bbfd
argument_list|)
block|{
return|return
name|abfd
operator|->
name|arch_info
operator|->
name|compatible
argument_list|(
name|abfd
operator|->
name|arch_info
argument_list|,
name|bbfd
operator|->
name|arch_info
argument_list|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/* INTERNAL_DEFINITION 	bfd_default_arch_struct  DESCRIPTION 	The<<bfd_default_arch_struct>> is an item of<<bfd_arch_info_type>> which has been initialized to a fairly 	generic state.  A BFD starts life by pointing to this 	structure, until the correct back end has determined the real 	architecture of the file.  .extern bfd_arch_info_type bfd_default_arch_struct;  */
end_comment

begin_decl_stmt
name|bfd_arch_info_type
name|bfd_default_arch_struct
init|=
block|{
literal|32
block|,
literal|32
block|,
literal|8
block|,
name|bfd_arch_unknown
block|,
literal|0
block|,
literal|"unknown"
block|,
literal|"unknown"
block|,
literal|2
block|,
name|true
block|,
name|bfd_default_compatible
block|,
name|bfd_default_scan
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* FUNCTION 	bfd_set_arch_info  SYNOPSIS 	void bfd_set_arch_info(bfd *, bfd_arch_info_type *);  */
end_comment

begin_decl_stmt
name|void
name|DEFUN
argument_list|(
name|bfd_set_arch_info
argument_list|,
operator|(
name|abfd
operator|,
name|arg
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|bfd_arch_info_type
operator|*
name|arg
argument_list|)
block|{
name|abfd
operator|->
name|arch_info
operator|=
name|arg
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* INTERNAL_FUNCTION 	bfd_default_set_arch_mach  SYNOPSIS 	boolean bfd_default_set_arch_mach(bfd *abfd, 		enum bfd_architecture arch, 		unsigned long mach);  DESCRIPTION 	Set the architecture and machine type in a bfd. This finds the 	correct pointer to structure and inserts it into the arch_info 	pointer.  */
end_comment

begin_decl_stmt
name|boolean
name|DEFUN
argument_list|(
name|bfd_default_set_arch_mach
argument_list|,
operator|(
name|abfd
operator|,
name|arch
operator|,
name|mach
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
expr|enum
name|bfd_architecture
name|arch
name|AND
name|unsigned
name|long
name|mach
argument_list|)
block|{
specifier|static
name|struct
name|bfd_arch_info
modifier|*
name|old_ptr
init|=
operator|&
name|bfd_default_arch_struct
decl_stmt|;
name|boolean
name|found
init|=
name|false
decl_stmt|;
comment|/* run through the table to find the one we want, we keep a little      cache to speed things up */
if|if
condition|(
name|old_ptr
operator|==
literal|0
operator|||
name|arch
operator|!=
name|old_ptr
operator|->
name|arch
operator|||
name|mach
operator|!=
name|old_ptr
operator|->
name|mach
condition|)
block|{
name|bfd_arch_info_type
modifier|*
name|ptr
decl_stmt|;
name|old_ptr
operator|=
operator|(
name|bfd_arch_info_type
operator|*
operator|)
name|NULL
expr_stmt|;
for|for
control|(
name|ptr
operator|=
name|bfd_arch_info_list
init|;
name|ptr
operator|!=
operator|(
name|bfd_arch_info_type
operator|*
operator|)
name|NULL
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|ptr
operator|->
name|arch
operator|==
name|arch
operator|&&
operator|(
operator|(
name|ptr
operator|->
name|mach
operator|==
name|mach
operator|)
operator|||
operator|(
name|ptr
operator|->
name|the_default
operator|&&
name|mach
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|old_ptr
operator|=
name|ptr
expr_stmt|;
name|found
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|found
operator|==
name|false
condition|)
block|{
comment|/*looked for it and it wasn't there, so put in the default */
name|old_ptr
operator|=
operator|&
name|bfd_default_arch_struct
expr_stmt|;
name|bfd_error
operator|=
name|bad_value
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* it was in the cache */
name|found
operator|=
name|true
expr_stmt|;
block|}
name|abfd
operator|->
name|arch_info
operator|=
name|old_ptr
expr_stmt|;
return|return
name|found
return|;
block|}
end_decl_stmt

begin_comment
comment|/* FUNCTION 	bfd_get_arch  SYNOPSIS 	enum bfd_architecture bfd_get_arch(bfd *abfd);  DESCRIPTION 	Returns the enumerated type which describes the supplied bfd's 	architecture  */
end_comment

begin_decl_stmt
name|enum
name|bfd_architecture
name|DEFUN
argument_list|(
name|bfd_get_arch
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
return|return
name|abfd
operator|->
name|arch_info
operator|->
name|arch
return|;
block|}
end_decl_stmt

begin_comment
comment|/* FUNCTION 	bfd_get_mach  SYNOPSIS 	unsigned long bfd_get_mach(bfd *abfd);  DESCRIPTION 	Returns the long type which describes the supplied bfd's 	machine */
end_comment

begin_decl_stmt
name|unsigned
name|long
name|DEFUN
argument_list|(
name|bfd_get_mach
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
return|return
name|abfd
operator|->
name|arch_info
operator|->
name|mach
return|;
block|}
end_decl_stmt

begin_comment
comment|/* FUNCTION 	bfd_arch_bits_per_byte  SYNOPSIS 	unsigned int bfd_arch_bits_per_byte(bfd *abfd);  DESCRIPTION 	Returns the number of bits in one of the architectures bytes  */
end_comment

begin_decl_stmt
name|unsigned
name|int
name|DEFUN
argument_list|(
name|bfd_arch_bits_per_byte
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
return|return
name|abfd
operator|->
name|arch_info
operator|->
name|bits_per_byte
return|;
block|}
end_decl_stmt

begin_comment
comment|/* FUNCTION 	bfd_arch_bits_per_address  SYNOPSIS 	unsigned int bfd_arch_bits_per_address(bfd *abfd);  DESCRIPTION 	Returns the number of bits in one of the architectures addresses */
end_comment

begin_decl_stmt
name|unsigned
name|int
name|DEFUN
argument_list|(
name|bfd_arch_bits_per_address
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
return|return
name|abfd
operator|->
name|arch_info
operator|->
name|bits_per_address
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_a29k_arch
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_alpha_arch
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_h8300_arch
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_h8500_arch
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_hppa_arch
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_i386_arch
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_i960_arch
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_m68k_arch
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_m88k_arch
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_mips_arch
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_rs6000_arch
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_sh_arch
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_sparc_arch
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_vax_arch
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_we32k_arch
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_z8k_arch
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|void
argument_list|(
argument|*archures_init_table[]
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
operator|=
block|{
ifdef|#
directive|ifdef
name|SELECT_ARCHITECTURES
name|SELECT_ARCHITECTURES
block|,
else|#
directive|else
name|bfd_a29k_arch
block|,
name|bfd_alpha_arch
block|,
name|bfd_h8300_arch
block|,
name|bfd_h8500_arch
block|,
name|bfd_hppa_arch
block|,
name|bfd_i386_arch
block|,
name|bfd_i960_arch
block|,
name|bfd_m68k_arch
block|,
name|bfd_m88k_arch
block|,
name|bfd_mips_arch
block|,
name|bfd_rs6000_arch
block|,
name|bfd_sh_arch
block|,
name|bfd_sparc_arch
block|,
name|bfd_vax_arch
block|,
name|bfd_we32k_arch
block|,
name|bfd_z8k_arch
block|,
endif|#
directive|endif
literal|0
block|}
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* INTERNAL_FUNCTION  	bfd_arch_init  SYNOPSIS 	void  bfd_arch_init(void);  DESCRIPTION 	This routine initializes the architecture dispatch table by 	calling all installed architecture packages and getting them 	to poke around. */
end_comment

begin_function
name|void
name|DEFUN_VOID
parameter_list|(
name|bfd_arch_init
parameter_list|)
block|{
name|void
argument_list|(
argument|**ptable
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|ptable
operator|=
name|archures_init_table
init|;
operator|*
name|ptable
condition|;
name|ptable
operator|++
control|)
block|{
call|(
modifier|*
name|ptable
call|)
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* INTERNAL_FUNCTION 	bfd_arch_linkin  SYNOPSIS 	void bfd_arch_linkin(bfd_arch_info_type *);  DESCRIPTION 	Link the provided arch info structure into the list */
end_comment

begin_decl_stmt
name|void
name|DEFUN
argument_list|(
name|bfd_arch_linkin
argument_list|,
operator|(
name|ptr
operator|)
argument_list|,
name|bfd_arch_info_type
operator|*
name|ptr
argument_list|)
block|{
name|ptr
operator|->
name|next
operator|=
name|bfd_arch_info_list
expr_stmt|;
name|bfd_arch_info_list
operator|=
name|ptr
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* INTERNAL_FUNCTION  	bfd_default_compatible  SYNOPSIS 	CONST bfd_arch_info_type *bfd_default_compatible 	(CONST bfd_arch_info_type *a, 	CONST bfd_arch_info_type *b);  DESCRIPTION 	The default function for testing for compatibility. */
end_comment

begin_decl_stmt
name|CONST
name|bfd_arch_info_type
modifier|*
name|DEFUN
argument_list|(
name|bfd_default_compatible
argument_list|,
operator|(
name|a
operator|,
name|b
operator|)
argument_list|,
name|CONST
name|bfd_arch_info_type
operator|*
name|a
name|AND
name|CONST
name|bfd_arch_info_type
operator|*
name|b
argument_list|)
block|{
if|if
condition|(
name|a
operator|->
name|arch
operator|!=
name|b
operator|->
name|arch
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|a
operator|->
name|mach
operator|>
name|b
operator|->
name|mach
condition|)
block|{
return|return
name|a
return|;
block|}
if|if
condition|(
name|b
operator|->
name|mach
operator|>
name|a
operator|->
name|mach
condition|)
block|{
return|return
name|b
return|;
block|}
return|return
name|a
return|;
block|}
end_decl_stmt

begin_comment
comment|/* INTERNAL_FUNCTION 	bfd_default_scan  SYNOPSIS 	boolean bfd_default_scan(CONST struct bfd_arch_info *, CONST char *);  DESCRIPTION 	The default function for working out whether this is an 	architecture hit and a machine hit. */
end_comment

begin_decl_stmt
name|boolean
name|DEFUN
argument_list|(
name|bfd_default_scan
argument_list|,
operator|(
name|info
operator|,
name|string
operator|)
argument_list|,
name|CONST
expr|struct
name|bfd_arch_info
operator|*
name|info
name|AND
name|CONST
name|char
operator|*
name|string
argument_list|)
block|{
name|CONST
name|char
modifier|*
name|ptr_src
decl_stmt|;
name|CONST
name|char
modifier|*
name|ptr_tst
decl_stmt|;
name|unsigned
name|long
name|number
decl_stmt|;
name|enum
name|bfd_architecture
name|arch
decl_stmt|;
comment|/* First test for an exact match */
if|if
condition|(
name|strcmp
argument_list|(
name|string
argument_list|,
name|info
operator|->
name|printable_name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|true
return|;
comment|/* See how much of the supplied string matches with the        architecture, eg the string m68k:68020 would match the 68k entry        up to the :, then we get left with the machine number */
for|for
control|(
name|ptr_src
operator|=
name|string
operator|,
name|ptr_tst
operator|=
name|info
operator|->
name|arch_name
init|;
operator|*
name|ptr_src
operator|&&
operator|*
name|ptr_tst
condition|;
name|ptr_src
operator|++
operator|,
name|ptr_tst
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|ptr_src
operator|!=
operator|*
name|ptr_tst
condition|)
break|break;
block|}
comment|/* Chewed up as much of the architecture as will match, skip any        colons */
if|if
condition|(
operator|*
name|ptr_src
operator|==
literal|':'
condition|)
name|ptr_src
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|ptr_src
operator|==
literal|0
condition|)
block|{
comment|/* nothing more, then only keep this one if it is the default 	       machine for this architecture */
return|return
name|info
operator|->
name|the_default
return|;
block|}
name|number
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|ptr_src
argument_list|)
condition|)
block|{
name|number
operator|=
name|number
operator|*
literal|10
operator|+
operator|*
name|ptr_src
operator|-
literal|'0'
expr_stmt|;
name|ptr_src
operator|++
expr_stmt|;
block|}
switch|switch
condition|(
name|number
condition|)
block|{
case|case
literal|300
case|:
name|arch
operator|=
name|bfd_arch_h8300
expr_stmt|;
break|break;
case|case
literal|500
case|:
name|arch
operator|=
name|bfd_arch_h8500
expr_stmt|;
break|break;
case|case
literal|68010
case|:
case|case
literal|68020
case|:
case|case
literal|68030
case|:
case|case
literal|68040
case|:
case|case
literal|68332
case|:
case|case
literal|68050
case|:
case|case
literal|68000
case|:
name|arch
operator|=
name|bfd_arch_m68k
expr_stmt|;
break|break;
case|case
literal|386
case|:
case|case
literal|80386
case|:
case|case
literal|486
case|:
case|case
literal|80486
case|:
name|arch
operator|=
name|bfd_arch_i386
expr_stmt|;
break|break;
case|case
literal|29000
case|:
name|arch
operator|=
name|bfd_arch_a29k
expr_stmt|;
break|break;
case|case
literal|8000
case|:
name|arch
operator|=
name|bfd_arch_z8k
expr_stmt|;
break|break;
case|case
literal|32000
case|:
name|arch
operator|=
name|bfd_arch_we32k
expr_stmt|;
break|break;
case|case
literal|860
case|:
case|case
literal|80860
case|:
name|arch
operator|=
name|bfd_arch_i860
expr_stmt|;
break|break;
case|case
literal|960
case|:
case|case
literal|80960
case|:
name|arch
operator|=
name|bfd_arch_i960
expr_stmt|;
break|break;
case|case
literal|2000
case|:
case|case
literal|3000
case|:
case|case
literal|4000
case|:
case|case
literal|4400
case|:
name|arch
operator|=
name|bfd_arch_mips
expr_stmt|;
break|break;
case|case
literal|6000
case|:
name|arch
operator|=
name|bfd_arch_rs6000
expr_stmt|;
break|break;
default|default:
return|return
name|false
return|;
block|}
if|if
condition|(
name|arch
operator|!=
name|info
operator|->
name|arch
condition|)
return|return
name|false
return|;
if|if
condition|(
name|number
operator|!=
name|info
operator|->
name|mach
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_decl_stmt

begin_comment
comment|/* FUNCTION 	bfd_get_arch_info   SYNOPSIS 	bfd_arch_info_type * bfd_get_arch_info(bfd *);  */
end_comment

begin_decl_stmt
name|bfd_arch_info_type
modifier|*
name|DEFUN
argument_list|(
name|bfd_get_arch_info
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
return|return
name|abfd
operator|->
name|arch_info
return|;
block|}
end_decl_stmt

begin_comment
comment|/* FUNCTION 	bfd_lookup_arch  SYNOPSIS 	bfd_arch_info_type *bfd_lookup_arch 		(enum bfd_architecture 		arch, 		long machine);  DESCRIPTION 	Look for the architecure info struct which matches the 	arguments given. A machine of 0 will match the 	machine/architecture structure which marks itself as the 	default. */
end_comment

begin_decl_stmt
name|bfd_arch_info_type
modifier|*
name|DEFUN
argument_list|(
name|bfd_lookup_arch
argument_list|,
operator|(
name|arch
operator|,
name|machine
operator|)
argument_list|,
expr|enum
name|bfd_architecture
name|arch
name|AND
name|long
name|machine
argument_list|)
block|{
name|bfd_arch_info_type
modifier|*
name|ap
decl_stmt|;
name|bfd_check_init
argument_list|()
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|bfd_arch_info_list
init|;
name|ap
operator|!=
operator|(
name|bfd_arch_info_type
operator|*
operator|)
name|NULL
condition|;
name|ap
operator|=
name|ap
operator|->
name|next
control|)
block|{
if|if
condition|(
name|ap
operator|->
name|arch
operator|==
name|arch
operator|&&
operator|(
operator|(
name|ap
operator|->
name|mach
operator|==
name|machine
operator|)
operator|||
operator|(
name|ap
operator|->
name|the_default
operator|&&
name|machine
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
return|return
name|ap
return|;
block|}
block|}
return|return
operator|(
name|bfd_arch_info_type
operator|*
operator|)
name|NULL
return|;
block|}
end_decl_stmt

begin_comment
comment|/* FUNCTION 	bfd_printable_arch_mach  SYNOPSIS 	CONST char * bfd_printable_arch_mach 		(enum bfd_architecture arch, unsigned long machine);  DESCRIPTION 	Return a printable string representing the architecture and 	machine type.   	NB. The use of this routine is depreciated. */
end_comment

begin_decl_stmt
name|CONST
name|char
modifier|*
name|DEFUN
argument_list|(
name|bfd_printable_arch_mach
argument_list|,
operator|(
name|arch
operator|,
name|machine
operator|)
argument_list|,
expr|enum
name|bfd_architecture
name|arch
name|AND
name|unsigned
name|long
name|machine
argument_list|)
block|{
name|bfd_arch_info_type
modifier|*
name|ap
init|=
name|bfd_lookup_arch
argument_list|(
name|arch
argument_list|,
name|machine
argument_list|)
decl_stmt|;
if|if
condition|(
name|ap
condition|)
return|return
name|ap
operator|->
name|printable_name
return|;
return|return
literal|"UNKNOWN!"
return|;
block|}
end_decl_stmt

end_unit

