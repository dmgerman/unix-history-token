begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BFD back-end for s-record objects.    Copyright 1990, 1991, 1992, 1993, 1994 Free Software Foundation, Inc.    Written by Steve Chamberlain of Cygnus Support<sac@cygnus.com>.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* SUBSECTION 	S-Record handling  DESCRIPTION  	Ordinary S-Records cannot hold anything but addresses and 	data, so that's all that we implement.  	The only interesting thing is that S-Records may come out of 	order and there is no header, so an initial scan is required 	to discover the minimum and maximum addresses used to create 	the vma and size of the only section we create.  We 	arbitrarily call this section ".text".  	When bfd_get_section_contents is called the file is read 	again, and this time the data is placed into a bfd_alloc'd 	area.  	Any number of sections may be created for output, we save them 	up and output them when it's time to close the bfd.  	An s record looks like:  EXAMPLE 	S<type><length><address><data><checksum>  DESCRIPTION 	Where 	o length 	is the number of bytes following upto the checksum. Note that 	this is not the number of chars following, since it takes two 	chars to represent a byte. 	o type 	is one of: 	0) header record 	1) two byte address data record 	2) three byte address data record 	3) four byte address data record 	7) four byte address termination record 	8) three byte address termination record 	9) two byte address termination record  	o address 	is the start address of the data following, or in the case of 	a termination record, the start address of the image 	o data 	is the data. 	o checksum 	is the sum of all the raw byte data in the record, from the length 	upwards, modulo 256 and subtracted from 255.   SUBSECTION 	Symbol S-Record handling  DESCRIPTION 	Some ICE equipment understands an addition to the standard 	S-Record format; symbols and their addresses can be sent 	before the data.  	The format of this is: 	($$<modulename> 		(<space><symbol><address>)*) 	$$  	so a short symbol table could look like:  EXAMPLE 	$$ flash.x 	$$ flash.c 	  _port6 $0 	  _delay $4 	  _start $14 	  _etext $8036 	  _edata $8036  	  _end $8036 	$$  DESCRIPTION 	We allow symbols to be anywhere in the data stream - the module names 	are always ignored.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_decl_stmt
specifier|static
name|boolean
name|srec_write_record
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|int
operator|,
name|bfd_vma
operator|,
specifier|const
name|unsigned
name|char
operator|*
operator|,
specifier|const
name|unsigned
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|srec_write_header
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|srec_write_symbols
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Macros for converting between hex and binary. */
end_comment

begin_decl_stmt
specifier|static
name|CONST
name|char
name|digs
index|[]
init|=
literal|"0123456789ABCDEF"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Table that gets filled in with numbers corresponding to hex chars. */
end_comment

begin_decl_stmt
specifier|static
name|char
name|hex_value
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NOT_HEX
value|20
end_define

begin_define
define|#
directive|define
name|NIBBLE
parameter_list|(
name|x
parameter_list|)
value|hex_value[(unsigned char)(x)]
end_define

begin_define
define|#
directive|define
name|HEX
parameter_list|(
name|buffer
parameter_list|)
value|((NIBBLE((buffer)[0])<<4) + NIBBLE((buffer)[1]))
end_define

begin_define
define|#
directive|define
name|TOHEX
parameter_list|(
name|d
parameter_list|,
name|x
parameter_list|,
name|ch
parameter_list|)
define|\
value|d[1] = digs[(x)& 0xf]; \ 	d[0] = digs[((x)>>4)&0xf]; \ 	ch += ((x)& 0xff);
end_define

begin_define
define|#
directive|define
name|ISHEX
parameter_list|(
name|x
parameter_list|)
value|(hex_value[(unsigned char)(x)] != NOT_HEX)
end_define

begin_comment
comment|/* Initialize by filling in the hex conversion array. */
end_comment

begin_function
specifier|static
name|void
name|srec_init
parameter_list|()
block|{
name|unsigned
name|int
name|i
decl_stmt|;
specifier|static
name|boolean
name|inited
init|=
name|false
decl_stmt|;
if|if
condition|(
name|inited
operator|==
name|false
condition|)
block|{
name|inited
operator|=
name|true
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|hex_value
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|hex_value
index|[
name|i
index|]
operator|=
name|NOT_HEX
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|hex_value
index|[
name|i
operator|+
literal|'0'
index|]
operator|=
name|i
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
block|{
name|hex_value
index|[
name|i
operator|+
literal|'a'
index|]
operator|=
name|i
operator|+
literal|10
expr_stmt|;
name|hex_value
index|[
name|i
operator|+
literal|'A'
index|]
operator|=
name|i
operator|+
literal|10
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* The maximum number of bytes on a line is FF */
end_comment

begin_define
define|#
directive|define
name|MAXCHUNK
value|0xff
end_define

begin_comment
comment|/* The number of bytes we fit onto a line on output */
end_comment

begin_define
define|#
directive|define
name|CHUNK
value|21
end_define

begin_comment
comment|/* We cannot output our srecords as we see them, we have to glue them    together, this is done in this structure : */
end_comment

begin_struct
struct|struct
name|srec_data_list_struct
block|{
name|unsigned
name|char
modifier|*
name|data
decl_stmt|;
name|bfd_vma
name|where
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
name|struct
name|srec_data_list_struct
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|srec_data_list_struct
name|srec_data_list_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|srec_data_struct
block|{
name|srec_data_list_type
modifier|*
name|head
decl_stmt|;
name|unsigned
name|int
name|type
decl_stmt|;
name|int
name|done_symbol_read
decl_stmt|;
name|int
name|count
decl_stmt|;
name|asymbol
modifier|*
name|symbols
decl_stmt|;
name|char
modifier|*
name|strings
decl_stmt|;
name|int
name|symbol_idx
decl_stmt|;
name|int
name|string_size
decl_stmt|;
name|int
name|string_idx
decl_stmt|;
block|}
name|tdata_type
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|boolean
name|srec_write_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|tdata_type
operator|*
operator|,
name|srec_data_list_type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|srec_write_terminator
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|tdata_type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*    called once per input S-Record, used to work out vma and size of data.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_vma
name|low
decl_stmt|,
name|high
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|size_symbols
parameter_list|(
name|abfd
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|,
name|val
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|val
decl_stmt|;
block|{
name|abfd
operator|->
name|symcount
operator|++
expr_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|srec_data
operator|->
name|string_size
operator|+=
name|len
operator|+
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fillup_symbols
parameter_list|(
name|abfd
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|,
name|val
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|val
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|abfd
operator|->
name|tdata
operator|.
name|srec_data
operator|->
name|done_symbol_read
condition|)
block|{
name|asymbol
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|abfd
operator|->
name|tdata
operator|.
name|srec_data
operator|->
name|symbols
operator|==
literal|0
condition|)
block|{
name|abfd
operator|->
name|tdata
operator|.
name|srec_data
operator|->
name|symbols
operator|=
operator|(
name|asymbol
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|abfd
operator|->
name|symcount
operator|*
sizeof|sizeof
argument_list|(
name|asymbol
argument_list|)
argument_list|)
expr_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|srec_data
operator|->
name|strings
operator|=
operator|(
name|char
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|abfd
operator|->
name|tdata
operator|.
name|srec_data
operator|->
name|string_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|abfd
operator|->
name|tdata
operator|.
name|srec_data
operator|->
name|symbols
operator|||
operator|!
name|abfd
operator|->
name|tdata
operator|.
name|srec_data
operator|->
name|strings
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
comment|/* FIXME */
block|}
name|abfd
operator|->
name|tdata
operator|.
name|srec_data
operator|->
name|symbol_idx
operator|=
literal|0
expr_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|srec_data
operator|->
name|string_idx
operator|=
literal|0
expr_stmt|;
block|}
name|p
operator|=
name|abfd
operator|->
name|tdata
operator|.
name|srec_data
operator|->
name|symbols
operator|+
name|abfd
operator|->
name|tdata
operator|.
name|srec_data
operator|->
name|symbol_idx
operator|++
expr_stmt|;
name|p
operator|->
name|the_bfd
operator|=
name|abfd
expr_stmt|;
name|p
operator|->
name|name
operator|=
name|abfd
operator|->
name|tdata
operator|.
name|srec_data
operator|->
name|strings
operator|+
name|abfd
operator|->
name|tdata
operator|.
name|srec_data
operator|->
name|string_idx
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|p
operator|->
name|name
operator|)
argument_list|,
name|buf
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|srec_data
operator|->
name|string_idx
operator|+=
name|len
operator|+
literal|1
expr_stmt|;
name|p
operator|->
name|value
operator|=
name|val
expr_stmt|;
name|p
operator|->
name|flags
operator|=
name|BSF_EXPORT
operator||
name|BSF_GLOBAL
expr_stmt|;
name|p
operator|->
name|section
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
name|p
operator|->
name|udata
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|size_srec
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|address
parameter_list|,
name|raw
parameter_list|,
name|length
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|bfd_vma
name|address
decl_stmt|;
name|bfd_byte
modifier|*
name|raw
decl_stmt|;
name|unsigned
name|int
name|length
decl_stmt|;
block|{
if|if
condition|(
name|address
operator|<
name|low
condition|)
name|low
operator|=
name|address
expr_stmt|;
if|if
condition|(
name|address
operator|+
name|length
operator|>
name|high
condition|)
name|high
operator|=
name|address
operator|+
name|length
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  called once per input S-Record, copies data from input into bfd_alloc'd area  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|fillup
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|address
parameter_list|,
name|raw
parameter_list|,
name|length
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|bfd_vma
name|address
decl_stmt|;
name|bfd_byte
modifier|*
name|raw
decl_stmt|;
name|unsigned
name|int
name|length
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|bfd_byte
modifier|*
name|dst
init|=
operator|(
name|bfd_byte
operator|*
operator|)
operator|(
name|section
operator|->
name|used_by_bfd
operator|)
operator|+
name|address
operator|-
name|section
operator|->
name|vma
decl_stmt|;
comment|/* length -1 because we don't read in the checksum */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|dst
operator|=
name|HEX
argument_list|(
name|raw
argument_list|)
expr_stmt|;
name|dst
operator|++
expr_stmt|;
name|raw
operator|+=
literal|2
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Pass over an S-Record file, calling one of the above functions on each    record.  */
end_comment

begin_function
specifier|static
name|int
name|white
parameter_list|(
name|x
parameter_list|)
name|char
name|x
decl_stmt|;
block|{
return|return
operator|(
name|x
operator|==
literal|' '
operator|||
name|x
operator|==
literal|'\t'
operator|||
name|x
operator|==
literal|'\n'
operator|||
name|x
operator|==
literal|'\r'
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|skipwhite
parameter_list|(
name|src
parameter_list|,
name|abfd
parameter_list|)
name|char
modifier|*
name|src
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|int
name|eof
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|white
argument_list|(
operator|*
name|src
argument_list|)
operator|&&
operator|!
name|eof
condition|)
block|{
name|eof
operator|=
call|(
name|boolean
call|)
argument_list|(
name|bfd_read
argument_list|(
name|src
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|eof
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|srec_mkobject
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
if|if
condition|(
name|abfd
operator|->
name|tdata
operator|.
name|srec_data
operator|==
literal|0
condition|)
block|{
name|tdata_type
modifier|*
name|tdata
init|=
operator|(
name|tdata_type
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|tdata_type
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|tdata
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|abfd
operator|->
name|tdata
operator|.
name|srec_data
operator|=
name|tdata
expr_stmt|;
name|tdata
operator|->
name|type
operator|=
literal|1
expr_stmt|;
name|tdata
operator|->
name|head
operator|=
operator|(
name|srec_data_list_type
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|pass_over
argument_list|(
name|abfd
argument_list|,
name|func
argument_list|,
name|symbolfunc
argument_list|,
name|section
argument_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
function_decl|(
modifier|*
name|symbolfunc
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|asection
modifier|*
name|section
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|unsigned
name|int
name|bytes_on_line
decl_stmt|;
name|boolean
name|eof
init|=
name|false
decl_stmt|;
name|srec_mkobject
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* To the front of the file */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
while|while
condition|(
name|eof
operator|==
name|false
condition|)
block|{
name|char
name|buffer
index|[
name|MAXCHUNK
index|]
decl_stmt|;
name|char
modifier|*
name|src
init|=
name|buffer
decl_stmt|;
name|char
name|type
decl_stmt|;
name|bfd_vma
name|address
init|=
literal|0
decl_stmt|;
comment|/* Find first 'S' or $ */
name|eof
operator|=
call|(
name|boolean
call|)
argument_list|(
name|bfd_read
argument_list|(
name|src
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|src
condition|)
block|{
default|default:
if|if
condition|(
name|eof
condition|)
return|return;
break|break;
case|case
literal|'$'
case|:
comment|/* Inside a symbol definition - just ignore the module name */
while|while
condition|(
operator|*
name|src
operator|!=
literal|'\n'
operator|&&
operator|!
name|eof
condition|)
block|{
name|eof
operator|=
call|(
name|boolean
call|)
argument_list|(
name|bfd_read
argument_list|(
name|src
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|' '
case|:
comment|/* spaces - maybe just before a symbol */
while|while
condition|(
operator|*
name|src
operator|!=
literal|'\n'
operator|&&
operator|*
name|src
operator|!=
literal|'\r'
operator|&&
name|white
argument_list|(
operator|*
name|src
argument_list|)
condition|)
block|{
name|eof
operator|=
name|skipwhite
argument_list|(
name|src
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
block|{
name|int
name|val
init|=
literal|0
decl_stmt|;
name|int
name|slen
init|=
literal|0
decl_stmt|;
name|char
name|symbol
index|[
name|MAXCHUNK
index|]
decl_stmt|;
comment|/* get the symbol part */
while|while
condition|(
operator|!
name|eof
operator|&&
operator|!
name|white
argument_list|(
operator|*
name|src
argument_list|)
operator|&&
name|slen
operator|<
name|MAXCHUNK
condition|)
block|{
name|symbol
index|[
name|slen
operator|++
index|]
operator|=
operator|*
name|src
expr_stmt|;
name|eof
operator|=
call|(
name|boolean
call|)
argument_list|(
name|bfd_read
argument_list|(
name|src
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|1
argument_list|)
expr_stmt|;
block|}
name|symbol
index|[
name|slen
index|]
operator|=
literal|0
expr_stmt|;
name|eof
operator|=
name|skipwhite
argument_list|(
name|src
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
comment|/* skip the $ for the hex value */
if|if
condition|(
operator|*
name|src
operator|==
literal|'$'
condition|)
block|{
name|eof
operator|=
call|(
name|boolean
call|)
argument_list|(
name|bfd_read
argument_list|(
name|src
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Scan off the hex number */
while|while
condition|(
name|isxdigit
argument_list|(
operator|*
name|src
argument_list|)
condition|)
block|{
name|val
operator|*=
literal|16
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|src
argument_list|)
condition|)
name|val
operator|+=
operator|*
name|src
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|isupper
argument_list|(
operator|*
name|src
argument_list|)
condition|)
block|{
name|val
operator|+=
operator|*
name|src
operator|-
literal|'A'
operator|+
literal|10
expr_stmt|;
block|}
else|else
block|{
name|val
operator|+=
operator|*
name|src
operator|-
literal|'a'
operator|+
literal|10
expr_stmt|;
block|}
name|eof
operator|=
call|(
name|boolean
call|)
argument_list|(
name|bfd_read
argument_list|(
name|src
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|1
argument_list|)
expr_stmt|;
block|}
name|symbolfunc
argument_list|(
name|abfd
argument_list|,
name|symbol
argument_list|,
name|slen
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'S'
case|:
name|src
operator|++
expr_stmt|;
comment|/* Fetch the type and the length */
if|if
condition|(
name|bfd_read
argument_list|(
name|src
argument_list|,
literal|1
argument_list|,
literal|3
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|3
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* FIXME */
name|type
operator|=
operator|*
name|src
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|ISHEX
argument_list|(
name|src
index|[
literal|0
index|]
argument_list|)
operator|||
operator|!
name|ISHEX
argument_list|(
name|src
index|[
literal|1
index|]
argument_list|)
condition|)
break|break;
name|bytes_on_line
operator|=
name|HEX
argument_list|(
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_on_line
operator|>
name|MAXCHUNK
operator|/
literal|2
condition|)
break|break;
name|src
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|bfd_read
argument_list|(
name|src
argument_list|,
literal|1
argument_list|,
name|bytes_on_line
operator|*
literal|2
argument_list|,
name|abfd
argument_list|)
operator|!=
name|bytes_on_line
operator|*
literal|2
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* FIXME */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'0'
case|:
case|case
literal|'5'
case|:
comment|/* Prologue - ignore */
break|break;
case|case
literal|'3'
case|:
name|address
operator|=
name|HEX
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|src
operator|+=
literal|2
expr_stmt|;
name|bytes_on_line
operator|--
expr_stmt|;
case|case
literal|'2'
case|:
name|address
operator|=
name|HEX
argument_list|(
name|src
argument_list|)
operator||
operator|(
name|address
operator|<<
literal|8
operator|)
expr_stmt|;
name|src
operator|+=
literal|2
expr_stmt|;
name|bytes_on_line
operator|--
expr_stmt|;
case|case
literal|'1'
case|:
name|address
operator|=
name|HEX
argument_list|(
name|src
argument_list|)
operator||
operator|(
name|address
operator|<<
literal|8
operator|)
expr_stmt|;
name|src
operator|+=
literal|2
expr_stmt|;
name|address
operator|=
name|HEX
argument_list|(
name|src
argument_list|)
operator||
operator|(
name|address
operator|<<
literal|8
operator|)
expr_stmt|;
name|src
operator|+=
literal|2
expr_stmt|;
name|bytes_on_line
operator|-=
literal|2
expr_stmt|;
name|func
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|address
argument_list|,
name|src
argument_list|,
name|bytes_on_line
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return;
block|}
block|}
block|}
block|}
end_block

begin_function
specifier|static
specifier|const
name|bfd_target
modifier|*
name|object_p
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|asection
modifier|*
name|section
decl_stmt|;
comment|/* We create one section called .text for all the contents,      and allocate enough room for the entire file.  */
name|section
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".text"
argument_list|)
expr_stmt|;
name|section
operator|->
name|_raw_size
operator|=
literal|0
expr_stmt|;
name|section
operator|->
name|vma
operator|=
literal|0xffffffff
expr_stmt|;
name|low
operator|=
literal|0xffffffff
expr_stmt|;
name|high
operator|=
literal|0
expr_stmt|;
name|pass_over
argument_list|(
name|abfd
argument_list|,
name|size_srec
argument_list|,
name|size_symbols
argument_list|,
name|section
argument_list|)
expr_stmt|;
name|section
operator|->
name|_raw_size
operator|=
name|high
operator|-
name|low
expr_stmt|;
name|section
operator|->
name|vma
operator|=
name|low
expr_stmt|;
name|section
operator|->
name|flags
operator|=
name|SEC_HAS_CONTENTS
operator||
name|SEC_LOAD
operator||
name|SEC_ALLOC
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|symcount
condition|)
name|abfd
operator|->
name|flags
operator||=
name|HAS_SYMS
expr_stmt|;
return|return
name|abfd
operator|->
name|xvec
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|bfd_target
modifier|*
name|srec_object_p
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|char
name|b
index|[
literal|4
index|]
decl_stmt|;
name|srec_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_read
argument_list|(
name|b
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|4
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|b
index|[
literal|0
index|]
operator|!=
literal|'S'
operator|||
operator|!
name|ISHEX
argument_list|(
name|b
index|[
literal|1
index|]
argument_list|)
operator|||
operator|!
name|ISHEX
argument_list|(
name|b
index|[
literal|2
index|]
argument_list|)
operator|||
operator|!
name|ISHEX
argument_list|(
name|b
index|[
literal|3
index|]
argument_list|)
condition|)
return|return
operator|(
specifier|const
name|bfd_target
operator|*
operator|)
name|NULL
return|;
comment|/* We create one section called .text for all the contents,      and allocate enough room for the entire file.  */
return|return
name|object_p
argument_list|(
name|abfd
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|bfd_target
modifier|*
name|symbolsrec_object_p
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|char
name|b
index|[
literal|4
index|]
decl_stmt|;
name|srec_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_read
argument_list|(
name|b
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|4
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|b
index|[
literal|0
index|]
operator|!=
literal|'$'
operator|||
name|b
index|[
literal|1
index|]
operator|!=
literal|'$'
condition|)
return|return
operator|(
specifier|const
name|bfd_target
operator|*
operator|)
name|NULL
return|;
return|return
name|object_p
argument_list|(
name|abfd
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|srec_get_section_contents
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|location
parameter_list|,
name|offset
parameter_list|,
name|count
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|PTR
name|location
decl_stmt|;
name|file_ptr
name|offset
decl_stmt|;
name|bfd_size_type
name|count
decl_stmt|;
block|{
if|if
condition|(
name|section
operator|->
name|used_by_bfd
operator|==
operator|(
name|PTR
operator|)
name|NULL
condition|)
block|{
name|section
operator|->
name|used_by_bfd
operator|=
operator|(
name|PTR
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|section
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|section
operator|->
name|used_by_bfd
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|pass_over
argument_list|(
name|abfd
argument_list|,
name|fillup
argument_list|,
name|fillup_symbols
argument_list|,
name|section
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
operator|(
name|PTR
operator|)
name|location
argument_list|,
call|(
name|PTR
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|section
operator|->
name|used_by_bfd
operator|)
operator|+
name|offset
argument_list|)
argument_list|,
name|count
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
name|boolean
name|srec_set_arch_mach
parameter_list|(
name|abfd
parameter_list|,
name|arch
parameter_list|,
name|machine
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|enum
name|bfd_architecture
name|arch
decl_stmt|;
name|unsigned
name|long
name|machine
decl_stmt|;
block|{
return|return
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|arch
argument_list|,
name|machine
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* we have to save up all the Srecords for a splurge before output,    also remember   */
end_comment

begin_function
specifier|static
name|boolean
name|srec_set_section_contents
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|location
parameter_list|,
name|offset
parameter_list|,
name|bytes_to_do
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|sec_ptr
name|section
decl_stmt|;
name|PTR
name|location
decl_stmt|;
name|file_ptr
name|offset
decl_stmt|;
name|bfd_size_type
name|bytes_to_do
decl_stmt|;
block|{
name|tdata_type
modifier|*
name|tdata
init|=
name|abfd
operator|->
name|tdata
operator|.
name|srec_data
decl_stmt|;
name|srec_data_list_type
modifier|*
name|entry
init|=
operator|(
name|srec_data_list_type
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|srec_data_list_type
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|entry
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
operator|(
name|section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|&&
operator|(
name|section
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
condition|)
block|{
name|unsigned
name|char
modifier|*
name|data
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|bytes_to_do
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|data
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|memcpy
argument_list|(
operator|(
name|PTR
operator|)
name|data
argument_list|,
name|location
argument_list|,
name|bytes_to_do
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|section
operator|->
name|lma
operator|+
name|offset
operator|+
name|bytes_to_do
operator|)
operator|<=
literal|0xffff
condition|)
block|{  	}
elseif|else
if|if
condition|(
operator|(
name|section
operator|->
name|lma
operator|+
name|offset
operator|+
name|bytes_to_do
operator|)
operator|<=
literal|0xffffff
operator|&&
name|tdata
operator|->
name|type
operator|<
literal|2
condition|)
block|{
name|tdata
operator|->
name|type
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|tdata
operator|->
name|type
operator|=
literal|3
expr_stmt|;
block|}
name|entry
operator|->
name|data
operator|=
name|data
expr_stmt|;
name|entry
operator|->
name|where
operator|=
name|section
operator|->
name|lma
operator|+
name|offset
expr_stmt|;
name|entry
operator|->
name|size
operator|=
name|bytes_to_do
expr_stmt|;
name|entry
operator|->
name|next
operator|=
name|tdata
operator|->
name|head
expr_stmt|;
name|tdata
operator|->
name|head
operator|=
name|entry
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Write a record of type, of the supplied number of bytes. The    supplied bytes and length don't have a checksum. That's worked out    here */
end_comment

begin_function
specifier|static
name|boolean
name|srec_write_record
parameter_list|(
name|abfd
parameter_list|,
name|type
parameter_list|,
name|address
parameter_list|,
name|data
parameter_list|,
name|end
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|int
name|type
decl_stmt|;
name|bfd_vma
name|address
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|data
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|end
decl_stmt|;
block|{
name|char
name|buffer
index|[
name|MAXCHUNK
index|]
decl_stmt|;
name|unsigned
name|int
name|check_sum
init|=
literal|0
decl_stmt|;
name|CONST
name|unsigned
name|char
modifier|*
name|src
init|=
name|data
decl_stmt|;
name|char
modifier|*
name|dst
init|=
name|buffer
decl_stmt|;
name|char
modifier|*
name|length
decl_stmt|;
operator|*
name|dst
operator|++
operator|=
literal|'S'
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
literal|'0'
operator|+
name|type
expr_stmt|;
name|length
operator|=
name|dst
expr_stmt|;
name|dst
operator|+=
literal|2
expr_stmt|;
comment|/* leave room for dst*/
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|3
case|:
case|case
literal|7
case|:
name|TOHEX
argument_list|(
name|dst
argument_list|,
operator|(
name|address
operator|>>
literal|24
operator|)
argument_list|,
name|check_sum
argument_list|)
expr_stmt|;
name|dst
operator|+=
literal|2
expr_stmt|;
case|case
literal|8
case|:
case|case
literal|2
case|:
name|TOHEX
argument_list|(
name|dst
argument_list|,
operator|(
name|address
operator|>>
literal|16
operator|)
argument_list|,
name|check_sum
argument_list|)
expr_stmt|;
name|dst
operator|+=
literal|2
expr_stmt|;
case|case
literal|9
case|:
case|case
literal|1
case|:
case|case
literal|0
case|:
name|TOHEX
argument_list|(
name|dst
argument_list|,
operator|(
name|address
operator|>>
literal|8
operator|)
argument_list|,
name|check_sum
argument_list|)
expr_stmt|;
name|dst
operator|+=
literal|2
expr_stmt|;
name|TOHEX
argument_list|(
name|dst
argument_list|,
operator|(
name|address
operator|)
argument_list|,
name|check_sum
argument_list|)
expr_stmt|;
name|dst
operator|+=
literal|2
expr_stmt|;
break|break;
block|}
for|for
control|(
name|src
operator|=
name|data
init|;
name|src
operator|<
name|end
condition|;
name|src
operator|++
control|)
block|{
name|TOHEX
argument_list|(
name|dst
argument_list|,
operator|*
name|src
argument_list|,
name|check_sum
argument_list|)
expr_stmt|;
name|dst
operator|+=
literal|2
expr_stmt|;
block|}
comment|/* Fill in the length */
name|TOHEX
argument_list|(
name|length
argument_list|,
operator|(
name|dst
operator|-
name|length
operator|)
operator|/
literal|2
argument_list|,
name|check_sum
argument_list|)
expr_stmt|;
name|check_sum
operator|&=
literal|0xff
expr_stmt|;
name|check_sum
operator|=
literal|255
operator|-
name|check_sum
expr_stmt|;
name|TOHEX
argument_list|(
name|dst
argument_list|,
name|check_sum
argument_list|,
name|check_sum
argument_list|)
expr_stmt|;
name|dst
operator|+=
literal|2
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
literal|'\r'
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
literal|'\n'
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|buffer
argument_list|,
literal|1
argument_list|,
name|dst
operator|-
name|buffer
argument_list|,
name|abfd
argument_list|)
operator|!=
name|dst
operator|-
name|buffer
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|srec_write_header
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|unsigned
name|char
name|buffer
index|[
name|MAXCHUNK
index|]
decl_stmt|;
name|unsigned
name|char
modifier|*
name|dst
init|=
name|buffer
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* I'll put an arbitary 40 char limit on header size */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|40
operator|&&
name|abfd
operator|->
name|filename
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|dst
operator|++
operator|=
name|abfd
operator|->
name|filename
index|[
name|i
index|]
expr_stmt|;
block|}
return|return
name|srec_write_record
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|buffer
argument_list|,
name|dst
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|srec_write_section
parameter_list|(
name|abfd
parameter_list|,
name|tdata
parameter_list|,
name|list
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|tdata_type
modifier|*
name|tdata
decl_stmt|;
name|srec_data_list_type
modifier|*
name|list
decl_stmt|;
block|{
name|unsigned
name|int
name|bytes_written
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
modifier|*
name|location
init|=
name|list
operator|->
name|data
decl_stmt|;
while|while
condition|(
name|bytes_written
operator|<
name|list
operator|->
name|size
condition|)
block|{
name|bfd_vma
name|address
decl_stmt|;
name|unsigned
name|int
name|bytes_this_chunk
init|=
name|list
operator|->
name|size
operator|-
name|bytes_written
decl_stmt|;
if|if
condition|(
name|bytes_this_chunk
operator|>
name|CHUNK
condition|)
block|{
name|bytes_this_chunk
operator|=
name|CHUNK
expr_stmt|;
block|}
name|address
operator|=
name|list
operator|->
name|where
operator|+
name|bytes_written
expr_stmt|;
if|if
condition|(
operator|!
name|srec_write_record
argument_list|(
name|abfd
argument_list|,
name|tdata
operator|->
name|type
argument_list|,
name|address
argument_list|,
name|location
argument_list|,
name|location
operator|+
name|bytes_this_chunk
argument_list|)
condition|)
return|return
name|false
return|;
name|bytes_written
operator|+=
name|bytes_this_chunk
expr_stmt|;
name|location
operator|+=
name|bytes_this_chunk
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|srec_write_terminator
parameter_list|(
name|abfd
parameter_list|,
name|tdata
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|tdata_type
modifier|*
name|tdata
decl_stmt|;
block|{
name|unsigned
name|char
name|buffer
index|[
literal|2
index|]
decl_stmt|;
return|return
name|srec_write_record
argument_list|(
name|abfd
argument_list|,
literal|10
operator|-
name|tdata
operator|->
name|type
argument_list|,
name|abfd
operator|->
name|start_address
argument_list|,
name|buffer
argument_list|,
name|buffer
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|srec_write_symbols
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|char
name|buffer
index|[
name|MAXCHUNK
index|]
decl_stmt|;
comment|/* Dump out the symbols of a bfd */
name|int
name|i
decl_stmt|;
name|int
name|count
init|=
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
if|if
condition|(
name|count
condition|)
block|{
name|size_t
name|len
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|table
init|=
name|bfd_get_outsymbols
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"$$ %s\r\n"
argument_list|,
name|abfd
operator|->
name|filename
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
name|buffer
argument_list|,
name|len
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
name|len
condition|)
return|return
name|false
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|asymbol
modifier|*
name|s
init|=
name|table
index|[
name|i
index|]
decl_stmt|;
if|#
directive|if
literal|0
block|int len = strlen (s->name);
comment|/* If this symbol has a .[ocs] in it, it's probably a file name 	 and we'll output that as the module name */
block|if (len> 3&& s->name[len - 2] == '.') 	    { 	      int l; 	      sprintf (buffer, "$$ %s\r\n", s->name); 	      l = strlen (buffer); 	      if (bfd_write (buffer, l, 1, abfd) != l) 		return false; 	    } 	  else
endif|#
directive|endif
if|if
condition|(
name|s
operator|->
name|flags
operator|&
operator|(
name|BSF_GLOBAL
operator||
name|BSF_LOCAL
operator|)
operator|&&
operator|(
name|s
operator|->
name|flags
operator|&
name|BSF_DEBUGGING
operator|)
operator|==
literal|0
operator|&&
name|s
operator|->
name|name
index|[
literal|0
index|]
operator|!=
literal|'.'
operator|&&
name|s
operator|->
name|name
index|[
literal|0
index|]
operator|!=
literal|'t'
condition|)
block|{
comment|/* Just dump out non debug symbols */
name|int
name|l
decl_stmt|;
name|char
name|buf2
index|[
literal|40
index|]
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|sprintf_vma
argument_list|(
name|buf2
argument_list|,
name|s
operator|->
name|value
operator|+
name|s
operator|->
name|section
operator|->
name|output_section
operator|->
name|lma
operator|+
name|s
operator|->
name|section
operator|->
name|output_offset
argument_list|)
expr_stmt|;
name|p
operator|=
name|buf2
expr_stmt|;
while|while
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'0'
operator|&&
name|p
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
name|p
operator|++
expr_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"  %s $%s\r\n"
argument_list|,
name|s
operator|->
name|name
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|l
operator|=
name|strlen
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
name|buffer
argument_list|,
name|l
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
name|l
condition|)
return|return
name|false
return|;
block|}
block|}
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"$$ \r\n"
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
name|buffer
argument_list|,
name|len
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
name|len
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|internal_srec_write_object_contents
parameter_list|(
name|abfd
parameter_list|,
name|symbols
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|int
name|symbols
decl_stmt|;
block|{
name|tdata_type
modifier|*
name|tdata
init|=
name|abfd
operator|->
name|tdata
operator|.
name|srec_data
decl_stmt|;
name|srec_data_list_type
modifier|*
name|list
decl_stmt|;
if|if
condition|(
name|symbols
condition|)
block|{
if|if
condition|(
operator|!
name|srec_write_symbols
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|srec_write_header
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Now wander though all the sections provided and output them */
name|list
operator|=
name|tdata
operator|->
name|head
expr_stmt|;
while|while
condition|(
name|list
operator|!=
operator|(
name|srec_data_list_type
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|srec_write_section
argument_list|(
name|abfd
argument_list|,
name|tdata
argument_list|,
name|list
argument_list|)
condition|)
return|return
name|false
return|;
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
block|}
return|return
name|srec_write_terminator
argument_list|(
name|abfd
argument_list|,
name|tdata
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|srec_write_object_contents
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
return|return
name|internal_srec_write_object_contents
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|symbolsrec_write_object_contents
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
return|return
name|internal_srec_write_object_contents
argument_list|(
name|abfd
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|srec_sizeof_headers
parameter_list|(
name|abfd
parameter_list|,
name|exec
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|boolean
name|exec
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|asymbol
modifier|*
name|srec_make_empty_symbol
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|asymbol
modifier|*
name|new
init|=
operator|(
name|asymbol
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|asymbol
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|new
condition|)
name|new
operator|->
name|the_bfd
operator|=
name|abfd
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_function
specifier|static
name|long
name|srec_get_symtab_upper_bound
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
comment|/* Read in all the info */
if|if
condition|(
operator|!
name|srec_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|abfd
operator|->
name|sections
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
operator|(
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|+
literal|1
operator|)
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|long
name|srec_get_symtab
parameter_list|(
name|abfd
parameter_list|,
name|alocation
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|alocation
decl_stmt|;
block|{
name|int
name|lim
init|=
name|abfd
operator|->
name|symcount
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lim
condition|;
name|i
operator|++
control|)
block|{
name|alocation
index|[
name|i
index|]
operator|=
name|abfd
operator|->
name|tdata
operator|.
name|srec_data
operator|->
name|symbols
operator|+
name|i
expr_stmt|;
block|}
name|alocation
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|lim
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|srec_get_symbol_info
parameter_list|(
name|ignore_abfd
parameter_list|,
name|symbol
parameter_list|,
name|ret
parameter_list|)
name|bfd
modifier|*
name|ignore_abfd
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|symbol_info
modifier|*
name|ret
decl_stmt|;
block|{
name|bfd_symbol_info
argument_list|(
name|symbol
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|srec_print_symbol
parameter_list|(
name|ignore_abfd
parameter_list|,
name|afile
parameter_list|,
name|symbol
parameter_list|,
name|how
parameter_list|)
name|bfd
modifier|*
name|ignore_abfd
decl_stmt|;
name|PTR
name|afile
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|bfd_print_symbol_type
name|how
decl_stmt|;
block|{
name|FILE
modifier|*
name|file
init|=
operator|(
name|FILE
operator|*
operator|)
name|afile
decl_stmt|;
switch|switch
condition|(
name|how
condition|)
block|{
case|case
name|bfd_print_symbol_name
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|symbol
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
default|default:
name|bfd_print_symbol_vandf
argument_list|(
operator|(
name|PTR
operator|)
name|file
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %-5s %s"
argument_list|,
name|symbol
operator|->
name|section
operator|->
name|name
argument_list|,
name|symbol
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|srec_close_and_cleanup
value|_bfd_generic_close_and_cleanup
end_define

begin_define
define|#
directive|define
name|srec_bfd_free_cached_info
value|_bfd_generic_bfd_free_cached_info
end_define

begin_define
define|#
directive|define
name|srec_new_section_hook
value|_bfd_generic_new_section_hook
end_define

begin_define
define|#
directive|define
name|srec_bfd_is_local_label
value|bfd_generic_is_local_label
end_define

begin_define
define|#
directive|define
name|srec_get_lineno
value|_bfd_nosymbols_get_lineno
end_define

begin_define
define|#
directive|define
name|srec_find_nearest_line
value|_bfd_nosymbols_find_nearest_line
end_define

begin_define
define|#
directive|define
name|srec_bfd_make_debug_symbol
value|_bfd_nosymbols_bfd_make_debug_symbol
end_define

begin_define
define|#
directive|define
name|srec_bfd_get_relocated_section_contents
define|\
value|bfd_generic_get_relocated_section_contents
end_define

begin_define
define|#
directive|define
name|srec_bfd_relax_section
value|bfd_generic_relax_section
end_define

begin_define
define|#
directive|define
name|srec_bfd_link_hash_table_create
value|_bfd_generic_link_hash_table_create
end_define

begin_define
define|#
directive|define
name|srec_bfd_link_add_symbols
value|_bfd_generic_link_add_symbols
end_define

begin_define
define|#
directive|define
name|srec_bfd_final_link
value|_bfd_generic_final_link
end_define

begin_decl_stmt
specifier|const
name|bfd_target
name|srec_vec
init|=
block|{
literal|"srec"
block|,
comment|/* name */
name|bfd_target_srec_flavour
block|,
name|true
block|,
comment|/* target byte order */
name|true
block|,
comment|/* target headers byte order */
operator|(
name|HAS_RELOC
operator||
name|EXEC_P
operator||
comment|/* object flags */
name|HAS_LINENO
operator||
name|HAS_DEBUG
operator||
name|HAS_SYMS
operator||
name|HAS_LOCALS
operator||
name|WP_TEXT
operator||
name|D_PAGED
operator|)
block|,
operator|(
name|SEC_CODE
operator||
name|SEC_DATA
operator||
name|SEC_ROM
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator|)
block|,
comment|/* section flags */
literal|0
block|,
comment|/* leading underscore */
literal|' '
block|,
comment|/* ar_pad_char */
literal|16
block|,
comment|/* ar_max_namelen */
literal|1
block|,
comment|/* minimum alignment */
name|bfd_getb64
block|,
name|bfd_getb_signed_64
block|,
name|bfd_putb64
block|,
name|bfd_getb32
block|,
name|bfd_getb_signed_32
block|,
name|bfd_putb32
block|,
name|bfd_getb16
block|,
name|bfd_getb_signed_16
block|,
name|bfd_putb16
block|,
comment|/* data */
name|bfd_getb64
block|,
name|bfd_getb_signed_64
block|,
name|bfd_putb64
block|,
name|bfd_getb32
block|,
name|bfd_getb_signed_32
block|,
name|bfd_putb32
block|,
name|bfd_getb16
block|,
name|bfd_getb_signed_16
block|,
name|bfd_putb16
block|,
comment|/* hdrs */
block|{
name|_bfd_dummy_target
block|,
name|srec_object_p
block|,
comment|/* bfd_check_format */
name|_bfd_dummy_target
block|,
name|_bfd_dummy_target
block|,   }
block|,
block|{
name|bfd_false
block|,
name|srec_mkobject
block|,
name|_bfd_generic_mkarchive
block|,
name|bfd_false
block|,   }
block|,
block|{
comment|/* bfd_write_contents */
name|bfd_false
block|,
name|srec_write_object_contents
block|,
name|_bfd_write_archive_contents
block|,
name|bfd_false
block|,   }
block|,
name|BFD_JUMP_TABLE_GENERIC
argument_list|(
name|srec
argument_list|)
block|,
name|BFD_JUMP_TABLE_COPY
argument_list|(
name|_bfd_generic
argument_list|)
block|,
name|BFD_JUMP_TABLE_CORE
argument_list|(
name|_bfd_nocore
argument_list|)
block|,
name|BFD_JUMP_TABLE_ARCHIVE
argument_list|(
name|_bfd_noarchive
argument_list|)
block|,
name|BFD_JUMP_TABLE_SYMBOLS
argument_list|(
name|srec
argument_list|)
block|,
name|BFD_JUMP_TABLE_RELOCS
argument_list|(
name|_bfd_norelocs
argument_list|)
block|,
name|BFD_JUMP_TABLE_WRITE
argument_list|(
name|srec
argument_list|)
block|,
name|BFD_JUMP_TABLE_LINK
argument_list|(
name|srec
argument_list|)
block|,
name|BFD_JUMP_TABLE_DYNAMIC
argument_list|(
name|_bfd_nodynamic
argument_list|)
block|,
operator|(
name|PTR
operator|)
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|bfd_target
name|symbolsrec_vec
init|=
block|{
literal|"symbolsrec"
block|,
comment|/* name */
name|bfd_target_srec_flavour
block|,
name|true
block|,
comment|/* target byte order */
name|true
block|,
comment|/* target headers byte order */
operator|(
name|HAS_RELOC
operator||
name|EXEC_P
operator||
comment|/* object flags */
name|HAS_LINENO
operator||
name|HAS_DEBUG
operator||
name|HAS_SYMS
operator||
name|HAS_LOCALS
operator||
name|WP_TEXT
operator||
name|D_PAGED
operator|)
block|,
operator|(
name|SEC_CODE
operator||
name|SEC_DATA
operator||
name|SEC_ROM
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator|)
block|,
comment|/* section flags */
literal|0
block|,
comment|/* leading underscore */
literal|' '
block|,
comment|/* ar_pad_char */
literal|16
block|,
comment|/* ar_max_namelen */
literal|1
block|,
comment|/* minimum alignment */
name|bfd_getb64
block|,
name|bfd_getb_signed_64
block|,
name|bfd_putb64
block|,
name|bfd_getb32
block|,
name|bfd_getb_signed_32
block|,
name|bfd_putb32
block|,
name|bfd_getb16
block|,
name|bfd_getb_signed_16
block|,
name|bfd_putb16
block|,
comment|/* data */
name|bfd_getb64
block|,
name|bfd_getb_signed_64
block|,
name|bfd_putb64
block|,
name|bfd_getb32
block|,
name|bfd_getb_signed_32
block|,
name|bfd_putb32
block|,
name|bfd_getb16
block|,
name|bfd_getb_signed_16
block|,
name|bfd_putb16
block|,
comment|/* hdrs */
block|{
name|_bfd_dummy_target
block|,
name|symbolsrec_object_p
block|,
comment|/* bfd_check_format */
name|_bfd_dummy_target
block|,
name|_bfd_dummy_target
block|,   }
block|,
block|{
name|bfd_false
block|,
name|srec_mkobject
block|,
name|_bfd_generic_mkarchive
block|,
name|bfd_false
block|,   }
block|,
block|{
comment|/* bfd_write_contents */
name|bfd_false
block|,
name|symbolsrec_write_object_contents
block|,
name|_bfd_write_archive_contents
block|,
name|bfd_false
block|,   }
block|,
name|BFD_JUMP_TABLE_GENERIC
argument_list|(
name|srec
argument_list|)
block|,
name|BFD_JUMP_TABLE_COPY
argument_list|(
name|_bfd_generic
argument_list|)
block|,
name|BFD_JUMP_TABLE_CORE
argument_list|(
name|_bfd_nocore
argument_list|)
block|,
name|BFD_JUMP_TABLE_ARCHIVE
argument_list|(
name|_bfd_noarchive
argument_list|)
block|,
name|BFD_JUMP_TABLE_SYMBOLS
argument_list|(
name|srec
argument_list|)
block|,
name|BFD_JUMP_TABLE_RELOCS
argument_list|(
name|_bfd_norelocs
argument_list|)
block|,
name|BFD_JUMP_TABLE_WRITE
argument_list|(
name|srec
argument_list|)
block|,
name|BFD_JUMP_TABLE_LINK
argument_list|(
name|srec
argument_list|)
block|,
name|BFD_JUMP_TABLE_DYNAMIC
argument_list|(
name|_bfd_nodynamic
argument_list|)
block|,
operator|(
name|PTR
operator|)
literal|0
block|}
decl_stmt|;
end_decl_stmt

end_unit

