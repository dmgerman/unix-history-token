begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Generic symbol-table support for the BFD library.    Copyright (C) 1990, 1991, 1992, 1993 Free Software Foundation, Inc.    Written by Cygnus Support.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* SECTION 	Symbols  	BFD tries to maintain as much symbol information as it can when 	it moves information from file to file. BFD passes information 	to applications though the<<asymbol>> structure. When the 	application requests the symbol table, BFD reads the table in 	the native form and translates parts of it into the internal 	format. To maintain more than the information passed to 	applications, some targets keep some information ``behind the 	scenes'' in a structure only the particular back end knows 	about. For example, the coff back end keeps the original 	symbol table structure as well as the canonical structure when 	a BFD is read in. On output, the coff back end can reconstruct 	the output symbol table so that no information is lost, even 	information unique to coff which BFD doesn't know or 	understand. If a coff symbol table were read, but were written 	through an a.out back end, all the coff specific information 	would be lost. The symbol table of a BFD 	is not necessarily read in until a canonicalize request is 	made. Then the BFD back end fills in a table provided by the 	application with pointers to the canonical information.  To 	output symbols, the application provides BFD with a table of 	pointers to pointers to<<asymbol>>s. This allows applications 	like the linker to output a symbol as it was read, since the ``behind 	the scenes'' information will be still available. @menu @* Reading Symbols:: @* Writing Symbols:: @* typedef asymbol:: @* symbol handling functions:: @end menu  INODE Reading Symbols, Writing Symbols, Symbols, Symbols SUBSECTION 	Reading symbols  	There are two stages to reading a symbol table from a BFD: 	allocating storage, and the actual reading process. This is an 	excerpt from an application which reads the symbol table:  |	  long storage_needed; |	  asymbol **symbol_table; |	  long number_of_symbols; |	  long i; | |	  storage_needed = bfd_get_symtab_upper_bound (abfd); | |         if (storage_needed< 0) |           FAIL | |	  if (storage_needed == 0) { |	     return ; |	  } |	  symbol_table = (asymbol **) xmalloc (storage_needed); |	    ... |	  number_of_symbols = |	     bfd_canonicalize_symtab (abfd, symbol_table); | |         if (number_of_symbols< 0) |           FAIL | |	  for (i = 0; i< number_of_symbols; i++) { |	     process_symbol (symbol_table[i]); |	  }  	All storage for the symbols themselves is in an obstack 	connected to the BFD; it is freed when the BFD is closed.   INODE Writing Symbols, typedef asymbol, Reading Symbols, Symbols SUBSECTION 	Writing symbols  	Writing of a symbol table is automatic when a BFD open for 	writing is closed. The application attaches a vector of 	pointers to pointers to symbols to the BFD being written, and 	fills in the symbol count. The close and cleanup code reads 	through the table provided and performs all the necessary 	operations. The BFD output code must always be provided with an 	``owned'' symbol: one which has come from another BFD, or one 	which has been created using<<bfd_make_empty_symbol>>.  Here is an 	example showing the creation of a symbol table with only one element:  |	#include "bfd.h" |	main() |	{ |	  bfd *abfd; |	  asymbol *ptrs[2]; |	  asymbol *new; | |	  abfd = bfd_openw("foo","a.out-sunos-big"); |	  bfd_set_format(abfd, bfd_object); |	  new = bfd_make_empty_symbol(abfd); |	  new->name = "dummy_symbol"; |	  new->section = bfd_make_section_old_way(abfd, ".text"); |	  new->flags = BSF_GLOBAL; |	  new->value = 0x12345; | |	  ptrs[0] = new; |	  ptrs[1] = (asymbol *)0; | |	  bfd_set_symtab(abfd, ptrs, 1); |	  bfd_close(abfd); |	} | |	./makesym |	nm foo |	00012345 A dummy_symbol  	Many formats cannot represent arbitary symbol information; for  	instance, the<<a.out>> object format does not allow an 	arbitary number of sections. A symbol pointing to a section 	which is not one  of<<.text>>,<<.data>> or<<.bss>> cannot 	be described.  */
end_comment

begin_comment
comment|/* DOCDD INODE typedef asymbol, symbol handling functions, Writing Symbols, Symbols  */
end_comment

begin_comment
comment|/* SUBSECTION 	typedef asymbol  	An<<asymbol>> has the form:  */
end_comment

begin_comment
comment|/* CODE_FRAGMENT  . .typedef struct symbol_cache_entry .{ .	{* A pointer to the BFD which owns the symbol. This information .	   is necessary so that a back end can work out what additional .   	   information (invisible to the application writer) is carried .	   with the symbol. . .	   This field is *almost* redundant, since you can use section->owner .	   instead, except that some symbols point to the global sections .	   bfd_{abs,com,und}_section.  This could be fixed by making .	   these globals be per-bfd (or per-target-flavor).  FIXME. *} . .  struct _bfd *the_bfd; {* Use bfd_asymbol_bfd(sym) to access this field. *} . .	{* The text of the symbol. The name is left alone, and not copied; the .	   application may not alter it. *} .  CONST char *name; . .	{* The value of the symbol.  This really should be a union of a .          numeric value with a pointer, since some flags indicate that .          a pointer to another symbol is stored here.  *} .  symvalue value; . .	{* Attributes of a symbol: *} . .#define BSF_NO_FLAGS    0x00 . .	{* The symbol has local scope;<<static>> in<<C>>. The value . 	   is the offset into the section of the data. *} .#define BSF_LOCAL	0x01 . .	{* The symbol has global scope; initialized data in<<C>>. The .	   value is the offset into the section of the data. *} .#define BSF_GLOBAL	0x02 . .	{* The symbol has global scope and is exported. The value is .	   the offset into the section of the data. *} .#define BSF_EXPORT	BSF_GLOBAL {* no real difference *} . .	{* A normal C symbol would be one of: .<<BSF_LOCAL>>,<<BSF_FORT_COMM>>,<<BSF_UNDEFINED>> or .<<BSF_GLOBAL>> *} . .	{* The symbol is a debugging record. The value has an arbitary .	   meaning. *} .#define BSF_DEBUGGING	0x08 . .	{* The symbol denotes a function entry point.  Used in ELF, .	   perhaps others someday.  *} .#define BSF_FUNCTION    0x10 . .	{* Used by the linker. *} .#define BSF_KEEP        0x20 .#define BSF_KEEP_G      0x40 . .	{* A weak global symbol, overridable without warnings by .	   a regular global symbol of the same name.  *} .#define BSF_WEAK        0x80 . .       {* This symbol was created to point to a section, e.g. ELF's .	   STT_SECTION symbols.  *} .#define BSF_SECTION_SYM 0x100 . .	{* The symbol used to be a common symbol, but now it is .	   allocated. *} .#define BSF_OLD_COMMON  0x200 . .	{* The default value for common data. *} .#define BFD_FORT_COMM_DEFAULT_VALUE 0 . .	{* In some files the type of a symbol sometimes alters its .	   location in an output file - ie in coff a<<ISFCN>> symbol .	   which is also<<C_EXT>> symbol appears where it was .	   declared and not at the end of a section.  This bit is set .  	   by the target BFD part to convey this information. *} . .#define BSF_NOT_AT_END    0x400 . .	{* Signal that the symbol is the label of constructor section. *} .#define BSF_CONSTRUCTOR   0x800 . .	{* Signal that the symbol is a warning symbol. If the symbol .	   is a warning symbol, then the value field (I know this is .	   tacky) will point to the asymbol which when referenced will .	   cause the warning. *} .#define BSF_WARNING       0x1000 . .	{* Signal that the symbol is indirect. The value of the symbol .	   is a pointer to an undefined asymbol which contains the .	   name to use instead. *} .#define BSF_INDIRECT      0x2000 . .	{* BSF_FILE marks symbols that contain a file name.  This is used .	   for ELF STT_FILE symbols.  *} .#define BSF_FILE          0x4000 . .	{* Symbol is from dynamic linking information.  *} .#define BSF_DYNAMIC	   0x8000 . .  flagword flags; . .	{* A pointer to the section to which this symbol is .	   relative.  This will always be non NULL, there are special .          sections for undefined and absolute symbols *} .  struct sec *section; . .	{* Back end special data. This is being phased out in favour .	   of making this a union. *} .  PTR udata; . .} asymbol; */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"aout/stab_gnu.h"
end_include

begin_comment
comment|/* DOCDD INODE symbol handling functions,  , typedef asymbol, Symbols SUBSECTION 	Symbol handling functions */
end_comment

begin_comment
comment|/* FUNCTION 	bfd_get_symtab_upper_bound  DESCRIPTION 	Return the number of bytes required to store a vector of pointers 	to<<asymbols>> for all the symbols in the BFD @var{abfd}, 	including a terminal NULL pointer. If there are no symbols in 	the BFD, then return 0.  If an error occurs, return -1.  .#define bfd_get_symtab_upper_bound(abfd) \ .     BFD_SEND (abfd, _bfd_get_symtab_upper_bound, (abfd))  */
end_comment

begin_comment
comment|/* FUNCTION 	bfd_is_local_label  SYNOPSIS         boolean bfd_is_local_label(bfd *abfd, asymbol *sym);  DESCRIPTION 	Return true if the given symbol @var{sym} in the BFD @var{abfd} is 	a compiler generated local label, else return false. .#define bfd_is_local_label(abfd, sym) \ .     BFD_SEND (abfd, _bfd_is_local_label,(abfd, sym)) */
end_comment

begin_comment
comment|/* FUNCTION 	bfd_canonicalize_symtab  DESCRIPTION 	Read the symbols from the BFD @var{abfd}, and fills in 	the vector @var{location} with pointers to the symbols and 	a trailing NULL. 	Return the actual number of symbol pointers, not 	including the NULL.   .#define bfd_canonicalize_symtab(abfd, location) \ .     BFD_SEND (abfd, _bfd_canonicalize_symtab,\ .                  (abfd, location))  */
end_comment

begin_comment
comment|/* FUNCTION 	bfd_set_symtab  SYNOPSIS 	boolean bfd_set_symtab (bfd *abfd, asymbol **location, unsigned int count);  DESCRIPTION 	Arrange that when the output BFD @var{abfd} is closed, 	the table @var{location} of @var{count} pointers to symbols 	will be written. */
end_comment

begin_function
name|boolean
name|bfd_set_symtab
parameter_list|(
name|abfd
parameter_list|,
name|location
parameter_list|,
name|symcount
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|location
decl_stmt|;
name|unsigned
name|int
name|symcount
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|abfd
operator|->
name|format
operator|!=
name|bfd_object
operator|)
operator|||
operator|(
name|bfd_read_p
argument_list|(
name|abfd
argument_list|)
operator|)
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|bfd_get_outsymbols
argument_list|(
name|abfd
argument_list|)
operator|=
name|location
expr_stmt|;
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|=
name|symcount
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* FUNCTION 	bfd_print_symbol_vandf  SYNOPSIS 	void bfd_print_symbol_vandf(PTR file, asymbol *symbol);  DESCRIPTION 	Print the value and flags of the @var{symbol} supplied to the 	stream @var{file}. */
end_comment

begin_function
name|void
name|bfd_print_symbol_vandf
parameter_list|(
name|arg
parameter_list|,
name|symbol
parameter_list|)
name|PTR
name|arg
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
block|{
name|FILE
modifier|*
name|file
init|=
operator|(
name|FILE
operator|*
operator|)
name|arg
decl_stmt|;
name|flagword
name|type
init|=
name|symbol
operator|->
name|flags
decl_stmt|;
if|if
condition|(
name|symbol
operator|->
name|section
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|)
block|{
name|fprintf_vma
argument_list|(
name|file
argument_list|,
name|symbol
operator|->
name|value
operator|+
name|symbol
operator|->
name|section
operator|->
name|vma
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf_vma
argument_list|(
name|file
argument_list|,
name|symbol
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
comment|/* This presumes that a symbol can not be both BSF_DEBUGGING and      BSF_DYNAMIC.  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %c%c%c%c%c%c%c"
argument_list|,
operator|(
name|type
operator|&
name|BSF_LOCAL
operator|)
condition|?
literal|'l'
else|:
literal|' '
argument_list|,
operator|(
name|type
operator|&
name|BSF_GLOBAL
operator|)
condition|?
literal|'g'
else|:
literal|' '
argument_list|,
operator|(
name|type
operator|&
name|BSF_WEAK
operator|)
condition|?
literal|'w'
else|:
literal|' '
argument_list|,
operator|(
name|type
operator|&
name|BSF_CONSTRUCTOR
operator|)
condition|?
literal|'C'
else|:
literal|' '
argument_list|,
operator|(
name|type
operator|&
name|BSF_WARNING
operator|)
condition|?
literal|'W'
else|:
literal|' '
argument_list|,
operator|(
name|type
operator|&
name|BSF_INDIRECT
operator|)
condition|?
literal|'I'
else|:
literal|' '
argument_list|,
operator|(
name|type
operator|&
name|BSF_DEBUGGING
operator|)
condition|?
literal|'d'
else|:
operator|(
name|type
operator|&
name|BSF_DYNAMIC
operator|)
condition|?
literal|'D'
else|:
literal|' '
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* FUNCTION 	bfd_make_empty_symbol  DESCRIPTION 	Create a new<<asymbol>> structure for the BFD @var{abfd} 	and return a pointer to it.  	This routine is necessary because each back end has private 	information surrounding the<<asymbol>>. Building your own<<asymbol>> and pointing to it will not create the private 	information, and will cause problems later on.  .#define bfd_make_empty_symbol(abfd) \ .     BFD_SEND (abfd, _bfd_make_empty_symbol, (abfd)) */
end_comment

begin_comment
comment|/* FUNCTION 	bfd_make_debug_symbol  DESCRIPTION 	Create a new<<asymbol>> structure for the BFD @var{abfd}, 	to be used as a debugging symbol.  Further details of its use have 	yet to be worked out.  .#define bfd_make_debug_symbol(abfd,ptr,size) \ .        BFD_SEND (abfd, _bfd_make_debug_symbol, (abfd, ptr, size)) */
end_comment

begin_struct
struct|struct
name|section_to_type
block|{
name|CONST
name|char
modifier|*
name|section
decl_stmt|;
name|char
name|type
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Map section names to POSIX/BSD single-character symbol types.    This table is probably incomplete.  It is sorted for convenience of    adding entries.  Since it is so short, a linear search is used.  */
end_comment

begin_expr_stmt
specifier|static
name|CONST
expr|struct
name|section_to_type
name|stt
index|[]
operator|=
block|{
block|{
literal|"*DEBUG*"
block|,
literal|'N'
block|}
block|,
block|{
literal|".bss"
block|,
literal|'b'
block|}
block|,
block|{
literal|".data"
block|,
literal|'d'
block|}
block|,
block|{
literal|".sbss"
block|,
literal|'s'
block|}
block|,
comment|/* Small BSS (uninitialized data) */
block|{
literal|".scommon"
block|,
literal|'c'
block|}
block|,
comment|/* Small common */
block|{
literal|".sdata"
block|,
literal|'g'
block|}
block|,
comment|/* Small initialized data */
block|{
literal|".text"
block|,
literal|'t'
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Return the single-character symbol type corresponding to    section S, or '?' for an unknown COFF section.  */
end_comment

begin_function
specifier|static
name|char
name|coff_section_type
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|CONST
name|struct
name|section_to_type
modifier|*
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
operator|&
name|stt
index|[
literal|0
index|]
init|;
name|t
operator|->
name|section
condition|;
name|t
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|s
argument_list|,
name|t
operator|->
name|section
argument_list|)
condition|)
return|return
name|t
operator|->
name|type
return|;
return|return
literal|'?'
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|islower
end_ifndef

begin_define
define|#
directive|define
name|islower
parameter_list|(
name|c
parameter_list|)
value|((c)>= 'a'&& (c)<= 'z')
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|toupper
end_ifndef

begin_define
define|#
directive|define
name|toupper
parameter_list|(
name|c
parameter_list|)
value|(islower(c) ? ((c)& ~0x20) : (c))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FUNCTION 	bfd_decode_symclass  DESCRIPTION 	Return a character corresponding to the symbol 	class of @var{symbol}, or '?' for an unknown class.  SYNOPSIS 	int bfd_decode_symclass(asymbol *symbol); */
end_comment

begin_function
name|int
name|bfd_decode_symclass
parameter_list|(
name|symbol
parameter_list|)
name|asymbol
modifier|*
name|symbol
decl_stmt|;
block|{
name|char
name|c
decl_stmt|;
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
return|return
literal|'C'
return|;
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
return|return
literal|'U'
return|;
if|if
condition|(
name|bfd_is_ind_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
return|return
literal|'I'
return|;
if|if
condition|(
operator|!
operator|(
name|symbol
operator|->
name|flags
operator|&
operator|(
name|BSF_GLOBAL
operator||
name|BSF_LOCAL
operator|)
operator|)
condition|)
return|return
literal|'?'
return|;
if|if
condition|(
name|bfd_is_abs_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
name|c
operator|=
literal|'a'
expr_stmt|;
elseif|else
if|if
condition|(
name|symbol
operator|->
name|section
condition|)
name|c
operator|=
name|coff_section_type
argument_list|(
name|symbol
operator|->
name|section
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
return|return
literal|'?'
return|;
if|if
condition|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_GLOBAL
condition|)
name|c
operator|=
name|toupper
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
name|c
return|;
comment|/* We don't have to handle these cases just yet, but we will soon:      N_SETV: 'v';      N_SETA: 'l';      N_SETT: 'x';      N_SETD: 'z';      N_SETB: 's';      N_INDR: 'i';      */
block|}
end_function

begin_comment
comment|/* FUNCTION 	bfd_symbol_info  DESCRIPTION 	Fill in the basic info about symbol that nm needs. 	Additional info may be added by the back-ends after 	calling this function.  SYNOPSIS 	void bfd_symbol_info(asymbol *symbol, symbol_info *ret); */
end_comment

begin_function
name|void
name|bfd_symbol_info
parameter_list|(
name|symbol
parameter_list|,
name|ret
parameter_list|)
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|symbol_info
modifier|*
name|ret
decl_stmt|;
block|{
name|ret
operator|->
name|type
operator|=
name|bfd_decode_symclass
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|->
name|type
operator|!=
literal|'U'
condition|)
name|ret
operator|->
name|value
operator|=
name|symbol
operator|->
name|value
operator|+
name|symbol
operator|->
name|section
operator|->
name|vma
expr_stmt|;
else|else
name|ret
operator|->
name|value
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|name
operator|=
name|symbol
operator|->
name|name
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bfd_symbol_is_absolute
parameter_list|()
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

