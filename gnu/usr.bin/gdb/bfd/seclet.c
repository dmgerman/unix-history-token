begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* seclet.c    Copyright (C) 1992, 1993 Free Software Foundation, Inc.    Written by Cygnus Support.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* This module is part of BFD */
end_comment

begin_comment
comment|/* The intention is that one day, all the code which uses sections    will change and use seclets instead - maybe seglet would have been    a better name..     Anyway, a seclet contains enough info to be able to describe an    area of output memory in one go.     The only description so far catered for is that of the<<bfd_indirect_seclet>>, which is a select which points to a<<section>> and the<<asymbols>> associated with the section, so    that relocation can be done when needed.     One day there will be more types - they will at least migrate from    the linker's data structures - also there could be extra stuff,    like a bss seclet, which descibes a lump of memory as containing    zeros compactly, without the horrible SEC_* flag cruft.   */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"seclet.h"
end_include

begin_include
include|#
directive|include
file|"coff/internal.h"
end_include

begin_comment
comment|/* Create a new seclet and attach it to a section.  */
end_comment

begin_decl_stmt
name|bfd_seclet_type
modifier|*
name|DEFUN
argument_list|(
name|bfd_new_seclet
argument_list|,
operator|(
name|abfd
operator|,
name|section
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|asection
operator|*
name|section
argument_list|)
block|{
name|bfd_seclet_type
modifier|*
name|n
init|=
operator|(
name|bfd_seclet_type
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|bfd_seclet_type
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|section
operator|->
name|seclets_tail
operator|!=
operator|(
name|bfd_seclet_type
operator|*
operator|)
name|NULL
condition|)
block|{
name|section
operator|->
name|seclets_tail
operator|->
name|next
operator|=
name|n
expr_stmt|;
block|}
else|else
block|{
name|section
operator|->
name|seclets_head
operator|=
name|n
expr_stmt|;
block|}
name|section
operator|->
name|seclets_tail
operator|=
name|n
expr_stmt|;
return|return
name|n
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Given an indirect seclet which points to an input section, relocate    the contents of the seclet and put the data in its final    destination.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|DEFUN
argument_list|(
name|rel
argument_list|,
operator|(
name|abfd
operator|,
name|seclet
operator|,
name|output_section
operator|,
name|data
operator|,
name|relocateable
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|bfd_seclet_type
operator|*
name|seclet
name|AND
name|asection
operator|*
name|output_section
name|AND
name|PTR
name|data
name|AND
name|boolean
name|relocateable
argument_list|)
block|{
if|if
condition|(
operator|(
name|output_section
operator|->
name|flags
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|!=
literal|0
operator|&&
name|seclet
operator|->
name|size
condition|)
block|{
name|data
operator|=
operator|(
name|PTR
operator|)
name|bfd_get_relocated_section_contents
argument_list|(
name|abfd
argument_list|,
name|seclet
argument_list|,
name|data
argument_list|,
name|relocateable
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|output_section
argument_list|,
name|data
argument_list|,
name|seclet
operator|->
name|offset
argument_list|,
name|seclet
operator|->
name|size
argument_list|)
operator|==
name|false
condition|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|true
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Put the contents of a seclet in its final destination.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|DEFUN
argument_list|(
name|seclet_dump_seclet
argument_list|,
operator|(
name|abfd
operator|,
name|seclet
operator|,
name|section
operator|,
name|data
operator|,
name|relocateable
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|bfd_seclet_type
operator|*
name|seclet
name|AND
name|asection
operator|*
name|section
name|AND
name|PTR
name|data
name|AND
name|boolean
name|relocateable
argument_list|)
block|{
switch|switch
condition|(
name|seclet
operator|->
name|type
condition|)
block|{
case|case
name|bfd_indirect_seclet
case|:
comment|/* The contents of this section come from another one somewhere 	 else */
return|return
name|rel
argument_list|(
name|abfd
argument_list|,
name|seclet
argument_list|,
name|section
argument_list|,
name|data
argument_list|,
name|relocateable
argument_list|)
return|;
case|case
name|bfd_fill_seclet
case|:
comment|/* Fill in the section with us */
block|{
name|char
modifier|*
name|d
init|=
name|bfd_xmalloc
argument_list|(
name|seclet
operator|->
name|size
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|seclet
operator|->
name|size
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|d
index|[
name|i
index|]
operator|=
name|seclet
operator|->
name|u
operator|.
name|fill
operator|.
name|value
operator|>>
literal|8
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|seclet
operator|->
name|size
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|d
index|[
name|i
index|]
operator|=
name|seclet
operator|->
name|u
operator|.
name|fill
operator|.
name|value
expr_stmt|;
block|}
comment|/* Don't bother to fill in empty sections */
if|if
condition|(
operator|!
operator|(
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
operator|&
name|SEC_HAS_CONTENTS
operator|)
condition|)
block|{
return|return
name|true
return|;
block|}
return|return
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|d
argument_list|,
name|seclet
operator|->
name|offset
argument_list|,
name|seclet
operator|->
name|size
argument_list|)
return|;
block|}
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_decl_stmt

begin_comment
comment|/* INTERNAL_FUNCTION 	bfd_generic_seclet_link  SYNOPSIS 	boolean bfd_generic_seclet_link 	 (bfd *abfd, 	  PTR data, 	  boolean relocateable);  DESCRIPTION  	The generic seclet linking routine.  The caller should have 	set up seclets for all the output sections.  The DATA argument 	should point to a memory area large enough to hold the largest 	section.  This function looks through the seclets and moves 	the contents into the output sections.  If RELOCATEABLE is 	true, the orelocation fields of the output sections must 	already be initialized.  */
end_comment

begin_decl_stmt
name|boolean
name|DEFUN
argument_list|(
name|bfd_generic_seclet_link
argument_list|,
operator|(
name|abfd
operator|,
name|data
operator|,
name|relocateable
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|PTR
name|data
name|AND
name|boolean
name|relocateable
argument_list|)
block|{
name|asection
modifier|*
name|o
init|=
name|abfd
operator|->
name|sections
decl_stmt|;
while|while
condition|(
name|o
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|)
block|{
name|bfd_seclet_type
modifier|*
name|p
init|=
name|o
operator|->
name|seclets_head
decl_stmt|;
while|while
condition|(
name|p
operator|!=
operator|(
name|bfd_seclet_type
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
name|seclet_dump_seclet
argument_list|(
name|abfd
argument_list|,
name|p
argument_list|,
name|o
argument_list|,
name|data
argument_list|,
name|relocateable
argument_list|)
operator|==
name|false
condition|)
return|return
name|false
return|;
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
name|o
operator|=
name|o
operator|->
name|next
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_decl_stmt

end_unit

