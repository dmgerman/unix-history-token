begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ELF executable support for BFD.    Copyright 1993 Free Software Foundation, Inc.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/*  SECTION 	ELF backends  	BFD support for ELF formats is being worked on. 	Currently, the best supported back ends are for sparc and i386 	(running svr4 or Solaris 2).  	Documentation of the internals of the support code still needs 	to be written.  The code is changing quickly enough that we 	haven't bothered yet.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_define
define|#
directive|define
name|ARCH_SIZE
value|0
end_define

begin_include
include|#
directive|include
file|"libelf.h"
end_include

begin_comment
comment|/* Standard ELF hash function.  Do not change this function; you will    cause invalid hash tables to be generated.  (Well, you would if this    were being used yet.)  */
end_comment

begin_function
name|unsigned
name|long
name|bfd_elf_hash
parameter_list|(
name|name
parameter_list|)
name|CONST
name|unsigned
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|unsigned
name|long
name|h
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|g
decl_stmt|;
name|int
name|ch
decl_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
operator|*
name|name
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
block|{
name|h
operator|=
operator|(
name|h
operator|<<
literal|4
operator|)
operator|+
name|ch
expr_stmt|;
if|if
condition|(
operator|(
name|g
operator|=
operator|(
name|h
operator|&
literal|0xf0000000
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|h
operator|^=
name|g
operator|>>
literal|24
expr_stmt|;
name|h
operator|&=
operator|~
name|g
expr_stmt|;
block|}
block|}
return|return
name|h
return|;
block|}
end_function

begin_comment
comment|/* Read a specified number of bytes at a specified offset in an ELF    file, into a newly allocated buffer, and return a pointer to the    buffer. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|elf_read
parameter_list|(
name|abfd
parameter_list|,
name|offset
parameter_list|,
name|size
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|long
name|offset
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|char
modifier|*
name|buf
decl_stmt|;
if|if
condition|(
operator|(
name|buf
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|buf
argument_list|,
name|size
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
name|size
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_system_call
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_file_truncated
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|buf
return|;
block|}
end_function

begin_function
name|boolean
name|elf_mkobject
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
comment|/* this just does initialization */
comment|/* coff_mkobject zalloc's space for tdata.coff_obj_data ... */
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|=
operator|(
expr|struct
name|elf_obj_tdata
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|elf_obj_tdata
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|==
literal|0
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* since everything is done at close time, do we need any      initialization? */
return|return
name|true
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|elf_get_str_section
parameter_list|(
name|abfd
parameter_list|,
name|shindex
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|unsigned
name|int
name|shindex
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
modifier|*
name|i_shdrp
decl_stmt|;
name|char
modifier|*
name|shstrtab
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|offset
decl_stmt|;
name|unsigned
name|int
name|shstrtabsize
decl_stmt|;
name|i_shdrp
operator|=
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|i_shdrp
operator|==
literal|0
operator|||
name|i_shdrp
index|[
name|shindex
index|]
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|shstrtab
operator|=
name|i_shdrp
index|[
name|shindex
index|]
operator|->
name|rawdata
expr_stmt|;
if|if
condition|(
name|shstrtab
operator|==
name|NULL
condition|)
block|{
comment|/* No cached one, attempt to read, and cache what we read. */
name|offset
operator|=
name|i_shdrp
index|[
name|shindex
index|]
operator|->
name|sh_offset
expr_stmt|;
name|shstrtabsize
operator|=
name|i_shdrp
index|[
name|shindex
index|]
operator|->
name|sh_size
expr_stmt|;
name|shstrtab
operator|=
name|elf_read
argument_list|(
name|abfd
argument_list|,
name|offset
argument_list|,
name|shstrtabsize
argument_list|)
expr_stmt|;
name|i_shdrp
index|[
name|shindex
index|]
operator|->
name|rawdata
operator|=
operator|(
name|void
operator|*
operator|)
name|shstrtab
expr_stmt|;
block|}
return|return
name|shstrtab
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|elf_string_from_elf_section
parameter_list|(
name|abfd
parameter_list|,
name|shindex
parameter_list|,
name|strindex
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|unsigned
name|int
name|shindex
decl_stmt|;
name|unsigned
name|int
name|strindex
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
if|if
condition|(
name|strindex
operator|==
literal|0
condition|)
return|return
literal|""
return|;
name|hdr
operator|=
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
index|[
name|shindex
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|hdr
operator|->
name|rawdata
operator|&&
name|elf_get_str_section
argument_list|(
name|abfd
argument_list|,
name|shindex
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|hdr
operator|->
name|rawdata
operator|)
operator|+
name|strindex
return|;
block|}
end_function

begin_comment
comment|/* Make a BFD section from an ELF section.  We store a pointer to the    BFD section in the rawdata field of the header.  */
end_comment

begin_function
name|boolean
name|_bfd_elf_make_section_from_shdr
parameter_list|(
name|abfd
parameter_list|,
name|hdr
parameter_list|,
name|name
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|asection
modifier|*
name|newsect
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
if|if
condition|(
name|hdr
operator|->
name|rawdata
operator|!=
name|NULL
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|strcmp
argument_list|(
name|name
argument_list|,
operator|(
operator|(
name|asection
operator|*
operator|)
name|hdr
operator|->
name|rawdata
operator|)
operator|->
name|name
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
name|newsect
operator|=
name|bfd_make_section_anyway
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|newsect
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|newsect
operator|->
name|filepos
operator|=
name|hdr
operator|->
name|sh_offset
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_vma
argument_list|(
name|abfd
argument_list|,
name|newsect
argument_list|,
name|hdr
operator|->
name|sh_addr
argument_list|)
operator|||
operator|!
name|bfd_set_section_size
argument_list|(
name|abfd
argument_list|,
name|newsect
argument_list|,
name|hdr
operator|->
name|sh_size
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|newsect
argument_list|,
name|bfd_log2
argument_list|(
name|hdr
operator|->
name|sh_addralign
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
name|flags
operator|=
name|SEC_NO_FLAGS
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|sh_type
operator|!=
name|SHT_NOBITS
condition|)
name|flags
operator||=
name|SEC_HAS_CONTENTS
expr_stmt|;
if|if
condition|(
operator|(
name|hdr
operator|->
name|sh_flags
operator|&
name|SHF_ALLOC
operator|)
operator|!=
literal|0
condition|)
block|{
name|flags
operator||=
name|SEC_ALLOC
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|sh_type
operator|!=
name|SHT_NOBITS
condition|)
name|flags
operator||=
name|SEC_LOAD
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|hdr
operator|->
name|sh_flags
operator|&
name|SHF_WRITE
operator|)
operator|==
literal|0
condition|)
name|flags
operator||=
name|SEC_READONLY
expr_stmt|;
if|if
condition|(
operator|(
name|hdr
operator|->
name|sh_flags
operator|&
name|SHF_EXECINSTR
operator|)
operator|!=
literal|0
condition|)
name|flags
operator||=
name|SEC_CODE
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|!=
literal|0
condition|)
name|flags
operator||=
name|SEC_DATA
expr_stmt|;
comment|/* The debugging sections appear to be recognized only by name, not      any sort of flag.  */
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".debug"
argument_list|,
sizeof|sizeof
expr|".debug"
operator|-
literal|1
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".line"
argument_list|,
sizeof|sizeof
expr|".line"
operator|-
literal|1
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".stab"
argument_list|,
sizeof|sizeof
expr|".stab"
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|flags
operator||=
name|SEC_DEBUGGING
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|newsect
argument_list|,
name|flags
argument_list|)
condition|)
return|return
name|false
return|;
name|hdr
operator|->
name|rawdata
operator|=
operator|(
name|PTR
operator|)
name|newsect
expr_stmt|;
name|elf_section_data
argument_list|(
name|newsect
argument_list|)
operator|->
name|this_hdr
operator|=
operator|*
name|hdr
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* INTERNAL_FUNCTION 	bfd_elf_find_section  SYNOPSIS 	struct elf_internal_shdr *bfd_elf_find_section (bfd *abfd, char *name);  DESCRIPTION 	Helper functions for GDB to locate the string tables. 	Since BFD hides string tables from callers, GDB needs to use an 	internal hook to find them.  Sun's .stabstr, in particular, 	isn't even pointed to by the .stab section, so ordinary 	mechanisms wouldn't work to find it, even if we had some. */
end_comment

begin_function
name|struct
name|elf_internal_shdr
modifier|*
name|bfd_elf_find_section
parameter_list|(
name|abfd
parameter_list|,
name|name
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
modifier|*
name|i_shdrp
decl_stmt|;
name|char
modifier|*
name|shstrtab
decl_stmt|;
name|unsigned
name|int
name|max
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|i_shdrp
operator|=
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|i_shdrp
operator|!=
name|NULL
condition|)
block|{
name|shstrtab
operator|=
name|elf_get_str_section
argument_list|(
name|abfd
argument_list|,
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_shstrndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|shstrtab
operator|!=
name|NULL
condition|)
block|{
name|max
operator|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_shnum
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|&
name|shstrtab
index|[
name|i_shdrp
index|[
name|i
index|]
operator|->
name|sh_name
index|]
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|i_shdrp
index|[
name|i
index|]
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|const
name|char
modifier|*
specifier|const
name|bfd_elf_section_type_names
index|[]
init|=
block|{
literal|"SHT_NULL"
block|,
literal|"SHT_PROGBITS"
block|,
literal|"SHT_SYMTAB"
block|,
literal|"SHT_STRTAB"
block|,
literal|"SHT_RELA"
block|,
literal|"SHT_HASH"
block|,
literal|"SHT_DYNAMIC"
block|,
literal|"SHT_NOTE"
block|,
literal|"SHT_NOBITS"
block|,
literal|"SHT_REL"
block|,
literal|"SHT_SHLIB"
block|,
literal|"SHT_DYNSYM"
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ELF relocs are against symbols.  If we are producing relocateable    output, and the reloc is against an external symbol, and nothing    has given us any additional addend, the resulting reloc will also    be against the same symbol.  In such a case, we don't want to    change anything about the way the reloc is handled, since it will    all be done at final link time.  Rather than put special case code    into bfd_perform_relocation, all the reloc types use this howto    function.  It just short circuits the reloc if producing    relocateable output against an external symbol.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|bfd_reloc_status_type
name|bfd_elf_generic_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
decl_stmt|;
block|{
if|if
condition|(
name|output_bfd
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
operator|&&
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|!
name|reloc_entry
operator|->
name|howto
operator|->
name|partial_inplace
operator|||
name|reloc_entry
operator|->
name|addend
operator|==
literal|0
operator|)
condition|)
block|{
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
return|return
name|bfd_reloc_continue
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create an entry in an ELF linker hash table.  */
end_comment

begin_function
name|struct
name|bfd_hash_entry
modifier|*
name|_bfd_elf_link_hash_newfunc
parameter_list|(
name|entry
parameter_list|,
name|table
parameter_list|,
name|string
parameter_list|)
name|struct
name|bfd_hash_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|bfd_hash_table
modifier|*
name|table
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|ret
init|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|entry
decl_stmt|;
comment|/* Allocate the structure if it has not already been allocated by a      subclass.  */
if|if
condition|(
name|ret
operator|==
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
name|ret
operator|=
operator|(
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|bfd_hash_allocate
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|elf_link_hash_entry
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
return|;
block|}
comment|/* Call the allocation method of the superclass.  */
name|ret
operator|=
operator|(
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|_bfd_link_hash_newfunc
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
argument_list|,
name|table
argument_list|,
name|string
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* Set local fields.  */
name|ret
operator|->
name|indx
operator|=
operator|-
literal|1
expr_stmt|;
name|ret
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|align
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|dynindx
operator|=
operator|-
literal|1
expr_stmt|;
name|ret
operator|->
name|dynstr_index
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|weakdef
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|type
operator|=
name|STT_NOTYPE
expr_stmt|;
name|ret
operator|->
name|elf_link_hash_flags
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Initialize an ELF linker hash table.  */
end_comment

begin_decl_stmt
name|boolean
name|_bfd_elf_link_hash_table_init
argument_list|(
name|table
argument_list|,
name|abfd
argument_list|,
name|newfunc
argument_list|)
decl|struct
name|elf_link_hash_table
modifier|*
name|table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd
modifier|*
name|abfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|bfd_hash_entry
modifier|*
argument_list|(
operator|*
name|newfunc
argument_list|)
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|,
expr|struct
name|bfd_hash_table
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|table
operator|->
name|dynobj
operator|=
name|NULL
expr_stmt|;
name|table
operator|->
name|dynsymcount
operator|=
literal|0
expr_stmt|;
name|table
operator|->
name|dynstr
operator|=
name|NULL
expr_stmt|;
name|table
operator|->
name|bucketcount
operator|=
literal|0
expr_stmt|;
return|return
name|_bfd_link_hash_table_init
argument_list|(
operator|&
name|table
operator|->
name|root
argument_list|,
name|abfd
argument_list|,
name|newfunc
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/* Create an ELF linker hash table.  */
end_comment

begin_function
name|struct
name|bfd_link_hash_table
modifier|*
name|_bfd_elf_link_hash_table_create
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|struct
name|elf_link_hash_table
modifier|*
name|ret
decl_stmt|;
name|ret
operator|=
operator|(
operator|(
expr|struct
name|elf_link_hash_table
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|elf_link_hash_table
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|(
expr|struct
name|elf_link_hash_table
operator|*
operator|)
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
name|_bfd_elf_link_hash_table_init
argument_list|(
name|ret
argument_list|,
name|abfd
argument_list|,
name|_bfd_elf_link_hash_newfunc
argument_list|)
condition|)
block|{
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
operator|&
name|ret
operator|->
name|root
return|;
block|}
end_function

begin_comment
comment|/* This is a hook for the ELF emulation code in the generic linker to    tell the backend linker what file name to use for the DT_NEEDED    entry for a dynamic object.  */
end_comment

begin_function
name|void
name|bfd_elf_set_dt_needed_name
parameter_list|(
name|abfd
parameter_list|,
name|name
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|elf_dt_needed_name
argument_list|(
name|abfd
argument_list|)
operator|=
name|name
expr_stmt|;
block|}
end_function

end_unit

