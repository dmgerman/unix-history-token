begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Generic BFD support for file formats.    Copyright (C) 1990-1991 Free Software Foundation, Inc.    Written by Cygnus Support.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* SECTION 	File Formats  	A format is a BFD concept of high level file contents. The 	formats supported by BFD are:   	o bfd_object  	The BFD may contain data, symbols, relocations and debug info.  	o bfd_archive  	The BFD contains other BFDs and an optional index.  	o bfd_core  	The BFD contains the result of an executable core dump.   */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_decl_stmt
specifier|extern
name|bfd_target
modifier|*
name|target_vector
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_target
modifier|*
name|default_vector
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* FUNCTION 	bfd_check_format  SYNOPSIS 	boolean bfd_check_format(bfd *abfd, bfd_format format);  DESCRIPTION 	This routine is supplied a BFD and a format. It attempts to 	verify if the file attached to the BFD is indeed compatible 	with the format specified (ie, one of<<bfd_object>>,<<bfd_archive>> or<<bfd_core>>).  	If the BFD has been set to a specific @var{target} before the 	call, only the named target and format combination will be 	checked. If the target has not been set, or has been set to<<default>> then all the known target backends will be 	interrogated to determine a match.  If the default target 	matches, it is used.  If not, exactly one target must recognize 	the file, or an error results.  	The function returns<<true>> on success, otherwise<<false>> 	with one of the following error codes:    	o invalid_operation - 	if<<format>> is not one of<<bfd_object>>,<<bfd_archive>> or<<bfd_core>>.  	o system_call_error - 	if an error occured during a read - even some file mismatches 	can cause system_call_errors  	o file_not_recognised - 	none of the backends recognised the file format  	o file_ambiguously_recognized - 	more than one backend recognised the file format.  */
end_comment

begin_decl_stmt
name|boolean
name|DEFUN
argument_list|(
name|bfd_check_format
argument_list|,
operator|(
name|abfd
operator|,
name|format
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|bfd_format
name|format
argument_list|)
block|{
name|bfd_target
modifier|*
modifier|*
name|target
decl_stmt|,
modifier|*
name|save_targ
decl_stmt|,
modifier|*
name|right_targ
decl_stmt|;
name|int
name|match_count
decl_stmt|;
if|if
condition|(
operator|!
name|bfd_read_p
argument_list|(
name|abfd
argument_list|)
operator|||
operator|(
call|(
name|int
call|)
argument_list|(
name|abfd
operator|->
name|format
argument_list|)
operator|<
operator|(
name|int
operator|)
name|bfd_unknown
operator|)
operator|||
operator|(
call|(
name|int
call|)
argument_list|(
name|abfd
operator|->
name|format
argument_list|)
operator|>=
operator|(
name|int
operator|)
name|bfd_type_end
operator|)
condition|)
block|{
name|bfd_error
operator|=
name|invalid_operation
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|abfd
operator|->
name|format
operator|!=
name|bfd_unknown
condition|)
return|return
operator|(
name|abfd
operator|->
name|format
operator|==
name|format
operator|)
condition|?
name|true
else|:
name|false
return|;
comment|/* Since the target type was defaulted, check them       all in the hope that one will be uniquely recognized.  */
name|save_targ
operator|=
name|abfd
operator|->
name|xvec
expr_stmt|;
name|match_count
operator|=
literal|0
expr_stmt|;
name|right_targ
operator|=
literal|0
expr_stmt|;
comment|/* presume the answer is yes */
name|abfd
operator|->
name|format
operator|=
name|format
expr_stmt|;
comment|/* If the target type was explicitly specified, just check that target.  */
if|if
condition|(
operator|!
name|abfd
operator|->
name|target_defaulted
condition|)
block|{
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
comment|/* rewind! */
name|right_targ
operator|=
name|BFD_SEND_FMT
argument_list|(
name|abfd
argument_list|,
name|_bfd_check_format
argument_list|,
operator|(
name|abfd
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|right_targ
condition|)
block|{
name|abfd
operator|->
name|xvec
operator|=
name|right_targ
expr_stmt|;
comment|/* Set the target as returned */
return|return
name|true
return|;
comment|/* File position has moved, BTW */
block|}
block|}
for|for
control|(
name|target
operator|=
name|target_vector
init|;
operator|*
name|target
operator|!=
name|NULL
condition|;
name|target
operator|++
control|)
block|{
name|bfd_target
modifier|*
name|temp
decl_stmt|;
name|abfd
operator|->
name|xvec
operator|=
operator|*
name|target
expr_stmt|;
comment|/* Change BFD's target temporarily */
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
comment|/* If _bfd_check_format neglects to set bfd_error, assume wrong_format.        We didn't used to even pay any attention to bfd_error, so I suspect        that some _bfd_check_format might have this problem.  */
name|bfd_error
operator|=
name|wrong_format
expr_stmt|;
name|temp
operator|=
name|BFD_SEND_FMT
argument_list|(
name|abfd
argument_list|,
name|_bfd_check_format
argument_list|,
operator|(
name|abfd
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
block|{
comment|/* This format checks out as ok! */
name|right_targ
operator|=
name|temp
expr_stmt|;
name|match_count
operator|++
expr_stmt|;
comment|/* If this is the default target, accept it, even if other targets 	 might match.  People who want those other targets have to set  	 the GNUTARGET variable.  */
if|if
condition|(
name|temp
operator|==
name|default_vector
index|[
literal|0
index|]
condition|)
block|{
name|match_count
operator|=
literal|1
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|GNU960
comment|/* Big- and little-endian b.out archives look the same, but it doesn't        * matter: there is no difference in their headers, and member file byte        * orders will (I hope) be handled appropriately by bfd.  Ditto for big        * and little coff archives.  And the 4 coff/b.out object formats are        * unambiguous.  So accept the first match we find.        */
break|break;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|bfd_error
operator|!=
name|wrong_format
condition|)
block|{
name|abfd
operator|->
name|xvec
operator|=
name|save_targ
expr_stmt|;
name|abfd
operator|->
name|format
operator|=
name|bfd_unknown
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
if|if
condition|(
name|match_count
operator|==
literal|1
condition|)
block|{
name|abfd
operator|->
name|xvec
operator|=
name|right_targ
expr_stmt|;
comment|/* Change BFD's target permanently */
return|return
name|true
return|;
comment|/* File position has moved, BTW */
block|}
name|abfd
operator|->
name|xvec
operator|=
name|save_targ
expr_stmt|;
comment|/* Restore original target type */
name|abfd
operator|->
name|format
operator|=
name|bfd_unknown
expr_stmt|;
comment|/* Restore original format */
name|bfd_error
operator|=
operator|(
operator|(
name|match_count
operator|==
literal|0
operator|)
condition|?
name|file_not_recognized
else|:
name|file_ambiguously_recognized
operator|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_decl_stmt

begin_comment
comment|/* FUNCTION 	bfd_set_format  SYNOPSIS 	boolean bfd_set_format(bfd *, bfd_format);  DESCRIPTION 	This function sets the file format of the supplied BFD to the 	format requested. If the target set in the BFD does not 	support the format requested, the format is illegal or the BFD 	is not open for writing than an error occurs.  */
end_comment

begin_decl_stmt
name|boolean
name|DEFUN
argument_list|(
name|bfd_set_format
argument_list|,
operator|(
name|abfd
operator|,
name|format
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|bfd_format
name|format
argument_list|)
block|{
if|if
condition|(
name|bfd_read_p
argument_list|(
name|abfd
argument_list|)
operator|||
operator|(
operator|(
name|int
operator|)
name|abfd
operator|->
name|format
operator|<
operator|(
name|int
operator|)
name|bfd_unknown
operator|)
operator|||
operator|(
operator|(
name|int
operator|)
name|abfd
operator|->
name|format
operator|>=
operator|(
name|int
operator|)
name|bfd_type_end
operator|)
condition|)
block|{
name|bfd_error
operator|=
name|invalid_operation
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|abfd
operator|->
name|format
operator|!=
name|bfd_unknown
condition|)
return|return
operator|(
name|abfd
operator|->
name|format
operator|==
name|format
operator|)
condition|?
name|true
else|:
name|false
return|;
comment|/* presume the answer is yes */
name|abfd
operator|->
name|format
operator|=
name|format
expr_stmt|;
if|if
condition|(
operator|!
name|BFD_SEND_FMT
argument_list|(
name|abfd
argument_list|,
name|_bfd_set_format
argument_list|,
operator|(
name|abfd
operator|)
argument_list|)
condition|)
block|{
name|abfd
operator|->
name|format
operator|=
name|bfd_unknown
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_decl_stmt

begin_comment
comment|/* FUNCTION 	bfd_format_string  SYNOPSIS 	CONST char *bfd_format_string(bfd_format);  DESCRIPTION 	This function takes one argument, and enumerated type 	(bfd_format) and returns a pointer to a const string<<invalid>>,<<object>>,<<archive>>,<<core>> or<<unknown>> 	depending upon the value of the enumeration. */
end_comment

begin_decl_stmt
name|CONST
name|char
modifier|*
name|DEFUN
argument_list|(
name|bfd_format_string
argument_list|,
operator|(
name|format
operator|)
argument_list|,
name|bfd_format
name|format
argument_list|)
block|{
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|format
operator|<
operator|(
name|int
operator|)
name|bfd_unknown
operator|)
operator|||
operator|(
operator|(
name|int
operator|)
name|format
operator|>=
operator|(
name|int
operator|)
name|bfd_type_end
operator|)
condition|)
return|return
literal|"invalid"
return|;
switch|switch
condition|(
name|format
condition|)
block|{
case|case
name|bfd_object
case|:
return|return
literal|"object"
return|;
comment|/* linker/assember/compiler output */
case|case
name|bfd_archive
case|:
return|return
literal|"archive"
return|;
comment|/* object archive file */
case|case
name|bfd_core
case|:
return|return
literal|"core"
return|;
comment|/* core dump */
default|default:
return|return
literal|"unknown"
return|;
block|}
block|}
end_decl_stmt

end_unit

