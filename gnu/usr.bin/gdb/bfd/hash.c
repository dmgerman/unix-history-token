begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* hash.c -- hash table routines for BFD    Copyright (C) 1993, 94 Free Software Foundation, Inc.    Written by Steve Chamberlain<sac@cygnus.com>  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_comment
comment|/* SECTION 	Hash Tables  @cindex Hash tables 	BFD provides a simple set of hash table functions.  Routines 	are provided to initialize a hash table, to free a hash table, 	to look up a string in a hash table and optionally create an 	entry for it, and to traverse a hash table.  There is 	currently no routine to delete an string from a hash table.  	The basic hash table does not permit any data to be stored 	with a string.  However, a hash table is designed to present a 	base class from which other types of hash tables may be 	derived.  These derived types may store additional information 	with the string.  Hash tables were implemented in this way, 	rather than simply providing a data pointer in a hash table 	entry, because they were designed for use by the linker back 	ends.  The linker may create thousands of hash table entries, 	and the overhead of allocating private data and storing and 	following pointers becomes noticeable.  	The basic hash table code is in<<hash.c>>.  @menu @* Creating and Freeing a Hash Table:: @* Looking Up or Entering a String:: @* Traversing a Hash Table:: @* Deriving a New Hash Table Type:: @end menu  INODE Creating and Freeing a Hash Table, Looking Up or Entering a String, Hash Tables, Hash Tables SUBSECTION 	Creating and freeing a hash table  @findex bfd_hash_table_init @findex bfd_hash_table_init_n 	To create a hash table, create an instance of a<<struct 	bfd_hash_table>> (defined in<<bfd.h>>) and call<<bfd_hash_table_init>> (if you know approximately how many 	entries you will need, the function<<bfd_hash_table_init_n>>, 	which takes a @var{size} argument, may be used).<<bfd_hash_table_init>> returns<<false>> if some sort of 	error occurs.  @findex bfd_hash_newfunc 	The function<<bfd_hash_table_init>> take as an argument a 	function to use to create new entries.  For a basic hash 	table, use the function<<bfd_hash_newfunc>>.  @xref{Deriving 	a New Hash Table Type} for why you would want to use a 	different value for this argument.  @findex bfd_hash_allocate<<bfd_hash_table_init>> will create an obstack which will be 	used to allocate new entries.  You may allocate memory on this 	obstack using<<bfd_hash_allocate>>.  @findex bfd_hash_table_free 	Use<<bfd_hash_table_free>> to free up all the memory that has 	been allocated for a hash table.  This will not free up the<<struct bfd_hash_table>> itself, which you must provide.  INODE Looking Up or Entering a String, Traversing a Hash Table, Creating and Freeing a Hash Table, Hash Tables SUBSECTION 	Looking up or entering a string  @findex bfd_hash_lookup 	The function<<bfd_hash_lookup>> is used both to look up a 	string in the hash table and to create a new entry.  	If the @var{create} argument is<<false>>,<<bfd_hash_lookup>> 	will look up a string.  If the string is found, it will 	returns a pointer to a<<struct bfd_hash_entry>>.  If the 	string is not found in the table<<bfd_hash_lookup>> will 	return<<NULL>>.  You should not modify any of the fields in 	the returns<<struct bfd_hash_entry>>.  	If the @var{create} argument is<<true>>, the string will be 	entered into the hash table if it is not already there. 	Either way a pointer to a<<struct bfd_hash_entry>> will be 	returned, either to the existing structure or to a newly 	created one.  In this case, a<<NULL>> return means that an 	error occurred.  	If the @var{create} argument is<<true>>, and a new entry is 	created, the @var{copy} argument is used to decide whether to 	copy the string onto the hash table obstack or not.  If 	@var{copy} is passed as<<false>>, you must be careful not to 	deallocate or modify the string as long as the hash table 	exists.  INODE Traversing a Hash Table, Deriving a New Hash Table Type, Looking Up or Entering a String, Hash Tables SUBSECTION 	Traversing a hash table  @findex bfd_hash_traverse 	The function<<bfd_hash_traverse>> may be used to traverse a 	hash table, calling a function on each element.  The traversal 	is done in a random order.<<bfd_hash_traverse>> takes as arguments a function and a 	generic<<void *>> pointer.  The function is called with a 	hash table entry (a<<struct bfd_hash_entry *>>) and the 	generic pointer passed to<<bfd_hash_traverse>>.  The function 	must return a<<boolean>> value, which indicates whether to 	continue traversing the hash table.  If the function returns<<false>>,<<bfd_hash_traverse>> will stop the traversal and 	return immediately.  INODE Deriving a New Hash Table Type, , Traversing a Hash Table, Hash Tables SUBSECTION 	Deriving a new hash table type  	Many uses of hash tables want to store additional information 	which each entry in the hash table.  Some also find it 	convenient to store additional information with the hash table 	itself.  This may be done using a derived hash table.  	Since C is not an object oriented language, creating a derived 	hash table requires sticking together some boilerplate 	routines with a few differences specific to the type of hash 	table you want to create.  	An example of a derived hash table is the linker hash table. 	The structures for this are defined in<<bfdlink.h>>.  The 	functions are in<<linker.c>>.  	You may also derive a hash table from an already derived hash 	table.  For example, the a.out linker backend code uses a hash 	table derived from the linker hash table.  @menu @* Define the Derived Structures:: @* Write the Derived Creation Routine:: @* Write Other Derived Routines:: @end menu  INODE Define the Derived Structures, Write the Derived Creation Routine, Deriving a New Hash Table Type, Deriving a New Hash Table Type SUBSUBSECTION 	Define the derived structures  	You must define a structure for an entry in the hash table, 	and a structure for the hash table itself.  	The first field in the structure for an entry in the hash 	table must be of the type used for an entry in the hash table 	you are deriving from.  If you are deriving from a basic hash 	table this is<<struct bfd_hash_entry>>, which is defined in<<bfd.h>>.  The first field in the structure for the hash 	table itself must be of the type of the hash table you are 	deriving from itself.  If you are deriving from a basic hash 	table, this is<<struct bfd_hash_table>>.  	For example, the linker hash table defines<<struct 	bfd_link_hash_entry>> (in<<bfdlink.h>>).  The first field,<<root>>, is of type<<struct bfd_hash_entry>>.  Similarly, 	the first field in<<struct bfd_link_hash_table>>,<<table>>, 	is of type<<struct bfd_hash_table>>.  INODE Write the Derived Creation Routine, Write Other Derived Routines, Define the Derived Structures, Deriving a New Hash Table Type SUBSUBSECTION 	Write the derived creation routine  	You must write a routine which will create and initialize an 	entry in the hash table.  This routine is passed as the 	function argument to<<bfd_hash_table_init>>.  	In order to permit other hash tables to be derived from the 	hash table you are creating, this routine must be written in a 	standard way.  	The first argument to the creation routine is a pointer to a 	hash table entry.  This may be<<NULL>>, in which case the 	routine should allocate the right amount of space.  Otherwise 	the space has already been allocated by a hash table type 	derived from this one.  	After allocating space, the creation routine must call the 	creation routine of the hash table type it is derived from, 	passing in a pointer to the space it just allocated.  This 	will initialize any fields used by the base hash table.  	Finally the creation routine must initialize any local fields 	for the new hash table type.  	Here is a boilerplate example of a creation routine. 	@var{function_name} is the name of the routine. 	@var{entry_type} is the type of an entry in the hash table you 	are creating.  @var{base_newfunc} is the name of the creation 	routine of the hash table type your hash table is derived 	from.  EXAMPLE  .struct bfd_hash_entry * .@var{function_name} (entry, table, string) .     struct bfd_hash_entry *entry; .     struct bfd_hash_table *table; .     const char *string; .{ .  struct @var{entry_type} *ret = (@var{entry_type} *) entry; . . {* Allocate the structure if it has not already been allocated by a .    derived class.  *} .  if (ret == (@var{entry_type} *) NULL) .    { .      ret = ((@var{entry_type} *) .	      bfd_hash_allocate (table, sizeof (@var{entry_type}))); .      if (ret == (@var{entry_type} *) NULL) .        return NULL; .    } . . {* Call the allocation method of the base class.  *} .  ret = ((@var{entry_type} *) .	 @var{base_newfunc} ((struct bfd_hash_entry *) ret, table, string)); . . {* Initialize the local fields here.  *} . .  return (struct bfd_hash_entry *) ret; .}  DESCRIPTION 	The creation routine for the linker hash table, which is in<<linker.c>>, looks just like this example. 	@var{function_name} is<<_bfd_link_hash_newfunc>>. 	@var{entry_type} is<<struct bfd_link_hash_entry>>. 	@var{base_newfunc} is<<bfd_hash_newfunc>>, the creation 	routine for a basic hash table.<<_bfd_link_hash_newfunc>> also initializes the local fields 	in a linker hash table entry:<<type>>,<<written>> and<<next>>.  INODE Write Other Derived Routines, , Write the Derived Creation Routine, Deriving a New Hash Table Type SUBSUBSECTION 	Write other derived routines  	You will want to write other routines for your new hash table, 	as well.    	You will want an initialization routine which calls the 	initialization routine of the hash table you are deriving from 	and initializes any other local fields.  For the linker hash 	table, this is<<_bfd_link_hash_table_init>> in<<linker.c>>.  	You will want a lookup routine which calls the lookup routine 	of the hash table you are deriving from and casts the result. 	The linker hash table uses<<bfd_link_hash_lookup>> in<<linker.c>> (this actually takes an additional argument which 	it uses to decide how to return the looked up value).  	You may want a traversal routine.  This should just call the 	traversal routine of the hash table you are deriving from with 	appropriate casts.  The linker hash table uses<<bfd_link_hash_traverse>> in<<linker.c>>.  	These routines may simply be defined as macros.  For example, 	the a.out backend linker hash table, which is derived from the 	linker hash table, uses macros for the lookup and traversal 	routines.  These are<<aout_link_hash_lookup>> and<<aout_link_hash_traverse>> in aoutx.h. */
end_comment

begin_comment
comment|/* Obstack allocation and deallocation routines.  */
end_comment

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|malloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_comment
comment|/* The default number of entries to use when creating a hash table.  */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_SIZE
value|(4051)
end_define

begin_comment
comment|/* Create a new hash table, given a number of entries.  */
end_comment

begin_decl_stmt
name|boolean
name|bfd_hash_table_init_n
argument_list|(
name|table
argument_list|,
name|newfunc
argument_list|,
name|size
argument_list|)
decl|struct
name|bfd_hash_table
modifier|*
name|table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|bfd_hash_entry
modifier|*
argument_list|(
operator|*
name|newfunc
argument_list|)
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|,
expr|struct
name|bfd_hash_table
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|unsigned
name|int
name|alloc
decl_stmt|;
name|alloc
operator|=
name|size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|bfd_hash_entry
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|obstack_begin
argument_list|(
operator|&
name|table
operator|->
name|memory
argument_list|,
name|alloc
argument_list|)
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|table
operator|->
name|table
operator|=
operator|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|table
operator|->
name|memory
argument_list|,
name|alloc
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|table
operator|->
name|table
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|memset
argument_list|(
operator|(
name|PTR
operator|)
name|table
operator|->
name|table
argument_list|,
literal|0
argument_list|,
name|alloc
argument_list|)
expr_stmt|;
name|table
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|table
operator|->
name|newfunc
operator|=
name|newfunc
expr_stmt|;
return|return
name|true
return|;
block|}
end_block

begin_comment
comment|/* Create a new hash table with the default number of entries.  */
end_comment

begin_decl_stmt
name|boolean
name|bfd_hash_table_init
argument_list|(
name|table
argument_list|,
name|newfunc
argument_list|)
decl|struct
name|bfd_hash_table
modifier|*
name|table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|bfd_hash_entry
modifier|*
argument_list|(
operator|*
name|newfunc
argument_list|)
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|,
expr|struct
name|bfd_hash_table
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
name|bfd_hash_table_init_n
argument_list|(
name|table
argument_list|,
name|newfunc
argument_list|,
name|DEFAULT_SIZE
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/* Free a hash table.  */
end_comment

begin_function
name|void
name|bfd_hash_table_free
parameter_list|(
name|table
parameter_list|)
name|struct
name|bfd_hash_table
modifier|*
name|table
decl_stmt|;
block|{
name|obstack_free
argument_list|(
operator|&
name|table
operator|->
name|memory
argument_list|,
operator|(
name|PTR
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Look up a string in a hash table.  */
end_comment

begin_function
name|struct
name|bfd_hash_entry
modifier|*
name|bfd_hash_lookup
parameter_list|(
name|table
parameter_list|,
name|string
parameter_list|,
name|create
parameter_list|,
name|copy
parameter_list|)
name|struct
name|bfd_hash_table
modifier|*
name|table
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
name|boolean
name|create
decl_stmt|;
name|boolean
name|copy
decl_stmt|;
block|{
specifier|register
specifier|const
name|unsigned
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|unsigned
name|long
name|hash
decl_stmt|;
specifier|register
name|unsigned
name|int
name|c
decl_stmt|;
name|struct
name|bfd_hash_entry
modifier|*
name|hashp
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
name|unsigned
name|int
name|index
decl_stmt|;
name|hash
operator|=
literal|0
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
name|s
operator|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|string
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|s
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
block|{
name|hash
operator|+=
name|c
operator|+
operator|(
name|c
operator|<<
literal|17
operator|)
expr_stmt|;
name|hash
operator|^=
name|hash
operator|>>
literal|2
expr_stmt|;
operator|++
name|len
expr_stmt|;
block|}
name|hash
operator|+=
name|len
operator|+
operator|(
name|len
operator|<<
literal|17
operator|)
expr_stmt|;
name|hash
operator|^=
name|hash
operator|>>
literal|2
expr_stmt|;
name|index
operator|=
name|hash
operator|%
name|table
operator|->
name|size
expr_stmt|;
for|for
control|(
name|hashp
operator|=
name|table
operator|->
name|table
index|[
name|index
index|]
init|;
name|hashp
operator|!=
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|NULL
condition|;
name|hashp
operator|=
name|hashp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|hashp
operator|->
name|hash
operator|==
name|hash
operator|&&
name|strcmp
argument_list|(
name|hashp
operator|->
name|string
argument_list|,
name|string
argument_list|)
operator|==
literal|0
condition|)
return|return
name|hashp
return|;
block|}
if|if
condition|(
operator|!
name|create
condition|)
return|return
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|NULL
return|;
name|hashp
operator|=
call|(
modifier|*
name|table
operator|->
name|newfunc
call|)
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|NULL
argument_list|,
name|table
argument_list|,
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|hashp
operator|==
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|NULL
return|;
if|if
condition|(
name|copy
condition|)
block|{
name|char
modifier|*
name|new
decl_stmt|;
name|new
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|table
operator|->
name|memory
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|NULL
return|;
block|}
name|strcpy
argument_list|(
name|new
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|string
operator|=
name|new
expr_stmt|;
block|}
name|hashp
operator|->
name|string
operator|=
name|string
expr_stmt|;
name|hashp
operator|->
name|hash
operator|=
name|hash
expr_stmt|;
name|hashp
operator|->
name|next
operator|=
name|table
operator|->
name|table
index|[
name|index
index|]
expr_stmt|;
name|table
operator|->
name|table
index|[
name|index
index|]
operator|=
name|hashp
expr_stmt|;
return|return
name|hashp
return|;
block|}
end_function

begin_comment
comment|/* Base method for creating a new hash table entry.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|struct
name|bfd_hash_entry
modifier|*
name|bfd_hash_newfunc
parameter_list|(
name|entry
parameter_list|,
name|table
parameter_list|,
name|string
parameter_list|)
name|struct
name|bfd_hash_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|bfd_hash_table
modifier|*
name|table
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|{
if|if
condition|(
name|entry
operator|==
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|NULL
condition|)
name|entry
operator|=
operator|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|bfd_hash_allocate
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bfd_hash_entry
argument_list|)
argument_list|)
operator|)
expr_stmt|;
return|return
name|entry
return|;
block|}
end_function

begin_comment
comment|/* Allocate space in a hash table.  */
end_comment

begin_function
name|PTR
name|bfd_hash_allocate
parameter_list|(
name|table
parameter_list|,
name|size
parameter_list|)
name|struct
name|bfd_hash_table
modifier|*
name|table
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
block|{
name|PTR
name|ret
decl_stmt|;
name|ret
operator|=
name|obstack_alloc
argument_list|(
operator|&
name|table
operator|->
name|memory
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
operator|&&
name|size
operator|!=
literal|0
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Traverse a hash table.  */
end_comment

begin_function_decl
name|void
name|bfd_hash_traverse
parameter_list|(
name|table
parameter_list|,
name|func
parameter_list|,
name|info
parameter_list|)
name|struct
name|bfd_hash_table
modifier|*
name|table
decl_stmt|;
function_decl|boolean
parameter_list|(
function_decl|*func
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|PTR
name|info
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|table
operator|->
name|size
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|bfd_hash_entry
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|table
operator|->
name|table
index|[
name|i
index|]
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
call|(
modifier|*
name|func
call|)
argument_list|(
name|p
argument_list|,
name|info
argument_list|)
condition|)
return|return;
block|}
block|}
block|}
end_block

end_unit

