begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ELF executable support for BFD.    Copyright 1991, 1992, 1993, 1994 Free Software Foundation, Inc.     Written by Fred Fish @ Cygnus Support, from information published    in "UNIX System V Release 4, Programmers Guide: ANSI C and    Programming Support Tools".  Sufficient support for gdb.     Rewritten by Mark Eichin @ Cygnus Support, from information    published in "System V Application Binary Interface", chapters 4    and 5, as well as the various "Processor Supplement" documents    derived from it. Added support for assembler and other object file    utilities.  Further work done by Ken Raeburn (Cygnus Support), Michael    Meissner (Open Software Foundation), and Peter Hoogenboom (University    of Utah) to finish and extend this.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* Problems and other issues to resolve.     (1)	BFD expects there to be some fixed number of "sections" in         the object file.  I.E. there is a "section_count" variable in the 	bfd structure which contains the number of sections.  However, ELF 	supports multiple "views" of a file.  In particular, with current 	implementations, executable files typically have two tables, a 	program header table and a section header table, both of which 	partition the executable.  	In ELF-speak, the "linking view" of the file uses the section header 	table to access "sections" within the file, and the "execution view" 	uses the program header table to access "segments" within the file. 	"Segments" typically may contain all the data from one or more 	"sections".  	Note that the section header table is optional in ELF executables, 	but it is this information that is most useful to gdb.  If the 	section header table is missing, then gdb should probably try 	to make do with the program header table.  (FIXME)     (2)  The code in this file is compiled twice, once in 32-bit mode and 	once in 64-bit mode.  More of it should be made size-independent 	and moved into elf.c.     (3)	ELF section symbols are handled rather sloppily now.  This should 	be cleaned up, and ELF section symbols reconciled with BFD section 	symbols.     (4)  We need a published spec for 64-bit ELF.  We've got some stuff here 	that we're using for SPARC V9 64-bit chips, but don't assume that 	it's cast in stone.  */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|/* For strrchr and friends */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"libelf.h"
end_include

begin_comment
comment|/* Renaming structures, typedefs, macros and functions to be size-specific.  */
end_comment

begin_define
define|#
directive|define
name|Elf_External_Ehdr
value|NAME(Elf,External_Ehdr)
end_define

begin_define
define|#
directive|define
name|Elf_External_Sym
value|NAME(Elf,External_Sym)
end_define

begin_define
define|#
directive|define
name|Elf_External_Shdr
value|NAME(Elf,External_Shdr)
end_define

begin_define
define|#
directive|define
name|Elf_External_Phdr
value|NAME(Elf,External_Phdr)
end_define

begin_define
define|#
directive|define
name|Elf_External_Rel
value|NAME(Elf,External_Rel)
end_define

begin_define
define|#
directive|define
name|Elf_External_Rela
value|NAME(Elf,External_Rela)
end_define

begin_define
define|#
directive|define
name|Elf_External_Dyn
value|NAME(Elf,External_Dyn)
end_define

begin_define
define|#
directive|define
name|elf_core_file_failing_command
value|NAME(bfd_elf,core_file_failing_command)
end_define

begin_define
define|#
directive|define
name|elf_core_file_failing_signal
value|NAME(bfd_elf,core_file_failing_signal)
end_define

begin_define
define|#
directive|define
name|elf_core_file_matches_executable_p
define|\
value|NAME(bfd_elf,core_file_matches_executable_p)
end_define

begin_define
define|#
directive|define
name|elf_object_p
value|NAME(bfd_elf,object_p)
end_define

begin_define
define|#
directive|define
name|elf_core_file_p
value|NAME(bfd_elf,core_file_p)
end_define

begin_define
define|#
directive|define
name|elf_get_symtab_upper_bound
value|NAME(bfd_elf,get_symtab_upper_bound)
end_define

begin_define
define|#
directive|define
name|elf_get_dynamic_symtab_upper_bound
define|\
value|NAME(bfd_elf,get_dynamic_symtab_upper_bound)
end_define

begin_define
define|#
directive|define
name|elf_swap_reloc_in
value|NAME(bfd_elf,swap_reloc_in)
end_define

begin_define
define|#
directive|define
name|elf_swap_reloca_in
value|NAME(bfd_elf,swap_reloca_in)
end_define

begin_define
define|#
directive|define
name|elf_swap_reloc_out
value|NAME(bfd_elf,swap_reloc_out)
end_define

begin_define
define|#
directive|define
name|elf_swap_reloca_out
value|NAME(bfd_elf,swap_reloca_out)
end_define

begin_define
define|#
directive|define
name|elf_swap_symbol_in
value|NAME(bfd_elf,swap_symbol_in)
end_define

begin_define
define|#
directive|define
name|elf_swap_symbol_out
value|NAME(bfd_elf,swap_symbol_out)
end_define

begin_define
define|#
directive|define
name|elf_swap_dyn_in
value|NAME(bfd_elf,swap_dyn_in)
end_define

begin_define
define|#
directive|define
name|elf_swap_dyn_out
value|NAME(bfd_elf,swap_dyn_out)
end_define

begin_define
define|#
directive|define
name|elf_get_reloc_upper_bound
value|NAME(bfd_elf,get_reloc_upper_bound)
end_define

begin_define
define|#
directive|define
name|elf_canonicalize_reloc
value|NAME(bfd_elf,canonicalize_reloc)
end_define

begin_define
define|#
directive|define
name|elf_get_symtab
value|NAME(bfd_elf,get_symtab)
end_define

begin_define
define|#
directive|define
name|elf_canonicalize_dynamic_symtab
define|\
value|NAME(bfd_elf,canonicalize_dynamic_symtab)
end_define

begin_define
define|#
directive|define
name|elf_make_empty_symbol
value|NAME(bfd_elf,make_empty_symbol)
end_define

begin_define
define|#
directive|define
name|elf_get_symbol_info
value|NAME(bfd_elf,get_symbol_info)
end_define

begin_define
define|#
directive|define
name|elf_print_symbol
value|NAME(bfd_elf,print_symbol)
end_define

begin_define
define|#
directive|define
name|elf_get_lineno
value|NAME(bfd_elf,get_lineno)
end_define

begin_define
define|#
directive|define
name|elf_set_arch_mach
value|NAME(bfd_elf,set_arch_mach)
end_define

begin_define
define|#
directive|define
name|elf_find_nearest_line
value|NAME(bfd_elf,find_nearest_line)
end_define

begin_define
define|#
directive|define
name|elf_sizeof_headers
value|NAME(bfd_elf,sizeof_headers)
end_define

begin_define
define|#
directive|define
name|elf_set_section_contents
value|NAME(bfd_elf,set_section_contents)
end_define

begin_define
define|#
directive|define
name|elf_no_info_to_howto
value|NAME(bfd_elf,no_info_to_howto)
end_define

begin_define
define|#
directive|define
name|elf_no_info_to_howto_rel
value|NAME(bfd_elf,no_info_to_howto_rel)
end_define

begin_define
define|#
directive|define
name|elf_new_section_hook
value|NAME(bfd_elf,new_section_hook)
end_define

begin_define
define|#
directive|define
name|write_relocs
value|NAME(bfd_elf,_write_relocs)
end_define

begin_define
define|#
directive|define
name|elf_find_section
value|NAME(bfd_elf,find_section)
end_define

begin_define
define|#
directive|define
name|elf_bfd_link_add_symbols
value|NAME(bfd_elf,bfd_link_add_symbols)
end_define

begin_define
define|#
directive|define
name|elf_add_dynamic_entry
value|NAME(bfd_elf,add_dynamic_entry)
end_define

begin_define
define|#
directive|define
name|elf_bfd_final_link
value|NAME(bfd_elf,bfd_final_link)
end_define

begin_if
if|#
directive|if
name|ARCH_SIZE
operator|==
literal|64
end_if

begin_define
define|#
directive|define
name|ELF_R_INFO
parameter_list|(
name|X
parameter_list|,
name|Y
parameter_list|)
value|ELF64_R_INFO(X,Y)
end_define

begin_define
define|#
directive|define
name|ELF_R_SYM
parameter_list|(
name|X
parameter_list|)
value|ELF64_R_SYM(X)
end_define

begin_define
define|#
directive|define
name|ELF_R_TYPE
parameter_list|(
name|X
parameter_list|)
value|ELF64_R_TYPE(X)
end_define

begin_define
define|#
directive|define
name|ELFCLASS
value|ELFCLASS64
end_define

begin_define
define|#
directive|define
name|FILE_ALIGN
value|8
end_define

begin_define
define|#
directive|define
name|LOG_FILE_ALIGN
value|3
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|ARCH_SIZE
operator|==
literal|32
end_if

begin_define
define|#
directive|define
name|ELF_R_INFO
parameter_list|(
name|X
parameter_list|,
name|Y
parameter_list|)
value|ELF32_R_INFO(X,Y)
end_define

begin_define
define|#
directive|define
name|ELF_R_SYM
parameter_list|(
name|X
parameter_list|)
value|ELF32_R_SYM(X)
end_define

begin_define
define|#
directive|define
name|ELF_R_TYPE
parameter_list|(
name|X
parameter_list|)
value|ELF32_R_TYPE(X)
end_define

begin_define
define|#
directive|define
name|ELFCLASS
value|ELFCLASS32
end_define

begin_define
define|#
directive|define
name|FILE_ALIGN
value|4
end_define

begin_define
define|#
directive|define
name|LOG_FILE_ALIGN
value|2
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Forward declarations of static functions */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|bfd_add_to_strtab
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|strtab
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asection
modifier|*
name|section_from_elf_index
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|elf_section_from_bfd_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|sec
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|elf_slurp_symbol_table
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asymbol
operator|*
operator|*
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf_slurp_reloc_table
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|asymbol
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|elf_symbol_from_bfd_symbol
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|symbol_cache_entry
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf_compute_section_file_positions
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|prep_headers
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|elf_fake_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|assign_section_numbers
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|file_ptr
name|align_file_position
name|PARAMS
argument_list|(
operator|(
name|file_ptr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|file_ptr
name|assign_file_position_for_section
name|PARAMS
argument_list|(
operator|(
name|Elf_Internal_Shdr
operator|*
operator|,
name|file_ptr
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|assign_file_positions_except_relocs
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|assign_file_positions_for_relocs
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_size_type
name|get_program_header_size
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|file_ptr
name|map_program_segments
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|file_ptr
operator|,
name|Elf_Internal_Shdr
operator|*
operator|,
name|bfd_size_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf_map_symbols
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|swap_out_syms
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|bfd_section_from_shdr
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|unsigned
name|int
name|shindex
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|elf_debug_section
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|Elf_Internal_Shdr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|elf_debug_file
name|PARAMS
argument_list|(
operator|(
name|Elf_Internal_Ehdr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|elf_string_from_elf_strtab
parameter_list|(
name|abfd
parameter_list|,
name|strindex
parameter_list|)
define|\
value|elf_string_from_elf_section(abfd,elf_elfheader(abfd)->e_shstrndx,strindex)
end_define

begin_escape
end_escape

begin_comment
comment|/* Structure swapping routines */
end_comment

begin_comment
comment|/* Should perhaps use put_offset, put_word, etc.  For now, the two versions    can be handled by explicitly specifying 32 bits or "the long type".  */
end_comment

begin_if
if|#
directive|if
name|ARCH_SIZE
operator|==
literal|64
end_if

begin_define
define|#
directive|define
name|put_word
value|bfd_h_put_64
end_define

begin_define
define|#
directive|define
name|get_word
value|bfd_h_get_64
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|ARCH_SIZE
operator|==
literal|32
end_if

begin_define
define|#
directive|define
name|put_word
value|bfd_h_put_32
end_define

begin_define
define|#
directive|define
name|get_word
value|bfd_h_get_32
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Translate an ELF symbol in external format into an ELF symbol in internal    format. */
end_comment

begin_function
name|void
name|elf_swap_symbol_in
parameter_list|(
name|abfd
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|Elf_External_Sym
modifier|*
name|src
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|dst
decl_stmt|;
block|{
name|dst
operator|->
name|st_name
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|st_name
argument_list|)
expr_stmt|;
name|dst
operator|->
name|st_value
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|st_value
argument_list|)
expr_stmt|;
name|dst
operator|->
name|st_size
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|st_size
argument_list|)
expr_stmt|;
name|dst
operator|->
name|st_info
operator|=
name|bfd_h_get_8
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|st_info
argument_list|)
expr_stmt|;
name|dst
operator|->
name|st_other
operator|=
name|bfd_h_get_8
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|st_other
argument_list|)
expr_stmt|;
name|dst
operator|->
name|st_shndx
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|st_shndx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Translate an ELF symbol in internal format into an ELF symbol in external    format. */
end_comment

begin_function
name|void
name|elf_swap_symbol_out
parameter_list|(
name|abfd
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|src
decl_stmt|;
name|Elf_External_Sym
modifier|*
name|dst
decl_stmt|;
block|{
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|st_name
argument_list|,
name|dst
operator|->
name|st_name
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|st_value
argument_list|,
name|dst
operator|->
name|st_value
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|st_size
argument_list|,
name|dst
operator|->
name|st_size
argument_list|)
expr_stmt|;
name|bfd_h_put_8
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|st_info
argument_list|,
name|dst
operator|->
name|st_info
argument_list|)
expr_stmt|;
name|bfd_h_put_8
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|st_other
argument_list|,
name|dst
operator|->
name|st_other
argument_list|)
expr_stmt|;
name|bfd_h_put_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|st_shndx
argument_list|,
name|dst
operator|->
name|st_shndx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Translate an ELF file header in external format into an ELF file header in    internal format. */
end_comment

begin_function
specifier|static
name|void
name|elf_swap_ehdr_in
parameter_list|(
name|abfd
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|Elf_External_Ehdr
modifier|*
name|src
decl_stmt|;
name|Elf_Internal_Ehdr
modifier|*
name|dst
decl_stmt|;
block|{
name|memcpy
argument_list|(
name|dst
operator|->
name|e_ident
argument_list|,
name|src
operator|->
name|e_ident
argument_list|,
name|EI_NIDENT
argument_list|)
expr_stmt|;
name|dst
operator|->
name|e_type
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|e_type
argument_list|)
expr_stmt|;
name|dst
operator|->
name|e_machine
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|e_machine
argument_list|)
expr_stmt|;
name|dst
operator|->
name|e_version
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|e_version
argument_list|)
expr_stmt|;
name|dst
operator|->
name|e_entry
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|e_entry
argument_list|)
expr_stmt|;
name|dst
operator|->
name|e_phoff
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|e_phoff
argument_list|)
expr_stmt|;
name|dst
operator|->
name|e_shoff
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|e_shoff
argument_list|)
expr_stmt|;
name|dst
operator|->
name|e_flags
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|e_flags
argument_list|)
expr_stmt|;
name|dst
operator|->
name|e_ehsize
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|e_ehsize
argument_list|)
expr_stmt|;
name|dst
operator|->
name|e_phentsize
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|e_phentsize
argument_list|)
expr_stmt|;
name|dst
operator|->
name|e_phnum
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|e_phnum
argument_list|)
expr_stmt|;
name|dst
operator|->
name|e_shentsize
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|e_shentsize
argument_list|)
expr_stmt|;
name|dst
operator|->
name|e_shnum
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|e_shnum
argument_list|)
expr_stmt|;
name|dst
operator|->
name|e_shstrndx
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|e_shstrndx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Translate an ELF file header in internal format into an ELF file header in    external format. */
end_comment

begin_function
specifier|static
name|void
name|elf_swap_ehdr_out
parameter_list|(
name|abfd
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|Elf_Internal_Ehdr
modifier|*
name|src
decl_stmt|;
name|Elf_External_Ehdr
modifier|*
name|dst
decl_stmt|;
block|{
name|memcpy
argument_list|(
name|dst
operator|->
name|e_ident
argument_list|,
name|src
operator|->
name|e_ident
argument_list|,
name|EI_NIDENT
argument_list|)
expr_stmt|;
comment|/* note that all elements of dst are *arrays of unsigned char* already... */
name|bfd_h_put_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|e_type
argument_list|,
name|dst
operator|->
name|e_type
argument_list|)
expr_stmt|;
name|bfd_h_put_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|e_machine
argument_list|,
name|dst
operator|->
name|e_machine
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|e_version
argument_list|,
name|dst
operator|->
name|e_version
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|e_entry
argument_list|,
name|dst
operator|->
name|e_entry
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|e_phoff
argument_list|,
name|dst
operator|->
name|e_phoff
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|e_shoff
argument_list|,
name|dst
operator|->
name|e_shoff
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|e_flags
argument_list|,
name|dst
operator|->
name|e_flags
argument_list|)
expr_stmt|;
name|bfd_h_put_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|e_ehsize
argument_list|,
name|dst
operator|->
name|e_ehsize
argument_list|)
expr_stmt|;
name|bfd_h_put_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|e_phentsize
argument_list|,
name|dst
operator|->
name|e_phentsize
argument_list|)
expr_stmt|;
name|bfd_h_put_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|e_phnum
argument_list|,
name|dst
operator|->
name|e_phnum
argument_list|)
expr_stmt|;
name|bfd_h_put_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|e_shentsize
argument_list|,
name|dst
operator|->
name|e_shentsize
argument_list|)
expr_stmt|;
name|bfd_h_put_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|e_shnum
argument_list|,
name|dst
operator|->
name|e_shnum
argument_list|)
expr_stmt|;
name|bfd_h_put_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|e_shstrndx
argument_list|,
name|dst
operator|->
name|e_shstrndx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Translate an ELF section header table entry in external format into an    ELF section header table entry in internal format. */
end_comment

begin_function
specifier|static
name|void
name|elf_swap_shdr_in
parameter_list|(
name|abfd
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|Elf_External_Shdr
modifier|*
name|src
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|dst
decl_stmt|;
block|{
name|dst
operator|->
name|sh_name
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|sh_name
argument_list|)
expr_stmt|;
name|dst
operator|->
name|sh_type
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|sh_type
argument_list|)
expr_stmt|;
name|dst
operator|->
name|sh_flags
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|sh_flags
argument_list|)
expr_stmt|;
name|dst
operator|->
name|sh_addr
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|sh_addr
argument_list|)
expr_stmt|;
name|dst
operator|->
name|sh_offset
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|sh_offset
argument_list|)
expr_stmt|;
name|dst
operator|->
name|sh_size
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|sh_size
argument_list|)
expr_stmt|;
name|dst
operator|->
name|sh_link
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|sh_link
argument_list|)
expr_stmt|;
name|dst
operator|->
name|sh_info
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|sh_info
argument_list|)
expr_stmt|;
name|dst
operator|->
name|sh_addralign
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|sh_addralign
argument_list|)
expr_stmt|;
name|dst
operator|->
name|sh_entsize
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|sh_entsize
argument_list|)
expr_stmt|;
comment|/* we haven't done any processing on it yet, so... */
name|dst
operator|->
name|rawdata
operator|=
operator|(
name|void
operator|*
operator|)
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Translate an ELF section header table entry in internal format into an    ELF section header table entry in external format. */
end_comment

begin_function
specifier|static
name|void
name|elf_swap_shdr_out
parameter_list|(
name|abfd
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|src
decl_stmt|;
name|Elf_External_Shdr
modifier|*
name|dst
decl_stmt|;
block|{
comment|/* note that all elements of dst are *arrays of unsigned char* already... */
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|sh_name
argument_list|,
name|dst
operator|->
name|sh_name
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|sh_type
argument_list|,
name|dst
operator|->
name|sh_type
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|sh_flags
argument_list|,
name|dst
operator|->
name|sh_flags
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|sh_addr
argument_list|,
name|dst
operator|->
name|sh_addr
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|sh_offset
argument_list|,
name|dst
operator|->
name|sh_offset
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|sh_size
argument_list|,
name|dst
operator|->
name|sh_size
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|sh_link
argument_list|,
name|dst
operator|->
name|sh_link
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|sh_info
argument_list|,
name|dst
operator|->
name|sh_info
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|sh_addralign
argument_list|,
name|dst
operator|->
name|sh_addralign
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|sh_entsize
argument_list|,
name|dst
operator|->
name|sh_entsize
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Translate an ELF program header table entry in external format into an    ELF program header table entry in internal format. */
end_comment

begin_function
specifier|static
name|void
name|elf_swap_phdr_in
parameter_list|(
name|abfd
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|Elf_External_Phdr
modifier|*
name|src
decl_stmt|;
name|Elf_Internal_Phdr
modifier|*
name|dst
decl_stmt|;
block|{
name|dst
operator|->
name|p_type
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|p_type
argument_list|)
expr_stmt|;
name|dst
operator|->
name|p_flags
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|p_flags
argument_list|)
expr_stmt|;
name|dst
operator|->
name|p_offset
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|p_offset
argument_list|)
expr_stmt|;
name|dst
operator|->
name|p_vaddr
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|p_vaddr
argument_list|)
expr_stmt|;
name|dst
operator|->
name|p_paddr
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|p_paddr
argument_list|)
expr_stmt|;
name|dst
operator|->
name|p_filesz
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|p_filesz
argument_list|)
expr_stmt|;
name|dst
operator|->
name|p_memsz
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|p_memsz
argument_list|)
expr_stmt|;
name|dst
operator|->
name|p_align
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|p_align
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|elf_swap_phdr_out
parameter_list|(
name|abfd
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|Elf_Internal_Phdr
modifier|*
name|src
decl_stmt|;
name|Elf_External_Phdr
modifier|*
name|dst
decl_stmt|;
block|{
comment|/* note that all elements of dst are *arrays of unsigned char* already... */
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|p_type
argument_list|,
name|dst
operator|->
name|p_type
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|p_offset
argument_list|,
name|dst
operator|->
name|p_offset
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|p_vaddr
argument_list|,
name|dst
operator|->
name|p_vaddr
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|p_paddr
argument_list|,
name|dst
operator|->
name|p_paddr
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|p_filesz
argument_list|,
name|dst
operator|->
name|p_filesz
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|p_memsz
argument_list|,
name|dst
operator|->
name|p_memsz
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|p_flags
argument_list|,
name|dst
operator|->
name|p_flags
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|p_align
argument_list|,
name|dst
operator|->
name|p_align
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Translate an ELF reloc from external format to internal format. */
end_comment

begin_function
name|INLINE
name|void
name|elf_swap_reloc_in
parameter_list|(
name|abfd
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|Elf_External_Rel
modifier|*
name|src
decl_stmt|;
name|Elf_Internal_Rel
modifier|*
name|dst
decl_stmt|;
block|{
name|dst
operator|->
name|r_offset
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|dst
operator|->
name|r_info
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|r_info
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|INLINE
name|void
name|elf_swap_reloca_in
parameter_list|(
name|abfd
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|Elf_External_Rela
modifier|*
name|src
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|dst
decl_stmt|;
block|{
name|dst
operator|->
name|r_offset
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|dst
operator|->
name|r_info
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|dst
operator|->
name|r_addend
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|->
name|r_addend
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Translate an ELF reloc from internal format to external format. */
end_comment

begin_function
name|INLINE
name|void
name|elf_swap_reloc_out
parameter_list|(
name|abfd
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|Elf_Internal_Rel
modifier|*
name|src
decl_stmt|;
name|Elf_External_Rel
modifier|*
name|dst
decl_stmt|;
block|{
name|put_word
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|r_offset
argument_list|,
name|dst
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|r_info
argument_list|,
name|dst
operator|->
name|r_info
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|INLINE
name|void
name|elf_swap_reloca_out
parameter_list|(
name|abfd
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|src
decl_stmt|;
name|Elf_External_Rela
modifier|*
name|dst
decl_stmt|;
block|{
name|put_word
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|r_offset
argument_list|,
name|dst
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|r_info
argument_list|,
name|dst
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|r_addend
argument_list|,
name|dst
operator|->
name|r_addend
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|INLINE
name|void
name|elf_swap_dyn_in
parameter_list|(
name|abfd
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|Elf_External_Dyn
modifier|*
name|src
decl_stmt|;
name|Elf_Internal_Dyn
modifier|*
name|dst
decl_stmt|;
block|{
name|dst
operator|->
name|d_tag
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|d_tag
argument_list|)
expr_stmt|;
name|dst
operator|->
name|d_un
operator|.
name|d_val
operator|=
name|get_word
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|d_un
operator|.
name|d_val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|INLINE
name|void
name|elf_swap_dyn_out
parameter_list|(
name|abfd
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|Elf_Internal_Dyn
modifier|*
name|src
decl_stmt|;
name|Elf_External_Dyn
modifier|*
name|dst
decl_stmt|;
block|{
name|put_word
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|d_tag
argument_list|,
name|dst
operator|->
name|d_tag
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|d_un
operator|.
name|d_val
argument_list|,
name|dst
operator|->
name|d_un
operator|.
name|d_val
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* String table creation/manipulation routines */
end_comment

begin_function
specifier|static
name|struct
name|strtab
modifier|*
name|bfd_new_strtab
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|struct
name|strtab
modifier|*
name|ss
decl_stmt|;
name|ss
operator|=
operator|(
expr|struct
name|strtab
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|strtab
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ss
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ss
operator|->
name|tab
operator|=
name|malloc
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ss
operator|->
name|tab
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|*
name|ss
operator|->
name|tab
operator|=
literal|0
expr_stmt|;
name|ss
operator|->
name|nentries
operator|=
literal|0
expr_stmt|;
name|ss
operator|->
name|length
operator|=
literal|1
expr_stmt|;
return|return
name|ss
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|long
name|bfd_add_to_strtab
parameter_list|(
name|abfd
parameter_list|,
name|ss
parameter_list|,
name|str
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|strtab
modifier|*
name|ss
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
block|{
comment|/* should search first, but for now: */
comment|/* include the trailing NUL */
name|int
name|ln
init|=
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
decl_stmt|;
comment|/* FIXME: This is slow.  Also, we could combine this with the a.out      string table building and use a hash table, although it might not      be worth it since ELF symbols don't include debugging information      and thus have much less overlap.  */
name|ss
operator|->
name|tab
operator|=
name|realloc
argument_list|(
name|ss
operator|->
name|tab
argument_list|,
name|ss
operator|->
name|length
operator|+
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
name|ss
operator|->
name|tab
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
operator|(
name|unsigned
name|long
operator|)
operator|-
literal|1
return|;
block|}
name|strcpy
argument_list|(
name|ss
operator|->
name|tab
operator|+
name|ss
operator|->
name|length
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|ss
operator|->
name|nentries
operator|++
expr_stmt|;
name|ss
operator|->
name|length
operator|+=
name|ln
expr_stmt|;
return|return
name|ss
operator|->
name|length
operator|-
name|ln
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bfd_add_2_to_strtab
parameter_list|(
name|abfd
parameter_list|,
name|ss
parameter_list|,
name|str
parameter_list|,
name|str2
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|strtab
modifier|*
name|ss
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|CONST
name|char
modifier|*
name|str2
decl_stmt|;
block|{
comment|/* should search first, but for now: */
comment|/* include the trailing NUL */
name|int
name|ln
init|=
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
name|strlen
argument_list|(
name|str2
argument_list|)
operator|+
literal|1
decl_stmt|;
comment|/* should this be using obstacks? */
if|if
condition|(
name|ss
operator|->
name|length
condition|)
name|ss
operator|->
name|tab
operator|=
name|realloc
argument_list|(
name|ss
operator|->
name|tab
argument_list|,
name|ss
operator|->
name|length
operator|+
name|ln
argument_list|)
expr_stmt|;
else|else
name|ss
operator|->
name|tab
operator|=
name|malloc
argument_list|(
name|ln
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|ss
operator|->
name|tab
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* FIXME */
name|strcpy
argument_list|(
name|ss
operator|->
name|tab
operator|+
name|ss
operator|->
name|length
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ss
operator|->
name|tab
operator|+
name|ss
operator|->
name|length
operator|+
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|,
name|str2
argument_list|)
expr_stmt|;
name|ss
operator|->
name|nentries
operator|++
expr_stmt|;
name|ss
operator|->
name|length
operator|+=
name|ln
expr_stmt|;
return|return
name|ss
operator|->
name|length
operator|-
name|ln
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ELF .o/exec file reading */
end_comment

begin_comment
comment|/* Create a new bfd section from an ELF section header. */
end_comment

begin_function
specifier|static
name|boolean
name|bfd_section_from_shdr
parameter_list|(
name|abfd
parameter_list|,
name|shindex
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|unsigned
name|int
name|shindex
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
name|hdr
init|=
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
index|[
name|shindex
index|]
decl_stmt|;
name|Elf_Internal_Ehdr
modifier|*
name|ehdr
init|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|elf_string_from_elf_strtab
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|sh_name
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hdr
operator|->
name|sh_type
condition|)
block|{
case|case
name|SHT_NULL
case|:
comment|/* Inactive section. Throw it away.  */
return|return
name|true
return|;
case|case
name|SHT_PROGBITS
case|:
comment|/* Normal section with contents.  */
case|case
name|SHT_DYNAMIC
case|:
comment|/* Dynamic linking information.  */
case|case
name|SHT_NOBITS
case|:
comment|/* .bss section.  */
case|case
name|SHT_HASH
case|:
comment|/* .hash section.  */
return|return
name|_bfd_elf_make_section_from_shdr
argument_list|(
name|abfd
argument_list|,
name|hdr
argument_list|,
name|name
argument_list|)
return|;
case|case
name|SHT_SYMTAB
case|:
comment|/* A symbol table */
if|if
condition|(
name|elf_onesymtab
argument_list|(
name|abfd
argument_list|)
operator|==
name|shindex
condition|)
return|return
name|true
return|;
name|BFD_ASSERT
argument_list|(
name|hdr
operator|->
name|sh_entsize
operator|==
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|elf_onesymtab
argument_list|(
name|abfd
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|elf_onesymtab
argument_list|(
name|abfd
argument_list|)
operator|=
name|shindex
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
operator|=
operator|*
name|hdr
expr_stmt|;
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
index|[
name|shindex
index|]
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|abfd
operator|->
name|flags
operator||=
name|HAS_SYMS
expr_stmt|;
return|return
name|true
return|;
case|case
name|SHT_DYNSYM
case|:
comment|/* A dynamic symbol table */
if|if
condition|(
name|elf_dynsymtab
argument_list|(
name|abfd
argument_list|)
operator|==
name|shindex
condition|)
return|return
name|true
return|;
name|BFD_ASSERT
argument_list|(
name|hdr
operator|->
name|sh_entsize
operator|==
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|elf_dynsymtab
argument_list|(
name|abfd
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|elf_dynsymtab
argument_list|(
name|abfd
argument_list|)
operator|=
name|shindex
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|dynsymtab_hdr
operator|=
operator|*
name|hdr
expr_stmt|;
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
index|[
name|shindex
index|]
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|dynsymtab_hdr
expr_stmt|;
name|abfd
operator|->
name|flags
operator||=
name|HAS_SYMS
expr_stmt|;
comment|/* Besides being a symbol table, we also treat this as a regular 	 section, so that objcopy can handle it.  */
return|return
name|_bfd_elf_make_section_from_shdr
argument_list|(
name|abfd
argument_list|,
name|hdr
argument_list|,
name|name
argument_list|)
return|;
case|case
name|SHT_STRTAB
case|:
comment|/* A string table */
if|if
condition|(
name|hdr
operator|->
name|rawdata
operator|!=
name|NULL
condition|)
return|return
name|true
return|;
if|if
condition|(
name|ehdr
operator|->
name|e_shstrndx
operator|==
name|shindex
condition|)
block|{
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|shstrtab_hdr
operator|=
operator|*
name|hdr
expr_stmt|;
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
index|[
name|shindex
index|]
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|shstrtab_hdr
expr_stmt|;
name|hdr
operator|->
name|rawdata
operator|=
operator|(
name|PTR
operator|)
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|shstrtab_hdr
expr_stmt|;
return|return
name|true
return|;
block|}
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|ehdr
operator|->
name|e_shnum
condition|;
name|i
operator|++
control|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|hdr2
init|=
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|hdr2
operator|->
name|sh_link
operator|==
name|shindex
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_section_from_shdr
argument_list|(
name|abfd
argument_list|,
name|i
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|elf_onesymtab
argument_list|(
name|abfd
argument_list|)
operator|==
name|i
condition|)
block|{
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|strtab_hdr
operator|=
operator|*
name|hdr
expr_stmt|;
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
index|[
name|shindex
index|]
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|strtab_hdr
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|elf_dynsymtab
argument_list|(
name|abfd
argument_list|)
operator|==
name|i
condition|)
block|{
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|dynstrtab_hdr
operator|=
operator|*
name|hdr
expr_stmt|;
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
index|[
name|shindex
index|]
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|dynstrtab_hdr
expr_stmt|;
comment|/* We also treat this as a regular section, so 		       that objcopy can handle it.  */
break|break;
block|}
if|#
directive|if
literal|0
comment|/* Not handling other string tables specially right now.  */
block|hdr2 = elf_elfsections (abfd)[i];
comment|/* in case it moved */
comment|/* We have a strtab for some random other section.  */
block|newsect = (asection *) hdr2->rawdata; 		if (!newsect) 		  break; 		hdr->rawdata = (PTR) newsect; 		hdr2 =&elf_section_data (newsect)->str_hdr; 		*hdr2 = *hdr; 		elf_elfsections (abfd)[shindex] = hdr2;
endif|#
directive|endif
block|}
block|}
block|}
return|return
name|_bfd_elf_make_section_from_shdr
argument_list|(
name|abfd
argument_list|,
name|hdr
argument_list|,
name|name
argument_list|)
return|;
case|case
name|SHT_REL
case|:
case|case
name|SHT_RELA
case|:
comment|/* *These* do a lot of work -- but build no sections!  */
block|{
name|asection
modifier|*
name|target_sect
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|hdr2
decl_stmt|;
name|int
name|use_rela_p
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|use_rela_p
decl_stmt|;
comment|/* Get the symbol table.  */
if|if
condition|(
operator|!
name|bfd_section_from_shdr
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|sh_link
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* If this reloc section does not use the main symbol table we 	   don't treat it as a reloc section.  BFD can't adequately 	   represent such a section, so at least for now, we don't 	   try.  We just present it as a normal section.  */
if|if
condition|(
name|hdr
operator|->
name|sh_link
operator|!=
name|elf_onesymtab
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|_bfd_elf_make_section_from_shdr
argument_list|(
name|abfd
argument_list|,
name|hdr
argument_list|,
name|name
argument_list|)
return|;
comment|/* Don't allow REL relocations on a machine that uses RELA and 	   vice versa.  */
comment|/* @@ Actually, the generic ABI does suggest that both might be 	   used in one file.  But the four ABI Processor Supplements I 	   have access to right now all specify that only one is used on 	   each of those architectures.  It's conceivable that, e.g., a 	   bunch of absolute 32-bit relocs might be more compact in REL 	   form even on a RELA machine...  */
name|BFD_ASSERT
argument_list|(
name|use_rela_p
condition|?
operator|(
name|hdr
operator|->
name|sh_type
operator|==
name|SHT_RELA
operator|&&
name|hdr
operator|->
name|sh_entsize
operator|==
sizeof|sizeof
argument_list|(
name|Elf_External_Rela
argument_list|)
operator|)
else|:
operator|(
name|hdr
operator|->
name|sh_type
operator|==
name|SHT_REL
operator|&&
name|hdr
operator|->
name|sh_entsize
operator|==
sizeof|sizeof
argument_list|(
name|Elf_External_Rel
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_section_from_shdr
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|sh_info
argument_list|)
condition|)
return|return
name|false
return|;
name|target_sect
operator|=
name|section_from_elf_index
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|sh_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_sect
operator|==
name|NULL
operator|||
name|elf_section_data
argument_list|(
name|target_sect
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|hdr2
operator|=
operator|&
name|elf_section_data
argument_list|(
name|target_sect
argument_list|)
operator|->
name|rel_hdr
expr_stmt|;
operator|*
name|hdr2
operator|=
operator|*
name|hdr
expr_stmt|;
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
index|[
name|shindex
index|]
operator|=
name|hdr2
expr_stmt|;
name|target_sect
operator|->
name|reloc_count
operator|=
name|hdr
operator|->
name|sh_size
operator|/
name|hdr
operator|->
name|sh_entsize
expr_stmt|;
name|target_sect
operator|->
name|flags
operator||=
name|SEC_RELOC
expr_stmt|;
name|target_sect
operator|->
name|relocation
operator|=
name|NULL
expr_stmt|;
name|target_sect
operator|->
name|rel_filepos
operator|=
name|hdr
operator|->
name|sh_offset
expr_stmt|;
name|abfd
operator|->
name|flags
operator||=
name|HAS_RELOC
expr_stmt|;
return|return
name|true
return|;
block|}
break|break;
case|case
name|SHT_NOTE
case|:
if|#
directive|if
literal|0
block|fprintf (stderr, "Note Sections not yet supported.\n");       BFD_FAIL ();
endif|#
directive|endif
break|break;
case|case
name|SHT_SHLIB
case|:
if|#
directive|if
literal|0
block|fprintf (stderr, "SHLIB Sections not supported (and non conforming.)\n");
endif|#
directive|endif
return|return
name|true
return|;
default|default:
comment|/* Check for any processor-specific section types.  */
block|{
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
if|if
condition|(
name|bed
operator|->
name|elf_backend_section_from_shdr
condition|)
call|(
modifier|*
name|bed
operator|->
name|elf_backend_section_from_shdr
call|)
argument_list|(
name|abfd
argument_list|,
name|hdr
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
name|boolean
name|elf_new_section_hook
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
block|{
name|struct
name|bfd_elf_section_data
modifier|*
name|sdata
decl_stmt|;
name|sdata
operator|=
operator|(
expr|struct
name|bfd_elf_section_data
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sdata
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sdata
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|sec
operator|->
name|used_by_bfd
operator|=
operator|(
name|PTR
operator|)
name|sdata
expr_stmt|;
name|memset
argument_list|(
name|sdata
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sdata
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Create a new bfd section from an ELF program header.     Since program segments have no names, we generate a synthetic name    of the form segment<NUM>, where NUM is generally the index in the    program header table.  For segments that are split (see below) we    generate the names segment<NUM>a and segment<NUM>b.     Note that some program segments may have a file size that is different than    (less than) the memory size.  All this means is that at execution the    system must allocate the amount of memory specified by the memory size,    but only initialize it with the first "file size" bytes read from the    file.  This would occur for example, with program segments consisting    of combined data+bss.     To handle the above situation, this routine generates TWO bfd sections    for the single program segment.  The first has the length specified by    the file size of the segment, and the second has the length specified    by the difference between the two sizes.  In effect, the segment is split    into it's initialized and uninitialized parts.   */
end_comment

begin_function
specifier|static
name|boolean
name|bfd_section_from_phdr
parameter_list|(
name|abfd
parameter_list|,
name|hdr
parameter_list|,
name|index
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|Elf_Internal_Phdr
modifier|*
name|hdr
decl_stmt|;
name|int
name|index
decl_stmt|;
block|{
name|asection
modifier|*
name|newsect
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|namebuf
index|[
literal|64
index|]
decl_stmt|;
name|int
name|split
decl_stmt|;
name|split
operator|=
operator|(
operator|(
name|hdr
operator|->
name|p_memsz
operator|>
literal|0
operator|)
operator|&&
operator|(
name|hdr
operator|->
name|p_filesz
operator|>
literal|0
operator|)
operator|&&
operator|(
name|hdr
operator|->
name|p_memsz
operator|>
name|hdr
operator|->
name|p_filesz
operator|)
operator|)
expr_stmt|;
name|sprintf
argument_list|(
name|namebuf
argument_list|,
name|split
condition|?
literal|"segment%da"
else|:
literal|"segment%d"
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|name
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|strlen
argument_list|(
name|namebuf
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|strcpy
argument_list|(
name|name
argument_list|,
name|namebuf
argument_list|)
expr_stmt|;
name|newsect
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|newsect
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|newsect
operator|->
name|vma
operator|=
name|hdr
operator|->
name|p_vaddr
expr_stmt|;
name|newsect
operator|->
name|_raw_size
operator|=
name|hdr
operator|->
name|p_filesz
expr_stmt|;
name|newsect
operator|->
name|filepos
operator|=
name|hdr
operator|->
name|p_offset
expr_stmt|;
name|newsect
operator|->
name|flags
operator||=
name|SEC_HAS_CONTENTS
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|p_type
operator|==
name|PT_LOAD
condition|)
block|{
name|newsect
operator|->
name|flags
operator||=
name|SEC_ALLOC
expr_stmt|;
name|newsect
operator|->
name|flags
operator||=
name|SEC_LOAD
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|p_flags
operator|&
name|PF_X
condition|)
block|{
comment|/* FIXME: all we known is that it has execute PERMISSION, 	     may be data. */
name|newsect
operator|->
name|flags
operator||=
name|SEC_CODE
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|hdr
operator|->
name|p_flags
operator|&
name|PF_W
operator|)
condition|)
block|{
name|newsect
operator|->
name|flags
operator||=
name|SEC_READONLY
expr_stmt|;
block|}
if|if
condition|(
name|split
condition|)
block|{
name|sprintf
argument_list|(
name|namebuf
argument_list|,
literal|"segment%db"
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|name
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|strlen
argument_list|(
name|namebuf
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|strcpy
argument_list|(
name|name
argument_list|,
name|namebuf
argument_list|)
expr_stmt|;
name|newsect
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|newsect
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|newsect
operator|->
name|vma
operator|=
name|hdr
operator|->
name|p_vaddr
operator|+
name|hdr
operator|->
name|p_filesz
expr_stmt|;
name|newsect
operator|->
name|_raw_size
operator|=
name|hdr
operator|->
name|p_memsz
operator|-
name|hdr
operator|->
name|p_filesz
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|p_type
operator|==
name|PT_LOAD
condition|)
block|{
name|newsect
operator|->
name|flags
operator||=
name|SEC_ALLOC
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|p_flags
operator|&
name|PF_X
condition|)
name|newsect
operator|->
name|flags
operator||=
name|SEC_CODE
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|hdr
operator|->
name|p_flags
operator|&
name|PF_W
operator|)
condition|)
name|newsect
operator|->
name|flags
operator||=
name|SEC_READONLY
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Begin processing a given object.     First we validate the file by reading in the ELF header and checking    the magic number.  */
end_comment

begin_function
specifier|static
name|INLINE
name|boolean
name|elf_file_p
parameter_list|(
name|x_ehdrp
parameter_list|)
name|Elf_External_Ehdr
modifier|*
name|x_ehdrp
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|x_ehdrp
operator|->
name|e_ident
index|[
name|EI_MAG0
index|]
operator|==
name|ELFMAG0
operator|)
operator|&&
operator|(
name|x_ehdrp
operator|->
name|e_ident
index|[
name|EI_MAG1
index|]
operator|==
name|ELFMAG1
operator|)
operator|&&
operator|(
name|x_ehdrp
operator|->
name|e_ident
index|[
name|EI_MAG2
index|]
operator|==
name|ELFMAG2
operator|)
operator|&&
operator|(
name|x_ehdrp
operator|->
name|e_ident
index|[
name|EI_MAG3
index|]
operator|==
name|ELFMAG3
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Check to see if the file associated with ABFD matches the target vector    that ABFD points to.     Note that we may be called several times with the same ABFD, but different    target vectors, most of which will not match.  We have to avoid leaving    any side effects in ABFD, or any data it points to (like tdata), if the    file does not match the target vector.  */
end_comment

begin_function
specifier|const
name|bfd_target
modifier|*
name|elf_object_p
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|Elf_External_Ehdr
name|x_ehdr
decl_stmt|;
comment|/* Elf file header, external form */
name|Elf_Internal_Ehdr
modifier|*
name|i_ehdrp
decl_stmt|;
comment|/* Elf file header, internal form */
name|Elf_External_Shdr
name|x_shdr
decl_stmt|;
comment|/* Section header table entry, external form */
name|Elf_Internal_Shdr
modifier|*
name|i_shdrp
init|=
name|NULL
decl_stmt|;
comment|/* Section header table, internal form */
name|unsigned
name|int
name|shindex
decl_stmt|;
name|char
modifier|*
name|shstrtab
decl_stmt|;
comment|/* Internal copy of section header stringtab */
name|struct
name|elf_backend_data
modifier|*
name|ebd
decl_stmt|;
name|struct
name|elf_obj_tdata
modifier|*
name|preserved_tdata
init|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|struct
name|elf_obj_tdata
modifier|*
name|new_tdata
init|=
name|NULL
decl_stmt|;
comment|/* Read in the ELF header in external format.  */
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|x_ehdr
argument_list|,
sizeof|sizeof
argument_list|(
name|x_ehdr
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|x_ehdr
argument_list|)
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_system_call
condition|)
goto|goto
name|got_wrong_format_error
goto|;
else|else
goto|goto
name|got_no_match
goto|;
block|}
comment|/* Now check to see if we have a valid ELF file, and one that BFD can      make use of.  The magic number must match, the address size ('class')      and byte-swapping must match our XVEC entry, and it must have a      section header table (FIXME: See comments re sections at top of this      file). */
if|if
condition|(
operator|(
name|elf_file_p
argument_list|(
operator|&
name|x_ehdr
argument_list|)
operator|==
name|false
operator|)
operator|||
operator|(
name|x_ehdr
operator|.
name|e_ident
index|[
name|EI_VERSION
index|]
operator|!=
name|EV_CURRENT
operator|)
operator|||
operator|(
name|x_ehdr
operator|.
name|e_ident
index|[
name|EI_CLASS
index|]
operator|!=
name|ELFCLASS
operator|)
condition|)
goto|goto
name|got_wrong_format_error
goto|;
comment|/* Check that file's byte order matches xvec's */
switch|switch
condition|(
name|x_ehdr
operator|.
name|e_ident
index|[
name|EI_DATA
index|]
condition|)
block|{
case|case
name|ELFDATA2MSB
case|:
comment|/* Big-endian */
if|if
condition|(
operator|!
name|abfd
operator|->
name|xvec
operator|->
name|header_byteorder_big_p
condition|)
goto|goto
name|got_wrong_format_error
goto|;
break|break;
case|case
name|ELFDATA2LSB
case|:
comment|/* Little-endian */
if|if
condition|(
name|abfd
operator|->
name|xvec
operator|->
name|header_byteorder_big_p
condition|)
goto|goto
name|got_wrong_format_error
goto|;
break|break;
case|case
name|ELFDATANONE
case|:
comment|/* No data encoding specified */
default|default:
comment|/* Unknown data encoding specified */
goto|goto
name|got_wrong_format_error
goto|;
block|}
comment|/* Allocate an instance of the elf_obj_tdata structure and hook it up to      the tdata pointer in the bfd.  */
name|new_tdata
operator|=
operator|(
operator|(
expr|struct
name|elf_obj_tdata
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|elf_obj_tdata
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|new_tdata
operator|==
name|NULL
condition|)
goto|goto
name|got_no_memory_error
goto|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|=
name|new_tdata
expr_stmt|;
comment|/* Now that we know the byte order, swap in the rest of the header */
name|i_ehdrp
operator|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|elf_swap_ehdr_in
argument_list|(
name|abfd
argument_list|,
operator|&
name|x_ehdr
argument_list|,
name|i_ehdrp
argument_list|)
expr_stmt|;
if|#
directive|if
name|DEBUG
operator|&
literal|1
name|elf_debug_file
argument_list|(
name|i_ehdrp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If there is no section header table, we're hosed. */
if|if
condition|(
name|i_ehdrp
operator|->
name|e_shoff
operator|==
literal|0
condition|)
goto|goto
name|got_wrong_format_error
goto|;
comment|/* As a simple sanity check, verify that the what BFD thinks is the      size of each section header table entry actually matches the size      recorded in the file. */
if|if
condition|(
name|i_ehdrp
operator|->
name|e_shentsize
operator|!=
sizeof|sizeof
argument_list|(
name|x_shdr
argument_list|)
condition|)
goto|goto
name|got_wrong_format_error
goto|;
name|ebd
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* Check that the ELF e_machine field matches what this particular      BFD format expects.  */
if|if
condition|(
name|ebd
operator|->
name|elf_machine_code
operator|!=
name|i_ehdrp
operator|->
name|e_machine
condition|)
block|{
specifier|const
name|bfd_target
modifier|*
specifier|const
modifier|*
name|target_ptr
decl_stmt|;
if|if
condition|(
name|ebd
operator|->
name|elf_machine_code
operator|!=
name|EM_NONE
condition|)
goto|goto
name|got_wrong_format_error
goto|;
comment|/* This is the generic ELF target.  Let it match any ELF target 	 for which we do not have a specific backend.  */
for|for
control|(
name|target_ptr
operator|=
name|bfd_target_vector
init|;
operator|*
name|target_ptr
operator|!=
name|NULL
condition|;
name|target_ptr
operator|++
control|)
block|{
name|struct
name|elf_backend_data
modifier|*
name|back
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|target_ptr
operator|)
operator|->
name|flavour
operator|!=
name|bfd_target_elf_flavour
condition|)
continue|continue;
name|back
operator|=
operator|(
expr|struct
name|elf_backend_data
operator|*
operator|)
operator|(
operator|*
name|target_ptr
operator|)
operator|->
name|backend_data
expr_stmt|;
if|if
condition|(
name|back
operator|->
name|elf_machine_code
operator|==
name|i_ehdrp
operator|->
name|e_machine
condition|)
block|{
comment|/* target_ptr is an ELF backend which matches this 		 object file, so reject the generic ELF target.  */
goto|goto
name|got_wrong_format_error
goto|;
block|}
block|}
block|}
if|if
condition|(
name|i_ehdrp
operator|->
name|e_type
operator|==
name|ET_EXEC
condition|)
name|abfd
operator|->
name|flags
operator||=
name|EXEC_P
expr_stmt|;
elseif|else
if|if
condition|(
name|i_ehdrp
operator|->
name|e_type
operator|==
name|ET_DYN
condition|)
name|abfd
operator|->
name|flags
operator||=
name|DYNAMIC
expr_stmt|;
if|if
condition|(
name|i_ehdrp
operator|->
name|e_phnum
operator|>
literal|0
condition|)
name|abfd
operator|->
name|flags
operator||=
name|D_PAGED
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|ebd
operator|->
name|arch
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|got_no_match
goto|;
comment|/* Remember the entry point specified in the ELF file header. */
name|bfd_get_start_address
argument_list|(
name|abfd
argument_list|)
operator|=
name|i_ehdrp
operator|->
name|e_entry
expr_stmt|;
comment|/* Allocate space for a copy of the section header table in      internal form, seek to the section header table in the file,      read it in, and convert it to internal form.  */
name|i_shdrp
operator|=
operator|(
operator|(
name|Elf_Internal_Shdr
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|i_shdrp
argument_list|)
operator|*
name|i_ehdrp
operator|->
name|e_shnum
argument_list|)
operator|)
expr_stmt|;
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
operator|=
operator|(
operator|(
name|Elf_Internal_Shdr
operator|*
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|i_shdrp
argument_list|)
operator|*
name|i_ehdrp
operator|->
name|e_shnum
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|i_shdrp
operator|||
operator|!
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
condition|)
goto|goto
name|got_no_memory_error
goto|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|i_ehdrp
operator|->
name|e_shoff
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|got_no_match
goto|;
for|for
control|(
name|shindex
operator|=
literal|0
init|;
name|shindex
operator|<
name|i_ehdrp
operator|->
name|e_shnum
condition|;
name|shindex
operator|++
control|)
block|{
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|x_shdr
argument_list|,
sizeof|sizeof
name|x_shdr
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|x_shdr
argument_list|)
condition|)
goto|goto
name|got_no_match
goto|;
name|elf_swap_shdr_in
argument_list|(
name|abfd
argument_list|,
operator|&
name|x_shdr
argument_list|,
name|i_shdrp
operator|+
name|shindex
argument_list|)
expr_stmt|;
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
index|[
name|shindex
index|]
operator|=
name|i_shdrp
operator|+
name|shindex
expr_stmt|;
block|}
if|if
condition|(
name|i_ehdrp
operator|->
name|e_shstrndx
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_section_from_shdr
argument_list|(
name|abfd
argument_list|,
name|i_ehdrp
operator|->
name|e_shstrndx
argument_list|)
condition|)
goto|goto
name|got_no_match
goto|;
block|}
comment|/* Read in the string table containing the names of the sections.  We      will need the base pointer to this table later. */
comment|/* We read this inline now, so that we don't have to go through      bfd_section_from_shdr with it (since this particular strtab is      used to find all of the ELF section names.) */
name|shstrtab
operator|=
name|elf_get_str_section
argument_list|(
name|abfd
argument_list|,
name|i_ehdrp
operator|->
name|e_shstrndx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|shstrtab
condition|)
goto|goto
name|got_no_match
goto|;
comment|/* Once all of the section headers have been read and converted, we      can start processing them.  Note that the first section header is      a dummy placeholder entry, so we ignore it.  */
for|for
control|(
name|shindex
operator|=
literal|1
init|;
name|shindex
operator|<
name|i_ehdrp
operator|->
name|e_shnum
condition|;
name|shindex
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|bfd_section_from_shdr
argument_list|(
name|abfd
argument_list|,
name|shindex
argument_list|)
condition|)
goto|goto
name|got_no_match
goto|;
block|}
comment|/* Let the backend double check the format and override global      information.  */
if|if
condition|(
name|ebd
operator|->
name|elf_backend_object_p
condition|)
block|{
if|if
condition|(
call|(
modifier|*
name|ebd
operator|->
name|elf_backend_object_p
call|)
argument_list|(
name|abfd
argument_list|)
operator|==
name|false
condition|)
goto|goto
name|got_wrong_format_error
goto|;
block|}
return|return
operator|(
name|abfd
operator|->
name|xvec
operator|)
return|;
name|got_wrong_format_error
label|:
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
goto|goto
name|got_no_match
goto|;
name|got_no_memory_error
label|:
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
goto|goto
name|got_no_match
goto|;
name|got_no_match
label|:
if|if
condition|(
name|new_tdata
operator|!=
name|NULL
operator|&&
name|new_tdata
operator|->
name|elf_sect_ptr
operator|!=
name|NULL
condition|)
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|new_tdata
operator|->
name|elf_sect_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|i_shdrp
operator|!=
name|NULL
condition|)
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|i_shdrp
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_tdata
operator|!=
name|NULL
condition|)
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|new_tdata
argument_list|)
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|=
name|preserved_tdata
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ELF .o/exec file writing */
end_comment

begin_comment
comment|/* Takes a bfd and a symbol, returns a pointer to the elf specific area    of the symbol if there is one.  */
end_comment

begin_function
specifier|static
name|INLINE
name|elf_symbol_type
modifier|*
name|elf_symbol_from
parameter_list|(
name|ignore_abfd
parameter_list|,
name|symbol
parameter_list|)
name|bfd
modifier|*
name|ignore_abfd
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
block|{
if|if
condition|(
name|symbol
operator|->
name|the_bfd
operator|->
name|xvec
operator|->
name|flavour
operator|!=
name|bfd_target_elf_flavour
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|symbol
operator|->
name|the_bfd
operator|->
name|tdata
operator|.
name|elf_obj_data
operator|==
operator|(
expr|struct
name|elf_obj_tdata
operator|*
operator|)
name|NULL
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|elf_symbol_type
operator|*
operator|)
name|symbol
return|;
block|}
end_function

begin_function
name|void
name|write_relocs
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|xxx
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|PTR
name|xxx
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
name|rela_hdr
decl_stmt|;
name|Elf_External_Rela
modifier|*
name|outbound_relocas
decl_stmt|;
name|Elf_External_Rel
modifier|*
name|outbound_relocs
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|int
name|use_rela_p
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|use_rela_p
decl_stmt|;
name|asymbol
modifier|*
name|last_sym
init|=
literal|0
decl_stmt|;
name|int
name|last_sym_idx
init|=
literal|9999999
decl_stmt|;
comment|/* should always be written before use */
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|==
literal|0
condition|)
return|return;
comment|/* The linker backend writes the relocs out itself, and sets the      reloc_count field to zero to inhibit writing them here.  Also,      sometimes the SEC_RELOC flag gets set even when there aren't any      relocs.  */
if|if
condition|(
name|sec
operator|->
name|reloc_count
operator|==
literal|0
condition|)
return|return;
name|rela_hdr
operator|=
operator|&
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|rel_hdr
expr_stmt|;
name|rela_hdr
operator|->
name|sh_size
operator|=
name|rela_hdr
operator|->
name|sh_entsize
operator|*
name|sec
operator|->
name|reloc_count
expr_stmt|;
name|rela_hdr
operator|->
name|contents
operator|=
operator|(
name|void
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|rela_hdr
operator|->
name|sh_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rela_hdr
operator|->
name|contents
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
comment|/* FIXME */
block|}
comment|/* orelocation has the data, reloc_count has the count... */
if|if
condition|(
name|use_rela_p
condition|)
block|{
name|outbound_relocas
operator|=
operator|(
name|Elf_External_Rela
operator|*
operator|)
name|rela_hdr
operator|->
name|contents
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|sec
operator|->
name|reloc_count
condition|;
name|idx
operator|++
control|)
block|{
name|Elf_Internal_Rela
name|dst_rela
decl_stmt|;
name|Elf_External_Rela
modifier|*
name|src_rela
decl_stmt|;
name|arelent
modifier|*
name|ptr
decl_stmt|;
name|asymbol
modifier|*
name|sym
decl_stmt|;
name|int
name|n
decl_stmt|;
name|ptr
operator|=
name|sec
operator|->
name|orelocation
index|[
name|idx
index|]
expr_stmt|;
name|src_rela
operator|=
name|outbound_relocas
operator|+
name|idx
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|abfd
operator|->
name|flags
operator|&
name|EXEC_P
operator|)
condition|)
name|dst_rela
operator|.
name|r_offset
operator|=
name|ptr
operator|->
name|address
operator|-
name|sec
operator|->
name|vma
expr_stmt|;
else|else
name|dst_rela
operator|.
name|r_offset
operator|=
name|ptr
operator|->
name|address
expr_stmt|;
name|sym
operator|=
operator|*
name|ptr
operator|->
name|sym_ptr_ptr
expr_stmt|;
if|if
condition|(
name|sym
operator|==
name|last_sym
condition|)
name|n
operator|=
name|last_sym_idx
expr_stmt|;
else|else
block|{
name|last_sym
operator|=
name|sym
expr_stmt|;
name|last_sym_idx
operator|=
name|n
operator|=
name|elf_symbol_from_bfd_symbol
argument_list|(
name|abfd
argument_list|,
operator|&
name|sym
argument_list|)
expr_stmt|;
block|}
name|dst_rela
operator|.
name|r_info
operator|=
name|ELF_R_INFO
argument_list|(
name|n
argument_list|,
name|ptr
operator|->
name|howto
operator|->
name|type
argument_list|)
expr_stmt|;
name|dst_rela
operator|.
name|r_addend
operator|=
name|ptr
operator|->
name|addend
expr_stmt|;
name|elf_swap_reloca_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|dst_rela
argument_list|,
name|src_rela
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/* REL relocations */
block|{
name|outbound_relocs
operator|=
operator|(
name|Elf_External_Rel
operator|*
operator|)
name|rela_hdr
operator|->
name|contents
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|sec
operator|->
name|reloc_count
condition|;
name|idx
operator|++
control|)
block|{
name|Elf_Internal_Rel
name|dst_rel
decl_stmt|;
name|Elf_External_Rel
modifier|*
name|src_rel
decl_stmt|;
name|arelent
modifier|*
name|ptr
decl_stmt|;
name|int
name|n
decl_stmt|;
name|asymbol
modifier|*
name|sym
decl_stmt|;
name|ptr
operator|=
name|sec
operator|->
name|orelocation
index|[
name|idx
index|]
expr_stmt|;
name|sym
operator|=
operator|*
name|ptr
operator|->
name|sym_ptr_ptr
expr_stmt|;
name|src_rel
operator|=
name|outbound_relocs
operator|+
name|idx
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|abfd
operator|->
name|flags
operator|&
name|EXEC_P
operator|)
condition|)
name|dst_rel
operator|.
name|r_offset
operator|=
name|ptr
operator|->
name|address
operator|-
name|sec
operator|->
name|vma
expr_stmt|;
else|else
name|dst_rel
operator|.
name|r_offset
operator|=
name|ptr
operator|->
name|address
expr_stmt|;
if|if
condition|(
name|sym
operator|==
name|last_sym
condition|)
name|n
operator|=
name|last_sym_idx
expr_stmt|;
else|else
block|{
name|last_sym
operator|=
name|sym
expr_stmt|;
name|last_sym_idx
operator|=
name|n
operator|=
name|elf_symbol_from_bfd_symbol
argument_list|(
name|abfd
argument_list|,
operator|&
name|sym
argument_list|)
expr_stmt|;
block|}
name|dst_rel
operator|.
name|r_info
operator|=
name|ELF_R_INFO
argument_list|(
name|n
argument_list|,
name|ptr
operator|->
name|howto
operator|->
name|type
argument_list|)
expr_stmt|;
name|elf_swap_reloc_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|dst_rel
argument_list|,
name|src_rel
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Set up an ELF internal section header for a section.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|elf_fake_sections
parameter_list|(
name|abfd
parameter_list|,
name|asect
parameter_list|,
name|ignore
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|asect
decl_stmt|;
name|PTR
name|ignore
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
name|this_hdr
decl_stmt|;
name|this_hdr
operator|=
operator|&
name|elf_section_data
argument_list|(
name|asect
argument_list|)
operator|->
name|this_hdr
expr_stmt|;
name|this_hdr
operator|->
name|sh_name
operator|=
name|bfd_add_to_strtab
argument_list|(
name|abfd
argument_list|,
name|elf_shstrtab
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|asect
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_hdr
operator|->
name|sh_name
operator|==
operator|(
name|unsigned
name|long
operator|)
operator|-
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* FIXME */
name|this_hdr
operator|->
name|sh_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|asect
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
name|this_hdr
operator|->
name|sh_addr
operator|=
name|asect
operator|->
name|vma
expr_stmt|;
else|else
name|this_hdr
operator|->
name|sh_addr
operator|=
literal|0
expr_stmt|;
name|this_hdr
operator|->
name|sh_offset
operator|=
literal|0
expr_stmt|;
name|this_hdr
operator|->
name|sh_size
operator|=
name|asect
operator|->
name|_raw_size
expr_stmt|;
name|this_hdr
operator|->
name|sh_link
operator|=
literal|0
expr_stmt|;
name|this_hdr
operator|->
name|sh_info
operator|=
literal|0
expr_stmt|;
name|this_hdr
operator|->
name|sh_addralign
operator|=
literal|1
operator|<<
name|asect
operator|->
name|alignment_power
expr_stmt|;
name|this_hdr
operator|->
name|sh_entsize
operator|=
literal|0
expr_stmt|;
name|this_hdr
operator|->
name|rawdata
operator|=
operator|(
name|PTR
operator|)
name|asect
expr_stmt|;
name|this_hdr
operator|->
name|contents
operator|=
name|NULL
expr_stmt|;
name|this_hdr
operator|->
name|size
operator|=
literal|0
expr_stmt|;
comment|/* FIXME: This should not be based on section names.  */
if|if
condition|(
name|strcmp
argument_list|(
name|asect
operator|->
name|name
argument_list|,
literal|".dynstr"
argument_list|)
operator|==
literal|0
condition|)
name|this_hdr
operator|->
name|sh_type
operator|=
name|SHT_STRTAB
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|asect
operator|->
name|name
argument_list|,
literal|".hash"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|this_hdr
operator|->
name|sh_type
operator|=
name|SHT_HASH
expr_stmt|;
name|this_hdr
operator|->
name|sh_entsize
operator|=
name|ARCH_SIZE
operator|/
literal|8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|asect
operator|->
name|name
argument_list|,
literal|".dynsym"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|this_hdr
operator|->
name|sh_type
operator|=
name|SHT_DYNSYM
expr_stmt|;
name|this_hdr
operator|->
name|sh_entsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|asect
operator|->
name|name
argument_list|,
literal|".dynamic"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|this_hdr
operator|->
name|sh_type
operator|=
name|SHT_DYNAMIC
expr_stmt|;
name|this_hdr
operator|->
name|sh_entsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf_External_Dyn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|asect
operator|->
name|name
argument_list|,
literal|".rel."
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|this_hdr
operator|->
name|sh_type
operator|=
name|SHT_REL
expr_stmt|;
name|this_hdr
operator|->
name|sh_entsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf_External_Rel
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|asect
operator|->
name|name
argument_list|,
literal|".rela."
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
name|this_hdr
operator|->
name|sh_type
operator|=
name|SHT_RELA
expr_stmt|;
name|this_hdr
operator|->
name|sh_entsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf_External_Rela
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|asect
operator|->
name|name
argument_list|,
literal|".note"
argument_list|)
operator|==
literal|0
condition|)
name|this_hdr
operator|->
name|sh_type
operator|=
name|SHT_NOTE
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|asect
operator|->
name|name
argument_list|,
literal|".stab"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|asect
operator|->
name|name
operator|+
name|strlen
argument_list|(
name|asect
operator|->
name|name
argument_list|)
operator|-
literal|3
argument_list|,
literal|"str"
argument_list|)
operator|==
literal|0
condition|)
name|this_hdr
operator|->
name|sh_type
operator|=
name|SHT_STRTAB
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|asect
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|asect
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|!=
literal|0
condition|)
name|this_hdr
operator|->
name|sh_type
operator|=
name|SHT_PROGBITS
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|asect
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|asect
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|strcmp
argument_list|(
name|asect
operator|->
name|name
argument_list|,
literal|".bss"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|asect
operator|->
name|name
argument_list|,
literal|".sbss"
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|this_hdr
operator|->
name|sh_type
operator|=
name|SHT_NOBITS
expr_stmt|;
block|}
else|else
block|{
comment|/* Who knows?  */
name|this_hdr
operator|->
name|sh_type
operator|=
name|SHT_PROGBITS
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|asect
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
name|this_hdr
operator|->
name|sh_flags
operator||=
name|SHF_ALLOC
expr_stmt|;
if|if
condition|(
operator|(
name|asect
operator|->
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|==
literal|0
condition|)
name|this_hdr
operator|->
name|sh_flags
operator||=
name|SHF_WRITE
expr_stmt|;
if|if
condition|(
operator|(
name|asect
operator|->
name|flags
operator|&
name|SEC_CODE
operator|)
operator|!=
literal|0
condition|)
name|this_hdr
operator|->
name|sh_flags
operator||=
name|SHF_EXECINSTR
expr_stmt|;
comment|/* Check for processor-specific section types.  */
block|{
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
if|if
condition|(
name|bed
operator|->
name|elf_backend_fake_sections
condition|)
call|(
modifier|*
name|bed
operator|->
name|elf_backend_fake_sections
call|)
argument_list|(
name|abfd
argument_list|,
name|this_hdr
argument_list|,
name|asect
argument_list|)
expr_stmt|;
block|}
comment|/* If the section has relocs, set up a section header for the      SHT_REL[A] section.  */
if|if
condition|(
operator|(
name|asect
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|!=
literal|0
condition|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|rela_hdr
decl_stmt|;
name|int
name|use_rela_p
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|use_rela_p
decl_stmt|;
name|rela_hdr
operator|=
operator|&
name|elf_section_data
argument_list|(
name|asect
argument_list|)
operator|->
name|rel_hdr
expr_stmt|;
name|rela_hdr
operator|->
name|sh_name
operator|=
name|bfd_add_2_to_strtab
argument_list|(
name|abfd
argument_list|,
name|elf_shstrtab
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|use_rela_p
condition|?
literal|".rela"
else|:
literal|".rel"
argument_list|,
name|asect
operator|->
name|name
argument_list|)
expr_stmt|;
name|rela_hdr
operator|->
name|sh_type
operator|=
name|use_rela_p
condition|?
name|SHT_RELA
else|:
name|SHT_REL
expr_stmt|;
name|rela_hdr
operator|->
name|sh_entsize
operator|=
operator|(
name|use_rela_p
condition|?
sizeof|sizeof
argument_list|(
name|Elf_External_Rela
argument_list|)
else|:
sizeof|sizeof
argument_list|(
name|Elf_External_Rel
argument_list|)
operator|)
expr_stmt|;
name|rela_hdr
operator|->
name|sh_addralign
operator|=
name|FILE_ALIGN
expr_stmt|;
name|rela_hdr
operator|->
name|sh_flags
operator|=
literal|0
expr_stmt|;
name|rela_hdr
operator|->
name|sh_addr
operator|=
literal|0
expr_stmt|;
name|rela_hdr
operator|->
name|sh_size
operator|=
literal|0
expr_stmt|;
name|rela_hdr
operator|->
name|sh_offset
operator|=
literal|0
expr_stmt|;
name|rela_hdr
operator|->
name|size
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Assign all ELF section numbers.  The dummy first section is handled here    too.  The link/info pointers for the standard section types are filled    in here too, while we're at it.  */
end_comment

begin_function
specifier|static
name|boolean
name|assign_section_numbers
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|struct
name|elf_obj_tdata
modifier|*
name|t
init|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|unsigned
name|int
name|section_number
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
modifier|*
name|i_shdrp
decl_stmt|;
name|section_number
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|sec
operator|=
name|abfd
operator|->
name|sections
init|;
name|sec
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
block|{
name|struct
name|bfd_elf_section_data
modifier|*
name|d
init|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
decl_stmt|;
name|d
operator|->
name|this_idx
operator|=
name|section_number
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|==
literal|0
condition|)
name|d
operator|->
name|rel_idx
operator|=
literal|0
expr_stmt|;
else|else
name|d
operator|->
name|rel_idx
operator|=
name|section_number
operator|++
expr_stmt|;
block|}
name|t
operator|->
name|shstrtab_section
operator|=
name|section_number
operator|++
expr_stmt|;
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_shstrndx
operator|=
name|t
operator|->
name|shstrtab_section
expr_stmt|;
name|t
operator|->
name|shstrtab_hdr
operator|.
name|sh_size
operator|=
name|elf_shstrtab
argument_list|(
name|abfd
argument_list|)
operator|->
name|length
expr_stmt|;
name|t
operator|->
name|shstrtab_hdr
operator|.
name|contents
operator|=
operator|(
name|PTR
operator|)
name|elf_shstrtab
argument_list|(
name|abfd
argument_list|)
operator|->
name|tab
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|symcount
operator|>
literal|0
condition|)
block|{
name|t
operator|->
name|symtab_section
operator|=
name|section_number
operator|++
expr_stmt|;
name|t
operator|->
name|strtab_section
operator|=
name|section_number
operator|++
expr_stmt|;
block|}
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_shnum
operator|=
name|section_number
expr_stmt|;
comment|/* Set up the list of section header pointers, in agreement with the      indices.  */
name|i_shdrp
operator|=
operator|(
operator|(
name|Elf_Internal_Shdr
operator|*
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|section_number
operator|*
sizeof|sizeof
argument_list|(
name|Elf_Internal_Shdr
operator|*
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|i_shdrp
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|i_shdrp
index|[
literal|0
index|]
operator|=
operator|(
operator|(
name|Elf_Internal_Shdr
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf_Internal_Shdr
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|i_shdrp
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
block|{
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|i_shdrp
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|memset
argument_list|(
name|i_shdrp
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf_Internal_Shdr
argument_list|)
argument_list|)
expr_stmt|;
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
operator|=
name|i_shdrp
expr_stmt|;
name|i_shdrp
index|[
name|t
operator|->
name|shstrtab_section
index|]
operator|=
operator|&
name|t
operator|->
name|shstrtab_hdr
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|symcount
operator|>
literal|0
condition|)
block|{
name|i_shdrp
index|[
name|t
operator|->
name|symtab_section
index|]
operator|=
operator|&
name|t
operator|->
name|symtab_hdr
expr_stmt|;
name|i_shdrp
index|[
name|t
operator|->
name|strtab_section
index|]
operator|=
operator|&
name|t
operator|->
name|strtab_hdr
expr_stmt|;
name|t
operator|->
name|symtab_hdr
operator|.
name|sh_link
operator|=
name|t
operator|->
name|strtab_section
expr_stmt|;
block|}
for|for
control|(
name|sec
operator|=
name|abfd
operator|->
name|sections
init|;
name|sec
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
block|{
name|struct
name|bfd_elf_section_data
modifier|*
name|d
init|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|i_shdrp
index|[
name|d
operator|->
name|this_idx
index|]
operator|=
operator|&
name|d
operator|->
name|this_hdr
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|rel_idx
operator|!=
literal|0
condition|)
name|i_shdrp
index|[
name|d
operator|->
name|rel_idx
index|]
operator|=
operator|&
name|d
operator|->
name|rel_hdr
expr_stmt|;
comment|/* Fill in the sh_link and sh_info fields while we're at it.  */
comment|/* sh_link of a reloc section is the section index of the symbol 	 table.  sh_info is the section index of the section to which 	 the relocation entries apply.  */
if|if
condition|(
name|d
operator|->
name|rel_idx
operator|!=
literal|0
condition|)
block|{
name|d
operator|->
name|rel_hdr
operator|.
name|sh_link
operator|=
name|t
operator|->
name|symtab_section
expr_stmt|;
name|d
operator|->
name|rel_hdr
operator|.
name|sh_info
operator|=
name|d
operator|->
name|this_idx
expr_stmt|;
block|}
switch|switch
condition|(
name|d
operator|->
name|this_hdr
operator|.
name|sh_type
condition|)
block|{
case|case
name|SHT_REL
case|:
case|case
name|SHT_RELA
case|:
comment|/* A reloc section which we are treating as a normal BFD 	     section.  sh_link is the section index of the symbol 	     table.  sh_info is the section index of the section to 	     which the relocation entries apply.  We assume that an 	     allocated reloc section uses the dynamic symbol table. 	     FIXME: How can we be sure?  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".dynsym"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
name|d
operator|->
name|this_hdr
operator|.
name|sh_link
operator|=
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|this_idx
expr_stmt|;
comment|/* We look up the section the relocs apply to by name.  */
name|name
operator|=
name|sec
operator|->
name|name
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|this_hdr
operator|.
name|sh_type
operator|==
name|SHT_REL
condition|)
name|name
operator|+=
literal|4
expr_stmt|;
else|else
name|name
operator|+=
literal|5
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
name|d
operator|->
name|this_hdr
operator|.
name|sh_info
operator|=
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|this_idx
expr_stmt|;
break|break;
case|case
name|SHT_STRTAB
case|:
comment|/* We assume that a section named .stab*str is a stabs 	     string section.  We look for a section with the same name 	     but without the trailing ``str'', and set its sh_link 	     field to point to this section.  */
if|if
condition|(
name|strncmp
argument_list|(
name|sec
operator|->
name|name
argument_list|,
literal|".stab"
argument_list|,
sizeof|sizeof
expr|".stab"
operator|-
literal|1
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|sec
operator|->
name|name
operator|+
name|strlen
argument_list|(
name|sec
operator|->
name|name
argument_list|)
operator|-
literal|3
argument_list|,
literal|"str"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|size_t
name|len
decl_stmt|;
name|char
modifier|*
name|alc
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|sec
operator|->
name|name
argument_list|)
expr_stmt|;
name|alc
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|len
operator|-
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|alc
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|strncpy
argument_list|(
name|alc
argument_list|,
name|sec
operator|->
name|name
argument_list|,
name|len
operator|-
literal|3
argument_list|)
expr_stmt|;
name|alc
index|[
name|len
operator|-
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|alc
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|alc
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_link
operator|=
name|d
operator|->
name|this_idx
expr_stmt|;
comment|/* This is a .stab section.  */
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_entsize
operator|=
literal|4
operator|+
literal|2
operator|*
operator|(
name|ARCH_SIZE
operator|/
literal|8
operator|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|SHT_DYNAMIC
case|:
case|case
name|SHT_DYNSYM
case|:
comment|/* sh_link is the section header index of the string table 	     used for the dynamic entries or symbol table.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".dynstr"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
name|d
operator|->
name|this_hdr
operator|.
name|sh_link
operator|=
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|this_idx
expr_stmt|;
break|break;
case|case
name|SHT_HASH
case|:
comment|/* sh_link is the section header index of the symbol table 	     this hash table is for.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".dynsym"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
name|d
operator|->
name|this_hdr
operator|.
name|sh_link
operator|=
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|this_idx
expr_stmt|;
break|break;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Map symbol from it's internal number to the external number, moving    all local symbols to be at the head of the list.  */
end_comment

begin_function
specifier|static
name|INLINE
name|int
name|sym_is_global
parameter_list|(
name|abfd
parameter_list|,
name|sym
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asymbol
modifier|*
name|sym
decl_stmt|;
block|{
comment|/* If the backend has a special mapping, use it.  */
if|if
condition|(
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|elf_backend_sym_is_global
condition|)
return|return
operator|(
operator|(
operator|*
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|elf_backend_sym_is_global
operator|)
operator|(
name|abfd
operator|,
name|sym
operator|)
operator|)
return|;
if|if
condition|(
name|sym
operator|->
name|flags
operator|&
operator|(
name|BSF_GLOBAL
operator||
name|BSF_WEAK
operator|)
condition|)
block|{
if|if
condition|(
name|sym
operator|->
name|flags
operator|&
name|BSF_LOCAL
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|sym
operator|->
name|section
operator|==
literal|0
condition|)
block|{
comment|/* Is this valid?  */
name|abort
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|sym
operator|->
name|section
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|sym
operator|->
name|section
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|sym
operator|->
name|flags
operator|&
operator|(
name|BSF_LOCAL
operator||
name|BSF_SECTION_SYM
operator||
name|BSF_FILE
operator|)
condition|)
return|return
literal|0
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|elf_map_symbols
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|int
name|symcount
init|=
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|syms
init|=
name|bfd_get_outsymbols
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|sect_syms
decl_stmt|;
name|int
name|num_locals
init|=
literal|0
decl_stmt|;
name|int
name|num_globals
init|=
literal|0
decl_stmt|;
name|int
name|num_locals2
init|=
literal|0
decl_stmt|;
name|int
name|num_globals2
init|=
literal|0
decl_stmt|;
name|int
name|max_index
init|=
literal|0
decl_stmt|;
name|int
name|num_sections
init|=
literal|0
decl_stmt|;
name|Elf_Sym_Extra
modifier|*
name|sym_extra
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|asection
modifier|*
name|asect
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"elf_map_symbols\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Add local symbols for each section for which there are relocs.      FIXME: How can we tell which sections have relocs at this point?      Will reloc_count always be accurate?  Actually, I think most ELF      targets create section symbols for all sections anyhow.  */
for|for
control|(
name|asect
operator|=
name|abfd
operator|->
name|sections
init|;
name|asect
condition|;
name|asect
operator|=
name|asect
operator|->
name|next
control|)
block|{
if|if
condition|(
name|max_index
operator|<
name|asect
operator|->
name|index
condition|)
name|max_index
operator|=
name|asect
operator|->
name|index
expr_stmt|;
block|}
name|max_index
operator|++
expr_stmt|;
name|elf_num_section_syms
argument_list|(
name|abfd
argument_list|)
operator|=
name|max_index
expr_stmt|;
name|sect_syms
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|max_index
operator|*
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|elf_section_syms
argument_list|(
name|abfd
argument_list|)
operator|=
name|sect_syms
expr_stmt|;
if|if
condition|(
name|sect_syms
operator|==
literal|0
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
for|for
control|(
name|asect
operator|=
name|abfd
operator|->
name|sections
init|;
name|asect
condition|;
name|asect
operator|=
name|asect
operator|->
name|next
control|)
block|{
name|asymbol
modifier|*
name|sym
init|=
name|bfd_make_empty_symbol
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sym
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|sym
operator|->
name|the_bfd
operator|=
name|abfd
expr_stmt|;
name|sym
operator|->
name|name
operator|=
name|asect
operator|->
name|name
expr_stmt|;
name|sym
operator|->
name|value
operator|=
name|asect
operator|->
name|vma
expr_stmt|;
name|sym
operator|->
name|flags
operator|=
name|BSF_SECTION_SYM
expr_stmt|;
name|sym
operator|->
name|section
operator|=
name|asect
expr_stmt|;
name|sect_syms
index|[
name|asect
operator|->
name|index
index|]
operator|=
name|sym
expr_stmt|;
name|num_sections
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"creating section symbol, name = %s, value = 0x%.8lx, index = %d, section = 0x%.8lx\n"
argument_list|,
name|asect
operator|->
name|name
argument_list|,
operator|(
name|long
operator|)
name|asect
operator|->
name|vma
argument_list|,
name|asect
operator|->
name|index
argument_list|,
operator|(
name|long
operator|)
name|asect
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|num_sections
condition|)
block|{
if|if
condition|(
name|syms
condition|)
name|syms
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|bfd_realloc
argument_list|(
name|abfd
argument_list|,
name|syms
argument_list|,
operator|(
operator|(
name|symcount
operator|+
name|num_sections
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
else|else
name|syms
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
operator|(
name|num_sections
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|syms
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
for|for
control|(
name|asect
operator|=
name|abfd
operator|->
name|sections
init|;
name|asect
condition|;
name|asect
operator|=
name|asect
operator|->
name|next
control|)
block|{
if|if
condition|(
name|sect_syms
index|[
name|asect
operator|->
name|index
index|]
condition|)
name|syms
index|[
name|symcount
operator|++
index|]
operator|=
name|sect_syms
index|[
name|asect
operator|->
name|index
index|]
expr_stmt|;
block|}
name|syms
index|[
name|symcount
index|]
operator|=
operator|(
name|asymbol
operator|*
operator|)
literal|0
expr_stmt|;
name|bfd_set_symtab
argument_list|(
name|abfd
argument_list|,
name|syms
argument_list|,
name|symcount
argument_list|)
expr_stmt|;
block|}
name|elf_sym_extra
argument_list|(
name|abfd
argument_list|)
operator|=
name|sym_extra
operator|=
operator|(
name|Elf_Sym_Extra
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|symcount
operator|*
sizeof|sizeof
argument_list|(
name|Elf_Sym_Extra
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sym_extra
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* Identify and classify all of the symbols.  */
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|symcount
condition|;
name|idx
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|sym_is_global
argument_list|(
name|abfd
argument_list|,
name|syms
index|[
name|idx
index|]
argument_list|)
condition|)
name|num_locals
operator|++
expr_stmt|;
else|else
name|num_globals
operator|++
expr_stmt|;
block|}
comment|/* Now provide mapping information.  Add +1 for skipping over the      dummy symbol.  */
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|symcount
condition|;
name|idx
operator|++
control|)
block|{
name|syms
index|[
name|idx
index|]
operator|->
name|udata
operator|=
operator|(
name|PTR
operator|)
operator|&
name|sym_extra
index|[
name|idx
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|sym_is_global
argument_list|(
name|abfd
argument_list|,
name|syms
index|[
name|idx
index|]
argument_list|)
condition|)
name|sym_extra
index|[
name|idx
index|]
operator|.
name|elf_sym_num
operator|=
literal|1
operator|+
name|num_locals2
operator|++
expr_stmt|;
else|else
name|sym_extra
index|[
name|idx
index|]
operator|.
name|elf_sym_num
operator|=
literal|1
operator|+
name|num_locals
operator|+
name|num_globals2
operator|++
expr_stmt|;
block|}
name|elf_num_locals
argument_list|(
name|abfd
argument_list|)
operator|=
name|num_locals
expr_stmt|;
name|elf_num_globals
argument_list|(
name|abfd
argument_list|)
operator|=
name|num_globals
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Compute the file positions we are going to put the sections at, and    otherwise prepare to begin writing out the ELF file.  If LINK_INFO    is not NULL, this is being called by the ELF backend linker.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf_compute_section_file_positions
parameter_list|(
name|abfd
parameter_list|,
name|link_info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|link_info
decl_stmt|;
block|{
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|shstrtab_hdr
decl_stmt|;
if|if
condition|(
name|abfd
operator|->
name|output_has_begun
condition|)
return|return
name|true
return|;
comment|/* Do any elf backend specific processing first.  */
if|if
condition|(
name|bed
operator|->
name|elf_backend_begin_write_processing
condition|)
call|(
modifier|*
name|bed
operator|->
name|elf_backend_begin_write_processing
call|)
argument_list|(
name|abfd
argument_list|,
name|link_info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prep_headers
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|false
return|;
name|bfd_map_over_sections
argument_list|(
name|abfd
argument_list|,
name|elf_fake_sections
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|assign_section_numbers
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* The backend linker builds symbol table information itself.  */
if|if
condition|(
name|link_info
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|swap_out_syms
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|false
return|;
block|}
name|shstrtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|shstrtab_hdr
expr_stmt|;
comment|/* sh_name was set in prep_headers.  */
name|shstrtab_hdr
operator|->
name|sh_type
operator|=
name|SHT_STRTAB
expr_stmt|;
name|shstrtab_hdr
operator|->
name|sh_flags
operator|=
literal|0
expr_stmt|;
name|shstrtab_hdr
operator|->
name|sh_addr
operator|=
literal|0
expr_stmt|;
name|shstrtab_hdr
operator|->
name|sh_size
operator|=
name|elf_shstrtab
argument_list|(
name|abfd
argument_list|)
operator|->
name|length
expr_stmt|;
name|shstrtab_hdr
operator|->
name|sh_entsize
operator|=
literal|0
expr_stmt|;
name|shstrtab_hdr
operator|->
name|sh_link
operator|=
literal|0
expr_stmt|;
name|shstrtab_hdr
operator|->
name|sh_info
operator|=
literal|0
expr_stmt|;
comment|/* sh_offset is set in assign_file_positions_for_symtabs_and_strtabs.  */
name|shstrtab_hdr
operator|->
name|sh_addralign
operator|=
literal|1
expr_stmt|;
name|shstrtab_hdr
operator|->
name|contents
operator|=
operator|(
name|PTR
operator|)
name|elf_shstrtab
argument_list|(
name|abfd
argument_list|)
operator|->
name|tab
expr_stmt|;
if|if
condition|(
operator|!
name|assign_file_positions_except_relocs
argument_list|(
name|abfd
argument_list|,
name|link_info
operator|==
name|NULL
condition|?
name|true
else|:
name|false
argument_list|)
condition|)
return|return
name|false
return|;
name|abfd
operator|->
name|output_has_begun
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Align to the maximum file alignment that could be required for any    ELF data structure.  */
end_comment

begin_function
specifier|static
name|INLINE
name|file_ptr
name|align_file_position
parameter_list|(
name|off
parameter_list|)
name|file_ptr
name|off
decl_stmt|;
block|{
return|return
operator|(
name|off
operator|+
name|FILE_ALIGN
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|FILE_ALIGN
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Assign a file position to a section, optionally aligning to the    required section alignment.  */
end_comment

begin_function
specifier|static
name|INLINE
name|file_ptr
name|assign_file_position_for_section
parameter_list|(
name|i_shdrp
parameter_list|,
name|offset
parameter_list|,
name|align
parameter_list|)
name|Elf_Internal_Shdr
modifier|*
name|i_shdrp
decl_stmt|;
name|file_ptr
name|offset
decl_stmt|;
name|boolean
name|align
decl_stmt|;
block|{
if|if
condition|(
name|align
condition|)
block|{
name|unsigned
name|int
name|al
decl_stmt|;
name|al
operator|=
name|i_shdrp
operator|->
name|sh_addralign
expr_stmt|;
if|if
condition|(
name|al
operator|>
literal|1
condition|)
name|offset
operator|=
name|BFD_ALIGN
argument_list|(
name|offset
argument_list|,
name|al
argument_list|)
expr_stmt|;
block|}
name|i_shdrp
operator|->
name|sh_offset
operator|=
name|offset
expr_stmt|;
if|if
condition|(
name|i_shdrp
operator|->
name|rawdata
operator|!=
name|NULL
condition|)
operator|(
operator|(
name|asection
operator|*
operator|)
name|i_shdrp
operator|->
name|rawdata
operator|)
operator|->
name|filepos
operator|=
name|offset
expr_stmt|;
if|if
condition|(
name|i_shdrp
operator|->
name|sh_type
operator|!=
name|SHT_NOBITS
condition|)
name|offset
operator|+=
name|i_shdrp
operator|->
name|sh_size
expr_stmt|;
return|return
name|offset
return|;
block|}
end_function

begin_comment
comment|/* Get the size of the program header.  This is called by the linker    before any of the section VMA's are set, so it can't calculate the    correct value for a strange memory layout.  */
end_comment

begin_function
specifier|static
name|bfd_size_type
name|get_program_header_size
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|size_t
name|segs
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
comment|/* Assume we will need exactly two PT_LOAD segments: one for text      and one for data.  */
name|segs
operator|=
literal|2
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".interp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
operator|&&
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* If we have a loadable interpreter section, we need a 	 PT_INTERP segment.  In this case, assume we also need a 	 PT_PHDR segment, although that may not be true for all 	 targets.  */
name|segs
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".dynamic"
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* We need a PT_DYNAMIC segment.  */
operator|++
name|segs
expr_stmt|;
block|}
return|return
name|segs
operator|*
sizeof|sizeof
argument_list|(
name|Elf_External_Phdr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Create the program header.  OFF is the file offset where the    program header should be written.  FIRST is the first loadable ELF    section.  PHDR_SIZE is the size of the program header as returned    by get_program_header_size.  */
end_comment

begin_function
specifier|static
name|file_ptr
name|map_program_segments
parameter_list|(
name|abfd
parameter_list|,
name|off
parameter_list|,
name|first
parameter_list|,
name|phdr_size
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|file_ptr
name|off
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|first
decl_stmt|;
name|bfd_size_type
name|phdr_size
decl_stmt|;
block|{
name|Elf_Internal_Phdr
name|phdrs
index|[
literal|10
index|]
decl_stmt|;
name|unsigned
name|int
name|phdr_count
decl_stmt|;
name|Elf_Internal_Phdr
modifier|*
name|phdr
decl_stmt|;
name|int
name|phdr_size_adjust
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
modifier|*
name|hdrpp
decl_stmt|;
name|asection
modifier|*
name|sinterp
decl_stmt|,
modifier|*
name|sdyn
decl_stmt|;
name|unsigned
name|int
name|last_type
decl_stmt|;
name|Elf_Internal_Ehdr
modifier|*
name|i_ehdrp
decl_stmt|;
name|BFD_ASSERT
argument_list|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|EXEC_P
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|phdr_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf_Internal_Phdr
argument_list|)
operator|<=
sizeof|sizeof
name|phdrs
operator|/
sizeof|sizeof
argument_list|(
name|phdrs
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|phdr_count
operator|=
literal|0
expr_stmt|;
name|phdr
operator|=
name|phdrs
expr_stmt|;
name|phdr_size_adjust
operator|=
literal|0
expr_stmt|;
comment|/* If we have a loadable .interp section, we must create a PT_INTERP      segment which must precede all PT_LOAD segments.  We assume that      we must also create a PT_PHDR segment, although that may not be      true for all targets.  */
name|sinterp
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".interp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sinterp
operator|!=
name|NULL
operator|&&
operator|(
name|sinterp
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|!=
literal|0
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|first
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|phdr
operator|->
name|p_type
operator|=
name|PT_PHDR
expr_stmt|;
name|phdr
operator|->
name|p_offset
operator|=
name|off
expr_stmt|;
comment|/* Account for any adjustment made because of the alignment of 	 the first loadable section.  */
name|phdr_size_adjust
operator|=
operator|(
name|first
operator|->
name|sh_offset
operator|-
name|phdr_size
operator|)
operator|-
name|off
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|phdr_size_adjust
operator|>=
literal|0
operator|&&
name|phdr_size_adjust
operator|<
literal|128
argument_list|)
expr_stmt|;
comment|/* The program header precedes all loadable sections.  This lets 	 us compute its loadable address.  This depends on the linker 	 script.  */
name|phdr
operator|->
name|p_vaddr
operator|=
name|first
operator|->
name|sh_addr
operator|-
operator|(
name|phdr_size
operator|+
name|phdr_size_adjust
operator|)
expr_stmt|;
name|phdr
operator|->
name|p_paddr
operator|=
literal|0
expr_stmt|;
name|phdr
operator|->
name|p_filesz
operator|=
name|phdr_size
expr_stmt|;
name|phdr
operator|->
name|p_memsz
operator|=
name|phdr_size
expr_stmt|;
comment|/* FIXME: UnixWare and Solaris set PF_X, Irix 5 does not.  */
name|phdr
operator|->
name|p_flags
operator|=
name|PF_R
operator||
name|PF_X
expr_stmt|;
name|phdr
operator|->
name|p_align
operator|=
name|FILE_ALIGN
expr_stmt|;
name|BFD_ASSERT
argument_list|(
operator|(
name|phdr
operator|->
name|p_vaddr
operator|-
name|phdr
operator|->
name|p_offset
operator|)
operator|%
name|FILE_ALIGN
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* Include the ELF header in the first loadable segment.  */
name|phdr_size_adjust
operator|+=
name|off
expr_stmt|;
operator|++
name|phdr_count
expr_stmt|;
operator|++
name|phdr
expr_stmt|;
name|phdr
operator|->
name|p_type
operator|=
name|PT_INTERP
expr_stmt|;
name|phdr
operator|->
name|p_offset
operator|=
name|sinterp
operator|->
name|filepos
expr_stmt|;
name|phdr
operator|->
name|p_vaddr
operator|=
name|sinterp
operator|->
name|vma
expr_stmt|;
name|phdr
operator|->
name|p_paddr
operator|=
literal|0
expr_stmt|;
name|phdr
operator|->
name|p_filesz
operator|=
name|sinterp
operator|->
name|_raw_size
expr_stmt|;
name|phdr
operator|->
name|p_memsz
operator|=
name|sinterp
operator|->
name|_raw_size
expr_stmt|;
name|phdr
operator|->
name|p_flags
operator|=
name|PF_R
expr_stmt|;
name|phdr
operator|->
name|p_align
operator|=
literal|1
operator|<<
name|bfd_get_section_alignment
argument_list|(
name|abfd
argument_list|,
name|sinterp
argument_list|)
expr_stmt|;
operator|++
name|phdr_count
expr_stmt|;
operator|++
name|phdr
expr_stmt|;
block|}
comment|/* Look through the sections to see how they will be divided into      program segments.  The sections must be arranged in order by      sh_addr for this to work correctly.  */
name|phdr
operator|->
name|p_type
operator|=
name|PT_NULL
expr_stmt|;
name|last_type
operator|=
name|SHT_PROGBITS
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|hdrpp
operator|=
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
operator|+
literal|1
init|;
name|i
operator|<
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_shnum
condition|;
name|i
operator|++
operator|,
name|hdrpp
operator|++
control|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
name|hdr
operator|=
operator|*
name|hdrpp
expr_stmt|;
comment|/* Ignore any section which will not be part of the process 	 image.  */
if|if
condition|(
operator|(
name|hdr
operator|->
name|sh_flags
operator|&
name|SHF_ALLOC
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* If this section fits in the segment we are constructing, add 	 it in.  */
if|if
condition|(
name|phdr
operator|->
name|p_type
operator|!=
name|PT_NULL
operator|&&
operator|(
name|hdr
operator|->
name|sh_offset
operator|-
operator|(
name|phdr
operator|->
name|p_offset
operator|+
name|phdr
operator|->
name|p_memsz
operator|)
operator|==
name|hdr
operator|->
name|sh_addr
operator|-
operator|(
name|phdr
operator|->
name|p_vaddr
operator|+
name|phdr
operator|->
name|p_memsz
operator|)
operator|)
operator|&&
operator|(
name|last_type
operator|!=
name|SHT_NOBITS
operator|||
name|hdr
operator|->
name|sh_type
operator|==
name|SHT_NOBITS
operator|)
condition|)
block|{
name|bfd_size_type
name|adjust
decl_stmt|;
name|adjust
operator|=
name|hdr
operator|->
name|sh_addr
operator|-
operator|(
name|phdr
operator|->
name|p_vaddr
operator|+
name|phdr
operator|->
name|p_memsz
operator|)
expr_stmt|;
name|phdr
operator|->
name|p_memsz
operator|+=
name|hdr
operator|->
name|sh_size
operator|+
name|adjust
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|sh_type
operator|!=
name|SHT_NOBITS
condition|)
name|phdr
operator|->
name|p_filesz
operator|+=
name|hdr
operator|->
name|sh_size
operator|+
name|adjust
expr_stmt|;
if|if
condition|(
operator|(
name|hdr
operator|->
name|sh_flags
operator|&
name|SHF_WRITE
operator|)
operator|!=
literal|0
condition|)
name|phdr
operator|->
name|p_flags
operator||=
name|PF_W
expr_stmt|;
if|if
condition|(
operator|(
name|hdr
operator|->
name|sh_flags
operator|&
name|SHF_EXECINSTR
operator|)
operator|!=
literal|0
condition|)
name|phdr
operator|->
name|p_flags
operator||=
name|PF_X
expr_stmt|;
name|last_type
operator|=
name|hdr
operator|->
name|sh_type
expr_stmt|;
continue|continue;
block|}
comment|/* If we have a segment, move to the next one.  */
if|if
condition|(
name|phdr
operator|->
name|p_type
operator|!=
name|PT_NULL
condition|)
block|{
operator|++
name|phdr
expr_stmt|;
operator|++
name|phdr_count
expr_stmt|;
block|}
comment|/* Start a new segment.  */
name|phdr
operator|->
name|p_type
operator|=
name|PT_LOAD
expr_stmt|;
name|phdr
operator|->
name|p_offset
operator|=
name|hdr
operator|->
name|sh_offset
expr_stmt|;
name|phdr
operator|->
name|p_vaddr
operator|=
name|hdr
operator|->
name|sh_addr
expr_stmt|;
name|phdr
operator|->
name|p_paddr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|sh_type
operator|==
name|SHT_NOBITS
condition|)
name|phdr
operator|->
name|p_filesz
operator|=
literal|0
expr_stmt|;
else|else
name|phdr
operator|->
name|p_filesz
operator|=
name|hdr
operator|->
name|sh_size
expr_stmt|;
name|phdr
operator|->
name|p_memsz
operator|=
name|hdr
operator|->
name|sh_size
expr_stmt|;
name|phdr
operator|->
name|p_flags
operator|=
name|PF_R
expr_stmt|;
if|if
condition|(
operator|(
name|hdr
operator|->
name|sh_flags
operator|&
name|SHF_WRITE
operator|)
operator|!=
literal|0
condition|)
name|phdr
operator|->
name|p_flags
operator||=
name|PF_W
expr_stmt|;
if|if
condition|(
operator|(
name|hdr
operator|->
name|sh_flags
operator|&
name|SHF_EXECINSTR
operator|)
operator|!=
literal|0
condition|)
name|phdr
operator|->
name|p_flags
operator||=
name|PF_X
expr_stmt|;
name|phdr
operator|->
name|p_align
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|maxpagesize
expr_stmt|;
if|if
condition|(
name|hdr
operator|==
name|first
operator|&&
name|sinterp
operator|!=
name|NULL
operator|&&
operator|(
name|sinterp
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|!=
literal|0
condition|)
block|{
name|phdr
operator|->
name|p_offset
operator|-=
name|phdr_size
operator|+
name|phdr_size_adjust
expr_stmt|;
name|phdr
operator|->
name|p_vaddr
operator|-=
name|phdr_size
operator|+
name|phdr_size_adjust
expr_stmt|;
name|phdr
operator|->
name|p_filesz
operator|+=
name|phdr_size
operator|+
name|phdr_size_adjust
expr_stmt|;
name|phdr
operator|->
name|p_memsz
operator|+=
name|phdr_size
operator|+
name|phdr_size_adjust
expr_stmt|;
block|}
name|last_type
operator|=
name|hdr
operator|->
name|sh_type
expr_stmt|;
block|}
if|if
condition|(
name|phdr
operator|->
name|p_type
operator|!=
name|PT_NULL
condition|)
block|{
operator|++
name|phdr
expr_stmt|;
operator|++
name|phdr_count
expr_stmt|;
block|}
comment|/* If we have a .dynamic section, create a PT_DYNAMIC segment.  */
name|sdyn
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdyn
operator|!=
name|NULL
operator|&&
operator|(
name|sdyn
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|!=
literal|0
condition|)
block|{
name|phdr
operator|->
name|p_type
operator|=
name|PT_DYNAMIC
expr_stmt|;
name|phdr
operator|->
name|p_offset
operator|=
name|sdyn
operator|->
name|filepos
expr_stmt|;
name|phdr
operator|->
name|p_vaddr
operator|=
name|sdyn
operator|->
name|vma
expr_stmt|;
name|phdr
operator|->
name|p_paddr
operator|=
literal|0
expr_stmt|;
name|phdr
operator|->
name|p_filesz
operator|=
name|sdyn
operator|->
name|_raw_size
expr_stmt|;
name|phdr
operator|->
name|p_memsz
operator|=
name|sdyn
operator|->
name|_raw_size
expr_stmt|;
name|phdr
operator|->
name|p_flags
operator|=
name|PF_R
expr_stmt|;
if|if
condition|(
operator|(
name|sdyn
operator|->
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|==
literal|0
condition|)
name|phdr
operator|->
name|p_flags
operator||=
name|PF_W
expr_stmt|;
if|if
condition|(
operator|(
name|sdyn
operator|->
name|flags
operator|&
name|SEC_CODE
operator|)
operator|!=
literal|0
condition|)
name|phdr
operator|->
name|p_flags
operator||=
name|PF_X
expr_stmt|;
name|phdr
operator|->
name|p_align
operator|=
literal|1
operator|<<
name|bfd_get_section_alignment
argument_list|(
name|abfd
argument_list|,
name|sdyn
argument_list|)
expr_stmt|;
operator|++
name|phdr
expr_stmt|;
operator|++
name|phdr_count
expr_stmt|;
block|}
comment|/* Make sure the return value from get_program_header_size matches      what we computed here.  */
if|if
condition|(
name|phdr_count
operator|!=
name|phdr_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf_External_Phdr
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Set up program header information.  */
name|i_ehdrp
operator|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|i_ehdrp
operator|->
name|e_phentsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf_External_Phdr
argument_list|)
expr_stmt|;
name|i_ehdrp
operator|->
name|e_phoff
operator|=
name|off
expr_stmt|;
name|i_ehdrp
operator|->
name|e_phnum
operator|=
name|phdr_count
expr_stmt|;
comment|/* Save the program headers away.  I don't think anybody uses this      information right now.  */
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|phdr
operator|=
operator|(
operator|(
name|Elf_Internal_Phdr
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
operator|(
name|phdr_count
operator|*
sizeof|sizeof
argument_list|(
name|Elf_Internal_Phdr
argument_list|)
operator|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|phdr
operator|==
name|NULL
operator|&&
name|phdr_count
operator|!=
literal|0
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
operator|(
name|file_ptr
operator|)
operator|-
literal|1
return|;
block|}
name|memcpy
argument_list|(
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|phdr
argument_list|,
name|phdrs
argument_list|,
name|phdr_count
operator|*
sizeof|sizeof
argument_list|(
name|Elf_Internal_Phdr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Write out the program headers.  */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|off
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|file_ptr
operator|)
operator|-
literal|1
return|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|phdr
operator|=
name|phdrs
init|;
name|i
operator|<
name|phdr_count
condition|;
name|i
operator|++
operator|,
name|phdr
operator|++
control|)
block|{
name|Elf_External_Phdr
name|extphdr
decl_stmt|;
name|elf_swap_phdr_out
argument_list|(
name|abfd
argument_list|,
name|phdr
argument_list|,
operator|&
name|extphdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
operator|&
name|extphdr
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf_External_Phdr
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|Elf_External_Phdr
argument_list|)
condition|)
return|return
operator|(
name|file_ptr
operator|)
operator|-
literal|1
return|;
block|}
return|return
name|off
operator|+
name|phdr_count
operator|*
sizeof|sizeof
argument_list|(
name|Elf_External_Phdr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Work out the file positions of all the sections.  This is called by    elf_compute_section_file_positions.  All the section sizes and VMAs    must be known before this is called.     We do not consider reloc sections at this point, unless they form    part of the loadable image.  Reloc sections are assigned file    positions in assign_file_positions_for_relocs, which is called by    write_object_contents and final_link.     If DOSYMS is false, we do not assign file positions for the symbol    table or the string table.  */
end_comment

begin_function
specifier|static
name|boolean
name|assign_file_positions_except_relocs
parameter_list|(
name|abfd
parameter_list|,
name|dosyms
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|boolean
name|dosyms
decl_stmt|;
block|{
name|struct
name|elf_obj_tdata
modifier|*
specifier|const
name|tdata
init|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|Elf_Internal_Ehdr
modifier|*
specifier|const
name|i_ehdrp
init|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
modifier|*
specifier|const
name|i_shdrpp
init|=
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|file_ptr
name|off
decl_stmt|;
comment|/* Start after the ELF header.  */
name|off
operator|=
name|i_ehdrp
operator|->
name|e_ehsize
expr_stmt|;
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|EXEC_P
operator|)
operator|==
literal|0
condition|)
block|{
name|Elf_Internal_Shdr
modifier|*
modifier|*
name|hdrpp
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* We are not creating an executable, which means that we are 	 not creating a program header, and that the actual order of 	 the sections in the file is unimportant.  */
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|hdrpp
operator|=
name|i_shdrpp
operator|+
literal|1
init|;
name|i
operator|<
name|i_ehdrp
operator|->
name|e_shnum
condition|;
name|i
operator|++
operator|,
name|hdrpp
operator|++
control|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
name|hdr
operator|=
operator|*
name|hdrpp
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|sh_type
operator|==
name|SHT_REL
operator|||
name|hdr
operator|->
name|sh_type
operator|==
name|SHT_RELA
condition|)
block|{
name|hdr
operator|->
name|sh_offset
operator|=
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|dosyms
operator|&&
operator|(
name|i
operator|==
name|tdata
operator|->
name|symtab_section
operator|||
name|i
operator|==
name|tdata
operator|->
name|strtab_section
operator|)
condition|)
block|{
name|hdr
operator|->
name|sh_offset
operator|=
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
name|off
operator|=
name|assign_file_position_for_section
argument_list|(
name|hdr
argument_list|,
name|off
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|file_ptr
name|phdr_off
decl_stmt|;
name|bfd_size_type
name|phdr_size
decl_stmt|;
name|bfd_vma
name|maxpagesize
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
modifier|*
name|hdrpp
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|first
decl_stmt|;
name|file_ptr
name|phdr_map
decl_stmt|;
comment|/* We are creating an executable.  We must create a program 	 header.  We can't actually create the program header until we 	 have set the file positions for the sections, but we can 	 figure out how big it is going to be.  */
name|off
operator|=
name|align_file_position
argument_list|(
name|off
argument_list|)
expr_stmt|;
name|phdr_size
operator|=
name|get_program_header_size
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|phdr_size
operator|==
operator|(
name|file_ptr
operator|)
operator|-
literal|1
condition|)
return|return
name|false
return|;
name|phdr_off
operator|=
name|off
expr_stmt|;
name|off
operator|+=
name|phdr_size
expr_stmt|;
name|maxpagesize
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|maxpagesize
expr_stmt|;
if|if
condition|(
name|maxpagesize
operator|==
literal|0
condition|)
name|maxpagesize
operator|=
literal|1
expr_stmt|;
comment|/* FIXME: We might want to sort the sections on the sh_addr 	 field here.  For now, we just assume that the linker will 	 create the sections in an appropriate order.  */
comment|/* Assign file positions in two passes.  In the first pass, we 	 assign a file position to every section which forms part of 	 the executable image.  */
name|first
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|hdrpp
operator|=
name|i_shdrpp
operator|+
literal|1
init|;
name|i
operator|<
name|i_ehdrp
operator|->
name|e_shnum
condition|;
name|i
operator|++
operator|,
name|hdrpp
operator|++
control|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
name|hdr
operator|=
operator|*
name|hdrpp
expr_stmt|;
if|if
condition|(
operator|(
name|hdr
operator|->
name|sh_flags
operator|&
name|SHF_ALLOC
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|first
operator|==
name|NULL
condition|)
name|first
operator|=
name|hdr
expr_stmt|;
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|D_PAGED
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* The section VMA must equal the file position modulo 		 the page size.  This is required by the program 		 header.  */
name|off
operator|+=
operator|(
name|hdr
operator|->
name|sh_addr
operator|-
name|off
operator|)
operator|%
name|maxpagesize
expr_stmt|;
block|}
name|off
operator|=
name|assign_file_position_for_section
argument_list|(
name|hdr
argument_list|,
name|off
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
comment|/* Assign file positions to all the sections which do not form 	 part of the loadable image, except for the relocs.  */
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|hdrpp
operator|=
name|i_shdrpp
operator|+
literal|1
init|;
name|i
operator|<
name|i_ehdrp
operator|->
name|e_shnum
condition|;
name|i
operator|++
operator|,
name|hdrpp
operator|++
control|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
name|hdr
operator|=
operator|*
name|hdrpp
expr_stmt|;
if|if
condition|(
operator|(
name|hdr
operator|->
name|sh_flags
operator|&
name|SHF_ALLOC
operator|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|hdr
operator|->
name|sh_type
operator|==
name|SHT_REL
operator|||
name|hdr
operator|->
name|sh_type
operator|==
name|SHT_RELA
condition|)
block|{
name|hdr
operator|->
name|sh_offset
operator|=
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|dosyms
operator|&&
operator|(
name|i
operator|==
name|tdata
operator|->
name|symtab_section
operator|||
name|i
operator|==
name|tdata
operator|->
name|strtab_section
operator|)
condition|)
block|{
name|hdr
operator|->
name|sh_offset
operator|=
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
name|off
operator|=
name|assign_file_position_for_section
argument_list|(
name|hdr
argument_list|,
name|off
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
name|phdr_map
operator|=
name|map_program_segments
argument_list|(
name|abfd
argument_list|,
name|phdr_off
argument_list|,
name|first
argument_list|,
name|phdr_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|phdr_map
operator|==
operator|(
name|file_ptr
operator|)
operator|-
literal|1
condition|)
return|return
name|false
return|;
name|BFD_ASSERT
argument_list|(
name|phdr_map
operator|==
name|phdr_off
operator|+
name|phdr_size
argument_list|)
expr_stmt|;
block|}
comment|/* Place the section headers.  */
name|off
operator|=
name|align_file_position
argument_list|(
name|off
argument_list|)
expr_stmt|;
name|i_ehdrp
operator|->
name|e_shoff
operator|=
name|off
expr_stmt|;
name|off
operator|+=
name|i_ehdrp
operator|->
name|e_shnum
operator|*
name|i_ehdrp
operator|->
name|e_shentsize
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|next_file_pos
operator|=
name|off
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|prep_headers
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|Elf_Internal_Ehdr
modifier|*
name|i_ehdrp
decl_stmt|;
comment|/* Elf file header, internal form */
name|Elf_Internal_Phdr
modifier|*
name|i_phdrp
init|=
literal|0
decl_stmt|;
comment|/* Program header table, internal form */
name|Elf_Internal_Shdr
modifier|*
modifier|*
name|i_shdrp
decl_stmt|;
comment|/* Section header table, internal form */
name|int
name|count
decl_stmt|;
name|struct
name|strtab
modifier|*
name|shstrtab
decl_stmt|;
name|i_ehdrp
operator|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|i_shdrp
operator|=
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|shstrtab
operator|=
name|bfd_new_strtab
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|shstrtab
condition|)
return|return
name|false
return|;
name|elf_shstrtab
argument_list|(
name|abfd
argument_list|)
operator|=
name|shstrtab
expr_stmt|;
name|i_ehdrp
operator|->
name|e_ident
index|[
name|EI_MAG0
index|]
operator|=
name|ELFMAG0
expr_stmt|;
name|i_ehdrp
operator|->
name|e_ident
index|[
name|EI_MAG1
index|]
operator|=
name|ELFMAG1
expr_stmt|;
name|i_ehdrp
operator|->
name|e_ident
index|[
name|EI_MAG2
index|]
operator|=
name|ELFMAG2
expr_stmt|;
name|i_ehdrp
operator|->
name|e_ident
index|[
name|EI_MAG3
index|]
operator|=
name|ELFMAG3
expr_stmt|;
name|i_ehdrp
operator|->
name|e_ident
index|[
name|EI_CLASS
index|]
operator|=
name|ELFCLASS
expr_stmt|;
name|i_ehdrp
operator|->
name|e_ident
index|[
name|EI_DATA
index|]
operator|=
name|abfd
operator|->
name|xvec
operator|->
name|byteorder_big_p
condition|?
name|ELFDATA2MSB
else|:
name|ELFDATA2LSB
expr_stmt|;
name|i_ehdrp
operator|->
name|e_ident
index|[
name|EI_VERSION
index|]
operator|=
name|EV_CURRENT
expr_stmt|;
for|for
control|(
name|count
operator|=
name|EI_PAD
init|;
name|count
operator|<
name|EI_NIDENT
condition|;
name|count
operator|++
control|)
name|i_ehdrp
operator|->
name|e_ident
index|[
name|count
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|!=
literal|0
condition|)
name|i_ehdrp
operator|->
name|e_type
operator|=
name|ET_DYN
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|EXEC_P
operator|)
operator|!=
literal|0
condition|)
name|i_ehdrp
operator|->
name|e_type
operator|=
name|ET_EXEC
expr_stmt|;
else|else
name|i_ehdrp
operator|->
name|e_type
operator|=
name|ET_REL
expr_stmt|;
switch|switch
condition|(
name|bfd_get_arch
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
case|case
name|bfd_arch_unknown
case|:
name|i_ehdrp
operator|->
name|e_machine
operator|=
name|EM_NONE
expr_stmt|;
break|break;
case|case
name|bfd_arch_sparc
case|:
if|#
directive|if
name|ARCH_SIZE
operator|==
literal|64
name|i_ehdrp
operator|->
name|e_machine
operator|=
name|EM_SPARC64
expr_stmt|;
else|#
directive|else
name|i_ehdrp
operator|->
name|e_machine
operator|=
name|EM_SPARC
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|bfd_arch_i386
case|:
name|i_ehdrp
operator|->
name|e_machine
operator|=
name|EM_386
expr_stmt|;
break|break;
case|case
name|bfd_arch_m68k
case|:
name|i_ehdrp
operator|->
name|e_machine
operator|=
name|EM_68K
expr_stmt|;
break|break;
case|case
name|bfd_arch_m88k
case|:
name|i_ehdrp
operator|->
name|e_machine
operator|=
name|EM_88K
expr_stmt|;
break|break;
case|case
name|bfd_arch_i860
case|:
name|i_ehdrp
operator|->
name|e_machine
operator|=
name|EM_860
expr_stmt|;
break|break;
case|case
name|bfd_arch_mips
case|:
comment|/* MIPS Rxxxx */
name|i_ehdrp
operator|->
name|e_machine
operator|=
name|EM_MIPS
expr_stmt|;
comment|/* only MIPS R3000 */
break|break;
case|case
name|bfd_arch_hppa
case|:
name|i_ehdrp
operator|->
name|e_machine
operator|=
name|EM_PARISC
expr_stmt|;
break|break;
case|case
name|bfd_arch_powerpc
case|:
name|i_ehdrp
operator|->
name|e_machine
operator|=
name|EM_CYGNUS_POWERPC
expr_stmt|;
break|break;
comment|/* also note that EM_M32, AT&T WE32100 is unknown to bfd */
default|default:
name|i_ehdrp
operator|->
name|e_machine
operator|=
name|EM_NONE
expr_stmt|;
block|}
name|i_ehdrp
operator|->
name|e_version
operator|=
name|EV_CURRENT
expr_stmt|;
name|i_ehdrp
operator|->
name|e_ehsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf_External_Ehdr
argument_list|)
expr_stmt|;
comment|/* no program header, for now. */
name|i_ehdrp
operator|->
name|e_phoff
operator|=
literal|0
expr_stmt|;
name|i_ehdrp
operator|->
name|e_phentsize
operator|=
literal|0
expr_stmt|;
name|i_ehdrp
operator|->
name|e_phnum
operator|=
literal|0
expr_stmt|;
comment|/* each bfd section is section header entry */
name|i_ehdrp
operator|->
name|e_entry
operator|=
name|bfd_get_start_address
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|i_ehdrp
operator|->
name|e_shentsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf_External_Shdr
argument_list|)
expr_stmt|;
comment|/* if we're building an executable, we'll need a program header table */
if|if
condition|(
name|abfd
operator|->
name|flags
operator|&
name|EXEC_P
condition|)
block|{
comment|/* it all happens later */
if|#
directive|if
literal|0
block|i_ehdrp->e_phentsize = sizeof (Elf_External_Phdr);
comment|/* elf_build_phdrs() returns a (NULL-terminated) array of 	 Elf_Internal_Phdrs */
block|i_phdrp = elf_build_phdrs (abfd, i_ehdrp, i_shdrp,&i_ehdrp->e_phnum);       i_ehdrp->e_phoff = outbase;       outbase += i_ehdrp->e_phentsize * i_ehdrp->e_phnum;
endif|#
directive|endif
block|}
else|else
block|{
name|i_ehdrp
operator|->
name|e_phentsize
operator|=
literal|0
expr_stmt|;
name|i_phdrp
operator|=
literal|0
expr_stmt|;
name|i_ehdrp
operator|->
name|e_phoff
operator|=
literal|0
expr_stmt|;
block|}
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
operator|.
name|sh_name
operator|=
name|bfd_add_to_strtab
argument_list|(
name|abfd
argument_list|,
name|shstrtab
argument_list|,
literal|".symtab"
argument_list|)
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|strtab_hdr
operator|.
name|sh_name
operator|=
name|bfd_add_to_strtab
argument_list|(
name|abfd
argument_list|,
name|shstrtab
argument_list|,
literal|".strtab"
argument_list|)
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|shstrtab_hdr
operator|.
name|sh_name
operator|=
name|bfd_add_to_strtab
argument_list|(
name|abfd
argument_list|,
name|shstrtab
argument_list|,
literal|".shstrtab"
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
operator|.
name|sh_name
operator|==
operator|(
name|unsigned
name|int
operator|)
operator|-
literal|1
operator|||
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
operator|.
name|sh_name
operator|==
operator|(
name|unsigned
name|int
operator|)
operator|-
literal|1
operator|||
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|shstrtab_hdr
operator|.
name|sh_name
operator|==
operator|(
name|unsigned
name|int
operator|)
operator|-
literal|1
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|swap_out_syms
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|elf_map_symbols
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Dump out the symtabs. */
block|{
name|int
name|symcount
init|=
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|syms
init|=
name|bfd_get_outsymbols
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|struct
name|strtab
modifier|*
name|stt
init|=
name|bfd_new_strtab
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symstrtab_hdr
decl_stmt|;
name|Elf_External_Sym
modifier|*
name|outbound_syms
decl_stmt|;
name|int
name|idx
decl_stmt|;
if|if
condition|(
operator|!
name|stt
condition|)
return|return
name|false
return|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|symtab_hdr
operator|->
name|sh_type
operator|=
name|SHT_SYMTAB
expr_stmt|;
name|symtab_hdr
operator|->
name|sh_entsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
expr_stmt|;
name|symtab_hdr
operator|->
name|sh_size
operator|=
name|symtab_hdr
operator|->
name|sh_entsize
operator|*
operator|(
name|symcount
operator|+
literal|1
operator|)
expr_stmt|;
name|symtab_hdr
operator|->
name|sh_info
operator|=
name|elf_num_locals
argument_list|(
name|abfd
argument_list|)
operator|+
literal|1
expr_stmt|;
name|symtab_hdr
operator|->
name|sh_addralign
operator|=
name|FILE_ALIGN
expr_stmt|;
name|symstrtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|strtab_hdr
expr_stmt|;
name|symstrtab_hdr
operator|->
name|sh_type
operator|=
name|SHT_STRTAB
expr_stmt|;
name|outbound_syms
operator|=
operator|(
name|Elf_External_Sym
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
operator|(
literal|1
operator|+
name|symcount
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|outbound_syms
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* now generate the data (for "contents") */
block|{
comment|/* Fill in zeroth symbol and swap it out.  */
name|Elf_Internal_Sym
name|sym
decl_stmt|;
name|sym
operator|.
name|st_name
operator|=
literal|0
expr_stmt|;
name|sym
operator|.
name|st_value
operator|=
literal|0
expr_stmt|;
name|sym
operator|.
name|st_size
operator|=
literal|0
expr_stmt|;
name|sym
operator|.
name|st_info
operator|=
literal|0
expr_stmt|;
name|sym
operator|.
name|st_other
operator|=
literal|0
expr_stmt|;
name|sym
operator|.
name|st_shndx
operator|=
name|SHN_UNDEF
expr_stmt|;
name|elf_swap_symbol_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|sym
argument_list|,
name|outbound_syms
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|symcount
condition|;
name|idx
operator|++
control|)
block|{
name|Elf_Internal_Sym
name|sym
decl_stmt|;
name|bfd_vma
name|value
init|=
name|syms
index|[
name|idx
index|]
operator|->
name|value
decl_stmt|;
name|elf_symbol_type
modifier|*
name|type_ptr
decl_stmt|;
if|if
condition|(
name|syms
index|[
name|idx
index|]
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
condition|)
comment|/* Section symbols have no names.  */
name|sym
operator|.
name|st_name
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|sym
operator|.
name|st_name
operator|=
name|bfd_add_to_strtab
argument_list|(
name|abfd
argument_list|,
name|stt
argument_list|,
name|syms
index|[
name|idx
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|.
name|st_name
operator|==
operator|(
name|unsigned
name|long
operator|)
operator|-
literal|1
condition|)
return|return
name|false
return|;
block|}
name|type_ptr
operator|=
name|elf_symbol_from
argument_list|(
name|abfd
argument_list|,
name|syms
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|syms
index|[
name|idx
index|]
operator|->
name|section
argument_list|)
condition|)
block|{
comment|/* ELF common symbols put the alignment into the `value' field, 	       and the size into the `size' field.  This is backwards from 	       how BFD handles it, so reverse it here.  */
name|sym
operator|.
name|st_size
operator|=
name|value
expr_stmt|;
name|sym
operator|.
name|st_value
operator|=
name|type_ptr
condition|?
name|type_ptr
operator|->
name|internal_elf_sym
operator|.
name|st_value
else|:
literal|16
expr_stmt|;
name|sym
operator|.
name|st_shndx
operator|=
name|elf_section_from_bfd_section
argument_list|(
name|abfd
argument_list|,
name|syms
index|[
name|idx
index|]
operator|->
name|section
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|asection
modifier|*
name|sec
init|=
name|syms
index|[
name|idx
index|]
operator|->
name|section
decl_stmt|;
name|int
name|shndx
decl_stmt|;
if|if
condition|(
name|sec
operator|->
name|output_section
condition|)
block|{
name|value
operator|+=
name|sec
operator|->
name|output_offset
expr_stmt|;
name|sec
operator|=
name|sec
operator|->
name|output_section
expr_stmt|;
block|}
name|value
operator|+=
name|sec
operator|->
name|vma
expr_stmt|;
name|sym
operator|.
name|st_value
operator|=
name|value
expr_stmt|;
name|sym
operator|.
name|st_size
operator|=
name|type_ptr
condition|?
name|type_ptr
operator|->
name|internal_elf_sym
operator|.
name|st_size
else|:
literal|0
expr_stmt|;
name|sym
operator|.
name|st_shndx
operator|=
name|shndx
operator|=
name|elf_section_from_bfd_section
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|shndx
operator|==
operator|-
literal|1
condition|)
block|{
name|asection
modifier|*
name|sec2
decl_stmt|;
comment|/* Writing this would be a hell of a lot easier if we had 		   some decent documentation on bfd, and knew what to expect 		   of the library, and what to demand of applications.  For 		   example, it appears that `objcopy' might not set the 		   section of a symbol to be a section that is actually in 		   the output file.  */
name|sec2
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|sec
operator|->
name|name
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sec2
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|sym
operator|.
name|st_shndx
operator|=
name|shndx
operator|=
name|elf_section_from_bfd_section
argument_list|(
name|abfd
argument_list|,
name|sec2
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|shndx
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|syms
index|[
name|idx
index|]
operator|->
name|section
argument_list|)
condition|)
name|sym
operator|.
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|STB_GLOBAL
argument_list|,
name|STT_OBJECT
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|syms
index|[
name|idx
index|]
operator|->
name|section
argument_list|)
condition|)
name|sym
operator|.
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|STB_GLOBAL
argument_list|,
name|STT_NOTYPE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|syms
index|[
name|idx
index|]
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
condition|)
name|sym
operator|.
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|STB_LOCAL
argument_list|,
name|STT_SECTION
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|syms
index|[
name|idx
index|]
operator|->
name|flags
operator|&
name|BSF_FILE
condition|)
name|sym
operator|.
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|STB_LOCAL
argument_list|,
name|STT_FILE
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|bind
init|=
name|STB_LOCAL
decl_stmt|;
name|int
name|type
init|=
name|STT_OBJECT
decl_stmt|;
name|unsigned
name|int
name|flags
init|=
name|syms
index|[
name|idx
index|]
operator|->
name|flags
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|BSF_LOCAL
condition|)
name|bind
operator|=
name|STB_LOCAL
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|BSF_WEAK
condition|)
name|bind
operator|=
name|STB_WEAK
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|BSF_GLOBAL
condition|)
name|bind
operator|=
name|STB_GLOBAL
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|BSF_FUNCTION
condition|)
name|type
operator|=
name|STT_FUNC
expr_stmt|;
name|sym
operator|.
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|bind
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
name|sym
operator|.
name|st_other
operator|=
literal|0
expr_stmt|;
name|elf_swap_symbol_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|sym
argument_list|,
operator|(
name|outbound_syms
operator|+
name|elf_sym_extra
argument_list|(
name|abfd
argument_list|)
index|[
name|idx
index|]
operator|.
name|elf_sym_num
operator|)
argument_list|)
expr_stmt|;
block|}
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|PTR
operator|)
name|outbound_syms
expr_stmt|;
name|symstrtab_hdr
operator|->
name|contents
operator|=
operator|(
name|PTR
operator|)
name|stt
operator|->
name|tab
expr_stmt|;
name|symstrtab_hdr
operator|->
name|sh_size
operator|=
name|stt
operator|->
name|length
expr_stmt|;
name|symstrtab_hdr
operator|->
name|sh_type
operator|=
name|SHT_STRTAB
expr_stmt|;
name|symstrtab_hdr
operator|->
name|sh_flags
operator|=
literal|0
expr_stmt|;
name|symstrtab_hdr
operator|->
name|sh_addr
operator|=
literal|0
expr_stmt|;
name|symstrtab_hdr
operator|->
name|sh_entsize
operator|=
literal|0
expr_stmt|;
name|symstrtab_hdr
operator|->
name|sh_link
operator|=
literal|0
expr_stmt|;
name|symstrtab_hdr
operator|->
name|sh_info
operator|=
literal|0
expr_stmt|;
name|symstrtab_hdr
operator|->
name|sh_addralign
operator|=
literal|1
expr_stmt|;
name|symstrtab_hdr
operator|->
name|size
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|write_shdrs_and_ehdr
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|Elf_External_Ehdr
name|x_ehdr
decl_stmt|;
comment|/* Elf file header, external form */
name|Elf_Internal_Ehdr
modifier|*
name|i_ehdrp
decl_stmt|;
comment|/* Elf file header, internal form */
name|Elf_External_Shdr
modifier|*
name|x_shdrp
decl_stmt|;
comment|/* Section header table, external form */
name|Elf_Internal_Shdr
modifier|*
modifier|*
name|i_shdrp
decl_stmt|;
comment|/* Section header table, internal form */
name|unsigned
name|int
name|count
decl_stmt|;
name|struct
name|strtab
modifier|*
name|shstrtab
decl_stmt|;
name|i_ehdrp
operator|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|i_shdrp
operator|=
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|shstrtab
operator|=
name|elf_shstrtab
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* swap the header before spitting it out... */
if|#
directive|if
name|DEBUG
operator|&
literal|1
name|elf_debug_file
argument_list|(
name|i_ehdrp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|elf_swap_ehdr_out
argument_list|(
name|abfd
argument_list|,
name|i_ehdrp
argument_list|,
operator|&
name|x_ehdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|x_ehdr
argument_list|,
sizeof|sizeof
argument_list|(
name|x_ehdr
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|x_ehdr
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
comment|/* at this point we've concocted all the ELF sections... */
name|x_shdrp
operator|=
operator|(
name|Elf_External_Shdr
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|x_shdrp
argument_list|)
operator|*
operator|(
name|i_ehdrp
operator|->
name|e_shnum
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|x_shdrp
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|i_ehdrp
operator|->
name|e_shnum
condition|;
name|count
operator|++
control|)
block|{
if|#
directive|if
name|DEBUG
operator|&
literal|2
name|elf_debug_section
argument_list|(
name|shstrtab
operator|->
name|tab
operator|+
name|i_shdrp
index|[
name|count
index|]
operator|->
name|sh_name
argument_list|,
name|count
argument_list|,
name|i_shdrp
index|[
name|count
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|elf_swap_shdr_out
argument_list|(
name|abfd
argument_list|,
name|i_shdrp
index|[
name|count
index|]
argument_list|,
name|x_shdrp
operator|+
name|count
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
name|i_ehdrp
operator|->
name|e_shoff
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|x_shdrp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|x_shdrp
argument_list|)
argument_list|,
name|i_ehdrp
operator|->
name|e_shnum
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|x_shdrp
argument_list|)
operator|*
name|i_ehdrp
operator|->
name|e_shnum
operator|)
condition|)
return|return
name|false
return|;
comment|/* need to dump the string table too... */
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Assign file positions for all the reloc sections which are not part    of the loadable file image.  */
end_comment

begin_function
specifier|static
name|void
name|assign_file_positions_for_relocs
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|file_ptr
name|off
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
modifier|*
name|shdrpp
decl_stmt|;
name|off
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|next_file_pos
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|shdrpp
operator|=
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
operator|+
literal|1
init|;
name|i
operator|<
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_shnum
condition|;
name|i
operator|++
operator|,
name|shdrpp
operator|++
control|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|shdrp
decl_stmt|;
name|shdrp
operator|=
operator|*
name|shdrpp
expr_stmt|;
if|if
condition|(
operator|(
name|shdrp
operator|->
name|sh_type
operator|==
name|SHT_REL
operator|||
name|shdrp
operator|->
name|sh_type
operator|==
name|SHT_RELA
operator|)
operator|&&
name|shdrp
operator|->
name|sh_offset
operator|==
operator|-
literal|1
condition|)
name|off
operator|=
name|assign_file_position_for_section
argument_list|(
name|shdrp
argument_list|,
name|off
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|next_file_pos
operator|=
name|off
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|boolean
name|NAME
argument_list|(
name|bfd_elf
argument_list|,
name|write_object_contents
argument_list|)
argument_list|(
name|abfd
argument_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|Elf_Internal_Ehdr
modifier|*
name|i_ehdrp
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
modifier|*
name|i_shdrp
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
if|if
condition|(
operator|!
name|abfd
operator|->
name|output_has_begun
operator|&&
operator|!
name|elf_compute_section_file_positions
argument_list|(
name|abfd
argument_list|,
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|)
name|NULL
argument_list|)
condition|)
return|return
name|false
return|;
name|i_shdrp
operator|=
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|i_ehdrp
operator|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|bfd_map_over_sections
argument_list|(
name|abfd
argument_list|,
name|write_relocs
argument_list|,
operator|(
name|PTR
operator|)
literal|0
argument_list|)
expr_stmt|;
name|assign_file_positions_for_relocs
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* After writing the headers, we need to write the sections too... */
for|for
control|(
name|count
operator|=
literal|1
init|;
name|count
operator|<
name|i_ehdrp
operator|->
name|e_shnum
condition|;
name|count
operator|++
control|)
block|{
if|if
condition|(
name|bed
operator|->
name|elf_backend_section_processing
condition|)
call|(
modifier|*
name|bed
operator|->
name|elf_backend_section_processing
call|)
argument_list|(
name|abfd
argument_list|,
name|i_shdrp
index|[
name|count
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|i_shdrp
index|[
name|count
index|]
operator|->
name|contents
condition|)
block|{
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|i_shdrp
index|[
name|count
index|]
operator|->
name|sh_offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|bfd_write
argument_list|(
name|i_shdrp
index|[
name|count
index|]
operator|->
name|contents
argument_list|,
name|i_shdrp
index|[
name|count
index|]
operator|->
name|sh_size
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
name|i_shdrp
index|[
name|count
index|]
operator|->
name|sh_size
operator|)
condition|)
return|return
name|false
return|;
block|}
block|}
if|if
condition|(
name|bed
operator|->
name|elf_backend_final_write_processing
condition|)
call|(
modifier|*
name|bed
operator|->
name|elf_backend_final_write_processing
call|)
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|write_shdrs_and_ehdr
argument_list|(
name|abfd
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/* Given an index of a section, retrieve a pointer to it.  Note    that for our purposes, sections are indexed by {1, 2, ...} with    0 being an illegal index. */
end_comment

begin_comment
comment|/* In the original, each ELF section went into exactly one BFD    section. This doesn't really make sense, so we need a real mapping.    The mapping has to hide in the Elf_Internal_Shdr since asection    doesn't have anything like a tdata field... */
end_comment

begin_function
specifier|static
name|asection
modifier|*
name|section_from_elf_index
parameter_list|(
name|abfd
parameter_list|,
name|index
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|unsigned
name|int
name|index
decl_stmt|;
block|{
comment|/* @@ Is bfd_com_section_ptr really correct in all the places it could      be returned from this routine?  */
if|if
condition|(
name|index
operator|==
name|SHN_ABS
condition|)
return|return
name|bfd_com_section_ptr
return|;
comment|/* not abs? */
if|if
condition|(
name|index
operator|==
name|SHN_COMMON
condition|)
return|return
name|bfd_com_section_ptr
return|;
if|if
condition|(
name|index
operator|>=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_shnum
condition|)
return|return
name|NULL
return|;
block|{
name|Elf_Internal_Shdr
modifier|*
name|hdr
init|=
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
index|[
name|index
index|]
decl_stmt|;
switch|switch
condition|(
name|hdr
operator|->
name|sh_type
condition|)
block|{
comment|/* ELF sections that map to BFD sections */
case|case
name|SHT_PROGBITS
case|:
case|case
name|SHT_NOBITS
case|:
case|case
name|SHT_HASH
case|:
case|case
name|SHT_DYNAMIC
case|:
if|if
condition|(
name|hdr
operator|->
name|rawdata
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_section_from_shdr
argument_list|(
name|abfd
argument_list|,
name|index
argument_list|)
condition|)
return|return
name|NULL
return|;
block|}
return|return
operator|(
expr|struct
name|sec
operator|*
operator|)
name|hdr
operator|->
name|rawdata
return|;
default|default:
return|return
name|bfd_abs_section_ptr
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* given a section, search the header to find them... */
end_comment

begin_function
specifier|static
name|int
name|elf_section_from_bfd_section
parameter_list|(
name|abfd
parameter_list|,
name|asect
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|sec
modifier|*
name|asect
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
modifier|*
name|i_shdrp
init|=
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|int
name|index
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
name|int
name|maxindex
init|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_shnum
decl_stmt|;
if|if
condition|(
name|asect
operator|->
name|owner
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|bfd_is_abs_section
argument_list|(
name|asect
argument_list|)
condition|)
return|return
name|SHN_ABS
return|;
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|asect
argument_list|)
condition|)
return|return
name|SHN_COMMON
return|;
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|asect
argument_list|)
condition|)
return|return
name|SHN_UNDEF
return|;
return|return
operator|-
literal|1
return|;
block|}
name|BFD_ASSERT
argument_list|(
name|asect
operator|->
name|owner
operator|==
name|abfd
argument_list|)
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|maxindex
condition|;
name|index
operator|++
control|)
block|{
name|hdr
operator|=
name|i_shdrp
index|[
name|index
index|]
expr_stmt|;
switch|switch
condition|(
name|hdr
operator|->
name|sh_type
condition|)
block|{
comment|/* ELF sections that map to BFD sections */
case|case
name|SHT_PROGBITS
case|:
case|case
name|SHT_NOBITS
case|:
case|case
name|SHT_NOTE
case|:
case|case
name|SHT_HASH
case|:
case|case
name|SHT_DYNAMIC
case|:
case|case
name|SHT_DYNSYM
case|:
if|if
condition|(
name|hdr
operator|->
name|rawdata
condition|)
block|{
if|if
condition|(
operator|(
operator|(
expr|struct
name|sec
operator|*
operator|)
operator|(
name|hdr
operator|->
name|rawdata
operator|)
operator|)
operator|==
name|asect
condition|)
return|return
name|index
return|;
block|}
break|break;
case|case
name|SHT_REL
case|:
case|case
name|SHT_RELA
case|:
comment|/* We sometimes map a reloc section to a BFD section.  */
if|if
condition|(
name|hdr
operator|->
name|sh_link
operator|!=
name|elf_onesymtab
argument_list|(
name|abfd
argument_list|)
operator|&&
operator|(
name|asection
operator|*
operator|)
name|hdr
operator|->
name|rawdata
operator|==
name|asect
condition|)
return|return
name|index
return|;
break|break;
case|case
name|SHT_STRTAB
case|:
comment|/* We map most string tables to BFD sections.  */
if|if
condition|(
name|index
operator|!=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_shstrndx
operator|&&
name|index
operator|!=
name|elf_onesymtab
argument_list|(
name|abfd
argument_list|)
operator|&&
operator|(
name|asection
operator|*
operator|)
name|hdr
operator|->
name|rawdata
operator|==
name|asect
condition|)
return|return
name|index
return|;
comment|/* FALL THROUGH */
default|default:
block|{
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
if|if
condition|(
name|bed
operator|->
name|elf_backend_section_from_bfd_section
condition|)
block|{
name|int
name|retval
decl_stmt|;
name|retval
operator|=
name|index
expr_stmt|;
if|if
condition|(
call|(
modifier|*
name|bed
operator|->
name|elf_backend_section_from_bfd_section
call|)
argument_list|(
name|abfd
argument_list|,
name|hdr
argument_list|,
name|asect
argument_list|,
operator|&
name|retval
argument_list|)
condition|)
return|return
name|retval
return|;
block|}
block|}
break|break;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* given a symbol, return the bfd index for that symbol.  */
end_comment

begin_function
specifier|static
name|int
name|elf_symbol_from_bfd_symbol
parameter_list|(
name|abfd
parameter_list|,
name|asym_ptr_ptr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|symbol_cache_entry
modifier|*
modifier|*
name|asym_ptr_ptr
decl_stmt|;
block|{
name|struct
name|symbol_cache_entry
modifier|*
name|asym_ptr
init|=
operator|*
name|asym_ptr_ptr
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|flagword
name|flags
init|=
name|asym_ptr
operator|->
name|flags
decl_stmt|;
comment|/* When gas creates relocations against local labels, it creates its      own symbol for the section, but does put the symbol into the      symbol chain, so udata is 0.  When the linker is generating      relocatable output, this section symbol may be for one of the      input sections rather than the output section.  */
if|if
condition|(
name|asym_ptr
operator|->
name|udata
operator|==
operator|(
name|PTR
operator|)
literal|0
operator|&&
operator|(
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|&&
name|asym_ptr
operator|->
name|section
condition|)
block|{
name|int
name|indx
decl_stmt|;
if|if
condition|(
name|asym_ptr
operator|->
name|section
operator|->
name|output_section
operator|!=
name|NULL
condition|)
name|indx
operator|=
name|asym_ptr
operator|->
name|section
operator|->
name|output_section
operator|->
name|index
expr_stmt|;
else|else
name|indx
operator|=
name|asym_ptr
operator|->
name|section
operator|->
name|index
expr_stmt|;
if|if
condition|(
name|elf_section_syms
argument_list|(
name|abfd
argument_list|)
index|[
name|indx
index|]
condition|)
name|asym_ptr
operator|->
name|udata
operator|=
name|elf_section_syms
argument_list|(
name|abfd
argument_list|)
index|[
name|indx
index|]
operator|->
name|udata
expr_stmt|;
block|}
if|if
condition|(
name|asym_ptr
operator|->
name|udata
condition|)
name|idx
operator|=
operator|(
operator|(
name|Elf_Sym_Extra
operator|*
operator|)
name|asym_ptr
operator|->
name|udata
operator|)
operator|->
name|elf_sym_num
expr_stmt|;
else|else
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
if|#
directive|if
name|DEBUG
operator|&
literal|4
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"elf_symbol_from_bfd_symbol 0x%.8lx, name = %s, sym num = %d, flags = 0x%.8lx %s\n"
argument_list|,
operator|(
name|long
operator|)
name|asym_ptr
argument_list|,
name|asym_ptr
operator|->
name|name
argument_list|,
name|idx
argument_list|,
name|flags
argument_list|,
name|elf_symbol_flags
argument_list|(
name|flags
argument_list|)
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|idx
return|;
block|}
end_function

begin_function
specifier|static
name|long
name|elf_slurp_symbol_table
parameter_list|(
name|abfd
parameter_list|,
name|symptrs
parameter_list|,
name|dynamic
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symptrs
decl_stmt|;
comment|/* Buffer for generated bfd symbols */
name|boolean
name|dynamic
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
name|long
name|symcount
decl_stmt|;
comment|/* Number of external ELF symbols */
name|elf_symbol_type
modifier|*
name|sym
decl_stmt|;
comment|/* Pointer to current bfd symbol */
name|elf_symbol_type
modifier|*
name|symbase
decl_stmt|;
comment|/* Buffer for generated bfd symbols */
name|Elf_Internal_Sym
name|i_sym
decl_stmt|;
name|Elf_External_Sym
modifier|*
name|x_symp
init|=
name|NULL
decl_stmt|;
comment|/* Read each raw ELF symbol, converting from external ELF form to      internal ELF form, and then using the information to create a      canonical bfd symbol table entry.       Note that we allocate the initial bfd canonical symbol buffer      based on a one-to-one mapping of the ELF symbols to canonical      symbols.  We actually use all the ELF symbols, so there will be no      space left over at the end.  When we have all the symbols, we      build the caller's pointer vector. */
if|if
condition|(
name|dynamic
condition|)
name|hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|dynsymtab_hdr
expr_stmt|;
else|else
name|hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|sh_offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|symcount
operator|=
name|hdr
operator|->
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|symcount
operator|==
literal|0
condition|)
name|sym
operator|=
name|symbase
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|long
name|i
decl_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|sh_offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|symbase
operator|=
operator|(
operator|(
name|elf_symbol_type
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|symcount
operator|*
sizeof|sizeof
argument_list|(
name|elf_symbol_type
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|symbase
operator|==
operator|(
name|elf_symbol_type
operator|*
operator|)
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|sym
operator|=
name|symbase
expr_stmt|;
comment|/* Temporarily allocate room for the raw ELF symbols.  */
name|x_symp
operator|=
operator|(
operator|(
name|Elf_External_Sym
operator|*
operator|)
name|malloc
argument_list|(
name|symcount
operator|*
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|x_symp
operator|==
name|NULL
operator|&&
name|symcount
operator|!=
literal|0
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|x_symp
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
argument_list|,
name|symcount
argument_list|,
name|abfd
argument_list|)
operator|!=
name|symcount
operator|*
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* Skip first symbol, which is a null dummy.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|symcount
condition|;
name|i
operator|++
control|)
block|{
name|elf_swap_symbol_in
argument_list|(
name|abfd
argument_list|,
name|x_symp
operator|+
name|i
argument_list|,
operator|&
name|i_sym
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|sym
operator|->
name|internal_elf_sym
argument_list|,
operator|&
name|i_sym
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf_Internal_Sym
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ELF_KEEP_EXTSYM
name|memcpy
argument_list|(
operator|&
name|sym
operator|->
name|native_elf_sym
argument_list|,
name|x_symp
operator|+
name|i
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sym
operator|->
name|symbol
operator|.
name|the_bfd
operator|=
name|abfd
expr_stmt|;
name|sym
operator|->
name|symbol
operator|.
name|name
operator|=
name|elf_string_from_elf_section
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|sh_link
argument_list|,
name|i_sym
operator|.
name|st_name
argument_list|)
expr_stmt|;
name|sym
operator|->
name|symbol
operator|.
name|value
operator|=
name|i_sym
operator|.
name|st_value
expr_stmt|;
if|if
condition|(
name|i_sym
operator|.
name|st_shndx
operator|>
literal|0
operator|&&
name|i_sym
operator|.
name|st_shndx
operator|<
name|SHN_LORESERVE
condition|)
block|{
name|sym
operator|->
name|symbol
operator|.
name|section
operator|=
name|section_from_elf_index
argument_list|(
name|abfd
argument_list|,
name|i_sym
operator|.
name|st_shndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|->
name|symbol
operator|.
name|section
operator|==
name|NULL
condition|)
block|{
comment|/* This symbol is in a section for which we did not 		     create a BFD section.  Just use bfd_abs_section, 		     although it is wrong.  FIXME.  */
name|sym
operator|->
name|symbol
operator|.
name|section
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|i_sym
operator|.
name|st_shndx
operator|==
name|SHN_ABS
condition|)
block|{
name|sym
operator|->
name|symbol
operator|.
name|section
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i_sym
operator|.
name|st_shndx
operator|==
name|SHN_COMMON
condition|)
block|{
name|sym
operator|->
name|symbol
operator|.
name|section
operator|=
name|bfd_com_section_ptr
expr_stmt|;
comment|/* Elf puts the alignment into the `value' field, and 		 the size into the `size' field.  BFD wants to see the 		 size in the value field, and doesn't care (at the 		 moment) about the alignment.  */
name|sym
operator|->
name|symbol
operator|.
name|value
operator|=
name|i_sym
operator|.
name|st_size
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i_sym
operator|.
name|st_shndx
operator|==
name|SHN_UNDEF
condition|)
block|{
name|sym
operator|->
name|symbol
operator|.
name|section
operator|=
name|bfd_und_section_ptr
expr_stmt|;
block|}
else|else
name|sym
operator|->
name|symbol
operator|.
name|section
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
name|sym
operator|->
name|symbol
operator|.
name|value
operator|-=
name|sym
operator|->
name|symbol
operator|.
name|section
operator|->
name|vma
expr_stmt|;
switch|switch
condition|(
name|ELF_ST_BIND
argument_list|(
name|i_sym
operator|.
name|st_info
argument_list|)
condition|)
block|{
case|case
name|STB_LOCAL
case|:
name|sym
operator|->
name|symbol
operator|.
name|flags
operator||=
name|BSF_LOCAL
expr_stmt|;
break|break;
case|case
name|STB_GLOBAL
case|:
name|sym
operator|->
name|symbol
operator|.
name|flags
operator||=
name|BSF_GLOBAL
expr_stmt|;
break|break;
case|case
name|STB_WEAK
case|:
name|sym
operator|->
name|symbol
operator|.
name|flags
operator||=
name|BSF_WEAK
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|ELF_ST_TYPE
argument_list|(
name|i_sym
operator|.
name|st_info
argument_list|)
condition|)
block|{
case|case
name|STT_SECTION
case|:
name|sym
operator|->
name|symbol
operator|.
name|flags
operator||=
name|BSF_SECTION_SYM
operator||
name|BSF_DEBUGGING
expr_stmt|;
break|break;
case|case
name|STT_FILE
case|:
name|sym
operator|->
name|symbol
operator|.
name|flags
operator||=
name|BSF_FILE
operator||
name|BSF_DEBUGGING
expr_stmt|;
break|break;
case|case
name|STT_FUNC
case|:
name|sym
operator|->
name|symbol
operator|.
name|flags
operator||=
name|BSF_FUNCTION
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|dynamic
condition|)
name|sym
operator|->
name|symbol
operator|.
name|flags
operator||=
name|BSF_DYNAMIC
expr_stmt|;
comment|/* Do some backend-specific processing on this symbol.  */
block|{
name|struct
name|elf_backend_data
modifier|*
name|ebd
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
if|if
condition|(
name|ebd
operator|->
name|elf_backend_symbol_processing
condition|)
call|(
modifier|*
name|ebd
operator|->
name|elf_backend_symbol_processing
call|)
argument_list|(
name|abfd
argument_list|,
operator|&
name|sym
operator|->
name|symbol
argument_list|)
expr_stmt|;
block|}
name|sym
operator|++
expr_stmt|;
block|}
block|}
comment|/* Do some backend-specific processing on this symbol table.  */
block|{
name|struct
name|elf_backend_data
modifier|*
name|ebd
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
if|if
condition|(
name|ebd
operator|->
name|elf_backend_symbol_table_processing
condition|)
call|(
modifier|*
name|ebd
operator|->
name|elf_backend_symbol_table_processing
call|)
argument_list|(
name|abfd
argument_list|,
name|symbase
argument_list|,
name|symcount
argument_list|)
expr_stmt|;
block|}
comment|/* We rely on the zalloc to clear out the final symbol entry.  */
name|symcount
operator|=
name|sym
operator|-
name|symbase
expr_stmt|;
comment|/* Fill in the user's symbol pointer vector if needed.  */
if|if
condition|(
name|symptrs
condition|)
block|{
name|long
name|l
init|=
name|symcount
decl_stmt|;
name|sym
operator|=
name|symbase
expr_stmt|;
while|while
condition|(
name|l
operator|--
operator|>
literal|0
condition|)
block|{
operator|*
name|symptrs
operator|++
operator|=
operator|&
name|sym
operator|->
name|symbol
expr_stmt|;
name|sym
operator|++
expr_stmt|;
block|}
operator|*
name|symptrs
operator|=
literal|0
expr_stmt|;
comment|/* Final null pointer */
block|}
if|if
condition|(
name|x_symp
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|x_symp
argument_list|)
expr_stmt|;
return|return
name|symcount
return|;
name|error_return
label|:
if|if
condition|(
name|x_symp
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|x_symp
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return the number of bytes required to hold the symtab vector.     Note that we base it on the count plus 1, since we will null terminate    the vector allocated based on this size.  However, the ELF symbol table    always has a dummy entry as symbol #0, so it ends up even.  */
end_comment

begin_function
name|long
name|elf_get_symtab_upper_bound
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|long
name|symcount
decl_stmt|;
name|long
name|symtab_size
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|hdr
init|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
decl_stmt|;
name|symcount
operator|=
name|hdr
operator|->
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
expr_stmt|;
name|symtab_size
operator|=
operator|(
name|symcount
operator|-
literal|1
operator|+
literal|1
operator|)
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
operator|)
expr_stmt|;
return|return
name|symtab_size
return|;
block|}
end_function

begin_function
name|long
name|elf_get_dynamic_symtab_upper_bound
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|long
name|symcount
decl_stmt|;
name|long
name|symtab_size
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|hdr
init|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|dynsymtab_hdr
decl_stmt|;
if|if
condition|(
name|elf_dynsymtab
argument_list|(
name|abfd
argument_list|)
operator|==
literal|0
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|symcount
operator|=
name|hdr
operator|->
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
expr_stmt|;
name|symtab_size
operator|=
operator|(
name|symcount
operator|-
literal|1
operator|+
literal|1
operator|)
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
operator|)
expr_stmt|;
return|return
name|symtab_size
return|;
block|}
end_function

begin_function
name|long
name|elf_get_reloc_upper_bound
parameter_list|(
name|abfd
parameter_list|,
name|asect
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|sec_ptr
name|asect
decl_stmt|;
block|{
return|return
operator|(
name|asect
operator|->
name|reloc_count
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|arelent
operator|*
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Read in and swap the external relocs.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf_slurp_reloc_table
parameter_list|(
name|abfd
parameter_list|,
name|asect
parameter_list|,
name|symbols
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|asect
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
block|{
name|struct
name|elf_backend_data
modifier|*
specifier|const
name|ebd
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|struct
name|bfd_elf_section_data
modifier|*
specifier|const
name|d
init|=
name|elf_section_data
argument_list|(
name|asect
argument_list|)
decl_stmt|;
name|PTR
name|allocated
init|=
name|NULL
decl_stmt|;
name|bfd_byte
modifier|*
name|native_relocs
decl_stmt|;
name|arelent
modifier|*
name|relents
decl_stmt|;
name|arelent
modifier|*
name|relent
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|int
name|entsize
decl_stmt|;
if|if
condition|(
name|asect
operator|->
name|relocation
operator|!=
name|NULL
condition|)
return|return
name|true
return|;
name|BFD_ASSERT
argument_list|(
name|asect
operator|->
name|rel_filepos
operator|==
name|d
operator|->
name|rel_hdr
operator|.
name|sh_offset
operator|&&
operator|(
name|asect
operator|->
name|reloc_count
operator|==
name|d
operator|->
name|rel_hdr
operator|.
name|sh_size
operator|/
name|d
operator|->
name|rel_hdr
operator|.
name|sh_entsize
operator|)
argument_list|)
expr_stmt|;
name|native_relocs
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|elf_section_data
argument_list|(
name|asect
argument_list|)
operator|->
name|relocs
expr_stmt|;
if|if
condition|(
name|native_relocs
operator|==
name|NULL
condition|)
block|{
name|allocated
operator|=
operator|(
name|PTR
operator|)
name|malloc
argument_list|(
name|d
operator|->
name|rel_hdr
operator|.
name|sh_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|allocated
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|asect
operator|->
name|rel_filepos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|bfd_read
argument_list|(
name|allocated
argument_list|,
literal|1
argument_list|,
name|d
operator|->
name|rel_hdr
operator|.
name|sh_size
argument_list|,
name|abfd
argument_list|)
operator|!=
name|d
operator|->
name|rel_hdr
operator|.
name|sh_size
operator|)
condition|)
goto|goto
name|error_return
goto|;
name|native_relocs
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|allocated
expr_stmt|;
block|}
name|relents
operator|=
operator|(
operator|(
name|arelent
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|asect
operator|->
name|reloc_count
operator|*
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|relents
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
name|entsize
operator|=
name|d
operator|->
name|rel_hdr
operator|.
name|sh_entsize
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|entsize
operator|==
sizeof|sizeof
argument_list|(
name|Elf_External_Rel
argument_list|)
operator|||
name|entsize
operator|==
sizeof|sizeof
argument_list|(
name|Elf_External_Rela
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|relent
operator|=
name|relents
init|;
name|i
operator|<
name|asect
operator|->
name|reloc_count
condition|;
name|i
operator|++
operator|,
name|relent
operator|++
operator|,
name|native_relocs
operator|+=
name|entsize
control|)
block|{
name|Elf_Internal_Rela
name|rela
decl_stmt|;
name|Elf_Internal_Rel
name|rel
decl_stmt|;
if|if
condition|(
name|entsize
operator|==
sizeof|sizeof
argument_list|(
name|Elf_External_Rela
argument_list|)
condition|)
name|elf_swap_reloca_in
argument_list|(
name|abfd
argument_list|,
operator|(
name|Elf_External_Rela
operator|*
operator|)
name|native_relocs
argument_list|,
operator|&
name|rela
argument_list|)
expr_stmt|;
else|else
block|{
name|elf_swap_reloc_in
argument_list|(
name|abfd
argument_list|,
operator|(
name|Elf_External_Rel
operator|*
operator|)
name|native_relocs
argument_list|,
operator|&
name|rel
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_offset
operator|=
name|rel
operator|.
name|r_offset
expr_stmt|;
name|rela
operator|.
name|r_info
operator|=
name|rel
operator|.
name|r_info
expr_stmt|;
name|rela
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
block|}
comment|/* The address of an ELF reloc is section relative for an object 	 file, and absolute for an executable file or shared library. 	 The address of a BFD reloc is always section relative.  */
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
operator|(
name|EXEC_P
operator||
name|DYNAMIC
operator|)
operator|)
operator|==
literal|0
condition|)
name|relent
operator|->
name|address
operator|=
name|rela
operator|.
name|r_offset
expr_stmt|;
else|else
name|relent
operator|->
name|address
operator|=
name|rela
operator|.
name|r_offset
operator|-
name|asect
operator|->
name|vma
expr_stmt|;
if|if
condition|(
name|ELF_R_SYM
argument_list|(
name|rela
operator|.
name|r_info
argument_list|)
operator|==
literal|0
condition|)
name|relent
operator|->
name|sym_ptr_ptr
operator|=
name|bfd_abs_section_ptr
operator|->
name|symbol_ptr_ptr
expr_stmt|;
else|else
block|{
name|asymbol
modifier|*
modifier|*
name|ps
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|ps
operator|=
name|symbols
operator|+
name|ELF_R_SYM
argument_list|(
name|rela
operator|.
name|r_info
argument_list|)
operator|-
literal|1
expr_stmt|;
name|s
operator|=
operator|*
name|ps
expr_stmt|;
comment|/* Canonicalize ELF section symbols.  FIXME: Why?  */
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|==
literal|0
condition|)
name|relent
operator|->
name|sym_ptr_ptr
operator|=
name|ps
expr_stmt|;
else|else
name|relent
operator|->
name|sym_ptr_ptr
operator|=
name|s
operator|->
name|section
operator|->
name|symbol_ptr_ptr
expr_stmt|;
block|}
name|relent
operator|->
name|addend
operator|=
name|rela
operator|.
name|r_addend
expr_stmt|;
if|if
condition|(
name|entsize
operator|==
sizeof|sizeof
argument_list|(
name|Elf_External_Rela
argument_list|)
condition|)
call|(
modifier|*
name|ebd
operator|->
name|elf_info_to_howto
call|)
argument_list|(
name|abfd
argument_list|,
name|relent
argument_list|,
operator|&
name|rela
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|ebd
operator|->
name|elf_info_to_howto_rel
call|)
argument_list|(
name|abfd
argument_list|,
name|relent
argument_list|,
operator|&
name|rel
argument_list|)
expr_stmt|;
block|}
name|asect
operator|->
name|relocation
operator|=
name|relents
expr_stmt|;
if|if
condition|(
name|allocated
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|allocated
argument_list|)
expr_stmt|;
return|return
name|true
return|;
name|error_return
label|:
if|if
condition|(
name|allocated
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|allocated
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function
specifier|static
name|void
name|elf_debug_section
parameter_list|(
name|str
parameter_list|,
name|num
parameter_list|,
name|hdr
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|num
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nSection#%d '%s' 0x%.8lx\n"
argument_list|,
name|num
argument_list|,
name|str
argument_list|,
operator|(
name|long
operator|)
name|hdr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"sh_name      = %ld\tsh_type      = %ld\tsh_flags     = %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|hdr
operator|->
name|sh_name
argument_list|,
operator|(
name|long
operator|)
name|hdr
operator|->
name|sh_type
argument_list|,
operator|(
name|long
operator|)
name|hdr
operator|->
name|sh_flags
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"sh_addr      = %ld\tsh_offset    = %ld\tsh_size      = %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|hdr
operator|->
name|sh_addr
argument_list|,
operator|(
name|long
operator|)
name|hdr
operator|->
name|sh_offset
argument_list|,
operator|(
name|long
operator|)
name|hdr
operator|->
name|sh_size
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"sh_link      = %ld\tsh_info      = %ld\tsh_addralign = %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|hdr
operator|->
name|sh_link
argument_list|,
operator|(
name|long
operator|)
name|hdr
operator|->
name|sh_info
argument_list|,
operator|(
name|long
operator|)
name|hdr
operator|->
name|sh_addralign
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"sh_entsize   = %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|hdr
operator|->
name|sh_entsize
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"rawdata      = 0x%.8lx\n"
argument_list|,
operator|(
name|long
operator|)
name|hdr
operator|->
name|rawdata
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"contents     = 0x%.8lx\n"
argument_list|,
operator|(
name|long
operator|)
name|hdr
operator|->
name|contents
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"size         = %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|hdr
operator|->
name|size
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|elf_debug_file
parameter_list|(
name|ehdrp
parameter_list|)
name|Elf_Internal_Ehdr
modifier|*
name|ehdrp
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"e_entry      = 0x%.8lx\n"
argument_list|,
operator|(
name|long
operator|)
name|ehdrp
operator|->
name|e_entry
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"e_phoff      = %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|ehdrp
operator|->
name|e_phoff
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"e_phnum      = %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|ehdrp
operator|->
name|e_phnum
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"e_phentsize  = %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|ehdrp
operator|->
name|e_phentsize
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"e_shoff      = %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|ehdrp
operator|->
name|e_shoff
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"e_shnum      = %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|ehdrp
operator|->
name|e_shnum
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"e_shentsize  = %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|ehdrp
operator|->
name|e_shentsize
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Canonicalize the relocs.  */
end_comment

begin_function
name|long
name|elf_canonicalize_reloc
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|relptr
parameter_list|,
name|symbols
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|sec_ptr
name|section
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|relptr
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
block|{
name|arelent
modifier|*
name|tblptr
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|elf_slurp_reloc_table
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|symbols
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|tblptr
operator|=
name|section
operator|->
name|relocation
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|section
operator|->
name|reloc_count
condition|;
name|i
operator|++
control|)
operator|*
name|relptr
operator|++
operator|=
name|tblptr
operator|++
expr_stmt|;
operator|*
name|relptr
operator|=
name|NULL
expr_stmt|;
return|return
name|section
operator|->
name|reloc_count
return|;
block|}
end_function

begin_function
name|long
name|elf_get_symtab
parameter_list|(
name|abfd
parameter_list|,
name|alocation
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|alocation
decl_stmt|;
block|{
name|long
name|symcount
init|=
name|elf_slurp_symbol_table
argument_list|(
name|abfd
argument_list|,
name|alocation
argument_list|,
name|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|symcount
operator|>=
literal|0
condition|)
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|=
name|symcount
expr_stmt|;
return|return
name|symcount
return|;
block|}
end_function

begin_function
name|long
name|elf_canonicalize_dynamic_symtab
parameter_list|(
name|abfd
parameter_list|,
name|alocation
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|alocation
decl_stmt|;
block|{
return|return
name|elf_slurp_symbol_table
argument_list|(
name|abfd
argument_list|,
name|alocation
argument_list|,
name|true
argument_list|)
return|;
block|}
end_function

begin_function
name|asymbol
modifier|*
name|elf_make_empty_symbol
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|elf_symbol_type
modifier|*
name|newsym
decl_stmt|;
name|newsym
operator|=
operator|(
name|elf_symbol_type
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|elf_symbol_type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|newsym
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
else|else
block|{
name|newsym
operator|->
name|symbol
operator|.
name|the_bfd
operator|=
name|abfd
expr_stmt|;
return|return
operator|&
name|newsym
operator|->
name|symbol
return|;
block|}
block|}
end_function

begin_function
name|void
name|elf_get_symbol_info
parameter_list|(
name|ignore_abfd
parameter_list|,
name|symbol
parameter_list|,
name|ret
parameter_list|)
name|bfd
modifier|*
name|ignore_abfd
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|symbol_info
modifier|*
name|ret
decl_stmt|;
block|{
name|bfd_symbol_info
argument_list|(
name|symbol
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|elf_print_symbol
parameter_list|(
name|ignore_abfd
parameter_list|,
name|filep
parameter_list|,
name|symbol
parameter_list|,
name|how
parameter_list|)
name|bfd
modifier|*
name|ignore_abfd
decl_stmt|;
name|PTR
name|filep
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|bfd_print_symbol_type
name|how
decl_stmt|;
block|{
name|FILE
modifier|*
name|file
init|=
operator|(
name|FILE
operator|*
operator|)
name|filep
decl_stmt|;
switch|switch
condition|(
name|how
condition|)
block|{
case|case
name|bfd_print_symbol_name
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|symbol
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_print_symbol_more
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"elf "
argument_list|)
expr_stmt|;
name|fprintf_vma
argument_list|(
name|file
argument_list|,
name|symbol
operator|->
name|value
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %lx"
argument_list|,
operator|(
name|long
operator|)
name|symbol
operator|->
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_print_symbol_all
case|:
block|{
name|CONST
name|char
modifier|*
name|section_name
decl_stmt|;
name|section_name
operator|=
name|symbol
operator|->
name|section
condition|?
name|symbol
operator|->
name|section
operator|->
name|name
else|:
literal|"(*none*)"
expr_stmt|;
name|bfd_print_symbol_vandf
argument_list|(
operator|(
name|PTR
operator|)
name|file
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %s\t%s"
argument_list|,
name|section_name
argument_list|,
name|symbol
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

begin_function
name|alent
modifier|*
name|elf_get_lineno
parameter_list|(
name|ignore_abfd
parameter_list|,
name|symbol
parameter_list|)
name|bfd
modifier|*
name|ignore_abfd
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"elf_get_lineno unimplemented\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|BFD_FAIL
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|boolean
name|elf_set_arch_mach
parameter_list|(
name|abfd
parameter_list|,
name|arch
parameter_list|,
name|machine
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|enum
name|bfd_architecture
name|arch
decl_stmt|;
name|unsigned
name|long
name|machine
decl_stmt|;
block|{
comment|/* If this isn't the right architecture for this backend, and this      isn't the generic backend, fail.  */
if|if
condition|(
name|arch
operator|!=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|arch
operator|&&
name|arch
operator|!=
name|bfd_arch_unknown
operator|&&
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|arch
operator|!=
name|bfd_arch_unknown
condition|)
return|return
name|false
return|;
return|return
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|arch
argument_list|,
name|machine
argument_list|)
return|;
block|}
end_function

begin_function
name|boolean
name|elf_find_nearest_line
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|symbols
parameter_list|,
name|offset
parameter_list|,
name|filename_ptr
parameter_list|,
name|functionname_ptr
parameter_list|,
name|line_ptr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
name|CONST
name|char
modifier|*
modifier|*
name|filename_ptr
decl_stmt|;
name|CONST
name|char
modifier|*
modifier|*
name|functionname_ptr
decl_stmt|;
name|unsigned
name|int
modifier|*
name|line_ptr
decl_stmt|;
block|{
return|return
name|false
return|;
block|}
end_function

begin_function
name|int
name|elf_sizeof_headers
parameter_list|(
name|abfd
parameter_list|,
name|reloc
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|boolean
name|reloc
decl_stmt|;
block|{
name|int
name|ret
decl_stmt|;
name|ret
operator|=
sizeof|sizeof
argument_list|(
name|Elf_External_Ehdr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reloc
condition|)
name|ret
operator|+=
name|get_program_header_size
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|boolean
name|elf_set_section_contents
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|location
parameter_list|,
name|offset
parameter_list|,
name|count
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|sec_ptr
name|section
decl_stmt|;
name|PTR
name|location
decl_stmt|;
name|file_ptr
name|offset
decl_stmt|;
name|bfd_size_type
name|count
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
if|if
condition|(
operator|!
name|abfd
operator|->
name|output_has_begun
operator|&&
operator|!
name|elf_compute_section_file_positions
argument_list|(
name|abfd
argument_list|,
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|)
name|NULL
argument_list|)
condition|)
return|return
name|false
return|;
name|hdr
operator|=
operator|&
name|elf_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|this_hdr
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|sh_offset
operator|+
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
name|false
return|;
if|if
condition|(
name|bfd_write
argument_list|(
name|location
argument_list|,
literal|1
argument_list|,
name|count
argument_list|,
name|abfd
argument_list|)
operator|!=
name|count
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_function
name|void
name|elf_no_info_to_howto
parameter_list|(
name|abfd
parameter_list|,
name|cache_ptr
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|cache_ptr
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|dst
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"elf RELA relocation support for target machine unimplemented\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|BFD_FAIL
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|elf_no_info_to_howto_rel
parameter_list|(
name|abfd
parameter_list|,
name|cache_ptr
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|cache_ptr
decl_stmt|;
name|Elf_Internal_Rel
modifier|*
name|dst
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"elf REL relocation support for target machine unimplemented\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|BFD_FAIL
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Core file support */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PROCFS
end_ifdef

begin_comment
comment|/* Some core file support requires host /proc files */
end_comment

begin_include
include|#
directive|include
file|<sys/procfs.h>
end_include

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|bfd_prstatus
parameter_list|(
name|abfd
parameter_list|,
name|descdata
parameter_list|,
name|descsz
parameter_list|,
name|filepos
parameter_list|)
value|true
end_define

begin_define
define|#
directive|define
name|bfd_fpregset
parameter_list|(
name|abfd
parameter_list|,
name|descdata
parameter_list|,
name|descsz
parameter_list|,
name|filepos
parameter_list|)
value|true
end_define

begin_define
define|#
directive|define
name|bfd_prpsinfo
parameter_list|(
name|abfd
parameter_list|,
name|descdata
parameter_list|,
name|descsz
parameter_list|,
name|filepos
parameter_list|)
value|true
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PROCFS
end_ifdef

begin_function
specifier|static
name|boolean
name|bfd_prstatus
parameter_list|(
name|abfd
parameter_list|,
name|descdata
parameter_list|,
name|descsz
parameter_list|,
name|filepos
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|char
modifier|*
name|descdata
decl_stmt|;
name|int
name|descsz
decl_stmt|;
name|long
name|filepos
decl_stmt|;
block|{
name|asection
modifier|*
name|newsect
decl_stmt|;
name|prstatus_t
modifier|*
name|status
init|=
operator|(
name|prstatus_t
operator|*
operator|)
literal|0
decl_stmt|;
if|if
condition|(
name|descsz
operator|==
sizeof|sizeof
argument_list|(
name|prstatus_t
argument_list|)
condition|)
block|{
name|newsect
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".reg"
argument_list|)
expr_stmt|;
if|if
condition|(
name|newsect
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|newsect
operator|->
name|_raw_size
operator|=
sizeof|sizeof
argument_list|(
name|status
operator|->
name|pr_reg
argument_list|)
expr_stmt|;
name|newsect
operator|->
name|filepos
operator|=
name|filepos
operator|+
operator|(
name|long
operator|)
operator|&
name|status
operator|->
name|pr_reg
expr_stmt|;
name|newsect
operator|->
name|flags
operator|=
name|SEC_HAS_CONTENTS
expr_stmt|;
name|newsect
operator|->
name|alignment_power
operator|=
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|core_prstatus
argument_list|(
name|abfd
argument_list|)
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|descsz
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|memcpy
argument_list|(
name|core_prstatus
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|descdata
argument_list|,
name|descsz
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Stash a copy of the prpsinfo structure away for future use. */
end_comment

begin_function
specifier|static
name|boolean
name|bfd_prpsinfo
parameter_list|(
name|abfd
parameter_list|,
name|descdata
parameter_list|,
name|descsz
parameter_list|,
name|filepos
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|char
modifier|*
name|descdata
decl_stmt|;
name|int
name|descsz
decl_stmt|;
name|long
name|filepos
decl_stmt|;
block|{
if|if
condition|(
name|descsz
operator|==
sizeof|sizeof
argument_list|(
name|prpsinfo_t
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|core_prpsinfo
argument_list|(
name|abfd
argument_list|)
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|descsz
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|memcpy
argument_list|(
name|core_prpsinfo
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|descdata
argument_list|,
name|descsz
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|bfd_fpregset
parameter_list|(
name|abfd
parameter_list|,
name|descdata
parameter_list|,
name|descsz
parameter_list|,
name|filepos
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|char
modifier|*
name|descdata
decl_stmt|;
name|int
name|descsz
decl_stmt|;
name|long
name|filepos
decl_stmt|;
block|{
name|asection
modifier|*
name|newsect
decl_stmt|;
name|newsect
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".reg2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|newsect
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|newsect
operator|->
name|_raw_size
operator|=
name|descsz
expr_stmt|;
name|newsect
operator|->
name|filepos
operator|=
name|filepos
expr_stmt|;
name|newsect
operator|->
name|flags
operator|=
name|SEC_HAS_CONTENTS
expr_stmt|;
name|newsect
operator|->
name|alignment_power
operator|=
literal|2
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_PROCFS */
end_comment

begin_comment
comment|/* Return a pointer to the args (including the command name) that were    seen by the program that generated the core dump.  Note that for    some reason, a spurious space is tacked onto the end of the args    in some (at least one anyway) implementations, so strip it off if    it exists. */
end_comment

begin_function
name|char
modifier|*
name|elf_core_file_failing_command
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|HAVE_PROCFS
if|if
condition|(
name|core_prpsinfo
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
name|prpsinfo_t
modifier|*
name|p
init|=
name|core_prpsinfo
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|char
modifier|*
name|scan
init|=
name|p
operator|->
name|pr_psargs
decl_stmt|;
while|while
condition|(
operator|*
name|scan
operator|++
condition|)
block|{
empty_stmt|;
block|}
name|scan
operator|-=
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|scan
operator|>
name|p
operator|->
name|pr_psargs
operator|)
operator|&&
operator|(
operator|*
name|scan
operator|==
literal|' '
operator|)
condition|)
block|{
operator|*
name|scan
operator|=
literal|'\000'
expr_stmt|;
block|}
return|return
name|p
operator|->
name|pr_psargs
return|;
block|}
endif|#
directive|endif
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return the number of the signal that caused the core dump.  Presumably,    since we have a core file, we got a signal of some kind, so don't bother    checking the other process status fields, just return the signal number.    */
end_comment

begin_function
name|int
name|elf_core_file_failing_signal
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|HAVE_PROCFS
if|if
condition|(
name|core_prstatus
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
return|return
operator|(
operator|(
name|prstatus_t
operator|*
operator|)
operator|(
name|core_prstatus
argument_list|(
name|abfd
argument_list|)
operator|)
operator|)
operator|->
name|pr_cursig
return|;
block|}
endif|#
directive|endif
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Check to see if the core file could reasonably be expected to have    come for the current executable file.  Note that by default we return    true unless we find something that indicates that there might be a    problem.    */
end_comment

begin_function
name|boolean
name|elf_core_file_matches_executable_p
parameter_list|(
name|core_bfd
parameter_list|,
name|exec_bfd
parameter_list|)
name|bfd
modifier|*
name|core_bfd
decl_stmt|;
name|bfd
modifier|*
name|exec_bfd
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|HAVE_PROCFS
name|char
modifier|*
name|corename
decl_stmt|;
name|char
modifier|*
name|execname
decl_stmt|;
endif|#
directive|endif
comment|/* First, xvecs must match since both are ELF files for the same target. */
if|if
condition|(
name|core_bfd
operator|->
name|xvec
operator|!=
name|exec_bfd
operator|->
name|xvec
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_system_call
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
ifdef|#
directive|ifdef
name|HAVE_PROCFS
comment|/* If no prpsinfo, just return true.  Otherwise, grab the last component      of the exec'd pathname from the prpsinfo. */
if|if
condition|(
name|core_prpsinfo
argument_list|(
name|core_bfd
argument_list|)
condition|)
block|{
name|corename
operator|=
operator|(
operator|(
operator|(
expr|struct
name|prpsinfo
operator|*
operator|)
name|core_prpsinfo
argument_list|(
name|core_bfd
argument_list|)
operator|)
operator|->
name|pr_fname
operator|)
expr_stmt|;
block|}
else|else
block|{
return|return
name|true
return|;
block|}
comment|/* Find the last component of the executable pathname. */
if|if
condition|(
operator|(
name|execname
operator|=
name|strrchr
argument_list|(
name|exec_bfd
operator|->
name|filename
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|execname
operator|++
expr_stmt|;
block|}
else|else
block|{
name|execname
operator|=
operator|(
name|char
operator|*
operator|)
name|exec_bfd
operator|->
name|filename
expr_stmt|;
block|}
comment|/* See if they match */
return|return
name|strcmp
argument_list|(
name|execname
argument_list|,
name|corename
argument_list|)
condition|?
name|false
else|:
name|true
return|;
else|#
directive|else
return|return
name|true
return|;
endif|#
directive|endif
comment|/* HAVE_PROCFS */
block|}
end_function

begin_comment
comment|/* ELF core files contain a segment of type PT_NOTE, that holds much of    the information that would normally be available from the /proc interface    for the process, at the time the process dumped core.  Currently this    includes copies of the prstatus, prpsinfo, and fpregset structures.     Since these structures are potentially machine dependent in size and    ordering, bfd provides two levels of support for them.  The first level,    available on all machines since it does not require that the host    have /proc support or the relevant include files, is to create a bfd    section for each of the prstatus, prpsinfo, and fpregset structures,    without any interpretation of their contents.  With just this support,    the bfd client will have to interpret the structures itself.  Even with    /proc support, it might want these full structures for it's own reasons.     In the second level of support, where HAVE_PROCFS is defined, bfd will    pick apart the structures to gather some additional information that    clients may want, such as the general register set, the name of the    exec'ed file and its arguments, the signal (if any) that caused the    core dump, etc.     */
end_comment

begin_function
specifier|static
name|boolean
name|elf_corefile_note
parameter_list|(
name|abfd
parameter_list|,
name|hdr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|Elf_Internal_Phdr
modifier|*
name|hdr
decl_stmt|;
block|{
name|Elf_External_Note
modifier|*
name|x_note_p
decl_stmt|;
comment|/* Elf note, external form */
name|Elf_Internal_Note
name|i_note
decl_stmt|;
comment|/* Elf note, internal form */
name|char
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
comment|/* Entire note segment contents */
name|char
modifier|*
name|namedata
decl_stmt|;
comment|/* Name portion of the note */
name|char
modifier|*
name|descdata
decl_stmt|;
comment|/* Descriptor portion of the note */
name|char
modifier|*
name|sectname
decl_stmt|;
comment|/* Name to use for new section */
name|long
name|filepos
decl_stmt|;
comment|/* File offset to descriptor data */
name|asection
modifier|*
name|newsect
decl_stmt|;
if|if
condition|(
name|hdr
operator|->
name|p_filesz
operator|>
literal|0
operator|&&
operator|(
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|hdr
operator|->
name|p_filesz
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|p_offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
operator|-
literal|1
operator|&&
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|buf
argument_list|,
name|hdr
operator|->
name|p_filesz
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|==
name|hdr
operator|->
name|p_filesz
condition|)
block|{
name|x_note_p
operator|=
operator|(
name|Elf_External_Note
operator|*
operator|)
name|buf
expr_stmt|;
while|while
condition|(
operator|(
name|char
operator|*
operator|)
name|x_note_p
operator|<
operator|(
name|buf
operator|+
name|hdr
operator|->
name|p_filesz
operator|)
condition|)
block|{
name|i_note
operator|.
name|namesz
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|x_note_p
operator|->
name|namesz
argument_list|)
expr_stmt|;
name|i_note
operator|.
name|descsz
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|x_note_p
operator|->
name|descsz
argument_list|)
expr_stmt|;
name|i_note
operator|.
name|type
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|x_note_p
operator|->
name|type
argument_list|)
expr_stmt|;
name|namedata
operator|=
name|x_note_p
operator|->
name|name
expr_stmt|;
name|descdata
operator|=
name|namedata
operator|+
name|BFD_ALIGN
argument_list|(
name|i_note
operator|.
name|namesz
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|filepos
operator|=
name|hdr
operator|->
name|p_offset
operator|+
operator|(
name|descdata
operator|-
name|buf
operator|)
expr_stmt|;
switch|switch
condition|(
name|i_note
operator|.
name|type
condition|)
block|{
case|case
name|NT_PRSTATUS
case|:
comment|/* process descdata as prstatus info */
if|if
condition|(
operator|!
name|bfd_prstatus
argument_list|(
name|abfd
argument_list|,
name|descdata
argument_list|,
name|i_note
operator|.
name|descsz
argument_list|,
name|filepos
argument_list|)
condition|)
return|return
name|false
return|;
name|sectname
operator|=
literal|".prstatus"
expr_stmt|;
break|break;
case|case
name|NT_FPREGSET
case|:
comment|/* process descdata as fpregset info */
if|if
condition|(
operator|!
name|bfd_fpregset
argument_list|(
name|abfd
argument_list|,
name|descdata
argument_list|,
name|i_note
operator|.
name|descsz
argument_list|,
name|filepos
argument_list|)
condition|)
return|return
name|false
return|;
name|sectname
operator|=
literal|".fpregset"
expr_stmt|;
break|break;
case|case
name|NT_PRPSINFO
case|:
comment|/* process descdata as prpsinfo */
if|if
condition|(
operator|!
name|bfd_prpsinfo
argument_list|(
name|abfd
argument_list|,
name|descdata
argument_list|,
name|i_note
operator|.
name|descsz
argument_list|,
name|filepos
argument_list|)
condition|)
return|return
name|false
return|;
name|sectname
operator|=
literal|".prpsinfo"
expr_stmt|;
break|break;
default|default:
comment|/* Unknown descriptor, just ignore it. */
name|sectname
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|sectname
operator|!=
name|NULL
condition|)
block|{
name|newsect
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
name|sectname
argument_list|)
expr_stmt|;
if|if
condition|(
name|newsect
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|newsect
operator|->
name|_raw_size
operator|=
name|i_note
operator|.
name|descsz
expr_stmt|;
name|newsect
operator|->
name|filepos
operator|=
name|filepos
expr_stmt|;
name|newsect
operator|->
name|flags
operator|=
name|SEC_ALLOC
operator||
name|SEC_HAS_CONTENTS
expr_stmt|;
name|newsect
operator|->
name|alignment_power
operator|=
literal|2
expr_stmt|;
block|}
name|x_note_p
operator|=
operator|(
name|Elf_External_Note
operator|*
operator|)
operator|(
name|descdata
operator|+
name|BFD_ALIGN
argument_list|(
name|i_note
operator|.
name|descsz
argument_list|,
literal|4
argument_list|)
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hdr
operator|->
name|p_filesz
operator|>
literal|0
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/*  Core files are simply standard ELF formatted files that partition     the file using the execution view of the file (program header table)     rather than the linking view.  In fact, there is no section header     table in a core file.      The process status information (including the contents of the general     register set) and the floating point register set are stored in a     segment of type PT_NOTE.  We handcraft a couple of extra bfd sections     that allow standard bfd access to the general registers (.reg) and the     floating point registers (.reg2).   */
end_comment

begin_function
specifier|const
name|bfd_target
modifier|*
name|elf_core_file_p
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|Elf_External_Ehdr
name|x_ehdr
decl_stmt|;
comment|/* Elf file header, external form */
name|Elf_Internal_Ehdr
modifier|*
name|i_ehdrp
decl_stmt|;
comment|/* Elf file header, internal form */
name|Elf_External_Phdr
name|x_phdr
decl_stmt|;
comment|/* Program header table entry, external form */
name|Elf_Internal_Phdr
modifier|*
name|i_phdrp
decl_stmt|;
comment|/* Program header table, internal form */
name|unsigned
name|int
name|phindex
decl_stmt|;
name|struct
name|elf_backend_data
modifier|*
name|ebd
decl_stmt|;
comment|/* Read in the ELF header in external format.  */
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|x_ehdr
argument_list|,
sizeof|sizeof
argument_list|(
name|x_ehdr
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|x_ehdr
argument_list|)
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_system_call
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Now check to see if we have a valid ELF file, and one that BFD can      make use of.  The magic number must match, the address size ('class')      and byte-swapping must match our XVEC entry, and it must have a      program header table (FIXME: See comments re segments at top of this      file). */
if|if
condition|(
name|elf_file_p
argument_list|(
operator|&
name|x_ehdr
argument_list|)
operator|==
name|false
condition|)
block|{
name|wrong
label|:
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* FIXME, Check EI_VERSION here !  */
block|{
if|#
directive|if
name|ARCH_SIZE
operator|==
literal|32
name|int
name|desired_address_size
init|=
name|ELFCLASS32
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
name|ARCH_SIZE
operator|==
literal|64
name|int
name|desired_address_size
init|=
name|ELFCLASS64
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|x_ehdr
operator|.
name|e_ident
index|[
name|EI_CLASS
index|]
operator|!=
name|desired_address_size
condition|)
goto|goto
name|wrong
goto|;
block|}
comment|/* Switch xvec to match the specified byte order.  */
switch|switch
condition|(
name|x_ehdr
operator|.
name|e_ident
index|[
name|EI_DATA
index|]
condition|)
block|{
case|case
name|ELFDATA2MSB
case|:
comment|/* Big-endian */
if|if
condition|(
name|abfd
operator|->
name|xvec
operator|->
name|byteorder_big_p
operator|==
name|false
condition|)
goto|goto
name|wrong
goto|;
break|break;
case|case
name|ELFDATA2LSB
case|:
comment|/* Little-endian */
if|if
condition|(
name|abfd
operator|->
name|xvec
operator|->
name|byteorder_big_p
operator|==
name|true
condition|)
goto|goto
name|wrong
goto|;
break|break;
case|case
name|ELFDATANONE
case|:
comment|/* No data encoding specified */
default|default:
comment|/* Unknown data encoding specified */
goto|goto
name|wrong
goto|;
block|}
comment|/* Allocate an instance of the elf_obj_tdata structure and hook it up to      the tdata pointer in the bfd. */
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|=
operator|(
expr|struct
name|elf_obj_tdata
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|elf_obj_tdata
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* FIXME, `wrong' returns from this point onward, leak memory.  */
comment|/* Now that we know the byte order, swap in the rest of the header */
name|i_ehdrp
operator|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|elf_swap_ehdr_in
argument_list|(
name|abfd
argument_list|,
operator|&
name|x_ehdr
argument_list|,
name|i_ehdrp
argument_list|)
expr_stmt|;
if|#
directive|if
name|DEBUG
operator|&
literal|1
name|elf_debug_file
argument_list|(
name|i_ehdrp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ebd
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* Check that the ELF e_machine field matches what this particular      BFD format expects.  */
if|if
condition|(
name|ebd
operator|->
name|elf_machine_code
operator|!=
name|i_ehdrp
operator|->
name|e_machine
condition|)
block|{
specifier|const
name|bfd_target
modifier|*
specifier|const
modifier|*
name|target_ptr
decl_stmt|;
if|if
condition|(
name|ebd
operator|->
name|elf_machine_code
operator|!=
name|EM_NONE
condition|)
goto|goto
name|wrong
goto|;
comment|/* This is the generic ELF target.  Let it match any ELF target 	 for which we do not have a specific backend.  */
for|for
control|(
name|target_ptr
operator|=
name|bfd_target_vector
init|;
operator|*
name|target_ptr
operator|!=
name|NULL
condition|;
name|target_ptr
operator|++
control|)
block|{
name|struct
name|elf_backend_data
modifier|*
name|back
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|target_ptr
operator|)
operator|->
name|flavour
operator|!=
name|bfd_target_elf_flavour
condition|)
continue|continue;
name|back
operator|=
operator|(
expr|struct
name|elf_backend_data
operator|*
operator|)
operator|(
operator|*
name|target_ptr
operator|)
operator|->
name|backend_data
expr_stmt|;
if|if
condition|(
name|back
operator|->
name|elf_machine_code
operator|==
name|i_ehdrp
operator|->
name|e_machine
condition|)
block|{
comment|/* target_ptr is an ELF backend which matches this 		 object file, so reject the generic ELF target.  */
goto|goto
name|wrong
goto|;
block|}
block|}
block|}
comment|/* If there is no program header, or the type is not a core file, then      we are hosed. */
if|if
condition|(
name|i_ehdrp
operator|->
name|e_phoff
operator|==
literal|0
operator|||
name|i_ehdrp
operator|->
name|e_type
operator|!=
name|ET_CORE
condition|)
goto|goto
name|wrong
goto|;
comment|/* Allocate space for a copy of the program header table in      internal form, seek to the program header table in the file,      read it in, and convert it to internal form.  As a simple sanity      check, verify that the what BFD thinks is the size of each program      header table entry actually matches the size recorded in the file. */
if|if
condition|(
name|i_ehdrp
operator|->
name|e_phentsize
operator|!=
sizeof|sizeof
argument_list|(
name|x_phdr
argument_list|)
condition|)
goto|goto
name|wrong
goto|;
name|i_phdrp
operator|=
operator|(
name|Elf_Internal_Phdr
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|i_phdrp
argument_list|)
operator|*
name|i_ehdrp
operator|->
name|e_phnum
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|i_phdrp
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|i_ehdrp
operator|->
name|e_phoff
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|phindex
operator|=
literal|0
init|;
name|phindex
operator|<
name|i_ehdrp
operator|->
name|e_phnum
condition|;
name|phindex
operator|++
control|)
block|{
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|x_phdr
argument_list|,
sizeof|sizeof
argument_list|(
name|x_phdr
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|x_phdr
argument_list|)
condition|)
return|return
name|NULL
return|;
name|elf_swap_phdr_in
argument_list|(
name|abfd
argument_list|,
operator|&
name|x_phdr
argument_list|,
name|i_phdrp
operator|+
name|phindex
argument_list|)
expr_stmt|;
block|}
comment|/* Once all of the program headers have been read and converted, we      can start processing them. */
for|for
control|(
name|phindex
operator|=
literal|0
init|;
name|phindex
operator|<
name|i_ehdrp
operator|->
name|e_phnum
condition|;
name|phindex
operator|++
control|)
block|{
name|bfd_section_from_phdr
argument_list|(
name|abfd
argument_list|,
name|i_phdrp
operator|+
name|phindex
argument_list|,
name|phindex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i_phdrp
operator|+
name|phindex
operator|)
operator|->
name|p_type
operator|==
name|PT_NOTE
condition|)
block|{
if|if
condition|(
operator|!
name|elf_corefile_note
argument_list|(
name|abfd
argument_list|,
name|i_phdrp
operator|+
name|phindex
argument_list|)
condition|)
return|return
name|NULL
return|;
block|}
block|}
comment|/* Remember the entry point specified in the ELF file header. */
name|bfd_get_start_address
argument_list|(
name|abfd
argument_list|)
operator|=
name|i_ehdrp
operator|->
name|e_entry
expr_stmt|;
return|return
name|abfd
operator|->
name|xvec
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ELF linker code.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|elf_link_add_object_symbols
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf_link_add_archive_symbols
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|INLINE
name|boolean
name|elf_link_record_dynamic_symbol
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf_link_create_dynamic_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf_adjust_dynamic_symbol
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Given an ELF BFD, add symbols to the global hash table as    appropriate.  */
end_comment

begin_function
name|boolean
name|elf_bfd_link_add_symbols
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
switch|switch
condition|(
name|bfd_get_format
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
case|case
name|bfd_object
case|:
return|return
name|elf_link_add_object_symbols
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
return|;
case|case
name|bfd_archive
case|:
return|return
name|elf_link_add_archive_symbols
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
return|;
default|default:
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
end_function

begin_comment
comment|/* Add symbols from an ELF archive file to the linker hash table.  We    don't use _bfd_generic_link_add_archive_symbols because of a    problem which arises on UnixWare.  The UnixWare libc.so is an    archive which includes an entry libc.so.1 which defines a bunch of    symbols.  The libc.so archive also includes a number of other    object files, which also define symbols, some of which are the same    as those defined in libc.so.1.  Correct linking requires that we    consider each object file in turn, and include it if it defines any    symbols we need.  _bfd_generic_link_add_archive_symbols does not do    this; it looks through the list of undefined symbols, and includes    any object file which defines them.  When this algorithm is used on    UnixWare, it winds up pulling in libc.so.1 early and defining a    bunch of symbols.  This means that some of the other objects in the    archive are not included in the link, which is incorrect since they    precede libc.so.1 in the archive.     Fortunately, ELF archive handling is simpler than that done by    _bfd_generic_link_add_archive_symbols, which has to allow for a.out    oddities.  In ELF, if we find a symbol in the archive map, and the    symbol is currently undefined, we know that we must pull in that    object file.     Unfortunately, we do have to make multiple passes over the symbol    table until nothing further is resolved.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf_link_add_archive_symbols
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|symindex
name|c
decl_stmt|;
name|boolean
modifier|*
name|defined
init|=
name|NULL
decl_stmt|;
name|boolean
modifier|*
name|included
init|=
name|NULL
decl_stmt|;
name|carsym
modifier|*
name|symdefs
decl_stmt|;
name|boolean
name|loop
decl_stmt|;
if|if
condition|(
operator|!
name|bfd_has_map
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_symbols
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* Keep track of all symbols we know to be already defined, and all      files we know to be already included.  This is to speed up the      second and subsequent passes.  */
name|c
operator|=
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symdef_count
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
return|return
name|true
return|;
name|defined
operator|=
operator|(
name|boolean
operator|*
operator|)
name|malloc
argument_list|(
name|c
operator|*
sizeof|sizeof
argument_list|(
name|boolean
argument_list|)
argument_list|)
expr_stmt|;
name|included
operator|=
operator|(
name|boolean
operator|*
operator|)
name|malloc
argument_list|(
name|c
operator|*
sizeof|sizeof
argument_list|(
name|boolean
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|defined
operator|==
operator|(
name|boolean
operator|*
operator|)
name|NULL
operator|||
name|included
operator|==
operator|(
name|boolean
operator|*
operator|)
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
name|memset
argument_list|(
name|defined
argument_list|,
literal|0
argument_list|,
name|c
operator|*
sizeof|sizeof
argument_list|(
name|boolean
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|included
argument_list|,
literal|0
argument_list|,
name|c
operator|*
sizeof|sizeof
argument_list|(
name|boolean
argument_list|)
argument_list|)
expr_stmt|;
name|symdefs
operator|=
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symdefs
expr_stmt|;
do|do
block|{
name|file_ptr
name|last
decl_stmt|;
name|symindex
name|i
decl_stmt|;
name|carsym
modifier|*
name|symdef
decl_stmt|;
name|carsym
modifier|*
name|symdefend
decl_stmt|;
name|loop
operator|=
name|false
expr_stmt|;
name|last
operator|=
operator|-
literal|1
expr_stmt|;
name|symdef
operator|=
name|symdefs
expr_stmt|;
name|symdefend
operator|=
name|symdef
operator|+
name|c
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|symdef
operator|<
name|symdefend
condition|;
name|symdef
operator|++
operator|,
name|i
operator|++
control|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|bfd
modifier|*
name|element
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|undefs_tail
decl_stmt|;
name|symindex
name|mark
decl_stmt|;
if|if
condition|(
name|defined
index|[
name|i
index|]
operator|||
name|included
index|[
name|i
index|]
condition|)
continue|continue;
if|if
condition|(
name|symdef
operator|->
name|file_offset
operator|==
name|last
condition|)
block|{
name|included
index|[
name|i
index|]
operator|=
name|true
expr_stmt|;
continue|continue;
block|}
name|h
operator|=
name|elf_link_hash_lookup
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|symdef
operator|->
name|name
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefined
condition|)
block|{
name|defined
index|[
name|i
index|]
operator|=
name|true
expr_stmt|;
continue|continue;
block|}
comment|/* We need to include this archive member.  */
name|element
operator|=
name|_bfd_get_elt_at_filepos
argument_list|(
name|abfd
argument_list|,
name|symdef
operator|->
name|file_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|element
operator|==
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
operator|!
name|bfd_check_format
argument_list|(
name|element
argument_list|,
name|bfd_object
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* Doublecheck that we have not included this object 	     already--it should be impossible, but there may be 	     something wrong with the archive.  */
if|if
condition|(
name|element
operator|->
name|archive_pass
operator|!=
literal|0
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
name|element
operator|->
name|archive_pass
operator|=
literal|1
expr_stmt|;
name|undefs_tail
operator|=
name|info
operator|->
name|hash
operator|->
name|undefs_tail
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|add_archive_element
call|)
argument_list|(
name|info
argument_list|,
name|element
argument_list|,
name|symdef
operator|->
name|name
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
operator|!
name|elf_link_add_object_symbols
argument_list|(
name|element
argument_list|,
name|info
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* If there are any new undefined symbols, we need to make 	     another pass through the archive in order to see whether 	     they can be defined.  FIXME: This isn't perfect, because 	     common symbols wind up on undefs_tail and because an 	     undefined symbol which is defined later on in this pass 	     does not require another pass.  This isn't a bug, but it 	     does make the code less efficient than it could be.  */
if|if
condition|(
name|undefs_tail
operator|!=
name|info
operator|->
name|hash
operator|->
name|undefs_tail
condition|)
name|loop
operator|=
name|true
expr_stmt|;
comment|/* Look backward to mark all symbols from this object file 	     which we have already seen in this pass.  */
name|mark
operator|=
name|i
expr_stmt|;
do|do
block|{
name|included
index|[
name|mark
index|]
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|mark
operator|==
literal|0
condition|)
break|break;
operator|--
name|mark
expr_stmt|;
block|}
do|while
condition|(
name|symdefs
index|[
name|mark
index|]
operator|.
name|file_offset
operator|==
name|symdef
operator|->
name|file_offset
condition|)
do|;
comment|/* We mark subsequent symbols from this object file as we go 	     on through the loop.  */
name|last
operator|=
name|symdef
operator|->
name|file_offset
expr_stmt|;
block|}
block|}
do|while
condition|(
name|loop
condition|)
do|;
name|free
argument_list|(
name|defined
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|included
argument_list|)
expr_stmt|;
return|return
name|true
return|;
name|error_return
label|:
if|if
condition|(
name|defined
operator|!=
operator|(
name|boolean
operator|*
operator|)
name|NULL
condition|)
name|free
argument_list|(
name|defined
argument_list|)
expr_stmt|;
if|if
condition|(
name|included
operator|!=
operator|(
name|boolean
operator|*
operator|)
name|NULL
condition|)
name|free
argument_list|(
name|included
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Record a new dynamic symbol.  We record the dynamic symbols as we    read the input files, since we need to have a list of all of them    before we can determine the final sizes of the output sections.  */
end_comment

begin_function
specifier|static
name|INLINE
name|boolean
name|elf_link_record_dynamic_symbol
parameter_list|(
name|info
parameter_list|,
name|h
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
block|{
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
condition|)
block|{
name|h
operator|->
name|dynindx
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynsymcount
expr_stmt|;
operator|++
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynsymcount
expr_stmt|;
name|h
operator|->
name|dynstr_index
operator|=
name|bfd_add_to_strtab
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
argument_list|,
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynstr
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|dynstr_index
operator|==
operator|(
name|unsigned
name|long
operator|)
operator|-
literal|1
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Add symbols from an ELF object file to the linker hash table.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf_link_add_object_symbols
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|boolean
argument_list|(
argument|*add_symbol_hook
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
specifier|const
name|Elf_Internal_Sym
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|flagword
operator|*
operator|,
name|asection
operator|*
operator|*
operator|,
name|bfd_vma
operator|*
operator|)
argument_list|)
expr_stmt|;
name|boolean
name|collect
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
name|size_t
name|symcount
decl_stmt|;
name|size_t
name|extsymcount
decl_stmt|;
name|size_t
name|extsymoff
decl_stmt|;
name|Elf_External_Sym
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hash
decl_stmt|;
name|boolean
name|dynamic
decl_stmt|;
name|Elf_External_Dyn
modifier|*
name|dynbuf
init|=
name|NULL
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|weaks
decl_stmt|;
name|Elf_External_Sym
modifier|*
name|esym
decl_stmt|;
name|Elf_External_Sym
modifier|*
name|esymend
decl_stmt|;
name|add_symbol_hook
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|elf_add_symbol_hook
expr_stmt|;
name|collect
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|collect
expr_stmt|;
name|hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|symcount
operator|=
name|hdr
operator|->
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
expr_stmt|;
comment|/* The sh_info field of the symtab header tells us where the      external symbols start.  We don't care about the local symbols at      this point.  */
if|if
condition|(
name|elf_bad_symtab
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
name|extsymcount
operator|=
name|symcount
expr_stmt|;
name|extsymoff
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|extsymcount
operator|=
name|symcount
operator|-
name|hdr
operator|->
name|sh_info
expr_stmt|;
name|extsymoff
operator|=
name|hdr
operator|->
name|sh_info
expr_stmt|;
block|}
name|buf
operator|=
operator|(
name|Elf_External_Sym
operator|*
operator|)
name|malloc
argument_list|(
name|extsymcount
operator|*
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
operator|&&
name|extsymcount
operator|!=
literal|0
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
comment|/* We store a pointer to the hash table entry for each external      symbol.  */
name|sym_hash
operator|=
operator|(
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|extsymcount
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|elf_link_hash_entry
operator|*
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|sym_hash
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
operator|=
name|sym_hash
expr_stmt|;
if|if
condition|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_type
operator|!=
name|ET_DYN
condition|)
block|{
name|dynamic
operator|=
name|false
expr_stmt|;
comment|/* If we are creating a shared library, create all the dynamic          sections immediately.  We need to attach them to something,          so we attach them to this BFD, provided it is the right          format.  FIXME: If there are no input BFD's of the same          format as the output, we can't make a shared library.  */
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
operator|==
name|NULL
operator|&&
name|abfd
operator|->
name|xvec
operator|==
name|info
operator|->
name|hash
operator|->
name|creator
condition|)
block|{
if|if
condition|(
operator|!
name|elf_link_create_dynamic_sections
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
operator|=
name|abfd
expr_stmt|;
block|}
block|}
else|else
block|{
name|asection
modifier|*
name|s
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|long
name|strindex
decl_stmt|;
name|dynamic
operator|=
name|true
expr_stmt|;
comment|/* You can't use -r against a dynamic object.  There's no hope 	 of using a dynamic object which does not exactly match the 	 format of the output file.  */
if|if
condition|(
name|info
operator|->
name|relocateable
operator|||
name|info
operator|->
name|hash
operator|->
name|creator
operator|!=
name|abfd
operator|->
name|xvec
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
comment|/* Find the name to use in a DT_NEEDED entry that refers to this 	 object.  If the object has a DT_SONAME entry, we use it. 	 Otherwise, if the generic linker stuck something in 	 elf_dt_needed_name, we use that.  Otherwise, we just use the 	 file name.  */
name|name
operator|=
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_dt_needed_name
argument_list|(
name|abfd
argument_list|)
operator|!=
name|NULL
condition|)
name|name
operator|=
name|elf_dt_needed_name
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
name|Elf_External_Dyn
modifier|*
name|extdyn
decl_stmt|;
name|Elf_External_Dyn
modifier|*
name|extdynend
decl_stmt|;
name|dynbuf
operator|=
operator|(
name|Elf_External_Dyn
operator|*
operator|)
name|malloc
argument_list|(
name|s
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|dynbuf
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
operator|(
name|PTR
operator|)
name|dynbuf
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|s
operator|->
name|_raw_size
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
name|extdyn
operator|=
name|dynbuf
expr_stmt|;
name|extdynend
operator|=
name|extdyn
operator|+
name|s
operator|->
name|_raw_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf_External_Dyn
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|extdyn
operator|<
name|extdynend
condition|;
name|extdyn
operator|++
control|)
block|{
name|Elf_Internal_Dyn
name|dyn
decl_stmt|;
name|elf_swap_dyn_in
argument_list|(
name|abfd
argument_list|,
name|extdyn
argument_list|,
operator|&
name|dyn
argument_list|)
expr_stmt|;
if|if
condition|(
name|dyn
operator|.
name|d_tag
operator|==
name|DT_SONAME
condition|)
block|{
name|int
name|elfsec
decl_stmt|;
name|unsigned
name|long
name|link
decl_stmt|;
name|elfsec
operator|=
name|elf_section_from_bfd_section
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|elfsec
operator|==
operator|-
literal|1
condition|)
goto|goto
name|error_return
goto|;
name|link
operator|=
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
index|[
name|elfsec
index|]
operator|->
name|sh_link
expr_stmt|;
name|name
operator|=
name|elf_string_from_elf_section
argument_list|(
name|abfd
argument_list|,
name|link
argument_list|,
name|dyn
operator|.
name|d_un
operator|.
name|d_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
break|break;
block|}
block|}
name|free
argument_list|(
name|dynbuf
argument_list|)
expr_stmt|;
name|dynbuf
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* We do not want to include any of the sections in a dynamic 	 object in the output file.  We hack by simply clobbering the 	 list of sections in the BFD.  This could be handled more 	 cleanly by, say, a new section flag; the existing 	 SEC_NEVER_LOAD flag is not the one we want, because that one 	 still implies that the section takes up space in the output 	 file.  */
name|abfd
operator|->
name|sections
operator|=
name|NULL
expr_stmt|;
comment|/* If this is the first dynamic object found in the link, create 	 the special sections required for dynamic linking.  We need 	 to put them somewhere, and attaching them to the first 	 dynamic object is as good place as any.  */
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|elf_link_create_dynamic_sections
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
operator|=
name|abfd
expr_stmt|;
block|}
comment|/* Add a DT_NEEDED entry for this dynamic object.  */
name|strindex
operator|=
name|bfd_add_to_strtab
argument_list|(
name|abfd
argument_list|,
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynstr
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|strindex
operator|==
operator|(
name|unsigned
name|long
operator|)
operator|-
literal|1
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
operator|!
name|elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_NEEDED
argument_list|,
name|strindex
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|sh_offset
operator|+
name|extsymoff
operator|*
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
argument_list|,
name|extsymcount
argument_list|,
name|abfd
argument_list|)
operator|!=
name|extsymcount
operator|*
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
operator|)
condition|)
goto|goto
name|error_return
goto|;
name|weaks
operator|=
name|NULL
expr_stmt|;
name|esymend
operator|=
name|buf
operator|+
name|extsymcount
expr_stmt|;
for|for
control|(
name|esym
operator|=
name|buf
init|;
name|esym
operator|<
name|esymend
condition|;
name|esym
operator|++
operator|,
name|sym_hash
operator|++
control|)
block|{
name|Elf_Internal_Sym
name|sym
decl_stmt|;
name|int
name|bind
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
init|=
name|NULL
decl_stmt|;
name|boolean
name|definition
decl_stmt|;
name|elf_swap_symbol_in
argument_list|(
name|abfd
argument_list|,
name|esym
argument_list|,
operator|&
name|sym
argument_list|)
expr_stmt|;
name|flags
operator|=
name|BSF_NO_FLAGS
expr_stmt|;
name|sec
operator|=
name|NULL
expr_stmt|;
name|value
operator|=
name|sym
operator|.
name|st_value
expr_stmt|;
operator|*
name|sym_hash
operator|=
name|NULL
expr_stmt|;
name|bind
operator|=
name|ELF_ST_BIND
argument_list|(
name|sym
operator|.
name|st_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|bind
operator|==
name|STB_LOCAL
condition|)
block|{
comment|/* This should be impossible, since ELF requires that all 	     global symbols follow all local symbols, and that sh_info 	     point to the first global symbol.  Unfortunatealy, Irix 5 	     screws this up.  */
continue|continue;
block|}
elseif|else
if|if
condition|(
name|bind
operator|==
name|STB_GLOBAL
condition|)
name|flags
operator|=
name|BSF_GLOBAL
expr_stmt|;
elseif|else
if|if
condition|(
name|bind
operator|==
name|STB_WEAK
condition|)
name|flags
operator|=
name|BSF_WEAK
expr_stmt|;
else|else
block|{
comment|/* Leave it up to the processor backend.  */
block|}
if|if
condition|(
name|sym
operator|.
name|st_shndx
operator|==
name|SHN_UNDEF
condition|)
name|sec
operator|=
name|bfd_und_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|sym
operator|.
name|st_shndx
operator|>
literal|0
operator|&&
name|sym
operator|.
name|st_shndx
operator|<
name|SHN_LORESERVE
condition|)
block|{
name|sec
operator|=
name|section_from_elf_index
argument_list|(
name|abfd
argument_list|,
name|sym
operator|.
name|st_shndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|value
operator|-=
name|sec
operator|->
name|vma
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sym
operator|.
name|st_shndx
operator|==
name|SHN_ABS
condition|)
name|sec
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|sym
operator|.
name|st_shndx
operator|==
name|SHN_COMMON
condition|)
block|{
name|sec
operator|=
name|bfd_com_section_ptr
expr_stmt|;
comment|/* What ELF calls the size we call the value.  What ELF 	     calls the value we call the alignment.  */
name|value
operator|=
name|sym
operator|.
name|st_size
expr_stmt|;
block|}
else|else
block|{
comment|/* Leave it up to the processor backend.  */
block|}
name|name
operator|=
name|elf_string_from_elf_section
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|sh_link
argument_list|,
name|sym
operator|.
name|st_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|add_symbol_hook
condition|)
block|{
if|if
condition|(
operator|!
call|(
modifier|*
name|add_symbol_hook
call|)
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
operator|&
name|sym
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|flags
argument_list|,
operator|&
name|sec
argument_list|,
operator|&
name|value
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* The hook function sets the name to NULL if this symbol 	     should be skipped for some reason.  */
if|if
condition|(
name|name
operator|==
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
condition|)
continue|continue;
block|}
comment|/* Sanity check that all possibilities were handled.  */
if|if
condition|(
name|flags
operator|==
name|BSF_NO_FLAGS
operator|||
name|sec
operator|==
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|sec
argument_list|)
operator|||
name|bfd_is_com_section
argument_list|(
name|sec
argument_list|)
condition|)
name|definition
operator|=
name|false
expr_stmt|;
else|else
name|definition
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|hash
operator|->
name|creator
operator|->
name|flavour
operator|==
name|bfd_target_elf_flavour
condition|)
block|{
comment|/* We need to look up the symbol now in order to get some of 	     the dynamic object handling right.  We pass the hash 	     table entry in to _bfd_generic_link_add_one_symbol so 	     that it does not have to look it up again.  */
name|h
operator|=
name|elf_link_hash_lookup
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|name
argument_list|,
name|true
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
operator|*
name|sym_hash
operator|=
name|h
expr_stmt|;
comment|/* If we are looking at a dynamic object, and this is a 	     definition, we need to see if it has already been defined 	     by some other object.  If it has, we want to use the 	     existing definition, and we do not want to report a 	     multiple symbol definition error; we do this by 	     clobbering sec to be bfd_und_section_ptr.  */
if|if
condition|(
name|dynamic
operator|&&
name|definition
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
condition|)
name|sec
operator|=
name|bfd_und_section_ptr
expr_stmt|;
block|}
comment|/* Similarly, if we are not looking at a dynamic object, and 	     we have a definition, we want to override any definition 	     we may have from a dynamic object.  Symbols from regular 	     files always take precedence over symbols from dynamic 	     objects, even if they are defined after the dynamic 	     object in the link.  */
if|if
condition|(
operator|!
name|dynamic
operator|&&
name|definition
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|bfd_get_flavour
argument_list|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
argument_list|)
operator|==
name|bfd_target_elf_flavour
operator|)
operator|&&
operator|(
name|elf_elfheader
argument_list|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
argument_list|)
operator|->
name|e_type
operator|==
name|ET_DYN
operator|)
condition|)
block|{
comment|/* Change the hash table entry to undefined, and let 		 _bfd_generic_link_add_one_symbol do the right thing 		 with the new definition.  */
name|h
operator|->
name|root
operator|.
name|type
operator|=
name|bfd_link_hash_undefined
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|undef
operator|.
name|abfd
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator|&=
operator|~
name|ELF_LINK_HASH_DEFINED_WEAK
expr_stmt|;
block|}
comment|/* If this is a weak definition which we are going to use, 	     and the symbol is currently undefined, record that the 	     definition is weak.  */
if|if
condition|(
name|definition
operator|&&
operator|(
name|flags
operator|&
name|BSF_WEAK
operator|)
operator|!=
literal|0
operator|&&
operator|!
name|bfd_is_und_section
argument_list|(
name|sec
argument_list|)
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_new
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_weak
operator|)
condition|)
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_DEFINED_WEAK
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
name|name
argument_list|,
name|flags
argument_list|,
name|sec
argument_list|,
name|value
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|false
argument_list|,
name|collect
argument_list|,
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|*
operator|)
name|sym_hash
argument_list|)
operator|)
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|dynamic
operator|&&
name|definition
operator|&&
operator|(
name|flags
operator|&
name|BSF_WEAK
operator|)
operator|!=
literal|0
operator|&&
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|.
name|st_info
argument_list|)
operator|!=
name|STT_FUNC
operator|&&
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|weakdef
operator|==
name|NULL
condition|)
block|{
comment|/* Keep a list of all weak defined non function symbols from 	     a dynamic object, using the weakdef field.  Later in this 	     function we will set the weakdef field to the correct 	     value.  We only put non-function symbols from dynamic 	     objects on this list, because that happens to be the only 	     time we need to know the normal symbol corresponding to a 	     weak symbol, and the information is time consuming to 	     figure out.  If the weakdef field is not already NULL, 	     then this symbol was already defined by some previous 	     dynamic object, and we will be using that previous 	     definition anyhow.  */
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|weakdef
operator|=
name|weaks
expr_stmt|;
name|weaks
operator|=
operator|*
name|sym_hash
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|->
name|hash
operator|->
name|creator
operator|->
name|flavour
operator|==
name|bfd_target_elf_flavour
condition|)
block|{
name|int
name|old_flags
decl_stmt|;
name|boolean
name|dynsym
decl_stmt|;
name|int
name|new_flag
decl_stmt|;
comment|/* Remember the symbol size, type and alignment.  */
if|if
condition|(
name|sym
operator|.
name|st_size
operator|!=
literal|0
condition|)
block|{
comment|/* FIXME: We should probably somehow give a warning if 		 the symbol size changes.  */
name|h
operator|->
name|size
operator|=
name|sym
operator|.
name|st_size
expr_stmt|;
block|}
if|if
condition|(
name|sym
operator|.
name|st_shndx
operator|==
name|SHN_COMMON
operator|&&
name|sym
operator|.
name|st_value
operator|>
name|h
operator|->
name|align
condition|)
name|h
operator|->
name|align
operator|=
name|sym
operator|.
name|st_value
expr_stmt|;
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|.
name|st_info
argument_list|)
operator|!=
name|STT_NOTYPE
condition|)
block|{
comment|/* FIXME: We should probably somehow give a warning if 		 the symbol type changes.  */
name|h
operator|->
name|type
operator|=
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|.
name|st_info
argument_list|)
expr_stmt|;
block|}
comment|/* Set a flag in the hash table entry indicating the type of 	     reference or definition we just found.  Keep a count of 	     the number of dynamic symbols we find.  A dynamic symbol 	     is one which is referenced or defined by both a regular 	     object and a shared object, or one which is referenced or 	     defined by more than one shared object.  */
name|old_flags
operator|=
name|h
operator|->
name|elf_link_hash_flags
expr_stmt|;
name|dynsym
operator|=
name|false
expr_stmt|;
if|if
condition|(
operator|!
name|dynamic
condition|)
block|{
if|if
condition|(
operator|!
name|definition
condition|)
name|new_flag
operator|=
name|ELF_LINK_HASH_REF_REGULAR
expr_stmt|;
else|else
name|new_flag
operator|=
name|ELF_LINK_HASH_DEF_REGULAR
expr_stmt|;
if|if
condition|(
operator|(
name|old_flags
operator|&
operator|(
name|ELF_LINK_HASH_DEF_DYNAMIC
operator||
name|ELF_LINK_HASH_REF_DYNAMIC
operator|)
operator|)
operator|!=
literal|0
condition|)
name|dynsym
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|definition
condition|)
name|new_flag
operator|=
name|ELF_LINK_HASH_REF_DYNAMIC
expr_stmt|;
else|else
name|new_flag
operator|=
name|ELF_LINK_HASH_DEF_DYNAMIC
expr_stmt|;
if|if
condition|(
operator|(
name|old_flags
operator|&
name|new_flag
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|definition
condition|)
name|new_flag
operator|=
name|ELF_LINK_HASH_REF_DYNAMIC_MULTIPLE
expr_stmt|;
else|else
name|new_flag
operator|=
name|ELF_LINK_HASH_DEF_DYNAMIC_MULTIPLE
expr_stmt|;
name|dynsym
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|old_flags
operator|&
operator|(
name|ELF_LINK_HASH_DEF_REGULAR
operator||
name|ELF_LINK_HASH_REF_REGULAR
operator|)
operator|)
operator|!=
literal|0
condition|)
name|dynsym
operator|=
name|true
expr_stmt|;
block|}
block|}
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|new_flag
expr_stmt|;
if|if
condition|(
name|dynsym
operator|&&
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
block|}
block|}
comment|/* Now set the weakdefs field correctly for all the weak defined      symbols we found.  The only way to do this is to search all the      symbols.  Since we only need the information for non functions in      dynamic objects, that's the only time we actually put anything on      the list WEAKS.  We need this information so that if a regular      object refers to a symbol defined weakly in a dynamic object, the      real symbol in the dynamic object is also put in the dynamic      symbols; we also must arrange for both symbols to point to the      same memory location.  We could handle the general case of symbol      aliasing, but a general symbol alias can only be generated in      assembler code, handling it correctly would be very time      consuming, and other ELF linkers don't handle general aliasing      either.  */
while|while
condition|(
name|weaks
operator|!=
name|NULL
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|hlook
decl_stmt|;
name|asection
modifier|*
name|slook
decl_stmt|;
name|bfd_vma
name|vlook
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|hpp
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|hppend
decl_stmt|;
name|hlook
operator|=
name|weaks
expr_stmt|;
name|weaks
operator|=
name|hlook
operator|->
name|weakdef
expr_stmt|;
name|hlook
operator|->
name|weakdef
operator|=
name|NULL
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|hlook
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
argument_list|)
expr_stmt|;
name|slook
operator|=
name|hlook
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|vlook
operator|=
name|hlook
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
name|hpp
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|hppend
operator|=
name|hpp
operator|+
name|extsymcount
expr_stmt|;
for|for
control|(
init|;
name|hpp
operator|<
name|hppend
condition|;
name|hpp
operator|++
control|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
operator|*
name|hpp
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|hlook
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|&&
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|==
name|slook
operator|&&
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|==
name|vlook
condition|)
block|{
name|hlook
operator|->
name|weakdef
operator|=
name|h
expr_stmt|;
comment|/* If the weak definition is in the list of dynamic 		 symbols, make sure the real definition is put there 		 as well.  */
if|if
condition|(
name|hlook
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|&&
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
break|break;
block|}
block|}
block|}
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|true
return|;
name|error_return
label|:
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|dynbuf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|dynbuf
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Create some sections which will be filled in with dynamic linking    information.  The ABFD argument is an input file which is a dynamic    object.  The dynamic sections take up virtual memory space when the    final executable is run, so we need to create them before addresses    are assigned to the output sections.  We work out the actual    contents and size of these sections later.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf_link_create_dynamic_sections
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|flagword
name|flags
decl_stmt|;
specifier|register
name|asection
modifier|*
name|s
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
comment|/* Note that we set the SEC_IN_MEMORY flag for all of these      sections.  */
name|flags
operator|=
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
expr_stmt|;
comment|/* A dynamically linked executable has a .interp section, but a      shared library does not.  */
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
block|{
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".interp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|flags
operator||
name|SEC_READONLY
argument_list|)
condition|)
return|return
name|false
return|;
block|}
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|flags
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|LOG_FILE_ALIGN
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* The special symbol _DYNAMIC is always set to the start of the      .dynamic section.  This call occurs before we have processed the      symbols for any dynamic object, so we don't have to worry about      overriding a dynamic definition.  We could set _DYNAMIC in a      linker script, but we only want to define it if we are, in fact,      creating a .dynamic section.  We don't want to define it if there      is no .dynamic section, since on some ELF platforms the start up      code examines it to decide how to initialize the process.  */
name|h
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
literal|"_DYNAMIC"
argument_list|,
name|BSF_GLOBAL
argument_list|,
name|s
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|false
argument_list|,
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|collect
argument_list|,
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|*
operator|)
operator|&
name|h
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_DEF_REGULAR
expr_stmt|;
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".dynsym"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|flags
operator||
name|SEC_READONLY
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|LOG_FILE_ALIGN
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* The first .dynsym symbol is a dummy.  */
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynsymcount
operator|=
literal|1
expr_stmt|;
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".dynstr"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|flags
operator||
name|SEC_READONLY
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Create a strtab to hold the dynamic symbol names.  */
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynstr
operator|=
name|bfd_new_strtab
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynstr
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".hash"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|flags
operator||
name|SEC_READONLY
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|LOG_FILE_ALIGN
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Let the backend create the rest of the sections.  This lets the      backend set the right flags.  The backend will normally create      the .got and .plt sections.  */
name|bed
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
return|return
call|(
modifier|*
name|bed
operator|->
name|elf_backend_create_dynamic_sections
call|)
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Add an entry to the .dynamic table.  */
end_comment

begin_function
name|boolean
name|elf_add_dynamic_entry
parameter_list|(
name|info
parameter_list|,
name|tag
parameter_list|,
name|val
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|bfd_vma
name|tag
decl_stmt|;
name|bfd_vma
name|val
decl_stmt|;
block|{
name|Elf_Internal_Dyn
name|dyn
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|size_t
name|newsize
decl_stmt|;
name|bfd_byte
modifier|*
name|newcontents
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|newsize
operator|=
name|s
operator|->
name|_raw_size
operator|+
sizeof|sizeof
argument_list|(
name|Elf_External_Dyn
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|contents
operator|==
name|NULL
condition|)
name|newcontents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|malloc
argument_list|(
name|newsize
argument_list|)
expr_stmt|;
else|else
name|newcontents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|realloc
argument_list|(
name|s
operator|->
name|contents
argument_list|,
name|newsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|newcontents
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|dyn
operator|.
name|d_tag
operator|=
name|tag
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|val
expr_stmt|;
name|elf_swap_dyn_out
argument_list|(
name|dynobj
argument_list|,
operator|&
name|dyn
argument_list|,
operator|(
name|Elf_External_Dyn
operator|*
operator|)
operator|(
name|newcontents
operator|+
name|s
operator|->
name|_raw_size
operator|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|=
name|newsize
expr_stmt|;
name|s
operator|->
name|contents
operator|=
name|newcontents
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Record an assignment to a symbol made by a linker script.  We need    this in case some dynamic object refers to this symbol.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_decl_stmt
name|boolean
name|NAME
argument_list|(
name|bfd_elf
argument_list|,
name|record_link_assignment
argument_list|)
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|name
argument_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
comment|/* This is called after we have examined all the input objects.  If      the symbol does not exist, it merely means that no object refers      to it, and we can just ignore it at this point.  */
name|h
operator|=
name|elf_link_hash_lookup
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|name
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
return|return
name|true
return|;
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_DEF_REGULAR
expr_stmt|;
if|if
condition|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
operator|(
name|ELF_LINK_HASH_DEF_DYNAMIC
operator||
name|ELF_LINK_HASH_REF_DYNAMIC
operator|)
operator|)
operator|!=
literal|0
operator|&&
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* If this is a weak defined symbol, and we know a corresponding 	 real symbol from the same dynamic object, make sure the real 	 symbol is also made into a dynamic symbol.  */
if|if
condition|(
name|h
operator|->
name|weakdef
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|weakdef
operator|->
name|dynindx
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
operator|->
name|weakdef
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
return|return
name|true
return|;
block|}
end_block

begin_comment
comment|/* Array used to determine the number of hash table buckets to use    based on the number of symbols there are.  If there are fewer than    3 symbols we use 1 bucket, fewer than 17 symbols we use 3 buckets,    fewer than 37 we use 17 buckets, and so forth.  We never use more    than 521 buckets.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|size_t
name|elf_buckets
index|[]
init|=
block|{
literal|1
block|,
literal|3
block|,
literal|17
block|,
literal|37
block|,
literal|67
block|,
literal|97
block|,
literal|131
block|,
literal|197
block|,
literal|263
block|,
literal|521
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set up the sizes and contents of the ELF dynamic sections.  This is    called by the ELF linker emulation before_allocation routine.  We    must set the sizes of the sections before the linker sets the    addresses of the various sections.  */
end_comment

begin_decl_stmt
name|boolean
name|NAME
argument_list|(
name|bfd_elf
argument_list|,
name|size_dynamic_sections
argument_list|)
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|sinterpptr
argument_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|asection
modifier|*
modifier|*
name|sinterpptr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|size_t
name|dynsymcount
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|Elf_Internal_Sym
name|isym
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|size_t
name|bucketcount
decl_stmt|;
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
operator|*
name|sinterpptr
operator|=
name|NULL
expr_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|dynsymcount
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynsymcount
expr_stmt|;
comment|/* If there were no dynamic objects in the link, there is nothing to      do here.  */
if|if
condition|(
name|dynobj
operator|==
name|NULL
condition|)
return|return
name|true
return|;
operator|*
name|sinterpptr
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".interp"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
operator|*
name|sinterpptr
operator|!=
name|NULL
operator|||
name|info
operator|->
name|shared
argument_list|)
expr_stmt|;
comment|/* Set the size of the .dynsym and .hash sections.  We counted the      number of dynamic symbols in elf_link_add_object_symbols.  We      will build the contents of .dynsym and .hash when we build the      final symbol table, because until then we do not know the correct      value to give the symbols.  We built the .dynstr section as we      went along in elf_link_add_object_symbols.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynsym"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|=
name|dynsymcount
operator|*
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
expr_stmt|;
name|s
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|output_bfd
argument_list|,
name|s
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|contents
operator|==
name|NULL
operator|&&
name|s
operator|->
name|_raw_size
operator|!=
literal|0
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* The first entry in .dynsym is a dummy symbol.  */
name|isym
operator|.
name|st_value
operator|=
literal|0
expr_stmt|;
name|isym
operator|.
name|st_size
operator|=
literal|0
expr_stmt|;
name|isym
operator|.
name|st_name
operator|=
literal|0
expr_stmt|;
name|isym
operator|.
name|st_info
operator|=
literal|0
expr_stmt|;
name|isym
operator|.
name|st_other
operator|=
literal|0
expr_stmt|;
name|isym
operator|.
name|st_shndx
operator|=
literal|0
expr_stmt|;
name|elf_swap_symbol_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|isym
argument_list|,
operator|(
name|Elf_External_Sym
operator|*
operator|)
name|s
operator|->
name|contents
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|elf_buckets
index|[
name|i
index|]
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|bucketcount
operator|=
name|elf_buckets
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|dynsymcount
operator|<
name|elf_buckets
index|[
name|i
operator|+
literal|1
index|]
condition|)
break|break;
block|}
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".hash"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|=
operator|(
literal|2
operator|+
name|bucketcount
operator|+
name|dynsymcount
operator|)
operator|*
operator|(
name|ARCH_SIZE
operator|/
literal|8
operator|)
expr_stmt|;
name|s
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|output_bfd
argument_list|,
name|s
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|contents
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|memset
argument_list|(
name|s
operator|->
name|contents
argument_list|,
literal|0
argument_list|,
name|s
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|output_bfd
argument_list|,
name|bucketcount
argument_list|,
name|s
operator|->
name|contents
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|output_bfd
argument_list|,
name|dynsymcount
argument_list|,
name|s
operator|->
name|contents
operator|+
operator|(
name|ARCH_SIZE
operator|/
literal|8
operator|)
argument_list|)
expr_stmt|;
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|bucketcount
operator|=
name|bucketcount
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynstr"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynstr
operator|->
name|length
expr_stmt|;
name|s
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynstr
operator|->
name|tab
expr_stmt|;
comment|/* Find all symbols which were defined in a dynamic object and make      the backend pick a reasonable value for them.  */
name|elf_link_hash_traverse
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|elf_adjust_dynamic_symbol
argument_list|,
operator|(
name|PTR
operator|)
name|info
argument_list|)
expr_stmt|;
comment|/* Add some entries to the .dynamic section.  We fill in some of the      values later, in elf_bfd_final_link, but we must add the entries      now so that we know the final size of the .dynamic section.  */
if|if
condition|(
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
literal|".init"
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_INIT
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
literal|".fini"
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_FINI
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_HASH
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_STRTAB
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_SYMTAB
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_STRSZ
argument_list|,
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynstr
operator|->
name|length
argument_list|)
operator|||
operator|!
name|elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_SYMENT
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* The backend must work out the sizes of all the other dynamic      sections.  */
name|bed
operator|=
name|get_elf_backend_data
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|bed
operator|->
name|elf_backend_size_dynamic_sections
call|)
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_NULL
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/* Make the backend pick a good value for a dynamic symbol.  This is    called via elf_link_hash_traverse, and also calls itself    recursively.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf_adjust_dynamic_symbol
parameter_list|(
name|h
parameter_list|,
name|data
parameter_list|)
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|PTR
name|data
decl_stmt|;
block|{
name|struct
name|bfd_link_info
modifier|*
name|info
init|=
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|)
name|data
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
comment|/* If this symbol is not defined by a dynamic object, or is not      referenced by a regular object, ignore it.  FIXME: Do we need to      worry about symbols which are defined by one dynamic object and      referenced by another one?  */
if|if
condition|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|!=
literal|0
operator|||
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|==
literal|0
operator|||
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_REF_REGULAR
operator|)
operator|==
literal|0
condition|)
return|return
name|true
return|;
comment|/* If we've already adjusted this symbol, don't do it again.  This      can happen via a recursive call.  */
if|if
condition|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DYNAMIC_ADJUSTED
operator|)
operator|!=
literal|0
condition|)
return|return
name|true
return|;
comment|/* Don't look at this symbol again.  Note that we must set this      after checking the above conditions, because we may look at a      symbol once, decide not to do anything, and then get called      recursively later after REF_REGULAR is set below.  */
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_DYNAMIC_ADJUSTED
expr_stmt|;
comment|/* If this is a weak definition, and we know a real definition, and      the real symbol is not itself defined by a regular object file,      then get a good value for the real definition.  We handle the      real symbol first, for the convenience of the backend routine.       Note that there is a confusing case here.  If the real definition      is defined by a regular object file, we don't get the real symbol      from the dynamic object, but we do get the weak symbol.  If the      processor backend uses a COPY reloc, then if some routine in the      dynamic object changes the real symbol, we will not see that      change in the corresponding weak symbol.  This is the way other      ELF linkers work as well, and seems to be a result of the shared      library model.       I will clarify this issue.  Most SVR4 shared libraries define the      variable _timezone and define timezone as a weak synonym.  The      tzset call changes _timezone.  If you write        extern int timezone;        int _timezone = 5;        int main () { tzset (); printf ("%d %d\n", timezone, _timezone); }      you might expect that, since timezone is a synonym for _timezone,      the same number will print both times.  However, if the processor      backend uses a COPY reloc, then actually timezone will be copied      into your process image, and, since you define _timezone      yourself, _timezone will not.  Thus timezone and _timezone will      wind up at different memory locations.  The tzset call will set      _timezone, leaving timezone unchanged.  */
if|if
condition|(
name|h
operator|->
name|weakdef
operator|!=
name|NULL
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|weakdef
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
argument_list|)
expr_stmt|;
name|weakdef
operator|=
name|h
operator|->
name|weakdef
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|weakdef
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|weakdef
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|!=
literal|0
operator|||
operator|(
name|weakdef
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_REF_REGULAR
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* This symbol is defined or referenced by a regular object 	     file, so we will not do anything special.  Clear weakdef 	     for the convenience of the processor backend.  */
name|h
operator|->
name|weakdef
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* There is an implicit reference by a regular object file 	     via the weak symbol.  */
name|weakdef
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_REF_REGULAR
expr_stmt|;
if|if
condition|(
operator|!
name|elf_adjust_dynamic_symbol
argument_list|(
name|weakdef
argument_list|,
operator|(
name|PTR
operator|)
name|info
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|bed
operator|=
name|get_elf_backend_data
argument_list|(
name|dynobj
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|bed
operator|->
name|elf_backend_adjust_dynamic_symbol
call|)
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
block|{
comment|/* FIXME: No way to return error.  */
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Final phase of ELF linker.  */
end_comment

begin_comment
comment|/* A structure we use to avoid passing large numbers of arguments.  */
end_comment

begin_struct
struct|struct
name|elf_final_link_info
block|{
comment|/* General link information.  */
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
comment|/* Output BFD.  */
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
comment|/* Symbol string table.  */
name|struct
name|strtab
modifier|*
name|symstrtab
decl_stmt|;
comment|/* .dynsym section.  */
name|asection
modifier|*
name|dynsym_sec
decl_stmt|;
comment|/* .hash section.  */
name|asection
modifier|*
name|hash_sec
decl_stmt|;
comment|/* Buffer large enough to hold contents of any section.  */
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
comment|/* Buffer large enough to hold external relocs of any section.  */
name|PTR
name|external_relocs
decl_stmt|;
comment|/* Buffer large enough to hold internal relocs of any section.  */
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
decl_stmt|;
comment|/* Buffer large enough to hold external local symbols of any input      BFD.  */
name|Elf_External_Sym
modifier|*
name|external_syms
decl_stmt|;
comment|/* Buffer large enough to hold internal local symbols of any input      BFD.  */
name|Elf_Internal_Sym
modifier|*
name|internal_syms
decl_stmt|;
comment|/* Array large enough to hold a symbol index for each local symbol      of any input BFD.  */
name|long
modifier|*
name|indices
decl_stmt|;
comment|/* Array large enough to hold a section pointer for each local      symbol of any input BFD.  */
name|asection
modifier|*
modifier|*
name|sections
decl_stmt|;
comment|/* Buffer to hold swapped out symbols.  */
name|Elf_External_Sym
modifier|*
name|symbuf
decl_stmt|;
comment|/* Number of swapped out symbols in buffer.  */
name|size_t
name|symbuf_count
decl_stmt|;
comment|/* Number of symbols which fit in symbuf.  */
name|size_t
name|symbuf_size
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|boolean
name|elf_link_output_sym
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf_final_link_info
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|,
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf_link_flush_output_syms
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf_final_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf_link_output_extsym
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf_link_input_bfd
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf_final_link_info
operator|*
operator|,
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf_reloc_link_order
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|asection
operator|*
operator|,
expr|struct
name|bfd_link_order
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Do the final step of an ELF link.  */
end_comment

begin_function
name|boolean
name|elf_bfd_final_link
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|struct
name|elf_final_link_info
name|finfo
decl_stmt|;
specifier|register
name|asection
modifier|*
name|o
decl_stmt|;
specifier|register
name|struct
name|bfd_link_order
modifier|*
name|p
decl_stmt|;
specifier|register
name|bfd
modifier|*
name|sub
decl_stmt|;
name|size_t
name|max_contents_size
decl_stmt|;
name|size_t
name|max_external_reloc_size
decl_stmt|;
name|size_t
name|max_internal_reloc_count
decl_stmt|;
name|size_t
name|max_sym_count
decl_stmt|;
name|file_ptr
name|off
decl_stmt|;
name|Elf_Internal_Sym
name|elfsym
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symstrtab_hdr
decl_stmt|;
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Generating ELF shared libraries is not yet supported\n"
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|finfo
operator|.
name|info
operator|=
name|info
expr_stmt|;
name|finfo
operator|.
name|output_bfd
operator|=
name|abfd
expr_stmt|;
name|finfo
operator|.
name|symstrtab
operator|=
name|bfd_new_strtab
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|symstrtab
operator|==
name|NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
name|dynobj
operator|==
name|NULL
condition|)
block|{
name|finfo
operator|.
name|dynsym_sec
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|hash_sec
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|finfo
operator|.
name|dynsym_sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynsym"
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|hash_sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".hash"
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|dynsym_sec
operator|==
name|NULL
operator|||
name|finfo
operator|.
name|hash_sec
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
name|finfo
operator|.
name|contents
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|external_relocs
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|internal_relocs
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|external_syms
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|internal_syms
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|indices
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|sections
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|symbuf
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|symbuf_count
operator|=
literal|0
expr_stmt|;
comment|/* Count up the number of relocations we will output for each output      section, so that we know the sizes of the reloc sections.  We      also figure out some maximum sizes.  */
name|max_contents_size
operator|=
literal|0
expr_stmt|;
name|max_external_reloc_size
operator|=
literal|0
expr_stmt|;
name|max_internal_reloc_count
operator|=
literal|0
expr_stmt|;
name|max_sym_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
name|o
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|o
operator|->
name|link_order_head
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|bfd_section_reloc_link_order
operator|||
name|p
operator|->
name|type
operator|==
name|bfd_symbol_reloc_link_order
condition|)
operator|++
name|o
operator|->
name|reloc_count
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|bfd_indirect_link_order
condition|)
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
name|sec
operator|=
name|p
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|relocateable
condition|)
name|o
operator|->
name|reloc_count
operator|+=
name|sec
operator|->
name|reloc_count
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|_raw_size
operator|>
name|max_contents_size
condition|)
name|max_contents_size
operator|=
name|sec
operator|->
name|_raw_size
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|_cooked_size
operator|>
name|max_contents_size
condition|)
name|max_contents_size
operator|=
name|sec
operator|->
name|_cooked_size
expr_stmt|;
comment|/* We are interested in just local symbols, not all 		 symbols.  */
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|sec
operator|->
name|owner
argument_list|)
operator|==
name|bfd_target_elf_flavour
condition|)
block|{
name|size_t
name|sym_count
decl_stmt|;
if|if
condition|(
name|elf_bad_symtab
argument_list|(
name|sec
operator|->
name|owner
argument_list|)
condition|)
name|sym_count
operator|=
operator|(
name|elf_tdata
argument_list|(
name|sec
operator|->
name|owner
argument_list|)
operator|->
name|symtab_hdr
operator|.
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
operator|)
expr_stmt|;
else|else
name|sym_count
operator|=
name|elf_tdata
argument_list|(
name|sec
operator|->
name|owner
argument_list|)
operator|->
name|symtab_hdr
operator|.
name|sh_info
expr_stmt|;
if|if
condition|(
name|sym_count
operator|>
name|max_sym_count
condition|)
name|max_sym_count
operator|=
name|sym_count
expr_stmt|;
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|!=
literal|0
condition|)
block|{
name|size_t
name|ext_size
decl_stmt|;
name|ext_size
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|rel_hdr
operator|.
name|sh_size
expr_stmt|;
if|if
condition|(
name|ext_size
operator|>
name|max_external_reloc_size
condition|)
name|max_external_reloc_size
operator|=
name|ext_size
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|reloc_count
operator|>
name|max_internal_reloc_count
condition|)
name|max_internal_reloc_count
operator|=
name|sec
operator|->
name|reloc_count
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|o
operator|->
name|reloc_count
operator|>
literal|0
condition|)
name|o
operator|->
name|flags
operator||=
name|SEC_RELOC
expr_stmt|;
else|else
block|{
comment|/* Explicitly clear the SEC_RELOC flag.  The linker tends to 	     set it (this is probably a bug) and if it is set 	     assign_section_numbers will create a reloc section.  */
name|o
operator|->
name|flags
operator|&=
operator|~
name|SEC_RELOC
expr_stmt|;
block|}
block|}
comment|/* Figure out the file positions for everything but the symbol table      and the relocs.  We set symcount to force assign_section_numbers      to create a symbol table.  */
name|abfd
operator|->
name|symcount
operator|=
name|info
operator|->
name|strip
operator|==
name|strip_all
condition|?
literal|0
else|:
literal|1
expr_stmt|;
name|BFD_ASSERT
argument_list|(
operator|!
name|abfd
operator|->
name|output_has_begun
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|elf_compute_section_file_positions
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* That created the reloc sections.  Set their sizes, and assign      them file positions, and allocate some buffers.  */
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|!=
literal|0
condition|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|rel_hdr
decl_stmt|;
specifier|register
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|p
decl_stmt|,
modifier|*
modifier|*
name|pend
decl_stmt|;
name|rel_hdr
operator|=
operator|&
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|rel_hdr
expr_stmt|;
name|rel_hdr
operator|->
name|sh_size
operator|=
name|rel_hdr
operator|->
name|sh_entsize
operator|*
name|o
operator|->
name|reloc_count
expr_stmt|;
comment|/* The contents field must last into write_object_contents, 	     so we allocate it with bfd_alloc rather than malloc.  */
name|rel_hdr
operator|->
name|contents
operator|=
operator|(
name|PTR
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|rel_hdr
operator|->
name|sh_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|rel_hdr
operator|->
name|contents
operator|==
name|NULL
operator|&&
name|rel_hdr
operator|->
name|sh_size
operator|!=
literal|0
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
name|p
operator|=
operator|(
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|o
operator|->
name|reloc_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|elf_link_hash_entry
operator|*
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
operator|&&
name|o
operator|->
name|reloc_count
operator|!=
literal|0
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|rel_hashes
operator|=
name|p
expr_stmt|;
name|pend
operator|=
name|p
operator|+
name|o
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
init|;
name|p
operator|<
name|pend
condition|;
name|p
operator|++
control|)
operator|*
name|p
operator|=
name|NULL
expr_stmt|;
comment|/* Use the reloc_count field as an index when outputting the 	     relocs.  */
name|o
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|assign_file_positions_for_relocs
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* We have now assigned file positions for all the sections except      .symtab and .strtab.  We start the .symtab section at the current      file position, and write directly to it.  We build the .strtab      section in memory.  When we add .dynsym support, we will build      that in memory as well (.dynsym is smaller than .symtab).  */
name|abfd
operator|->
name|symcount
operator|=
literal|0
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
comment|/* sh_name is set in prep_headers.  */
name|symtab_hdr
operator|->
name|sh_type
operator|=
name|SHT_SYMTAB
expr_stmt|;
name|symtab_hdr
operator|->
name|sh_flags
operator|=
literal|0
expr_stmt|;
name|symtab_hdr
operator|->
name|sh_addr
operator|=
literal|0
expr_stmt|;
name|symtab_hdr
operator|->
name|sh_size
operator|=
literal|0
expr_stmt|;
name|symtab_hdr
operator|->
name|sh_entsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
expr_stmt|;
comment|/* sh_link is set in assign_section_numbers.  */
comment|/* sh_info is set below.  */
comment|/* sh_offset is set just below.  */
name|symtab_hdr
operator|->
name|sh_addralign
operator|=
literal|4
expr_stmt|;
comment|/* FIXME: system dependent?  */
name|off
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|next_file_pos
expr_stmt|;
name|off
operator|=
name|assign_file_position_for_section
argument_list|(
name|symtab_hdr
argument_list|,
name|off
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* Note that at this point elf_tdata (abfd)->next_file_pos is      incorrect.  We do not yet know the size of the .symtab section.      We correct next_file_pos below, after we do know the size.  */
comment|/* Allocate a buffer to hold swapped out symbols.  This is to avoid      continuously seeking to the right position in the file.  */
if|if
condition|(
operator|!
name|info
operator|->
name|keep_memory
operator|||
name|max_sym_count
operator|<
literal|20
condition|)
name|finfo
operator|.
name|symbuf_size
operator|=
literal|20
expr_stmt|;
else|else
name|finfo
operator|.
name|symbuf_size
operator|=
name|max_sym_count
expr_stmt|;
name|finfo
operator|.
name|symbuf
operator|=
operator|(
operator|(
name|Elf_External_Sym
operator|*
operator|)
name|malloc
argument_list|(
name|finfo
operator|.
name|symbuf_size
operator|*
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|symbuf
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
comment|/* Start writing out the symbol table.  The first symbol is always a      dummy symbol.  */
name|elfsym
operator|.
name|st_value
operator|=
literal|0
expr_stmt|;
name|elfsym
operator|.
name|st_size
operator|=
literal|0
expr_stmt|;
name|elfsym
operator|.
name|st_info
operator|=
literal|0
expr_stmt|;
name|elfsym
operator|.
name|st_other
operator|=
literal|0
expr_stmt|;
name|elfsym
operator|.
name|st_shndx
operator|=
name|SHN_UNDEF
expr_stmt|;
if|if
condition|(
operator|!
name|elf_link_output_sym
argument_list|(
operator|&
name|finfo
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|elfsym
argument_list|,
name|bfd_und_section_ptr
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
if|#
directive|if
literal|0
comment|/* Some standard ELF linkers do this, but we don't because it causes      bootstrap comparison failures.  */
comment|/* Output a file symbol for the output file as the second symbol.      We output this even if we are discarding local symbols, although      I'm not sure if this is correct.  */
block|elfsym.st_value = 0;   elfsym.st_size = 0;   elfsym.st_info = ELF_ST_INFO (STB_LOCAL, STT_FILE);   elfsym.st_other = 0;   elfsym.st_shndx = SHN_ABS;   if (! elf_link_output_sym (&finfo, bfd_get_filename (abfd),&elfsym, bfd_abs_section_ptr))     goto error_return;
endif|#
directive|endif
comment|/* Output a symbol for each section.  We output these even if we are      discarding local symbols, since they are used for relocs.  These      symbols have no names.  We store the index of each one in the      index field of the section, so that we can find it again when      outputting relocs.  */
name|elfsym
operator|.
name|st_value
operator|=
literal|0
expr_stmt|;
name|elfsym
operator|.
name|st_size
operator|=
literal|0
expr_stmt|;
name|elfsym
operator|.
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|STB_LOCAL
argument_list|,
name|STT_SECTION
argument_list|)
expr_stmt|;
name|elfsym
operator|.
name|st_other
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_shnum
condition|;
name|i
operator|++
control|)
block|{
name|o
operator|=
name|section_from_elf_index
argument_list|(
name|abfd
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_is_abs_section
argument_list|(
name|o
argument_list|)
condition|)
name|o
operator|->
name|target_index
operator|=
name|abfd
operator|->
name|symcount
expr_stmt|;
name|elfsym
operator|.
name|st_shndx
operator|=
name|i
expr_stmt|;
if|if
condition|(
operator|!
name|elf_link_output_sym
argument_list|(
operator|&
name|finfo
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|elfsym
argument_list|,
name|o
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
comment|/* Allocate some memory to hold information read in from the input      files.  */
name|finfo
operator|.
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|malloc
argument_list|(
name|max_contents_size
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|external_relocs
operator|=
operator|(
name|PTR
operator|)
name|malloc
argument_list|(
name|max_external_reloc_size
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|internal_relocs
operator|=
operator|(
operator|(
name|Elf_Internal_Rela
operator|*
operator|)
name|malloc
argument_list|(
name|max_internal_reloc_count
operator|*
sizeof|sizeof
argument_list|(
name|Elf_Internal_Rela
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|finfo
operator|.
name|external_syms
operator|=
operator|(
operator|(
name|Elf_External_Sym
operator|*
operator|)
name|malloc
argument_list|(
name|max_sym_count
operator|*
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|finfo
operator|.
name|internal_syms
operator|=
operator|(
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|malloc
argument_list|(
name|max_sym_count
operator|*
sizeof|sizeof
argument_list|(
name|Elf_Internal_Sym
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|finfo
operator|.
name|indices
operator|=
operator|(
name|long
operator|*
operator|)
name|malloc
argument_list|(
name|max_sym_count
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|sections
operator|=
operator|(
name|asection
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|max_sym_count
operator|*
sizeof|sizeof
argument_list|(
name|asection
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|finfo
operator|.
name|contents
operator|==
name|NULL
operator|&&
name|max_contents_size
operator|!=
literal|0
operator|)
operator|||
operator|(
name|finfo
operator|.
name|external_relocs
operator|==
name|NULL
operator|&&
name|max_external_reloc_size
operator|!=
literal|0
operator|)
operator|||
operator|(
name|finfo
operator|.
name|internal_relocs
operator|==
name|NULL
operator|&&
name|max_internal_reloc_count
operator|!=
literal|0
operator|)
operator|||
operator|(
name|finfo
operator|.
name|external_syms
operator|==
name|NULL
operator|&&
name|max_sym_count
operator|!=
literal|0
operator|)
operator|||
operator|(
name|finfo
operator|.
name|internal_syms
operator|==
name|NULL
operator|&&
name|max_sym_count
operator|!=
literal|0
operator|)
operator|||
operator|(
name|finfo
operator|.
name|indices
operator|==
name|NULL
operator|&&
name|max_sym_count
operator|!=
literal|0
operator|)
operator|||
operator|(
name|finfo
operator|.
name|sections
operator|==
name|NULL
operator|&&
name|max_sym_count
operator|!=
literal|0
operator|)
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
comment|/* Since ELF permits relocations to be against local symbols, we      must have the local symbols available when we do the relocations.      Since we would rather only read the local symbols once, and we      would rather not keep them in memory, we handle all the      relocations for a single input file at the same time.       Unfortunately, there is no way to know the total number of local      symbols until we have seen all of them, and the local symbol      indices precede the global symbol indices.  This means that when      we are generating relocateable output, and we see a reloc against      a global symbol, we can not know the symbol index until we have      finished examining all the local symbols to see which ones we are      going to output.  To deal with this, we keep the relocations in      memory, and don't output them until the end of the link.  This is      an unfortunate waste of memory, but I don't see a good way around      it.  Fortunately, it only happens when performing a relocateable      link, which is not the common case.  FIXME: If keep_memory is set      we could write the relocs out and then read them again; I don't      know how bad the memory loss will be.  */
for|for
control|(
name|sub
operator|=
name|info
operator|->
name|input_bfds
init|;
name|sub
operator|!=
name|NULL
condition|;
name|sub
operator|=
name|sub
operator|->
name|next
control|)
name|sub
operator|->
name|output_has_begun
operator|=
name|false
expr_stmt|;
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
for|for
control|(
name|p
operator|=
name|o
operator|->
name|link_order_head
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|bfd_indirect_link_order
operator|&&
operator|(
name|bfd_get_flavour
argument_list|(
name|p
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
operator|->
name|owner
argument_list|)
operator|==
name|bfd_target_elf_flavour
operator|)
condition|)
block|{
name|sub
operator|=
name|p
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
operator|->
name|owner
expr_stmt|;
if|if
condition|(
operator|!
name|sub
operator|->
name|output_has_begun
condition|)
block|{
if|if
condition|(
operator|!
name|elf_link_input_bfd
argument_list|(
operator|&
name|finfo
argument_list|,
name|sub
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
name|sub
operator|->
name|output_has_begun
operator|=
name|true
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|bfd_section_reloc_link_order
operator|||
name|p
operator|->
name|type
operator|==
name|bfd_symbol_reloc_link_order
condition|)
block|{
if|if
condition|(
operator|!
name|elf_reloc_link_order
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|o
argument_list|,
name|p
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|_bfd_default_link_order
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|o
argument_list|,
name|p
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
block|}
block|}
comment|/* That wrote out all the local symbols.  Finish up the symbol table      with the global symbols.  */
comment|/* The sh_info field records the index of the first non local      symbol.  */
name|symtab_hdr
operator|->
name|sh_info
operator|=
name|abfd
operator|->
name|symcount
expr_stmt|;
if|if
condition|(
name|dynobj
operator|!=
name|NULL
condition|)
name|elf_section_data
argument_list|(
name|finfo
operator|.
name|dynsym_sec
operator|->
name|output_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_info
operator|=
literal|1
expr_stmt|;
comment|/* We get the global symbols from the hash table.  */
name|elf_link_hash_traverse
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|elf_link_output_extsym
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|finfo
argument_list|)
expr_stmt|;
comment|/* Flush all symbols to the file.  */
if|if
condition|(
operator|!
name|elf_link_flush_output_syms
argument_list|(
operator|&
name|finfo
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Now we know the size of the symtab section.  */
name|off
operator|+=
name|symtab_hdr
operator|->
name|sh_size
expr_stmt|;
comment|/* Finish up the symbol string table (.strtab) section.  */
name|symstrtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|strtab_hdr
expr_stmt|;
comment|/* sh_name was set in prep_headers.  */
name|symstrtab_hdr
operator|->
name|sh_type
operator|=
name|SHT_STRTAB
expr_stmt|;
name|symstrtab_hdr
operator|->
name|sh_flags
operator|=
literal|0
expr_stmt|;
name|symstrtab_hdr
operator|->
name|sh_addr
operator|=
literal|0
expr_stmt|;
name|symstrtab_hdr
operator|->
name|sh_size
operator|=
name|finfo
operator|.
name|symstrtab
operator|->
name|length
expr_stmt|;
name|symstrtab_hdr
operator|->
name|sh_entsize
operator|=
literal|0
expr_stmt|;
name|symstrtab_hdr
operator|->
name|sh_link
operator|=
literal|0
expr_stmt|;
name|symstrtab_hdr
operator|->
name|sh_info
operator|=
literal|0
expr_stmt|;
comment|/* sh_offset is set just below.  */
name|symstrtab_hdr
operator|->
name|sh_addralign
operator|=
literal|1
expr_stmt|;
name|symstrtab_hdr
operator|->
name|contents
operator|=
operator|(
name|PTR
operator|)
name|finfo
operator|.
name|symstrtab
operator|->
name|tab
expr_stmt|;
name|off
operator|=
name|assign_file_position_for_section
argument_list|(
name|symstrtab_hdr
argument_list|,
name|off
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|next_file_pos
operator|=
name|off
expr_stmt|;
comment|/* Adjust the relocs to have the correct symbol indices.  */
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|rel_hash
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|rel_hdr
decl_stmt|;
if|if
condition|(
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|rel_hash
operator|=
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|rel_hashes
expr_stmt|;
name|rel_hdr
operator|=
operator|&
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|rel_hdr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|o
operator|->
name|reloc_count
condition|;
name|i
operator|++
operator|,
name|rel_hash
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|rel_hash
operator|==
name|NULL
condition|)
continue|continue;
name|BFD_ASSERT
argument_list|(
operator|(
operator|*
name|rel_hash
operator|)
operator|->
name|indx
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rel_hdr
operator|->
name|sh_entsize
operator|==
sizeof|sizeof
argument_list|(
name|Elf_External_Rel
argument_list|)
condition|)
block|{
name|Elf_External_Rel
modifier|*
name|erel
decl_stmt|;
name|Elf_Internal_Rel
name|irel
decl_stmt|;
name|erel
operator|=
operator|(
name|Elf_External_Rel
operator|*
operator|)
name|rel_hdr
operator|->
name|contents
operator|+
name|i
expr_stmt|;
name|elf_swap_reloc_in
argument_list|(
name|abfd
argument_list|,
name|erel
argument_list|,
operator|&
name|irel
argument_list|)
expr_stmt|;
name|irel
operator|.
name|r_info
operator|=
name|ELF_R_INFO
argument_list|(
operator|(
operator|*
name|rel_hash
operator|)
operator|->
name|indx
argument_list|,
name|ELF_R_TYPE
argument_list|(
name|irel
operator|.
name|r_info
argument_list|)
argument_list|)
expr_stmt|;
name|elf_swap_reloc_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|irel
argument_list|,
name|erel
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Elf_External_Rela
modifier|*
name|erela
decl_stmt|;
name|Elf_Internal_Rela
name|irela
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|rel_hdr
operator|->
name|sh_entsize
operator|==
sizeof|sizeof
argument_list|(
name|Elf_External_Rela
argument_list|)
argument_list|)
expr_stmt|;
name|erela
operator|=
operator|(
name|Elf_External_Rela
operator|*
operator|)
name|rel_hdr
operator|->
name|contents
operator|+
name|i
expr_stmt|;
name|elf_swap_reloca_in
argument_list|(
name|abfd
argument_list|,
name|erela
argument_list|,
operator|&
name|irela
argument_list|)
expr_stmt|;
name|irela
operator|.
name|r_info
operator|=
name|ELF_R_INFO
argument_list|(
operator|(
operator|*
name|rel_hash
operator|)
operator|->
name|indx
argument_list|,
name|ELF_R_TYPE
argument_list|(
name|irela
operator|.
name|r_info
argument_list|)
argument_list|)
expr_stmt|;
name|elf_swap_reloca_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|irela
argument_list|,
name|erela
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Set the reloc_count field to 0 to prevent write_relocs from 	 trying to swap the relocs out itself.  */
name|o
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If we are linking against a dynamic object, finish up the dynamic      linking information.  */
if|if
condition|(
name|dynobj
operator|!=
name|NULL
condition|)
block|{
name|Elf_External_Dyn
modifier|*
name|dyncon
decl_stmt|,
modifier|*
name|dynconend
decl_stmt|;
comment|/* Fix up .dynamic entries.  */
name|o
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|o
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dyncon
operator|=
operator|(
name|Elf_External_Dyn
operator|*
operator|)
name|o
operator|->
name|contents
expr_stmt|;
name|dynconend
operator|=
operator|(
name|Elf_External_Dyn
operator|*
operator|)
operator|(
name|o
operator|->
name|contents
operator|+
name|o
operator|->
name|_raw_size
operator|)
expr_stmt|;
for|for
control|(
init|;
name|dyncon
operator|<
name|dynconend
condition|;
name|dyncon
operator|++
control|)
block|{
name|Elf_Internal_Dyn
name|dyn
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|int
name|type
decl_stmt|;
name|elf_swap_dyn_in
argument_list|(
name|dynobj
argument_list|,
name|dyncon
argument_list|,
operator|&
name|dyn
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dyn
operator|.
name|d_tag
condition|)
block|{
default|default:
break|break;
case|case
name|DT_INIT
case|:
name|name
operator|=
literal|".init"
expr_stmt|;
goto|goto
name|get_vma
goto|;
case|case
name|DT_FINI
case|:
name|name
operator|=
literal|".fini"
expr_stmt|;
goto|goto
name|get_vma
goto|;
case|case
name|DT_HASH
case|:
name|name
operator|=
literal|".hash"
expr_stmt|;
goto|goto
name|get_vma
goto|;
case|case
name|DT_STRTAB
case|:
name|name
operator|=
literal|".dynstr"
expr_stmt|;
goto|goto
name|get_vma
goto|;
case|case
name|DT_SYMTAB
case|:
name|name
operator|=
literal|".dynsym"
expr_stmt|;
name|get_vma
label|:
name|o
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|o
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
name|o
operator|->
name|vma
expr_stmt|;
name|elf_swap_dyn_out
argument_list|(
name|dynobj
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_REL
case|:
case|case
name|DT_RELA
case|:
case|case
name|DT_RELSZ
case|:
case|case
name|DT_RELASZ
case|:
if|if
condition|(
name|dyn
operator|.
name|d_tag
operator|==
name|DT_REL
operator|||
name|dyn
operator|.
name|d_tag
operator|==
name|DT_RELSZ
condition|)
name|type
operator|=
name|SHT_REL
expr_stmt|;
else|else
name|type
operator|=
name|SHT_RELA
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_shnum
condition|;
name|i
operator|++
control|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
name|hdr
operator|=
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|sh_type
operator|==
name|type
operator|&&
operator|(
name|hdr
operator|->
name|sh_flags
operator|&
name|SHF_ALLOC
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|dyn
operator|.
name|d_tag
operator|==
name|DT_RELSZ
operator|||
name|dyn
operator|.
name|d_tag
operator|==
name|DT_RELASZ
condition|)
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|+=
name|hdr
operator|->
name|sh_size
expr_stmt|;
else|else
block|{
if|if
condition|(
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|==
literal|0
operator|||
name|hdr
operator|->
name|sh_addr
operator|<
name|dyn
operator|.
name|d_un
operator|.
name|d_val
condition|)
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|hdr
operator|->
name|sh_addr
expr_stmt|;
block|}
block|}
block|}
name|elf_swap_dyn_out
argument_list|(
name|dynobj
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
call|(
modifier|*
name|bed
operator|->
name|elf_backend_finish_dynamic_sections
call|)
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
for|for
control|(
name|o
operator|=
name|dynobj
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_IN_MEMORY
operator|)
operator|==
literal|0
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|info
operator|->
name|shared
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|o
operator|->
name|output_section
argument_list|,
name|o
operator|->
name|contents
argument_list|,
name|o
operator|->
name|output_offset
argument_list|,
name|o
operator|->
name|_raw_size
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
block|}
comment|/* Now backend stuff.  */
if|if
condition|(
name|bed
operator|->
name|elf_backend_final_write_processing
condition|)
call|(
modifier|*
name|bed
operator|->
name|elf_backend_final_write_processing
call|)
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|contents
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|contents
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|external_relocs
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|external_relocs
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|internal_relocs
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|internal_relocs
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|external_syms
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|external_syms
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|internal_syms
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|internal_syms
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|indices
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|indices
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|sections
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|sections
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|symbuf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|symbuf
argument_list|)
expr_stmt|;
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|!=
literal|0
operator|&&
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|rel_hashes
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|rel_hashes
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
name|error_return
label|:
if|if
condition|(
name|finfo
operator|.
name|contents
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|contents
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|external_relocs
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|external_relocs
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|internal_relocs
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|internal_relocs
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|external_syms
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|external_syms
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|internal_syms
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|internal_syms
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|indices
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|indices
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|sections
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|sections
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|symbuf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|symbuf
argument_list|)
expr_stmt|;
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|!=
literal|0
operator|&&
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|rel_hashes
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|rel_hashes
argument_list|)
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Add a symbol to the output symbol table.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf_link_output_sym
parameter_list|(
name|finfo
parameter_list|,
name|name
parameter_list|,
name|elfsym
parameter_list|,
name|input_sec
parameter_list|)
name|struct
name|elf_final_link_info
modifier|*
name|finfo
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|elfsym
decl_stmt|;
name|asection
modifier|*
name|input_sec
decl_stmt|;
block|{
name|boolean
argument_list|(
argument|*output_symbol_hook
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|,
specifier|const
name|char
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|,
name|asection
operator|*
operator|)
argument_list|)
expr_stmt|;
name|output_symbol_hook
operator|=
name|get_elf_backend_data
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|)
operator|->
name|elf_backend_link_output_symbol_hook
expr_stmt|;
if|if
condition|(
name|output_symbol_hook
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|output_symbol_hook
call|)
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|,
name|finfo
operator|->
name|info
argument_list|,
name|name
argument_list|,
name|elfsym
argument_list|,
name|input_sec
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|name
operator|==
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
operator|||
operator|*
name|name
operator|==
literal|'\0'
condition|)
name|elfsym
operator|->
name|st_name
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|elfsym
operator|->
name|st_name
operator|=
name|bfd_add_to_strtab
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|,
name|finfo
operator|->
name|symstrtab
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|elfsym
operator|->
name|st_name
operator|==
operator|(
name|unsigned
name|long
operator|)
operator|-
literal|1
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|finfo
operator|->
name|symbuf_count
operator|>=
name|finfo
operator|->
name|symbuf_size
condition|)
block|{
if|if
condition|(
operator|!
name|elf_link_flush_output_syms
argument_list|(
name|finfo
argument_list|)
condition|)
return|return
name|false
return|;
block|}
name|elf_swap_symbol_out
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|,
name|elfsym
argument_list|,
name|finfo
operator|->
name|symbuf
operator|+
name|finfo
operator|->
name|symbuf_count
argument_list|)
expr_stmt|;
operator|++
name|finfo
operator|->
name|symbuf_count
expr_stmt|;
operator|++
name|finfo
operator|->
name|output_bfd
operator|->
name|symcount
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Flush the output symbols to the file.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf_link_flush_output_syms
parameter_list|(
name|finfo
parameter_list|)
name|struct
name|elf_final_link_info
modifier|*
name|finfo
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab
decl_stmt|;
name|symtab
operator|=
operator|&
name|elf_tdata
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|,
name|symtab
operator|->
name|sh_offset
operator|+
name|symtab
operator|->
name|sh_size
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|finfo
operator|->
name|symbuf
argument_list|,
name|finfo
operator|->
name|symbuf_count
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
argument_list|,
name|finfo
operator|->
name|output_bfd
argument_list|)
operator|!=
name|finfo
operator|->
name|symbuf_count
operator|*
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
name|symtab
operator|->
name|sh_size
operator|+=
name|finfo
operator|->
name|symbuf_count
operator|*
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
expr_stmt|;
name|finfo
operator|->
name|symbuf_count
operator|=
literal|0
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Add an external symbol to the symbol table.  This is called from    the hash table traversal routine.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf_link_output_extsym
parameter_list|(
name|h
parameter_list|,
name|data
parameter_list|)
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|PTR
name|data
decl_stmt|;
block|{
name|struct
name|elf_final_link_info
modifier|*
name|finfo
init|=
operator|(
expr|struct
name|elf_final_link_info
operator|*
operator|)
name|data
decl_stmt|;
name|boolean
name|strip
decl_stmt|;
name|Elf_Internal_Sym
name|sym
decl_stmt|;
name|asection
modifier|*
name|input_sec
decl_stmt|;
comment|/* We don't want to output symbols that have never been mentioned by      a regular file, or that we have been told to strip.  However, if      h->indx is set to -2, the symbol is used by a reloc and we must      output it.  */
if|if
condition|(
name|h
operator|->
name|indx
operator|==
operator|-
literal|2
condition|)
name|strip
operator|=
name|false
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|!=
literal|0
operator|||
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_REF_DYNAMIC
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_REF_REGULAR
operator|)
operator|==
literal|0
condition|)
name|strip
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|finfo
operator|->
name|info
operator|->
name|strip
operator|==
name|strip_all
operator|||
operator|(
name|finfo
operator|->
name|info
operator|->
name|strip
operator|==
name|strip_some
operator|&&
name|bfd_hash_lookup
argument_list|(
name|finfo
operator|->
name|info
operator|->
name|keep_hash
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
operator|==
name|NULL
operator|)
condition|)
name|strip
operator|=
name|true
expr_stmt|;
else|else
name|strip
operator|=
name|false
expr_stmt|;
comment|/* If we're stripping it, and it's not a dynamic symbol, there's      nothing else to do.  */
if|if
condition|(
name|strip
operator|&&
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
condition|)
return|return
name|true
return|;
name|sym
operator|.
name|st_value
operator|=
literal|0
expr_stmt|;
name|sym
operator|.
name|st_size
operator|=
name|h
operator|->
name|size
expr_stmt|;
name|sym
operator|.
name|st_other
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_weak
operator|||
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEFINED_WEAK
operator|)
operator|!=
literal|0
condition|)
name|sym
operator|.
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|STB_WEAK
argument_list|,
name|h
operator|->
name|type
argument_list|)
expr_stmt|;
else|else
name|sym
operator|.
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|STB_GLOBAL
argument_list|,
name|h
operator|->
name|type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|h
operator|->
name|root
operator|.
name|type
condition|)
block|{
default|default:
case|case
name|bfd_link_hash_new
case|:
name|abort
argument_list|()
expr_stmt|;
return|return
name|false
return|;
case|case
name|bfd_link_hash_undefined
case|:
name|input_sec
operator|=
name|bfd_und_section_ptr
expr_stmt|;
name|sym
operator|.
name|st_shndx
operator|=
name|SHN_UNDEF
expr_stmt|;
break|break;
case|case
name|bfd_link_hash_weak
case|:
name|input_sec
operator|=
name|bfd_und_section_ptr
expr_stmt|;
name|sym
operator|.
name|st_shndx
operator|=
name|SHN_UNDEF
expr_stmt|;
break|break;
case|case
name|bfd_link_hash_defined
case|:
block|{
name|input_sec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
if|if
condition|(
name|input_sec
operator|->
name|output_section
operator|!=
name|NULL
condition|)
block|{
name|sym
operator|.
name|st_shndx
operator|=
name|elf_section_from_bfd_section
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|,
name|input_sec
operator|->
name|output_section
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|.
name|st_shndx
operator|==
operator|(
name|unsigned
name|short
operator|)
operator|-
literal|1
condition|)
block|{
comment|/* FIXME: No way to handle errors.  */
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* ELF symbols in relocateable files are section relative, 	       but in nonrelocateable files they are virtual 	       addresses.  */
name|sym
operator|.
name|st_value
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|input_sec
operator|->
name|output_offset
expr_stmt|;
if|if
condition|(
operator|!
name|finfo
operator|->
name|info
operator|->
name|relocateable
condition|)
name|sym
operator|.
name|st_value
operator|+=
name|input_sec
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
block|}
else|else
block|{
name|BFD_ASSERT
argument_list|(
name|bfd_get_flavour
argument_list|(
name|input_sec
operator|->
name|owner
argument_list|)
operator|==
name|bfd_target_elf_flavour
operator|&&
name|elf_elfheader
argument_list|(
name|input_sec
operator|->
name|owner
argument_list|)
operator|->
name|e_type
operator|==
name|ET_DYN
argument_list|)
expr_stmt|;
name|sym
operator|.
name|st_shndx
operator|=
name|SHN_UNDEF
expr_stmt|;
name|input_sec
operator|=
name|bfd_und_section_ptr
expr_stmt|;
block|}
block|}
break|break;
case|case
name|bfd_link_hash_common
case|:
name|input_sec
operator|=
name|bfd_com_section_ptr
expr_stmt|;
name|sym
operator|.
name|st_shndx
operator|=
name|SHN_COMMON
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|align
operator|==
literal|0
condition|)
name|sym
operator|.
name|st_value
operator|=
literal|1
expr_stmt|;
else|else
name|sym
operator|.
name|st_value
operator|=
name|h
operator|->
name|align
expr_stmt|;
break|break;
case|case
name|bfd_link_hash_indirect
case|:
case|case
name|bfd_link_hash_warning
case|:
comment|/* I have no idea how these should be handled.  */
return|return
name|true
return|;
block|}
comment|/* If this symbol should be put in the .dynsym section, then put it      there now.  We have already know the symbol index.  We also fill      in the entry in the .hash section.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
condition|)
block|{
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
name|size_t
name|bucketcount
decl_stmt|;
name|size_t
name|bucket
decl_stmt|;
name|bfd_byte
modifier|*
name|bucketpos
decl_stmt|;
name|bfd_vma
name|chain
decl_stmt|;
name|sym
operator|.
name|st_name
operator|=
name|h
operator|->
name|dynstr_index
expr_stmt|;
comment|/* Give the processor backend a chance to tweak the symbol 	 value, and also to finish up anything that needs to be done 	 for this symbol.  */
name|bed
operator|=
name|get_elf_backend_data
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|bed
operator|->
name|elf_backend_finish_dynamic_symbol
call|)
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|,
name|finfo
operator|->
name|info
argument_list|,
name|h
argument_list|,
operator|&
name|sym
argument_list|)
operator|)
condition|)
block|{
comment|/* FIXME: No way to return error.  */
name|abort
argument_list|()
expr_stmt|;
block|}
name|elf_swap_symbol_out
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|,
operator|&
name|sym
argument_list|,
operator|(
operator|(
name|Elf_External_Sym
operator|*
operator|)
name|finfo
operator|->
name|dynsym_sec
operator|->
name|contents
operator|+
name|h
operator|->
name|dynindx
operator|)
argument_list|)
expr_stmt|;
name|bucketcount
operator|=
name|elf_hash_table
argument_list|(
name|finfo
operator|->
name|info
argument_list|)
operator|->
name|bucketcount
expr_stmt|;
name|bucket
operator|=
name|bfd_elf_hash
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
operator|%
name|bucketcount
expr_stmt|;
name|bucketpos
operator|=
operator|(
operator|(
name|bfd_byte
operator|*
operator|)
name|finfo
operator|->
name|hash_sec
operator|->
name|contents
operator|+
operator|(
name|bucket
operator|+
literal|2
operator|)
operator|*
operator|(
name|ARCH_SIZE
operator|/
literal|8
operator|)
operator|)
expr_stmt|;
name|chain
operator|=
name|get_word
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|,
name|bucketpos
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|,
name|h
operator|->
name|dynindx
argument_list|,
name|bucketpos
argument_list|)
expr_stmt|;
name|put_word
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|,
name|chain
argument_list|,
operator|(
operator|(
name|bfd_byte
operator|*
operator|)
name|finfo
operator|->
name|hash_sec
operator|->
name|contents
operator|+
operator|(
name|bucketcount
operator|+
literal|2
operator|+
name|h
operator|->
name|dynindx
operator|)
operator|*
operator|(
name|ARCH_SIZE
operator|/
literal|8
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* If we're stripping it, then it was just a dynamic symbol, and      there's nothing else to do.  */
if|if
condition|(
name|strip
condition|)
return|return
name|true
return|;
name|h
operator|->
name|indx
operator|=
name|finfo
operator|->
name|output_bfd
operator|->
name|symcount
expr_stmt|;
if|if
condition|(
operator|!
name|elf_link_output_sym
argument_list|(
name|finfo
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
operator|&
name|sym
argument_list|,
name|input_sec
argument_list|)
condition|)
block|{
comment|/* FIXME: No way to return error.  */
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Link an input file into the linker output file.  This function    handles all the sections and relocations of the input file at once.    This is so that we only have to read the local symbols once, and    don't have to keep them in memory.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf_link_input_bfd
parameter_list|(
name|finfo
parameter_list|,
name|input_bfd
parameter_list|)
name|struct
name|elf_final_link_info
modifier|*
name|finfo
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
block|{
name|boolean
argument_list|(
argument|*relocate_section
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|,
name|asection
operator|*
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
expr_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|size_t
name|locsymcount
decl_stmt|;
name|size_t
name|extsymoff
decl_stmt|;
name|Elf_External_Sym
modifier|*
name|esym
decl_stmt|;
name|Elf_External_Sym
modifier|*
name|esymend
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isym
decl_stmt|;
name|long
modifier|*
name|pindex
decl_stmt|;
name|asection
modifier|*
modifier|*
name|ppsection
decl_stmt|;
name|asection
modifier|*
name|o
decl_stmt|;
name|output_bfd
operator|=
name|finfo
operator|->
name|output_bfd
expr_stmt|;
name|relocate_section
operator|=
name|get_elf_backend_data
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|elf_backend_relocate_section
expr_stmt|;
comment|/* If this is a dynamic object, we don't want to do anything here:      we don't want the local symbols, and we don't want the section      contents.  */
if|if
condition|(
name|elf_elfheader
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|e_type
operator|==
name|ET_DYN
condition|)
return|return
name|true
return|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
if|if
condition|(
name|elf_bad_symtab
argument_list|(
name|input_bfd
argument_list|)
condition|)
block|{
name|locsymcount
operator|=
name|symtab_hdr
operator|->
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
expr_stmt|;
name|extsymoff
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|locsymcount
operator|=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|extsymoff
operator|=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
block|}
comment|/* Read the local symbols.  */
if|if
condition|(
name|locsymcount
operator|>
literal|0
operator|&&
operator|(
name|bfd_seek
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
operator|->
name|sh_offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|bfd_read
argument_list|(
name|finfo
operator|->
name|external_syms
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
argument_list|,
name|locsymcount
argument_list|,
name|input_bfd
argument_list|)
operator|!=
name|locsymcount
operator|*
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
operator|)
operator|)
condition|)
return|return
name|false
return|;
comment|/* Swap in the local symbols and write out the ones which we know      are going into the output file.  */
name|esym
operator|=
name|finfo
operator|->
name|external_syms
expr_stmt|;
name|esymend
operator|=
name|esym
operator|+
name|locsymcount
expr_stmt|;
name|isym
operator|=
name|finfo
operator|->
name|internal_syms
expr_stmt|;
name|pindex
operator|=
name|finfo
operator|->
name|indices
expr_stmt|;
name|ppsection
operator|=
name|finfo
operator|->
name|sections
expr_stmt|;
for|for
control|(
init|;
name|esym
operator|<
name|esymend
condition|;
name|esym
operator|++
operator|,
name|isym
operator|++
operator|,
name|pindex
operator|++
operator|,
name|ppsection
operator|++
control|)
block|{
name|asection
modifier|*
name|isec
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|bfd_vma
name|oldval
decl_stmt|;
name|elf_swap_symbol_in
argument_list|(
name|input_bfd
argument_list|,
name|esym
argument_list|,
name|isym
argument_list|)
expr_stmt|;
operator|*
name|pindex
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|elf_bad_symtab
argument_list|(
name|input_bfd
argument_list|)
condition|)
block|{
if|if
condition|(
name|ELF_ST_BIND
argument_list|(
name|isym
operator|->
name|st_info
argument_list|)
operator|!=
name|STB_LOCAL
condition|)
block|{
operator|*
name|ppsection
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_UNDEF
condition|)
name|isec
operator|=
name|bfd_und_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|>
literal|0
operator|&&
name|isym
operator|->
name|st_shndx
operator|<
name|SHN_LORESERVE
condition|)
block|{
name|isec
operator|=
name|section_from_elf_index
argument_list|(
name|input_bfd
argument_list|,
name|isym
operator|->
name|st_shndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|isec
operator|==
name|NULL
condition|)
return|return
name|false
return|;
block|}
elseif|else
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_ABS
condition|)
name|isec
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_COMMON
condition|)
name|isec
operator|=
name|bfd_com_section_ptr
expr_stmt|;
else|else
block|{
comment|/* Who knows?  */
name|isec
operator|=
name|NULL
expr_stmt|;
block|}
operator|*
name|ppsection
operator|=
name|isec
expr_stmt|;
comment|/* Don't output the first, undefined, symbol.  */
if|if
condition|(
name|esym
operator|==
name|finfo
operator|->
name|external_syms
condition|)
continue|continue;
comment|/* If we are stripping all symbols, we don't want to output this 	 one.  */
if|if
condition|(
name|finfo
operator|->
name|info
operator|->
name|strip
operator|==
name|strip_all
condition|)
continue|continue;
comment|/* We never output section symbols.  Instead, we use the section 	 symbol of the corresponding section in the output file.  */
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|isym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_SECTION
condition|)
continue|continue;
comment|/* If we are discarding all local symbols, we don't want to 	 output this one.  If we are generating a relocateable output 	 file, then some of the local symbols may be required by 	 relocs; we output them below as we discover that they are 	 needed.  */
if|if
condition|(
name|finfo
operator|->
name|info
operator|->
name|discard
operator|==
name|discard_all
condition|)
continue|continue;
comment|/* Get the name of the symbol.  */
name|name
operator|=
name|elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
operator|->
name|sh_link
argument_list|,
name|isym
operator|->
name|st_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|false
return|;
comment|/* See if we are discarding symbols with this name.  */
if|if
condition|(
operator|(
name|finfo
operator|->
name|info
operator|->
name|strip
operator|==
name|strip_some
operator|&&
operator|(
name|bfd_hash_lookup
argument_list|(
name|finfo
operator|->
name|info
operator|->
name|keep_hash
argument_list|,
name|name
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
operator|==
name|NULL
operator|)
operator|)
operator|||
operator|(
name|finfo
operator|->
name|info
operator|->
name|discard
operator|==
name|discard_l
operator|&&
name|strncmp
argument_list|(
name|name
argument_list|,
name|finfo
operator|->
name|info
operator|->
name|lprefix
argument_list|,
name|finfo
operator|->
name|info
operator|->
name|lprefix_len
argument_list|)
operator|==
literal|0
operator|)
condition|)
continue|continue;
comment|/* If we get here, we are going to output this symbol.  */
comment|/* Adjust the section index for the output file.  */
name|isym
operator|->
name|st_shndx
operator|=
name|elf_section_from_bfd_section
argument_list|(
name|output_bfd
argument_list|,
name|isec
operator|->
name|output_section
argument_list|)
expr_stmt|;
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
operator|(
name|unsigned
name|short
operator|)
operator|-
literal|1
condition|)
return|return
name|false
return|;
operator|*
name|pindex
operator|=
name|output_bfd
operator|->
name|symcount
expr_stmt|;
comment|/* ELF symbols in relocateable files are section relative, but 	 in executable files they are virtual addresses.  Note that 	 this code assumes that all ELF sections have an associated 	 BFD section with a reasonable value for output_offset; below 	 we assume that they also have a reasonable value for 	 output_section.  Any special sections must be set up to meet 	 these requirements.  */
name|oldval
operator|=
name|isym
operator|->
name|st_value
expr_stmt|;
name|isym
operator|->
name|st_value
operator|+=
name|isec
operator|->
name|output_offset
expr_stmt|;
if|if
condition|(
operator|!
name|finfo
operator|->
name|info
operator|->
name|relocateable
condition|)
name|isym
operator|->
name|st_value
operator|+=
name|isec
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
if|if
condition|(
operator|!
name|elf_link_output_sym
argument_list|(
name|finfo
argument_list|,
name|name
argument_list|,
name|isym
argument_list|,
name|isec
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Restore the old value for reloc handling.  */
name|isym
operator|->
name|st_value
operator|=
name|oldval
expr_stmt|;
block|}
comment|/* Relocate the contents of each section.  */
for|for
control|(
name|o
operator|=
name|input_bfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|input_rel_hdr
decl_stmt|;
if|if
condition|(
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_IN_MEMORY
operator|)
operator|!=
literal|0
operator|&&
name|input_bfd
operator|==
name|elf_hash_table
argument_list|(
name|finfo
operator|->
name|info
argument_list|)
operator|->
name|dynobj
condition|)
block|{
comment|/* Section was created by elf_link_create_dynamic_sections.              FIXME: This test is fragile.  */
continue|continue;
block|}
comment|/* Read the contents of the section.  */
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|input_bfd
argument_list|,
name|o
argument_list|,
name|finfo
operator|->
name|contents
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|o
operator|->
name|_raw_size
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|!=
literal|0
condition|)
block|{
name|PTR
name|external_relocs
decl_stmt|;
comment|/* Get the external relocs.  They may have been cached.  */
name|external_relocs
operator|=
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|relocs
expr_stmt|;
if|if
condition|(
name|external_relocs
operator|==
name|NULL
condition|)
block|{
name|input_rel_hdr
operator|=
operator|&
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|rel_hdr
expr_stmt|;
if|if
condition|(
operator|(
name|bfd_seek
argument_list|(
name|input_bfd
argument_list|,
name|input_rel_hdr
operator|->
name|sh_offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|bfd_read
argument_list|(
name|finfo
operator|->
name|external_relocs
argument_list|,
literal|1
argument_list|,
name|input_rel_hdr
operator|->
name|sh_size
argument_list|,
name|input_bfd
argument_list|)
operator|!=
name|input_rel_hdr
operator|->
name|sh_size
operator|)
condition|)
return|return
name|false
return|;
name|external_relocs
operator|=
name|finfo
operator|->
name|external_relocs
expr_stmt|;
block|}
comment|/* Swap in the relocs.  For convenience, we always produce 	     an Elf_Internal_Rela array; if the relocs are Rel, we set 	     the addend to 0.  */
if|if
condition|(
name|input_rel_hdr
operator|->
name|sh_entsize
operator|==
sizeof|sizeof
argument_list|(
name|Elf_External_Rel
argument_list|)
condition|)
block|{
name|Elf_External_Rel
modifier|*
name|erel
decl_stmt|;
name|Elf_External_Rel
modifier|*
name|erelend
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irela
decl_stmt|;
name|erel
operator|=
operator|(
name|Elf_External_Rel
operator|*
operator|)
name|external_relocs
expr_stmt|;
name|erelend
operator|=
name|erel
operator|+
name|o
operator|->
name|reloc_count
expr_stmt|;
name|irela
operator|=
name|finfo
operator|->
name|internal_relocs
expr_stmt|;
for|for
control|(
init|;
name|erel
operator|<
name|erelend
condition|;
name|erel
operator|++
operator|,
name|irela
operator|++
control|)
block|{
name|Elf_Internal_Rel
name|irel
decl_stmt|;
name|elf_swap_reloc_in
argument_list|(
name|input_bfd
argument_list|,
name|erel
argument_list|,
operator|&
name|irel
argument_list|)
expr_stmt|;
name|irela
operator|->
name|r_offset
operator|=
name|irel
operator|.
name|r_offset
expr_stmt|;
name|irela
operator|->
name|r_info
operator|=
name|irel
operator|.
name|r_info
expr_stmt|;
name|irela
operator|->
name|r_addend
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|Elf_External_Rela
modifier|*
name|erela
decl_stmt|;
name|Elf_External_Rela
modifier|*
name|erelaend
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irela
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|input_rel_hdr
operator|->
name|sh_entsize
operator|==
sizeof|sizeof
argument_list|(
name|Elf_External_Rela
argument_list|)
argument_list|)
expr_stmt|;
name|erela
operator|=
operator|(
name|Elf_External_Rela
operator|*
operator|)
name|external_relocs
expr_stmt|;
name|erelaend
operator|=
name|erela
operator|+
name|o
operator|->
name|reloc_count
expr_stmt|;
name|irela
operator|=
name|finfo
operator|->
name|internal_relocs
expr_stmt|;
for|for
control|(
init|;
name|erela
operator|<
name|erelaend
condition|;
name|erela
operator|++
operator|,
name|irela
operator|++
control|)
name|elf_swap_reloca_in
argument_list|(
name|input_bfd
argument_list|,
name|erela
argument_list|,
name|irela
argument_list|)
expr_stmt|;
block|}
comment|/* Relocate the section by invoking a back end routine.  	     The back end routine is responsible for adjusting the 	     section contents as necessary, and (if using Rela relocs 	     and generating a relocateable output file) adjusting the 	     reloc addend as necessary.  	     The back end routine does not have to worry about setting 	     the reloc address or the reloc symbol index.  	     The back end routine is given a pointer to the swapped in 	     internal symbols, and can access the hash table entries 	     for the external symbols via elf_sym_hashes (input_bfd).  	     When generating relocateable output, the back end routine 	     must handle STB_LOCAL/STT_SECTION symbols specially.  The 	     output symbol is going to be a section symbol 	     corresponding to the output section, which will require 	     the addend to be adjusted.  */
if|if
condition|(
operator|!
call|(
modifier|*
name|relocate_section
call|)
argument_list|(
name|output_bfd
argument_list|,
name|finfo
operator|->
name|info
argument_list|,
name|input_bfd
argument_list|,
name|o
argument_list|,
name|finfo
operator|->
name|contents
argument_list|,
name|finfo
operator|->
name|internal_relocs
argument_list|,
name|finfo
operator|->
name|internal_syms
argument_list|,
name|finfo
operator|->
name|sections
argument_list|,
name|finfo
operator|->
name|symstrtab
operator|->
name|tab
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|finfo
operator|->
name|info
operator|->
name|relocateable
condition|)
block|{
name|Elf_Internal_Rela
modifier|*
name|irela
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irelaend
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|rel_hash
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|output_rel_hdr
decl_stmt|;
comment|/* Adjust the reloc addresses and symbol indices.  */
name|irela
operator|=
name|finfo
operator|->
name|internal_relocs
expr_stmt|;
name|irelaend
operator|=
name|irela
operator|+
name|o
operator|->
name|reloc_count
expr_stmt|;
name|rel_hash
operator|=
operator|(
name|elf_section_data
argument_list|(
name|o
operator|->
name|output_section
argument_list|)
operator|->
name|rel_hashes
operator|+
name|o
operator|->
name|output_section
operator|->
name|reloc_count
operator|)
expr_stmt|;
for|for
control|(
init|;
name|irela
operator|<
name|irelaend
condition|;
name|irela
operator|++
operator|,
name|rel_hash
operator|++
control|)
block|{
name|long
name|r_symndx
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isym
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|irela
operator|->
name|r_offset
operator|+=
name|o
operator|->
name|output_offset
expr_stmt|;
name|r_symndx
operator|=
name|ELF_R_SYM
argument_list|(
name|irela
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|r_symndx
operator|>=
name|locsymcount
operator|||
operator|(
name|elf_bad_symtab
argument_list|(
name|input_bfd
argument_list|)
operator|&&
name|finfo
operator|->
name|sections
index|[
name|r_symndx
index|]
operator|==
name|NULL
operator|)
condition|)
block|{
name|long
name|indx
decl_stmt|;
comment|/* This is a reloc against a global symbol.  We 			 have not yet output all the local symbols, so 			 we do not know the symbol index of any global 			 symbol.  We set the rel_hash entry for this 			 reloc to point to the global hash table entry 			 for this symbol.  The symbol index is then 			 set at the end of elf_bfd_final_link.  */
name|indx
operator|=
name|r_symndx
operator|-
name|extsymoff
expr_stmt|;
operator|*
name|rel_hash
operator|=
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
index|[
name|indx
index|]
expr_stmt|;
comment|/* Setting the index to -2 tells 			 elf_link_output_extsym that this symbol is 			 used by a reloc.  */
name|BFD_ASSERT
argument_list|(
operator|(
operator|*
name|rel_hash
operator|)
operator|->
name|indx
operator|<
literal|0
argument_list|)
expr_stmt|;
operator|(
operator|*
name|rel_hash
operator|)
operator|->
name|indx
operator|=
operator|-
literal|2
expr_stmt|;
continue|continue;
block|}
comment|/* This is a reloc against a local symbol. */
operator|*
name|rel_hash
operator|=
name|NULL
expr_stmt|;
name|isym
operator|=
name|finfo
operator|->
name|internal_syms
operator|+
name|r_symndx
expr_stmt|;
name|sec
operator|=
name|finfo
operator|->
name|sections
index|[
name|r_symndx
index|]
expr_stmt|;
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|isym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_SECTION
condition|)
block|{
comment|/* I suppose the backend ought to fill in the 			 section of any STT_SECTION symbol against a 			 processor specific section.  */
if|if
condition|(
name|sec
operator|!=
name|NULL
operator|&&
name|bfd_is_abs_section
argument_list|(
name|sec
argument_list|)
condition|)
name|r_symndx
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|sec
operator|==
name|NULL
operator|||
name|sec
operator|->
name|owner
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
else|else
block|{
name|r_symndx
operator|=
name|sec
operator|->
name|output_section
operator|->
name|target_index
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|finfo
operator|->
name|indices
index|[
name|r_symndx
index|]
operator|==
operator|-
literal|1
condition|)
block|{
name|unsigned
name|long
name|link
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|asection
modifier|*
name|osec
decl_stmt|;
if|if
condition|(
name|finfo
operator|->
name|info
operator|->
name|strip
operator|==
name|strip_all
condition|)
block|{
comment|/* You can't do ld -r -s.  */
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* This symbol was skipped earlier, but 			     since it is needed by a reloc, we 			     must output it now.  */
name|link
operator|=
name|symtab_hdr
operator|->
name|sh_link
expr_stmt|;
name|name
operator|=
name|elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|link
argument_list|,
name|isym
operator|->
name|st_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|osec
operator|=
name|sec
operator|->
name|output_section
expr_stmt|;
name|isym
operator|->
name|st_shndx
operator|=
name|elf_section_from_bfd_section
argument_list|(
name|output_bfd
argument_list|,
name|osec
argument_list|)
expr_stmt|;
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
operator|(
name|unsigned
name|short
operator|)
operator|-
literal|1
condition|)
return|return
name|false
return|;
name|isym
operator|->
name|st_value
operator|+=
name|sec
operator|->
name|output_offset
expr_stmt|;
if|if
condition|(
operator|!
name|finfo
operator|->
name|info
operator|->
name|relocateable
condition|)
name|isym
operator|->
name|st_value
operator|+=
name|osec
operator|->
name|vma
expr_stmt|;
name|finfo
operator|->
name|indices
index|[
name|r_symndx
index|]
operator|=
name|output_bfd
operator|->
name|symcount
expr_stmt|;
if|if
condition|(
operator|!
name|elf_link_output_sym
argument_list|(
name|finfo
argument_list|,
name|name
argument_list|,
name|isym
argument_list|,
name|sec
argument_list|)
condition|)
return|return
name|false
return|;
block|}
name|r_symndx
operator|=
name|finfo
operator|->
name|indices
index|[
name|r_symndx
index|]
expr_stmt|;
block|}
name|irela
operator|->
name|r_info
operator|=
name|ELF_R_INFO
argument_list|(
name|r_symndx
argument_list|,
name|ELF_R_TYPE
argument_list|(
name|irela
operator|->
name|r_info
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Swap out the relocs.  */
name|output_rel_hdr
operator|=
operator|&
name|elf_section_data
argument_list|(
name|o
operator|->
name|output_section
argument_list|)
operator|->
name|rel_hdr
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|output_rel_hdr
operator|->
name|sh_entsize
operator|==
name|input_rel_hdr
operator|->
name|sh_entsize
argument_list|)
expr_stmt|;
name|irela
operator|=
name|finfo
operator|->
name|internal_relocs
expr_stmt|;
name|irelaend
operator|=
name|irela
operator|+
name|o
operator|->
name|reloc_count
expr_stmt|;
if|if
condition|(
name|input_rel_hdr
operator|->
name|sh_entsize
operator|==
sizeof|sizeof
argument_list|(
name|Elf_External_Rel
argument_list|)
condition|)
block|{
name|Elf_External_Rel
modifier|*
name|erel
decl_stmt|;
name|erel
operator|=
operator|(
operator|(
name|Elf_External_Rel
operator|*
operator|)
name|output_rel_hdr
operator|->
name|contents
operator|+
name|o
operator|->
name|output_section
operator|->
name|reloc_count
operator|)
expr_stmt|;
for|for
control|(
init|;
name|irela
operator|<
name|irelaend
condition|;
name|irela
operator|++
operator|,
name|erel
operator|++
control|)
block|{
name|Elf_Internal_Rel
name|irel
decl_stmt|;
name|irel
operator|.
name|r_offset
operator|=
name|irela
operator|->
name|r_offset
expr_stmt|;
name|irel
operator|.
name|r_info
operator|=
name|irela
operator|->
name|r_info
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|irela
operator|->
name|r_addend
operator|==
literal|0
argument_list|)
expr_stmt|;
name|elf_swap_reloc_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|irel
argument_list|,
name|erel
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|Elf_External_Rela
modifier|*
name|erela
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|input_rel_hdr
operator|->
name|sh_entsize
operator|==
sizeof|sizeof
argument_list|(
name|Elf_External_Rela
argument_list|)
argument_list|)
expr_stmt|;
name|erela
operator|=
operator|(
operator|(
name|Elf_External_Rela
operator|*
operator|)
name|output_rel_hdr
operator|->
name|contents
operator|+
name|o
operator|->
name|output_section
operator|->
name|reloc_count
operator|)
expr_stmt|;
for|for
control|(
init|;
name|irela
operator|<
name|irelaend
condition|;
name|irela
operator|++
operator|,
name|erela
operator|++
control|)
name|elf_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
name|irela
argument_list|,
name|erela
argument_list|)
expr_stmt|;
block|}
name|o
operator|->
name|output_section
operator|->
name|reloc_count
operator|+=
name|o
operator|->
name|reloc_count
expr_stmt|;
block|}
block|}
comment|/* Write out the modified section contents.  */
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|output_bfd
argument_list|,
name|o
operator|->
name|output_section
argument_list|,
name|finfo
operator|->
name|contents
argument_list|,
name|o
operator|->
name|output_offset
argument_list|,
operator|(
name|o
operator|->
name|_cooked_size
operator|!=
literal|0
condition|?
name|o
operator|->
name|_cooked_size
else|:
name|o
operator|->
name|_raw_size
operator|)
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Generate a reloc when linking an ELF file.  This is a reloc    requested by the linker, and does come from any input file.  This    is used to build constructor and destructor tables when linking    with -Ur.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf_reloc_link_order
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|,
name|output_section
parameter_list|,
name|link_order
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|asection
modifier|*
name|output_section
decl_stmt|;
name|struct
name|bfd_link_order
modifier|*
name|link_order
decl_stmt|;
block|{
specifier|const
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|long
name|indx
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|rel_hash_ptr
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|rel_hdr
decl_stmt|;
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|output_bfd
argument_list|,
name|link_order
operator|->
name|u
operator|.
name|reloc
operator|.
name|p
operator|->
name|reloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|howto
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* If this is an inplace reloc, we must write the addend into the      object file.  */
if|if
condition|(
name|howto
operator|->
name|partial_inplace
operator|&&
name|link_order
operator|->
name|u
operator|.
name|reloc
operator|.
name|p
operator|->
name|addend
operator|!=
literal|0
condition|)
block|{
name|bfd_size_type
name|size
decl_stmt|;
name|bfd_reloc_status_type
name|rstat
decl_stmt|;
name|bfd_byte
modifier|*
name|buf
decl_stmt|;
name|boolean
name|ok
decl_stmt|;
name|size
operator|=
name|bfd_get_reloc_size
argument_list|(
name|howto
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_zmalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
operator|(
name|bfd_byte
operator|*
operator|)
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|rstat
operator|=
name|_bfd_relocate_contents
argument_list|(
name|howto
argument_list|,
name|output_bfd
argument_list|,
name|link_order
operator|->
name|u
operator|.
name|reloc
operator|.
name|p
operator|->
name|addend
argument_list|,
name|buf
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rstat
condition|)
block|{
case|case
name|bfd_reloc_ok
case|:
break|break;
default|default:
case|case
name|bfd_reloc_outofrange
case|:
name|abort
argument_list|()
expr_stmt|;
case|case
name|bfd_reloc_overflow
case|:
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_overflow
call|)
argument_list|(
name|info
argument_list|,
operator|(
name|link_order
operator|->
name|type
operator|==
name|bfd_section_reloc_link_order
condition|?
name|bfd_section_name
argument_list|(
name|output_bfd
argument_list|,
name|link_order
operator|->
name|u
operator|.
name|reloc
operator|.
name|p
operator|->
name|u
operator|.
name|section
argument_list|)
else|:
name|link_order
operator|->
name|u
operator|.
name|reloc
operator|.
name|p
operator|->
name|u
operator|.
name|name
operator|)
argument_list|,
name|howto
operator|->
name|name
argument_list|,
name|link_order
operator|->
name|u
operator|.
name|reloc
operator|.
name|p
operator|->
name|addend
argument_list|,
operator|(
name|bfd
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|asection
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|)
operator|)
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
break|break;
block|}
name|ok
operator|=
name|bfd_set_section_contents
argument_list|(
name|output_bfd
argument_list|,
name|output_section
argument_list|,
operator|(
name|PTR
operator|)
name|buf
argument_list|,
operator|(
name|file_ptr
operator|)
name|link_order
operator|->
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
name|false
return|;
block|}
comment|/* Figure out the symbol index.  */
name|rel_hash_ptr
operator|=
operator|(
name|elf_section_data
argument_list|(
name|output_section
argument_list|)
operator|->
name|rel_hashes
operator|+
name|output_section
operator|->
name|reloc_count
operator|)
expr_stmt|;
if|if
condition|(
name|link_order
operator|->
name|type
operator|==
name|bfd_section_reloc_link_order
condition|)
block|{
name|indx
operator|=
name|link_order
operator|->
name|u
operator|.
name|reloc
operator|.
name|p
operator|->
name|u
operator|.
name|section
operator|->
name|target_index
expr_stmt|;
if|if
condition|(
name|indx
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
operator|*
name|rel_hash_ptr
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
name|elf_link_hash_lookup
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|link_order
operator|->
name|u
operator|.
name|reloc
operator|.
name|p
operator|->
name|u
operator|.
name|name
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
comment|/* Setting the index to -2 tells elf_link_output_extsym that 	     this symbol is used by a reloc.  */
name|h
operator|->
name|indx
operator|=
operator|-
literal|2
expr_stmt|;
operator|*
name|rel_hash_ptr
operator|=
name|h
expr_stmt|;
name|indx
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|unattached_reloc
call|)
argument_list|(
name|info
argument_list|,
name|link_order
operator|->
name|u
operator|.
name|reloc
operator|.
name|p
operator|->
name|u
operator|.
name|name
argument_list|,
operator|(
name|bfd
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|asection
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
name|indx
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* The address of a reloc is relative to the section in a      relocateable file, and is a virtual address in an executable      file.  */
name|offset
operator|=
name|link_order
operator|->
name|offset
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|relocateable
condition|)
name|offset
operator|+=
name|output_section
operator|->
name|vma
expr_stmt|;
name|rel_hdr
operator|=
operator|&
name|elf_section_data
argument_list|(
name|output_section
argument_list|)
operator|->
name|rel_hdr
expr_stmt|;
if|if
condition|(
name|rel_hdr
operator|->
name|sh_type
operator|==
name|SHT_REL
condition|)
block|{
name|Elf_Internal_Rel
name|irel
decl_stmt|;
name|Elf_External_Rel
modifier|*
name|erel
decl_stmt|;
name|irel
operator|.
name|r_offset
operator|=
name|offset
expr_stmt|;
name|irel
operator|.
name|r_info
operator|=
name|ELF_R_INFO
argument_list|(
name|indx
argument_list|,
name|howto
operator|->
name|type
argument_list|)
expr_stmt|;
name|erel
operator|=
operator|(
operator|(
name|Elf_External_Rel
operator|*
operator|)
name|rel_hdr
operator|->
name|contents
operator|+
name|output_section
operator|->
name|reloc_count
operator|)
expr_stmt|;
name|elf_swap_reloc_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|irel
argument_list|,
name|erel
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Elf_Internal_Rela
name|irela
decl_stmt|;
name|Elf_External_Rela
modifier|*
name|erela
decl_stmt|;
name|irela
operator|.
name|r_offset
operator|=
name|offset
expr_stmt|;
name|irela
operator|.
name|r_info
operator|=
name|ELF_R_INFO
argument_list|(
name|indx
argument_list|,
name|howto
operator|->
name|type
argument_list|)
expr_stmt|;
name|irela
operator|.
name|r_addend
operator|=
name|link_order
operator|->
name|u
operator|.
name|reloc
operator|.
name|p
operator|->
name|addend
expr_stmt|;
name|erela
operator|=
operator|(
operator|(
name|Elf_External_Rela
operator|*
operator|)
name|rel_hdr
operator|->
name|contents
operator|+
name|output_section
operator|->
name|reloc_count
operator|)
expr_stmt|;
name|elf_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|irela
argument_list|,
name|erela
argument_list|)
expr_stmt|;
block|}
operator|++
name|output_section
operator|->
name|reloc_count
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

end_unit

