begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BFD back-end data structures for ELF files.    Copyright (C) 1992, 1993 Free Software Foundation, Inc.    Written by Cygnus Support.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_LIBELF_H_
end_ifndef

begin_define
define|#
directive|define
name|_LIBELF_H_
value|1
end_define

begin_include
include|#
directive|include
file|"elf/common.h"
end_include

begin_include
include|#
directive|include
file|"elf/internal.h"
end_include

begin_include
include|#
directive|include
file|"elf/external.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_comment
comment|/* If size isn't specified as 64 or 32, NAME macro should fail.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NAME
end_ifndef

begin_if
if|#
directive|if
name|ARCH_SIZE
operator|==
literal|64
end_if

begin_define
define|#
directive|define
name|NAME
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|CAT4(x,64,_,y)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|ARCH_SIZE
operator|==
literal|32
end_if

begin_define
define|#
directive|define
name|NAME
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|CAT4(x,32,_,y)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NAME
end_ifndef

begin_define
define|#
directive|define
name|NAME
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|CAT4(x,NOSIZE,_,y)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ElfNAME
parameter_list|(
name|X
parameter_list|)
value|NAME(Elf,X)
end_define

begin_define
define|#
directive|define
name|elfNAME
parameter_list|(
name|X
parameter_list|)
value|NAME(elf,X)
end_define

begin_comment
comment|/* Information held for an ELF symbol.  The first field is the    corresponding asymbol.  Every symbol is an ELF file is actually a    pointer to this structure, although it is often handled as a    pointer to an asymbol.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
comment|/* The BFD symbol.  */
name|asymbol
name|symbol
decl_stmt|;
comment|/* ELF symbol information.  */
name|Elf_Internal_Sym
name|internal_elf_sym
decl_stmt|;
comment|/* Backend specific information.  */
union|union
block|{
name|unsigned
name|int
name|hppa_arg_reloc
decl_stmt|;
name|PTR
name|mips_extr
decl_stmt|;
name|PTR
name|any
decl_stmt|;
block|}
name|tc_data
union|;
block|}
name|elf_symbol_type
typedef|;
end_typedef

begin_escape
end_escape

begin_comment
comment|/* ELF linker hash table entries.  */
end_comment

begin_struct
struct|struct
name|elf_link_hash_entry
block|{
name|struct
name|bfd_link_hash_entry
name|root
decl_stmt|;
comment|/* Symbol index in output file.  This is initialized to -1.  It is      set to -2 if the symbol is used by a reloc.  */
name|long
name|indx
decl_stmt|;
comment|/* Symbol size.  */
name|bfd_size_type
name|size
decl_stmt|;
comment|/* Symbol alignment (common symbols only).  */
name|bfd_size_type
name|align
decl_stmt|;
comment|/* Symbol index as a dynamic symbol.  Initialized to -1, and remains      -1 if this is not a dynamic symbol.  */
name|long
name|dynindx
decl_stmt|;
comment|/* String table index in .dynstr if this is a dynamic symbol.  */
name|unsigned
name|long
name|dynstr_index
decl_stmt|;
comment|/* If this is a weak defined symbol from a dynamic object, this      field points to a defined symbol with the same value, if there is      one.  Otherwise it is NULL.  */
name|struct
name|elf_link_hash_entry
modifier|*
name|weakdef
decl_stmt|;
comment|/* Symbol type (STT_NOTYPE, STT_OBJECT, etc.).  */
name|char
name|type
decl_stmt|;
comment|/* Some flags; legal values follow.  */
name|unsigned
name|char
name|elf_link_hash_flags
decl_stmt|;
comment|/* Symbol is referenced by a non-shared object.  */
define|#
directive|define
name|ELF_LINK_HASH_REF_REGULAR
value|01
comment|/* Symbol is defined by a non-shared object.  */
define|#
directive|define
name|ELF_LINK_HASH_DEF_REGULAR
value|02
comment|/* Symbol is referenced by a shared object.  */
define|#
directive|define
name|ELF_LINK_HASH_REF_DYNAMIC
value|04
comment|/* Symbol is defined by a shared object.  */
define|#
directive|define
name|ELF_LINK_HASH_DEF_DYNAMIC
value|010
comment|/* Symbol is referenced by two or more shared objects.  */
define|#
directive|define
name|ELF_LINK_HASH_REF_DYNAMIC_MULTIPLE
value|020
comment|/* Symbol is defined by two or more shared objects.  */
define|#
directive|define
name|ELF_LINK_HASH_DEF_DYNAMIC_MULTIPLE
value|040
comment|/* Dynamic symbol has been adjustd.  */
define|#
directive|define
name|ELF_LINK_HASH_DYNAMIC_ADJUSTED
value|0100
comment|/* Symbol is defined as weak.  */
define|#
directive|define
name|ELF_LINK_HASH_DEFINED_WEAK
value|0200
block|}
struct|;
end_struct

begin_comment
comment|/* ELF linker hash table.  */
end_comment

begin_struct
struct|struct
name|elf_link_hash_table
block|{
name|struct
name|bfd_link_hash_table
name|root
decl_stmt|;
comment|/* The first dynamic object found during a link.  We create several      special input sections when linking against dynamic objects, and      we simply attach them to the first one found.  */
name|bfd
modifier|*
name|dynobj
decl_stmt|;
comment|/* The number of symbols found in the link which must be put into      the .dynsym section.  */
name|size_t
name|dynsymcount
decl_stmt|;
comment|/* The string table of dynamic symbols, which becomes the .dynstr      section.  */
name|struct
name|strtab
modifier|*
name|dynstr
decl_stmt|;
comment|/* The number of buckets in the hash table in the .hash section.      This is based on the number of dynamic symbols.  */
name|size_t
name|bucketcount
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Look up an entry in an ELF linker hash table.  */
end_comment

begin_define
define|#
directive|define
name|elf_link_hash_lookup
parameter_list|(
name|table
parameter_list|,
name|string
parameter_list|,
name|create
parameter_list|,
name|copy
parameter_list|,
name|follow
parameter_list|)
define|\
value|((struct elf_link_hash_entry *)					\    bfd_link_hash_lookup (&(table)->root, (string), (create),		\ 			 (copy), (follow)))
end_define

begin_comment
comment|/* Traverse an ELF linker hash table.  */
end_comment

begin_define
define|#
directive|define
name|elf_link_hash_traverse
parameter_list|(
name|table
parameter_list|,
name|func
parameter_list|,
name|info
parameter_list|)
define|\
value|(bfd_link_hash_traverse						\    (&(table)->root,							\     (boolean (*) PARAMS ((struct bfd_link_hash_entry *, PTR))) (func),	\     (info)))
end_define

begin_comment
comment|/* Get the ELF linker hash table from a link_info structure.  */
end_comment

begin_define
define|#
directive|define
name|elf_hash_table
parameter_list|(
name|p
parameter_list|)
value|((struct elf_link_hash_table *) ((p)->hash))
end_define

begin_escape
end_escape

begin_comment
comment|/* Constant information held for an ELF backend.  */
end_comment

begin_struct
struct|struct
name|elf_backend_data
block|{
comment|/* Whether the backend uses REL or RELA relocations.  FIXME: some      ELF backends use both.  When we need to support one, this whole      approach will need to be changed.  */
name|int
name|use_rela_p
decl_stmt|;
comment|/* Whether this backend is 64 bits or not.  FIXME: Who cares?  */
name|int
name|elf_64_p
decl_stmt|;
comment|/* The architecture for this backend.  */
name|enum
name|bfd_architecture
name|arch
decl_stmt|;
comment|/* The ELF machine code (EM_xxxx) for this backend.  */
name|int
name|elf_machine_code
decl_stmt|;
comment|/* The maximum page size for this backend.  */
name|bfd_vma
name|maxpagesize
decl_stmt|;
comment|/* This is true if the linker should act like collect and gather      global constructors and destructors by name.  This is true for      MIPS ELF because the Irix 5 tools can not handle the .init      section.  */
name|boolean
name|collect
decl_stmt|;
comment|/* A function to translate an ELF RELA relocation to a BFD arelent      structure.  */
name|void
argument_list|(
argument|*elf_info_to_howto
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* A function to translate an ELF REL relocation to a BFD arelent      structure.  */
name|void
argument_list|(
argument|*elf_info_to_howto_rel
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|Elf_Internal_Rel
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* A function to determine whether a symbol is global when      partitioning the symbol table into local and global symbols.      This should be NULL for most targets, in which case the correct      thing will be done.  MIPS ELF, at least on the Irix 5, has      special requirements.  */
name|boolean
argument_list|(
argument|*elf_backend_sym_is_global
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asymbol
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* The remaining functions are hooks which are called only if they      are not NULL.  */
comment|/* A function to permit a backend specific check on whether a      particular BFD format is relevant for an object file, and to      permit the backend to set any global information it wishes.  When      this is called elf_elfheader is set, but anything else should be      used with caution.  If this returns false, the check_format      routine will return a bfd_error_wrong_format error.  */
name|boolean
argument_list|(
argument|*elf_backend_object_p
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* A function to do additional symbol processing when reading the      ELF symbol table.  This is where any processor-specific special      section indices are handled.  */
name|void
argument_list|(
argument|*elf_backend_symbol_processing
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asymbol
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* A function to do additional symbol processing after reading the      entire ELF symbol table.  */
name|boolean
argument_list|(
argument|*elf_backend_symbol_table_processing
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|elf_symbol_type
operator|*
operator|,
name|int
operator|)
argument_list|)
expr_stmt|;
comment|/* A function to do additional processing on the ELF section header      just before writing it out.  This is used to set the flags and      type fields for some sections, or to actually write out data for      unusual sections.  */
name|boolean
argument_list|(
argument|*elf_backend_section_processing
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|Elf32_Internal_Shdr
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* A function to handle unusual section types when creating BFD      sections from ELF sections.  */
name|boolean
argument_list|(
argument|*elf_backend_section_from_shdr
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|Elf32_Internal_Shdr
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* A function to set up the ELF section header for a BFD section in      preparation for writing it out.  This is where the flags and type      fields are set for unusual sections.  */
name|boolean
argument_list|(
argument|*elf_backend_fake_sections
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|Elf32_Internal_Shdr
operator|*
operator|,
name|asection
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* A function to get the ELF section index for a BFD section.  If      this returns true, the section was found.  If it is a normal ELF      section, *RETVAL should be left unchanged.  If it is not a normal      ELF section *RETVAL should be set to the SHN_xxxx index.  */
name|boolean
argument_list|(
argument|*elf_backend_section_from_bfd_section
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|Elf32_Internal_Shdr
operator|*
operator|,
name|asection
operator|*
operator|,
name|int
operator|*
name|retval
operator|)
argument_list|)
expr_stmt|;
comment|/* If this field is not NULL, it is called by the add_symbols phase      of a link just before adding a symbol to the global linker hash      table.  It may modify any of the fields as it wishes.  If *NAME      is set to NULL, the symbol will be skipped rather than being      added to the hash table.  This function is responsible for      handling all processor dependent symbol bindings and section      indices, and must set at least *FLAGS and *SEC for each processor      dependent case; failure to do so will cause a link error.  */
name|boolean
argument_list|(
argument|*elf_add_symbol_hook
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|,
specifier|const
name|Elf_Internal_Sym
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
name|name
operator|,
name|flagword
operator|*
name|flags
operator|,
name|asection
operator|*
operator|*
name|sec
operator|,
name|bfd_vma
operator|*
name|value
operator|)
argument_list|)
expr_stmt|;
comment|/* If this field is not NULL, it is called by the elf_link_output_sym      phase of a link for each symbol which will appear in the object file.  */
name|boolean
argument_list|(
argument|*elf_backend_link_output_symbol_hook
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|,
specifier|const
name|char
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|,
name|asection
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* The CREATE_DYNAMIC_SECTIONS function is called by the ELF backend      linker the first time it encounters a dynamic object in the link.      This function must create any sections required for dynamic      linking.  The ABFD argument is a dynamic object.  The .interp,      .dynamic, .dynsym, .dynstr, and .hash functions have already been      created, and this function may modify the section flags if      desired.  This function will normally create the .got and .plt      sections, but different backends have different requirements.  */
name|boolean
argument_list|(
argument|*elf_backend_create_dynamic_sections
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|)
argument_list|)
expr_stmt|;
comment|/* The ADJUST_DYNAMIC_SYMBOL function is called by the ELF backend      linker for every symbol which is defined by a dynamic object and      referenced by a regular object.  This is called after all the      input files have been seen, but before the SIZE_DYNAMIC_SECTIONS      function has been called.  The hash table entry should be      bfd_link_hash_defined, and it should be defined in a section from      a dynamic object.  Dynamic object sections are not included in      the final link, and this function is responsible for changing the      value to something which the rest of the link can deal with.      This will normally involve adding an entry to the .plt or .got or      some such section, and setting the symbol to point to that.  */
name|boolean
argument_list|(
argument|*elf_backend_adjust_dynamic_symbol
argument_list|)
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
name|info
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
name|h
operator|)
argument_list|)
expr_stmt|;
comment|/* The SIZE_DYNAMIC_SECTIONS function is called by the ELF backend      linker after all the linker input files have been seen but before      the sections sizes have been set.  This is called after      ADJUST_DYNAMIC_SYMBOL has been called on all appropriate symbols.      It is only called when linking against a dynamic object.  It must      set the sizes of the dynamic sections, and may fill in their      contents as well.  The generic ELF linker can handle the .dynsym,      .dynstr and .hash sections.  This function must handle the      .interp section and any sections created by the      CREATE_DYNAMIC_SECTIONS entry point.  */
name|boolean
argument_list|(
argument|*elf_backend_size_dynamic_sections
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|output_bfd
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|)
argument_list|)
expr_stmt|;
comment|/* The RELOCATE_SECTION function is called by the ELF backend linker      to handle the relocations for a section.       The relocs are always passed as Rela structures; if the section      actually uses Rel structures, the r_addend field will always be      zero.       This function is responsible for adjust the section contents as      necessary, and (if using Rela relocs and generating a      relocateable output file) adjusting the reloc addend as      necessary.       This function does not have to worry about setting the reloc      address or the reloc symbol index.       LOCAL_SYMS is a pointer to the swapped in local symbols.       LOCAL_SECTIONS is an array giving the section in the input file      corresponding to the st_shndx field of each local symbol.       The global hash table entry for the global symbols can be found      via elf_sym_hashes (input_bfd).       When generating relocateable output, this function must handle      STB_LOCAL/STT_SECTION symbols specially.  The output symbol is      going to be the section symbol corresponding to the output      section, which means that the addend must be adjusted      accordingly.  */
name|boolean
argument_list|(
argument|*elf_backend_relocate_section
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|output_bfd
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|,
name|bfd
operator|*
name|input_bfd
operator|,
name|asection
operator|*
name|input_section
operator|,
name|bfd_byte
operator|*
name|contents
operator|,
name|Elf_Internal_Rela
operator|*
name|relocs
operator|,
name|Elf_Internal_Sym
operator|*
name|local_syms
operator|,
name|asection
operator|*
operator|*
name|local_sections
operator|,
name|char
operator|*
name|output_names
operator|)
argument_list|)
expr_stmt|;
comment|/* The FINISH_DYNAMIC_SYMBOL function is called by the ELF backend      linker just before it writes a symbol out to the .dynsym section.      The processor backend may make any required adjustment to the      symbol.  It may also take the opportunity to set contents of the      dynamic sections.  Note that FINISH_DYNAMIC_SYMBOL is called on      all .dynsym symbols, while ADJUST_DYNAMIC_SYMBOL is only called      on those symbols which are defined by a dynamic object.  */
name|boolean
argument_list|(
argument|*elf_backend_finish_dynamic_symbol
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|output_bfd
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
name|h
operator|,
name|Elf_Internal_Sym
operator|*
name|sym
operator|)
argument_list|)
expr_stmt|;
comment|/* The FINISH_DYNAMIC_SECTIONS function is called by the ELF backend      linker just before it writes all the dynamic sections out to the      output file.  The FINISH_DYNAMIC_SYMBOL will have been called on      all dynamic symbols.  */
name|boolean
argument_list|(
argument|*elf_backend_finish_dynamic_sections
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|output_bfd
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|)
argument_list|)
expr_stmt|;
comment|/* A function to do any beginning processing needed for the ELF file      before building the ELF headers and computing file positions.  */
name|void
argument_list|(
argument|*elf_backend_begin_write_processing
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* A function to do any final processing needed for the ELF file      before writing it out.  */
name|void
argument_list|(
argument|*elf_backend_final_write_processing
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* The swapping table to use when dealing with ECOFF information.      Used for the MIPS ELF .mdebug section.  */
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|elf_backend_ecoff_debug_swap
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|elf_sym_extra
block|{
name|int
name|elf_sym_num
decl_stmt|;
comment|/* sym# after locals/globals are reordered */
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|elf_sym_extra
name|Elf_Sym_Extra
typedef|;
end_typedef

begin_comment
comment|/* Information stored for each BFD section in an ELF file.  This    structure is allocated by elf_new_section_hook.  */
end_comment

begin_struct
struct|struct
name|bfd_elf_section_data
block|{
comment|/* The ELF header for this section.  */
name|Elf_Internal_Shdr
name|this_hdr
decl_stmt|;
comment|/* The ELF header for the reloc section associated with this      section, if any.  */
name|Elf_Internal_Shdr
name|rel_hdr
decl_stmt|;
comment|/* The ELF section number of this section.  Only used for an output      file.  */
name|int
name|this_idx
decl_stmt|;
comment|/* The ELF section number of the reloc section associated with this      section, if any.  Only used for an output file.  */
name|int
name|rel_idx
decl_stmt|;
comment|/* Used by the backend linker to store the symbol hash table entries      associated with relocs against global symbols.  */
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|rel_hashes
decl_stmt|;
comment|/* A pointer to the unswapped external relocs; this may be NULL.  */
name|PTR
name|relocs
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|elf_section_data
parameter_list|(
name|sec
parameter_list|)
value|((struct bfd_elf_section_data*)sec->used_by_bfd)
end_define

begin_define
define|#
directive|define
name|get_elf_backend_data
parameter_list|(
name|abfd
parameter_list|)
define|\
value|((struct elf_backend_data *) (abfd)->xvec->backend_data)
end_define

begin_struct
struct|struct
name|strtab
block|{
name|char
modifier|*
name|tab
decl_stmt|;
name|int
name|nentries
decl_stmt|;
name|int
name|length
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Some private data is stashed away for future use using the tdata pointer    in the bfd structure.  */
end_comment

begin_struct
struct|struct
name|elf_obj_tdata
block|{
name|Elf_Internal_Ehdr
name|elf_header
index|[
literal|1
index|]
decl_stmt|;
comment|/* Actual data, but ref like ptr */
name|Elf_Internal_Shdr
modifier|*
modifier|*
name|elf_sect_ptr
decl_stmt|;
name|Elf_Internal_Phdr
modifier|*
name|phdr
decl_stmt|;
name|struct
name|strtab
modifier|*
name|strtab_ptr
decl_stmt|;
name|int
name|num_locals
decl_stmt|;
name|int
name|num_globals
decl_stmt|;
name|Elf_Sym_Extra
modifier|*
name|sym_extra
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|section_syms
decl_stmt|;
comment|/* STT_SECTION symbols for each section */
name|int
name|num_section_syms
decl_stmt|;
comment|/* number of section_syms allocated */
name|Elf_Internal_Shdr
name|symtab_hdr
decl_stmt|;
name|Elf_Internal_Shdr
name|shstrtab_hdr
decl_stmt|;
name|Elf_Internal_Shdr
name|strtab_hdr
decl_stmt|;
name|Elf_Internal_Shdr
name|dynsymtab_hdr
decl_stmt|;
name|Elf_Internal_Shdr
name|dynstrtab_hdr
decl_stmt|;
name|int
name|symtab_section
decl_stmt|,
name|shstrtab_section
decl_stmt|,
name|strtab_section
decl_stmt|,
name|dynsymtab_section
decl_stmt|;
name|file_ptr
name|next_file_pos
decl_stmt|;
name|void
modifier|*
name|prstatus
decl_stmt|;
comment|/* The raw /proc prstatus structure */
name|void
modifier|*
name|prpsinfo
decl_stmt|;
comment|/* The raw /proc prpsinfo structure */
name|bfd_vma
name|gp
decl_stmt|;
comment|/* The gp value (MIPS only, for now) */
name|int
name|gp_size
decl_stmt|;
comment|/* The gp size (MIPS only, for now) */
comment|/* A mapping from external symbols to entries in the linker hash      table, used when linking.  This is indexed by the symbol index      minus the sh_info field of the symbol table header.  */
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
comment|/* The linker ELF emulation code needs to let the backend ELF linker      know what filename should be used for a dynamic object if the      dynamic object is found using a search.  This field is used to      hold that information.  */
specifier|const
name|char
modifier|*
name|dt_needed_name
decl_stmt|;
comment|/* Irix 5 often screws up the symbol table, sorting local symbols      after global symbols.  This flag is set if the symbol table in      this BFD appears to be screwed up.  If it is, we ignore the      sh_info field in the symbol table header, and always read all the      symbols.  */
name|boolean
name|bad_symtab
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|elf_tdata
parameter_list|(
name|bfd
parameter_list|)
value|((bfd) -> tdata.elf_obj_data)
end_define

begin_define
define|#
directive|define
name|elf_elfheader
parameter_list|(
name|bfd
parameter_list|)
value|(elf_tdata(bfd) -> elf_header)
end_define

begin_define
define|#
directive|define
name|elf_elfsections
parameter_list|(
name|bfd
parameter_list|)
value|(elf_tdata(bfd) -> elf_sect_ptr)
end_define

begin_define
define|#
directive|define
name|elf_shstrtab
parameter_list|(
name|bfd
parameter_list|)
value|(elf_tdata(bfd) -> strtab_ptr)
end_define

begin_define
define|#
directive|define
name|elf_onesymtab
parameter_list|(
name|bfd
parameter_list|)
value|(elf_tdata(bfd) -> symtab_section)
end_define

begin_define
define|#
directive|define
name|elf_dynsymtab
parameter_list|(
name|bfd
parameter_list|)
value|(elf_tdata(bfd) -> dynsymtab_section)
end_define

begin_define
define|#
directive|define
name|elf_num_locals
parameter_list|(
name|bfd
parameter_list|)
value|(elf_tdata(bfd) -> num_locals)
end_define

begin_define
define|#
directive|define
name|elf_num_globals
parameter_list|(
name|bfd
parameter_list|)
value|(elf_tdata(bfd) -> num_globals)
end_define

begin_define
define|#
directive|define
name|elf_sym_extra
parameter_list|(
name|bfd
parameter_list|)
value|(elf_tdata(bfd) -> sym_extra)
end_define

begin_define
define|#
directive|define
name|elf_section_syms
parameter_list|(
name|bfd
parameter_list|)
value|(elf_tdata(bfd) -> section_syms)
end_define

begin_define
define|#
directive|define
name|elf_num_section_syms
parameter_list|(
name|bfd
parameter_list|)
value|(elf_tdata(bfd) -> num_section_syms)
end_define

begin_define
define|#
directive|define
name|core_prpsinfo
parameter_list|(
name|bfd
parameter_list|)
value|(elf_tdata(bfd) -> prpsinfo)
end_define

begin_define
define|#
directive|define
name|core_prstatus
parameter_list|(
name|bfd
parameter_list|)
value|(elf_tdata(bfd) -> prstatus)
end_define

begin_define
define|#
directive|define
name|elf_gp
parameter_list|(
name|bfd
parameter_list|)
value|(elf_tdata(bfd) -> gp)
end_define

begin_define
define|#
directive|define
name|elf_gp_size
parameter_list|(
name|bfd
parameter_list|)
value|(elf_tdata(bfd) -> gp_size)
end_define

begin_define
define|#
directive|define
name|elf_sym_hashes
parameter_list|(
name|bfd
parameter_list|)
value|(elf_tdata(bfd) -> sym_hashes)
end_define

begin_define
define|#
directive|define
name|elf_dt_needed_name
parameter_list|(
name|bfd
parameter_list|)
value|(elf_tdata(bfd) -> dt_needed_name)
end_define

begin_define
define|#
directive|define
name|elf_bad_symtab
parameter_list|(
name|bfd
parameter_list|)
value|(elf_tdata(bfd) -> bad_symtab)
end_define

begin_escape
end_escape

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|elf_string_from_elf_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|unsigned
operator|,
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|elf_get_str_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|bfd_elf32_mkobject
value|bfd_elf_mkobject
end_define

begin_define
define|#
directive|define
name|bfd_elf64_mkobject
value|bfd_elf_mkobject
end_define

begin_define
define|#
directive|define
name|elf_mkobject
value|bfd_elf_mkobject
end_define

begin_decl_stmt
specifier|extern
name|unsigned
name|long
name|bfd_elf_hash
name|PARAMS
argument_list|(
operator|(
name|CONST
name|unsigned
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_reloc_status_type
name|bfd_elf_generic_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|bfd_elf_mkobject
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|Elf_Internal_Shdr
modifier|*
name|bfd_elf_find_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_elf_make_section_from_shdr
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|Elf_Internal_Shdr
operator|*
name|hdr
operator|,
specifier|const
name|char
operator|*
name|name
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|bfd_hash_entry
modifier|*
name|_bfd_elf_link_hash_newfunc
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|,
expr|struct
name|bfd_hash_table
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|bfd_link_hash_table
modifier|*
name|_bfd_elf_link_hash_table_create
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_elf_link_hash_table_init
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf_link_hash_table
operator|*
operator|,
name|bfd
operator|*
operator|,
expr|struct
name|bfd_hash_entry
operator|*
call|(
modifier|*
call|)
argument_list|(
expr|struct
name|bfd_hash_entry
operator|*
argument_list|,
expr|struct
name|bfd_hash_table
operator|*
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|bfd_elf32_write_object_contents
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|bfd_elf64_write_object_contents
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
specifier|const
name|bfd_target
modifier|*
name|bfd_elf32_object_p
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
specifier|const
name|bfd_target
modifier|*
name|bfd_elf32_core_file_p
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|bfd_elf32_core_file_failing_command
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|bfd_elf32_core_file_failing_signal
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|bfd_elf32_core_file_matches_executable_p
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|bfd_elf32_set_section_contents
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|sec_ptr
operator|,
name|PTR
operator|,
name|file_ptr
operator|,
name|bfd_size_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|long
name|bfd_elf32_get_symtab_upper_bound
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|long
name|bfd_elf32_get_symtab
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asymbol
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|long
name|bfd_elf32_get_dynamic_symtab_upper_bound
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|long
name|bfd_elf32_canonicalize_dynamic_symtab
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asymbol
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|long
name|bfd_elf32_get_reloc_upper_bound
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|sec_ptr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|long
name|bfd_elf32_canonicalize_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|sec_ptr
operator|,
name|arelent
operator|*
operator|*
operator|,
name|asymbol
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|asymbol
modifier|*
name|bfd_elf32_make_empty_symbol
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_elf32_print_symbol
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|asymbol
operator|*
operator|,
name|bfd_print_symbol_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_elf32_get_symbol_info
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|symbol_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|alent
modifier|*
name|bfd_elf32_get_lineno
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asymbol
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|bfd_elf32_set_arch_mach
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|enum
name|bfd_architecture
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|bfd_elf32_find_nearest_line
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|asymbol
operator|*
operator|*
operator|,
name|bfd_vma
operator|,
name|CONST
name|char
operator|*
operator|*
operator|,
name|CONST
name|char
operator|*
operator|*
operator|,
name|unsigned
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|bfd_elf32_sizeof_headers
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_elf32__write_relocs
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|bfd_elf32_new_section_hook
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|bfd_elf32_bfd_link_add_symbols
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|bfd_elf32_bfd_final_link
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_elf32_swap_symbol_in
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|Elf32_External_Sym
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_elf32_swap_symbol_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|,
name|Elf32_External_Sym
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_elf32_swap_reloc_in
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|Elf32_External_Rel
operator|*
operator|,
name|Elf_Internal_Rel
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_elf32_swap_reloc_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|Elf_Internal_Rel
operator|*
operator|,
name|Elf32_External_Rel
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_elf32_swap_reloca_in
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|Elf32_External_Rela
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_elf32_swap_reloca_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|,
name|Elf32_External_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_elf32_swap_dyn_in
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf32_External_Dyn
operator|*
operator|,
name|Elf_Internal_Dyn
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_elf32_swap_dyn_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf_Internal_Dyn
operator|*
operator|,
name|Elf32_External_Dyn
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|bfd_elf32_add_dynamic_entry
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
name|bfd_vma
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If the target doesn't have reloc handling written yet:  */
end_comment

begin_decl_stmt
specifier|extern
name|void
name|bfd_elf32_no_info_to_howto
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|Elf32_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
specifier|const
name|bfd_target
modifier|*
name|bfd_elf64_object_p
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
specifier|const
name|bfd_target
modifier|*
name|bfd_elf64_core_file_p
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|bfd_elf64_core_file_failing_command
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|bfd_elf64_core_file_failing_signal
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|bfd_elf64_core_file_matches_executable_p
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|bfd_elf64_set_section_contents
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|sec_ptr
operator|,
name|PTR
operator|,
name|file_ptr
operator|,
name|bfd_size_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|long
name|bfd_elf64_get_symtab_upper_bound
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|long
name|bfd_elf64_get_symtab
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asymbol
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|long
name|bfd_elf64_get_dynamic_symtab_upper_bound
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|long
name|bfd_elf64_canonicalize_dynamic_symtab
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asymbol
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|long
name|bfd_elf64_get_reloc_upper_bound
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|sec_ptr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|long
name|bfd_elf64_canonicalize_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|sec_ptr
operator|,
name|arelent
operator|*
operator|*
operator|,
name|asymbol
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|asymbol
modifier|*
name|bfd_elf64_make_empty_symbol
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_elf64_print_symbol
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|asymbol
operator|*
operator|,
name|bfd_print_symbol_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_elf64_get_symbol_info
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|symbol_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|alent
modifier|*
name|bfd_elf64_get_lineno
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asymbol
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|bfd_elf64_set_arch_mach
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|enum
name|bfd_architecture
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|bfd_elf64_find_nearest_line
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|asymbol
operator|*
operator|*
operator|,
name|bfd_vma
operator|,
name|CONST
name|char
operator|*
operator|*
operator|,
name|CONST
name|char
operator|*
operator|*
operator|,
name|unsigned
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|bfd_elf64_sizeof_headers
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_elf64__write_relocs
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|bfd_elf64_new_section_hook
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|bfd_elf64_bfd_link_add_symbols
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|bfd_elf64_bfd_final_link
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_elf64_swap_symbol_in
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|Elf64_External_Sym
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_elf64_swap_symbol_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|,
name|Elf64_External_Sym
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_elf64_swap_reloc_in
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|Elf64_External_Rel
operator|*
operator|,
name|Elf_Internal_Rel
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_elf64_swap_reloc_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|Elf_Internal_Rel
operator|*
operator|,
name|Elf64_External_Rel
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_elf64_swap_reloca_in
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|Elf64_External_Rela
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_elf64_swap_reloca_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|,
name|Elf64_External_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_elf64_swap_dyn_in
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf64_External_Dyn
operator|*
operator|,
name|Elf_Internal_Dyn
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|bfd_elf64_swap_dyn_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf_Internal_Dyn
operator|*
operator|,
name|Elf64_External_Dyn
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|bfd_elf64_add_dynamic_entry
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
name|bfd_vma
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If the target doesn't have reloc handling written yet:  */
end_comment

begin_decl_stmt
specifier|extern
name|void
name|bfd_elf64_no_info_to_howto
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|Elf64_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _LIBELF_H_ */
end_comment

end_unit

