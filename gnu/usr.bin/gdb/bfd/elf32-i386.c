begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Intel 80386/80486-specific support for 32-bit ELF    Copyright 1993 Free Software Foundation, Inc.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"libelf.h"
end_include

begin_expr_stmt
specifier|static
name|CONST
expr|struct
name|reloc_howto_struct
operator|*
name|elf_i386_reloc_type_lookup
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd_reloc_code_real_type
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|void
name|elf_i386_info_to_howto
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|Elf32_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|elf_i386_info_to_howto_rel
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|Elf32_Internal_Rel
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf_i386_create_dynamic_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf_i386_adjust_dynamic_symbol
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf_i386_allocate_dynamic_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf_i386_size_dynamic_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf_i386_relocate_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|,
name|asection
operator|*
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf_i386_finish_dynamic_symbol
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf_i386_finish_dynamic_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|USE_REL
value|1
end_define

begin_comment
comment|/* 386 uses REL relocations instead of RELA */
end_comment

begin_enum
enum|enum
name|reloc_type
block|{
name|R_386_NONE
init|=
literal|0
block|,
name|R_386_32
block|,
name|R_386_PC32
block|,
name|R_386_GOT32
block|,
name|R_386_PLT32
block|,
name|R_386_COPY
block|,
name|R_386_GLOB_DAT
block|,
name|R_386_JUMP_SLOT
block|,
name|R_386_RELATIVE
block|,
name|R_386_GOTOFF
block|,
name|R_386_GOTPC
block|,
name|R_386_max
block|}
enum|;
end_enum

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static CONST char *CONST reloc_type_names[] = {   "R_386_NONE",   "R_386_32",   "R_386_PC32",   "R_386_GOT32",   "R_386_PLT32",   "R_386_COPY",   "R_386_GLOB_DAT",   "R_386_JUMP_SLOT",   "R_386_RELATIVE",   "R_386_GOTOFF",   "R_386_GOTPC", };
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|elf_howto_table
index|[]
init|=
block|{
name|HOWTO
argument_list|(
name|R_386_NONE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_386_NONE"
argument_list|,
name|true
argument_list|,
literal|0x00000000
argument_list|,
literal|0x00000000
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_386_32
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_386_32"
argument_list|,
name|true
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_386_PC32
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_386_PC32"
argument_list|,
name|true
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_386_GOT32
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_386_GOT32"
argument_list|,
name|true
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_386_PLT32
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_386_PLT32"
argument_list|,
name|true
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_386_COPY
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_386_COPY"
argument_list|,
name|true
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_386_GLOB_DAT
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_386_GLOB_DAT"
argument_list|,
name|true
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_386_JUMP_SLOT
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_386_JUMP_SLOT"
argument_list|,
name|true
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_386_RELATIVE
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_386_RELATIVE"
argument_list|,
name|true
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_386_GOTOFF
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_386_GOTOFF"
argument_list|,
name|true
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_386_GOTPC
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_386_GOTPC"
argument_list|,
name|true
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|false
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG_GEN_RELOC
end_ifdef

begin_define
define|#
directive|define
name|TRACE
parameter_list|(
name|str
parameter_list|)
value|fprintf (stderr, "i386 bfd reloc lookup %d (%s)\n", code, str)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|TRACE
parameter_list|(
name|str
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
specifier|static
name|CONST
expr|struct
name|reloc_howto_struct
operator|*
name|elf_i386_reloc_type_lookup
argument_list|(
argument|abfd
argument_list|,
argument|code
argument_list|)
name|bfd
operator|*
name|abfd
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|bfd_reloc_code_real_type
name|code
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|BFD_RELOC_NONE
case|:
name|TRACE
argument_list|(
literal|"BFD_RELOC_NONE"
argument_list|)
expr_stmt|;
return|return
operator|&
name|elf_howto_table
index|[
operator|(
name|int
operator|)
name|R_386_NONE
index|]
return|;
case|case
name|BFD_RELOC_32
case|:
name|TRACE
argument_list|(
literal|"BFD_RELOC_32"
argument_list|)
expr_stmt|;
return|return
operator|&
name|elf_howto_table
index|[
operator|(
name|int
operator|)
name|R_386_32
index|]
return|;
case|case
name|BFD_RELOC_32_PCREL
case|:
name|TRACE
argument_list|(
literal|"BFD_RELOC_PC32"
argument_list|)
expr_stmt|;
return|return
operator|&
name|elf_howto_table
index|[
operator|(
name|int
operator|)
name|R_386_PC32
index|]
return|;
case|case
name|BFD_RELOC_386_GOT32
case|:
name|TRACE
argument_list|(
literal|"BFD_RELOC_386_GOT32"
argument_list|)
expr_stmt|;
return|return
operator|&
name|elf_howto_table
index|[
operator|(
name|int
operator|)
name|R_386_GOT32
index|]
return|;
case|case
name|BFD_RELOC_386_PLT32
case|:
name|TRACE
argument_list|(
literal|"BFD_RELOC_386_PLT32"
argument_list|)
expr_stmt|;
return|return
operator|&
name|elf_howto_table
index|[
operator|(
name|int
operator|)
name|R_386_PLT32
index|]
return|;
case|case
name|BFD_RELOC_386_COPY
case|:
name|TRACE
argument_list|(
literal|"BFD_RELOC_386_COPY"
argument_list|)
expr_stmt|;
return|return
operator|&
name|elf_howto_table
index|[
operator|(
name|int
operator|)
name|R_386_COPY
index|]
return|;
case|case
name|BFD_RELOC_386_GLOB_DAT
case|:
name|TRACE
argument_list|(
literal|"BFD_RELOC_386_GLOB_DAT"
argument_list|)
expr_stmt|;
return|return
operator|&
name|elf_howto_table
index|[
operator|(
name|int
operator|)
name|R_386_GLOB_DAT
index|]
return|;
case|case
name|BFD_RELOC_386_JUMP_SLOT
case|:
name|TRACE
argument_list|(
literal|"BFD_RELOC_386_JUMP_SLOT"
argument_list|)
expr_stmt|;
return|return
operator|&
name|elf_howto_table
index|[
operator|(
name|int
operator|)
name|R_386_JUMP_SLOT
index|]
return|;
case|case
name|BFD_RELOC_386_RELATIVE
case|:
name|TRACE
argument_list|(
literal|"BFD_RELOC_386_RELATIVE"
argument_list|)
expr_stmt|;
return|return
operator|&
name|elf_howto_table
index|[
operator|(
name|int
operator|)
name|R_386_RELATIVE
index|]
return|;
case|case
name|BFD_RELOC_386_GOTOFF
case|:
name|TRACE
argument_list|(
literal|"BFD_RELOC_386_GOTOFF"
argument_list|)
expr_stmt|;
return|return
operator|&
name|elf_howto_table
index|[
operator|(
name|int
operator|)
name|R_386_GOTOFF
index|]
return|;
case|case
name|BFD_RELOC_386_GOTPC
case|:
name|TRACE
argument_list|(
literal|"BFD_RELOC_386_GOTPC"
argument_list|)
expr_stmt|;
return|return
operator|&
name|elf_howto_table
index|[
operator|(
name|int
operator|)
name|R_386_GOTPC
index|]
return|;
default|default:
break|break;
block|}
name|TRACE
argument_list|(
literal|"Unknown"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_function
specifier|static
name|void
name|elf_i386_info_to_howto
parameter_list|(
name|abfd
parameter_list|,
name|cache_ptr
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|cache_ptr
decl_stmt|;
name|Elf32_Internal_Rela
modifier|*
name|dst
decl_stmt|;
block|{
name|BFD_ASSERT
argument_list|(
name|ELF32_R_TYPE
argument_list|(
name|dst
operator|->
name|r_info
argument_list|)
operator|<
operator|(
name|unsigned
name|int
operator|)
name|R_386_max
argument_list|)
expr_stmt|;
name|cache_ptr
operator|->
name|howto
operator|=
operator|&
name|elf_howto_table
index|[
name|ELF32_R_TYPE
argument_list|(
name|dst
operator|->
name|r_info
argument_list|)
index|]
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|elf_i386_info_to_howto_rel
parameter_list|(
name|abfd
parameter_list|,
name|cache_ptr
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|cache_ptr
decl_stmt|;
name|Elf32_Internal_Rel
modifier|*
name|dst
decl_stmt|;
block|{
name|BFD_ASSERT
argument_list|(
name|ELF32_R_TYPE
argument_list|(
name|dst
operator|->
name|r_info
argument_list|)
operator|<
operator|(
name|unsigned
name|int
operator|)
name|R_386_max
argument_list|)
expr_stmt|;
name|cache_ptr
operator|->
name|howto
operator|=
operator|&
name|elf_howto_table
index|[
name|ELF32_R_TYPE
argument_list|(
name|dst
operator|->
name|r_info
argument_list|)
index|]
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Functions for the i386 ELF linker.  */
end_comment

begin_comment
comment|/* The name of the dynamic interpreter.  This is put in the .interp    section.  */
end_comment

begin_define
define|#
directive|define
name|ELF_DYNAMIC_INTERPRETER
value|"/usr/lib/libc.so.1"
end_define

begin_comment
comment|/* The size in bytes of an entry in the procedure linkage table.  */
end_comment

begin_define
define|#
directive|define
name|PLT_ENTRY_SIZE
value|16
end_define

begin_comment
comment|/* The first entry in an absolute procedure linkage table looks like    this.  See the SVR4 ABI i386 supplement to see how this works.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_byte
name|elf_i386_plt0_entry
index|[
name|PLT_ENTRY_SIZE
index|]
init|=
block|{
literal|0xff
block|,
literal|0x35
block|,
comment|/* pushl contents of address */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* replaced with address of .got + 4.  */
literal|0xff
block|,
literal|0x25
block|,
comment|/* jmp indirect */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* replaced with address of .got + 8.  */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
comment|/* pad out to 16 bytes.  */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Subsequent entries in an absolute procedure linkage table look like    this.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_byte
name|elf_i386_plt_entry
index|[
name|PLT_ENTRY_SIZE
index|]
init|=
block|{
literal|0xff
block|,
literal|0x25
block|,
comment|/* jmp indirect */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* replaced with address of this symbol in .got.  */
literal|0x68
block|,
comment|/* pushl immediate */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* replaced with offset into relocation table.  */
literal|0xe9
block|,
comment|/* jmp relative */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
comment|/* replaced with offset to start of .plt.  */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Create dynamic sections when linking against a dynamic object.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf_i386_create_dynamic_sections
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|flagword
name|flags
decl_stmt|;
specifier|register
name|asection
modifier|*
name|s
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
comment|/* We need to create .plt, .rel.plt, .got, .dynbss, and .rel.bss      sections.  */
name|flags
operator|=
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
expr_stmt|;
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|flags
operator||
name|SEC_READONLY
operator||
name|SEC_CODE
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|false
return|;
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".rel.plt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|flags
operator||
name|SEC_READONLY
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|false
return|;
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|flags
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Define the symbol _GLOBAL_OFFSET_TABLE_ at the start of the .got      section.  We don't do this in the linker script because we don't      want to define the symbol if we are not creating a global offset      table.  */
name|h
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
literal|"_GLOBAL_OFFSET_TABLE_"
argument_list|,
name|BSF_GLOBAL
argument_list|,
name|s
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|false
argument_list|,
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|collect
argument_list|,
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|*
operator|)
operator|&
name|h
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_DEF_REGULAR
expr_stmt|;
comment|/* The first three global offset table entries are reserved.  */
name|s
operator|->
name|_raw_size
operator|+=
literal|3
operator|*
literal|4
expr_stmt|;
comment|/* The .dynbss section is a place to put symbols which are defined      by dynamic objects, are referenced by regular objects, and are      not functions.  We must allocate space for them in the process      image and use a R_386_COPY reloc to tell the dynamic linker to      initialize them at run time.  The linker script puts the .dynbss      section into the .bss section of the final image.  */
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".dynbss"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|SEC_ALLOC
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* The .rel.bss section holds copy relocs.  This section is not      normally needed.  We need to create it here, though, so that the      linker will map it to an output section.  If it turns out not to      be needed, we can discard it later.  */
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".rel.bss"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|flags
operator||
name|SEC_READONLY
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Adjust a symbol defined by a dynamic object and referenced by a    regular object.  The current definition is in some section of the    dynamic object, but we're not including those sections.  We have to    change the definition to something the rest of the link can    understand.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf_i386_adjust_dynamic_symbol
parameter_list|(
name|info
parameter_list|,
name|h
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|unsigned
name|int
name|power_of_two
decl_stmt|;
name|size_t
name|align
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
comment|/* Make sure we know what is going on here.  */
name|BFD_ASSERT
argument_list|(
name|dynobj
operator|!=
name|NULL
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_REF_REGULAR
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|&&
operator|(
name|bfd_get_flavour
argument_list|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
argument_list|)
operator|==
name|bfd_target_elf_flavour
operator|)
operator|&&
operator|(
name|elf_elfheader
argument_list|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
argument_list|)
operator|->
name|e_type
operator|==
name|ET_DYN
operator|)
operator|&&
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* If this is a function, put it in the procedure linkage table.  We      will fill in the contents of the procedure linkage table later,      when we know the address of the .got section.  */
if|if
condition|(
name|h
operator|->
name|type
operator|==
name|STT_FUNC
condition|)
block|{
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* If this is the first .plt entry, make room for the special 	 first entry.  */
if|if
condition|(
name|s
operator|->
name|_raw_size
operator|==
literal|0
condition|)
name|s
operator|->
name|_raw_size
operator|+=
name|PLT_ENTRY_SIZE
expr_stmt|;
comment|/* Set the symbol to this location in the .plt.  */
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|s
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|s
operator|->
name|_raw_size
expr_stmt|;
comment|/* Make room for this entry.  */
name|s
operator|->
name|_raw_size
operator|+=
name|PLT_ENTRY_SIZE
expr_stmt|;
comment|/* We also need to make an entry in the .got section.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|+=
literal|4
expr_stmt|;
comment|/* We also need to make an entry in the .rel.plt section.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rel.plt"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* If this is a weak symbol, and there is a real definition, the      processor independent code will have arranged for us to see the      real definition first, and we can just use the same value.  */
if|if
condition|(
name|h
operator|->
name|weakdef
operator|!=
name|NULL
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
argument_list|)
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
name|h
operator|->
name|align
operator|=
operator|(
name|bfd_size_type
operator|)
operator|-
literal|1
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* This is a reference to a symbol defined by a dynamic object which      is not a function.  We must allocate it in our .dynbss section,      which will become part of the .bss section of the executable.      There will be an entry for this symbol in the .dynsym section.      The dynamic object will contain position independent code, so all      references from the dynamic object to this symbol will go through      the global offset table.  The dynamic linker will use the .dynsym      entry to determine the address it must put in the global offset      table, so both the dynamic object and the regular object will      refer to the same memory location for the variable.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynbss"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* If the symbol is currently defined in the .bss section of the      dynamic object, then it is OK to simply initialize it to zero.      If the symbol is in some other section, we must generate a      R_386_COPY reloc to tell the dynamic linker to copy the initial      value out of the dynamic object and into the runtime process      image.  We need to remember the offset into the .rel.bss section      we are going to use, and we coopt the align field for this      purpose (the align field is only used for common symbols, and      these symbols are always defined).  It would be cleaner to use a      new field, but that would waste memory.  */
if|if
condition|(
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|==
literal|0
condition|)
name|h
operator|->
name|align
operator|=
operator|(
name|bfd_size_type
operator|)
operator|-
literal|1
expr_stmt|;
else|else
block|{
name|asection
modifier|*
name|srel
decl_stmt|;
name|srel
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rel.bss"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|srel
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|h
operator|->
name|align
operator|=
name|srel
operator|->
name|_raw_size
expr_stmt|;
name|srel
operator|->
name|_raw_size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
expr_stmt|;
block|}
comment|/* We need to figure out the alignment required for this symbol.  I      have no idea how ELF linkers handle this.  */
switch|switch
condition|(
name|h
operator|->
name|size
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|1
case|:
name|power_of_two
operator|=
literal|0
expr_stmt|;
name|align
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|power_of_two
operator|=
literal|1
expr_stmt|;
name|align
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|3
case|:
case|case
literal|4
case|:
name|power_of_two
operator|=
literal|2
expr_stmt|;
name|align
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|5
case|:
case|case
literal|6
case|:
case|case
literal|7
case|:
case|case
literal|8
case|:
name|power_of_two
operator|=
literal|3
expr_stmt|;
name|align
operator|=
literal|8
expr_stmt|;
break|break;
default|default:
name|power_of_two
operator|=
literal|4
expr_stmt|;
name|align
operator|=
literal|16
expr_stmt|;
break|break;
block|}
comment|/* Apply the required alignment.  */
name|s
operator|->
name|_raw_size
operator|=
name|BFD_ALIGN
argument_list|(
name|s
operator|->
name|_raw_size
argument_list|,
name|align
argument_list|)
expr_stmt|;
if|if
condition|(
name|power_of_two
operator|>
name|bfd_get_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|s
argument_list|,
name|power_of_two
argument_list|)
condition|)
return|return
name|false
return|;
block|}
comment|/* Define the symbol as being at this point in the section.  */
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|s
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|s
operator|->
name|_raw_size
expr_stmt|;
comment|/* Increment the section size to make room for the symbol.  */
name|s
operator|->
name|_raw_size
operator|+=
name|h
operator|->
name|size
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Allocate contents for a section.  */
end_comment

begin_function
specifier|static
name|INLINE
name|boolean
name|elf_i386_allocate_dynamic_section
parameter_list|(
name|dynobj
parameter_list|,
name|name
parameter_list|)
name|bfd
modifier|*
name|dynobj
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|asection
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|dynobj
argument_list|,
name|s
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|contents
operator|==
name|NULL
operator|&&
name|s
operator|->
name|_raw_size
operator|!=
literal|0
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Set the sizes of the dynamic sections.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf_i386_size_dynamic_sections
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|dynobj
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Set the contents of the .interp section to the interpreter.  */
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
block|{
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".interp"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|=
sizeof|sizeof
name|ELF_DYNAMIC_INTERPRETER
expr_stmt|;
name|s
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ELF_DYNAMIC_INTERPRETER
expr_stmt|;
block|}
comment|/* The adjust_dynamic_symbol entry point has determined the sizes of      the various dynamic sections.  Allocate some memory for them to      hold contents.  */
if|if
condition|(
operator|!
name|elf_i386_allocate_dynamic_section
argument_list|(
name|dynobj
argument_list|,
literal|".plt"
argument_list|)
operator|||
operator|!
name|elf_i386_allocate_dynamic_section
argument_list|(
name|dynobj
argument_list|,
literal|".rel.plt"
argument_list|)
operator|||
operator|!
name|elf_i386_allocate_dynamic_section
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
operator|||
operator|!
name|elf_i386_allocate_dynamic_section
argument_list|(
name|dynobj
argument_list|,
literal|".rel.bss"
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Add some entries to the .dynamic section.  We fill in the values      later, in elf_i386_finish_dynamic_sections, but we must add the      entries now so that we get the correct size for the .dynamic      section.  The DT_DEBUG entry is filled in by the dynamic linker      and used by the debugger.  */
if|if
condition|(
operator|!
name|bfd_elf32_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_DEBUG
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|bfd_elf32_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_PLTGOT
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|_raw_size
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf32_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_PLTRELSZ
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|bfd_elf32_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_PLTREL
argument_list|,
name|DT_REL
argument_list|)
operator|||
operator|!
name|bfd_elf32_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_JMPREL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
block|}
comment|/* If we didn't need the .rel.bss section, then discard it from the      output file.  This is a hack.  We don't bother to do it for the      other sections because they normally are needed.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rel.bss"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|_raw_size
operator|==
literal|0
condition|)
block|{
name|asection
modifier|*
modifier|*
name|spp
decl_stmt|;
for|for
control|(
name|spp
operator|=
operator|&
name|s
operator|->
name|output_section
operator|->
name|owner
operator|->
name|sections
init|;
operator|*
name|spp
operator|!=
name|s
operator|->
name|output_section
condition|;
name|spp
operator|=
operator|&
operator|(
operator|*
name|spp
operator|)
operator|->
name|next
control|)
empty_stmt|;
operator|*
name|spp
operator|=
name|s
operator|->
name|output_section
operator|->
name|next
expr_stmt|;
operator|--
name|s
operator|->
name|output_section
operator|->
name|owner
operator|->
name|section_count
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|bfd_elf32_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_REL
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|bfd_elf32_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_RELSZ
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|bfd_elf32_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_RELENT
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Relocate an i386 ELF section.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf_i386_relocate_section
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|,
name|input_bfd
parameter_list|,
name|input_section
parameter_list|,
name|contents
parameter_list|,
name|relocs
parameter_list|,
name|local_syms
parameter_list|,
name|local_sections
parameter_list|,
name|output_names
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relocs
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|local_syms
decl_stmt|;
name|asection
modifier|*
modifier|*
name|local_sections
decl_stmt|;
name|char
modifier|*
name|output_names
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relend
decl_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|rel
operator|=
name|relocs
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|input_section
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|int
name|r_type
decl_stmt|;
specifier|const
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|long
name|r_symndx
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
name|bfd_reloc_status_type
name|r
decl_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_type
operator|<
literal|0
operator|||
name|r_type
operator|>=
operator|(
name|int
operator|)
name|R_386_max
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|howto
operator|=
name|elf_howto_table
operator|+
name|r_type
expr_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|relocateable
condition|)
block|{
comment|/* This is a relocateable link.  We don't have to change 	     anything, unless the reloc is against a section symbol, 	     in which case we have to adjust according to where the 	     section symbol winds up in the output section.  */
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_SECTION
condition|)
block|{
name|bfd_vma
name|val
decl_stmt|;
name|sec
operator|=
name|local_sections
index|[
name|r_symndx
index|]
expr_stmt|;
name|val
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|val
operator|+=
name|sec
operator|->
name|output_offset
operator|+
name|sym
operator|->
name|st_value
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|val
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
block|}
block|}
continue|continue;
block|}
comment|/* This is a final link.  */
name|h
operator|=
name|NULL
expr_stmt|;
name|sym
operator|=
name|NULL
expr_stmt|;
name|sec
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
name|sec
operator|=
name|local_sections
index|[
name|r_symndx
index|]
expr_stmt|;
name|relocation
operator|=
operator|(
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|+
name|sym
operator|->
name|st_value
operator|)
expr_stmt|;
block|}
else|else
block|{
name|long
name|indx
decl_stmt|;
name|indx
operator|=
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|h
operator|=
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
index|[
name|indx
index|]
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
condition|)
block|{
name|sec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|relocation
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_weak
condition|)
name|relocation
operator|=
literal|0
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
call|)
argument_list|(
name|info
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
name|relocation
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|r
operator|=
name|_bfd_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|relocation
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|bfd_reloc_ok
condition|)
block|{
switch|switch
condition|(
name|r
condition|)
block|{
default|default:
case|case
name|bfd_reloc_outofrange
case|:
name|abort
argument_list|()
expr_stmt|;
case|case
name|bfd_reloc_overflow
case|:
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
else|else
block|{
name|name
operator|=
name|output_names
operator|+
name|sym
operator|->
name|st_name
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'\0'
condition|)
name|name
operator|=
name|bfd_section_name
argument_list|(
name|input_bfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_overflow
call|)
argument_list|(
name|info
argument_list|,
name|name
argument_list|,
name|howto
operator|->
name|name
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
block|}
break|break;
block|}
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Finish up dynamic symbol handling.  We set the contents of various    dynamic sections here.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf_i386_finish_dynamic_symbol
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|,
name|h
parameter_list|,
name|sym
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
block|{
comment|/* If this symbol is not defined by a dynamic object, or is not      referenced by a regular object, ignore it.  */
if|if
condition|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|!=
literal|0
operator|||
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|==
literal|0
operator|||
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_REF_REGULAR
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Mark _DYNAMIC and _GLOBAL_OFFSET_TABLE_ as absolute.  */
if|if
condition|(
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"_DYNAMIC"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"_GLOBAL_OFFSET_TABLE_"
argument_list|)
operator|==
literal|0
condition|)
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_ABS
expr_stmt|;
return|return
name|true
return|;
block|}
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|type
operator|==
name|STT_FUNC
condition|)
block|{
name|asection
modifier|*
name|splt
decl_stmt|;
name|asection
modifier|*
name|sgot
decl_stmt|;
name|asection
modifier|*
name|srel
decl_stmt|;
name|bfd_vma
name|plt_index
decl_stmt|;
name|bfd_vma
name|got_offset
decl_stmt|;
name|Elf_Internal_Rel
name|rel
decl_stmt|;
name|splt
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|splt
operator|->
name|owner
argument_list|,
name|splt
argument_list|)
argument_list|,
literal|".plt"
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|sgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|splt
operator|->
name|owner
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sgot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|srel
operator|=
name|bfd_get_section_by_name
argument_list|(
name|splt
operator|->
name|owner
argument_list|,
literal|".rel.plt"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|srel
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* FIXME: This only handles an absolute procedure linkage table. 	 When producing a dynamic object, we need to generate a 	 position independent procedure linkage table.  */
comment|/* Get the index in the procedure linkage table which 	 corresponds to this symbol.  This is the index of this symbol 	 in all the symbols for which we are making plt entries.  The 	 first entry in the procedure linkage table is reserved.  */
name|plt_index
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|/
name|PLT_ENTRY_SIZE
operator|-
literal|1
expr_stmt|;
comment|/* Get the offset into the .got table of the entry that 	 corresponds to this function.  Each .got entry is 4 bytes. 	 The first three are reserved.  */
name|got_offset
operator|=
operator|(
name|plt_index
operator|+
literal|3
operator|)
operator|*
literal|4
expr_stmt|;
comment|/* Fill in the entry in the procedure linkage table.  */
name|memcpy
argument_list|(
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
argument_list|,
name|elf_i386_plt_entry
argument_list|,
name|PLT_ENTRY_SIZE
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|+
name|got_offset
operator|)
argument_list|,
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
literal|2
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|plt_index
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
argument_list|,
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
literal|7
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|-
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|PLT_ENTRY_SIZE
operator|)
argument_list|,
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
literal|12
argument_list|)
expr_stmt|;
comment|/* Fill in the entry in the global offset table.  */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|splt
operator|->
name|output_offset
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
literal|6
operator|)
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|got_offset
argument_list|)
expr_stmt|;
comment|/* Fill in the entry in the .rel.plt section.  */
name|rel
operator|.
name|r_offset
operator|=
operator|(
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|+
name|got_offset
operator|)
expr_stmt|;
name|rel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|R_386_JUMP_SLOT
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloc_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rel
argument_list|,
operator|(
operator|(
name|Elf32_External_Rel
operator|*
operator|)
name|srel
operator|->
name|contents
operator|+
name|plt_index
operator|)
argument_list|)
expr_stmt|;
comment|/* Mark the symbol as undefined, rather than as defined in the 	 .plt section.  Leave the value alone.  */
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_UNDEF
expr_stmt|;
block|}
else|else
block|{
comment|/* This is not a function.  We have already allocated memory for 	 it in the .bss section (via .dynbss).  All we have to do here 	 is create a COPY reloc if required.  */
if|if
condition|(
name|h
operator|->
name|align
operator|!=
operator|(
name|bfd_size_type
operator|)
operator|-
literal|1
condition|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|Elf_Internal_Rel
name|rel
decl_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
argument_list|,
literal|".rel.bss"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|rel
operator|.
name|r_offset
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
name|rel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|R_386_COPY
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloc_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rel
argument_list|,
operator|(
operator|(
name|Elf32_External_Rel
operator|*
operator|)
operator|(
name|s
operator|->
name|contents
operator|+
name|h
operator|->
name|align
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Finish up the dynamic sections.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf_i386_finish_dynamic_sections
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|asection
modifier|*
name|splt
decl_stmt|;
name|asection
modifier|*
name|sgot
decl_stmt|;
name|asection
modifier|*
name|sdyn
decl_stmt|;
name|Elf32_External_Dyn
modifier|*
name|dyncon
decl_stmt|,
modifier|*
name|dynconend
decl_stmt|;
name|splt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
name|sgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
name|sdyn
operator|=
name|bfd_get_section_by_name
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|splt
operator|!=
name|NULL
operator|&&
name|sgot
operator|!=
name|NULL
operator|&&
name|sdyn
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dyncon
operator|=
operator|(
name|Elf32_External_Dyn
operator|*
operator|)
name|sdyn
operator|->
name|contents
expr_stmt|;
name|dynconend
operator|=
operator|(
name|Elf32_External_Dyn
operator|*
operator|)
operator|(
name|sdyn
operator|->
name|contents
operator|+
name|sdyn
operator|->
name|_raw_size
operator|)
expr_stmt|;
for|for
control|(
init|;
name|dyncon
operator|<
name|dynconend
condition|;
name|dyncon
operator|++
control|)
block|{
name|Elf_Internal_Dyn
name|dyn
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|boolean
name|size
decl_stmt|;
name|bfd_elf32_swap_dyn_in
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
argument_list|,
name|dyncon
argument_list|,
operator|&
name|dyn
argument_list|)
expr_stmt|;
comment|/* My reading of the SVR4 ABI indicates that the procedure 	 linkage table relocs (DT_JMPREL) should be included in the 	 overall relocs (DT_REL).  This is what Solaris does. 	 However, UnixWare can not handle that case.  Therefore, we 	 override the DT_REL and DT_RELSZ entries here to make them 	 not include the JMPREL relocs.  */
switch|switch
condition|(
name|dyn
operator|.
name|d_tag
condition|)
block|{
case|case
name|DT_PLTGOT
case|:
name|name
operator|=
literal|".got"
expr_stmt|;
name|size
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|DT_PLTRELSZ
case|:
name|name
operator|=
literal|".rel.plt"
expr_stmt|;
name|size
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|DT_JMPREL
case|:
name|name
operator|=
literal|".rel.plt"
expr_stmt|;
name|size
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|DT_REL
case|:
name|name
operator|=
literal|".rel.bss"
expr_stmt|;
name|size
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|DT_RELSZ
case|:
name|name
operator|=
literal|".rel.bss"
expr_stmt|;
name|size
operator|=
name|true
expr_stmt|;
break|break;
default|default:
name|name
operator|=
name|NULL
expr_stmt|;
name|size
operator|=
name|false
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|size
condition|)
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
name|s
operator|->
name|vma
expr_stmt|;
else|else
block|{
if|if
condition|(
name|s
operator|->
name|_cooked_size
operator|!=
literal|0
condition|)
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|s
operator|->
name|_cooked_size
expr_stmt|;
else|else
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|s
operator|->
name|_raw_size
expr_stmt|;
block|}
name|bfd_elf32_swap_dyn_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Fill in the first entry in the procedure linkage table.  */
if|if
condition|(
name|splt
operator|->
name|_raw_size
operator|>
literal|0
condition|)
block|{
name|memcpy
argument_list|(
name|splt
operator|->
name|contents
argument_list|,
name|elf_i386_plt0_entry
argument_list|,
name|PLT_ENTRY_SIZE
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|+
literal|4
argument_list|,
name|splt
operator|->
name|contents
operator|+
literal|2
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|+
literal|8
argument_list|,
name|splt
operator|->
name|contents
operator|+
literal|8
argument_list|)
expr_stmt|;
block|}
comment|/* Fill in the first three entries in the global offset table.  */
if|if
condition|(
name|sgot
operator|->
name|_raw_size
operator|>
literal|0
condition|)
block|{
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|sdyn
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sdyn
operator|->
name|output_offset
argument_list|,
name|sgot
operator|->
name|contents
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|sgot
operator|->
name|contents
operator|+
literal|4
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|sgot
operator|->
name|contents
operator|+
literal|8
argument_list|)
expr_stmt|;
block|}
name|elf_section_data
argument_list|(
name|sgot
operator|->
name|output_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_entsize
operator|=
literal|4
expr_stmt|;
comment|/* UnixWare sets the entsize of .plt to 4, although that doesn't      really seem like the right value.  */
name|elf_section_data
argument_list|(
name|splt
operator|->
name|output_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_entsize
operator|=
literal|4
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_define
define|#
directive|define
name|TARGET_LITTLE_SYM
value|bfd_elf32_i386_vec
end_define

begin_define
define|#
directive|define
name|TARGET_LITTLE_NAME
value|"elf32-i386"
end_define

begin_define
define|#
directive|define
name|ELF_ARCH
value|bfd_arch_i386
end_define

begin_define
define|#
directive|define
name|ELF_MACHINE_CODE
value|EM_386
end_define

begin_define
define|#
directive|define
name|elf_info_to_howto
value|elf_i386_info_to_howto
end_define

begin_define
define|#
directive|define
name|elf_info_to_howto_rel
value|elf_i386_info_to_howto_rel
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_reloc_type_lookup
value|elf_i386_reloc_type_lookup
end_define

begin_define
define|#
directive|define
name|ELF_MAXPAGESIZE
value|0x1000
end_define

begin_define
define|#
directive|define
name|elf_backend_create_dynamic_sections
define|\
value|elf_i386_create_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_adjust_dynamic_symbol
define|\
value|elf_i386_adjust_dynamic_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_size_dynamic_sections
define|\
value|elf_i386_size_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_relocate_section
value|elf_i386_relocate_section
end_define

begin_define
define|#
directive|define
name|elf_backend_finish_dynamic_symbol
define|\
value|elf_i386_finish_dynamic_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_finish_dynamic_sections
define|\
value|elf_i386_finish_dynamic_sections
end_define

begin_include
include|#
directive|include
file|"elf32-target.h"
end_include

end_unit

