begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* libbfd.h -- Declarations used by bfd library *implementation*.    (This include file is not for users of the library.)    Copyright 1990, 1991, 1992, 1993 Free Software Foundation, Inc.    Written by Cygnus Support.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* Align an address upward to a boundary, expressed as a number of bytes.    E.g. align to an 8-byte boundary with argument of 8.  */
end_comment

begin_define
define|#
directive|define
name|BFD_ALIGN
parameter_list|(
name|this
parameter_list|,
name|boundary
parameter_list|)
define|\
value|((( (this) + ((boundary) -1))& (~((boundary)-1))))
end_define

begin_comment
comment|/* If you want to read and write large blocks, you might want to do it    in quanta of this amount */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_BUFFERSIZE
value|8192
end_define

begin_comment
comment|/* Set a tdata field.  Can't use the other macros for this, since they    do casts, and casting to the left of assignment isn't portable.  */
end_comment

begin_define
define|#
directive|define
name|set_tdata
parameter_list|(
name|bfd
parameter_list|,
name|v
parameter_list|)
value|((bfd)->tdata.any = (PTR) (v))
end_define

begin_comment
comment|/* tdata for an archive.  For an input archive, cache    needs to be free()'d.  For an output archive, symdefs do.  */
end_comment

begin_struct
struct|struct
name|artdata
block|{
name|file_ptr
name|first_file_filepos
decl_stmt|;
comment|/* Speed up searching the armap */
name|struct
name|ar_cache
modifier|*
name|cache
decl_stmt|;
name|bfd
modifier|*
name|archive_head
decl_stmt|;
comment|/* Only interesting in output routines */
name|carsym
modifier|*
name|symdefs
decl_stmt|;
comment|/* the symdef entries */
name|symindex
name|symdef_count
decl_stmt|;
comment|/* how many there are */
name|char
modifier|*
name|extended_names
decl_stmt|;
comment|/* clever intel extension */
name|time_t
name|armap_timestamp
decl_stmt|;
comment|/* Timestamp value written into armap. 				   This is used for BSD archives to check 				   that the timestamp is recent enough 				   for the BSD linker to not complain, 				   just before we finish writing an 				   archive.  */
name|file_ptr
name|armap_datepos
decl_stmt|;
comment|/* Position within archive to seek to 				   rewrite the date field.  */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|bfd_ardata
parameter_list|(
name|bfd
parameter_list|)
value|((bfd)->tdata.aout_ar_data)
end_define

begin_comment
comment|/* Goes in bfd's arelt_data slot */
end_comment

begin_struct
struct|struct
name|areltdata
block|{
name|char
modifier|*
name|arch_header
decl_stmt|;
comment|/* it's actually a string */
name|unsigned
name|int
name|parsed_size
decl_stmt|;
comment|/* octets of filesize not including ar_hdr */
name|char
modifier|*
name|filename
decl_stmt|;
comment|/* null-terminated */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|arelt_size
parameter_list|(
name|bfd
parameter_list|)
value|(((struct areltdata *)((bfd)->arelt_data))->parsed_size)
end_define

begin_decl_stmt
name|char
modifier|*
name|zalloc
name|PARAMS
argument_list|(
operator|(
name|bfd_size_type
name|size
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These routines allocate and free things on the BFD's obstack.  Note    that realloc can never occur in place.  */
end_comment

begin_decl_stmt
name|PTR
name|bfd_alloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|size_t
name|size
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|PTR
name|bfd_zalloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|size_t
name|size
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|PTR
name|bfd_realloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|PTR
name|orig
operator|,
name|size_t
name|new
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|bfd_alloc_grow
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|PTR
name|thing
operator|,
name|size_t
name|size
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|PTR
name|bfd_alloc_finish
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|PTR
name|bfd_alloc_by_size_t
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|size_t
name|wanted
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|bfd_release
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(void) obstack_free(&(x->memory),y)
end_define

begin_decl_stmt
name|bfd_size_type
name|bfd_read
name|PARAMS
argument_list|(
operator|(
name|PTR
name|ptr
operator|,
name|bfd_size_type
name|size
operator|,
name|bfd_size_type
name|nitems
operator|,
name|bfd
operator|*
name|abfd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd_size_type
name|bfd_write
name|PARAMS
argument_list|(
operator|(
name|CONST
name|PTR
name|ptr
operator|,
name|bfd_size_type
name|size
operator|,
name|bfd_size_type
name|nitems
operator|,
name|bfd
operator|*
name|abfd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|bfd_seek
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|CONST
name|abfd
operator|,
name|CONST
name|file_ptr
name|fp
operator|,
name|CONST
name|int
name|direction
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|bfd_tell
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|bfd_flush
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|bfd_stat
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
expr|struct
name|stat
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd
modifier|*
name|_bfd_create_empty_archive_element_shell
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|obfd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd
modifier|*
name|look_for_bfd_in_cache
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|arch_bfd
operator|,
name|file_ptr
name|index
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean
name|_bfd_generic_mkarchive
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|areltdata
modifier|*
name|snarf_ar_hdr
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd_target
modifier|*
name|bfd_generic_archive_p
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean
name|bfd_slurp_armap
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean
name|bfd_slurp_bsd_armap_f2
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|bfd_slurp_bsd_armap
value|bfd_slurp_armap
end_define

begin_define
define|#
directive|define
name|bfd_slurp_coff_armap
value|bfd_slurp_armap
end_define

begin_decl_stmt
name|boolean
name|_bfd_slurp_extended_name_table
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean
name|_bfd_write_archive_contents
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd
modifier|*
name|new_bfd
name|PARAMS
argument_list|(
operator|(
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DEFAULT_STRING_SPACE_SIZE
value|0x2000
end_define

begin_decl_stmt
name|boolean
name|bfd_add_to_string_table
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
name|table
operator|,
name|char
operator|*
name|new_string
operator|,
name|unsigned
name|int
operator|*
name|table_length
operator|,
name|char
operator|*
operator|*
name|free_ptr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean
name|bfd_false
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|ignore
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean
name|bfd_true
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|ignore
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|PTR
name|bfd_nullvoidptr
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|ignore
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|bfd_0
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|ignore
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
name|bfd_0u
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|ignore
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|bfd_void
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|ignore
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd
modifier|*
name|new_bfd_contained_in
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean
name|_bfd_dummy_new_section_hook
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|ignore
operator|,
name|asection
operator|*
name|newsect
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|_bfd_dummy_core_file_failing_command
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|_bfd_dummy_core_file_failing_signal
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean
name|_bfd_dummy_core_file_matches_executable_p
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|core_bfd
operator|,
name|bfd
operator|*
name|exec_bfd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd_target
modifier|*
name|_bfd_dummy_target
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|bfd_dont_truncate_arname
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|CONST
name|char
operator|*
name|filename
operator|,
name|char
operator|*
name|hdr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|bfd_bsd_truncate_arname
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|CONST
name|char
operator|*
name|filename
operator|,
name|char
operator|*
name|hdr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|bfd_gnu_truncate_arname
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|CONST
name|char
operator|*
name|filename
operator|,
name|char
operator|*
name|hdr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean
name|bsd_write_armap
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|arch
operator|,
name|unsigned
name|int
name|elength
operator|,
expr|struct
name|orl
operator|*
name|map
operator|,
name|unsigned
name|int
name|orl_count
operator|,
name|int
name|stridx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean
name|coff_write_armap
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|arch
operator|,
name|unsigned
name|int
name|elength
operator|,
expr|struct
name|orl
operator|*
name|map
operator|,
name|unsigned
name|int
name|orl_count
operator|,
name|int
name|stridx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd
modifier|*
name|bfd_generic_openr_next_archived_file
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|archive
operator|,
name|bfd
operator|*
name|last_file
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|bfd_generic_stat_arch_elt
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|stat
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean
name|bfd_generic_get_section_contents
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|sec_ptr
name|section
operator|,
name|PTR
name|location
operator|,
name|file_ptr
name|offset
operator|,
name|bfd_size_type
name|count
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean
name|bfd_generic_set_section_contents
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|sec_ptr
name|section
operator|,
name|PTR
name|location
operator|,
name|file_ptr
name|offset
operator|,
name|bfd_size_type
name|count
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Macros to tell if bfds are read or write enabled.     Note that bfds open for read may be scribbled into if the fd passed    to bfd_fdopenr is actually open both for read and write    simultaneously.  However an output bfd will never be open for    read.  Therefore sometimes you want to check bfd_read_p or    !bfd_read_p, and only sometimes bfd_write_p. */
end_comment

begin_define
define|#
directive|define
name|bfd_read_p
parameter_list|(
name|abfd
parameter_list|)
value|((abfd)->direction == read_direction || (abfd)->direction == both_direction)
end_define

begin_define
define|#
directive|define
name|bfd_write_p
parameter_list|(
name|abfd
parameter_list|)
value|((abfd)->direction == write_direction || (abfd)->direction == both_direction)
end_define

begin_decl_stmt
name|void
name|bfd_assert
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|BFD_ASSERT
parameter_list|(
name|x
parameter_list|)
define|\
value|{ if (!(x)) bfd_assert(__FILE__,__LINE__); }
end_define

begin_define
define|#
directive|define
name|BFD_FAIL
parameter_list|()
define|\
value|{ bfd_assert(__FILE__,__LINE__); }
end_define

begin_decl_stmt
name|FILE
modifier|*
name|bfd_cache_lookup_worker
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd
modifier|*
name|bfd_last_cache
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Now Steve, what's the story here? */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|lint
end_ifdef

begin_define
define|#
directive|define
name|itos
parameter_list|(
name|x
parameter_list|)
value|"l"
end_define

begin_define
define|#
directive|define
name|stoi
parameter_list|(
name|x
parameter_list|)
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|itos
parameter_list|(
name|x
parameter_list|)
value|((char*)(x))
end_define

begin_define
define|#
directive|define
name|stoi
parameter_list|(
name|x
parameter_list|)
value|((int)(x))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Generic routine for close_and_cleanup is really just bfd_true.  */
end_comment

begin_define
define|#
directive|define
name|bfd_generic_close_and_cleanup
value|bfd_true
end_define

begin_comment
comment|/* And more follows */
end_comment

begin_decl_stmt
name|void
name|bfd_check_init
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|PTR
name|bfd_xmalloc
name|PARAMS
argument_list|(
operator|(
name|bfd_size_type
name|size
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|PTR
name|bfd_xmalloc_by_size_t
name|PARAMS
argument_list|(
operator|(
name|size_t
name|size
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|bfd_write_bigendian_4byte_int
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|int
name|i
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
name|bfd_log2
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
name|x
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|BFD_CACHE_MAX_OPEN
value|10
end_define

begin_decl_stmt
specifier|extern
name|bfd
modifier|*
name|bfd_last_cache
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|bfd_cache_lookup
parameter_list|(
name|x
parameter_list|)
define|\
value|((x)==bfd_last_cache? \       (FILE*)(bfd_last_cache->iostream): \        bfd_cache_lookup_worker(x))
end_define

begin_decl_stmt
name|boolean
name|bfd_cache_close
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|bfd_open_file
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|bfd_cache_lookup_worker
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|bfd_constructor_entry
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|asymbol
operator|*
operator|*
name|symbol_ptr_ptr
operator|,
name|CONST
name|char
operator|*
name|type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|CONST
name|struct
name|reloc_howto_struct
modifier|*
name|bfd_default_reloc_type_lookup
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
name|AND
name|bfd_reloc_code_real_type
name|code
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean
name|bfd_generic_relax_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|asection
operator|*
name|section
operator|,
name|asymbol
operator|*
operator|*
name|symbols
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd_byte
modifier|*
name|bfd_generic_get_relocated_section_contents
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
expr|struct
name|bfd_seclet
operator|*
name|seclet
operator|,
name|bfd_byte
operator|*
name|data
operator|,
name|boolean
name|relocateable
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean
name|bfd_generic_seclet_link
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|PTR
name|data
operator|,
name|boolean
name|relocateable
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_arch_info_type
name|bfd_default_arch_struct
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean
name|bfd_default_set_arch_mach
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
expr|enum
name|bfd_architecture
name|arch
operator|,
name|unsigned
name|long
name|mach
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|bfd_arch_init
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|bfd_arch_linkin
name|PARAMS
argument_list|(
operator|(
name|bfd_arch_info_type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|CONST
name|bfd_arch_info_type
modifier|*
name|bfd_default_compatible
name|PARAMS
argument_list|(
operator|(
name|CONST
name|bfd_arch_info_type
operator|*
name|a
operator|,
name|CONST
name|bfd_arch_info_type
operator|*
name|b
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean
name|bfd_default_scan
name|PARAMS
argument_list|(
operator|(
name|CONST
expr|struct
name|bfd_arch_info
operator|*
operator|,
name|CONST
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|elf_internal_shdr
modifier|*
name|bfd_elf_find_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|char
operator|*
name|name
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

end_unit

