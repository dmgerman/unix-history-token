begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Find a variable's value in memory, for GDB, the GNU debugger.    Copyright 1986, 1987, 1989, 1991 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_comment
comment|/* Basic byte-swapping routines.  GDB has needed these for a long time...    All extract a target-format integer at ADDR which is LEN bytes long.  */
end_comment

begin_if
if|#
directive|if
name|TARGET_CHAR_BIT
operator|!=
literal|8
operator|||
name|HOST_CHAR_BIT
operator|!=
literal|8
end_if

begin_comment
comment|/* 8 bit characters are a pretty safe assumption these days, so we      assume it throughout all these swapping routines.  If we had to deal with      9 bit characters, we would need to make len be in bits and would have      to re-write these routines...  */
end_comment

begin_function
name|you
name|lose
endif|#
directive|endif
name|LONGEST
name|extract_signed_integer
parameter_list|(
name|addr
parameter_list|,
name|len
parameter_list|)
name|PTR
name|addr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|LONGEST
name|retval
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|char
modifier|*
name|startaddr
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|addr
decl_stmt|;
name|unsigned
name|char
modifier|*
name|endaddr
init|=
name|startaddr
operator|+
name|len
decl_stmt|;
if|if
condition|(
name|len
operator|>
sizeof|sizeof
argument_list|(
name|LONGEST
argument_list|)
condition|)
name|error
argument_list|(
literal|"\ That operation is not available on integers of more than %d bytes."
argument_list|,
sizeof|sizeof
argument_list|(
name|LONGEST
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Start at the most significant end of the integer, and work towards      the least significant.  */
if|#
directive|if
name|TARGET_BYTE_ORDER
operator|==
name|BIG_ENDIAN
name|p
operator|=
name|startaddr
expr_stmt|;
else|#
directive|else
name|p
operator|=
name|endaddr
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* Do the sign extension once at the start.  */
name|retval
operator|=
operator|(
operator|(
name|LONGEST
operator|)
operator|*
name|p
operator|^
literal|0x80
operator|)
operator|-
literal|0x80
expr_stmt|;
if|#
directive|if
name|TARGET_BYTE_ORDER
operator|==
name|BIG_ENDIAN
for|for
control|(
operator|++
name|p
init|;
name|p
operator|<
name|endaddr
condition|;
operator|++
name|p
control|)
else|#
directive|else
for|for
control|(
operator|--
name|p
init|;
name|p
operator|>=
name|startaddr
condition|;
operator|--
name|p
control|)
endif|#
directive|endif
block|{
name|retval
operator|=
operator|(
name|retval
operator|<<
literal|8
operator|)
operator||
operator|*
name|p
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_function
name|unsigned
name|LONGEST
name|extract_unsigned_integer
parameter_list|(
name|addr
parameter_list|,
name|len
parameter_list|)
name|PTR
name|addr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|unsigned
name|LONGEST
name|retval
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|char
modifier|*
name|startaddr
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|addr
decl_stmt|;
name|unsigned
name|char
modifier|*
name|endaddr
init|=
name|startaddr
operator|+
name|len
decl_stmt|;
if|if
condition|(
name|len
operator|>
expr|sizeof
operator|(
name|unsigned
name|LONGEST
operator|)
condition|)
name|error
argument_list|(
literal|"\ That operation is not available on integers of more than %d bytes."
argument_list|,
expr|sizeof
operator|(
name|unsigned
name|LONGEST
operator|)
argument_list|)
expr_stmt|;
comment|/* Start at the most significant end of the integer, and work towards      the least significant.  */
name|retval
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|TARGET_BYTE_ORDER
operator|==
name|BIG_ENDIAN
for|for
control|(
name|p
operator|=
name|startaddr
init|;
name|p
operator|<
name|endaddr
condition|;
operator|++
name|p
control|)
else|#
directive|else
for|for
control|(
name|p
operator|=
name|endaddr
operator|-
literal|1
init|;
name|p
operator|>=
name|startaddr
condition|;
operator|--
name|p
control|)
endif|#
directive|endif
block|{
name|retval
operator|=
operator|(
name|retval
operator|<<
literal|8
operator|)
operator||
operator|*
name|p
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_function
name|CORE_ADDR
name|extract_address
parameter_list|(
name|addr
parameter_list|,
name|len
parameter_list|)
name|PTR
name|addr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
comment|/* Assume a CORE_ADDR can fit in a LONGEST (for now).  Not sure      whether we want this to be true eventually.  */
return|return
name|extract_unsigned_integer
argument_list|(
name|addr
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|store_signed_integer
parameter_list|(
name|addr
parameter_list|,
name|len
parameter_list|,
name|val
parameter_list|)
name|PTR
name|addr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|LONGEST
name|val
decl_stmt|;
block|{
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|char
modifier|*
name|startaddr
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|addr
decl_stmt|;
name|unsigned
name|char
modifier|*
name|endaddr
init|=
name|startaddr
operator|+
name|len
decl_stmt|;
comment|/* Start at the least significant end of the integer, and work towards      the most significant.  */
if|#
directive|if
name|TARGET_BYTE_ORDER
operator|==
name|BIG_ENDIAN
for|for
control|(
name|p
operator|=
name|endaddr
operator|-
literal|1
init|;
name|p
operator|>=
name|startaddr
condition|;
operator|--
name|p
control|)
else|#
directive|else
for|for
control|(
name|p
operator|=
name|startaddr
init|;
name|p
operator|<
name|endaddr
condition|;
operator|++
name|p
control|)
endif|#
directive|endif
block|{
operator|*
name|p
operator|=
name|val
operator|&
literal|0xff
expr_stmt|;
name|val
operator|>>=
literal|8
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|store_unsigned_integer
parameter_list|(
name|addr
parameter_list|,
name|len
parameter_list|,
name|val
parameter_list|)
name|PTR
name|addr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|unsigned
name|LONGEST
name|val
decl_stmt|;
block|{
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|char
modifier|*
name|startaddr
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|addr
decl_stmt|;
name|unsigned
name|char
modifier|*
name|endaddr
init|=
name|startaddr
operator|+
name|len
decl_stmt|;
comment|/* Start at the least significant end of the integer, and work towards      the most significant.  */
if|#
directive|if
name|TARGET_BYTE_ORDER
operator|==
name|BIG_ENDIAN
for|for
control|(
name|p
operator|=
name|endaddr
operator|-
literal|1
init|;
name|p
operator|>=
name|startaddr
condition|;
operator|--
name|p
control|)
else|#
directive|else
for|for
control|(
name|p
operator|=
name|startaddr
init|;
name|p
operator|<
name|endaddr
condition|;
operator|++
name|p
control|)
endif|#
directive|endif
block|{
operator|*
name|p
operator|=
name|val
operator|&
literal|0xff
expr_stmt|;
name|val
operator|>>=
literal|8
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|store_address
parameter_list|(
name|addr
parameter_list|,
name|len
parameter_list|,
name|val
parameter_list|)
name|PTR
name|addr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|CORE_ADDR
name|val
decl_stmt|;
block|{
comment|/* Assume a CORE_ADDR can fit in a LONGEST (for now).  Not sure      whether we want this to be true eventually.  */
name|store_unsigned_integer
argument_list|(
name|addr
argument_list|,
name|len
argument_list|,
operator|(
name|LONGEST
operator|)
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|GET_SAVED_REGISTER
argument_list|)
end_if

begin_comment
comment|/* Return the address in which frame FRAME's value of register REGNUM    has been saved in memory.  Or return zero if it has not been saved.    If REGNUM specifies the SP, the value we return is actually    the SP value, not an address where it was saved.  */
end_comment

begin_function
name|CORE_ADDR
name|find_saved_register
parameter_list|(
name|frame
parameter_list|,
name|regnum
parameter_list|)
name|FRAME
name|frame
decl_stmt|;
name|int
name|regnum
decl_stmt|;
block|{
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
name|struct
name|frame_saved_regs
name|saved_regs
decl_stmt|;
specifier|register
name|FRAME
name|frame1
init|=
literal|0
decl_stmt|;
specifier|register
name|CORE_ADDR
name|addr
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|frame
operator|==
literal|0
condition|)
comment|/* No regs saved if want current frame */
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|HAVE_REGISTER_WINDOWS
comment|/* We assume that a register in a register window will only be saved      in one place (since the name changes and/or disappears as you go      towards inner frames), so we only call get_frame_saved_regs on      the current frame.  This is directly in contradiction to the      usage below, which assumes that registers used in a frame must be      saved in a lower (more interior) frame.  This change is a result      of working on a register window machine; get_frame_saved_regs      always returns the registers saved within a frame, within the      context (register namespace) of that frame. */
comment|/* However, note that we don't want this to return anything if      nothing is saved (if there's a frame inside of this one).  Also,      callers to this routine asking for the stack pointer want the      stack pointer saved for *this* frame; this is returned from the      next frame.  */
if|if
condition|(
name|REGISTER_IN_WINDOW_P
argument_list|(
name|regnum
argument_list|)
condition|)
block|{
name|frame1
operator|=
name|get_next_frame
argument_list|(
name|frame
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|frame1
condition|)
return|return
literal|0
return|;
comment|/* Registers of this frame are 				   active.  */
comment|/* Get the SP from the next frame in; it will be this 	 current frame.  */
if|if
condition|(
name|regnum
operator|!=
name|SP_REGNUM
condition|)
name|frame1
operator|=
name|frame
expr_stmt|;
name|fi
operator|=
name|get_frame_info
argument_list|(
name|frame1
argument_list|)
expr_stmt|;
name|get_frame_saved_regs
argument_list|(
name|fi
argument_list|,
operator|&
name|saved_regs
argument_list|)
expr_stmt|;
return|return
name|saved_regs
operator|.
name|regs
index|[
name|regnum
index|]
return|;
comment|/* ... which might be zero */
block|}
endif|#
directive|endif
comment|/* HAVE_REGISTER_WINDOWS */
comment|/* Note that this next routine assumes that registers used in      frame x will be saved only in the frame that x calls and      frames interior to it.  This is not true on the sparc, but the      above macro takes care of it, so we should be all right. */
while|while
condition|(
literal|1
condition|)
block|{
name|QUIT
expr_stmt|;
name|frame1
operator|=
name|get_prev_frame
argument_list|(
name|frame1
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame1
operator|==
literal|0
operator|||
name|frame1
operator|==
name|frame
condition|)
break|break;
name|fi
operator|=
name|get_frame_info
argument_list|(
name|frame1
argument_list|)
expr_stmt|;
name|get_frame_saved_regs
argument_list|(
name|fi
argument_list|,
operator|&
name|saved_regs
argument_list|)
expr_stmt|;
if|if
condition|(
name|saved_regs
operator|.
name|regs
index|[
name|regnum
index|]
condition|)
name|addr
operator|=
name|saved_regs
operator|.
name|regs
index|[
name|regnum
index|]
expr_stmt|;
block|}
return|return
name|addr
return|;
block|}
end_function

begin_comment
comment|/* Find register number REGNUM relative to FRAME and put its (raw,    target format) contents in *RAW_BUFFER.  Set *OPTIMIZED if the    variable was optimized out (and thus can't be fetched).  Set *LVAL    to lval_memory, lval_register, or not_lval, depending on whether    the value was fetched from memory, from a register, or in a strange    and non-modifiable way (e.g. a frame pointer which was calculated    rather than fetched).  Set *ADDRP to the address, either in memory    on as a REGISTER_BYTE offset into the registers array.     Note that this implementation never sets *LVAL to not_lval.  But    it can be replaced by defining GET_SAVED_REGISTER and supplying    your own.     The argument RAW_BUFFER must point to aligned memory.  */
end_comment

begin_function
name|void
name|get_saved_register
parameter_list|(
name|raw_buffer
parameter_list|,
name|optimized
parameter_list|,
name|addrp
parameter_list|,
name|frame
parameter_list|,
name|regnum
parameter_list|,
name|lval
parameter_list|)
name|char
modifier|*
name|raw_buffer
decl_stmt|;
name|int
modifier|*
name|optimized
decl_stmt|;
name|CORE_ADDR
modifier|*
name|addrp
decl_stmt|;
name|FRAME
name|frame
decl_stmt|;
name|int
name|regnum
decl_stmt|;
name|enum
name|lval_type
modifier|*
name|lval
decl_stmt|;
block|{
name|CORE_ADDR
name|addr
decl_stmt|;
comment|/* Normal systems don't optimize out things with register numbers.  */
if|if
condition|(
name|optimized
operator|!=
name|NULL
condition|)
operator|*
name|optimized
operator|=
literal|0
expr_stmt|;
name|addr
operator|=
name|find_saved_register
argument_list|(
name|frame
argument_list|,
name|regnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|lval
operator|!=
name|NULL
condition|)
operator|*
name|lval
operator|=
name|lval_memory
expr_stmt|;
if|if
condition|(
name|regnum
operator|==
name|SP_REGNUM
condition|)
block|{
if|if
condition|(
name|raw_buffer
operator|!=
name|NULL
condition|)
block|{
comment|/* Put it back in target format.  */
name|store_address
argument_list|(
name|raw_buffer
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|addrp
operator|!=
name|NULL
condition|)
operator|*
name|addrp
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|raw_buffer
operator|!=
name|NULL
condition|)
name|read_memory
argument_list|(
name|addr
argument_list|,
name|raw_buffer
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|lval
operator|!=
name|NULL
condition|)
operator|*
name|lval
operator|=
name|lval_register
expr_stmt|;
name|addr
operator|=
name|REGISTER_BYTE
argument_list|(
name|regnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|raw_buffer
operator|!=
name|NULL
condition|)
name|read_register_gen
argument_list|(
name|regnum
argument_list|,
name|raw_buffer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|addrp
operator|!=
name|NULL
condition|)
operator|*
name|addrp
operator|=
name|addr
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* GET_SAVED_REGISTER.  */
end_comment

begin_comment
comment|/* Copy the bytes of register REGNUM, relative to the current stack frame,    into our memory at MYADDR, in target byte order.    The number of bytes copied is REGISTER_RAW_SIZE (REGNUM).     Returns 1 if could not be read, 0 if could.  */
end_comment

begin_function
name|int
name|read_relative_register_raw_bytes
parameter_list|(
name|regnum
parameter_list|,
name|myaddr
parameter_list|)
name|int
name|regnum
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
block|{
name|int
name|optim
decl_stmt|;
if|if
condition|(
name|regnum
operator|==
name|FP_REGNUM
operator|&&
name|selected_frame
condition|)
block|{
comment|/* Put it back in target format.  */
name|store_address
argument_list|(
name|myaddr
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|FP_REGNUM
argument_list|)
argument_list|,
name|FRAME_FP
argument_list|(
name|selected_frame
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|get_saved_register
argument_list|(
name|myaddr
argument_list|,
operator|&
name|optim
argument_list|,
operator|(
name|CORE_ADDR
operator|*
operator|)
name|NULL
argument_list|,
name|selected_frame
argument_list|,
name|regnum
argument_list|,
operator|(
expr|enum
name|lval_type
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|optim
return|;
block|}
end_function

begin_comment
comment|/* Return a `value' with the contents of register REGNUM    in its virtual format, with the type specified by    REGISTER_VIRTUAL_TYPE.  */
end_comment

begin_function
name|value
name|value_of_register
parameter_list|(
name|regnum
parameter_list|)
name|int
name|regnum
decl_stmt|;
block|{
name|CORE_ADDR
name|addr
decl_stmt|;
name|int
name|optim
decl_stmt|;
specifier|register
name|value
name|val
decl_stmt|;
name|char
name|raw_buffer
index|[
name|MAX_REGISTER_RAW_SIZE
index|]
decl_stmt|;
name|char
name|virtual_buffer
index|[
name|MAX_REGISTER_VIRTUAL_SIZE
index|]
decl_stmt|;
name|enum
name|lval_type
name|lval
decl_stmt|;
name|get_saved_register
argument_list|(
name|raw_buffer
argument_list|,
operator|&
name|optim
argument_list|,
operator|&
name|addr
argument_list|,
name|selected_frame
argument_list|,
name|regnum
argument_list|,
operator|&
name|lval
argument_list|)
expr_stmt|;
name|REGISTER_CONVERT_TO_VIRTUAL
argument_list|(
name|regnum
argument_list|,
name|raw_buffer
argument_list|,
name|virtual_buffer
argument_list|)
expr_stmt|;
name|val
operator|=
name|allocate_value
argument_list|(
name|REGISTER_VIRTUAL_TYPE
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|VALUE_CONTENTS_RAW
argument_list|(
name|val
argument_list|)
argument_list|,
name|virtual_buffer
argument_list|,
name|REGISTER_VIRTUAL_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
name|VALUE_LVAL
argument_list|(
name|val
argument_list|)
operator|=
name|lval
expr_stmt|;
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
operator|=
name|addr
expr_stmt|;
name|VALUE_REGNO
argument_list|(
name|val
argument_list|)
operator|=
name|regnum
expr_stmt|;
name|VALUE_OPTIMIZED_OUT
argument_list|(
name|val
argument_list|)
operator|=
name|optim
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Low level examining and depositing of registers.     The caller is responsible for making    sure that the inferior is stopped before calling the fetching routines,    or it will get garbage.  (a change from GDB version 3, in which    the caller got the value from the last stop).  */
end_comment

begin_comment
comment|/* Contents of the registers in target byte order.    We allocate some extra slop since we do a lot of memcpy's around `registers',    and failing-soft is better than failing hard.  */
end_comment

begin_decl_stmt
name|char
name|registers
index|[
name|REGISTER_BYTES
operator|+
comment|/* SLOP */
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if that register has been fetched.  */
end_comment

begin_decl_stmt
name|char
name|register_valid
index|[
name|NUM_REGS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indicate that registers may have changed, so invalidate the cache.  */
end_comment

begin_function
name|void
name|registers_changed
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_REGS
condition|;
name|i
operator|++
control|)
name|register_valid
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Indicate that all registers have been fetched, so mark them all valid.  */
end_comment

begin_function
name|void
name|registers_fetched
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_REGS
condition|;
name|i
operator|++
control|)
name|register_valid
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy LEN bytes of consecutive data from registers    starting with the REGBYTE'th byte of register data    into memory at MYADDR.  */
end_comment

begin_function
name|void
name|read_register_bytes
parameter_list|(
name|regbyte
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|)
name|int
name|regbyte
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
comment|/* Fetch all registers.  */
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_REGS
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|register_valid
index|[
name|i
index|]
condition|)
block|{
name|target_fetch_registers
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|myaddr
operator|!=
name|NULL
condition|)
name|memcpy
argument_list|(
name|myaddr
argument_list|,
operator|&
name|registers
index|[
name|regbyte
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read register REGNO into memory at MYADDR, which must be large enough    for REGISTER_RAW_BYTES (REGNO).  Target byte-order.    If the register is known to be the size of a CORE_ADDR or smaller,    read_register can be used instead.  */
end_comment

begin_function
name|void
name|read_register_gen
parameter_list|(
name|regno
parameter_list|,
name|myaddr
parameter_list|)
name|int
name|regno
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|register_valid
index|[
name|regno
index|]
condition|)
name|target_fetch_registers
argument_list|(
name|regno
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|myaddr
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|regno
argument_list|)
index|]
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy LEN bytes of consecutive data from memory at MYADDR    into registers starting with the REGBYTE'th byte of register data.  */
end_comment

begin_function
name|void
name|write_register_bytes
parameter_list|(
name|regbyte
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|)
name|int
name|regbyte
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
comment|/* Make sure the entire registers array is valid.  */
name|read_register_bytes
argument_list|(
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|REGISTER_BYTES
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|registers
index|[
name|regbyte
index|]
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|target_store_registers
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the raw contents of register REGNO, regarding it as an integer.  */
end_comment

begin_comment
comment|/* This probably should be returning LONGEST rather than CORE_ADDR.  */
end_comment

begin_function
name|CORE_ADDR
name|read_register
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|register_valid
index|[
name|regno
index|]
condition|)
name|target_fetch_registers
argument_list|(
name|regno
argument_list|)
expr_stmt|;
return|return
name|extract_address
argument_list|(
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|regno
argument_list|)
index|]
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Registers we shouldn't try to store.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CANNOT_STORE_REGISTER
argument_list|)
end_if

begin_define
define|#
directive|define
name|CANNOT_STORE_REGISTER
parameter_list|(
name|regno
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Store VALUE, into the raw contents of register number REGNO.  */
end_comment

begin_comment
comment|/* FIXME: The val arg should probably be a LONGEST.  */
end_comment

begin_function
name|void
name|write_register
parameter_list|(
name|regno
parameter_list|,
name|val
parameter_list|)
name|int
name|regno
decl_stmt|;
name|LONGEST
name|val
decl_stmt|;
block|{
name|PTR
name|buf
decl_stmt|;
name|int
name|size
decl_stmt|;
comment|/* On the sparc, writing %g0 is a no-op, so we don't even want to change      the registers array if something writes to this register.  */
if|if
condition|(
name|CANNOT_STORE_REGISTER
argument_list|(
name|regno
argument_list|)
condition|)
return|return;
name|size
operator|=
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
expr_stmt|;
name|buf
operator|=
name|alloca
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|store_signed_integer
argument_list|(
name|buf
argument_list|,
name|size
argument_list|,
operator|(
name|LONGEST
operator|)
name|val
argument_list|)
expr_stmt|;
comment|/* If we have a valid copy of the register, and new value == old value,      then don't bother doing the actual store. */
if|if
condition|(
name|register_valid
index|[
name|regno
index|]
condition|)
block|{
if|if
condition|(
name|memcmp
argument_list|(
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|regno
argument_list|)
index|]
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
operator|==
literal|0
condition|)
return|return;
block|}
name|target_prepare_to_store
argument_list|()
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|regno
argument_list|)
index|]
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|register_valid
index|[
name|regno
index|]
operator|=
literal|1
expr_stmt|;
name|target_store_registers
argument_list|(
name|regno
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record that register REGNO contains VAL.    This is used when the value is obtained from the inferior or core dump,    so there is no need to store the value there.  */
end_comment

begin_function
name|void
name|supply_register
parameter_list|(
name|regno
parameter_list|,
name|val
parameter_list|)
name|int
name|regno
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
block|{
name|register_valid
index|[
name|regno
index|]
operator|=
literal|1
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|regno
argument_list|)
index|]
argument_list|,
name|val
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* On some architectures, e.g. HPPA, there are a few stray bits in some      registers, that the rest of the code would like to ignore.  */
ifdef|#
directive|ifdef
name|CLEAN_UP_REGISTER_VALUE
name|CLEAN_UP_REGISTER_VALUE
argument_list|(
name|regno
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|regno
argument_list|)
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Will calling read_var_value or locate_var_value on SYM end    up caring what frame it is being evaluated relative to?  SYM must    be non-NULL.  */
end_comment

begin_function
name|int
name|symbol_read_needs_frame
parameter_list|(
name|sym
parameter_list|)
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
block|{
switch|switch
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
condition|)
block|{
comment|/* All cases listed explicitly so that gcc -Wall will detect it if 	 we failed to consider one.  */
case|case
name|LOC_REGISTER
case|:
case|case
name|LOC_ARG
case|:
case|case
name|LOC_REF_ARG
case|:
case|case
name|LOC_REGPARM
case|:
case|case
name|LOC_REGPARM_ADDR
case|:
case|case
name|LOC_LOCAL
case|:
case|case
name|LOC_LOCAL_ARG
case|:
case|case
name|LOC_BASEREG
case|:
case|case
name|LOC_BASEREG_ARG
case|:
return|return
literal|1
return|;
case|case
name|LOC_UNDEF
case|:
case|case
name|LOC_CONST
case|:
case|case
name|LOC_STATIC
case|:
case|case
name|LOC_TYPEDEF
case|:
case|case
name|LOC_LABEL
case|:
comment|/* Getting the address of a label can be done independently of the block, 	 even if some *uses* of that address wouldn't work so well without 	 the right frame.  */
case|case
name|LOC_BLOCK
case|:
case|case
name|LOC_CONST_BYTES
case|:
case|case
name|LOC_OPTIMIZED_OUT
case|:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Given a struct symbol for a variable,    and a stack frame id, read the value of the variable    and return a (pointer to a) struct value containing the value.     If the variable cannot be found, return a zero pointer.    If FRAME is NULL, use the selected_frame.  */
end_comment

begin_function
name|value
name|read_var_value
parameter_list|(
name|var
parameter_list|,
name|frame
parameter_list|)
specifier|register
name|struct
name|symbol
modifier|*
name|var
decl_stmt|;
name|FRAME
name|frame
decl_stmt|;
block|{
specifier|register
name|value
name|v
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
name|struct
name|type
modifier|*
name|type
init|=
name|SYMBOL_TYPE
argument_list|(
name|var
argument_list|)
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
name|v
operator|=
name|allocate_value
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|VALUE_LVAL
argument_list|(
name|v
argument_list|)
operator|=
name|lval_memory
expr_stmt|;
comment|/* The most likely possibility.  */
name|len
operator|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame
operator|==
literal|0
condition|)
name|frame
operator|=
name|selected_frame
expr_stmt|;
switch|switch
condition|(
name|SYMBOL_CLASS
argument_list|(
name|var
argument_list|)
condition|)
block|{
case|case
name|LOC_CONST
case|:
comment|/* Put the constant back in target format.  */
name|store_signed_integer
argument_list|(
name|VALUE_CONTENTS_RAW
argument_list|(
name|v
argument_list|)
argument_list|,
name|len
argument_list|,
operator|(
name|LONGEST
operator|)
name|SYMBOL_VALUE
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
name|VALUE_LVAL
argument_list|(
name|v
argument_list|)
operator|=
name|not_lval
expr_stmt|;
return|return
name|v
return|;
case|case
name|LOC_LABEL
case|:
comment|/* Put the constant back in target format.  */
name|store_address
argument_list|(
name|VALUE_CONTENTS_RAW
argument_list|(
name|v
argument_list|)
argument_list|,
name|len
argument_list|,
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
name|VALUE_LVAL
argument_list|(
name|v
argument_list|)
operator|=
name|not_lval
expr_stmt|;
return|return
name|v
return|;
case|case
name|LOC_CONST_BYTES
case|:
block|{
name|char
modifier|*
name|bytes_addr
decl_stmt|;
name|bytes_addr
operator|=
name|SYMBOL_VALUE_BYTES
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|VALUE_CONTENTS_RAW
argument_list|(
name|v
argument_list|)
argument_list|,
name|bytes_addr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|VALUE_LVAL
argument_list|(
name|v
argument_list|)
operator|=
name|not_lval
expr_stmt|;
return|return
name|v
return|;
block|}
case|case
name|LOC_STATIC
case|:
name|addr
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|var
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_ARG
case|:
name|fi
operator|=
name|get_frame_info
argument_list|(
name|frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|addr
operator|=
name|FRAME_ARGS_ADDRESS
argument_list|(
name|fi
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|addr
condition|)
block|{
return|return
literal|0
return|;
block|}
name|addr
operator|+=
name|SYMBOL_VALUE
argument_list|(
name|var
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_REF_ARG
case|:
name|fi
operator|=
name|get_frame_info
argument_list|(
name|frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|addr
operator|=
name|FRAME_ARGS_ADDRESS
argument_list|(
name|fi
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|addr
condition|)
block|{
return|return
literal|0
return|;
block|}
name|addr
operator|+=
name|SYMBOL_VALUE
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|addr
operator|=
name|read_memory_unsigned_integer
argument_list|(
name|addr
argument_list|,
name|TARGET_PTR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_LOCAL
case|:
case|case
name|LOC_LOCAL_ARG
case|:
name|fi
operator|=
name|get_frame_info
argument_list|(
name|frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|addr
operator|=
name|FRAME_LOCALS_ADDRESS
argument_list|(
name|fi
argument_list|)
expr_stmt|;
name|addr
operator|+=
name|SYMBOL_VALUE
argument_list|(
name|var
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_BASEREG
case|:
case|case
name|LOC_BASEREG_ARG
case|:
block|{
name|char
name|buf
index|[
name|MAX_REGISTER_RAW_SIZE
index|]
decl_stmt|;
name|get_saved_register
argument_list|(
name|buf
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|frame
argument_list|,
name|SYMBOL_BASEREG
argument_list|(
name|var
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|addr
operator|=
name|extract_address
argument_list|(
name|buf
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|SYMBOL_BASEREG
argument_list|(
name|var
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|+=
name|SYMBOL_VALUE
argument_list|(
name|var
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|LOC_TYPEDEF
case|:
name|error
argument_list|(
literal|"Cannot look up value of a typedef"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_BLOCK
case|:
name|VALUE_ADDRESS
argument_list|(
name|v
argument_list|)
operator|=
name|BLOCK_START
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|v
return|;
case|case
name|LOC_REGISTER
case|:
case|case
name|LOC_REGPARM
case|:
case|case
name|LOC_REGPARM_ADDR
case|:
block|{
name|struct
name|block
modifier|*
name|b
decl_stmt|;
if|if
condition|(
name|frame
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|b
operator|=
name|get_frame_block
argument_list|(
name|frame
argument_list|)
expr_stmt|;
name|v
operator|=
name|value_from_register
argument_list|(
name|type
argument_list|,
name|SYMBOL_VALUE
argument_list|(
name|var
argument_list|)
argument_list|,
name|frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|var
argument_list|)
operator|==
name|LOC_REGPARM_ADDR
condition|)
block|{
name|addr
operator|=
operator|*
operator|(
name|CORE_ADDR
operator|*
operator|)
name|VALUE_CONTENTS
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|VALUE_LVAL
argument_list|(
name|v
argument_list|)
operator|=
name|lval_memory
expr_stmt|;
block|}
else|else
return|return
name|v
return|;
block|}
break|break;
case|case
name|LOC_OPTIMIZED_OUT
case|:
name|VALUE_LVAL
argument_list|(
name|v
argument_list|)
operator|=
name|not_lval
expr_stmt|;
name|VALUE_OPTIMIZED_OUT
argument_list|(
name|v
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|v
return|;
default|default:
name|error
argument_list|(
literal|"Cannot look up value of a botched symbol."
argument_list|)
expr_stmt|;
break|break;
block|}
name|VALUE_ADDRESS
argument_list|(
name|v
argument_list|)
operator|=
name|addr
expr_stmt|;
name|VALUE_LAZY
argument_list|(
name|v
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_comment
comment|/* Return a value of type TYPE, stored in register REGNUM, in frame    FRAME. */
end_comment

begin_function
name|value
name|value_from_register
parameter_list|(
name|type
parameter_list|,
name|regnum
parameter_list|,
name|frame
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|int
name|regnum
decl_stmt|;
name|FRAME
name|frame
decl_stmt|;
block|{
name|char
name|raw_buffer
index|[
name|MAX_REGISTER_RAW_SIZE
index|]
decl_stmt|;
name|char
name|virtual_buffer
index|[
name|MAX_REGISTER_VIRTUAL_SIZE
index|]
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|int
name|optim
decl_stmt|;
name|value
name|v
init|=
name|allocate_value
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|char
modifier|*
name|value_bytes
init|=
literal|0
decl_stmt|;
name|int
name|value_bytes_copied
init|=
literal|0
decl_stmt|;
name|int
name|num_storage_locs
decl_stmt|;
name|enum
name|lval_type
name|lval
decl_stmt|;
name|VALUE_REGNO
argument_list|(
name|v
argument_list|)
operator|=
name|regnum
expr_stmt|;
name|num_storage_locs
operator|=
operator|(
name|len
operator|>
name|REGISTER_VIRTUAL_SIZE
argument_list|(
name|regnum
argument_list|)
condition|?
operator|(
operator|(
name|len
operator|-
literal|1
operator|)
operator|/
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
operator|)
operator|+
literal|1
else|:
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|num_storage_locs
operator|>
literal|1
ifdef|#
directive|ifdef
name|GDB_TARGET_IS_H8500
operator|||
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_PTR
endif|#
directive|endif
condition|)
block|{
comment|/* Value spread across multiple storage locations.  */
name|int
name|local_regnum
decl_stmt|;
name|int
name|mem_stor
init|=
literal|0
decl_stmt|,
name|reg_stor
init|=
literal|0
decl_stmt|;
name|int
name|mem_tracking
init|=
literal|1
decl_stmt|;
name|CORE_ADDR
name|last_addr
init|=
literal|0
decl_stmt|;
name|CORE_ADDR
name|first_addr
init|=
literal|0
decl_stmt|;
name|value_bytes
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
operator|+
name|MAX_REGISTER_RAW_SIZE
argument_list|)
expr_stmt|;
comment|/* Copy all of the data out, whereever it may be.  */
ifdef|#
directive|ifdef
name|GDB_TARGET_IS_H8500
comment|/* This piece of hideosity is required because the H8500 treats registers    differently depending upon whether they are used as pointers or not.  As a    pointer, a register needs to have a page register tacked onto the front.    An alternate way to do this would be to have gcc output different register    numbers for the pointer& non-pointer form of the register.  But, it    doesn't, so we're stuck with this.  */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_PTR
operator|&&
name|len
operator|>
literal|2
condition|)
block|{
name|int
name|page_regnum
decl_stmt|;
switch|switch
condition|(
name|regnum
condition|)
block|{
case|case
name|R0_REGNUM
case|:
case|case
name|R1_REGNUM
case|:
case|case
name|R2_REGNUM
case|:
case|case
name|R3_REGNUM
case|:
name|page_regnum
operator|=
name|SEG_D_REGNUM
expr_stmt|;
break|break;
case|case
name|R4_REGNUM
case|:
case|case
name|R5_REGNUM
case|:
name|page_regnum
operator|=
name|SEG_E_REGNUM
expr_stmt|;
break|break;
case|case
name|R6_REGNUM
case|:
case|case
name|R7_REGNUM
case|:
name|page_regnum
operator|=
name|SEG_T_REGNUM
expr_stmt|;
break|break;
block|}
name|value_bytes
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|get_saved_register
argument_list|(
name|value_bytes
operator|+
literal|1
argument_list|,
operator|&
name|optim
argument_list|,
operator|&
name|addr
argument_list|,
name|frame
argument_list|,
name|page_regnum
argument_list|,
operator|&
name|lval
argument_list|)
expr_stmt|;
if|if
condition|(
name|lval
operator|==
name|lval_register
condition|)
name|reg_stor
operator|++
expr_stmt|;
else|else
name|mem_stor
operator|++
expr_stmt|;
name|first_addr
operator|=
name|addr
expr_stmt|;
name|last_addr
operator|=
name|addr
expr_stmt|;
name|get_saved_register
argument_list|(
name|value_bytes
operator|+
literal|2
argument_list|,
operator|&
name|optim
argument_list|,
operator|&
name|addr
argument_list|,
name|frame
argument_list|,
name|regnum
argument_list|,
operator|&
name|lval
argument_list|)
expr_stmt|;
if|if
condition|(
name|lval
operator|==
name|lval_register
condition|)
name|reg_stor
operator|++
expr_stmt|;
else|else
block|{
name|mem_stor
operator|++
expr_stmt|;
name|mem_tracking
operator|=
name|mem_tracking
operator|&&
operator|(
name|addr
operator|==
name|last_addr
operator|)
expr_stmt|;
block|}
name|last_addr
operator|=
name|addr
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* GDB_TARGET_IS_H8500 */
for|for
control|(
name|local_regnum
operator|=
name|regnum
init|;
name|value_bytes_copied
operator|<
name|len
condition|;
operator|(
name|value_bytes_copied
operator|+=
name|REGISTER_RAW_SIZE
argument_list|(
name|local_regnum
argument_list|)
operator|,
operator|++
name|local_regnum
operator|)
control|)
block|{
name|get_saved_register
argument_list|(
name|value_bytes
operator|+
name|value_bytes_copied
argument_list|,
operator|&
name|optim
argument_list|,
operator|&
name|addr
argument_list|,
name|frame
argument_list|,
name|local_regnum
argument_list|,
operator|&
name|lval
argument_list|)
expr_stmt|;
if|if
condition|(
name|regnum
operator|==
name|local_regnum
condition|)
name|first_addr
operator|=
name|addr
expr_stmt|;
if|if
condition|(
name|lval
operator|==
name|lval_register
condition|)
name|reg_stor
operator|++
expr_stmt|;
else|else
block|{
name|mem_stor
operator|++
expr_stmt|;
name|mem_tracking
operator|=
operator|(
name|mem_tracking
operator|&&
operator|(
name|regnum
operator|==
name|local_regnum
operator|||
name|addr
operator|==
name|last_addr
operator|)
operator|)
expr_stmt|;
block|}
name|last_addr
operator|=
name|addr
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|reg_stor
operator|&&
name|mem_stor
operator|)
operator|||
operator|(
name|mem_stor
operator|&&
operator|!
name|mem_tracking
operator|)
condition|)
comment|/* Mixed storage; all of the hassle we just went through was 	   for some good purpose.  */
block|{
name|VALUE_LVAL
argument_list|(
name|v
argument_list|)
operator|=
name|lval_reg_frame_relative
expr_stmt|;
name|VALUE_FRAME
argument_list|(
name|v
argument_list|)
operator|=
name|FRAME_FP
argument_list|(
name|frame
argument_list|)
expr_stmt|;
name|VALUE_FRAME_REGNUM
argument_list|(
name|v
argument_list|)
operator|=
name|regnum
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mem_stor
condition|)
block|{
name|VALUE_LVAL
argument_list|(
name|v
argument_list|)
operator|=
name|lval_memory
expr_stmt|;
name|VALUE_ADDRESS
argument_list|(
name|v
argument_list|)
operator|=
name|first_addr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reg_stor
condition|)
block|{
name|VALUE_LVAL
argument_list|(
name|v
argument_list|)
operator|=
name|lval_register
expr_stmt|;
name|VALUE_ADDRESS
argument_list|(
name|v
argument_list|)
operator|=
name|first_addr
expr_stmt|;
block|}
else|else
name|fatal
argument_list|(
literal|"value_from_register: Value not stored anywhere!"
argument_list|)
expr_stmt|;
name|VALUE_OPTIMIZED_OUT
argument_list|(
name|v
argument_list|)
operator|=
name|optim
expr_stmt|;
comment|/* Any structure stored in more than one register will always be 	 an integral number of registers.  Otherwise, you'd need to do 	 some fiddling with the last register copied here for little 	 endian machines.  */
comment|/* Copy into the contents section of the value.  */
name|memcpy
argument_list|(
name|VALUE_CONTENTS_RAW
argument_list|(
name|v
argument_list|)
argument_list|,
name|value_bytes
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Finally do any conversion necessary when extracting this          type from more than one register.  */
ifdef|#
directive|ifdef
name|REGISTER_CONVERT_TO_TYPE
name|REGISTER_CONVERT_TO_TYPE
argument_list|(
name|regnum
argument_list|,
name|type
argument_list|,
name|VALUE_CONTENTS_RAW
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|v
return|;
block|}
comment|/* Data is completely contained within a single register.  Locate the      register's contents in a real register or in core;      read the data in raw format.  */
name|get_saved_register
argument_list|(
name|raw_buffer
argument_list|,
operator|&
name|optim
argument_list|,
operator|&
name|addr
argument_list|,
name|frame
argument_list|,
name|regnum
argument_list|,
operator|&
name|lval
argument_list|)
expr_stmt|;
name|VALUE_OPTIMIZED_OUT
argument_list|(
name|v
argument_list|)
operator|=
name|optim
expr_stmt|;
name|VALUE_LVAL
argument_list|(
name|v
argument_list|)
operator|=
name|lval
expr_stmt|;
name|VALUE_ADDRESS
argument_list|(
name|v
argument_list|)
operator|=
name|addr
expr_stmt|;
comment|/* Convert the raw contents to virtual contents.      (Just copy them if the formats are the same.)  */
name|REGISTER_CONVERT_TO_VIRTUAL
argument_list|(
name|regnum
argument_list|,
name|raw_buffer
argument_list|,
name|virtual_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|REGISTER_CONVERTIBLE
argument_list|(
name|regnum
argument_list|)
condition|)
block|{
comment|/* When the raw and virtual formats differ, the virtual format 	 corresponds to a specific data type.  If we want that type, 	 copy the data into the value. 	 Otherwise, do a type-conversion.  */
if|if
condition|(
name|type
operator|!=
name|REGISTER_VIRTUAL_TYPE
argument_list|(
name|regnum
argument_list|)
condition|)
block|{
comment|/* eg a variable of type `float' in a 68881 register 	     with raw type `extended' and virtual type `double'. 	     Fetch it as a `double' and then convert to `float'.  */
comment|/* FIXME: This value will be not_lval, which means we can't assign 	     to it.  Probably the right fix is to do the cast on a temporary 	     value, and just copy the VALUE_CONTENTS over.  */
name|v
operator|=
name|allocate_value
argument_list|(
name|REGISTER_VIRTUAL_TYPE
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|VALUE_CONTENTS_RAW
argument_list|(
name|v
argument_list|)
argument_list|,
name|virtual_buffer
argument_list|,
name|REGISTER_VIRTUAL_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
name|v
operator|=
name|value_cast
argument_list|(
name|type
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
else|else
name|memcpy
argument_list|(
name|VALUE_CONTENTS_RAW
argument_list|(
name|v
argument_list|)
argument_list|,
name|virtual_buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Raw and virtual formats are the same for this register.  */
if|#
directive|if
name|TARGET_BYTE_ORDER
operator|==
name|BIG_ENDIAN
if|if
condition|(
name|len
operator|<
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
condition|)
block|{
comment|/* Big-endian, and we want less than full size.  */
name|VALUE_OFFSET
argument_list|(
name|v
argument_list|)
operator|=
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
operator|-
name|len
expr_stmt|;
block|}
endif|#
directive|endif
name|memcpy
argument_list|(
name|VALUE_CONTENTS_RAW
argument_list|(
name|v
argument_list|)
argument_list|,
name|virtual_buffer
operator|+
name|VALUE_OFFSET
argument_list|(
name|v
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
return|return
name|v
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a struct symbol for a variable or function,    and a stack frame id,     return a (pointer to a) struct value containing the properly typed    address.  */
end_comment

begin_function
name|value
name|locate_var_value
parameter_list|(
name|var
parameter_list|,
name|frame
parameter_list|)
specifier|register
name|struct
name|symbol
modifier|*
name|var
decl_stmt|;
name|FRAME
name|frame
decl_stmt|;
block|{
name|CORE_ADDR
name|addr
init|=
literal|0
decl_stmt|;
name|struct
name|type
modifier|*
name|type
init|=
name|SYMBOL_TYPE
argument_list|(
name|var
argument_list|)
decl_stmt|;
name|value
name|lazy_value
decl_stmt|;
comment|/* Evaluate it first; if the result is a memory address, we're fine.      Lazy evaluation pays off here. */
name|lazy_value
operator|=
name|read_var_value
argument_list|(
name|var
argument_list|,
name|frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|lazy_value
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Address of \"%s\" is unknown."
argument_list|,
name|SYMBOL_SOURCE_NAME
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|VALUE_LAZY
argument_list|(
name|lazy_value
argument_list|)
operator|||
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_FUNC
condition|)
block|{
name|addr
operator|=
name|VALUE_ADDRESS
argument_list|(
name|lazy_value
argument_list|)
expr_stmt|;
return|return
name|value_from_longest
argument_list|(
name|lookup_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
operator|(
name|LONGEST
operator|)
name|addr
argument_list|)
return|;
block|}
comment|/* Not a memory address; check what the problem was.  */
switch|switch
condition|(
name|VALUE_LVAL
argument_list|(
name|lazy_value
argument_list|)
condition|)
block|{
case|case
name|lval_register
case|:
case|case
name|lval_reg_frame_relative
case|:
name|error
argument_list|(
literal|"Address requested for identifier \"%s\" which is in a register."
argument_list|,
name|SYMBOL_SOURCE_NAME
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Can't take address of \"%s\" which isn't an lvalue."
argument_list|,
name|SYMBOL_SOURCE_NAME
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
literal|0
return|;
comment|/* For lint -- never reached */
block|}
end_function

end_unit

