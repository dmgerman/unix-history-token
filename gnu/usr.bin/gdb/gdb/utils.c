begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* General utility routines for GDB, the GNU debugger.    Copyright 1986, 1989, 1990, 1991, 1992 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__GO32__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"signals.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"serial.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"annotate.h"
end_include

begin_include
include|#
directive|include
file|"readline.h"
end_include

begin_comment
comment|/* readline defines this.  */
end_comment

begin_undef
undef|#
directive|undef
name|savestring
end_undef

begin_comment
comment|/* Prototypes for local functions */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NO_MMALLOC
argument_list|)
operator|||
name|defined
argument_list|(
name|NO_MMALLOC_CHECK
argument_list|)
end_if

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|void
name|malloc_botch
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NO_MMALLOC, etc */
end_comment

begin_function_decl
specifier|static
name|void
name|fatal_dump_core
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Can't prototype with<varargs.h> usage... */
end_comment

begin_decl_stmt
specifier|static
name|void
name|prompt_for_continue
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_width_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
expr|struct
name|cmd_list_element
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If this definition isn't overridden by the header files, assume    that isatty and fileno exist on this system.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ISATTY
end_ifndef

begin_define
define|#
directive|define
name|ISATTY
parameter_list|(
name|FP
parameter_list|)
value|(isatty (fileno (FP)))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Chain of cleanup actions established with make_cleanup,    to be executed if an error happens.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cleanup
modifier|*
name|cleanup_chain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we have job control. */
end_comment

begin_decl_stmt
name|int
name|job_control
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means a quit has been requested.  */
end_comment

begin_decl_stmt
name|int
name|quit_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means quit immediately if Control-C is typed now, rather    than waiting until QUIT is executed.  Be careful in setting this;    code which executes with immediate_quit set has to be very careful    about being able to deal with being interrupted at any time.  It is    almost always better to use QUIT; the only exception I can think of    is being able to quit out of a system call (using EINTR loses if    the SIGINT happens between the previous QUIT and the system call).    To immediately quit in the case in which a SIGINT happens between    the previous QUIT and setting immediate_quit (desirable anytime we    expect to block), call QUIT after setting immediate_quit.  */
end_comment

begin_decl_stmt
name|int
name|immediate_quit
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means that encoded C++ names should be printed out in their    C++ form rather than raw.  */
end_comment

begin_decl_stmt
name|int
name|demangle
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means that encoded C++ names should be printed out in their    C++ form even in assembler language displays.  If this is set, but    DEMANGLE is zero, names are printed raw, i.e. DEMANGLE controls.  */
end_comment

begin_decl_stmt
name|int
name|asm_demangle
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means that strings with character values>0x7F should be printed    as octal escapes.  Zero means just print the value (e.g. it's an    international character, and the terminal or window can cope.)  */
end_comment

begin_decl_stmt
name|int
name|sevenbit_strings
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* String to be printed before error messages, if any.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|error_pre_print
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|warning_pre_print
init|=
literal|"\nwarning: "
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Add a new cleanup to the cleanup_chain,    and return the previous chain pointer    to be passed later to do_cleanups or discard_cleanups.    Args are FUNCTION to clean up with, and ARG to pass to it.  */
end_comment

begin_function_decl
name|struct
name|cleanup
modifier|*
name|make_cleanup
parameter_list|(
name|function
parameter_list|,
name|arg
parameter_list|)
function_decl|void
parameter_list|(
function_decl|*function
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|PTR
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|cleanup
modifier|*
name|new
init|=
operator|(
expr|struct
name|cleanup
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cleanup
argument_list|)
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|cleanup
modifier|*
name|old_chain
init|=
name|cleanup_chain
decl_stmt|;
name|new
operator|->
name|next
operator|=
name|cleanup_chain
expr_stmt|;
name|new
operator|->
name|function
operator|=
name|function
expr_stmt|;
name|new
operator|->
name|arg
operator|=
name|arg
expr_stmt|;
name|cleanup_chain
operator|=
name|new
expr_stmt|;
return|return
name|old_chain
return|;
block|}
end_block

begin_comment
comment|/* Discard cleanups and do the actions they describe    until we get back to the point OLD_CHAIN in the cleanup_chain.  */
end_comment

begin_function
name|void
name|do_cleanups
parameter_list|(
name|old_chain
parameter_list|)
specifier|register
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
block|{
specifier|register
name|struct
name|cleanup
modifier|*
name|ptr
decl_stmt|;
while|while
condition|(
operator|(
name|ptr
operator|=
name|cleanup_chain
operator|)
operator|!=
name|old_chain
condition|)
block|{
name|cleanup_chain
operator|=
name|ptr
operator|->
name|next
expr_stmt|;
comment|/* Do this first incase recursion */
call|(
modifier|*
name|ptr
operator|->
name|function
call|)
argument_list|(
name|ptr
operator|->
name|arg
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Discard cleanups, not doing the actions they describe,    until we get back to the point OLD_CHAIN in the cleanup_chain.  */
end_comment

begin_function
name|void
name|discard_cleanups
parameter_list|(
name|old_chain
parameter_list|)
specifier|register
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
block|{
specifier|register
name|struct
name|cleanup
modifier|*
name|ptr
decl_stmt|;
while|while
condition|(
operator|(
name|ptr
operator|=
name|cleanup_chain
operator|)
operator|!=
name|old_chain
condition|)
block|{
name|cleanup_chain
operator|=
name|ptr
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|ptr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Set the cleanup_chain to 0, and return the old cleanup chain.  */
end_comment

begin_function
name|struct
name|cleanup
modifier|*
name|save_cleanups
parameter_list|()
block|{
name|struct
name|cleanup
modifier|*
name|old_chain
init|=
name|cleanup_chain
decl_stmt|;
name|cleanup_chain
operator|=
literal|0
expr_stmt|;
return|return
name|old_chain
return|;
block|}
end_function

begin_comment
comment|/* Restore the cleanup chain from a previously saved chain.  */
end_comment

begin_function
name|void
name|restore_cleanups
parameter_list|(
name|chain
parameter_list|)
name|struct
name|cleanup
modifier|*
name|chain
decl_stmt|;
block|{
name|cleanup_chain
operator|=
name|chain
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function is useful for cleanups.    Do       foo = xmalloc (...);      old_chain = make_cleanup (free_current_contents,&foo);     to arrange to free the object thus allocated.  */
end_comment

begin_function
name|void
name|free_current_contents
parameter_list|(
name|location
parameter_list|)
name|char
modifier|*
modifier|*
name|location
decl_stmt|;
block|{
name|free
argument_list|(
operator|*
name|location
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Provide a known function that does nothing, to use as a base for    for a possibly long chain of cleanups.  This is useful where we    use the cleanup chain for handling normal cleanups as well as dealing    with cleanups that need to be done as a result of a call to error().    In such cases, we may not be certain where the first cleanup is, unless    we have a do-nothing one to always use as the base. */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|null_cleanup
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
modifier|*
name|arg
decl_stmt|;
block|{ }
end_function

begin_escape
end_escape

begin_comment
comment|/* Provide a hook for modules wishing to print their own warning messages    to set up the terminal state in a compatible way, without them having    to import all the target_<...> macros. */
end_comment

begin_function
name|void
name|warning_setup
parameter_list|()
block|{
name|target_terminal_ours
argument_list|()
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|/* Force out any buffered output */
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print a warning message.    The first argument STRING is the warning message, used as a fprintf string,    and the remaining args are passed as arguments to it.    The primary difference between warnings and errors is that a warning    does not force the return to command level. */
end_comment

begin_comment
comment|/* VARARGS */
end_comment

begin_function
name|void
name|warning
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
block|{
name|va_list
name|args
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|target_terminal_ours
argument_list|()
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|/* Force out any buffered output */
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|warning_pre_print
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
name|warning_pre_print
argument_list|)
expr_stmt|;
name|string
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|vfprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
name|string
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Start the printing of an error message.  Way to use this is to call    this, output the error message (use filtered output), and then call    return_to_top_level (RETURN_ERROR).  error() provides a convenient way to    do this for the special case that the error message can be formatted with    a single printf call, but this is more general.  */
end_comment

begin_function
name|void
name|error_begin
parameter_list|()
block|{
name|target_terminal_ours
argument_list|()
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|/* Force out any buffered output */
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
name|annotate_error_begin
argument_list|()
expr_stmt|;
if|if
condition|(
name|error_pre_print
condition|)
name|fprintf_filtered
argument_list|(
name|gdb_stderr
argument_list|,
name|error_pre_print
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print an error message and return to command level.    The first argument STRING is the error message, used as a fprintf string,    and the remaining args are passed as arguments to it.  */
end_comment

begin_comment
comment|/* VARARGS */
end_comment

begin_function
name|NORETURN
name|void
name|error
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
block|{
name|va_list
name|args
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|error_begin
argument_list|()
expr_stmt|;
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|string
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|vfprintf_filtered
argument_list|(
name|gdb_stderr
argument_list|,
name|string
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|return_to_top_level
argument_list|(
name|RETURN_ERROR
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print an error message and exit reporting failure.    This is for a error that we cannot continue from.    The arguments are printed a la printf.     This function cannot be declared volatile (NORETURN) in an    ANSI environment because exit() is not declared volatile. */
end_comment

begin_comment
comment|/* VARARGS */
end_comment

begin_function
name|NORETURN
name|void
name|fatal
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
block|{
name|va_list
name|args
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|string
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"\ngdb: "
argument_list|)
expr_stmt|;
name|vfprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
name|string
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print an error message and exit, dumping core.    The arguments are printed a la printf ().  */
end_comment

begin_comment
comment|/* VARARGS */
end_comment

begin_function
specifier|static
name|void
name|fatal_dump_core
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
block|{
name|va_list
name|args
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|string
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
comment|/* "internal error" is always correct, since GDB should never dump      core, no matter what the input.  */
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"\ngdb internal error: "
argument_list|)
expr_stmt|;
name|vfprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
name|string
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|SIGQUIT
argument_list|)
expr_stmt|;
comment|/* We should never get here, but just in case...  */
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The strerror() function can return NULL for errno values that are    out of range.  Provide a "safe" version that always returns a    printable string. */
end_comment

begin_function
name|char
modifier|*
name|safe_strerror
parameter_list|(
name|errnum
parameter_list|)
name|int
name|errnum
decl_stmt|;
block|{
name|char
modifier|*
name|msg
decl_stmt|;
specifier|static
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|msg
operator|=
name|strerror
argument_list|(
name|errnum
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"(undocumented errno %d)"
argument_list|,
name|errnum
argument_list|)
expr_stmt|;
name|msg
operator|=
name|buf
expr_stmt|;
block|}
return|return
operator|(
name|msg
operator|)
return|;
block|}
end_function

begin_comment
comment|/* The strsignal() function can return NULL for signal values that are    out of range.  Provide a "safe" version that always returns a    printable string. */
end_comment

begin_function
name|char
modifier|*
name|safe_strsignal
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
name|char
modifier|*
name|msg
decl_stmt|;
specifier|static
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|msg
operator|=
name|strsignal
argument_list|(
name|signo
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"(undocumented signal %d)"
argument_list|,
name|signo
argument_list|)
expr_stmt|;
name|msg
operator|=
name|buf
expr_stmt|;
block|}
return|return
operator|(
name|msg
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Print the system error message for errno, and also mention STRING    as the file name for which the error was encountered.    Then return to command level.  */
end_comment

begin_function
name|void
name|perror_with_name
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|char
modifier|*
name|err
decl_stmt|;
name|char
modifier|*
name|combined
decl_stmt|;
name|err
operator|=
name|safe_strerror
argument_list|(
name|errno
argument_list|)
expr_stmt|;
name|combined
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|err
argument_list|)
operator|+
name|strlen
argument_list|(
name|string
argument_list|)
operator|+
literal|3
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|combined
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|combined
argument_list|,
literal|": "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|combined
argument_list|,
name|err
argument_list|)
expr_stmt|;
comment|/* I understand setting these is a matter of taste.  Still, some people      may clear errno but not know about bfd_error.  Doing this here is not      unreasonable. */
name|bfd_set_error
argument_list|(
name|bfd_error_no_error
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|error
argument_list|(
literal|"%s."
argument_list|,
name|combined
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print the system error message for ERRCODE, and also mention STRING    as the file name for which the error was encountered.  */
end_comment

begin_function
name|void
name|print_sys_errmsg
parameter_list|(
name|string
parameter_list|,
name|errcode
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|errcode
decl_stmt|;
block|{
name|char
modifier|*
name|err
decl_stmt|;
name|char
modifier|*
name|combined
decl_stmt|;
name|err
operator|=
name|safe_strerror
argument_list|(
name|errcode
argument_list|)
expr_stmt|;
name|combined
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|err
argument_list|)
operator|+
name|strlen
argument_list|(
name|string
argument_list|)
operator|+
literal|3
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|combined
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|combined
argument_list|,
literal|": "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|combined
argument_list|,
name|err
argument_list|)
expr_stmt|;
comment|/* We want anything which was printed on stdout to come out first, before      this message.  */
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"%s.\n"
argument_list|,
name|combined
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Control C eventually causes this to be called, at a convenient time.  */
end_comment

begin_function
name|void
name|quit
parameter_list|()
block|{
name|serial_t
name|gdb_stdout_serial
init|=
name|serial_fdopen
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|target_terminal_ours
argument_list|()
expr_stmt|;
comment|/* We want all output to appear now, before we print "Quit".  We      have 3 levels of buffering we have to flush (it's possible that      some of these should be changed to flush the lower-level ones      too):  */
comment|/* 1.  The _filtered buffer.  */
name|wrap_here
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* 2.  The stdio buffer.  */
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stderr
argument_list|)
expr_stmt|;
comment|/* 3.  The system-level buffer.  */
name|SERIAL_FLUSH_OUTPUT
argument_list|(
name|gdb_stdout_serial
argument_list|)
expr_stmt|;
name|SERIAL_UN_FDOPEN
argument_list|(
name|gdb_stdout_serial
argument_list|)
expr_stmt|;
name|annotate_error_begin
argument_list|()
expr_stmt|;
comment|/* Don't use *_filtered; we don't want to prompt the user to continue.  */
if|if
condition|(
name|error_pre_print
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
name|error_pre_print
argument_list|)
expr_stmt|;
if|if
condition|(
name|job_control
comment|/* If there is no terminal switching for this target, then we can't 	 possibly get screwed by the lack of job control.  */
operator|||
name|current_target
operator|->
name|to_terminal_ours
operator|==
name|NULL
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Quit\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Quit (expect signal SIGINT when the program is resumed)\n"
argument_list|)
expr_stmt|;
name|return_to_top_level
argument_list|(
name|RETURN_QUIT
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__GO32__
end_ifdef

begin_comment
comment|/* In the absence of signals, poll keyboard for a quit.    Called from #define QUIT pollquit() in xm-go32.h. */
end_comment

begin_function
name|void
name|pollquit
parameter_list|()
block|{
if|if
condition|(
name|kbhit
argument_list|()
condition|)
block|{
name|int
name|k
init|=
name|getkey
argument_list|()
decl_stmt|;
if|if
condition|(
name|k
operator|==
literal|1
condition|)
block|{
name|quit_flag
operator|=
literal|1
expr_stmt|;
name|quit
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|k
operator|==
literal|2
condition|)
block|{
name|immediate_quit
operator|=
literal|1
expr_stmt|;
name|quit
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* We just ignore it */
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"CTRL-A to quit, CTRL-B to quit harder\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__GO32__
end_ifdef

begin_function
name|void
name|notice_quit
parameter_list|()
block|{
if|if
condition|(
name|kbhit
argument_list|()
condition|)
block|{
name|int
name|k
init|=
name|getkey
argument_list|()
decl_stmt|;
if|if
condition|(
name|k
operator|==
literal|1
condition|)
block|{
name|quit_flag
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|k
operator|==
literal|2
condition|)
block|{
name|immediate_quit
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"CTRL-A to quit, CTRL-B to quit harder\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
name|void
name|notice_quit
parameter_list|()
block|{
comment|/* Done by signals */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Control C comes here */
end_comment

begin_function
name|void
name|request_quit
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
name|quit_flag
operator|=
literal|1
expr_stmt|;
comment|/* Restore the signal handler.  Harmless with BSD-style signals, needed      for System V-style signals.  So just always do it, rather than worrying      about USG defines and stuff like that.  */
name|signal
argument_list|(
name|signo
argument_list|,
name|request_quit
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|REQUEST_QUIT
name|REQUEST_QUIT
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|immediate_quit
condition|)
name|quit
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Memory management stuff (malloc friends).  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NO_MMALLOC
argument_list|)
end_if

begin_function
name|PTR
name|mmalloc
parameter_list|(
name|md
parameter_list|,
name|size
parameter_list|)
name|PTR
name|md
decl_stmt|;
name|long
name|size
decl_stmt|;
block|{
return|return
operator|(
name|malloc
argument_list|(
name|size
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|PTR
name|mrealloc
parameter_list|(
name|md
parameter_list|,
name|ptr
parameter_list|,
name|size
parameter_list|)
name|PTR
name|md
decl_stmt|;
name|PTR
name|ptr
decl_stmt|;
name|long
name|size
decl_stmt|;
block|{
if|if
condition|(
name|ptr
operator|==
literal|0
condition|)
comment|/* Guard against old realloc's */
return|return
name|malloc
argument_list|(
name|size
argument_list|)
return|;
else|else
return|return
name|realloc
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|mfree
parameter_list|(
name|md
parameter_list|,
name|ptr
parameter_list|)
name|PTR
name|md
decl_stmt|;
name|PTR
name|ptr
decl_stmt|;
block|{
name|free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NO_MMALLOC */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NO_MMALLOC
argument_list|)
operator|||
name|defined
argument_list|(
name|NO_MMALLOC_CHECK
argument_list|)
end_if

begin_function
name|void
name|init_malloc
parameter_list|(
name|md
parameter_list|)
name|PTR
name|md
decl_stmt|;
block|{ }
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* have mmalloc and want corruption checking  */
end_comment

begin_function
specifier|static
name|void
name|malloc_botch
parameter_list|()
block|{
name|fatal_dump_core
argument_list|(
literal|"Memory corruption"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Attempt to install hooks in mmalloc/mrealloc/mfree for the heap specified    by MD, to detect memory corruption.  Note that MD may be NULL to specify    the default heap that grows via sbrk.     Note that for freshly created regions, we must call mmcheck prior to any    mallocs in the region.  Otherwise, any region which was allocated prior to    installing the checking hooks, which is later reallocated or freed, will    fail the checks!  The mmcheck function only allows initial hooks to be    installed before the first mmalloc.  However, anytime after we have called    mmcheck the first time to install the checking hooks, we can call it again    to update the function pointer to the memory corruption handler.     Returns zero on failure, non-zero on success. */
end_comment

begin_function
name|void
name|init_malloc
parameter_list|(
name|md
parameter_list|)
name|PTR
name|md
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|mmcheck
argument_list|(
name|md
argument_list|,
name|malloc_botch
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"internal error: failed to install memory consistency checks"
argument_list|)
expr_stmt|;
block|}
name|mmtrace
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Have mmalloc and want corruption checking  */
end_comment

begin_comment
comment|/* Called when a memory allocation fails, with the number of bytes of    memory requested in SIZE. */
end_comment

begin_function
name|NORETURN
name|void
name|nomem
parameter_list|(
name|size
parameter_list|)
name|long
name|size
decl_stmt|;
block|{
if|if
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|fatal
argument_list|(
literal|"virtual memory exhausted: can't allocate %ld bytes."
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fatal
argument_list|(
literal|"virtual memory exhausted."
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Like mmalloc but get error if no storage available, and protect against    the caller wanting to allocate zero bytes.  Whether to return NULL for    a zero byte request, or translate the request into a request for one    byte of zero'd storage, is a religious issue. */
end_comment

begin_function
name|PTR
name|xmmalloc
parameter_list|(
name|md
parameter_list|,
name|size
parameter_list|)
name|PTR
name|md
decl_stmt|;
name|long
name|size
decl_stmt|;
block|{
specifier|register
name|PTR
name|val
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
name|val
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|val
operator|=
name|mmalloc
argument_list|(
name|md
argument_list|,
name|size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|nomem
argument_list|(
name|size
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Like mrealloc but get error if no storage available.  */
end_comment

begin_function
name|PTR
name|xmrealloc
parameter_list|(
name|md
parameter_list|,
name|ptr
parameter_list|,
name|size
parameter_list|)
name|PTR
name|md
decl_stmt|;
name|PTR
name|ptr
decl_stmt|;
name|long
name|size
decl_stmt|;
block|{
specifier|register
name|PTR
name|val
decl_stmt|;
if|if
condition|(
name|ptr
operator|!=
name|NULL
condition|)
block|{
name|val
operator|=
name|mrealloc
argument_list|(
name|md
argument_list|,
name|ptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|val
operator|=
name|mmalloc
argument_list|(
name|md
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|==
name|NULL
condition|)
block|{
name|nomem
argument_list|(
name|size
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Like malloc but get error if no storage available, and protect against    the caller wanting to allocate zero bytes.  */
end_comment

begin_function
name|PTR
name|xmalloc
parameter_list|(
name|size
parameter_list|)
name|long
name|size
decl_stmt|;
block|{
return|return
operator|(
name|xmmalloc
argument_list|(
operator|(
name|PTR
operator|)
name|NULL
argument_list|,
name|size
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Like mrealloc but get error if no storage available.  */
end_comment

begin_function
name|PTR
name|xrealloc
parameter_list|(
name|ptr
parameter_list|,
name|size
parameter_list|)
name|PTR
name|ptr
decl_stmt|;
name|long
name|size
decl_stmt|;
block|{
return|return
operator|(
name|xmrealloc
argument_list|(
operator|(
name|PTR
operator|)
name|NULL
argument_list|,
name|ptr
argument_list|,
name|size
argument_list|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* My replacement for the read system call.    Used like `read' but keeps going if `read' returns too soon.  */
end_comment

begin_function
name|int
name|myread
parameter_list|(
name|desc
parameter_list|,
name|addr
parameter_list|,
name|len
parameter_list|)
name|int
name|desc
decl_stmt|;
name|char
modifier|*
name|addr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
specifier|register
name|int
name|val
decl_stmt|;
name|int
name|orglen
init|=
name|len
decl_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|val
operator|=
name|read
argument_list|(
name|desc
argument_list|,
name|addr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
return|return
name|val
return|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
return|return
name|orglen
operator|-
name|len
return|;
name|len
operator|-=
name|val
expr_stmt|;
name|addr
operator|+=
name|val
expr_stmt|;
block|}
return|return
name|orglen
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make a copy of the string at PTR with SIZE characters    (and add a null character at the end in the copy).    Uses malloc to get the space.  Returns the address of the copy.  */
end_comment

begin_function
name|char
modifier|*
name|savestring
parameter_list|(
name|ptr
parameter_list|,
name|size
parameter_list|)
specifier|const
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|size
operator|+
literal|1
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|ptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|p
index|[
name|size
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|msavestring
parameter_list|(
name|md
parameter_list|,
name|ptr
parameter_list|,
name|size
parameter_list|)
name|PTR
name|md
decl_stmt|;
specifier|const
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
init|=
operator|(
name|char
operator|*
operator|)
name|xmmalloc
argument_list|(
name|md
argument_list|,
name|size
operator|+
literal|1
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|ptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|p
index|[
name|size
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* The "const" is so it compiles under DGUX (which prototypes strsave    in<string.h>.  FIXME: This should be named "xstrsave", shouldn't it?    Doesn't real strsave return NULL if out of memory?  */
end_comment

begin_function
name|char
modifier|*
name|strsave
parameter_list|(
name|ptr
parameter_list|)
specifier|const
name|char
modifier|*
name|ptr
decl_stmt|;
block|{
return|return
name|savestring
argument_list|(
name|ptr
argument_list|,
name|strlen
argument_list|(
name|ptr
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|mstrsave
parameter_list|(
name|md
parameter_list|,
name|ptr
parameter_list|)
name|PTR
name|md
decl_stmt|;
specifier|const
name|char
modifier|*
name|ptr
decl_stmt|;
block|{
return|return
operator|(
name|msavestring
argument_list|(
name|md
argument_list|,
name|ptr
argument_list|,
name|strlen
argument_list|(
name|ptr
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|print_spaces
parameter_list|(
name|n
parameter_list|,
name|file
parameter_list|)
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
while|while
condition|(
name|n
operator|--
operator|>
literal|0
condition|)
name|fputc
argument_list|(
literal|' '
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print a host address.  */
end_comment

begin_function
name|void
name|gdb_print_address
parameter_list|(
name|addr
parameter_list|,
name|stream
parameter_list|)
name|PTR
name|addr
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
block|{
comment|/* We could use the %p conversion specifier to fprintf if we had any      way of knowing whether this host supports it.  But the following      should work on the Alpha and on 32 bit machines.  */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"0x%lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|addr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Ask user a y-or-n question and return 1 iff answer is yes.    Takes three args which are given to printf to print the question.    The first, a control string, should end in "? ".    It should not say how to answer, because we do that.  */
end_comment

begin_comment
comment|/* VARARGS */
end_comment

begin_function
name|int
name|query
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
block|{
name|va_list
name|args
decl_stmt|;
name|char
modifier|*
name|ctlstr
decl_stmt|;
specifier|register
name|int
name|answer
decl_stmt|;
specifier|register
name|int
name|ans2
decl_stmt|;
name|int
name|retval
decl_stmt|;
comment|/* Automatically answer "yes" if input is not from a terminal.  */
if|if
condition|(
operator|!
name|input_from_terminal_p
argument_list|()
condition|)
return|return
literal|1
return|;
while|while
condition|(
literal|1
condition|)
block|{
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|/* Flush any buffered output */
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|annotation_level
operator|>
literal|1
condition|)
name|printf_filtered
argument_list|(
literal|"\n\032\032pre-query\n"
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|ctlstr
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|vfprintf_filtered
argument_list|(
name|gdb_stdout
argument_list|,
name|ctlstr
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"(y or n) "
argument_list|)
expr_stmt|;
if|if
condition|(
name|annotation_level
operator|>
literal|1
condition|)
name|printf_filtered
argument_list|(
literal|"\n\032\032query\n"
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
name|answer
operator|=
name|fgetc
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
name|clearerr
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
comment|/* in case of C-d */
if|if
condition|(
name|answer
operator|==
name|EOF
condition|)
comment|/* C-d */
block|{
name|retval
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|answer
operator|!=
literal|'\n'
condition|)
comment|/* Eat rest of input line, to EOF or newline */
do|do
block|{
name|ans2
operator|=
name|fgetc
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
name|clearerr
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ans2
operator|!=
name|EOF
operator|&&
name|ans2
operator|!=
literal|'\n'
condition|)
do|;
if|if
condition|(
name|answer
operator|>=
literal|'a'
condition|)
name|answer
operator|-=
literal|040
expr_stmt|;
if|if
condition|(
name|answer
operator|==
literal|'Y'
condition|)
block|{
name|retval
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|answer
operator|==
literal|'N'
condition|)
block|{
name|retval
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|printf_filtered
argument_list|(
literal|"Please answer y or n.\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|annotation_level
operator|>
literal|1
condition|)
name|printf_filtered
argument_list|(
literal|"\n\032\032post-query\n"
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Parse a C escape sequence.  STRING_PTR points to a variable    containing a pointer to the string to parse.  That pointer    should point to the character after the \.  That pointer    is updated past the characters we use.  The value of the    escape sequence is returned.     A negative value means the sequence \ newline was seen,    which is supposed to be equivalent to nothing at all.     If \ is followed by a null character, we return a negative    value and leave the string pointer pointing at the null character.     If \ is followed by 000, we return 0 and leave the string pointer    after the zeros.  A value of 0 does not mean end of string.  */
end_comment

begin_function
name|int
name|parse_escape
parameter_list|(
name|string_ptr
parameter_list|)
name|char
modifier|*
modifier|*
name|string_ptr
decl_stmt|;
block|{
specifier|register
name|int
name|c
init|=
operator|*
operator|(
operator|*
name|string_ptr
operator|)
operator|++
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'a'
case|:
return|return
literal|007
return|;
comment|/* Bell (alert) char */
case|case
literal|'b'
case|:
return|return
literal|'\b'
return|;
case|case
literal|'e'
case|:
comment|/* Escape character */
return|return
literal|033
return|;
case|case
literal|'f'
case|:
return|return
literal|'\f'
return|;
case|case
literal|'n'
case|:
return|return
literal|'\n'
return|;
case|case
literal|'r'
case|:
return|return
literal|'\r'
return|;
case|case
literal|'t'
case|:
return|return
literal|'\t'
return|;
case|case
literal|'v'
case|:
return|return
literal|'\v'
return|;
case|case
literal|'\n'
case|:
return|return
operator|-
literal|2
return|;
case|case
literal|0
case|:
operator|(
operator|*
name|string_ptr
operator|)
operator|--
expr_stmt|;
return|return
literal|0
return|;
case|case
literal|'^'
case|:
name|c
operator|=
operator|*
operator|(
operator|*
name|string_ptr
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
name|c
operator|=
name|parse_escape
argument_list|(
name|string_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'?'
condition|)
return|return
literal|0177
return|;
return|return
operator|(
name|c
operator|&
literal|0200
operator|)
operator||
operator|(
name|c
operator|&
literal|037
operator|)
return|;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
block|{
specifier|register
name|int
name|i
init|=
name|c
operator|-
literal|'0'
decl_stmt|;
specifier|register
name|int
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|++
name|count
operator|<
literal|3
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
operator|*
operator|(
operator|*
name|string_ptr
operator|)
operator|++
operator|)
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'7'
condition|)
block|{
name|i
operator|*=
literal|8
expr_stmt|;
name|i
operator|+=
name|c
operator|-
literal|'0'
expr_stmt|;
block|}
else|else
block|{
operator|(
operator|*
name|string_ptr
operator|)
operator|--
expr_stmt|;
break|break;
block|}
block|}
return|return
name|i
return|;
block|}
default|default:
return|return
name|c
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print the character C on STREAM as part of the contents of a literal    string whose delimiter is QUOTER.  Note that this routine should only    be call for printing things which are independent of the language    of the program being debugged. */
end_comment

begin_function
name|void
name|gdb_printchar
parameter_list|(
name|c
parameter_list|,
name|stream
parameter_list|,
name|quoter
parameter_list|)
specifier|register
name|int
name|c
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|quoter
decl_stmt|;
block|{
name|c
operator|&=
literal|0xFF
expr_stmt|;
comment|/* Avoid sign bit follies */
if|if
condition|(
name|c
operator|<
literal|0x20
operator|||
comment|/* Low control chars */
operator|(
name|c
operator|>=
literal|0x7F
operator|&&
name|c
operator|<
literal|0xA0
operator|)
operator|||
comment|/* DEL, High controls */
operator|(
name|sevenbit_strings
operator|&&
name|c
operator|>=
literal|0x80
operator|)
condition|)
block|{
comment|/* high order bit set */
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
name|fputs_filtered
argument_list|(
literal|"\\n"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\b'
case|:
name|fputs_filtered
argument_list|(
literal|"\\b"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
name|fputs_filtered
argument_list|(
literal|"\\t"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\f'
case|:
name|fputs_filtered
argument_list|(
literal|"\\f"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
name|fputs_filtered
argument_list|(
literal|"\\r"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\033'
case|:
name|fputs_filtered
argument_list|(
literal|"\\e"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\007'
case|:
name|fputs_filtered
argument_list|(
literal|"\\a"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\\%.3o"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
operator|||
name|c
operator|==
name|quoter
condition|)
name|fputs_filtered
argument_list|(
literal|"\\"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Number of lines per page or UINT_MAX if paging is disabled.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|lines_per_page
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of chars per line or UNIT_MAX is line folding is disabled.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|chars_per_line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current count of lines printed on this page, chars on this line.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|lines_printed
decl_stmt|,
name|chars_printed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer and start column of buffered text, for doing smarter word-    wrapping.  When someone calls wrap_here(), we start buffering output    that comes through fputs_filtered().  If we see a newline, we just    spit it out and forget about the wrap_here().  If we see another    wrap_here(), we spit it out and remember the newer one.  If we see    the end of the line, we spit out a newline, the indent, and then    the buffered output.  */
end_comment

begin_comment
comment|/* Malloc'd buffer with chars_per_line+2 bytes.  Contains characters which    are waiting to be output (they have already been counted in chars_printed).    When wrap_buffer[0] is null, the buffer is empty.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|wrap_buffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer in wrap_buffer to the next character to fill.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|wrap_pointer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* String to indent by if the wrap occurs.  Must not be NULL if wrap_column    is non-zero.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|wrap_indent
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Column number on the screen where wrap_buffer begins, or 0 if wrapping    is not in effect.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|wrap_column
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|set_width_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|,
name|c
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|wrap_buffer
condition|)
block|{
name|wrap_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|chars_per_line
operator|+
literal|2
argument_list|)
expr_stmt|;
name|wrap_buffer
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
name|wrap_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|wrap_buffer
argument_list|,
name|chars_per_line
operator|+
literal|2
argument_list|)
expr_stmt|;
name|wrap_pointer
operator|=
name|wrap_buffer
expr_stmt|;
comment|/* Start it at the beginning */
block|}
end_function

begin_comment
comment|/* Wait, so the user can read what's on the screen.  Prompt the user    to continue by pressing RETURN.  */
end_comment

begin_function
specifier|static
name|void
name|prompt_for_continue
parameter_list|()
block|{
name|char
modifier|*
name|ignore
decl_stmt|;
name|char
name|cont_prompt
index|[
literal|120
index|]
decl_stmt|;
if|if
condition|(
name|annotation_level
operator|>
literal|1
condition|)
name|printf_unfiltered
argument_list|(
literal|"\n\032\032pre-prompt-for-continue\n"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|cont_prompt
argument_list|,
literal|"---Type<return> to continue, or q<return> to quit---"
argument_list|)
expr_stmt|;
if|if
condition|(
name|annotation_level
operator|>
literal|1
condition|)
name|strcat
argument_list|(
name|cont_prompt
argument_list|,
literal|"\n\032\032prompt-for-continue\n"
argument_list|)
expr_stmt|;
comment|/* We must do this *before* we call gdb_readline, else it will eventually      call us -- thinking that we're trying to print beyond the end of the      screen.  */
name|reinitialize_more_filter
argument_list|()
expr_stmt|;
name|immediate_quit
operator|++
expr_stmt|;
comment|/* On a real operating system, the user can quit with SIGINT.      But not on GO32.       'q' is provided on all systems so users don't have to change habits      from system to system, and because telling them what to do in      the prompt is more user-friendly than expecting them to think of      SIGINT.  */
comment|/* Call readline, not gdb_readline, because GO32 readline handles control-C      whereas control-C to gdb_readline will cause the user to get dumped      out to DOS.  */
name|ignore
operator|=
name|readline
argument_list|(
name|cont_prompt
argument_list|)
expr_stmt|;
if|if
condition|(
name|annotation_level
operator|>
literal|1
condition|)
name|printf_unfiltered
argument_list|(
literal|"\n\032\032post-prompt-for-continue\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ignore
condition|)
block|{
name|char
modifier|*
name|p
init|=
name|ignore
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
operator|++
name|p
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'q'
condition|)
name|request_quit
argument_list|(
name|SIGINT
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ignore
argument_list|)
expr_stmt|;
block|}
name|immediate_quit
operator|--
expr_stmt|;
comment|/* Now we have to do this again, so that GDB will know that it doesn't      need to save the ---Type<return>--- line at the top of the screen.  */
name|reinitialize_more_filter
argument_list|()
expr_stmt|;
name|dont_repeat
argument_list|()
expr_stmt|;
comment|/* Forget prev cmd -- CR won't repeat it. */
block|}
end_function

begin_comment
comment|/* Reinitialize filter; ie. tell it to reset to original values.  */
end_comment

begin_function
name|void
name|reinitialize_more_filter
parameter_list|()
block|{
name|lines_printed
operator|=
literal|0
expr_stmt|;
name|chars_printed
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Indicate that if the next sequence of characters overflows the line,    a newline should be inserted here rather than when it hits the end.    If INDENT is non-null, it is a string to be printed to indent the    wrapped part on the next line.  INDENT must remain accessible until    the next call to wrap_here() or until a newline is printed through    fputs_filtered().     If the line is already overfull, we immediately print a newline and    the indentation, and disable further wrapping.     If we don't know the width of lines, but we know the page height,    we must not wrap words, but should still keep track of newlines    that were explicitly printed.     INDENT should not contain tabs, as that will mess up the char count    on the next line.  FIXME.     This routine is guaranteed to force out any output which has been    squirreled away in the wrap_buffer, so wrap_here ((char *)0) can be    used to force out output from the wrap_buffer.  */
end_comment

begin_function
name|void
name|wrap_here
parameter_list|(
name|indent
parameter_list|)
name|char
modifier|*
name|indent
decl_stmt|;
block|{
comment|/* This should have been allocated, but be paranoid anyway. */
if|if
condition|(
operator|!
name|wrap_buffer
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|wrap_buffer
index|[
literal|0
index|]
condition|)
block|{
operator|*
name|wrap_pointer
operator|=
literal|'\0'
expr_stmt|;
name|fputs_unfiltered
argument_list|(
name|wrap_buffer
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
name|wrap_pointer
operator|=
name|wrap_buffer
expr_stmt|;
name|wrap_buffer
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|chars_per_line
operator|==
name|UINT_MAX
condition|)
comment|/* No line overflow checking */
block|{
name|wrap_column
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|chars_printed
operator|>=
name|chars_per_line
condition|)
block|{
name|puts_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|indent
operator|!=
name|NULL
condition|)
name|puts_filtered
argument_list|(
name|indent
argument_list|)
expr_stmt|;
name|wrap_column
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|wrap_column
operator|=
name|chars_printed
expr_stmt|;
if|if
condition|(
name|indent
operator|==
name|NULL
condition|)
name|wrap_indent
operator|=
literal|""
expr_stmt|;
else|else
name|wrap_indent
operator|=
name|indent
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Ensure that whatever gets printed next, using the filtered output    commands, starts at the beginning of the line.  I.E. if there is    any pending output for the current line, flush it and start a new    line.  Otherwise do nothing. */
end_comment

begin_function
name|void
name|begin_line
parameter_list|()
block|{
if|if
condition|(
name|chars_printed
operator|>
literal|0
condition|)
block|{
name|puts_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|GDB_FILE
modifier|*
name|gdb_fopen
parameter_list|(
name|name
parameter_list|,
name|mode
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|mode
decl_stmt|;
block|{
return|return
name|fopen
argument_list|(
name|name
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|gdb_flush
parameter_list|(
name|stream
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|fflush
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Like fputs but if FILTER is true, pause after every screenful.     Regardless of FILTER can wrap at points other than the final    character of a line.     Unlike fputs, fputs_maybe_filtered does not return a value.    It is OK for LINEBUFFER to be NULL, in which case just don't print    anything.     Note that a longjmp to top level may occur in this routine (only if    FILTER is true) (since prompt_for_continue may do so) so this    routine should not be called when cleanups are not in place.  */
end_comment

begin_function
specifier|static
name|void
name|fputs_maybe_filtered
parameter_list|(
name|linebuffer
parameter_list|,
name|stream
parameter_list|,
name|filter
parameter_list|)
specifier|const
name|char
modifier|*
name|linebuffer
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|filter
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|lineptr
decl_stmt|;
if|if
condition|(
name|linebuffer
operator|==
literal|0
condition|)
return|return;
comment|/* Don't do any filtering if it is disabled.  */
if|if
condition|(
name|stream
operator|!=
name|gdb_stdout
operator|||
operator|(
name|lines_per_page
operator|==
name|UINT_MAX
operator|&&
name|chars_per_line
operator|==
name|UINT_MAX
operator|)
condition|)
block|{
name|fputs_unfiltered
argument_list|(
name|linebuffer
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Go through and output each character.  Show line extension      when this is necessary; prompt user for new page when this is      necessary.  */
name|lineptr
operator|=
name|linebuffer
expr_stmt|;
while|while
condition|(
operator|*
name|lineptr
condition|)
block|{
comment|/* Possible new page.  */
if|if
condition|(
name|filter
operator|&&
operator|(
name|lines_printed
operator|>=
name|lines_per_page
operator|-
literal|1
operator|)
condition|)
name|prompt_for_continue
argument_list|()
expr_stmt|;
while|while
condition|(
operator|*
name|lineptr
operator|&&
operator|*
name|lineptr
operator|!=
literal|'\n'
condition|)
block|{
comment|/* Print a single line.  */
if|if
condition|(
operator|*
name|lineptr
operator|==
literal|'\t'
condition|)
block|{
if|if
condition|(
name|wrap_column
condition|)
operator|*
name|wrap_pointer
operator|++
operator|=
literal|'\t'
expr_stmt|;
else|else
name|fputc_unfiltered
argument_list|(
literal|'\t'
argument_list|,
name|stream
argument_list|)
expr_stmt|;
comment|/* Shifting right by 3 produces the number of tab stops 	         we have already passed, and then adding one and 		 shifting left 3 advances to the next tab stop.  */
name|chars_printed
operator|=
operator|(
operator|(
name|chars_printed
operator|>>
literal|3
operator|)
operator|+
literal|1
operator|)
operator|<<
literal|3
expr_stmt|;
name|lineptr
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|wrap_column
condition|)
operator|*
name|wrap_pointer
operator|++
operator|=
operator|*
name|lineptr
expr_stmt|;
else|else
name|fputc_unfiltered
argument_list|(
operator|*
name|lineptr
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|chars_printed
operator|++
expr_stmt|;
name|lineptr
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|chars_printed
operator|>=
name|chars_per_line
condition|)
block|{
name|unsigned
name|int
name|save_chars
init|=
name|chars_printed
decl_stmt|;
name|chars_printed
operator|=
literal|0
expr_stmt|;
name|lines_printed
operator|++
expr_stmt|;
comment|/* If we aren't actually wrapping, don't output newline -- 		 if chars_per_line is right, we probably just overflowed 		 anyway; if it's wrong, let us keep going.  */
if|if
condition|(
name|wrap_column
condition|)
name|fputc_unfiltered
argument_list|(
literal|'\n'
argument_list|,
name|stream
argument_list|)
expr_stmt|;
comment|/* Possible new page.  */
if|if
condition|(
name|lines_printed
operator|>=
name|lines_per_page
operator|-
literal|1
condition|)
name|prompt_for_continue
argument_list|()
expr_stmt|;
comment|/* Now output indentation and wrapped string */
if|if
condition|(
name|wrap_column
condition|)
block|{
name|fputs_unfiltered
argument_list|(
name|wrap_indent
argument_list|,
name|stream
argument_list|)
expr_stmt|;
operator|*
name|wrap_pointer
operator|=
literal|'\0'
expr_stmt|;
comment|/* Null-terminate saved stuff */
name|fputs_unfiltered
argument_list|(
name|wrap_buffer
argument_list|,
name|stream
argument_list|)
expr_stmt|;
comment|/* and eject it */
comment|/* FIXME, this strlen is what prevents wrap_indent from 		     containing tabs.  However, if we recurse to print it 		     and count its chars, we risk trouble if wrap_indent is 		     longer than (the user settable) chars_per_line. 		     Note also that this can set chars_printed> chars_per_line 		     if we are printing a long string.  */
name|chars_printed
operator|=
name|strlen
argument_list|(
name|wrap_indent
argument_list|)
operator|+
operator|(
name|save_chars
operator|-
name|wrap_column
operator|)
expr_stmt|;
name|wrap_pointer
operator|=
name|wrap_buffer
expr_stmt|;
comment|/* Reset buffer */
name|wrap_buffer
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|wrap_column
operator|=
literal|0
expr_stmt|;
comment|/* And disable fancy wrap */
block|}
block|}
block|}
if|if
condition|(
operator|*
name|lineptr
operator|==
literal|'\n'
condition|)
block|{
name|chars_printed
operator|=
literal|0
expr_stmt|;
name|wrap_here
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* Spit out chars, cancel further wraps */
name|lines_printed
operator|++
expr_stmt|;
name|fputc_unfiltered
argument_list|(
literal|'\n'
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|lineptr
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|fputs_filtered
parameter_list|(
name|linebuffer
parameter_list|,
name|stream
parameter_list|)
specifier|const
name|char
modifier|*
name|linebuffer
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|fputs_maybe_filtered
argument_list|(
name|linebuffer
argument_list|,
name|stream
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|putc_unfiltered
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|2
index|]
decl_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|fputs_unfiltered
argument_list|(
name|buf
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fputc_unfiltered
parameter_list|(
name|c
parameter_list|,
name|stream
parameter_list|)
name|int
name|c
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|2
index|]
decl_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|fputs_unfiltered
argument_list|(
name|buf
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print a variable number of ARGS using format FORMAT.  If this    information is going to put the amount written (since the last call    to REINITIALIZE_MORE_FILTER or the last page break) over the page size,    call prompt_for_continue to get the users permision to continue.     Unlike fprintf, this function does not return a value.     We implement three variants, vfprintf (takes a vararg list and stream),    fprintf (takes a stream to write on), and printf (the usual).     Note also that a longjmp to top level may occur in this routine    (since prompt_for_continue may do so) so this routine should not be    called when cleanups are not in place.  */
end_comment

begin_function
specifier|static
name|void
name|vfprintf_maybe_filtered
parameter_list|(
name|stream
parameter_list|,
name|format
parameter_list|,
name|args
parameter_list|,
name|filter
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|char
modifier|*
name|format
decl_stmt|;
name|va_list
name|args
decl_stmt|;
name|int
name|filter
decl_stmt|;
block|{
name|char
modifier|*
name|linebuffer
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_cleanups
decl_stmt|;
name|vasprintf
argument_list|(
operator|&
name|linebuffer
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|linebuffer
operator|==
name|NULL
condition|)
block|{
name|fputs_unfiltered
argument_list|(
literal|"\ngdb: virtual memory exhausted.\n"
argument_list|,
name|gdb_stderr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|old_cleanups
operator|=
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|linebuffer
argument_list|)
expr_stmt|;
name|fputs_maybe_filtered
argument_list|(
name|linebuffer
argument_list|,
name|stream
argument_list|,
name|filter
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_cleanups
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vfprintf_filtered
parameter_list|(
name|stream
parameter_list|,
name|format
parameter_list|,
name|args
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|char
modifier|*
name|format
decl_stmt|;
name|va_list
name|args
decl_stmt|;
block|{
name|vfprintf_maybe_filtered
argument_list|(
name|stream
argument_list|,
name|format
argument_list|,
name|args
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vfprintf_unfiltered
parameter_list|(
name|stream
parameter_list|,
name|format
parameter_list|,
name|args
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|char
modifier|*
name|format
decl_stmt|;
name|va_list
name|args
decl_stmt|;
block|{
name|char
modifier|*
name|linebuffer
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_cleanups
decl_stmt|;
name|vasprintf
argument_list|(
operator|&
name|linebuffer
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|linebuffer
operator|==
name|NULL
condition|)
block|{
name|fputs_unfiltered
argument_list|(
literal|"\ngdb: virtual memory exhausted.\n"
argument_list|,
name|gdb_stderr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|old_cleanups
operator|=
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|linebuffer
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
name|linebuffer
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_cleanups
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vprintf_filtered
parameter_list|(
name|format
parameter_list|,
name|args
parameter_list|)
name|char
modifier|*
name|format
decl_stmt|;
name|va_list
name|args
decl_stmt|;
block|{
name|vfprintf_maybe_filtered
argument_list|(
name|gdb_stdout
argument_list|,
name|format
argument_list|,
name|args
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vprintf_unfiltered
parameter_list|(
name|format
parameter_list|,
name|args
parameter_list|)
name|char
modifier|*
name|format
decl_stmt|;
name|va_list
name|args
decl_stmt|;
block|{
name|vfprintf_unfiltered
argument_list|(
name|gdb_stdout
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* VARARGS */
end_comment

begin_function
name|void
name|fprintf_filtered
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
block|{
name|va_list
name|args
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
name|char
modifier|*
name|format
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|stream
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|FILE
operator|*
argument_list|)
expr_stmt|;
name|format
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|vfprintf_filtered
argument_list|(
name|stream
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* VARARGS */
end_comment

begin_function
name|void
name|fprintf_unfiltered
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
block|{
name|va_list
name|args
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
name|char
modifier|*
name|format
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|stream
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|FILE
operator|*
argument_list|)
expr_stmt|;
name|format
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|vfprintf_unfiltered
argument_list|(
name|stream
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Like fprintf_filtered, but prints its result indented.    Called as fprintfi_filtered (spaces, stream, format, ...);  */
end_comment

begin_comment
comment|/* VARARGS */
end_comment

begin_function
name|void
name|fprintfi_filtered
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
block|{
name|va_list
name|args
decl_stmt|;
name|int
name|spaces
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
name|char
modifier|*
name|format
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|spaces
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|stream
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|FILE
operator|*
argument_list|)
expr_stmt|;
name|format
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|print_spaces_filtered
argument_list|(
name|spaces
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|vfprintf_filtered
argument_list|(
name|stream
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* VARARGS */
end_comment

begin_function
name|void
name|printf_filtered
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
block|{
name|va_list
name|args
decl_stmt|;
name|char
modifier|*
name|format
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|format
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|vfprintf_filtered
argument_list|(
name|gdb_stdout
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* VARARGS */
end_comment

begin_function
name|void
name|printf_unfiltered
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
block|{
name|va_list
name|args
decl_stmt|;
name|char
modifier|*
name|format
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|format
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|vfprintf_unfiltered
argument_list|(
name|gdb_stdout
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Like printf_filtered, but prints it's result indented.    Called as printfi_filtered (spaces, format, ...);  */
end_comment

begin_comment
comment|/* VARARGS */
end_comment

begin_function
name|void
name|printfi_filtered
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
block|{
name|va_list
name|args
decl_stmt|;
name|int
name|spaces
decl_stmt|;
name|char
modifier|*
name|format
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|spaces
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|format
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|print_spaces_filtered
argument_list|(
name|spaces
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|vfprintf_filtered
argument_list|(
name|gdb_stdout
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Easy -- but watch out!     This routine is *not* a replacement for puts()!  puts() appends a newline.    This one doesn't, and had better not!  */
end_comment

begin_function
name|void
name|puts_filtered
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|fputs_filtered
argument_list|(
name|string
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|puts_unfiltered
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|fputs_unfiltered
argument_list|(
name|string
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a pointer to N spaces and a null.  The pointer is good    until the next call to here.  */
end_comment

begin_function
name|char
modifier|*
name|n_spaces
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|t
decl_stmt|;
specifier|static
name|char
modifier|*
name|spaces
decl_stmt|;
specifier|static
name|int
name|max_spaces
decl_stmt|;
if|if
condition|(
name|n
operator|>
name|max_spaces
condition|)
block|{
if|if
condition|(
name|spaces
condition|)
name|free
argument_list|(
name|spaces
argument_list|)
expr_stmt|;
name|spaces
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|n
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|spaces
operator|+
name|n
init|;
name|t
operator|!=
name|spaces
condition|;
control|)
operator|*
operator|--
name|t
operator|=
literal|' '
expr_stmt|;
name|spaces
index|[
name|n
index|]
operator|=
literal|'\0'
expr_stmt|;
name|max_spaces
operator|=
name|n
expr_stmt|;
block|}
return|return
name|spaces
operator|+
name|max_spaces
operator|-
name|n
return|;
block|}
end_function

begin_comment
comment|/* Print N spaces.  */
end_comment

begin_function
name|void
name|print_spaces_filtered
parameter_list|(
name|n
parameter_list|,
name|stream
parameter_list|)
name|int
name|n
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|fputs_filtered
argument_list|(
name|n_spaces
argument_list|(
name|n
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* C++ demangler stuff.  */
end_comment

begin_comment
comment|/* fprintf_symbol_filtered attempts to demangle NAME, a symbol in language    LANG, using demangling args ARG_MODE, and print it filtered to STREAM.    If the name is not mangled, or the language for the name is unknown, or    demangling is off, the name is printed in its "raw" form. */
end_comment

begin_function
name|void
name|fprintf_symbol_filtered
parameter_list|(
name|stream
parameter_list|,
name|name
parameter_list|,
name|lang
parameter_list|,
name|arg_mode
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|enum
name|language
name|lang
decl_stmt|;
name|int
name|arg_mode
decl_stmt|;
block|{
name|char
modifier|*
name|demangled
decl_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
block|{
comment|/* If user wants to see raw output, no problem.  */
if|if
condition|(
operator|!
name|demangle
condition|)
block|{
name|fputs_filtered
argument_list|(
name|name
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|lang
condition|)
block|{
case|case
name|language_cplus
case|:
name|demangled
operator|=
name|cplus_demangle
argument_list|(
name|name
argument_list|,
name|arg_mode
argument_list|)
expr_stmt|;
break|break;
case|case
name|language_chill
case|:
name|demangled
operator|=
name|chill_demangle
argument_list|(
name|name
argument_list|)
expr_stmt|;
break|break;
default|default:
name|demangled
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
name|fputs_filtered
argument_list|(
name|demangled
condition|?
name|demangled
else|:
name|name
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|demangled
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|demangled
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Do a strcmp() type operation on STRING1 and STRING2, ignoring any    differences in whitespace.  Returns 0 if they match, non-zero if they    don't (slightly different than strcmp()'s range of return values).     As an extra hack, string1=="FOO(ARGS)" matches string2=="FOO".    This "feature" is useful when searching for matching C++ function names    (such as if the user types 'break FOO', where FOO is a mangled C++    function). */
end_comment

begin_function
name|int
name|strcmp_iw
parameter_list|(
name|string1
parameter_list|,
name|string2
parameter_list|)
specifier|const
name|char
modifier|*
name|string1
decl_stmt|;
specifier|const
name|char
modifier|*
name|string2
decl_stmt|;
block|{
while|while
condition|(
operator|(
operator|*
name|string1
operator|!=
literal|'\0'
operator|)
operator|&&
operator|(
operator|*
name|string2
operator|!=
literal|'\0'
operator|)
condition|)
block|{
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|string1
argument_list|)
condition|)
block|{
name|string1
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|string2
argument_list|)
condition|)
block|{
name|string2
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|string1
operator|!=
operator|*
name|string2
condition|)
block|{
break|break;
block|}
if|if
condition|(
operator|*
name|string1
operator|!=
literal|'\0'
condition|)
block|{
name|string1
operator|++
expr_stmt|;
name|string2
operator|++
expr_stmt|;
block|}
block|}
return|return
operator|(
operator|*
name|string1
operator|!=
literal|'\0'
operator|&&
operator|*
name|string1
operator|!=
literal|'('
operator|)
operator|||
operator|(
operator|*
name|string2
operator|!=
literal|'\0'
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|_initialize_utils
parameter_list|()
block|{
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
name|c
operator|=
name|add_set_cmd
argument_list|(
literal|"width"
argument_list|,
name|class_support
argument_list|,
name|var_uinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|chars_per_line
argument_list|,
literal|"Set number of characters gdb thinks are in a line."
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|c
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|c
operator|->
name|function
operator|.
name|sfunc
operator|=
name|set_width_command
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"height"
argument_list|,
name|class_support
argument_list|,
name|var_uinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|lines_per_page
argument_list|,
literal|"Set number of lines gdb thinks are in a page."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
comment|/* These defaults will be used if we are unable to get the correct      values from termcap.  */
if|#
directive|if
name|defined
argument_list|(
name|__GO32__
argument_list|)
name|lines_per_page
operator|=
name|ScreenRows
argument_list|()
expr_stmt|;
name|chars_per_line
operator|=
name|ScreenCols
argument_list|()
expr_stmt|;
else|#
directive|else
name|lines_per_page
operator|=
literal|24
expr_stmt|;
name|chars_per_line
operator|=
literal|80
expr_stmt|;
comment|/* Initialize the screen height and width from termcap.  */
block|{
name|char
modifier|*
name|termtype
init|=
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
decl_stmt|;
comment|/* Positive means success, nonpositive means failure.  */
name|int
name|status
decl_stmt|;
comment|/* 2048 is large enough for all known terminals, according to the        GNU termcap manual.  */
name|char
name|term_buffer
index|[
literal|2048
index|]
decl_stmt|;
if|if
condition|(
name|termtype
condition|)
block|{
name|status
operator|=
name|tgetent
argument_list|(
name|term_buffer
argument_list|,
name|termtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|>
literal|0
condition|)
block|{
name|int
name|val
decl_stmt|;
name|val
operator|=
name|tgetnum
argument_list|(
literal|"li"
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|>=
literal|0
condition|)
name|lines_per_page
operator|=
name|val
expr_stmt|;
else|else
comment|/* The number of lines per page is not mentioned 		 in the terminal description.  This probably means 		 that paging is not useful (e.g. emacs shell window), 		 so disable paging.  */
name|lines_per_page
operator|=
name|UINT_MAX
expr_stmt|;
name|val
operator|=
name|tgetnum
argument_list|(
literal|"co"
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|>=
literal|0
condition|)
name|chars_per_line
operator|=
name|val
expr_stmt|;
block|}
block|}
block|}
if|#
directive|if
name|defined
argument_list|(
name|SIGWINCH
argument_list|)
operator|&&
name|defined
argument_list|(
name|SIGWINCH_HANDLER
argument_list|)
comment|/* If there is a better way to determine the window size, use it. */
name|SIGWINCH_HANDLER
argument_list|()
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* If the output is not a terminal, don't paginate it.  */
if|if
condition|(
operator|!
name|ISATTY
argument_list|(
name|gdb_stdout
argument_list|)
condition|)
name|lines_per_page
operator|=
name|UINT_MAX
expr_stmt|;
name|set_width_command
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"demangle"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|demangle
argument_list|,
literal|"Set demangling of encoded C++ names when displaying symbols."
argument_list|,
operator|&
name|setprintlist
argument_list|)
argument_list|,
operator|&
name|showprintlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"sevenbit-strings"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sevenbit_strings
argument_list|,
literal|"Set printing of 8-bit characters in strings as \\nnn."
argument_list|,
operator|&
name|setprintlist
argument_list|)
argument_list|,
operator|&
name|showprintlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"asm-demangle"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|asm_demangle
argument_list|,
literal|"Set demangling of C++ names in disassembly listings."
argument_list|,
operator|&
name|setprintlist
argument_list|)
argument_list|,
operator|&
name|showprintlist
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Machine specific function to handle SIGWINCH signal. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SIGWINCH_HANDLER_BODY
end_ifdef

begin_macro
name|SIGWINCH_HANDLER_BODY
end_macro

begin_endif
endif|#
directive|endif
end_endif

end_unit

