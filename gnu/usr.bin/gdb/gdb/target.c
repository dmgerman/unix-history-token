begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Select target systems and architectures at runtime for GDB.    Copyright 1990, 1992, 1993 Free Software Foundation, Inc.    Contributed by Cygnus Support.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|target_info
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cleanup_target
name|PARAMS
argument_list|(
operator|(
expr|struct
name|target_ops
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|maybe_kill_then_create_inferior
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|maybe_kill_then_attach
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|kill_or_be_killed
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|default_terminal_info
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nosymbol
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|CORE_ADDR
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tcomplain
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nomemory
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
operator|,
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|return_zero
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ignore
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|target_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|target_ops
modifier|*
name|find_default_run_target
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to array of target architecture structures; the size of the    array; the current index into the array; the allocated size of the     array.  */
end_comment

begin_decl_stmt
name|struct
name|target_ops
modifier|*
modifier|*
name|target_structs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|target_struct_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|target_struct_index
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|target_struct_allocsize
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DEFAULT_ALLOCSIZE
value|10
end_define

begin_comment
comment|/* The initial current target, so that there is always a semi-valid    current target.  */
end_comment

begin_decl_stmt
name|struct
name|target_ops
name|dummy_target
init|=
block|{
literal|"None"
block|,
literal|"None"
block|,
literal|""
block|,
literal|0
block|,
literal|0
block|,
comment|/* open, close */
name|find_default_attach
block|,
literal|0
block|,
comment|/* attach, detach */
literal|0
block|,
literal|0
block|,
comment|/* resume, wait */
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* registers */
literal|0
block|,
literal|0
block|,
comment|/* memory */
literal|0
block|,
literal|0
block|,
comment|/* bkpts */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* terminal */
literal|0
block|,
literal|0
block|,
comment|/* kill, load */
literal|0
block|,
comment|/* lookup_symbol */
name|find_default_create_inferior
block|,
comment|/* create_inferior */
literal|0
block|,
comment|/* mourn_inferior */
literal|0
block|,
comment|/* can_run */
literal|0
block|,
comment|/* notice_signals */
name|dummy_stratum
block|,
literal|0
block|,
comment|/* stratum, next */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* all mem, mem, stack, regs, exec */
literal|0
block|,
literal|0
block|,
comment|/* section pointers */
name|OPS_MAGIC
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The target structure we are currently using to talk to a process    or file or whatever "inferior" we have.  */
end_comment

begin_decl_stmt
name|struct
name|target_ops
modifier|*
name|current_target
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The stack of target structures that have been pushed.  */
end_comment

begin_decl_stmt
name|struct
name|target_ops
modifier|*
modifier|*
name|current_target_stack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Command list for target.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cmd_list_element
modifier|*
name|targetlist
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The user just typed 'target' without the name of a target.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|target_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|fputs_filtered
argument_list|(
literal|"Argument required (target name).  Try `help target'\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a possible target architecture to the list.  */
end_comment

begin_function
name|void
name|add_target
parameter_list|(
name|t
parameter_list|)
name|struct
name|target_ops
modifier|*
name|t
decl_stmt|;
block|{
if|if
condition|(
name|t
operator|->
name|to_magic
operator|!=
name|OPS_MAGIC
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Magic number of %s target struct wrong\n"
argument_list|,
name|t
operator|->
name|to_shortname
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|target_structs
condition|)
block|{
name|target_struct_allocsize
operator|=
name|DEFAULT_ALLOCSIZE
expr_stmt|;
name|target_structs
operator|=
operator|(
expr|struct
name|target_ops
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|target_struct_allocsize
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|target_structs
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|target_struct_size
operator|>=
name|target_struct_allocsize
condition|)
block|{
name|target_struct_allocsize
operator|*=
literal|2
expr_stmt|;
name|target_structs
operator|=
operator|(
expr|struct
name|target_ops
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|target_structs
argument_list|,
name|target_struct_allocsize
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|target_structs
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|target_structs
index|[
name|target_struct_size
operator|++
index|]
operator|=
name|t
expr_stmt|;
name|cleanup_target
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetlist
operator|==
name|NULL
condition|)
name|add_prefix_cmd
argument_list|(
literal|"target"
argument_list|,
name|class_run
argument_list|,
name|target_command
argument_list|,
literal|"Connect to a target machine or process.\n\ The first argument is the type or protocol of the target machine.\n\ Remaining arguments are interpreted by the target protocol.  For more\n\ information on the arguments for a particular protocol, type\n\ `help target ' followed by the protocol name."
argument_list|,
operator|&
name|targetlist
argument_list|,
literal|"target "
argument_list|,
literal|0
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
name|t
operator|->
name|to_shortname
argument_list|,
name|no_class
argument_list|,
name|t
operator|->
name|to_open
argument_list|,
name|t
operator|->
name|to_doc
argument_list|,
operator|&
name|targetlist
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Stub functions */
end_comment

begin_function
specifier|static
name|void
name|ignore
parameter_list|()
block|{ }
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|nomemory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|,
name|write
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|write
decl_stmt|;
block|{
name|errno
operator|=
name|EIO
expr_stmt|;
comment|/* Can't read/write this location */
return|return
literal|0
return|;
comment|/* No bytes handled */
block|}
end_function

begin_function
specifier|static
name|void
name|tcomplain
parameter_list|()
block|{
name|error
argument_list|(
literal|"You can't do that when your target is `%s'"
argument_list|,
name|current_target
operator|->
name|to_shortname
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|noprocess
parameter_list|()
block|{
name|error
argument_list|(
literal|"You can't do that without a process to debug"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|nosymbol
parameter_list|(
name|name
parameter_list|,
name|addrp
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|CORE_ADDR
modifier|*
name|addrp
decl_stmt|;
block|{
return|return
literal|1
return|;
comment|/* Symbol does not exist in target env */
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|default_terminal_info
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"No saved terminal information.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* With strata, this function is no longer needed.  FIXME.  */
end_comment

begin_comment
comment|/* This is the default target_create_inferior function.  It looks up    the stack for some target that cares to create inferiors, then    calls it -- or complains if not found.  */
end_comment

begin_endif
unit|static void upstack_create_inferior (exec, args, env)      char *exec;      char *args;      char **env; {   struct target_ops *t;    for (t = current_target;        t;        t = t->to_next)     {       if (t->to_create_inferior != upstack_create_inferior) 	{           t->to_create_inferior (exec, args, env); 	  return; 	}      }   tcomplain(); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* This is the default target_create_inferior and target_attach function.    If the current target is executing, it asks whether to kill it off.    If this function returns without calling error(), it has killed off    the target, and the operation should be attempted.  */
end_comment

begin_function
specifier|static
name|void
name|kill_or_be_killed
parameter_list|(
name|from_tty
parameter_list|)
name|int
name|from_tty
decl_stmt|;
block|{
if|if
condition|(
name|target_has_execution
condition|)
block|{
name|printf
argument_list|(
literal|"You are already running a program:\n"
argument_list|)
expr_stmt|;
name|target_files_info
argument_list|()
expr_stmt|;
if|if
condition|(
name|query
argument_list|(
literal|"Kill it? "
argument_list|)
condition|)
block|{
name|target_kill
argument_list|()
expr_stmt|;
if|if
condition|(
name|target_has_execution
condition|)
name|error
argument_list|(
literal|"Killing the program did not help."
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|error
argument_list|(
literal|"Program not killed."
argument_list|)
expr_stmt|;
block|}
block|}
name|tcomplain
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|maybe_kill_then_attach
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|kill_or_be_killed
argument_list|(
name|from_tty
argument_list|)
expr_stmt|;
name|target_attach
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|maybe_kill_then_create_inferior
parameter_list|(
name|exec
parameter_list|,
name|args
parameter_list|,
name|env
parameter_list|)
name|char
modifier|*
name|exec
decl_stmt|;
name|char
modifier|*
name|args
decl_stmt|;
name|char
modifier|*
modifier|*
name|env
decl_stmt|;
block|{
name|kill_or_be_killed
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|target_create_inferior
argument_list|(
name|exec
argument_list|,
name|args
argument_list|,
name|env
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clean up a target struct so it no longer has any zero pointers in it.    We default entries, at least to stubs that print error messages.  */
end_comment

begin_function
specifier|static
name|void
name|cleanup_target
parameter_list|(
name|t
parameter_list|)
name|struct
name|target_ops
modifier|*
name|t
decl_stmt|;
block|{
comment|/* Check magic number.  If wrong, it probably means someone changed      the struct definition, but not all the places that initialize one.  */
if|if
condition|(
name|t
operator|->
name|to_magic
operator|!=
name|OPS_MAGIC
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Magic number of %s target struct wrong\n"
argument_list|,
name|t
operator|->
name|to_shortname
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
define|#
directive|define
name|de_fault
parameter_list|(
name|field
parameter_list|,
name|value
parameter_list|)
define|\
value|if (!t->field)	t->field = value
comment|/*        FIELD			DEFAULT VALUE        */
name|de_fault
argument_list|(
name|to_open
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|tcomplain
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_close
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|ignore
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_attach
argument_list|,
name|maybe_kill_then_attach
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_detach
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|ignore
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_resume
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|noprocess
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_wait
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|noprocess
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_fetch_registers
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|ignore
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_store_registers
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|noprocess
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_prepare_to_store
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|noprocess
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_xfer_memory
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|nomemory
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_files_info
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|ignore
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_insert_breakpoint
argument_list|,
name|memory_insert_breakpoint
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_remove_breakpoint
argument_list|,
name|memory_remove_breakpoint
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_terminal_init
argument_list|,
name|ignore
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_terminal_inferior
argument_list|,
name|ignore
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_terminal_ours_for_output
argument_list|,
name|ignore
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_terminal_ours
argument_list|,
name|ignore
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_terminal_info
argument_list|,
name|default_terminal_info
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_kill
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|noprocess
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_load
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|tcomplain
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_lookup_symbol
argument_list|,
name|nosymbol
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_create_inferior
argument_list|,
name|maybe_kill_then_create_inferior
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_mourn_inferior
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|noprocess
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_can_run
argument_list|,
name|return_zero
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_notice_signals
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|ignore
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_next
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_has_all_memory
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_has_memory
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_has_stack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_has_registers
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_has_execution
argument_list|,
literal|0
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|de_fault
block|}
end_function

begin_comment
comment|/* Push a new target type into the stack of the existing target accessors,    possibly superseding some of the existing accessors.     Result is zero if the pushed target ended up on top of the stack,    nonzero if at least one target is on top of it.     Rather than allow an empty stack, we always have the dummy target at    the bottom stratum, so we can call the function vectors without    checking them.  */
end_comment

begin_function
name|int
name|push_target
parameter_list|(
name|t
parameter_list|)
name|struct
name|target_ops
modifier|*
name|t
decl_stmt|;
block|{
name|struct
name|target_ops
modifier|*
name|st
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
for|for
control|(
name|prev
operator|=
literal|0
operator|,
name|st
operator|=
name|current_target
init|;
name|st
condition|;
name|prev
operator|=
name|st
operator|,
name|st
operator|=
name|st
operator|->
name|to_next
control|)
block|{
if|if
condition|(
call|(
name|int
call|)
argument_list|(
name|t
operator|->
name|to_stratum
argument_list|)
operator|>=
call|(
name|int
call|)
argument_list|(
name|st
operator|->
name|to_stratum
argument_list|)
condition|)
break|break;
block|}
while|while
condition|(
name|t
operator|->
name|to_stratum
operator|==
name|st
operator|->
name|to_stratum
condition|)
block|{
comment|/* There's already something on this stratum.  Close it off.  */
call|(
name|st
operator|->
name|to_close
call|)
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|to_next
operator|=
name|st
operator|->
name|to_next
expr_stmt|;
comment|/* Unchain old target_ops */
else|else
name|current_target
operator|=
name|st
operator|->
name|to_next
expr_stmt|;
comment|/* Unchain first on list */
name|st
operator|=
name|st
operator|->
name|to_next
expr_stmt|;
block|}
comment|/* We have removed all targets in our stratum, now add ourself.  */
name|t
operator|->
name|to_next
operator|=
name|st
expr_stmt|;
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|to_next
operator|=
name|t
expr_stmt|;
else|else
name|current_target
operator|=
name|t
expr_stmt|;
name|cleanup_target
argument_list|(
name|current_target
argument_list|)
expr_stmt|;
return|return
name|prev
operator|!=
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Remove a target_ops vector from the stack, wherever it may be.     Return how many times it was removed (0 or 1 unless bug).  */
end_comment

begin_function
name|int
name|unpush_target
parameter_list|(
name|t
parameter_list|)
name|struct
name|target_ops
modifier|*
name|t
decl_stmt|;
block|{
name|struct
name|target_ops
modifier|*
name|u
decl_stmt|,
modifier|*
name|v
decl_stmt|;
name|int
name|result
init|=
literal|0
decl_stmt|;
for|for
control|(
name|u
operator|=
name|current_target
operator|,
name|v
operator|=
literal|0
init|;
name|u
condition|;
name|v
operator|=
name|u
operator|,
name|u
operator|=
name|u
operator|->
name|to_next
control|)
if|if
condition|(
name|u
operator|==
name|t
condition|)
block|{
if|if
condition|(
name|v
operator|==
literal|0
condition|)
name|pop_target
argument_list|()
expr_stmt|;
comment|/* unchain top copy */
else|else
block|{
call|(
name|t
operator|->
name|to_close
call|)
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Let it clean up */
name|v
operator|->
name|to_next
operator|=
name|t
operator|->
name|to_next
expr_stmt|;
comment|/* unchain middle copy */
block|}
name|result
operator|++
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
name|void
name|pop_target
parameter_list|()
block|{
call|(
name|current_target
operator|->
name|to_close
call|)
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Let it clean up */
name|current_target
operator|=
name|current_target
operator|->
name|to_next
expr_stmt|;
if|#
directive|if
literal|0
comment|/* This will dump core if ever called--push_target expects current_target      to be non-NULL.  But I don't think it's needed; I don't see how the      dummy_target could ever be removed from the stack.  */
block|if (!current_target)
comment|/* At bottom, push dummy.  */
block|push_target (&dummy_target);
endif|#
directive|endif
block|}
end_function

begin_undef
undef|#
directive|undef
name|MIN
end_undef

begin_define
define|#
directive|define
name|MIN
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|)
value|(((A)<= (B)) ? (A) : (B))
end_define

begin_comment
comment|/* target_read_string -- read a null terminated string from MEMADDR in target.    The read may also be terminated early by getting an error from target_xfer_    memory.    LEN is the size of the buffer pointed to by MYADDR.  Note that a terminating    null will only be written if there is sufficient room.  The return value is    is the number of bytes (including the null) actually transferred. */
end_comment

begin_function
name|int
name|target_read_string
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|int
name|tlen
decl_stmt|,
name|origlen
decl_stmt|,
name|offset
decl_stmt|,
name|i
decl_stmt|;
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|origlen
operator|=
name|len
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|tlen
operator|=
name|MIN
argument_list|(
name|len
argument_list|,
literal|4
operator|-
operator|(
name|memaddr
operator|&
literal|3
operator|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|memaddr
operator|&
literal|3
expr_stmt|;
if|if
condition|(
name|target_xfer_memory
argument_list|(
name|memaddr
operator|&
operator|~
literal|3
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|origlen
operator|-
name|len
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tlen
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|myaddr
operator|++
operator|=
name|buf
index|[
name|i
operator|+
name|offset
index|]
expr_stmt|;
if|if
condition|(
name|buf
index|[
name|i
operator|+
name|offset
index|]
operator|==
literal|'\000'
condition|)
return|return
operator|(
name|origlen
operator|-
name|len
operator|)
operator|+
name|i
operator|+
literal|1
return|;
block|}
name|memaddr
operator|+=
name|tlen
expr_stmt|;
name|len
operator|-=
name|tlen
expr_stmt|;
block|}
return|return
name|origlen
return|;
block|}
end_function

begin_comment
comment|/* Read LEN bytes of target memory at address MEMADDR, placing the results in    GDB's memory at MYADDR.  Returns either 0 for success or an errno value    if any error occurs.     If an error occurs, no guarantee is made about the contents of the data at    MYADDR.  In particular, the caller should not depend upon partial reads    filling the buffer with good data.  There is no way for the caller to know    how much good data might have been transfered anyway.  Callers that can    deal with partial reads should call target_read_memory_partial. */
end_comment

begin_function
name|int
name|target_read_memory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
return|return
name|target_xfer_memory
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Read LEN bytes of target memory at address MEMADDR, placing the results    in GDB's memory at MYADDR.  Returns a count of the bytes actually read,    and optionally an errno value in the location pointed to by ERRNOPTR    if ERRNOPTR is non-null. */
end_comment

begin_function
name|int
name|target_read_memory_partial
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|,
name|errnoptr
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
modifier|*
name|errnoptr
decl_stmt|;
block|{
name|int
name|nread
decl_stmt|;
comment|/* Number of bytes actually read. */
name|int
name|errcode
decl_stmt|;
comment|/* Error from last read. */
comment|/* First try a complete read. */
name|errcode
operator|=
name|target_xfer_memory
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|errcode
operator|==
literal|0
condition|)
block|{
comment|/* Got it all. */
name|nread
operator|=
name|len
expr_stmt|;
block|}
else|else
block|{
comment|/* Loop, reading one byte at a time until we get as much as we can. */
for|for
control|(
name|errcode
operator|=
literal|0
operator|,
name|nread
operator|=
literal|0
init|;
name|len
operator|>
literal|0
operator|&&
name|errcode
operator|==
literal|0
condition|;
name|nread
operator|++
operator|,
name|len
operator|--
control|)
block|{
name|errcode
operator|=
name|target_xfer_memory
argument_list|(
name|memaddr
operator|++
argument_list|,
name|myaddr
operator|++
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* If an error, the last read was unsuccessful, so adjust count. */
if|if
condition|(
name|errcode
operator|!=
literal|0
condition|)
block|{
name|nread
operator|--
expr_stmt|;
block|}
block|}
if|if
condition|(
name|errnoptr
operator|!=
name|NULL
condition|)
block|{
operator|*
name|errnoptr
operator|=
name|errcode
expr_stmt|;
block|}
return|return
operator|(
name|nread
operator|)
return|;
block|}
end_function

begin_function
name|int
name|target_write_memory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
return|return
name|target_xfer_memory
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Move memory to or from the targets.  Iterate until all of it has    been moved, if necessary.  The top target gets priority; anything    it doesn't want, is offered to the next one down, etc.  Note the    business with curlen:  if an early target says "no, but I have a    boundary overlapping this xfer" then we shorten what we offer to    the subsequent targets so the early guy will get a chance at the    tail before the subsequent ones do.      Result is 0 or errno value.  */
end_comment

begin_function
name|int
name|target_xfer_memory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|,
name|write
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|write
decl_stmt|;
block|{
name|int
name|curlen
decl_stmt|;
name|int
name|res
decl_stmt|;
name|struct
name|target_ops
modifier|*
name|t
decl_stmt|;
comment|/* to_xfer_memory is not guaranteed to set errno, even when it returns      0.  */
name|errno
operator|=
literal|0
expr_stmt|;
comment|/* The quick case is that the top target does it all.  */
name|res
operator|=
name|current_target
operator|->
name|to_xfer_memory
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|,
name|write
argument_list|,
name|current_target
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|len
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|res
operator|>
literal|0
condition|)
goto|goto
name|bump
goto|;
comment|/* If res<= 0 then we call it again in the loop.  Ah well.  */
for|for
control|(
init|;
name|len
operator|>
literal|0
condition|;
control|)
block|{
name|curlen
operator|=
name|len
expr_stmt|;
comment|/* Want to do it all */
for|for
control|(
name|t
operator|=
name|current_target
init|;
name|t
condition|;
name|t
operator|=
name|t
operator|->
name|to_has_all_memory
condition|?
literal|0
else|:
name|t
operator|->
name|to_next
control|)
block|{
name|res
operator|=
name|t
operator|->
name|to_xfer_memory
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|curlen
argument_list|,
name|write
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|>
literal|0
condition|)
break|break;
comment|/* Handled all or part of xfer */
if|if
condition|(
name|res
operator|==
literal|0
condition|)
continue|continue;
comment|/* Handled none */
name|curlen
operator|=
operator|-
name|res
expr_stmt|;
comment|/* Could handle once we get past res bytes */
block|}
if|if
condition|(
name|res
operator|<=
literal|0
condition|)
block|{
comment|/* If this address is for nonexistent memory, 	     read zeros if reading, or do nothing if writing.  Return error. */
if|if
condition|(
operator|!
name|write
condition|)
name|memset
argument_list|(
name|myaddr
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|==
literal|0
condition|)
return|return
name|EIO
return|;
else|else
return|return
name|errno
return|;
block|}
name|bump
label|:
name|memaddr
operator|+=
name|res
expr_stmt|;
name|myaddr
operator|+=
name|res
expr_stmt|;
name|len
operator|-=
name|res
expr_stmt|;
block|}
return|return
literal|0
return|;
comment|/* We managed to cover it all somehow. */
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|target_info
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|struct
name|target_ops
modifier|*
name|t
decl_stmt|;
name|int
name|has_all_mem
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|symfile_objfile
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"Symbols from \"%s\".\n"
argument_list|,
name|symfile_objfile
operator|->
name|name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FILES_INFO_HOOK
if|if
condition|(
name|FILES_INFO_HOOK
argument_list|()
condition|)
return|return;
endif|#
directive|endif
for|for
control|(
name|t
operator|=
name|current_target
init|;
name|t
condition|;
name|t
operator|=
name|t
operator|->
name|to_next
control|)
block|{
if|if
condition|(
call|(
name|int
call|)
argument_list|(
name|t
operator|->
name|to_stratum
argument_list|)
operator|<=
operator|(
name|int
operator|)
name|dummy_stratum
condition|)
continue|continue;
if|if
condition|(
name|has_all_mem
condition|)
name|printf
argument_list|(
literal|"\tWhile running this, gdb does not access memory from...\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s:\n"
argument_list|,
name|t
operator|->
name|to_longname
argument_list|)
expr_stmt|;
call|(
name|t
operator|->
name|to_files_info
call|)
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|has_all_mem
operator|=
name|t
operator|->
name|to_has_all_memory
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This is to be called by the open routine before it does    anything.  */
end_comment

begin_function
name|void
name|target_preopen
parameter_list|(
name|from_tty
parameter_list|)
name|int
name|from_tty
decl_stmt|;
block|{
name|dont_repeat
argument_list|()
expr_stmt|;
if|if
condition|(
name|target_has_execution
condition|)
block|{
if|if
condition|(
name|query
argument_list|(
literal|"A program is being debugged already.  Kill it? "
argument_list|)
condition|)
name|target_kill
argument_list|()
expr_stmt|;
else|else
name|error
argument_list|(
literal|"Program not killed."
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Detach a target after doing deferred register stores.  */
end_comment

begin_function
name|void
name|target_detach
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
comment|/* Handle any optimized stores to the inferior.  */
ifdef|#
directive|ifdef
name|DO_DEFERRED_STORES
name|DO_DEFERRED_STORES
expr_stmt|;
endif|#
directive|endif
call|(
name|current_target
operator|->
name|to_detach
call|)
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Look through the list of possible targets for a target that can    execute a run or attach command without any other data.  This is    used to locate the default process stratum.     Result is always valid (error() is called for errors).  */
end_comment

begin_function
specifier|static
name|struct
name|target_ops
modifier|*
name|find_default_run_target
parameter_list|(
name|do_mesg
parameter_list|)
name|char
modifier|*
name|do_mesg
decl_stmt|;
block|{
name|struct
name|target_ops
modifier|*
modifier|*
name|t
decl_stmt|;
name|struct
name|target_ops
modifier|*
name|runable
init|=
name|NULL
decl_stmt|;
name|int
name|count
decl_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|t
operator|=
name|target_structs
init|;
name|t
operator|<
name|target_structs
operator|+
name|target_struct_size
condition|;
operator|++
name|t
control|)
block|{
if|if
condition|(
name|target_can_run
argument_list|(
operator|*
name|t
argument_list|)
condition|)
block|{
name|runable
operator|=
operator|*
name|t
expr_stmt|;
operator|++
name|count
expr_stmt|;
block|}
block|}
if|if
condition|(
name|count
operator|!=
literal|1
condition|)
name|error
argument_list|(
literal|"Don't know how to %s.  Try \"help target\"."
argument_list|,
name|do_mesg
argument_list|)
expr_stmt|;
return|return
name|runable
return|;
block|}
end_function

begin_function
name|void
name|find_default_attach
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|struct
name|target_ops
modifier|*
name|t
decl_stmt|;
name|t
operator|=
name|find_default_run_target
argument_list|(
literal|"attach"
argument_list|)
expr_stmt|;
call|(
name|t
operator|->
name|to_attach
call|)
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|find_default_create_inferior
parameter_list|(
name|exec_file
parameter_list|,
name|allargs
parameter_list|,
name|env
parameter_list|)
name|char
modifier|*
name|exec_file
decl_stmt|;
name|char
modifier|*
name|allargs
decl_stmt|;
name|char
modifier|*
modifier|*
name|env
decl_stmt|;
block|{
name|struct
name|target_ops
modifier|*
name|t
decl_stmt|;
name|t
operator|=
name|find_default_run_target
argument_list|(
literal|"run"
argument_list|)
expr_stmt|;
call|(
name|t
operator|->
name|to_create_inferior
call|)
argument_list|(
name|exec_file
argument_list|,
name|allargs
argument_list|,
name|env
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|return_zero
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|struct
name|target_ops
modifier|*
name|find_core_target
parameter_list|()
block|{
name|struct
name|target_ops
modifier|*
modifier|*
name|t
decl_stmt|;
name|struct
name|target_ops
modifier|*
name|runable
init|=
name|NULL
decl_stmt|;
name|int
name|count
decl_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|t
operator|=
name|target_structs
init|;
name|t
operator|<
name|target_structs
operator|+
name|target_struct_size
condition|;
operator|++
name|t
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|t
operator|)
operator|->
name|to_stratum
operator|==
name|core_stratum
condition|)
block|{
name|runable
operator|=
operator|*
name|t
expr_stmt|;
operator|++
name|count
expr_stmt|;
block|}
block|}
return|return
operator|(
name|count
operator|==
literal|1
condition|?
name|runable
else|:
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Convert a normal process ID to a string.  Returns the string in a static    buffer.  */
end_comment

begin_function
name|char
modifier|*
name|normal_pid_to_str
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
literal|30
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"process %d"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
name|targ_desc
index|[]
init|=
literal|"Names of targets and files being debugged.\n\ Shows the entire stack of targets currently in use (including the exec-file,\n\ core-file, and process, if any), as well as the symbol file name."
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|_initialize_targets
parameter_list|()
block|{
name|current_target
operator|=
operator|&
name|dummy_target
expr_stmt|;
name|cleanup_target
argument_list|(
name|current_target
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"target"
argument_list|,
name|target_info
argument_list|,
name|targ_desc
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"files"
argument_list|,
name|target_info
argument_list|,
name|targ_desc
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

