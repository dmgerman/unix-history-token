begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Multiple source language support for GDB.    Copyright 1991, 1992 Free Software Foundation, Inc.    Contributed by the Department of Computer Science at the State University    of New York at Buffalo.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* This file contains functions that return things that are specific    to languages.  Each function should examine current_language if necessary,    and return the appropriate result. */
end_comment

begin_comment
comment|/* FIXME:  Most of these would be better organized as macros which    return data out of a "language-specific" struct pointer that is set    whenever the working language changes.  That would be a lot faster.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"parser-defs.h"
end_include

begin_decl_stmt
specifier|static
name|void
name|show_language_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_language_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|show_type_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_type_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|show_range_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_range_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_range_str
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_type_str
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_lang_str
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|unk_lang_error
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|unk_lang_parser
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|show_check
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_check
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_type_range
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward declaration */
end_comment

begin_decl_stmt
specifier|extern
specifier|const
name|struct
name|language_defn
name|unknown_language_defn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|warning_pre_print
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The current (default at startup) state of type and range checking.     (If the modes are set to "auto", though, these are changed based     on the default language at startup, and then again based on the     language of the first source file.  */
end_comment

begin_decl_stmt
name|enum
name|range_mode
name|range_mode
init|=
name|range_mode_auto
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|range_check
name|range_check
init|=
name|range_check_off
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|type_mode
name|type_mode
init|=
name|type_mode_auto
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|type_check
name|type_check
init|=
name|type_check_off
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The current language and language_mode (see language.h) */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|language_defn
modifier|*
name|current_language
init|=
operator|&
name|unknown_language_defn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|language_mode
name|language_mode
init|=
name|language_mode_auto
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The language that the user expects to be typing in (the language    of main(), or the last language we notified them about, or C).  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|language_defn
modifier|*
name|expected_language
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The list of supported languages.  The list itself is malloc'd.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|language_defn
modifier|*
modifier|*
name|languages
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|languages_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|languages_allocsize
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DEFAULT_ALLOCSIZE
value|4
end_define

begin_comment
comment|/* The "set language/type/range" commands all put stuff in these    buffers.  This is to make them work as set/show commands.  The    user's string is copied here, then the set_* commands look at    them and update them to something that looks nice when it is    printed out. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|language
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|range
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Warning issued when current_language and the language of the current    frame do not match. */
end_comment

begin_decl_stmt
name|char
name|lang_frame_mismatch_warn
index|[]
init|=
literal|"Warning: the current language does not match this frame."
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* This page contains the functions corresponding to GDB commands    and their helpers. */
end_comment

begin_comment
comment|/* Show command.  Display a warning if the language set    does not match the frame. */
end_comment

begin_function
specifier|static
name|void
name|show_language_command
parameter_list|(
name|ignore
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|ignore
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|enum
name|language
name|flang
decl_stmt|;
comment|/* The language of the current frame */
name|flang
operator|=
name|get_frame_language
argument_list|()
expr_stmt|;
if|if
condition|(
name|flang
operator|!=
name|language_unknown
operator|&&
name|language_mode
operator|==
name|language_mode_manual
operator|&&
name|current_language
operator|->
name|la_language
operator|!=
name|flang
condition|)
name|printf_filtered
argument_list|(
literal|"%s\n"
argument_list|,
name|lang_frame_mismatch_warn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set command.  Change the current working language. */
end_comment

begin_function
specifier|static
name|void
name|set_language_command
parameter_list|(
name|ignore
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|ignore
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|enum
name|language
name|flang
decl_stmt|;
name|char
modifier|*
name|err_lang
decl_stmt|;
comment|/* FIXME -- do this from the list, with HELP.  */
if|if
condition|(
operator|!
name|language
operator|||
operator|!
name|language
index|[
literal|0
index|]
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"The currently understood settings are:\n\n"
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"local or auto    Automatic setting based on source file\n"
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"c                Use the C language\n"
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"c++              Use the C++ language\n"
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"chill            Use the Chill language\n"
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"modula-2         Use the Modula-2 language\n"
argument_list|)
expr_stmt|;
comment|/* Restore the silly string. */
name|set_language
argument_list|(
name|current_language
operator|->
name|la_language
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Search the list of languages for a match.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|languages_size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|STREQ
argument_list|(
name|languages
index|[
name|i
index|]
operator|->
name|la_name
argument_list|,
name|language
argument_list|)
condition|)
block|{
comment|/* Found it!  Go into manual mode, and use this language.  */
if|if
condition|(
name|languages
index|[
name|i
index|]
operator|->
name|la_language
operator|==
name|language_auto
condition|)
block|{
comment|/* Enter auto mode.  Set to the current frame's language, if known.  */
name|language_mode
operator|=
name|language_mode_auto
expr_stmt|;
name|flang
operator|=
name|get_frame_language
argument_list|()
expr_stmt|;
if|if
condition|(
name|flang
operator|!=
name|language_unknown
condition|)
name|set_language
argument_list|(
name|flang
argument_list|)
expr_stmt|;
name|expected_language
operator|=
name|current_language
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|/* Enter manual mode.  Set the specified language.  */
name|language_mode
operator|=
name|language_mode_manual
expr_stmt|;
name|current_language
operator|=
name|languages
index|[
name|i
index|]
expr_stmt|;
name|set_type_range
argument_list|()
expr_stmt|;
name|set_lang_str
argument_list|()
expr_stmt|;
name|expected_language
operator|=
name|current_language
expr_stmt|;
return|return;
block|}
block|}
block|}
comment|/* Reset the language (esp. the global string "language") to the      correct values. */
name|err_lang
operator|=
name|savestring
argument_list|(
name|language
argument_list|,
name|strlen
argument_list|(
name|language
argument_list|)
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|err_lang
argument_list|)
expr_stmt|;
comment|/* Free it after error */
name|set_language
argument_list|(
name|current_language
operator|->
name|la_language
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Unknown language `%s'."
argument_list|,
name|err_lang
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Show command.  Display a warning if the type setting does    not match the current language. */
end_comment

begin_function
specifier|static
name|void
name|show_type_command
parameter_list|(
name|ignore
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|ignore
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
if|if
condition|(
name|type_check
operator|!=
name|current_language
operator|->
name|la_type_check
condition|)
name|printf_unfiltered
argument_list|(
literal|"Warning: the current type check setting does not match the language.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set command.  Change the setting for type checking. */
end_comment

begin_function
specifier|static
name|void
name|set_type_command
parameter_list|(
name|ignore
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|ignore
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
if|if
condition|(
name|STREQ
argument_list|(
name|type
argument_list|,
literal|"on"
argument_list|)
condition|)
block|{
name|type_check
operator|=
name|type_check_on
expr_stmt|;
name|type_mode
operator|=
name|type_mode_manual
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|type
argument_list|,
literal|"warn"
argument_list|)
condition|)
block|{
name|type_check
operator|=
name|type_check_warn
expr_stmt|;
name|type_mode
operator|=
name|type_mode_manual
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|type
argument_list|,
literal|"off"
argument_list|)
condition|)
block|{
name|type_check
operator|=
name|type_check_off
expr_stmt|;
name|type_mode
operator|=
name|type_mode_manual
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|type
argument_list|,
literal|"auto"
argument_list|)
condition|)
block|{
name|type_mode
operator|=
name|type_mode_auto
expr_stmt|;
name|set_type_range
argument_list|()
expr_stmt|;
comment|/* Avoid hitting the set_type_str call below.  We          did it in set_type_range. */
return|return;
block|}
name|set_type_str
argument_list|()
expr_stmt|;
name|show_type_command
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Show command.  Display a warning if the range setting does    not match the current language. */
end_comment

begin_function
specifier|static
name|void
name|show_range_command
parameter_list|(
name|ignore
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|ignore
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
if|if
condition|(
name|range_check
operator|!=
name|current_language
operator|->
name|la_range_check
condition|)
name|printf_unfiltered
argument_list|(
literal|"Warning: the current range check setting does not match the language.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set command.  Change the setting for range checking. */
end_comment

begin_function
specifier|static
name|void
name|set_range_command
parameter_list|(
name|ignore
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|ignore
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
if|if
condition|(
name|STREQ
argument_list|(
name|range
argument_list|,
literal|"on"
argument_list|)
condition|)
block|{
name|range_check
operator|=
name|range_check_on
expr_stmt|;
name|range_mode
operator|=
name|range_mode_manual
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|range
argument_list|,
literal|"warn"
argument_list|)
condition|)
block|{
name|range_check
operator|=
name|range_check_warn
expr_stmt|;
name|range_mode
operator|=
name|range_mode_manual
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|range
argument_list|,
literal|"off"
argument_list|)
condition|)
block|{
name|range_check
operator|=
name|range_check_off
expr_stmt|;
name|range_mode
operator|=
name|range_mode_manual
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|range
argument_list|,
literal|"auto"
argument_list|)
condition|)
block|{
name|range_mode
operator|=
name|range_mode_auto
expr_stmt|;
name|set_type_range
argument_list|()
expr_stmt|;
comment|/* Avoid hitting the set_range_str call below.  We 	 did it in set_type_range. */
return|return;
block|}
name|set_range_str
argument_list|()
expr_stmt|;
name|show_range_command
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the status of range and type checking based on    the current modes and the current language.    If SHOW is non-zero, then print out the current language,    type and range checking status. */
end_comment

begin_function
specifier|static
name|void
name|set_type_range
parameter_list|()
block|{
if|if
condition|(
name|range_mode
operator|==
name|range_mode_auto
condition|)
name|range_check
operator|=
name|current_language
operator|->
name|la_range_check
expr_stmt|;
if|if
condition|(
name|type_mode
operator|==
name|type_mode_auto
condition|)
name|type_check
operator|=
name|current_language
operator|->
name|la_type_check
expr_stmt|;
name|set_type_str
argument_list|()
expr_stmt|;
name|set_range_str
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set current language to (enum language) LANG.  */
end_comment

begin_function
name|void
name|set_language
parameter_list|(
name|lang
parameter_list|)
name|enum
name|language
name|lang
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|languages_size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|languages
index|[
name|i
index|]
operator|->
name|la_language
operator|==
name|lang
condition|)
block|{
name|current_language
operator|=
name|languages
index|[
name|i
index|]
expr_stmt|;
name|set_type_range
argument_list|()
expr_stmt|;
name|set_lang_str
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This page contains functions that update the global vars    language, type and range. */
end_comment

begin_function
specifier|static
name|void
name|set_lang_str
parameter_list|()
block|{
name|char
modifier|*
name|prefix
init|=
literal|""
decl_stmt|;
name|free
argument_list|(
name|language
argument_list|)
expr_stmt|;
if|if
condition|(
name|language_mode
operator|==
name|language_mode_auto
condition|)
name|prefix
operator|=
literal|"auto; currently "
expr_stmt|;
name|language
operator|=
name|concat
argument_list|(
name|prefix
argument_list|,
name|current_language
operator|->
name|la_name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_type_str
parameter_list|()
block|{
name|char
modifier|*
name|tmp
decl_stmt|,
modifier|*
name|prefix
init|=
literal|""
decl_stmt|;
name|free
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type_mode
operator|==
name|type_mode_auto
condition|)
name|prefix
operator|=
literal|"auto; currently "
expr_stmt|;
switch|switch
condition|(
name|type_check
condition|)
block|{
case|case
name|type_check_on
case|:
name|tmp
operator|=
literal|"on"
expr_stmt|;
break|break;
case|case
name|type_check_off
case|:
name|tmp
operator|=
literal|"off"
expr_stmt|;
break|break;
case|case
name|type_check_warn
case|:
name|tmp
operator|=
literal|"warn"
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Unrecognized type check setting."
argument_list|)
expr_stmt|;
block|}
name|type
operator|=
name|concat
argument_list|(
name|prefix
argument_list|,
name|tmp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_range_str
parameter_list|()
block|{
name|char
modifier|*
name|tmp
decl_stmt|,
modifier|*
name|pref
init|=
literal|""
decl_stmt|;
name|free
argument_list|(
name|range
argument_list|)
expr_stmt|;
if|if
condition|(
name|range_mode
operator|==
name|range_mode_auto
condition|)
name|pref
operator|=
literal|"auto; currently "
expr_stmt|;
switch|switch
condition|(
name|range_check
condition|)
block|{
case|case
name|range_check_on
case|:
name|tmp
operator|=
literal|"on"
expr_stmt|;
break|break;
case|case
name|range_check_off
case|:
name|tmp
operator|=
literal|"off"
expr_stmt|;
break|break;
case|case
name|range_check_warn
case|:
name|tmp
operator|=
literal|"warn"
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Unrecognized range check setting."
argument_list|)
expr_stmt|;
block|}
name|range
operator|=
name|concat
argument_list|(
name|pref
argument_list|,
name|tmp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print out the current language settings: language, range and    type checking.  If QUIETLY, print only what has changed.  */
end_comment

begin_function
name|void
name|language_info
parameter_list|(
name|quietly
parameter_list|)
name|int
name|quietly
decl_stmt|;
block|{
if|if
condition|(
name|quietly
operator|&&
name|expected_language
operator|==
name|current_language
condition|)
return|return;
name|expected_language
operator|=
name|current_language
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"Current language:  %s\n"
argument_list|,
name|language
argument_list|)
expr_stmt|;
name|show_language_command
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quietly
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"Type checking:     %s\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|show_type_command
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"Range checking:    %s\n"
argument_list|,
name|range
argument_list|)
expr_stmt|;
name|show_range_command
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the result of a binary operation. */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Currently unused */
end_comment

begin_comment
unit|struct type * binop_result_type (v1, v2)    value_ptr v1, v2; {    int l1,l2,size,uns;     l1 = TYPE_LENGTH(VALUE_TYPE(v1));    l2 = TYPE_LENGTH(VALUE_TYPE(v2));     switch(current_language->la_language)    {    case language_c:    case language_cplus:       if (TYPE_CODE(VALUE_TYPE(v1))==TYPE_CODE_FLT) 	 return TYPE_CODE(VALUE_TYPE(v2)) == TYPE_CODE_FLT&& l2> l1 ? 	    VALUE_TYPE(v2) : VALUE_TYPE(v1);       else if (TYPE_CODE(VALUE_TYPE(v2))==TYPE_CODE_FLT) 	 return TYPE_CODE(VALUE_TYPE(v1)) == TYPE_CODE_FLT&& l1> l2 ? 	    VALUE_TYPE(v1) : VALUE_TYPE(v2);       else if (TYPE_UNSIGNED(VALUE_TYPE(v1))&& l1> l2) 	 return VALUE_TYPE(v1);       else if (TYPE_UNSIGNED(VALUE_TYPE(v2))&& l2> l1) 	 return VALUE_TYPE(v2);       else
comment|/* Both are signed.  Result is the longer type */
end_comment

begin_comment
unit|return l1> l2 ? VALUE_TYPE(v1) : VALUE_TYPE(v2);       break;    case language_m2:
comment|/* If we are doing type-checking, l1 should equal l2, so this is 	 not needed. */
end_comment

begin_comment
unit|return l1> l2 ? VALUE_TYPE(v1) : VALUE_TYPE(v2);       break;    case language_chill:       error ("Missing Chill support in function binop_result_check.");
comment|/*FIXME*/
end_comment

begin_comment
unit|}    abort();    return (struct type *)0;
comment|/* For lint */
end_comment

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_escape
end_escape

begin_comment
comment|/* This page contains functions that return format strings for    printf for printing out numbers in different formats */
end_comment

begin_comment
comment|/* Returns the appropriate printf format for hexadecimal    numbers. */
end_comment

begin_function
name|char
modifier|*
name|local_hex_format_custom
parameter_list|(
name|pre
parameter_list|)
name|char
modifier|*
name|pre
decl_stmt|;
block|{
specifier|static
name|char
name|form
index|[
literal|50
index|]
decl_stmt|;
name|strcpy
argument_list|(
name|form
argument_list|,
name|local_hex_format_prefix
argument_list|()
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|form
argument_list|,
literal|"%"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|form
argument_list|,
name|pre
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|form
argument_list|,
name|local_hex_format_specifier
argument_list|()
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|form
argument_list|,
name|local_hex_format_suffix
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|form
return|;
block|}
end_function

begin_comment
comment|/* Converts a number to hexadecimal and stores it in a static    string.  Returns a pointer to this string. */
end_comment

begin_function
name|char
modifier|*
name|local_hex_string
parameter_list|(
name|num
parameter_list|)
name|unsigned
name|long
name|num
decl_stmt|;
block|{
specifier|static
name|char
name|res
index|[
literal|50
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|res
argument_list|,
name|local_hex_format
argument_list|()
argument_list|,
name|num
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* Converts a number to custom hexadecimal and stores it in a static    string.  Returns a pointer to this string. */
end_comment

begin_function
name|char
modifier|*
name|local_hex_string_custom
parameter_list|(
name|num
parameter_list|,
name|pre
parameter_list|)
name|unsigned
name|long
name|num
decl_stmt|;
name|char
modifier|*
name|pre
decl_stmt|;
block|{
specifier|static
name|char
name|res
index|[
literal|50
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|res
argument_list|,
name|local_hex_format_custom
argument_list|(
name|pre
argument_list|)
argument_list|,
name|num
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* Returns the appropriate printf format for octal    numbers. */
end_comment

begin_function
name|char
modifier|*
name|local_octal_format_custom
parameter_list|(
name|pre
parameter_list|)
name|char
modifier|*
name|pre
decl_stmt|;
block|{
specifier|static
name|char
name|form
index|[
literal|50
index|]
decl_stmt|;
name|strcpy
argument_list|(
name|form
argument_list|,
name|local_octal_format_prefix
argument_list|()
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|form
argument_list|,
literal|"%"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|form
argument_list|,
name|pre
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|form
argument_list|,
name|local_octal_format_specifier
argument_list|()
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|form
argument_list|,
name|local_octal_format_suffix
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|form
return|;
block|}
end_function

begin_comment
comment|/* Returns the appropriate printf format for decimal numbers. */
end_comment

begin_function
name|char
modifier|*
name|local_decimal_format_custom
parameter_list|(
name|pre
parameter_list|)
name|char
modifier|*
name|pre
decl_stmt|;
block|{
specifier|static
name|char
name|form
index|[
literal|50
index|]
decl_stmt|;
name|strcpy
argument_list|(
name|form
argument_list|,
name|local_decimal_format_prefix
argument_list|()
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|form
argument_list|,
literal|"%"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|form
argument_list|,
name|pre
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|form
argument_list|,
name|local_decimal_format_specifier
argument_list|()
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|form
argument_list|,
name|local_decimal_format_suffix
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|form
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This page contains functions that are used in type/range checking.    They all return zero if the type/range check fails.     It is hoped that these will make extending GDB to parse different    languages a little easier.  These are primarily used in eval.c when    evaluating expressions and making sure that their types are correct.    Instead of having a mess of conjucted/disjuncted expressions in an "if",    the ideas of type can be wrapped up in the following functions.     Note that some of them are not currently dependent upon which language    is currently being parsed.  For example, floats are the same in    C and Modula-2 (ie. the only floating point type has TYPE_CODE of    TYPE_CODE_FLT), while booleans are different. */
end_comment

begin_comment
comment|/* Returns non-zero if its argument is a simple type.  This is the same for    both Modula-2 and for C.  In the C case, TYPE_CODE_CHAR will never occur,    and thus will never cause the failure of the test. */
end_comment

begin_function
name|int
name|simple_type
parameter_list|(
name|type
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
block|{
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_INT
case|:
case|case
name|TYPE_CODE_CHAR
case|:
case|case
name|TYPE_CODE_ENUM
case|:
case|case
name|TYPE_CODE_FLT
case|:
case|case
name|TYPE_CODE_RANGE
case|:
case|case
name|TYPE_CODE_BOOL
case|:
return|return
literal|1
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Returns non-zero if its argument is of an ordered type.    An ordered type is one in which the elements can be tested for the    properties of "greater than", "less than", etc, or for which the    operations "increment" or "decrement" make sense. */
end_comment

begin_function
name|int
name|ordered_type
parameter_list|(
name|type
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
block|{
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_INT
case|:
case|case
name|TYPE_CODE_CHAR
case|:
case|case
name|TYPE_CODE_ENUM
case|:
case|case
name|TYPE_CODE_FLT
case|:
case|case
name|TYPE_CODE_RANGE
case|:
return|return
literal|1
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Returns non-zero if the two types are the same */
end_comment

begin_function
name|int
name|same_type
parameter_list|(
name|arg1
parameter_list|,
name|arg2
parameter_list|)
name|struct
name|type
modifier|*
name|arg1
decl_stmt|,
decl|*
name|arg2
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
name|structured_type
argument_list|(
name|arg1
argument_list|)
condition|?
operator|!
name|structured_type
argument_list|(
name|arg2
argument_list|)
else|:
name|structured_type
argument_list|(
name|arg2
argument_list|)
condition|)
comment|/* One is structured and one isn't */
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|structured_type
argument_list|(
name|arg1
argument_list|)
operator|&&
name|structured_type
argument_list|(
name|arg2
argument_list|)
condition|)
return|return
name|arg1
operator|==
name|arg2
return|;
elseif|else
if|if
condition|(
name|numeric_type
argument_list|(
name|arg1
argument_list|)
operator|&&
name|numeric_type
argument_list|(
name|arg2
argument_list|)
condition|)
return|return
operator|(
name|TYPE_CODE
argument_list|(
name|arg2
argument_list|)
operator|==
name|TYPE_CODE
argument_list|(
name|arg1
argument_list|)
operator|)
operator|&&
operator|(
name|TYPE_UNSIGNED
argument_list|(
name|arg1
argument_list|)
operator|==
name|TYPE_UNSIGNED
argument_list|(
name|arg2
argument_list|)
operator|)
condition|?
literal|1
else|:
literal|0
return|;
else|else
return|return
name|arg1
operator|==
name|arg2
return|;
block|}
end_block

begin_comment
comment|/* Returns non-zero if the type is integral */
end_comment

begin_function
name|int
name|integral_type
parameter_list|(
name|type
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
block|{
switch|switch
condition|(
name|current_language
operator|->
name|la_language
condition|)
block|{
case|case
name|language_c
case|:
case|case
name|language_cplus
case|:
return|return
operator|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_CODE_INT
operator|)
operator|&&
operator|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_CODE_ENUM
operator|)
condition|?
literal|0
else|:
literal|1
return|;
case|case
name|language_m2
case|:
return|return
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_CODE_INT
condition|?
literal|0
else|:
literal|1
return|;
case|case
name|language_chill
case|:
name|error
argument_list|(
literal|"Missing Chill support in function integral_type."
argument_list|)
expr_stmt|;
comment|/*FIXME*/
default|default:
name|error
argument_list|(
literal|"Language not supported."
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Returns non-zero if the value is numeric */
end_comment

begin_function
name|int
name|numeric_type
parameter_list|(
name|type
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
block|{
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_INT
case|:
case|case
name|TYPE_CODE_FLT
case|:
return|return
literal|1
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Returns non-zero if the value is a character type */
end_comment

begin_function
name|int
name|character_type
parameter_list|(
name|type
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
block|{
switch|switch
condition|(
name|current_language
operator|->
name|la_language
condition|)
block|{
case|case
name|language_chill
case|:
case|case
name|language_m2
case|:
return|return
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_CODE_CHAR
condition|?
literal|0
else|:
literal|1
return|;
case|case
name|language_c
case|:
case|case
name|language_cplus
case|:
return|return
operator|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_INT
operator|)
operator|&&
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|char
argument_list|)
condition|?
literal|1
else|:
literal|0
return|;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Returns non-zero if the value is a string type */
end_comment

begin_function
name|int
name|string_type
parameter_list|(
name|type
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
block|{
switch|switch
condition|(
name|current_language
operator|->
name|la_language
condition|)
block|{
case|case
name|language_chill
case|:
case|case
name|language_m2
case|:
return|return
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_CODE_STRING
condition|?
literal|0
else|:
literal|1
return|;
case|case
name|language_c
case|:
case|case
name|language_cplus
case|:
comment|/* C does not have distinct string type. */
return|return
operator|(
literal|0
operator|)
return|;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Returns non-zero if the value is a boolean type */
end_comment

begin_function
name|int
name|boolean_type
parameter_list|(
name|type
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
block|{
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_BOOL
condition|)
return|return
literal|1
return|;
switch|switch
condition|(
name|current_language
operator|->
name|la_language
condition|)
block|{
case|case
name|language_c
case|:
case|case
name|language_cplus
case|:
comment|/* Might be more cleanly handled by having a TYPE_CODE_INT_NOT_BOOL 	 for CHILL and such languages, or a TYPE_CODE_INT_OR_BOOL for C.  */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_INT
condition|)
return|return
literal|1
return|;
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns non-zero if the value is a floating-point type */
end_comment

begin_function
name|int
name|float_type
parameter_list|(
name|type
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
block|{
return|return
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_FLT
return|;
block|}
end_function

begin_comment
comment|/* Returns non-zero if the value is a pointer type */
end_comment

begin_function
name|int
name|pointer_type
parameter_list|(
name|type
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
block|{
return|return
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_PTR
operator|||
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_REF
return|;
block|}
end_function

begin_comment
comment|/* Returns non-zero if the value is a structured type */
end_comment

begin_function
name|int
name|structured_type
parameter_list|(
name|type
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
block|{
switch|switch
condition|(
name|current_language
operator|->
name|la_language
condition|)
block|{
case|case
name|language_c
case|:
case|case
name|language_cplus
case|:
return|return
operator|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
operator|)
operator|||
operator|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_UNION
operator|)
operator|||
operator|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_ARRAY
operator|)
return|;
case|case
name|language_m2
case|:
return|return
operator|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
operator|)
operator|||
operator|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_SET
operator|)
operator|||
operator|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_ARRAY
operator|)
return|;
case|case
name|language_chill
case|:
name|error
argument_list|(
literal|"Missing Chill support in function structured_type."
argument_list|)
expr_stmt|;
comment|/*FIXME*/
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This page contains functions that return info about    (struct value) values used in GDB. */
end_comment

begin_comment
comment|/* Returns non-zero if the value VAL represents a true value. */
end_comment

begin_function
name|int
name|value_true
parameter_list|(
name|val
parameter_list|)
name|value_ptr
name|val
decl_stmt|;
block|{
comment|/* It is possible that we should have some sort of error if a non-boolean      value is used in this context.  Possibly dependent on some kind of      "boolean-checking" option like range checking.  But it should probably      not depend on the language except insofar as is necessary to identify      a "boolean" value (i.e. in C using a float, pointer, etc., as a boolean      should be an error, probably).  */
return|return
operator|!
name|value_logical_not
argument_list|(
name|val
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Returns non-zero if the operator OP is defined on    the values ARG1 and ARG2. */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Currently unused */
end_comment

begin_comment
unit|void binop_type_check(arg1,arg2,op)    value_ptr arg1,arg2;    int op; {    struct type *t1, *t2;
comment|/* If we're not checking types, always return success. */
end_comment

begin_comment
unit|if (!STRICT_TYPE)       return;     t1=VALUE_TYPE(arg1);    if (arg2 != NULL)       t2=VALUE_TYPE(arg2);    else       t2=NULL;     switch(op)    {    case BINOP_ADD:    case BINOP_SUB:       if ((numeric_type(t1)&& pointer_type(t2)) || 	 (pointer_type(t1)&& numeric_type(t2)))       { 	 warning ("combining pointer and integer.\n"); 	 break;       }    case BINOP_MUL:    case BINOP_LSH:    case BINOP_RSH:       if (!numeric_type(t1) || !numeric_type(t2)) 	 type_op_error ("Arguments to %s must be numbers.",op);       else if (!same_type(t1,t2)) 	 type_op_error ("Arguments to %s must be of the same type.",op);       break;     case BINOP_LOGICAL_AND:    case BINOP_LOGICAL_OR:       if (!boolean_type(t1) || !boolean_type(t2)) 	 type_op_error ("Arguments to %s must be of boolean type.",op);       break;     case BINOP_EQUAL:       if ((pointer_type(t1)&& !(pointer_type(t2) || integral_type(t2))) || 	 (pointer_type(t2)&& !(pointer_type(t1) || integral_type(t1)))) 	 type_op_error ("A pointer can only be compared to an integer or pointer.",op);       else if ((pointer_type(t1)&& integral_type(t2)) || 	 (integral_type(t1)&& pointer_type(t2)))       { 	 warning ("combining integer and pointer.\n"); 	 break;       }       else if (!simple_type(t1) || !simple_type(t2)) 	 type_op_error ("Arguments to %s must be of simple type.",op);       else if (!same_type(t1,t2)) 	 type_op_error ("Arguments to %s must be of the same type.",op);       break;     case BINOP_REM:    case BINOP_MOD:       if (!integral_type(t1) || !integral_type(t2)) 	 type_op_error ("Arguments to %s must be of integral type.",op);       break;     case BINOP_LESS:    case BINOP_GTR:    case BINOP_LEQ:    case BINOP_GEQ:       if (!ordered_type(t1) || !ordered_type(t2)) 	 type_op_error ("Arguments to %s must be of ordered type.",op);       else if (!same_type(t1,t2)) 	 type_op_error ("Arguments to %s must be of the same type.",op);       break;     case BINOP_ASSIGN:       if (pointer_type(t1)&& !integral_type(t2)) 	 type_op_error ("A pointer can only be assigned an integer.",op);       else if (pointer_type(t1)&& integral_type(t2))       { 	 warning ("combining integer and pointer."); 	 break;       }       else if (!simple_type(t1) || !simple_type(t2)) 	 type_op_error ("Arguments to %s must be of simple type.",op);       else if (!same_type(t1,t2)) 	 type_op_error ("Arguments to %s must be of the same type.",op);       break;      case BINOP_CONCAT:
comment|/* FIXME:  Needs to handle bitstrings as well. */
end_comment

begin_comment
unit|if (!(string_type(t1) || character_type(t1) || integral_type(t1)) 	  || !(string_type(t2) || character_type(t2) || integral_type(t2))) 	  type_op_error ("Arguments to %s must be strings or characters.", op);       break;
comment|/* Unary checks -- arg2 is null */
end_comment

begin_comment
unit|case UNOP_LOGICAL_NOT:       if (!boolean_type(t1)) 	 type_op_error ("Argument to %s must be of boolean type.",op);       break;     case UNOP_PLUS:    case UNOP_NEG:       if (!numeric_type(t1)) 	 type_op_error ("Argument to %s must be of numeric type.",op);       break;     case UNOP_IND:       if (integral_type(t1))       { 	 warning ("combining pointer and integer.\n"); 	 break;       }       else if (!pointer_type(t1)) 	 type_op_error ("Argument to %s must be a pointer.",op);       break;     case UNOP_PREINCREMENT:    case UNOP_POSTINCREMENT:    case UNOP_PREDECREMENT:    case UNOP_POSTDECREMENT:       if (!ordered_type(t1)) 	 type_op_error ("Argument to %s must be of an ordered type.",op);       break;     default:
comment|/* Ok.  The following operators have different meanings in 	 different languages. */
end_comment

begin_ifdef
unit|switch(current_language->la_language)       {
ifdef|#
directive|ifdef
name|_LANG_c
end_ifdef

begin_endif
unit|case language_c:       case language_cplus: 	 switch(op) 	 { 	 case BINOP_DIV: 	    if (!numeric_type(t1) || !numeric_type(t2)) 	       type_op_error ("Arguments to %s must be numbers.",op); 	    break; 	 } 	 break;
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|_LANG_m2
end_ifdef

begin_endif
unit|case language_m2: 	 switch(op) 	 { 	 case BINOP_DIV: 	    if (!float_type(t1) || !float_type(t2)) 	       type_op_error ("Arguments to %s must be floating point numbers.",op); 	    break; 	 case BINOP_INTDIV: 	    if (!integral_type(t1) || !integral_type(t2)) 	       type_op_error ("Arguments to %s must be of integral type.",op); 	    break; 	 }
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|_LANG_chill
end_ifdef

begin_comment
unit|case language_chill: 	 error ("Missing Chill support in function binop_type_check.");
comment|/*FIXME*/
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_endif
unit|}    } }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_escape
end_escape

begin_comment
comment|/* This page contains functions for the printing out of    error messages that occur during type- and range-    checking. */
end_comment

begin_comment
comment|/* Prints the format string FMT with the operator as a string    corresponding to the opcode OP.  If FATAL is non-zero, then    this is an error and error () is called.  Otherwise, it is    a warning and printf() is called. */
end_comment

begin_function
name|void
name|op_error
parameter_list|(
name|fmt
parameter_list|,
name|op
parameter_list|,
name|fatal
parameter_list|)
name|char
modifier|*
name|fmt
decl_stmt|;
name|enum
name|exp_opcode
name|op
decl_stmt|;
name|int
name|fatal
decl_stmt|;
block|{
if|if
condition|(
name|fatal
condition|)
name|error
argument_list|(
name|fmt
argument_list|,
name|op_string
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|warning
argument_list|(
name|fmt
argument_list|,
name|op_string
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* These are called when a language fails a type- or range-check.    The first argument should be a printf()-style format string, and    the rest of the arguments should be its arguments.  If    [type|range]_check is [type|range]_check_on, then return_to_top_level()    is called in the style of error ().  Otherwise, the message is prefixed    by the value of warning_pre_print and we do not return to the top level. */
end_comment

begin_function
name|void
name|type_error
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
block|{
name|va_list
name|args
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
if|if
condition|(
name|type_check
operator|==
name|type_check_warn
condition|)
name|fprintf_filtered
argument_list|(
name|gdb_stderr
argument_list|,
name|warning_pre_print
argument_list|)
expr_stmt|;
else|else
name|error_begin
argument_list|()
expr_stmt|;
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|string
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|vfprintf_filtered
argument_list|(
name|gdb_stderr
argument_list|,
name|string
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|type_check
operator|==
name|type_check_on
condition|)
name|return_to_top_level
argument_list|(
name|RETURN_ERROR
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|range_error
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
block|{
name|va_list
name|args
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
if|if
condition|(
name|range_check
operator|==
name|range_check_warn
condition|)
name|fprintf_filtered
argument_list|(
name|gdb_stderr
argument_list|,
name|warning_pre_print
argument_list|)
expr_stmt|;
else|else
name|error_begin
argument_list|()
expr_stmt|;
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|string
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|vfprintf_filtered
argument_list|(
name|gdb_stderr
argument_list|,
name|string
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|range_check
operator|==
name|range_check_on
condition|)
name|return_to_top_level
argument_list|(
name|RETURN_ERROR
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This page contains miscellaneous functions */
end_comment

begin_comment
comment|/* Return the language struct for a given language enum. */
end_comment

begin_function
specifier|const
name|struct
name|language_defn
modifier|*
name|language_def
parameter_list|(
name|lang
parameter_list|)
name|enum
name|language
name|lang
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|languages_size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|languages
index|[
name|i
index|]
operator|->
name|la_language
operator|==
name|lang
condition|)
block|{
return|return
name|languages
index|[
name|i
index|]
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return the language as a string */
end_comment

begin_function
name|char
modifier|*
name|language_str
parameter_list|(
name|lang
parameter_list|)
name|enum
name|language
name|lang
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|languages_size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|languages
index|[
name|i
index|]
operator|->
name|la_language
operator|==
name|lang
condition|)
block|{
return|return
name|languages
index|[
name|i
index|]
operator|->
name|la_name
return|;
block|}
block|}
return|return
literal|"Unknown"
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_check
parameter_list|(
name|ignore
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|ignore
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|printf_unfiltered
argument_list|(
literal|"\"set check\" must be followed by the name of a check subcommand.\n"
argument_list|)
expr_stmt|;
name|help_list
argument_list|(
name|setchecklist
argument_list|,
literal|"set check "
argument_list|,
operator|-
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|show_check
parameter_list|(
name|ignore
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|ignore
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|cmd_show_list
argument_list|(
name|showchecklist
argument_list|,
name|from_tty
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add a language to the set of known languages.  */
end_comment

begin_function
name|void
name|add_language
parameter_list|(
name|lang
parameter_list|)
specifier|const
name|struct
name|language_defn
modifier|*
name|lang
decl_stmt|;
block|{
if|if
condition|(
name|lang
operator|->
name|la_magic
operator|!=
name|LANG_MAGIC
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Magic number of %s language struct wrong\n"
argument_list|,
name|lang
operator|->
name|la_name
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|languages
condition|)
block|{
name|languages_allocsize
operator|=
name|DEFAULT_ALLOCSIZE
expr_stmt|;
name|languages
operator|=
operator|(
specifier|const
expr|struct
name|language_defn
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|languages_allocsize
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|languages
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|languages_size
operator|>=
name|languages_allocsize
condition|)
block|{
name|languages_allocsize
operator|*=
literal|2
expr_stmt|;
name|languages
operator|=
operator|(
specifier|const
expr|struct
name|language_defn
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|languages
argument_list|,
name|languages_allocsize
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|languages
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|languages
index|[
name|languages_size
operator|++
index|]
operator|=
name|lang
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Define the language that is no language.  */
end_comment

begin_function
specifier|static
name|int
name|unk_lang_parser
parameter_list|()
block|{
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|unk_lang_error
parameter_list|(
name|msg
parameter_list|)
name|char
modifier|*
name|msg
decl_stmt|;
block|{
name|error
argument_list|(
literal|"Attempted to parse an expression with unknown language"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|unk_lang_printchar
parameter_list|(
name|c
parameter_list|,
name|stream
parameter_list|)
specifier|register
name|int
name|c
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|error
argument_list|(
literal|"internal error - unimplemented function unk_lang_printchar called."
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|unk_lang_printstr
parameter_list|(
name|stream
parameter_list|,
name|string
parameter_list|,
name|length
parameter_list|,
name|force_ellipses
parameter_list|)
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|unsigned
name|int
name|length
decl_stmt|;
name|int
name|force_ellipses
decl_stmt|;
block|{
name|error
argument_list|(
literal|"internal error - unimplemented function unk_lang_printstr called."
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|type
modifier|*
name|unk_lang_create_fundamental_type
parameter_list|(
name|objfile
parameter_list|,
name|typeid
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|int
name|typeid
decl_stmt|;
block|{
name|error
argument_list|(
literal|"internal error - unimplemented function unk_lang_create_fundamental_type called."
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|unk_lang_print_type
parameter_list|(
name|type
parameter_list|,
name|varstring
parameter_list|,
name|stream
parameter_list|,
name|show
parameter_list|,
name|level
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|char
modifier|*
name|varstring
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|show
decl_stmt|;
name|int
name|level
decl_stmt|;
block|{
name|error
argument_list|(
literal|"internal error - unimplemented function unk_lang_print_type called."
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|unk_lang_val_print
parameter_list|(
name|type
parameter_list|,
name|valaddr
parameter_list|,
name|address
parameter_list|,
name|stream
parameter_list|,
name|format
parameter_list|,
name|deref_ref
parameter_list|,
name|recurse
parameter_list|,
name|pretty
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|char
modifier|*
name|valaddr
decl_stmt|;
name|CORE_ADDR
name|address
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|format
decl_stmt|;
name|int
name|deref_ref
decl_stmt|;
name|int
name|recurse
decl_stmt|;
name|enum
name|val_prettyprint
name|pretty
decl_stmt|;
block|{
name|error
argument_list|(
literal|"internal error - unimplemented function unk_lang_val_print called."
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|unk_lang_value_print
parameter_list|(
name|val
parameter_list|,
name|stream
parameter_list|,
name|format
parameter_list|,
name|pretty
parameter_list|)
name|value_ptr
name|val
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|format
decl_stmt|;
name|enum
name|val_prettyprint
name|pretty
decl_stmt|;
block|{
name|error
argument_list|(
literal|"internal error - unimplemented function unk_lang_value_print called."
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
modifier|*
function_decl|const (
name|unknown_builtin_types
function_decl|[]
end_function_decl

begin_expr_stmt
unit|)
operator|=
block|{
literal|0
block|}
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|op_print
name|unk_op_print_tab
index|[]
init|=
block|{
block|{
name|NULL
block|,
name|OP_NULL
block|,
name|PREC_NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|language_defn
name|unknown_language_defn
init|=
block|{
literal|"unknown"
block|,
name|language_unknown
block|,
operator|&
name|unknown_builtin_types
index|[
literal|0
index|]
block|,
name|range_check_off
block|,
name|type_check_off
block|,
name|unk_lang_parser
block|,
name|unk_lang_error
block|,
name|unk_lang_printchar
block|,
comment|/* Print character constant */
name|unk_lang_printstr
block|,
name|unk_lang_create_fundamental_type
block|,
name|unk_lang_print_type
block|,
comment|/* Print a type using appropriate syntax */
name|unk_lang_val_print
block|,
comment|/* Print a value using appropriate syntax */
name|unk_lang_value_print
block|,
comment|/* Print a top-level value */
operator|&
name|builtin_type_error
block|,
comment|/* longest floating point type */
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
comment|/* Binary format info */
block|{
literal|"0%lo"
block|,
literal|"0"
block|,
literal|"o"
block|,
literal|""
block|}
block|,
comment|/* Octal format info */
block|{
literal|"%ld"
block|,
literal|""
block|,
literal|"d"
block|,
literal|""
block|}
block|,
comment|/* Decimal format info */
block|{
literal|"0x%lx"
block|,
literal|"0x"
block|,
literal|"x"
block|,
literal|""
block|}
block|,
comment|/* Hex format info */
name|unk_op_print_tab
block|,
comment|/* expression operators for printing */
name|LANG_MAGIC
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These two structs define fake entries for the "local" and "auto" options. */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|language_defn
name|auto_language_defn
init|=
block|{
literal|"auto"
block|,
name|language_auto
block|,
operator|&
name|unknown_builtin_types
index|[
literal|0
index|]
block|,
name|range_check_off
block|,
name|type_check_off
block|,
name|unk_lang_parser
block|,
name|unk_lang_error
block|,
name|unk_lang_printchar
block|,
comment|/* Print character constant */
name|unk_lang_printstr
block|,
name|unk_lang_create_fundamental_type
block|,
name|unk_lang_print_type
block|,
comment|/* Print a type using appropriate syntax */
name|unk_lang_val_print
block|,
comment|/* Print a value using appropriate syntax */
name|unk_lang_value_print
block|,
comment|/* Print a top-level value */
operator|&
name|builtin_type_error
block|,
comment|/* longest floating point type */
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
comment|/* Binary format info */
block|{
literal|"0%lo"
block|,
literal|"0"
block|,
literal|"o"
block|,
literal|""
block|}
block|,
comment|/* Octal format info */
block|{
literal|"%ld"
block|,
literal|""
block|,
literal|"d"
block|,
literal|""
block|}
block|,
comment|/* Decimal format info */
block|{
literal|"0x%lx"
block|,
literal|"0x"
block|,
literal|"x"
block|,
literal|""
block|}
block|,
comment|/* Hex format info */
name|unk_op_print_tab
block|,
comment|/* expression operators for printing */
name|LANG_MAGIC
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|language_defn
name|local_language_defn
init|=
block|{
literal|"local"
block|,
name|language_auto
block|,
operator|&
name|unknown_builtin_types
index|[
literal|0
index|]
block|,
name|range_check_off
block|,
name|type_check_off
block|,
name|unk_lang_parser
block|,
name|unk_lang_error
block|,
name|unk_lang_printchar
block|,
comment|/* Print character constant */
name|unk_lang_printstr
block|,
name|unk_lang_create_fundamental_type
block|,
name|unk_lang_print_type
block|,
comment|/* Print a type using appropriate syntax */
name|unk_lang_val_print
block|,
comment|/* Print a value using appropriate syntax */
name|unk_lang_value_print
block|,
comment|/* Print a top-level value */
operator|&
name|builtin_type_error
block|,
comment|/* longest floating point type */
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
comment|/* Binary format info */
block|{
literal|"0%lo"
block|,
literal|"0"
block|,
literal|"o"
block|,
literal|""
block|}
block|,
comment|/* Octal format info */
block|{
literal|"%ld"
block|,
literal|""
block|,
literal|"d"
block|,
literal|""
block|}
block|,
comment|/* Decimal format info */
block|{
literal|"0x%lx"
block|,
literal|"0x"
block|,
literal|"x"
block|,
literal|""
block|}
block|,
comment|/* Hex format info */
name|unk_op_print_tab
block|,
comment|/* expression operators for printing */
name|LANG_MAGIC
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Initialize the language routines */
end_comment

begin_function
name|void
name|_initialize_language
parameter_list|()
block|{
name|struct
name|cmd_list_element
modifier|*
name|set
decl_stmt|,
modifier|*
name|show
decl_stmt|;
comment|/* GDB commands for language specific stuff */
name|set
operator|=
name|add_set_cmd
argument_list|(
literal|"language"
argument_list|,
name|class_support
argument_list|,
name|var_string_noescape
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|language
argument_list|,
literal|"Set the current source language."
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|show
operator|=
name|add_show_from_set
argument_list|(
name|set
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|set
operator|->
name|function
operator|.
name|cfunc
operator|=
name|set_language_command
expr_stmt|;
name|show
operator|->
name|function
operator|.
name|cfunc
operator|=
name|show_language_command
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"check"
argument_list|,
name|no_class
argument_list|,
name|set_check
argument_list|,
literal|"Set the status of the type/range checker"
argument_list|,
operator|&
name|setchecklist
argument_list|,
literal|"set check "
argument_list|,
literal|0
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_alias_cmd
argument_list|(
literal|"c"
argument_list|,
literal|"check"
argument_list|,
name|no_class
argument_list|,
literal|1
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_alias_cmd
argument_list|(
literal|"ch"
argument_list|,
literal|"check"
argument_list|,
name|no_class
argument_list|,
literal|1
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"check"
argument_list|,
name|no_class
argument_list|,
name|show_check
argument_list|,
literal|"Show the status of the type/range checker"
argument_list|,
operator|&
name|showchecklist
argument_list|,
literal|"show check "
argument_list|,
literal|0
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_alias_cmd
argument_list|(
literal|"c"
argument_list|,
literal|"check"
argument_list|,
name|no_class
argument_list|,
literal|1
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_alias_cmd
argument_list|(
literal|"ch"
argument_list|,
literal|"check"
argument_list|,
name|no_class
argument_list|,
literal|1
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|set
operator|=
name|add_set_cmd
argument_list|(
literal|"type"
argument_list|,
name|class_support
argument_list|,
name|var_string_noescape
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|type
argument_list|,
literal|"Set type checking.  (on/warn/off/auto)"
argument_list|,
operator|&
name|setchecklist
argument_list|)
expr_stmt|;
name|show
operator|=
name|add_show_from_set
argument_list|(
name|set
argument_list|,
operator|&
name|showchecklist
argument_list|)
expr_stmt|;
name|set
operator|->
name|function
operator|.
name|cfunc
operator|=
name|set_type_command
expr_stmt|;
name|show
operator|->
name|function
operator|.
name|cfunc
operator|=
name|show_type_command
expr_stmt|;
name|set
operator|=
name|add_set_cmd
argument_list|(
literal|"range"
argument_list|,
name|class_support
argument_list|,
name|var_string_noescape
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|range
argument_list|,
literal|"Set range checking.  (on/warn/off/auto)"
argument_list|,
operator|&
name|setchecklist
argument_list|)
expr_stmt|;
name|show
operator|=
name|add_show_from_set
argument_list|(
name|set
argument_list|,
operator|&
name|showchecklist
argument_list|)
expr_stmt|;
name|set
operator|->
name|function
operator|.
name|cfunc
operator|=
name|set_range_command
expr_stmt|;
name|show
operator|->
name|function
operator|.
name|cfunc
operator|=
name|show_range_command
expr_stmt|;
name|add_language
argument_list|(
operator|&
name|unknown_language_defn
argument_list|)
expr_stmt|;
name|add_language
argument_list|(
operator|&
name|local_language_defn
argument_list|)
expr_stmt|;
name|add_language
argument_list|(
operator|&
name|auto_language_defn
argument_list|)
expr_stmt|;
name|language
operator|=
name|savestring
argument_list|(
literal|"auto"
argument_list|,
name|strlen
argument_list|(
literal|"auto"
argument_list|)
argument_list|)
expr_stmt|;
name|range
operator|=
name|savestring
argument_list|(
literal|"auto"
argument_list|,
name|strlen
argument_list|(
literal|"auto"
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|savestring
argument_list|(
literal|"auto"
argument_list|,
name|strlen
argument_list|(
literal|"auto"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Have the above take effect */
name|set_language_command
argument_list|(
name|language
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_type_command
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_range_command
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

