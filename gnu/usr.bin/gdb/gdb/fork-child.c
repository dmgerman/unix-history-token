begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Fork a Unix child process, and set up to debug it, for GDB.    Copyright 1990, 1991, 1992 Free Software Foundation, Inc.    Contributed by Cygnus Support.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_comment
comment|/* required by inferior.h */
end_comment

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"wait.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"terminal.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SET_STACK_LIMIT_HUGE
end_ifdef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_decl_stmt
specifier|extern
name|int
name|original_stack_limit
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SET_STACK_LIMIT_HUGE */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Start an inferior Unix child process and sets inferior_pid to its pid.    EXEC_FILE is the file to run.    ALLARGS is a string containing the arguments to the program.    ENV is the environment vector to pass.  Errors reported with error().  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SHELL_FILE
end_ifndef

begin_define
define|#
directive|define
name|SHELL_FILE
value|"/bin/sh"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|void
name|fork_inferior
parameter_list|(
name|exec_file
parameter_list|,
name|allargs
parameter_list|,
name|env
parameter_list|,
name|traceme_fun
parameter_list|,
name|init_trace_fun
parameter_list|)
name|char
modifier|*
name|exec_file
decl_stmt|;
name|char
modifier|*
name|allargs
decl_stmt|;
name|char
modifier|*
modifier|*
name|env
decl_stmt|;
function_decl|void
parameter_list|(
function_decl|*traceme_fun
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|void
argument_list|(
argument|*init_trace_fun
argument_list|)
end_macro

begin_expr_stmt
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|pid
decl_stmt|;
name|char
modifier|*
name|shell_command
decl_stmt|;
name|char
modifier|*
name|shell_file
decl_stmt|;
specifier|static
name|char
name|default_shell_file
index|[]
init|=
name|SHELL_FILE
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|pending_execs
decl_stmt|;
name|int
name|terminal_initted
decl_stmt|;
comment|/* Set debug_fork then attach to the child while it sleeps, to debug. */
specifier|static
name|int
name|debug_fork
init|=
literal|0
decl_stmt|;
comment|/* This is set to the result of setpgrp, which if vforked, will be visible      to you in the parent process.  It's only used by humans for debugging.  */
specifier|static
name|int
name|debug_setpgrp
init|=
literal|657473
decl_stmt|;
name|char
modifier|*
modifier|*
name|save_our_env
decl_stmt|;
comment|/* If no exec file handed to us, get it from the exec-file command -- with      a good, common error message if none is specified.  */
if|if
condition|(
name|exec_file
operator|==
literal|0
condition|)
name|exec_file
operator|=
name|get_exec_file
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* The user might want tilde-expansion, and in general probably wants      the program to behave the same way as if run from      his/her favorite shell.  So we let the shell run it for us.      FIXME, this should probably search the local environment (as      modified by the setenv command), not the env gdb inherited.  */
name|shell_file
operator|=
name|getenv
argument_list|(
literal|"SHELL"
argument_list|)
expr_stmt|;
if|if
condition|(
name|shell_file
operator|==
name|NULL
condition|)
name|shell_file
operator|=
name|default_shell_file
expr_stmt|;
comment|/* Multiplying the length of exec_file by 4 is to account for the fact      that it may expand when quoted; it is a worst-case number based on      every character being '.  */
name|len
operator|=
literal|5
operator|+
literal|4
operator|*
name|strlen
argument_list|(
name|exec_file
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|allargs
argument_list|)
operator|+
literal|1
operator|+
comment|/*slop*/
literal|12
expr_stmt|;
comment|/* If desired, concat something onto the front of ALLARGS.      SHELL_COMMAND is the result.  */
ifdef|#
directive|ifdef
name|SHELL_COMMAND_CONCAT
name|shell_command
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|SHELL_COMMAND_CONCAT
argument_list|)
operator|+
name|len
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|shell_command
argument_list|,
name|SHELL_COMMAND_CONCAT
argument_list|)
expr_stmt|;
else|#
directive|else
name|shell_command
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|shell_command
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
endif|#
directive|endif
name|strcat
argument_list|(
name|shell_command
argument_list|,
literal|"exec "
argument_list|)
expr_stmt|;
comment|/* Now add exec_file, quoting as necessary.  */
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|need_to_quote
decl_stmt|;
comment|/* Quoting in this style is said to work with all shells.  But csh        on IRIX 4.0.1 can't deal with it.  So we only quote it if we need        to.  */
name|p
operator|=
name|exec_file
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'\''
case|:
case|case
literal|'"'
case|:
case|case
literal|'('
case|:
case|case
literal|')'
case|:
case|case
literal|'$'
case|:
case|case
literal|'&'
case|:
case|case
literal|';'
case|:
case|case
literal|'<'
case|:
case|case
literal|'>'
case|:
case|case
literal|' '
case|:
case|case
literal|'\n'
case|:
case|case
literal|'\t'
case|:
name|need_to_quote
operator|=
literal|1
expr_stmt|;
goto|goto
name|end_scan
goto|;
case|case
literal|'\0'
case|:
name|need_to_quote
operator|=
literal|0
expr_stmt|;
goto|goto
name|end_scan
goto|;
default|default:
break|break;
block|}
operator|++
name|p
expr_stmt|;
block|}
name|end_scan
label|:
if|if
condition|(
name|need_to_quote
condition|)
block|{
name|strcat
argument_list|(
name|shell_command
argument_list|,
literal|"'"
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|exec_file
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
operator|++
name|p
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\''
condition|)
name|strcat
argument_list|(
name|shell_command
argument_list|,
literal|"'\\''"
argument_list|)
expr_stmt|;
else|else
name|strncat
argument_list|(
name|shell_command
argument_list|,
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|strcat
argument_list|(
name|shell_command
argument_list|,
literal|"'"
argument_list|)
expr_stmt|;
block|}
else|else
name|strcat
argument_list|(
name|shell_command
argument_list|,
name|exec_file
argument_list|)
expr_stmt|;
block|}
name|strcat
argument_list|(
name|shell_command
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|shell_command
argument_list|,
name|allargs
argument_list|)
expr_stmt|;
comment|/* exec is said to fail if the executable is open.  */
name|close_exec_file
argument_list|()
expr_stmt|;
comment|/* Retain a copy of our environment variables, since the child will      replace the value of  environ  and if we're vforked, we have to       restore it.  */
name|save_our_env
operator|=
name|environ
expr_stmt|;
comment|/* Tell the terminal handling subsystem what tty we plan to run on;      it will just record the information for later.  */
name|new_tty_prefork
argument_list|(
name|inferior_io_terminal
argument_list|)
expr_stmt|;
comment|/* It is generally good practice to flush any possible pending stdio      output prior to doing a fork, to avoid the possibility of both the      parent and child flushing the same data after the fork. */
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|USG
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAVE_VFORK
argument_list|)
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|debug_fork
condition|)
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
else|else
name|pid
operator|=
name|vfork
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
literal|"vfork"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|debug_fork
condition|)
name|sleep
argument_list|(
name|debug_fork
argument_list|)
expr_stmt|;
comment|/* Run inferior in a separate process group.  */
name|debug_setpgrp
operator|=
name|gdb_setpgid
argument_list|()
expr_stmt|;
if|if
condition|(
name|debug_setpgrp
operator|==
operator|-
literal|1
condition|)
name|perror
argument_list|(
literal|"setpgrp failed in child"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SET_STACK_LIMIT_HUGE
comment|/* Reset the stack limit back to what it was.  */
block|{
name|struct
name|rlimit
name|rlim
decl_stmt|;
name|getrlimit
argument_list|(
name|RLIMIT_STACK
argument_list|,
operator|&
name|rlim
argument_list|)
expr_stmt|;
name|rlim
operator|.
name|rlim_cur
operator|=
name|original_stack_limit
expr_stmt|;
name|setrlimit
argument_list|(
name|RLIMIT_STACK
argument_list|,
operator|&
name|rlim
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SET_STACK_LIMIT_HUGE */
comment|/* Ask the tty subsystem to switch to the one we specified earlier 	 (or to share the current terminal, if none was specified).  */
name|new_tty
argument_list|()
expr_stmt|;
comment|/* Changing the signal handlers for the inferior after 	 a vfork can also change them for the superior, so we don't mess 	 with signals here.  See comments in 	 initialize_signals for how we get the right signal handlers 	 for the inferior.  */
comment|/* "Trace me, Dr. Memory!" */
call|(
modifier|*
name|traceme_fun
call|)
argument_list|()
expr_stmt|;
comment|/* There is no execlpe call, so we have to set the environment 	 for our child in the global variable.  If we've vforked, this 	 clobbers the parent, but environ is restored a few lines down 	 in the parent.  By the way, yes we do need to look down the 	 path to find $SHELL.  Rich Pixley says so, and I agree.  */
name|environ
operator|=
name|env
expr_stmt|;
name|execlp
argument_list|(
name|shell_file
argument_list|,
name|shell_file
argument_list|,
literal|"-c"
argument_list|,
name|shell_command
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot exec %s: %s.\n"
argument_list|,
name|shell_file
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|0177
argument_list|)
expr_stmt|;
block|}
comment|/* Restore our environment in case a vforked child clob'd it.  */
name|environ
operator|=
name|save_our_env
expr_stmt|;
name|init_thread_list
argument_list|()
expr_stmt|;
comment|/* Now that we have a child process, make it our target, and      initialize anything target-vector-specific that needs initializing.  */
call|(
modifier|*
name|init_trace_fun
call|)
argument_list|(
name|pid
argument_list|)
expr_stmt|;
comment|/* The process was started by the fork that created it,      but it will have stopped one instruction after execing the shell.      Here we must get it up to actual execution of the real program.  */
name|inferior_pid
operator|=
name|pid
expr_stmt|;
comment|/* Needed for wait_for_inferior stuff below */
name|clear_proceed_status
argument_list|()
expr_stmt|;
comment|/* We will get a trace trap after one instruction.      Continue it automatically.  Eventually (after shell does an exec)      it will get another trace trap.  Then insert breakpoints and continue.  */
ifdef|#
directive|ifdef
name|START_INFERIOR_TRAPS_EXPECTED
name|pending_execs
operator|=
name|START_INFERIOR_TRAPS_EXPECTED
expr_stmt|;
else|#
directive|else
name|pending_execs
operator|=
literal|2
expr_stmt|;
endif|#
directive|endif
name|init_wait_for_inferior
argument_list|()
expr_stmt|;
name|terminal_initted
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|stop_soon_quietly
operator|=
literal|1
expr_stmt|;
comment|/* Make wait_for_inferior be quiet */
name|wait_for_inferior
argument_list|()
expr_stmt|;
if|if
condition|(
name|stop_signal
operator|!=
name|SIGTRAP
condition|)
block|{
comment|/* Let shell child handle its own signals in its own way */
comment|/* FIXME, what if child has exit()ed?  Must exit loop somehow */
name|resume
argument_list|(
literal|0
argument_list|,
name|stop_signal
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We handle SIGTRAP, however; it means child did an exec.  */
if|if
condition|(
operator|!
name|terminal_initted
condition|)
block|{
comment|/* Now that the child has exec'd we know it has already set its 		 process group.  On POSIX systems, tcsetpgrp will fail with 		 EPERM if we try it before the child's setpgid.  */
comment|/* Set up the "saved terminal modes" of the inferior 		 based on what modes we are starting it with.  */
name|target_terminal_init
argument_list|()
expr_stmt|;
comment|/* Install inferior's terminal modes.  */
name|target_terminal_inferior
argument_list|()
expr_stmt|;
name|terminal_initted
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
literal|0
operator|==
operator|--
name|pending_execs
condition|)
break|break;
name|resume
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Just make it go on */
block|}
block|}
name|stop_soon_quietly
operator|=
literal|0
expr_stmt|;
comment|/* We are now in the child process of interest, having exec'd the      correct program, and are poised at the first instruction of the      new program.  */
ifdef|#
directive|ifdef
name|SOLIB_CREATE_INFERIOR_HOOK
name|SOLIB_CREATE_INFERIOR_HOOK
argument_list|(
name|pid
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

end_unit

