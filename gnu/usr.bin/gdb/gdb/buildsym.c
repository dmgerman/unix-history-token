begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Support routines for building symbol tables in GDB's internal format.    Copyright 1986, 1987, 1988, 1989, 1990, 1991, 1992              Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* This module provides subroutines used for creating and adding to    the symbol table.  These routines are called from various symbol-    file-reading routines.     Routines to support specific debugging information formats (stabs,    DWARF, etc) belong somewhere else. */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_comment
comment|/* Needed for "struct complaint" */
end_comment

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"complaints.h"
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|/* Ask buildsym.h to define the vars it normally declares `extern'.  */
end_comment

begin_define
define|#
directive|define
name|EXTERN
end_define

begin_comment
comment|/**/
end_comment

begin_include
include|#
directive|include
file|"buildsym.h"
end_include

begin_comment
comment|/* Our own declarations */
end_comment

begin_undef
undef|#
directive|undef
name|EXTERN
end_undef

begin_comment
comment|/* For cleanup_undefined_types and finish_global_stabs (somewhat    questionable--see comment where we call them).  */
end_comment

begin_include
include|#
directive|include
file|"stabsread.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|compare_line_numbers
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|,
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|blockvector
modifier|*
name|make_blockvector
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Initial sizes of data structures.  These are realloc'd larger if needed,    and realloc'd down to the size actually used, when completed.  */
end_comment

begin_define
define|#
directive|define
name|INITIAL_CONTEXT_STACK_SIZE
value|10
end_define

begin_define
define|#
directive|define
name|INITIAL_LINE_VECTOR_LENGTH
value|1000
end_define

begin_escape
end_escape

begin_comment
comment|/* Complaints about the symbols we have encountered.  */
end_comment

begin_decl_stmt
name|struct
name|complaint
name|innerblock_complaint
init|=
block|{
literal|"inner block not inside outer block in %s"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|innerblock_anon_complaint
init|=
block|{
literal|"inner block not inside outer block"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|blockvector_complaint
init|=
block|{
literal|"block at 0x%lx out of order"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* maintain the lists of symbols and blocks */
end_comment

begin_comment
comment|/* Add a symbol to one of the lists of symbols.  */
end_comment

begin_function
name|void
name|add_symbol_to_list
parameter_list|(
name|symbol
parameter_list|,
name|listhead
parameter_list|)
name|struct
name|symbol
modifier|*
name|symbol
decl_stmt|;
name|struct
name|pending
modifier|*
modifier|*
name|listhead
decl_stmt|;
block|{
specifier|register
name|struct
name|pending
modifier|*
name|link
decl_stmt|;
comment|/* We keep PENDINGSIZE symbols in each link of the list.      If we don't have a link with room in it, add a new link.  */
if|if
condition|(
operator|*
name|listhead
operator|==
name|NULL
operator|||
operator|(
operator|*
name|listhead
operator|)
operator|->
name|nsyms
operator|==
name|PENDINGSIZE
condition|)
block|{
if|if
condition|(
name|free_pendings
condition|)
block|{
name|link
operator|=
name|free_pendings
expr_stmt|;
name|free_pendings
operator|=
name|link
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
name|link
operator|=
operator|(
expr|struct
name|pending
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pending
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|link
operator|->
name|next
operator|=
operator|*
name|listhead
expr_stmt|;
operator|*
name|listhead
operator|=
name|link
expr_stmt|;
name|link
operator|->
name|nsyms
operator|=
literal|0
expr_stmt|;
block|}
operator|(
operator|*
name|listhead
operator|)
operator|->
name|symbol
index|[
operator|(
operator|*
name|listhead
operator|)
operator|->
name|nsyms
operator|++
index|]
operator|=
name|symbol
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find a symbol named NAME on a LIST.  NAME need not be '\0'-terminated;    LENGTH is the length of the name.  */
end_comment

begin_function
name|struct
name|symbol
modifier|*
name|find_symbol_in_list
parameter_list|(
name|list
parameter_list|,
name|name
parameter_list|,
name|length
parameter_list|)
name|struct
name|pending
modifier|*
name|list
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|length
decl_stmt|;
block|{
name|int
name|j
decl_stmt|;
name|char
modifier|*
name|pp
decl_stmt|;
while|while
condition|(
name|list
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|j
operator|=
name|list
operator|->
name|nsyms
init|;
operator|--
name|j
operator|>=
literal|0
condition|;
control|)
block|{
name|pp
operator|=
name|SYMBOL_NAME
argument_list|(
name|list
operator|->
name|symbol
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pp
operator|==
operator|*
name|name
operator|&&
name|strncmp
argument_list|(
name|pp
argument_list|,
name|name
argument_list|,
name|length
argument_list|)
operator|==
literal|0
operator|&&
name|pp
index|[
name|length
index|]
operator|==
literal|'\0'
condition|)
block|{
return|return
operator|(
name|list
operator|->
name|symbol
index|[
name|j
index|]
operator|)
return|;
block|}
block|}
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* At end of reading syms, or in case of quit,    really free as many `struct pending's as we can easily find. */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|really_free_pendings
parameter_list|(
name|foo
parameter_list|)
name|int
name|foo
decl_stmt|;
block|{
name|struct
name|pending
modifier|*
name|next
decl_stmt|,
modifier|*
name|next1
decl_stmt|;
if|#
directive|if
literal|0
block|struct pending_block *bnext, *bnext1;
endif|#
directive|endif
for|for
control|(
name|next
operator|=
name|free_pendings
init|;
name|next
condition|;
name|next
operator|=
name|next1
control|)
block|{
name|next1
operator|=
name|next
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|next
argument_list|)
expr_stmt|;
block|}
name|free_pendings
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Now we make the links in the symbol_obstack, so don't free them.  */
block|for (bnext = pending_blocks; bnext; bnext = bnext1)     {       bnext1 = bnext->next;       free ((PTR)bnext);     }
endif|#
directive|endif
name|pending_blocks
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|next
operator|=
name|file_symbols
init|;
name|next
operator|!=
name|NULL
condition|;
name|next
operator|=
name|next1
control|)
block|{
name|next1
operator|=
name|next
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|next
argument_list|)
expr_stmt|;
block|}
name|file_symbols
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|next
operator|=
name|global_symbols
init|;
name|next
operator|!=
name|NULL
condition|;
name|next
operator|=
name|next1
control|)
block|{
name|next1
operator|=
name|next
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|next
argument_list|)
expr_stmt|;
block|}
name|global_symbols
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Take one of the lists of symbols and make a block from it.    Keep the order the symbols have in the list (reversed from the input file).    Put the block on the list of pending blocks.  */
end_comment

begin_function
name|void
name|finish_block
parameter_list|(
name|symbol
parameter_list|,
name|listhead
parameter_list|,
name|old_blocks
parameter_list|,
name|start
parameter_list|,
name|end
parameter_list|,
name|objfile
parameter_list|)
name|struct
name|symbol
modifier|*
name|symbol
decl_stmt|;
name|struct
name|pending
modifier|*
modifier|*
name|listhead
decl_stmt|;
name|struct
name|pending_block
modifier|*
name|old_blocks
decl_stmt|;
name|CORE_ADDR
name|start
decl_stmt|,
name|end
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
specifier|register
name|struct
name|pending
modifier|*
name|next
decl_stmt|,
modifier|*
name|next1
decl_stmt|;
specifier|register
name|struct
name|block
modifier|*
name|block
decl_stmt|;
specifier|register
name|struct
name|pending_block
modifier|*
name|pblock
decl_stmt|;
name|struct
name|pending_block
modifier|*
name|opblock
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
comment|/* Count the length of the list of symbols.  */
for|for
control|(
name|next
operator|=
operator|*
name|listhead
operator|,
name|i
operator|=
literal|0
init|;
name|next
condition|;
name|i
operator|+=
name|next
operator|->
name|nsyms
operator|,
name|next
operator|=
name|next
operator|->
name|next
control|)
block|{
comment|/*EMPTY*/
empty_stmt|;
block|}
name|block
operator|=
operator|(
expr|struct
name|block
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|block
argument_list|)
operator|+
operator|(
operator|(
name|i
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
operator|*
argument_list|)
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Copy the symbols into the block.  */
name|BLOCK_NSYMS
argument_list|(
name|block
argument_list|)
operator|=
name|i
expr_stmt|;
for|for
control|(
name|next
operator|=
operator|*
name|listhead
init|;
name|next
condition|;
name|next
operator|=
name|next
operator|->
name|next
control|)
block|{
for|for
control|(
name|j
operator|=
name|next
operator|->
name|nsyms
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|BLOCK_SYM
argument_list|(
name|block
argument_list|,
operator|--
name|i
argument_list|)
operator|=
name|next
operator|->
name|symbol
index|[
name|j
index|]
expr_stmt|;
block|}
block|}
name|BLOCK_START
argument_list|(
name|block
argument_list|)
operator|=
name|start
expr_stmt|;
name|BLOCK_END
argument_list|(
name|block
argument_list|)
operator|=
name|end
expr_stmt|;
comment|/* Superblock filled in when containing block is made */
name|BLOCK_SUPERBLOCK
argument_list|(
name|block
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|BLOCK_GCC_COMPILED
argument_list|(
name|block
argument_list|)
operator|=
name|processing_gcc_compilation
expr_stmt|;
comment|/* Put the block in as the value of the symbol that names it.  */
if|if
condition|(
name|symbol
condition|)
block|{
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|symbol
argument_list|)
operator|=
name|block
expr_stmt|;
name|BLOCK_FUNCTION
argument_list|(
name|block
argument_list|)
operator|=
name|symbol
expr_stmt|;
block|}
else|else
block|{
name|BLOCK_FUNCTION
argument_list|(
name|block
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Now "free" the links of the list, and empty the list.  */
for|for
control|(
name|next
operator|=
operator|*
name|listhead
init|;
name|next
condition|;
name|next
operator|=
name|next1
control|)
block|{
name|next1
operator|=
name|next
operator|->
name|next
expr_stmt|;
name|next
operator|->
name|next
operator|=
name|free_pendings
expr_stmt|;
name|free_pendings
operator|=
name|next
expr_stmt|;
block|}
operator|*
name|listhead
operator|=
name|NULL
expr_stmt|;
comment|/* Install this block as the superblock      of all blocks made since the start of this scope      that don't have superblocks yet.  */
name|opblock
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|pblock
operator|=
name|pending_blocks
init|;
name|pblock
operator|!=
name|old_blocks
condition|;
name|pblock
operator|=
name|pblock
operator|->
name|next
control|)
block|{
if|if
condition|(
name|BLOCK_SUPERBLOCK
argument_list|(
name|pblock
operator|->
name|block
argument_list|)
operator|==
name|NULL
condition|)
block|{
if|#
directive|if
literal|1
comment|/* Check to be sure the blocks are nested as we receive them.  	     If the compiler/assembler/linker work, this just burns a small 	     amount of time.  */
if|if
condition|(
name|BLOCK_START
argument_list|(
name|pblock
operator|->
name|block
argument_list|)
operator|<
name|BLOCK_START
argument_list|(
name|block
argument_list|)
operator|||
name|BLOCK_END
argument_list|(
name|pblock
operator|->
name|block
argument_list|)
operator|>
name|BLOCK_END
argument_list|(
name|block
argument_list|)
condition|)
block|{
if|if
condition|(
name|symbol
condition|)
block|{
name|complain
argument_list|(
operator|&
name|innerblock_complaint
argument_list|,
name|SYMBOL_SOURCE_NAME
argument_list|(
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|complain
argument_list|(
operator|&
name|innerblock_anon_complaint
argument_list|)
expr_stmt|;
block|}
name|BLOCK_START
argument_list|(
name|pblock
operator|->
name|block
argument_list|)
operator|=
name|BLOCK_START
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|BLOCK_END
argument_list|(
name|pblock
operator|->
name|block
argument_list|)
operator|=
name|BLOCK_END
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|BLOCK_SUPERBLOCK
argument_list|(
name|pblock
operator|->
name|block
argument_list|)
operator|=
name|block
expr_stmt|;
block|}
name|opblock
operator|=
name|pblock
expr_stmt|;
block|}
comment|/* Record this block on the list of all blocks in the file.      Put it after opblock, or at the beginning if opblock is 0.      This puts the block in the list after all its subblocks.  */
comment|/* Allocate in the symbol_obstack to save time.      It wastes a little space.  */
name|pblock
operator|=
operator|(
expr|struct
name|pending_block
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pending_block
argument_list|)
argument_list|)
expr_stmt|;
name|pblock
operator|->
name|block
operator|=
name|block
expr_stmt|;
if|if
condition|(
name|opblock
condition|)
block|{
name|pblock
operator|->
name|next
operator|=
name|opblock
operator|->
name|next
expr_stmt|;
name|opblock
operator|->
name|next
operator|=
name|pblock
expr_stmt|;
block|}
else|else
block|{
name|pblock
operator|->
name|next
operator|=
name|pending_blocks
expr_stmt|;
name|pending_blocks
operator|=
name|pblock
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|blockvector
modifier|*
name|make_blockvector
parameter_list|(
name|objfile
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
specifier|register
name|struct
name|pending_block
modifier|*
name|next
decl_stmt|;
specifier|register
name|struct
name|blockvector
modifier|*
name|blockvector
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Count the length of the list of blocks.  */
for|for
control|(
name|next
operator|=
name|pending_blocks
operator|,
name|i
operator|=
literal|0
init|;
name|next
condition|;
name|next
operator|=
name|next
operator|->
name|next
operator|,
name|i
operator|++
control|)
block|{
empty_stmt|;
block|}
name|blockvector
operator|=
operator|(
expr|struct
name|blockvector
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|blockvector
argument_list|)
operator|+
operator|(
name|i
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|block
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Copy the blocks into the blockvector.      This is done in reverse order, which happens to put      the blocks into the proper order (ascending starting address).      finish_block has hair to insert each block into the list      after its subblocks in order to make sure this is true.  */
name|BLOCKVECTOR_NBLOCKS
argument_list|(
name|blockvector
argument_list|)
operator|=
name|i
expr_stmt|;
for|for
control|(
name|next
operator|=
name|pending_blocks
init|;
name|next
condition|;
name|next
operator|=
name|next
operator|->
name|next
control|)
block|{
name|BLOCKVECTOR_BLOCK
argument_list|(
name|blockvector
argument_list|,
operator|--
name|i
argument_list|)
operator|=
name|next
operator|->
name|block
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* Now we make the links in the obstack, so don't free them.  */
comment|/* Now free the links of the list, and empty the list.  */
block|for (next = pending_blocks; next; next = next1)     {       next1 = next->next;       free (next);     }
endif|#
directive|endif
name|pending_blocks
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
literal|1
comment|/* FIXME, shut this off after a while to speed up symbol reading.  */
comment|/* Some compilers output blocks in the wrong order, but we depend      on their being in the right order so we can binary search.       Check the order and moan about it.  FIXME.  */
if|if
condition|(
name|BLOCKVECTOR_NBLOCKS
argument_list|(
name|blockvector
argument_list|)
operator|>
literal|1
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|BLOCKVECTOR_NBLOCKS
argument_list|(
name|blockvector
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|BLOCK_START
argument_list|(
name|BLOCKVECTOR_BLOCK
argument_list|(
name|blockvector
argument_list|,
name|i
operator|-
literal|1
argument_list|)
argument_list|)
operator|>
name|BLOCK_START
argument_list|(
name|BLOCKVECTOR_BLOCK
argument_list|(
name|blockvector
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
block|{
comment|/* FIXME-32x64: loses if CORE_ADDR doesn't fit in a 		 long.  Possible solutions include a version of 		 complain which takes a callback, a 		 sprintf_address_numeric to match 		 print_address_numeric, or a way to set up a GDB_FILE 		 * which causes sprintf rather than fprintf to be 		 called.  */
name|complain
argument_list|(
operator|&
name|blockvector_complaint
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|BLOCK_START
argument_list|(
name|BLOCKVECTOR_BLOCK
argument_list|(
name|blockvector
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
return|return
operator|(
name|blockvector
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Start recording information about source code that came from an included    (or otherwise merged-in) source file with a different name.  NAME is    the name of the file (cannot be NULL), DIRNAME is the directory in which    it resides (or NULL if not known).  */
end_comment

begin_function
name|void
name|start_subfile
parameter_list|(
name|name
parameter_list|,
name|dirname
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|dirname
decl_stmt|;
block|{
specifier|register
name|struct
name|subfile
modifier|*
name|subfile
decl_stmt|;
comment|/* See if this subfile is already known as a subfile of the      current main source file.  */
for|for
control|(
name|subfile
operator|=
name|subfiles
init|;
name|subfile
condition|;
name|subfile
operator|=
name|subfile
operator|->
name|next
control|)
block|{
if|if
condition|(
name|STREQ
argument_list|(
name|subfile
operator|->
name|name
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|current_subfile
operator|=
name|subfile
expr_stmt|;
return|return;
block|}
block|}
comment|/* This subfile is not known.  Add an entry for it.      Make an entry for this subfile in the list of all subfiles      of the current main source file.  */
name|subfile
operator|=
operator|(
expr|struct
name|subfile
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|subfile
argument_list|)
argument_list|)
expr_stmt|;
name|subfile
operator|->
name|next
operator|=
name|subfiles
expr_stmt|;
name|subfiles
operator|=
name|subfile
expr_stmt|;
name|current_subfile
operator|=
name|subfile
expr_stmt|;
comment|/* Save its name and compilation directory name */
name|subfile
operator|->
name|name
operator|=
operator|(
name|name
operator|==
name|NULL
operator|)
condition|?
name|NULL
else|:
name|savestring
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|subfile
operator|->
name|dirname
operator|=
operator|(
name|dirname
operator|==
name|NULL
operator|)
condition|?
name|NULL
else|:
name|savestring
argument_list|(
name|dirname
argument_list|,
name|strlen
argument_list|(
name|dirname
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize line-number recording for this subfile.  */
name|subfile
operator|->
name|line_vector
operator|=
name|NULL
expr_stmt|;
comment|/* Default the source language to whatever can be deduced from      the filename.  If nothing can be deduced (such as for a C/C++      include file with a ".h" extension), then inherit whatever      language the previous subfile had.  This kludgery is necessary      because there is no standard way in some object formats to      record the source language.  Also, when symtabs are allocated      we try to deduce a language then as well, but it is too late      for us to use that information while reading symbols, since      symtabs aren't allocated until after all the symbols have      been processed for a given source file. */
name|subfile
operator|->
name|language
operator|=
name|deduce_language_from_filename
argument_list|(
name|subfile
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|subfile
operator|->
name|language
operator|==
name|language_unknown
operator|&&
name|subfile
operator|->
name|next
operator|!=
name|NULL
condition|)
block|{
name|subfile
operator|->
name|language
operator|=
name|subfile
operator|->
name|next
operator|->
name|language
expr_stmt|;
block|}
comment|/* cfront output is a C program, so in most ways it looks like a C      program.  But to demangle we need to set the language to C++.  We      can distinguish cfront code by the fact that it has #line      directives which specify a file name ending in .C.       So if the filename of this subfile ends in .C, then change the language      of any pending subfiles from C to C++.  We also accept any other C++      suffixes accepted by deduce_language_from_filename (in particular,      some people use .cxx with cfront).  */
if|if
condition|(
name|subfile
operator|->
name|name
condition|)
block|{
name|struct
name|subfile
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|deduce_language_from_filename
argument_list|(
name|subfile
operator|->
name|name
argument_list|)
operator|==
name|language_cplus
condition|)
for|for
control|(
name|s
operator|=
name|subfiles
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
if|if
condition|(
name|s
operator|->
name|language
operator|==
name|language_c
condition|)
name|s
operator|->
name|language
operator|=
name|language_cplus
expr_stmt|;
block|}
comment|/* And patch up this file if necessary.  */
if|if
condition|(
name|subfile
operator|->
name|language
operator|==
name|language_c
operator|&&
name|subfile
operator|->
name|next
operator|!=
name|NULL
operator|&&
name|subfile
operator|->
name|next
operator|->
name|language
operator|==
name|language_cplus
condition|)
block|{
name|subfile
operator|->
name|language
operator|=
name|language_cplus
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* For stabs readers, the first N_SO symbol is assumed to be the source    file name, and the subfile struct is initialized using that assumption.    If another N_SO symbol is later seen, immediately following the first    one, then the first one is assumed to be the directory name and the    second one is really the source file name.     So we have to patch up the subfile struct by moving the old name value to    dirname and remembering the new name.  Some sanity checking is performed    to ensure that the state of the subfile struct is reasonable and that the    old name we are assuming to be a directory name actually is (by checking    for a trailing '/'). */
end_comment

begin_function
name|void
name|patch_subfile_names
parameter_list|(
name|subfile
parameter_list|,
name|name
parameter_list|)
name|struct
name|subfile
modifier|*
name|subfile
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
if|if
condition|(
name|subfile
operator|!=
name|NULL
operator|&&
name|subfile
operator|->
name|dirname
operator|==
name|NULL
operator|&&
name|subfile
operator|->
name|name
operator|!=
name|NULL
operator|&&
name|subfile
operator|->
name|name
index|[
name|strlen
argument_list|(
name|subfile
operator|->
name|name
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
name|subfile
operator|->
name|dirname
operator|=
name|subfile
operator|->
name|name
expr_stmt|;
name|subfile
operator|->
name|name
operator|=
name|savestring
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Default the source language to whatever can be deduced from 	 the filename.  If nothing can be deduced (such as for a C/C++ 	 include file with a ".h" extension), then inherit whatever 	 language the previous subfile had.  This kludgery is necessary 	 because there is no standard way in some object formats to 	 record the source language.  Also, when symtabs are allocated 	 we try to deduce a language then as well, but it is too late 	 for us to use that information while reading symbols, since 	 symtabs aren't allocated until after all the symbols have 	 been processed for a given source file. */
name|subfile
operator|->
name|language
operator|=
name|deduce_language_from_filename
argument_list|(
name|subfile
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|subfile
operator|->
name|language
operator|==
name|language_unknown
operator|&&
name|subfile
operator|->
name|next
operator|!=
name|NULL
condition|)
block|{
name|subfile
operator|->
name|language
operator|=
name|subfile
operator|->
name|next
operator|->
name|language
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Handle the N_BINCL and N_EINCL symbol types    that act like N_SOL for switching source files    (different subfiles, as we call them) within one object file,    but using a stack rather than in an arbitrary order.  */
end_comment

begin_function
name|void
name|push_subfile
parameter_list|()
block|{
specifier|register
name|struct
name|subfile_stack
modifier|*
name|tem
init|=
operator|(
expr|struct
name|subfile_stack
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|subfile_stack
argument_list|)
argument_list|)
decl_stmt|;
name|tem
operator|->
name|next
operator|=
name|subfile_stack
expr_stmt|;
name|subfile_stack
operator|=
name|tem
expr_stmt|;
if|if
condition|(
name|current_subfile
operator|==
name|NULL
operator|||
name|current_subfile
operator|->
name|name
operator|==
name|NULL
condition|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
name|tem
operator|->
name|name
operator|=
name|current_subfile
operator|->
name|name
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|pop_subfile
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|struct
name|subfile_stack
modifier|*
name|link
init|=
name|subfile_stack
decl_stmt|;
if|if
condition|(
name|link
operator|==
name|NULL
condition|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
name|name
operator|=
name|link
operator|->
name|name
expr_stmt|;
name|subfile_stack
operator|=
name|link
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|link
argument_list|)
expr_stmt|;
return|return
operator|(
name|name
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add a linetable entry for line number LINE and address PC to the line    vector for SUBFILE.  */
end_comment

begin_function
name|void
name|record_line
parameter_list|(
name|subfile
parameter_list|,
name|line
parameter_list|,
name|pc
parameter_list|)
specifier|register
name|struct
name|subfile
modifier|*
name|subfile
decl_stmt|;
name|int
name|line
decl_stmt|;
name|CORE_ADDR
name|pc
decl_stmt|;
block|{
name|struct
name|linetable_entry
modifier|*
name|e
decl_stmt|;
comment|/* Ignore the dummy line number in libg.o */
if|if
condition|(
name|line
operator|==
literal|0xffff
condition|)
block|{
return|return;
block|}
comment|/* Make sure line vector exists and is big enough.  */
if|if
condition|(
operator|!
name|subfile
operator|->
name|line_vector
condition|)
block|{
name|subfile
operator|->
name|line_vector_length
operator|=
name|INITIAL_LINE_VECTOR_LENGTH
expr_stmt|;
name|subfile
operator|->
name|line_vector
operator|=
operator|(
expr|struct
name|linetable
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|linetable
argument_list|)
operator|+
name|subfile
operator|->
name|line_vector_length
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|linetable_entry
argument_list|)
argument_list|)
expr_stmt|;
name|subfile
operator|->
name|line_vector
operator|->
name|nitems
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|subfile
operator|->
name|line_vector
operator|->
name|nitems
operator|+
literal|1
operator|>=
name|subfile
operator|->
name|line_vector_length
condition|)
block|{
name|subfile
operator|->
name|line_vector_length
operator|*=
literal|2
expr_stmt|;
name|subfile
operator|->
name|line_vector
operator|=
operator|(
expr|struct
name|linetable
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|subfile
operator|->
name|line_vector
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|linetable
argument_list|)
operator|+
name|subfile
operator|->
name|line_vector_length
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|linetable_entry
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
name|e
operator|=
name|subfile
operator|->
name|line_vector
operator|->
name|item
operator|+
name|subfile
operator|->
name|line_vector
operator|->
name|nitems
operator|++
expr_stmt|;
name|e
operator|->
name|line
operator|=
name|line
expr_stmt|;
name|e
operator|->
name|pc
operator|=
name|pc
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Needed in order to sort line tables from IBM xcoff files.  Sigh!  */
end_comment

begin_function
specifier|static
name|int
name|compare_line_numbers
parameter_list|(
name|ln1p
parameter_list|,
name|ln2p
parameter_list|)
specifier|const
name|PTR
name|ln1p
decl_stmt|;
specifier|const
name|PTR
name|ln2p
decl_stmt|;
block|{
name|struct
name|linetable_entry
modifier|*
name|ln1
init|=
operator|(
expr|struct
name|linetable_entry
operator|*
operator|)
name|ln1p
decl_stmt|;
name|struct
name|linetable_entry
modifier|*
name|ln2
init|=
operator|(
expr|struct
name|linetable_entry
operator|*
operator|)
name|ln2p
decl_stmt|;
comment|/* Note: this code does not assume that CORE_ADDRs can fit in ints.      Please keep it that way.  */
if|if
condition|(
name|ln1
operator|->
name|pc
operator|<
name|ln2
operator|->
name|pc
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|ln1
operator|->
name|pc
operator|>
name|ln2
operator|->
name|pc
condition|)
return|return
literal|1
return|;
comment|/* If pc equal, sort by line.  I'm not sure whether this is optimum      behavior (see comment at struct linetable in symtab.h).  */
return|return
name|ln1
operator|->
name|line
operator|-
name|ln2
operator|->
name|line
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Start a new symtab for a new source file.    Called, for example, when a stabs symbol of type N_SO is seen, or when    a DWARF TAG_compile_unit DIE is seen.    It indicates the start of data for one original source file.  */
end_comment

begin_function
name|void
name|start_symtab
parameter_list|(
name|name
parameter_list|,
name|dirname
parameter_list|,
name|start_addr
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|dirname
decl_stmt|;
name|CORE_ADDR
name|start_addr
decl_stmt|;
block|{
name|last_source_file
operator|=
name|name
expr_stmt|;
name|last_source_start_addr
operator|=
name|start_addr
expr_stmt|;
name|file_symbols
operator|=
name|NULL
expr_stmt|;
name|global_symbols
operator|=
name|NULL
expr_stmt|;
name|within_function
operator|=
literal|0
expr_stmt|;
comment|/* Context stack is initially empty.  Allocate first one with room for      10 levels; reuse it forever afterward.  */
if|if
condition|(
name|context_stack
operator|==
name|NULL
condition|)
block|{
name|context_stack_size
operator|=
name|INITIAL_CONTEXT_STACK_SIZE
expr_stmt|;
name|context_stack
operator|=
operator|(
expr|struct
name|context_stack
operator|*
operator|)
name|xmalloc
argument_list|(
name|context_stack_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|context_stack
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|context_stack_depth
operator|=
literal|0
expr_stmt|;
comment|/* Initialize the list of sub source files with one entry      for this file (the top-level source file).  */
name|subfiles
operator|=
name|NULL
expr_stmt|;
name|current_subfile
operator|=
name|NULL
expr_stmt|;
name|start_subfile
argument_list|(
name|name
argument_list|,
name|dirname
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish the symbol definitions for one main source file,    close off all the lexical contexts for that file    (creating struct block's for them), then make the struct symtab    for that file and put it in the list of all such.     END_ADDR is the address of the end of the file's text.    SECTION is the section number (in objfile->section_offsets) of    the blockvector and linetable.     Note that it is possible for end_symtab() to return NULL.  In particular,    for the DWARF case at least, it will return NULL when it finds a    compilation unit that has exactly one DIE, a TAG_compile_unit DIE.  This    can happen when we link in an object file that was compiled from an empty    source file.  Returning NULL is probably not the correct thing to do,    because then gdb will never know about this empty file (FIXME). */
end_comment

begin_function
name|struct
name|symtab
modifier|*
name|end_symtab
parameter_list|(
name|end_addr
parameter_list|,
name|sort_pending
parameter_list|,
name|sort_linevec
parameter_list|,
name|objfile
parameter_list|,
name|section
parameter_list|)
name|CORE_ADDR
name|end_addr
decl_stmt|;
name|int
name|sort_pending
decl_stmt|;
name|int
name|sort_linevec
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|int
name|section
decl_stmt|;
block|{
specifier|register
name|struct
name|symtab
modifier|*
name|symtab
init|=
name|NULL
decl_stmt|;
specifier|register
name|struct
name|blockvector
modifier|*
name|blockvector
decl_stmt|;
specifier|register
name|struct
name|subfile
modifier|*
name|subfile
decl_stmt|;
specifier|register
name|struct
name|context_stack
modifier|*
name|cstk
decl_stmt|;
name|struct
name|subfile
modifier|*
name|nextsub
decl_stmt|;
comment|/* Finish the lexical context of the last function in the file;      pop the context stack.  */
if|if
condition|(
name|context_stack_depth
operator|>
literal|0
condition|)
block|{
name|context_stack_depth
operator|--
expr_stmt|;
name|cstk
operator|=
operator|&
name|context_stack
index|[
name|context_stack_depth
index|]
expr_stmt|;
comment|/* Make a block for the local symbols within.  */
name|finish_block
argument_list|(
name|cstk
operator|->
name|name
argument_list|,
operator|&
name|local_symbols
argument_list|,
name|cstk
operator|->
name|old_blocks
argument_list|,
name|cstk
operator|->
name|start_addr
argument_list|,
name|end_addr
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|context_stack_depth
operator|>
literal|0
condition|)
block|{
comment|/* This is said to happen with SCO.  The old coffread.c code 	     simply emptied the context stack, so we do the same.  FIXME: 	     Find out why it is happening.  This is not believed to happen 	     in most cases (even for coffread.c); it used to be an abort().  */
specifier|static
name|struct
name|complaint
name|msg
init|=
block|{
literal|"Context stack not empty in end_symtab"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|complain
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
name|context_stack_depth
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* It is unfortunate that in xcoff, pending blocks might not be ordered      in this stage. Especially, blocks for static functions will show up at      the end.  We need to sort them, so tools like `find_pc_function' and      `find_pc_block' can work reliably. */
if|if
condition|(
name|sort_pending
operator|&&
name|pending_blocks
condition|)
block|{
comment|/* FIXME!  Remove this horrid bubble sort and use qsort!!! */
name|int
name|swapped
decl_stmt|;
do|do
block|{
name|struct
name|pending_block
modifier|*
name|pb
decl_stmt|,
modifier|*
name|pbnext
decl_stmt|;
name|pb
operator|=
name|pending_blocks
expr_stmt|;
name|pbnext
operator|=
name|pb
operator|->
name|next
expr_stmt|;
name|swapped
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|pbnext
condition|)
block|{
comment|/* swap blocks if unordered! */
if|if
condition|(
name|BLOCK_START
argument_list|(
name|pb
operator|->
name|block
argument_list|)
operator|<
name|BLOCK_START
argument_list|(
name|pbnext
operator|->
name|block
argument_list|)
condition|)
block|{
name|struct
name|block
modifier|*
name|tmp
init|=
name|pb
operator|->
name|block
decl_stmt|;
name|pb
operator|->
name|block
operator|=
name|pbnext
operator|->
name|block
expr_stmt|;
name|pbnext
operator|->
name|block
operator|=
name|tmp
expr_stmt|;
name|swapped
operator|=
literal|1
expr_stmt|;
block|}
name|pb
operator|=
name|pbnext
expr_stmt|;
name|pbnext
operator|=
name|pbnext
operator|->
name|next
expr_stmt|;
block|}
block|}
do|while
condition|(
name|swapped
condition|)
do|;
block|}
comment|/* Cleanup any undefined types that have been left hanging around      (this needs to be done before the finish_blocks so that      file_symbols is still good).       Both cleanup_undefined_types and finish_global_stabs are stabs      specific, but harmless for other symbol readers, since on gdb      startup or when finished reading stabs, the state is set so these      are no-ops.  FIXME: Is this handled right in case of QUIT?  Can      we make this cleaner?  */
name|cleanup_undefined_types
argument_list|()
expr_stmt|;
name|finish_global_stabs
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|pending_blocks
operator|==
name|NULL
operator|&&
name|file_symbols
operator|==
name|NULL
operator|&&
name|global_symbols
operator|==
name|NULL
condition|)
block|{
comment|/* Ignore symtabs that have no functions with real debugging info */
name|blockvector
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* Define the STATIC_BLOCK& GLOBAL_BLOCK, and build the blockvector. */
name|finish_block
argument_list|(
literal|0
argument_list|,
operator|&
name|file_symbols
argument_list|,
literal|0
argument_list|,
name|last_source_start_addr
argument_list|,
name|end_addr
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|finish_block
argument_list|(
literal|0
argument_list|,
operator|&
name|global_symbols
argument_list|,
literal|0
argument_list|,
name|last_source_start_addr
argument_list|,
name|end_addr
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|blockvector
operator|=
name|make_blockvector
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PROCESS_LINENUMBER_HOOK
name|PROCESS_LINENUMBER_HOOK
argument_list|()
expr_stmt|;
comment|/* Needed for xcoff. */
endif|#
directive|endif
comment|/* Now create the symtab objects proper, one for each subfile.  */
comment|/* (The main file is the last one on the chain.)  */
for|for
control|(
name|subfile
operator|=
name|subfiles
init|;
name|subfile
condition|;
name|subfile
operator|=
name|nextsub
control|)
block|{
name|int
name|linetablesize
init|=
literal|0
decl_stmt|;
comment|/* If we have blocks of symbols, make a symtab. 	 Otherwise, just ignore this file and any line number info in it.  */
name|symtab
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|blockvector
condition|)
block|{
if|if
condition|(
name|subfile
operator|->
name|line_vector
condition|)
block|{
name|linetablesize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|linetable
argument_list|)
operator|+
name|subfile
operator|->
name|line_vector
operator|->
name|nitems
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|linetable_entry
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* I think this is artifact from before it went on the obstack. 		 I doubt we'll need the memory between now and when we 		 free it later in this function.  */
comment|/* First, shrink the linetable to make more memory.  */
block|subfile->line_vector = (struct linetable *) 		xrealloc ((char *) subfile->line_vector, linetablesize);
endif|#
directive|endif
comment|/* If sort_linevec is false, we might want just check to make 		 sure they are sorted and complain() if not, as a way of 		 tracking down compilers/symbol readers which don't get 		 them sorted right.  */
if|if
condition|(
name|sort_linevec
condition|)
name|qsort
argument_list|(
name|subfile
operator|->
name|line_vector
operator|->
name|item
argument_list|,
name|subfile
operator|->
name|line_vector
operator|->
name|nitems
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|linetable_entry
argument_list|)
argument_list|,
name|compare_line_numbers
argument_list|)
expr_stmt|;
block|}
comment|/* Now, allocate a symbol table.  */
name|symtab
operator|=
name|allocate_symtab
argument_list|(
name|subfile
operator|->
name|name
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* Fill in its components.  */
name|symtab
operator|->
name|blockvector
operator|=
name|blockvector
expr_stmt|;
if|if
condition|(
name|subfile
operator|->
name|line_vector
condition|)
block|{
comment|/* Reallocate the line table on the symbol obstack */
name|symtab
operator|->
name|linetable
operator|=
operator|(
expr|struct
name|linetable
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|,
name|linetablesize
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|symtab
operator|->
name|linetable
argument_list|,
name|subfile
operator|->
name|line_vector
argument_list|,
name|linetablesize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|symtab
operator|->
name|linetable
operator|=
name|NULL
expr_stmt|;
block|}
name|symtab
operator|->
name|block_line_section
operator|=
name|section
expr_stmt|;
if|if
condition|(
name|subfile
operator|->
name|dirname
condition|)
block|{
comment|/* Reallocate the dirname on the symbol obstack */
name|symtab
operator|->
name|dirname
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|,
name|strlen
argument_list|(
name|subfile
operator|->
name|dirname
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|symtab
operator|->
name|dirname
argument_list|,
name|subfile
operator|->
name|dirname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|symtab
operator|->
name|dirname
operator|=
name|NULL
expr_stmt|;
block|}
name|symtab
operator|->
name|free_code
operator|=
name|free_linetable
expr_stmt|;
name|symtab
operator|->
name|free_ptr
operator|=
name|NULL
expr_stmt|;
comment|/* Use whatever language we have been using for this subfile, 	     not the one that was deduced in allocate_symtab from the 	     filename.  We already did our own deducing when we created 	     the subfile, and we may have altered our opinion of what 	     language it is from things we found in the symbols. */
name|symtab
operator|->
name|language
operator|=
name|subfile
operator|->
name|language
expr_stmt|;
comment|/* All symtabs for the main file and the subfiles share a 	     blockvector, so we need to clear primary for everything but 	     the main file.  */
name|symtab
operator|->
name|primary
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|subfile
operator|->
name|name
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|subfile
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|subfile
operator|->
name|dirname
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|subfile
operator|->
name|dirname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|subfile
operator|->
name|line_vector
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|subfile
operator|->
name|line_vector
argument_list|)
expr_stmt|;
block|}
name|nextsub
operator|=
name|subfile
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|subfile
argument_list|)
expr_stmt|;
block|}
comment|/* Set this for the main source file.  */
if|if
condition|(
name|symtab
condition|)
block|{
name|symtab
operator|->
name|primary
operator|=
literal|1
expr_stmt|;
block|}
name|last_source_file
operator|=
name|NULL
expr_stmt|;
name|current_subfile
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|symtab
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Push a context block.  Args are an identifying nesting level (checkable    when you pop it), and the starting PC address of this context.  */
end_comment

begin_function
name|struct
name|context_stack
modifier|*
name|push_context
parameter_list|(
name|desc
parameter_list|,
name|valu
parameter_list|)
name|int
name|desc
decl_stmt|;
name|CORE_ADDR
name|valu
decl_stmt|;
block|{
specifier|register
name|struct
name|context_stack
modifier|*
name|new
decl_stmt|;
if|if
condition|(
name|context_stack_depth
operator|==
name|context_stack_size
condition|)
block|{
name|context_stack_size
operator|*=
literal|2
expr_stmt|;
name|context_stack
operator|=
operator|(
expr|struct
name|context_stack
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|context_stack
argument_list|,
operator|(
name|context_stack_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|context_stack
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
name|new
operator|=
operator|&
name|context_stack
index|[
name|context_stack_depth
operator|++
index|]
expr_stmt|;
name|new
operator|->
name|depth
operator|=
name|desc
expr_stmt|;
name|new
operator|->
name|locals
operator|=
name|local_symbols
expr_stmt|;
name|new
operator|->
name|old_blocks
operator|=
name|pending_blocks
expr_stmt|;
name|new
operator|->
name|start_addr
operator|=
name|valu
expr_stmt|;
name|new
operator|->
name|name
operator|=
name|NULL
expr_stmt|;
name|local_symbols
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compute a small integer hash code for the given name. */
end_comment

begin_function
name|int
name|hashname
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|name
decl_stmt|;
specifier|register
name|int
name|total
init|=
name|p
index|[
literal|0
index|]
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|c
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
name|total
operator|+=
name|c
operator|<<
literal|2
expr_stmt|;
if|if
condition|(
name|c
condition|)
block|{
name|c
operator|=
name|p
index|[
literal|2
index|]
expr_stmt|;
name|total
operator|+=
name|c
operator|<<
literal|4
expr_stmt|;
if|if
condition|(
name|c
condition|)
block|{
name|total
operator|+=
name|p
index|[
literal|3
index|]
operator|<<
literal|6
expr_stmt|;
block|}
block|}
comment|/* Ensure result is positive.  */
if|if
condition|(
name|total
operator|<
literal|0
condition|)
block|{
name|total
operator|+=
operator|(
literal|1000
operator|<<
literal|6
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|total
operator|%
name|HASHSIZE
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Initialize anything that needs initializing when starting to read    a fresh piece of a symbol file, e.g. reading in the stuff corresponding    to a psymtab.  */
end_comment

begin_function
name|void
name|buildsym_init
parameter_list|()
block|{
name|free_pendings
operator|=
name|NULL
expr_stmt|;
name|file_symbols
operator|=
name|NULL
expr_stmt|;
name|global_symbols
operator|=
name|NULL
expr_stmt|;
name|pending_blocks
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize anything that needs initializing when a completely new    symbol file is specified (not just adding some symbols from another    file, e.g. a shared library).  */
end_comment

begin_function
name|void
name|buildsym_new_init
parameter_list|()
block|{
name|buildsym_init
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initializer for this module */
end_comment

begin_function
name|void
name|_initialize_buildsym
parameter_list|()
block|{ }
end_function

end_unit

