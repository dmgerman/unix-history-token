begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Evaluate expressions for GDB.    Copyright 1986, 1987, 1989, 1991, 1992 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_comment
comment|/* For CAST_IS_CONVERSION */
end_comment

begin_comment
comment|/* Values of NOSIDE argument to eval_subexp.  */
end_comment

begin_enum
enum|enum
name|noside
block|{
name|EVAL_NORMAL
block|,
name|EVAL_SKIP
block|,
comment|/* Only effect is to increment pos.  */
name|EVAL_AVOID_SIDE_EFFECTS
comment|/* Don't modify any variables or 				   call any functions.  The value 				   returned will have the correct 				   type, and will have an 				   approximately correct lvalue 				   type (inaccuracy: anything that is 				   listed as being in a register in 				   the function in which it was 				   declared will be lval_register).  */
block|}
enum|;
end_enum

begin_comment
comment|/* Prototypes for local functions. */
end_comment

begin_decl_stmt
specifier|static
name|value
name|evaluate_subexp_for_sizeof
name|PARAMS
argument_list|(
operator|(
expr|struct
name|expression
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|value
name|evaluate_subexp_with_coercion
name|PARAMS
argument_list|(
operator|(
expr|struct
name|expression
operator|*
operator|,
name|int
operator|*
operator|,
expr|enum
name|noside
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|value
name|evaluate_subexp_for_address
name|PARAMS
argument_list|(
operator|(
expr|struct
name|expression
operator|*
operator|,
name|int
operator|*
operator|,
expr|enum
name|noside
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|value
name|evaluate_subexp
name|PARAMS
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|,
expr|struct
name|expression
operator|*
operator|,
name|int
operator|*
operator|,
expr|enum
name|noside
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Parse the string EXP as a C expression, evaluate it,    and return the result as a number.  */
end_comment

begin_function
name|CORE_ADDR
name|parse_and_eval_address
parameter_list|(
name|exp
parameter_list|)
name|char
modifier|*
name|exp
decl_stmt|;
block|{
name|struct
name|expression
modifier|*
name|expr
init|=
name|parse_expression
argument_list|(
name|exp
argument_list|)
decl_stmt|;
specifier|register
name|CORE_ADDR
name|addr
decl_stmt|;
specifier|register
name|struct
name|cleanup
modifier|*
name|old_chain
init|=
name|make_cleanup
argument_list|(
name|free_current_contents
argument_list|,
operator|&
name|expr
argument_list|)
decl_stmt|;
name|addr
operator|=
name|value_as_pointer
argument_list|(
name|evaluate_expression
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
name|addr
return|;
block|}
end_function

begin_comment
comment|/* Like parse_and_eval_address but takes a pointer to a char * variable    and advanced that variable across the characters parsed.  */
end_comment

begin_function
name|CORE_ADDR
name|parse_and_eval_address_1
parameter_list|(
name|expptr
parameter_list|)
name|char
modifier|*
modifier|*
name|expptr
decl_stmt|;
block|{
name|struct
name|expression
modifier|*
name|expr
init|=
name|parse_exp_1
argument_list|(
name|expptr
argument_list|,
operator|(
expr|struct
name|block
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|register
name|CORE_ADDR
name|addr
decl_stmt|;
specifier|register
name|struct
name|cleanup
modifier|*
name|old_chain
init|=
name|make_cleanup
argument_list|(
name|free_current_contents
argument_list|,
operator|&
name|expr
argument_list|)
decl_stmt|;
name|addr
operator|=
name|value_as_pointer
argument_list|(
name|evaluate_expression
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
name|addr
return|;
block|}
end_function

begin_function
name|value
name|parse_and_eval
parameter_list|(
name|exp
parameter_list|)
name|char
modifier|*
name|exp
decl_stmt|;
block|{
name|struct
name|expression
modifier|*
name|expr
init|=
name|parse_expression
argument_list|(
name|exp
argument_list|)
decl_stmt|;
specifier|register
name|value
name|val
decl_stmt|;
specifier|register
name|struct
name|cleanup
modifier|*
name|old_chain
init|=
name|make_cleanup
argument_list|(
name|free_current_contents
argument_list|,
operator|&
name|expr
argument_list|)
decl_stmt|;
name|val
operator|=
name|evaluate_expression
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Parse up to a comma (or to a closeparen)    in the string EXPP as an expression, evaluate it, and return the value.    EXPP is advanced to point to the comma.  */
end_comment

begin_function
name|value
name|parse_to_comma_and_eval
parameter_list|(
name|expp
parameter_list|)
name|char
modifier|*
modifier|*
name|expp
decl_stmt|;
block|{
name|struct
name|expression
modifier|*
name|expr
init|=
name|parse_exp_1
argument_list|(
name|expp
argument_list|,
operator|(
expr|struct
name|block
operator|*
operator|)
literal|0
argument_list|,
literal|1
argument_list|)
decl_stmt|;
specifier|register
name|value
name|val
decl_stmt|;
specifier|register
name|struct
name|cleanup
modifier|*
name|old_chain
init|=
name|make_cleanup
argument_list|(
name|free_current_contents
argument_list|,
operator|&
name|expr
argument_list|)
decl_stmt|;
name|val
operator|=
name|evaluate_expression
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Evaluate an expression in internal prefix form    such as is constructed by parse.y.     See expression.h for info on the format of an expression.  */
end_comment

begin_function_decl
specifier|static
name|value
name|evaluate_subexp
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|value
name|evaluate_subexp_for_address
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|value
name|evaluate_subexp_for_sizeof
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|value
name|evaluate_subexp_with_coercion
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|value
name|evaluate_expression
parameter_list|(
name|exp
parameter_list|)
name|struct
name|expression
modifier|*
name|exp
decl_stmt|;
block|{
name|int
name|pc
init|=
literal|0
decl_stmt|;
return|return
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
operator|&
name|pc
argument_list|,
name|EVAL_NORMAL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Evaluate an expression, avoiding all memory references    and getting a value whose type alone is correct.  */
end_comment

begin_function
name|value
name|evaluate_type
parameter_list|(
name|exp
parameter_list|)
name|struct
name|expression
modifier|*
name|exp
decl_stmt|;
block|{
name|int
name|pc
init|=
literal|0
decl_stmt|;
return|return
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
operator|&
name|pc
argument_list|,
name|EVAL_AVOID_SIDE_EFFECTS
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|value
name|evaluate_subexp
parameter_list|(
name|expect_type
parameter_list|,
name|exp
parameter_list|,
name|pos
parameter_list|,
name|noside
parameter_list|)
name|struct
name|type
modifier|*
name|expect_type
decl_stmt|;
specifier|register
name|struct
name|expression
modifier|*
name|exp
decl_stmt|;
specifier|register
name|int
modifier|*
name|pos
decl_stmt|;
name|enum
name|noside
name|noside
decl_stmt|;
block|{
name|enum
name|exp_opcode
name|op
decl_stmt|;
name|int
name|tem
decl_stmt|,
name|tem2
decl_stmt|,
name|tem3
decl_stmt|;
specifier|register
name|int
name|pc
decl_stmt|,
name|pc2
init|=
literal|0
decl_stmt|,
name|oldpos
decl_stmt|;
specifier|register
name|value
name|arg1
init|=
name|NULL
decl_stmt|,
name|arg2
init|=
name|NULL
decl_stmt|,
name|arg3
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|int
name|nargs
decl_stmt|;
name|value
modifier|*
name|argvec
decl_stmt|;
name|pc
operator|=
operator|(
operator|*
name|pos
operator|)
operator|++
expr_stmt|;
name|op
operator|=
name|exp
operator|->
name|elts
index|[
name|pc
index|]
operator|.
name|opcode
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|OP_SCOPE
case|:
name|tem
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|4
operator|+
name|BYTES_TO_EXP_ELEM
argument_list|(
name|tem
operator|+
literal|1
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|value_struct_elt_for_reference
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|type
argument_list|,
literal|0
argument_list|,
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|type
argument_list|,
operator|&
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|3
index|]
operator|.
name|string
argument_list|,
name|expect_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg1
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"There is no field named %s"
argument_list|,
operator|&
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|3
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
return|return
name|arg1
return|;
case|case
name|OP_LONG
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|3
expr_stmt|;
return|return
name|value_from_longest
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|type
argument_list|,
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|longconst
argument_list|)
return|;
case|case
name|OP_DOUBLE
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|3
expr_stmt|;
return|return
name|value_from_double
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|type
argument_list|,
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|doubleconst
argument_list|)
return|;
case|case
name|OP_VAR_VALUE
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|noside
operator|==
name|EVAL_AVOID_SIDE_EFFECTS
condition|)
block|{
name|struct
name|symbol
modifier|*
name|sym
init|=
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|symbol
decl_stmt|;
name|enum
name|lval_type
name|lv
decl_stmt|;
switch|switch
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
condition|)
block|{
case|case
name|LOC_CONST
case|:
case|case
name|LOC_LABEL
case|:
case|case
name|LOC_CONST_BYTES
case|:
name|lv
operator|=
name|not_lval
expr_stmt|;
break|break;
case|case
name|LOC_REGISTER
case|:
case|case
name|LOC_REGPARM
case|:
name|lv
operator|=
name|lval_register
expr_stmt|;
break|break;
default|default:
name|lv
operator|=
name|lval_memory
expr_stmt|;
break|break;
block|}
return|return
name|value_zero
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|,
name|lv
argument_list|)
return|;
block|}
else|else
return|return
name|value_of_variable
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|symbol
argument_list|,
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|block
argument_list|)
return|;
case|case
name|OP_LAST
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|2
expr_stmt|;
return|return
name|access_value_history
argument_list|(
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
argument_list|)
return|;
case|case
name|OP_REGISTER
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|2
expr_stmt|;
return|return
name|value_of_register
argument_list|(
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
argument_list|)
return|;
case|case
name|OP_BOOL
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|2
expr_stmt|;
return|return
name|value_from_longest
argument_list|(
name|builtin_type_chill_bool
argument_list|,
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
return|;
case|case
name|OP_INTERNALVAR
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|2
expr_stmt|;
return|return
name|value_of_internalvar
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|internalvar
argument_list|)
return|;
case|case
name|OP_STRING
case|:
name|tem
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|3
operator|+
name|BYTES_TO_EXP_ELEM
argument_list|(
name|tem
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
return|return
name|value_string
argument_list|(
operator|&
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|string
argument_list|,
name|tem
argument_list|)
return|;
case|case
name|OP_BITSTRING
case|:
name|error
argument_list|(
literal|"support for OP_BITSTRING unimplemented"
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_ARRAY
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|3
expr_stmt|;
name|tem2
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
name|tem3
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
name|nargs
operator|=
name|tem3
operator|-
name|tem2
operator|+
literal|1
expr_stmt|;
name|argvec
operator|=
operator|(
name|value
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|value
argument_list|)
operator|*
name|nargs
argument_list|)
expr_stmt|;
for|for
control|(
name|tem
operator|=
literal|0
init|;
name|tem
operator|<
name|nargs
condition|;
name|tem
operator|++
control|)
block|{
comment|/* Ensure that array expressions are coerced into pointer objects. */
name|argvec
index|[
name|tem
index|]
operator|=
name|evaluate_subexp_with_coercion
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
return|return
operator|(
name|value_array
argument_list|(
name|tem2
argument_list|,
name|tem3
argument_list|,
name|argvec
argument_list|)
operator|)
return|;
break|break;
case|case
name|TERNOP_COND
case|:
comment|/* Skip third and second args to evaluate the first one.  */
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|value_logical_not
argument_list|(
name|arg1
argument_list|)
condition|)
block|{
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|EVAL_SKIP
argument_list|)
expr_stmt|;
return|return
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
return|;
block|}
else|else
block|{
name|arg2
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|EVAL_SKIP
argument_list|)
expr_stmt|;
return|return
name|arg2
return|;
block|}
case|case
name|OP_FUNCALL
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|2
expr_stmt|;
name|op
operator|=
name|exp
operator|->
name|elts
index|[
operator|*
name|pos
index|]
operator|.
name|opcode
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|STRUCTOP_MEMBER
operator|||
name|op
operator|==
name|STRUCTOP_MPTR
condition|)
block|{
name|int
name|fnptr
decl_stmt|;
name|nargs
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* First, evaluate the structure into arg2 */
name|pc2
operator|=
operator|(
operator|*
name|pos
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|op
operator|==
name|STRUCTOP_MEMBER
condition|)
block|{
name|arg2
operator|=
name|evaluate_subexp_for_address
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arg2
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
block|}
comment|/* If the function is a virtual function, then the 	     aggregate value (providing the structure) plays 	     its part by providing the vtable.  Otherwise, 	     it is just along for the ride: call the function 	     directly.  */
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|fnptr
operator|=
name|longest_to_int
argument_list|(
name|value_as_long
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|METHOD_PTR_IS_VIRTUAL
argument_list|(
name|fnptr
argument_list|)
condition|)
block|{
name|int
name|fnoffset
init|=
name|METHOD_PTR_TO_VOFFSET
argument_list|(
name|fnptr
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|basetype
decl_stmt|;
name|struct
name|type
modifier|*
name|domain_type
init|=
name|TYPE_DOMAIN_TYPE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|basetype
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|domain_type
operator|!=
name|basetype
condition|)
name|arg2
operator|=
name|value_cast
argument_list|(
name|lookup_pointer_type
argument_list|(
name|domain_type
argument_list|)
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
name|basetype
operator|=
name|TYPE_VPTR_BASETYPE
argument_list|(
name|domain_type
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|TYPE_NFN_FIELDS
argument_list|(
name|basetype
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|struct
name|fn_field
modifier|*
name|f
init|=
name|TYPE_FN_FIELDLIST1
argument_list|(
name|basetype
argument_list|,
name|i
argument_list|)
decl_stmt|;
comment|/* If one is virtual, then all are virtual.  */
if|if
condition|(
name|TYPE_FN_FIELD_VIRTUAL_P
argument_list|(
name|f
argument_list|,
literal|0
argument_list|)
condition|)
for|for
control|(
name|j
operator|=
name|TYPE_FN_FIELDLIST_LENGTH
argument_list|(
name|basetype
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
operator|--
name|j
control|)
if|if
condition|(
name|TYPE_FN_FIELD_VOFFSET
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
operator|==
name|fnoffset
condition|)
block|{
name|value
name|temp
init|=
name|value_ind
argument_list|(
name|arg2
argument_list|)
decl_stmt|;
name|arg1
operator|=
name|value_virtual_fn_field
argument_list|(
operator|&
name|temp
argument_list|,
name|f
argument_list|,
name|j
argument_list|,
name|domain_type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|value_addr
argument_list|(
name|temp
argument_list|)
expr_stmt|;
goto|goto
name|got_it
goto|;
block|}
block|}
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"virtual function at index %d not found"
argument_list|,
name|fnoffset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
operator|=
name|lookup_pointer_type
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|got_it
label|:
comment|/* Now, say which argument to start evaluating from */
name|tem
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
name|STRUCTOP_STRUCT
operator|||
name|op
operator|==
name|STRUCTOP_PTR
condition|)
block|{
comment|/* Hair for method invocations */
name|int
name|tem2
decl_stmt|;
name|nargs
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* First, evaluate the structure into arg2 */
name|pc2
operator|=
operator|(
operator|*
name|pos
operator|)
operator|++
expr_stmt|;
name|tem2
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc2
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
operator|*
name|pos
operator|+=
literal|3
operator|+
name|BYTES_TO_EXP_ELEM
argument_list|(
name|tem2
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|op
operator|==
name|STRUCTOP_STRUCT
condition|)
block|{
comment|/* If v is a variable in a register, and the user types 		 v.method (), this will produce an error, because v has 		 no address.  		 A possible way around this would be to allocate a 		 copy of the variable on the stack, copy in the 		 contents, call the function, and copy out the 		 contents.  I.e. convert this from call by reference 		 to call by copy-return (or whatever it's called). 		 However, this does not work because it is not the 		 same: the method being called could stash a copy of 		 the address, and then future uses through that address 		 (after the method returns) would be expected to 		 use the variable itself, not some copy of it.  */
name|arg2
operator|=
name|evaluate_subexp_for_address
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arg2
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
block|}
comment|/* Now, say which argument to start evaluating from */
name|tem
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|nargs
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
name|tem
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Allocate arg vector, including space for the function to be 	 called in argvec[0] and a terminating NULL */
name|argvec
operator|=
operator|(
name|value
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|value
argument_list|)
operator|*
operator|(
name|nargs
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|tem
operator|<=
name|nargs
condition|;
name|tem
operator|++
control|)
comment|/* Ensure that array expressions are coerced into pointer objects. */
name|argvec
index|[
name|tem
index|]
operator|=
name|evaluate_subexp_with_coercion
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
comment|/* signal end of arglist */
name|argvec
index|[
name|tem
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|STRUCTOP_STRUCT
operator|||
name|op
operator|==
name|STRUCTOP_PTR
condition|)
block|{
name|int
name|static_memfuncp
decl_stmt|;
name|value
name|temp
init|=
name|arg2
decl_stmt|;
name|argvec
index|[
literal|1
index|]
operator|=
name|arg2
expr_stmt|;
name|argvec
index|[
literal|0
index|]
operator|=
name|value_struct_elt
argument_list|(
operator|&
name|temp
argument_list|,
name|argvec
operator|+
literal|1
argument_list|,
operator|&
name|exp
operator|->
name|elts
index|[
name|pc2
operator|+
literal|2
index|]
operator|.
name|string
argument_list|,
operator|&
name|static_memfuncp
argument_list|,
name|op
operator|==
name|STRUCTOP_STRUCT
condition|?
literal|"structure"
else|:
literal|"structure pointer"
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|value_from_longest
argument_list|(
name|lookup_pointer_type
argument_list|(
name|VALUE_TYPE
argument_list|(
name|temp
argument_list|)
argument_list|)
argument_list|,
name|VALUE_ADDRESS
argument_list|(
name|temp
argument_list|)
operator|+
name|VALUE_OFFSET
argument_list|(
name|temp
argument_list|)
argument_list|)
expr_stmt|;
name|argvec
index|[
literal|1
index|]
operator|=
name|arg2
expr_stmt|;
if|if
condition|(
name|static_memfuncp
condition|)
block|{
name|argvec
index|[
literal|1
index|]
operator|=
name|argvec
index|[
literal|0
index|]
expr_stmt|;
name|nargs
operator|--
expr_stmt|;
name|argvec
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|op
operator|==
name|STRUCTOP_MEMBER
operator|||
name|op
operator|==
name|STRUCTOP_MPTR
condition|)
block|{
name|argvec
index|[
literal|1
index|]
operator|=
name|arg2
expr_stmt|;
name|argvec
index|[
literal|0
index|]
operator|=
name|arg1
expr_stmt|;
block|}
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|noside
operator|==
name|EVAL_AVOID_SIDE_EFFECTS
condition|)
block|{
comment|/* If the return type doesn't look like a function type, call an 	     error.  This can happen if somebody tries to turn a variable into 	     a function call. This is here because people often want to 	     call, eg, strcmp, which gdb doesn't know is a function.  If 	     gdb isn't asked for it's opinion (ie. through "whatis"), 	     it won't offer it. */
name|struct
name|type
modifier|*
name|ftype
init|=
name|TYPE_TARGET_TYPE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|argvec
index|[
literal|0
index|]
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|ftype
condition|)
return|return
name|allocate_value
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|argvec
index|[
literal|0
index|]
argument_list|)
argument_list|)
argument_list|)
return|;
else|else
name|error
argument_list|(
literal|"Expression of type other than \"Function returning ...\" used as function"
argument_list|)
expr_stmt|;
block|}
return|return
name|call_function_by_hand
argument_list|(
name|argvec
index|[
literal|0
index|]
argument_list|,
name|nargs
argument_list|,
name|argvec
operator|+
literal|1
argument_list|)
return|;
case|case
name|STRUCTOP_STRUCT
case|:
name|tem
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|3
operator|+
name|BYTES_TO_EXP_ELEM
argument_list|(
name|tem
operator|+
literal|1
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|noside
operator|==
name|EVAL_AVOID_SIDE_EFFECTS
condition|)
return|return
name|value_zero
argument_list|(
name|lookup_struct_elt_type
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
operator|&
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|string
argument_list|,
literal|0
argument_list|)
argument_list|,
name|lval_memory
argument_list|)
return|;
else|else
block|{
name|value
name|temp
init|=
name|arg1
decl_stmt|;
return|return
name|value_struct_elt
argument_list|(
operator|&
name|temp
argument_list|,
operator|(
name|value
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|string
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|,
literal|"structure"
argument_list|)
return|;
block|}
case|case
name|STRUCTOP_PTR
case|:
name|tem
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|3
operator|+
name|BYTES_TO_EXP_ELEM
argument_list|(
name|tem
operator|+
literal|1
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|noside
operator|==
name|EVAL_AVOID_SIDE_EFFECTS
condition|)
return|return
name|value_zero
argument_list|(
name|lookup_struct_elt_type
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
operator|&
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|string
argument_list|,
literal|0
argument_list|)
argument_list|,
name|lval_memory
argument_list|)
return|;
else|else
block|{
name|value
name|temp
init|=
name|arg1
decl_stmt|;
return|return
name|value_struct_elt
argument_list|(
operator|&
name|temp
argument_list|,
operator|(
name|value
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|string
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|,
literal|"structure pointer"
argument_list|)
return|;
block|}
case|case
name|STRUCTOP_MEMBER
case|:
name|arg1
operator|=
name|evaluate_subexp_for_address
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
goto|goto
name|handle_pointer_to_member
goto|;
case|case
name|STRUCTOP_MPTR
case|:
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|handle_pointer_to_member
label|:
name|arg2
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_PTR
condition|)
goto|goto
name|bad_pointer_to_member
goto|;
name|type
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_METHOD
condition|)
name|error
argument_list|(
literal|"not implemented: pointer-to-method in pointer-to-member construct"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_CODE_MEMBER
condition|)
goto|goto
name|bad_pointer_to_member
goto|;
comment|/* Now, convert these values to an address.  */
name|arg1
operator|=
name|value_cast
argument_list|(
name|lookup_pointer_type
argument_list|(
name|TYPE_DOMAIN_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
name|arg3
operator|=
name|value_from_longest
argument_list|(
name|lookup_pointer_type
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|value_as_long
argument_list|(
name|arg1
argument_list|)
operator|+
name|value_as_long
argument_list|(
name|arg2
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|value_ind
argument_list|(
name|arg3
argument_list|)
return|;
name|bad_pointer_to_member
label|:
name|error
argument_list|(
literal|"non-pointer-to-member value used in pointer-to-member construct"
argument_list|)
expr_stmt|;
case|case
name|BINOP_CONCAT
case|:
name|arg1
operator|=
name|evaluate_subexp_with_coercion
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|evaluate_subexp_with_coercion
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|binop_user_defined_p
argument_list|(
name|op
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
condition|)
return|return
name|value_x_binop
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
name|op
argument_list|,
name|OP_NULL
argument_list|)
return|;
else|else
return|return
name|value_concat
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
return|;
case|case
name|BINOP_ASSIGN
case|:
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|evaluate_subexp
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
operator|||
name|noside
operator|==
name|EVAL_AVOID_SIDE_EFFECTS
condition|)
return|return
name|arg1
return|;
if|if
condition|(
name|binop_user_defined_p
argument_list|(
name|op
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
condition|)
return|return
name|value_x_binop
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
name|op
argument_list|,
name|OP_NULL
argument_list|)
return|;
else|else
return|return
name|value_assign
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
return|;
case|case
name|BINOP_ASSIGN_MODIFY
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|2
expr_stmt|;
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|evaluate_subexp
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
operator|||
name|noside
operator|==
name|EVAL_AVOID_SIDE_EFFECTS
condition|)
return|return
name|arg1
return|;
name|op
operator|=
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|opcode
expr_stmt|;
if|if
condition|(
name|binop_user_defined_p
argument_list|(
name|op
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
condition|)
return|return
name|value_x_binop
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
name|BINOP_ASSIGN_MODIFY
argument_list|,
name|op
argument_list|)
return|;
elseif|else
if|if
condition|(
name|op
operator|==
name|BINOP_ADD
condition|)
name|arg2
operator|=
name|value_add
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|op
operator|==
name|BINOP_SUB
condition|)
name|arg2
operator|=
name|value_sub
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
else|else
name|arg2
operator|=
name|value_binop
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
name|op
argument_list|)
expr_stmt|;
return|return
name|value_assign
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
return|;
case|case
name|BINOP_ADD
case|:
name|arg1
operator|=
name|evaluate_subexp_with_coercion
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|evaluate_subexp_with_coercion
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|binop_user_defined_p
argument_list|(
name|op
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
condition|)
return|return
name|value_x_binop
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
name|op
argument_list|,
name|OP_NULL
argument_list|)
return|;
else|else
return|return
name|value_add
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
return|;
case|case
name|BINOP_SUB
case|:
name|arg1
operator|=
name|evaluate_subexp_with_coercion
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|evaluate_subexp_with_coercion
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|binop_user_defined_p
argument_list|(
name|op
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
condition|)
return|return
name|value_x_binop
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
name|op
argument_list|,
name|OP_NULL
argument_list|)
return|;
else|else
return|return
name|value_sub
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
return|;
case|case
name|BINOP_MUL
case|:
case|case
name|BINOP_DIV
case|:
case|case
name|BINOP_REM
case|:
case|case
name|BINOP_MOD
case|:
case|case
name|BINOP_LSH
case|:
case|case
name|BINOP_RSH
case|:
case|case
name|BINOP_BITWISE_AND
case|:
case|case
name|BINOP_BITWISE_IOR
case|:
case|case
name|BINOP_BITWISE_XOR
case|:
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|binop_user_defined_p
argument_list|(
name|op
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
condition|)
return|return
name|value_x_binop
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
name|op
argument_list|,
name|OP_NULL
argument_list|)
return|;
elseif|else
if|if
condition|(
name|noside
operator|==
name|EVAL_AVOID_SIDE_EFFECTS
operator|&&
operator|(
name|op
operator|==
name|BINOP_DIV
operator|||
name|op
operator|==
name|BINOP_REM
operator|||
name|op
operator|==
name|BINOP_MOD
operator|)
condition|)
return|return
name|value_zero
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|not_lval
argument_list|)
return|;
else|else
return|return
name|value_binop
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
name|op
argument_list|)
return|;
case|case
name|BINOP_SUBSCRIPT
case|:
name|arg1
operator|=
name|evaluate_subexp_with_coercion
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|evaluate_subexp_with_coercion
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|noside
operator|==
name|EVAL_AVOID_SIDE_EFFECTS
condition|)
block|{
comment|/* If the user attempts to subscript something that has no target 	     type (like a plain int variable for example), then report this 	     as an error. */
name|type
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
condition|)
return|return
name|value_zero
argument_list|(
name|type
argument_list|,
name|VALUE_LVAL
argument_list|(
name|arg1
argument_list|)
argument_list|)
return|;
else|else
name|error
argument_list|(
literal|"cannot subscript something of type `%s'"
argument_list|,
name|TYPE_NAME
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|binop_user_defined_p
argument_list|(
name|op
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
condition|)
return|return
name|value_x_binop
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
name|op
argument_list|,
name|OP_NULL
argument_list|)
return|;
else|else
return|return
name|value_subscript
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
return|;
case|case
name|MULTI_SUBSCRIPT
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|2
expr_stmt|;
name|nargs
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|evaluate_subexp_with_coercion
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
while|while
condition|(
name|nargs
operator|--
operator|>
literal|0
condition|)
block|{
name|arg2
operator|=
name|evaluate_subexp_with_coercion
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
comment|/* FIXME:  EVAL_SKIP handling may not be correct. */
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
block|{
if|if
condition|(
name|nargs
operator|>
literal|0
condition|)
block|{
continue|continue;
block|}
else|else
block|{
goto|goto
name|nosideret
goto|;
block|}
block|}
comment|/* FIXME:  EVAL_AVOID_SIDE_EFFECTS handling may not be correct. */
if|if
condition|(
name|noside
operator|==
name|EVAL_AVOID_SIDE_EFFECTS
condition|)
block|{
comment|/* If the user attempts to subscript something that has no target 		 type (like a plain int variable for example), then report this 		 as an error. */
name|type
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|NULL
condition|)
block|{
name|arg1
operator|=
name|value_zero
argument_list|(
name|type
argument_list|,
name|VALUE_LVAL
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
name|noside
operator|=
name|EVAL_SKIP
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|error
argument_list|(
literal|"cannot subscript something of type `%s'"
argument_list|,
name|TYPE_NAME
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|binop_user_defined_p
argument_list|(
name|op
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
condition|)
block|{
name|arg1
operator|=
name|value_x_binop
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
name|op
argument_list|,
name|OP_NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arg1
operator|=
name|value_subscript
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|arg1
operator|)
return|;
case|case
name|BINOP_LOGICAL_AND
case|:
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
block|{
name|arg2
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
goto|goto
name|nosideret
goto|;
block|}
name|oldpos
operator|=
operator|*
name|pos
expr_stmt|;
name|arg2
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|EVAL_AVOID_SIDE_EFFECTS
argument_list|)
expr_stmt|;
operator|*
name|pos
operator|=
name|oldpos
expr_stmt|;
if|if
condition|(
name|binop_user_defined_p
argument_list|(
name|op
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
condition|)
block|{
name|arg2
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
return|return
name|value_x_binop
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
name|op
argument_list|,
name|OP_NULL
argument_list|)
return|;
block|}
else|else
block|{
name|tem
operator|=
name|value_logical_not
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
operator|(
name|tem
condition|?
name|EVAL_SKIP
else|:
name|noside
operator|)
argument_list|)
expr_stmt|;
return|return
name|value_from_longest
argument_list|(
name|builtin_type_int
argument_list|,
call|(
name|LONGEST
call|)
argument_list|(
operator|!
name|tem
operator|&&
operator|!
name|value_logical_not
argument_list|(
name|arg2
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
case|case
name|BINOP_LOGICAL_OR
case|:
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
block|{
name|arg2
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
goto|goto
name|nosideret
goto|;
block|}
name|oldpos
operator|=
operator|*
name|pos
expr_stmt|;
name|arg2
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|EVAL_AVOID_SIDE_EFFECTS
argument_list|)
expr_stmt|;
operator|*
name|pos
operator|=
name|oldpos
expr_stmt|;
if|if
condition|(
name|binop_user_defined_p
argument_list|(
name|op
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
condition|)
block|{
name|arg2
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
return|return
name|value_x_binop
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
name|op
argument_list|,
name|OP_NULL
argument_list|)
return|;
block|}
else|else
block|{
name|tem
operator|=
name|value_logical_not
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
operator|(
operator|!
name|tem
condition|?
name|EVAL_SKIP
else|:
name|noside
operator|)
argument_list|)
expr_stmt|;
return|return
name|value_from_longest
argument_list|(
name|builtin_type_int
argument_list|,
call|(
name|LONGEST
call|)
argument_list|(
operator|!
name|tem
operator|||
operator|!
name|value_logical_not
argument_list|(
name|arg2
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
case|case
name|BINOP_EQUAL
case|:
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|evaluate_subexp
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|binop_user_defined_p
argument_list|(
name|op
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
condition|)
block|{
return|return
name|value_x_binop
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
name|op
argument_list|,
name|OP_NULL
argument_list|)
return|;
block|}
else|else
block|{
name|tem
operator|=
name|value_equal
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
return|return
name|value_from_longest
argument_list|(
name|builtin_type_int
argument_list|,
operator|(
name|LONGEST
operator|)
name|tem
argument_list|)
return|;
block|}
case|case
name|BINOP_NOTEQUAL
case|:
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|evaluate_subexp
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|binop_user_defined_p
argument_list|(
name|op
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
condition|)
block|{
return|return
name|value_x_binop
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
name|op
argument_list|,
name|OP_NULL
argument_list|)
return|;
block|}
else|else
block|{
name|tem
operator|=
name|value_equal
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
return|return
name|value_from_longest
argument_list|(
name|builtin_type_int
argument_list|,
operator|(
name|LONGEST
operator|)
operator|!
name|tem
argument_list|)
return|;
block|}
case|case
name|BINOP_LESS
case|:
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|evaluate_subexp
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|binop_user_defined_p
argument_list|(
name|op
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
condition|)
block|{
return|return
name|value_x_binop
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
name|op
argument_list|,
name|OP_NULL
argument_list|)
return|;
block|}
else|else
block|{
name|tem
operator|=
name|value_less
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
return|return
name|value_from_longest
argument_list|(
name|builtin_type_int
argument_list|,
operator|(
name|LONGEST
operator|)
name|tem
argument_list|)
return|;
block|}
case|case
name|BINOP_GTR
case|:
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|evaluate_subexp
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|binop_user_defined_p
argument_list|(
name|op
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
condition|)
block|{
return|return
name|value_x_binop
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
name|op
argument_list|,
name|OP_NULL
argument_list|)
return|;
block|}
else|else
block|{
name|tem
operator|=
name|value_less
argument_list|(
name|arg2
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
return|return
name|value_from_longest
argument_list|(
name|builtin_type_int
argument_list|,
operator|(
name|LONGEST
operator|)
name|tem
argument_list|)
return|;
block|}
case|case
name|BINOP_GEQ
case|:
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|evaluate_subexp
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|binop_user_defined_p
argument_list|(
name|op
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
condition|)
block|{
return|return
name|value_x_binop
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
name|op
argument_list|,
name|OP_NULL
argument_list|)
return|;
block|}
else|else
block|{
name|tem
operator|=
name|value_less
argument_list|(
name|arg2
argument_list|,
name|arg1
argument_list|)
operator|||
name|value_equal
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
return|return
name|value_from_longest
argument_list|(
name|builtin_type_int
argument_list|,
operator|(
name|LONGEST
operator|)
name|tem
argument_list|)
return|;
block|}
case|case
name|BINOP_LEQ
case|:
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|evaluate_subexp
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|binop_user_defined_p
argument_list|(
name|op
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
condition|)
block|{
return|return
name|value_x_binop
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
name|op
argument_list|,
name|OP_NULL
argument_list|)
return|;
block|}
else|else
block|{
name|tem
operator|=
name|value_less
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
operator|||
name|value_equal
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
return|return
name|value_from_longest
argument_list|(
name|builtin_type_int
argument_list|,
operator|(
name|LONGEST
operator|)
name|tem
argument_list|)
return|;
block|}
case|case
name|BINOP_REPEAT
case|:
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_INT
condition|)
name|error
argument_list|(
literal|"Non-integral right operand for \"@\" operator."
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_AVOID_SIDE_EFFECTS
condition|)
return|return
name|allocate_repeat_value
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|longest_to_int
argument_list|(
name|value_as_long
argument_list|(
name|arg2
argument_list|)
argument_list|)
argument_list|)
return|;
else|else
return|return
name|value_repeat
argument_list|(
name|arg1
argument_list|,
name|longest_to_int
argument_list|(
name|value_as_long
argument_list|(
name|arg2
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|BINOP_COMMA
case|:
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
return|return
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
return|;
case|case
name|UNOP_NEG
case|:
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|unop_user_defined_p
argument_list|(
name|op
argument_list|,
name|arg1
argument_list|)
condition|)
return|return
name|value_x_unop
argument_list|(
name|arg1
argument_list|,
name|op
argument_list|)
return|;
else|else
return|return
name|value_neg
argument_list|(
name|arg1
argument_list|)
return|;
case|case
name|UNOP_COMPLEMENT
case|:
comment|/* C++: check for and handle destructor names.  */
name|op
operator|=
name|exp
operator|->
name|elts
index|[
operator|*
name|pos
index|]
operator|.
name|opcode
expr_stmt|;
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|unop_user_defined_p
argument_list|(
name|UNOP_COMPLEMENT
argument_list|,
name|arg1
argument_list|)
condition|)
return|return
name|value_x_unop
argument_list|(
name|arg1
argument_list|,
name|UNOP_COMPLEMENT
argument_list|)
return|;
else|else
return|return
name|value_complement
argument_list|(
name|arg1
argument_list|)
return|;
case|case
name|UNOP_LOGICAL_NOT
case|:
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|unop_user_defined_p
argument_list|(
name|op
argument_list|,
name|arg1
argument_list|)
condition|)
return|return
name|value_x_unop
argument_list|(
name|arg1
argument_list|,
name|op
argument_list|)
return|;
else|else
return|return
name|value_from_longest
argument_list|(
name|builtin_type_int
argument_list|,
operator|(
name|LONGEST
operator|)
name|value_logical_not
argument_list|(
name|arg1
argument_list|)
argument_list|)
return|;
case|case
name|UNOP_IND
case|:
if|if
condition|(
name|expect_type
operator|&&
name|TYPE_CODE
argument_list|(
name|expect_type
argument_list|)
operator|==
name|TYPE_CODE_PTR
condition|)
name|expect_type
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|expect_type
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|expect_type
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|noside
operator|==
name|EVAL_AVOID_SIDE_EFFECTS
condition|)
block|{
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_PTR
operator|||
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_REF
comment|/* In C you can dereference an array to get the 1st elt.  */
operator|||
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_ARRAY
condition|)
return|return
name|value_zero
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|,
name|lval_memory
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_INT
condition|)
comment|/* GDB allows dereferencing an int.  */
return|return
name|value_zero
argument_list|(
name|builtin_type_int
argument_list|,
name|lval_memory
argument_list|)
return|;
else|else
name|error
argument_list|(
literal|"Attempt to take contents of a non-pointer value."
argument_list|)
expr_stmt|;
block|}
return|return
name|value_ind
argument_list|(
name|arg1
argument_list|)
return|;
case|case
name|UNOP_ADDR
case|:
comment|/* C++: check for and handle pointer to members.  */
name|op
operator|=
name|exp
operator|->
name|elts
index|[
operator|*
name|pos
index|]
operator|.
name|opcode
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
block|{
if|if
condition|(
name|op
operator|==
name|OP_SCOPE
condition|)
block|{
name|int
name|temm
init|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|3
index|]
operator|.
name|longconst
argument_list|)
decl_stmt|;
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|3
operator|+
name|BYTES_TO_EXP_ELEM
argument_list|(
name|temm
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|evaluate_subexp
argument_list|(
name|expect_type
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|EVAL_SKIP
argument_list|)
expr_stmt|;
goto|goto
name|nosideret
goto|;
block|}
return|return
name|evaluate_subexp_for_address
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
return|;
case|case
name|UNOP_SIZEOF
case|:
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
block|{
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|EVAL_SKIP
argument_list|)
expr_stmt|;
goto|goto
name|nosideret
goto|;
block|}
return|return
name|evaluate_subexp_for_sizeof
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|)
return|;
case|case
name|UNOP_CAST
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|2
expr_stmt|;
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|expect_type
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
return|return
name|value_cast
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|type
argument_list|,
name|arg1
argument_list|)
return|;
case|case
name|UNOP_MEMVAL
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|2
expr_stmt|;
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|expect_type
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
if|if
condition|(
name|noside
operator|==
name|EVAL_AVOID_SIDE_EFFECTS
condition|)
return|return
name|value_zero
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|type
argument_list|,
name|lval_memory
argument_list|)
return|;
else|else
return|return
name|value_at_lazy
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|type
argument_list|,
name|value_as_pointer
argument_list|(
name|arg1
argument_list|)
argument_list|)
return|;
case|case
name|UNOP_PREINCREMENT
case|:
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|expect_type
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
operator|||
name|noside
operator|==
name|EVAL_AVOID_SIDE_EFFECTS
condition|)
return|return
name|arg1
return|;
elseif|else
if|if
condition|(
name|unop_user_defined_p
argument_list|(
name|op
argument_list|,
name|arg1
argument_list|)
condition|)
block|{
return|return
name|value_x_unop
argument_list|(
name|arg1
argument_list|,
name|op
argument_list|)
return|;
block|}
else|else
block|{
name|arg2
operator|=
name|value_add
argument_list|(
name|arg1
argument_list|,
name|value_from_longest
argument_list|(
name|builtin_type_char
argument_list|,
operator|(
name|LONGEST
operator|)
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|value_assign
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
return|;
block|}
case|case
name|UNOP_PREDECREMENT
case|:
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|expect_type
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
operator|||
name|noside
operator|==
name|EVAL_AVOID_SIDE_EFFECTS
condition|)
return|return
name|arg1
return|;
elseif|else
if|if
condition|(
name|unop_user_defined_p
argument_list|(
name|op
argument_list|,
name|arg1
argument_list|)
condition|)
block|{
return|return
name|value_x_unop
argument_list|(
name|arg1
argument_list|,
name|op
argument_list|)
return|;
block|}
else|else
block|{
name|arg2
operator|=
name|value_sub
argument_list|(
name|arg1
argument_list|,
name|value_from_longest
argument_list|(
name|builtin_type_char
argument_list|,
operator|(
name|LONGEST
operator|)
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|value_assign
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
return|;
block|}
case|case
name|UNOP_POSTINCREMENT
case|:
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|expect_type
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
operator|||
name|noside
operator|==
name|EVAL_AVOID_SIDE_EFFECTS
condition|)
return|return
name|arg1
return|;
elseif|else
if|if
condition|(
name|unop_user_defined_p
argument_list|(
name|op
argument_list|,
name|arg1
argument_list|)
condition|)
block|{
return|return
name|value_x_unop
argument_list|(
name|arg1
argument_list|,
name|op
argument_list|)
return|;
block|}
else|else
block|{
name|arg2
operator|=
name|value_add
argument_list|(
name|arg1
argument_list|,
name|value_from_longest
argument_list|(
name|builtin_type_char
argument_list|,
operator|(
name|LONGEST
operator|)
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|value_assign
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
return|return
name|arg1
return|;
block|}
case|case
name|UNOP_POSTDECREMENT
case|:
name|arg1
operator|=
name|evaluate_subexp
argument_list|(
name|expect_type
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
operator|||
name|noside
operator|==
name|EVAL_AVOID_SIDE_EFFECTS
condition|)
return|return
name|arg1
return|;
elseif|else
if|if
condition|(
name|unop_user_defined_p
argument_list|(
name|op
argument_list|,
name|arg1
argument_list|)
condition|)
block|{
return|return
name|value_x_unop
argument_list|(
name|arg1
argument_list|,
name|op
argument_list|)
return|;
block|}
else|else
block|{
name|arg2
operator|=
name|value_sub
argument_list|(
name|arg1
argument_list|,
name|value_from_longest
argument_list|(
name|builtin_type_char
argument_list|,
operator|(
name|LONGEST
operator|)
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|value_assign
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
return|return
name|arg1
return|;
block|}
case|case
name|OP_THIS
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|1
expr_stmt|;
return|return
name|value_of_this
argument_list|(
literal|1
argument_list|)
return|;
case|case
name|OP_TYPE
case|:
name|error
argument_list|(
literal|"Attempt to use a type name as an expression"
argument_list|)
expr_stmt|;
default|default:
comment|/* Removing this case and compiling with gcc -Wall reveals that 	 a lot of cases are hitting this case.  Some of these should 	 probably be removed from expression.h (e.g. do we need a BINOP_SCOPE 	 and an OP_SCOPE?); others are legitimate expressions which are 	 (apparently) not fully implemented.  	 If there are any cases landing here which mean a user error, 	 then they should be separate cases, with more descriptive 	 error messages.  */
name|error
argument_list|(
literal|"\ GDB does not (yet) know how to evaluated that kind of expression"
argument_list|)
expr_stmt|;
block|}
name|nosideret
label|:
return|return
name|value_from_longest
argument_list|(
name|builtin_type_long
argument_list|,
operator|(
name|LONGEST
operator|)
literal|1
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Evaluate a subexpression of EXP, at index *POS,    and return the address of that subexpression.    Advance *POS over the subexpression.    If the subexpression isn't an lvalue, get an error.    NOSIDE may be EVAL_AVOID_SIDE_EFFECTS;    then only the type of the result need be correct.  */
end_comment

begin_function
specifier|static
name|value
name|evaluate_subexp_for_address
parameter_list|(
name|exp
parameter_list|,
name|pos
parameter_list|,
name|noside
parameter_list|)
specifier|register
name|struct
name|expression
modifier|*
name|exp
decl_stmt|;
specifier|register
name|int
modifier|*
name|pos
decl_stmt|;
name|enum
name|noside
name|noside
decl_stmt|;
block|{
name|enum
name|exp_opcode
name|op
decl_stmt|;
specifier|register
name|int
name|pc
decl_stmt|;
name|struct
name|symbol
modifier|*
name|var
decl_stmt|;
name|pc
operator|=
operator|(
operator|*
name|pos
operator|)
expr_stmt|;
name|op
operator|=
name|exp
operator|->
name|elts
index|[
name|pc
index|]
operator|.
name|opcode
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|UNOP_IND
case|:
operator|(
operator|*
name|pos
operator|)
operator|++
expr_stmt|;
return|return
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
return|;
case|case
name|UNOP_MEMVAL
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|3
expr_stmt|;
return|return
name|value_cast
argument_list|(
name|lookup_pointer_type
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|type
argument_list|)
argument_list|,
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
argument_list|)
return|;
case|case
name|OP_VAR_VALUE
case|:
name|var
operator|=
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|symbol
expr_stmt|;
comment|/* C++: The "address" of a reference should yield the address        * of the object pointed to. Let value_addr() deal with it. */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|var
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_REF
condition|)
goto|goto
name|default_case
goto|;
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_AVOID_SIDE_EFFECTS
condition|)
block|{
name|struct
name|type
modifier|*
name|type
init|=
name|lookup_pointer_type
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|var
argument_list|)
argument_list|)
decl_stmt|;
name|enum
name|address_class
name|sym_class
init|=
name|SYMBOL_CLASS
argument_list|(
name|var
argument_list|)
decl_stmt|;
if|if
condition|(
name|sym_class
operator|==
name|LOC_CONST
operator|||
name|sym_class
operator|==
name|LOC_CONST_BYTES
operator|||
name|sym_class
operator|==
name|LOC_REGISTER
operator|||
name|sym_class
operator|==
name|LOC_REGPARM
condition|)
name|error
argument_list|(
literal|"Attempt to take address of register or constant."
argument_list|)
expr_stmt|;
return|return
name|value_zero
argument_list|(
name|type
argument_list|,
name|not_lval
argument_list|)
return|;
block|}
else|else
return|return
name|locate_var_value
argument_list|(
name|var
argument_list|,
name|block_innermost_frame
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|block
argument_list|)
argument_list|)
return|;
default|default:
name|default_case
label|:
if|if
condition|(
name|noside
operator|==
name|EVAL_AVOID_SIDE_EFFECTS
condition|)
block|{
name|value
name|x
init|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
decl_stmt|;
if|if
condition|(
name|VALUE_LVAL
argument_list|(
name|x
argument_list|)
operator|==
name|lval_memory
condition|)
return|return
name|value_zero
argument_list|(
name|lookup_pointer_type
argument_list|(
name|VALUE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|not_lval
argument_list|)
return|;
else|else
name|error
argument_list|(
literal|"Attempt to take address of non-lval"
argument_list|)
expr_stmt|;
block|}
return|return
name|value_addr
argument_list|(
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Evaluate like `evaluate_subexp' except coercing arrays to pointers.    When used in contexts where arrays will be coerced anyway, this is    equivalent to `evaluate_subexp' but much faster because it avoids    actually fetching array contents (perhaps obsolete now that we have    VALUE_LAZY).     Note that we currently only do the coercion for C expressions, where    arrays are zero based and the coercion is correct.  For other languages,    with nonzero based arrays, coercion loses.  Use CAST_IS_CONVERSION    to decide if coercion is appropriate.     */
end_comment

begin_function
specifier|static
name|value
name|evaluate_subexp_with_coercion
parameter_list|(
name|exp
parameter_list|,
name|pos
parameter_list|,
name|noside
parameter_list|)
specifier|register
name|struct
name|expression
modifier|*
name|exp
decl_stmt|;
specifier|register
name|int
modifier|*
name|pos
decl_stmt|;
name|enum
name|noside
name|noside
decl_stmt|;
block|{
specifier|register
name|enum
name|exp_opcode
name|op
decl_stmt|;
specifier|register
name|int
name|pc
decl_stmt|;
specifier|register
name|value
name|val
decl_stmt|;
name|struct
name|symbol
modifier|*
name|var
decl_stmt|;
name|pc
operator|=
operator|(
operator|*
name|pos
operator|)
expr_stmt|;
name|op
operator|=
name|exp
operator|->
name|elts
index|[
name|pc
index|]
operator|.
name|opcode
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|OP_VAR_VALUE
case|:
name|var
operator|=
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|symbol
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|var
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_ARRAY
operator|&&
name|CAST_IS_CONVERSION
condition|)
block|{
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|4
expr_stmt|;
name|val
operator|=
name|locate_var_value
argument_list|(
name|var
argument_list|,
name|block_innermost_frame
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|block
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|value_cast
argument_list|(
name|lookup_pointer_type
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|var
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|val
argument_list|)
return|;
block|}
comment|/* FALLTHROUGH */
default|default:
return|return
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Evaluate a subexpression of EXP, at index *POS,    and return a value for the size of that subexpression.    Advance *POS over the subexpression.  */
end_comment

begin_function
specifier|static
name|value
name|evaluate_subexp_for_sizeof
parameter_list|(
name|exp
parameter_list|,
name|pos
parameter_list|)
specifier|register
name|struct
name|expression
modifier|*
name|exp
decl_stmt|;
specifier|register
name|int
modifier|*
name|pos
decl_stmt|;
block|{
name|enum
name|exp_opcode
name|op
decl_stmt|;
specifier|register
name|int
name|pc
decl_stmt|;
name|value
name|val
decl_stmt|;
name|pc
operator|=
operator|(
operator|*
name|pos
operator|)
expr_stmt|;
name|op
operator|=
name|exp
operator|->
name|elts
index|[
name|pc
index|]
operator|.
name|opcode
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
comment|/* This case is handled specially 	 so that we avoid creating a value for the result type. 	 If the result type is very big, it's desirable not to 	 create a value unnecessarily.  */
case|case
name|UNOP_IND
case|:
operator|(
operator|*
name|pos
operator|)
operator|++
expr_stmt|;
name|val
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|EVAL_AVOID_SIDE_EFFECTS
argument_list|)
expr_stmt|;
return|return
name|value_from_longest
argument_list|(
name|builtin_type_int
argument_list|,
operator|(
name|LONGEST
operator|)
name|TYPE_LENGTH
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|UNOP_MEMVAL
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|3
expr_stmt|;
return|return
name|value_from_longest
argument_list|(
name|builtin_type_int
argument_list|,
operator|(
name|LONGEST
operator|)
name|TYPE_LENGTH
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|type
argument_list|)
argument_list|)
return|;
case|case
name|OP_VAR_VALUE
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|4
expr_stmt|;
return|return
name|value_from_longest
argument_list|(
name|builtin_type_int
argument_list|,
operator|(
name|LONGEST
operator|)
name|TYPE_LENGTH
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|symbol
argument_list|)
argument_list|)
argument_list|)
return|;
default|default:
name|val
operator|=
name|evaluate_subexp
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|EVAL_AVOID_SIDE_EFFECTS
argument_list|)
expr_stmt|;
return|return
name|value_from_longest
argument_list|(
name|builtin_type_int
argument_list|,
operator|(
name|LONGEST
operator|)
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Parse a type expression in the string [P..P+LENGTH). */
end_comment

begin_function
name|struct
name|type
modifier|*
name|parse_and_eval_type
parameter_list|(
name|p
parameter_list|,
name|length
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|length
decl_stmt|;
block|{
name|char
modifier|*
name|tmp
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|length
operator|+
literal|4
argument_list|)
decl_stmt|;
name|struct
name|expression
modifier|*
name|expr
decl_stmt|;
name|tmp
index|[
literal|0
index|]
operator|=
literal|'('
expr_stmt|;
name|memcpy
argument_list|(
name|tmp
operator|+
literal|1
argument_list|,
name|p
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|tmp
index|[
name|length
operator|+
literal|1
index|]
operator|=
literal|')'
expr_stmt|;
name|tmp
index|[
name|length
operator|+
literal|2
index|]
operator|=
literal|'0'
expr_stmt|;
name|tmp
index|[
name|length
operator|+
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
name|expr
operator|=
name|parse_expression
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
operator|->
name|elts
index|[
literal|0
index|]
operator|.
name|opcode
operator|!=
name|UNOP_CAST
condition|)
name|error
argument_list|(
literal|"Internal error in eval_type."
argument_list|)
expr_stmt|;
return|return
name|expr
operator|->
name|elts
index|[
literal|1
index|]
operator|.
name|type
return|;
block|}
end_function

end_unit

