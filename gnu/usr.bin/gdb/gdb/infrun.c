begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Target-struct-independent code to start (run) and stop an inferior process.    Copyright 1986, 1987, 1988, 1989, 1991, 1992, 1993, 1994    Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"breakpoint.h"
end_include

begin_include
include|#
directive|include
file|"wait.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"thread.h"
end_include

begin_include
include|#
directive|include
file|"annotate.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_comment
comment|/* unistd.h is needed to #define X_OK */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Prototypes for local functions */
end_comment

begin_decl_stmt
specifier|static
name|void
name|signals_info
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handle_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sig_print_info
name|PARAMS
argument_list|(
operator|(
expr|enum
name|target_signal
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sig_print_header
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|resume_cleanups
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hook_stop_stub
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* GET_LONGJMP_TARGET returns the PC at which longjmp() will resume the    program.  It needs to examine the jmp_buf argument and extract the PC    from it.  The return value is non-zero on success, zero otherwise. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|GET_LONGJMP_TARGET
end_ifndef

begin_define
define|#
directive|define
name|GET_LONGJMP_TARGET
parameter_list|(
name|PC_ADDR
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Some machines have trampoline code that sits between function callers    and the actual functions themselves.  If this machine doesn't have    such things, disable their processing.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SKIP_TRAMPOLINE_CODE
end_ifndef

begin_define
define|#
directive|define
name|SKIP_TRAMPOLINE_CODE
parameter_list|(
name|pc
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* For SVR4 shared libraries, each call goes through a small piece of    trampoline code in the ".plt" section.  IN_SOLIB_TRAMPOLINE evaluates    to nonzero if we are current stopped in one of these. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|IN_SOLIB_TRAMPOLINE
end_ifndef

begin_define
define|#
directive|define
name|IN_SOLIB_TRAMPOLINE
parameter_list|(
name|pc
parameter_list|,
name|name
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* On some systems, the PC may be left pointing at an instruction that  won't    actually be executed.  This is usually indicated by a bit in the PSW.  If    we find ourselves in such a state, then we step the target beyond the    nullified instruction before returning control to the user so as to avoid    confusion. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|INSTRUCTION_NULLIFIED
end_ifndef

begin_define
define|#
directive|define
name|INSTRUCTION_NULLIFIED
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Tables of how to react to signals; the user sets them.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|char
modifier|*
name|signal_stop
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
modifier|*
name|signal_print
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
modifier|*
name|signal_program
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SET_SIGS
parameter_list|(
name|nsigs
parameter_list|,
name|sigs
parameter_list|,
name|flags
parameter_list|)
define|\
value|do { \     int signum = (nsigs); \     while (signum--> 0) \       if ((sigs)[signum]) \ 	(flags)[signum] = 1; \   } while (0)
end_define

begin_define
define|#
directive|define
name|UNSET_SIGS
parameter_list|(
name|nsigs
parameter_list|,
name|sigs
parameter_list|,
name|flags
parameter_list|)
define|\
value|do { \     int signum = (nsigs); \     while (signum--> 0) \       if ((sigs)[signum]) \ 	(flags)[signum] = 0; \   } while (0)
end_define

begin_comment
comment|/* Command list pointer for the "stop" placeholder.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cmd_list_element
modifier|*
name|stop_command
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if breakpoints are now inserted in the inferior.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|breakpoints_inserted
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function inferior was in as of last step command.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|symbol
modifier|*
name|step_start_function
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we are expecting a trace trap and should proceed from it.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|trap_expected
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if the next time we try to continue the inferior, it will    step one instruction and generate a spurious trace trap.    This is used to compensate for a bug in HP-UX.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|trap_expected_after_continue
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means expecting a trace trap    and should stop the inferior and return silently when it happens.  */
end_comment

begin_decl_stmt
name|int
name|stop_after_trap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means expecting a trap and caller will handle it themselves.    It is used after attach, due to attaching to a process;    when running in the shell before the child program has been exec'd;    and when running some kinds of remote stuff (FIXME?).  */
end_comment

begin_decl_stmt
name|int
name|stop_soon_quietly
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if proceed is being used for a "finish" command or a similar    situation when stop_registers should be saved.  */
end_comment

begin_decl_stmt
name|int
name|proceed_to_finish
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Save register contents here when about to pop a stack dummy frame,    if-and-only-if proceed_to_finish is set.    Thus this contains the return value from the called function (assuming    values are returned in a register).  */
end_comment

begin_decl_stmt
name|char
name|stop_registers
index|[
name|REGISTER_BYTES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if program stopped due to error trying to insert breakpoints.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|breakpoints_failed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero after stop if current stack frame should be printed.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stop_print_frame
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|NO_SINGLE_STEP
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|one_stepped
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* From machine dependent code */
end_comment

begin_function_decl
specifier|extern
name|void
name|single_step
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Same. */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NO_SINGLE_STEP */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Things to clean up if we QUIT out of resume ().  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|resume_cleanups
parameter_list|(
name|arg
parameter_list|)
name|int
name|arg
decl_stmt|;
block|{
name|normal_stop
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Resume the inferior, but allow a QUIT.  This is useful if the user    wants to interrupt some lengthy single-stepping operation    (for child processes, the SIGINT goes to the inferior, and so    we get a SIGINT random_signal, but for remote debugging and perhaps    other targets, that's not true).     STEP nonzero if we should step (zero to continue instead).    SIG is the signal to give the inferior (zero for none).  */
end_comment

begin_function
name|void
name|resume
parameter_list|(
name|step
parameter_list|,
name|sig
parameter_list|)
name|int
name|step
decl_stmt|;
name|enum
name|target_signal
name|sig
decl_stmt|;
block|{
name|struct
name|cleanup
modifier|*
name|old_cleanups
init|=
name|make_cleanup
argument_list|(
name|resume_cleanups
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|QUIT
expr_stmt|;
ifdef|#
directive|ifdef
name|CANNOT_STEP_BREAKPOINT
comment|/* Most targets can step a breakpoint instruction, thus executing it      normally.  But if this one cannot, just continue and we will hit      it anyway.  */
if|if
condition|(
name|step
operator|&&
name|breakpoints_inserted
operator|&&
name|breakpoint_here_p
argument_list|(
name|read_pc
argument_list|()
argument_list|)
condition|)
name|step
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NO_SINGLE_STEP
if|if
condition|(
name|step
condition|)
block|{
name|single_step
argument_list|(
name|sig
argument_list|)
expr_stmt|;
comment|/* Do it the hard way, w/temp breakpoints */
name|step
operator|=
literal|0
expr_stmt|;
comment|/* ...and don't ask hardware to do it.  */
block|}
endif|#
directive|endif
comment|/* Handle any optimized stores to the inferior NOW...  */
ifdef|#
directive|ifdef
name|DO_DEFERRED_STORES
name|DO_DEFERRED_STORES
expr_stmt|;
endif|#
directive|endif
comment|/* Install inferior's terminal modes.  */
name|target_terminal_inferior
argument_list|()
expr_stmt|;
name|target_resume
argument_list|(
operator|-
literal|1
argument_list|,
name|step
argument_list|,
name|sig
argument_list|)
expr_stmt|;
name|discard_cleanups
argument_list|(
name|old_cleanups
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Clear out all variables saying what to do when inferior is continued.    First do this, then set the ones you want, then call `proceed'.  */
end_comment

begin_function
name|void
name|clear_proceed_status
parameter_list|()
block|{
name|trap_expected
operator|=
literal|0
expr_stmt|;
name|step_range_start
operator|=
literal|0
expr_stmt|;
name|step_range_end
operator|=
literal|0
expr_stmt|;
name|step_frame_address
operator|=
literal|0
expr_stmt|;
name|step_over_calls
operator|=
operator|-
literal|1
expr_stmt|;
name|stop_after_trap
operator|=
literal|0
expr_stmt|;
name|stop_soon_quietly
operator|=
literal|0
expr_stmt|;
name|proceed_to_finish
operator|=
literal|0
expr_stmt|;
name|breakpoint_proceeded
operator|=
literal|1
expr_stmt|;
comment|/* We're about to proceed... */
comment|/* Discard any remaining commands or status from previous stop.  */
name|bpstat_clear
argument_list|(
operator|&
name|stop_bpstat
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Basic routine for continuing the program in various fashions.     ADDR is the address to resume at, or -1 for resume where stopped.    SIGGNAL is the signal to give it, or 0 for none,      or -1 for act according to how it stopped.    STEP is nonzero if should trap after one instruction.      -1 means return after that and print nothing.      You should probably set various step_... variables      before calling here, if you are stepping.     You should call clear_proceed_status before calling proceed.  */
end_comment

begin_function
name|void
name|proceed
parameter_list|(
name|addr
parameter_list|,
name|siggnal
parameter_list|,
name|step
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
name|enum
name|target_signal
name|siggnal
decl_stmt|;
name|int
name|step
decl_stmt|;
block|{
name|int
name|oneproc
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|step
operator|>
literal|0
condition|)
name|step_start_function
operator|=
name|find_pc_function
argument_list|(
name|read_pc
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|step
operator|<
literal|0
condition|)
name|stop_after_trap
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|addr
operator|==
operator|(
name|CORE_ADDR
operator|)
operator|-
literal|1
condition|)
block|{
comment|/* If there is a breakpoint at the address we will resume at, 	 step one instruction before inserting breakpoints 	 so that we do not stop right away.  */
if|if
condition|(
name|breakpoint_here_p
argument_list|(
name|read_pc
argument_list|()
argument_list|)
condition|)
name|oneproc
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|STEP_SKIPS_DELAY
comment|/* Check breakpoint_here_p first, because breakpoint_here_p is fast 	 (it just checks internal GDB data structures) and STEP_SKIPS_DELAY 	 is slow (it needs to read memory from the target).  */
if|if
condition|(
name|breakpoint_here_p
argument_list|(
name|read_pc
argument_list|()
operator|+
literal|4
argument_list|)
operator|&&
name|STEP_SKIPS_DELAY
argument_list|(
name|read_pc
argument_list|()
argument_list|)
condition|)
name|oneproc
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* STEP_SKIPS_DELAY */
block|}
else|else
name|write_pc
argument_list|(
name|addr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PREPARE_TO_PROCEED
comment|/* In a multi-threaded task we may select another thread and then continue.       In this case the thread that stopped at a breakpoint will immediately      cause another stop, if it is not stepped over first. On the other hand,      if (ADDR != -1) we only want to single step over the breakpoint if we did      switch to another thread.       If we are single stepping, don't do any of the above.      (Note that in the current implementation single stepping another      thread after a breakpoint and then continuing will cause the original      breakpoint to be hit again, but you can always continue, so it's not      a big deal.)  */
if|if
condition|(
operator|!
name|step
operator|&&
name|PREPARE_TO_PROCEED
argument_list|(
literal|1
argument_list|)
operator|&&
name|breakpoint_here_p
argument_list|(
name|read_pc
argument_list|()
argument_list|)
condition|)
name|oneproc
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* PREPARE_TO_PROCEED */
if|if
condition|(
name|trap_expected_after_continue
condition|)
block|{
comment|/* If (step == 0), a trap will be automatically generated after 	 the first instruction is executed.  Force step one 	 instruction to clear this condition.  This should not occur 	 if step is nonzero, but it is harmless in that case.  */
name|oneproc
operator|=
literal|1
expr_stmt|;
name|trap_expected_after_continue
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|oneproc
condition|)
comment|/* We will get a trace trap after one instruction.        Continue it automatically and insert breakpoints then.  */
name|trap_expected
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|int
name|temp
init|=
name|insert_breakpoints
argument_list|()
decl_stmt|;
if|if
condition|(
name|temp
condition|)
block|{
name|print_sys_errmsg
argument_list|(
literal|"ptrace"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Cannot insert breakpoints.\n\ The same program may be running in another process."
argument_list|)
expr_stmt|;
block|}
name|breakpoints_inserted
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|siggnal
operator|!=
name|TARGET_SIGNAL_DEFAULT
condition|)
name|stop_signal
operator|=
name|siggnal
expr_stmt|;
comment|/* If this signal should not be seen by program,      give it zero.  Used for debugging signals.  */
elseif|else
if|if
condition|(
operator|!
name|signal_program
index|[
name|stop_signal
index|]
condition|)
name|stop_signal
operator|=
name|TARGET_SIGNAL_0
expr_stmt|;
name|annotate_starting
argument_list|()
expr_stmt|;
comment|/* Resume inferior.  */
name|resume
argument_list|(
name|oneproc
operator|||
name|step
operator|||
name|bpstat_should_step
argument_list|()
argument_list|,
name|stop_signal
argument_list|)
expr_stmt|;
comment|/* Wait for it to stop (if not standalone)      and in any case decode why it stopped, and act accordingly.  */
name|wait_for_inferior
argument_list|()
expr_stmt|;
name|normal_stop
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record the pc and sp of the program the last time it stopped.    These are just used internally by wait_for_inferior, but need    to be preserved over calls to it and cleared when the inferior    is started.  */
end_comment

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|prev_pc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|prev_sp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|prev_func_start
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|prev_func_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|prev_frame_address
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Start remote-debugging of a machine over a serial link.  */
end_comment

begin_function
name|void
name|start_remote
parameter_list|()
block|{
name|init_wait_for_inferior
argument_list|()
expr_stmt|;
name|clear_proceed_status
argument_list|()
expr_stmt|;
name|stop_soon_quietly
operator|=
literal|1
expr_stmt|;
name|trap_expected
operator|=
literal|0
expr_stmt|;
name|wait_for_inferior
argument_list|()
expr_stmt|;
name|normal_stop
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize static vars when a new inferior begins.  */
end_comment

begin_function
name|void
name|init_wait_for_inferior
parameter_list|()
block|{
comment|/* These are meaningless until the first time through wait_for_inferior.  */
name|prev_pc
operator|=
literal|0
expr_stmt|;
name|prev_sp
operator|=
literal|0
expr_stmt|;
name|prev_func_start
operator|=
literal|0
expr_stmt|;
name|prev_func_name
operator|=
name|NULL
expr_stmt|;
name|prev_frame_address
operator|=
literal|0
expr_stmt|;
name|trap_expected_after_continue
operator|=
literal|0
expr_stmt|;
name|breakpoints_inserted
operator|=
literal|0
expr_stmt|;
name|breakpoint_init_inferior
argument_list|()
expr_stmt|;
comment|/* Don't confuse first call to proceed(). */
name|stop_signal
operator|=
name|TARGET_SIGNAL_0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|delete_breakpoint_current_contents
parameter_list|(
name|arg
parameter_list|)
name|PTR
name|arg
decl_stmt|;
block|{
name|struct
name|breakpoint
modifier|*
modifier|*
name|breakpointp
init|=
operator|(
expr|struct
name|breakpoint
operator|*
operator|*
operator|)
name|arg
decl_stmt|;
if|if
condition|(
operator|*
name|breakpointp
operator|!=
name|NULL
condition|)
name|delete_breakpoint
argument_list|(
operator|*
name|breakpointp
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Wait for control to return from inferior to debugger.    If inferior gets a signal, we may decide to start it up again    instead of returning.  That is why there is a loop in this function.    When this function actually returns it means the inferior    should be left stopped and GDB should read more commands.  */
end_comment

begin_function
name|void
name|wait_for_inferior
parameter_list|()
block|{
name|struct
name|cleanup
modifier|*
name|old_cleanups
decl_stmt|;
name|struct
name|target_waitstatus
name|w
decl_stmt|;
name|int
name|another_trap
decl_stmt|;
name|int
name|random_signal
decl_stmt|;
name|CORE_ADDR
name|stop_sp
init|=
literal|0
decl_stmt|;
name|CORE_ADDR
name|stop_func_start
decl_stmt|;
name|CORE_ADDR
name|stop_func_end
decl_stmt|;
name|char
modifier|*
name|stop_func_name
decl_stmt|;
name|CORE_ADDR
name|prologue_pc
init|=
literal|0
decl_stmt|,
name|tmp
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|int
name|remove_breakpoints_on_following_step
init|=
literal|0
decl_stmt|;
name|int
name|current_line
decl_stmt|;
name|struct
name|symtab
modifier|*
name|current_symtab
decl_stmt|;
name|int
name|handling_longjmp
init|=
literal|0
decl_stmt|;
comment|/* FIXME */
name|struct
name|breakpoint
modifier|*
name|step_resume_breakpoint
init|=
name|NULL
decl_stmt|;
name|struct
name|breakpoint
modifier|*
name|through_sigtramp_breakpoint
init|=
name|NULL
decl_stmt|;
name|int
name|pid
decl_stmt|;
name|old_cleanups
operator|=
name|make_cleanup
argument_list|(
name|delete_breakpoint_current_contents
argument_list|,
operator|&
name|step_resume_breakpoint
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|delete_breakpoint_current_contents
argument_list|,
operator|&
name|through_sigtramp_breakpoint
argument_list|)
expr_stmt|;
name|sal
operator|=
name|find_pc_line
argument_list|(
name|prev_pc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|current_line
operator|=
name|sal
operator|.
name|line
expr_stmt|;
name|current_symtab
operator|=
name|sal
operator|.
name|symtab
expr_stmt|;
comment|/* Are we stepping?  */
define|#
directive|define
name|CURRENTLY_STEPPING
parameter_list|()
define|\
value|((through_sigtramp_breakpoint == NULL \&& !handling_longjmp \&& ((step_range_end&& step_resume_breakpoint == NULL) \ 	|| trap_expected)) \    || bpstat_should_step ())
while|while
condition|(
literal|1
condition|)
block|{
comment|/* We have to invalidate the registers BEFORE calling target_wait because 	 they can be loaded from the target while in target_wait.  This makes 	 remote debugging a bit more efficient for those targets that provide 	 critical registers as part of their normal status mechanism. */
name|registers_changed
argument_list|()
expr_stmt|;
name|pid
operator|=
name|target_wait
argument_list|(
operator|-
literal|1
argument_list|,
operator|&
name|w
argument_list|)
expr_stmt|;
name|flush_cached_frames
argument_list|()
expr_stmt|;
comment|/* If it's a new process, add it to the thread database */
if|if
condition|(
name|pid
operator|!=
name|inferior_pid
operator|&&
operator|!
name|in_thread_list
argument_list|(
name|pid
argument_list|)
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"[New %s]\n"
argument_list|,
name|target_pid_to_str
argument_list|(
name|pid
argument_list|)
argument_list|)
expr_stmt|;
name|add_thread
argument_list|(
name|pid
argument_list|)
expr_stmt|;
comment|/* We may want to consider not doing a resume here in order to give 	     the user a chance to play with the new thread.  It might be good 	     to make that a user-settable option.  */
comment|/* At this point, all threads are stopped (happens automatically in 	     either the OS or the native code).  Therefore we need to continue 	     all threads in order to make progress.  */
name|target_resume
argument_list|(
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|TARGET_SIGNAL_0
argument_list|)
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
name|w
operator|.
name|kind
condition|)
block|{
case|case
name|TARGET_WAITKIND_LOADED
case|:
comment|/* Ignore it gracefully.  */
if|if
condition|(
name|breakpoints_inserted
condition|)
block|{
name|mark_breakpoints_out
argument_list|()
expr_stmt|;
name|insert_breakpoints
argument_list|()
expr_stmt|;
block|}
name|resume
argument_list|(
literal|0
argument_list|,
name|TARGET_SIGNAL_0
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|TARGET_WAITKIND_SPURIOUS
case|:
name|resume
argument_list|(
literal|0
argument_list|,
name|TARGET_SIGNAL_0
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|TARGET_WAITKIND_EXITED
case|:
name|target_terminal_ours
argument_list|()
expr_stmt|;
comment|/* Must do this before mourn anyway */
name|annotate_exited
argument_list|(
name|w
operator|.
name|value
operator|.
name|integer
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|.
name|value
operator|.
name|integer
condition|)
name|printf_filtered
argument_list|(
literal|"\nProgram exited with code 0%o.\n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|w
operator|.
name|value
operator|.
name|integer
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|"\nProgram exited normally.\n"
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
name|target_mourn_inferior
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|NO_SINGLE_STEP
name|one_stepped
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|stop_print_frame
operator|=
literal|0
expr_stmt|;
goto|goto
name|stop_stepping
goto|;
case|case
name|TARGET_WAITKIND_SIGNALLED
case|:
name|stop_print_frame
operator|=
literal|0
expr_stmt|;
name|stop_signal
operator|=
name|w
operator|.
name|value
operator|.
name|sig
expr_stmt|;
name|target_terminal_ours
argument_list|()
expr_stmt|;
comment|/* Must do this before mourn anyway */
name|annotate_signalled
argument_list|()
expr_stmt|;
name|target_kill
argument_list|()
expr_stmt|;
comment|/* kill mourns as well */
name|printf_filtered
argument_list|(
literal|"\nProgram terminated with signal "
argument_list|)
expr_stmt|;
name|annotate_signal_name
argument_list|()
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%s"
argument_list|,
name|target_signal_to_name
argument_list|(
name|stop_signal
argument_list|)
argument_list|)
expr_stmt|;
name|annotate_signal_name_end
argument_list|()
expr_stmt|;
name|printf_filtered
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|annotate_signal_string
argument_list|()
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%s"
argument_list|,
name|target_signal_to_string
argument_list|(
name|stop_signal
argument_list|)
argument_list|)
expr_stmt|;
name|annotate_signal_string_end
argument_list|()
expr_stmt|;
name|printf_filtered
argument_list|(
literal|".\n"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"The program no longer exists.\n"
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NO_SINGLE_STEP
name|one_stepped
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
goto|goto
name|stop_stepping
goto|;
case|case
name|TARGET_WAITKIND_STOPPED
case|:
comment|/* This is the only case in which we keep going; the above cases 	     end in a continue or goto.  */
break|break;
block|}
name|stop_signal
operator|=
name|w
operator|.
name|value
operator|.
name|sig
expr_stmt|;
name|stop_pc
operator|=
name|read_pc_pid
argument_list|(
name|pid
argument_list|)
expr_stmt|;
comment|/* See if a thread hit a thread-specific breakpoint that was meant for 	 another thread.  If so, then step that thread past the breakpoint, 	 and continue it.  */
if|if
condition|(
name|stop_signal
operator|==
name|TARGET_SIGNAL_TRAP
operator|&&
name|breakpoints_inserted
operator|&&
name|breakpoint_here_p
argument_list|(
name|stop_pc
operator|-
name|DECR_PC_AFTER_BREAK
argument_list|)
condition|)
block|{
name|random_signal
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|breakpoint_thread_match
argument_list|(
name|stop_pc
operator|-
name|DECR_PC_AFTER_BREAK
argument_list|,
name|pid
argument_list|)
condition|)
block|{
comment|/* Saw a breakpoint, but it was hit by the wrong thread.  Just continue. */
name|write_pc
argument_list|(
name|stop_pc
operator|-
name|DECR_PC_AFTER_BREAK
argument_list|)
expr_stmt|;
name|remove_breakpoints
argument_list|()
expr_stmt|;
name|target_resume
argument_list|(
name|pid
argument_list|,
literal|1
argument_list|,
name|TARGET_SIGNAL_0
argument_list|)
expr_stmt|;
comment|/* Single step */
comment|/* FIXME: What if a signal arrives instead of the single-step 		 happening?  */
name|target_wait
argument_list|(
name|pid
argument_list|,
operator|&
name|w
argument_list|)
expr_stmt|;
name|insert_breakpoints
argument_list|()
expr_stmt|;
name|target_resume
argument_list|(
name|pid
argument_list|,
literal|0
argument_list|,
name|TARGET_SIGNAL_0
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
else|else
name|random_signal
operator|=
literal|1
expr_stmt|;
comment|/* See if something interesting happened to the non-current thread.  If          so, then switch to that thread, and eventually give control back to 	 the user.  */
if|if
condition|(
name|pid
operator|!=
name|inferior_pid
condition|)
block|{
name|int
name|printed
init|=
literal|0
decl_stmt|;
comment|/* If it's a random signal for a non-current thread, notify user 	     if he's expressed an interest.  */
if|if
condition|(
name|random_signal
operator|&&
name|signal_print
index|[
name|stop_signal
index|]
condition|)
block|{
name|printed
operator|=
literal|1
expr_stmt|;
name|target_terminal_ours_for_output
argument_list|()
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\nProgram received signal %s, %s.\n"
argument_list|,
name|target_signal_to_name
argument_list|(
name|stop_signal
argument_list|)
argument_list|,
name|target_signal_to_string
argument_list|(
name|stop_signal
argument_list|)
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
comment|/* If it's not SIGTRAP and not a signal we want to stop for, then 	     continue the thread. */
if|if
condition|(
name|stop_signal
operator|!=
name|TARGET_SIGNAL_TRAP
operator|&&
operator|!
name|signal_stop
index|[
name|stop_signal
index|]
condition|)
block|{
if|if
condition|(
name|printed
condition|)
name|target_terminal_inferior
argument_list|()
expr_stmt|;
comment|/* Clear the signal if it should not be passed.  */
if|if
condition|(
name|signal_program
index|[
name|stop_signal
index|]
operator|==
literal|0
condition|)
name|stop_signal
operator|=
name|TARGET_SIGNAL_0
expr_stmt|;
name|target_resume
argument_list|(
name|pid
argument_list|,
literal|0
argument_list|,
name|stop_signal
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* It's a SIGTRAP or a signal we're interested in.  Switch threads, 	     and fall into the rest of wait_for_inferior().  */
name|inferior_pid
operator|=
name|pid
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"[Switching to %s]\n"
argument_list|,
name|target_pid_to_str
argument_list|(
name|pid
argument_list|)
argument_list|)
expr_stmt|;
name|flush_cached_frames
argument_list|()
expr_stmt|;
name|trap_expected
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|step_resume_breakpoint
condition|)
block|{
name|delete_breakpoint
argument_list|(
name|step_resume_breakpoint
argument_list|)
expr_stmt|;
name|step_resume_breakpoint
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Not sure whether we need to blow this away too, 	     but probably it is like the step-resume 	     breakpoint.  */
if|if
condition|(
name|through_sigtramp_breakpoint
condition|)
block|{
name|delete_breakpoint
argument_list|(
name|through_sigtramp_breakpoint
argument_list|)
expr_stmt|;
name|through_sigtramp_breakpoint
operator|=
name|NULL
expr_stmt|;
block|}
name|prev_pc
operator|=
literal|0
expr_stmt|;
name|prev_sp
operator|=
literal|0
expr_stmt|;
name|prev_func_name
operator|=
name|NULL
expr_stmt|;
name|step_range_start
operator|=
literal|0
expr_stmt|;
name|step_range_end
operator|=
literal|0
expr_stmt|;
name|step_frame_address
operator|=
literal|0
expr_stmt|;
name|handling_longjmp
operator|=
literal|0
expr_stmt|;
name|another_trap
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|NO_SINGLE_STEP
if|if
condition|(
name|one_stepped
condition|)
name|single_step
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* This actually cleans up the ss */
endif|#
directive|endif
comment|/* NO_SINGLE_STEP */
comment|/* If PC is pointing at a nullified instruction, then step beyond 	 it so that the user won't be confused when GDB appears to be ready 	 to execute it. */
if|if
condition|(
name|INSTRUCTION_NULLIFIED
condition|)
block|{
name|resume
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|set_current_frame
argument_list|(
name|create_new_frame
argument_list|(
name|read_fp
argument_list|()
argument_list|,
name|stop_pc
argument_list|)
argument_list|)
expr_stmt|;
name|select_frame
argument_list|(
name|get_current_frame
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_STEPPABLE_WATCHPOINT
comment|/* It may not be necessary to disable the watchpoint to stop over 	 it.  For example, the PA can (with some kernel cooperation) 	 single step over a watchpoint without disabling the watchpoint.  */
if|if
condition|(
name|STOPPED_BY_WATCHPOINT
argument_list|(
name|w
argument_list|)
condition|)
block|{
name|resume
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_NONSTEPPABLE_WATCHPOINT
comment|/* It is far more common to need to disable a watchpoint 	 to step the inferior over it.  FIXME.  What else might 	 a debug register or page protection watchpoint scheme need 	 here?  */
if|if
condition|(
name|STOPPED_BY_WATCHPOINT
argument_list|(
name|w
argument_list|)
condition|)
block|{
name|remove_breakpoints
argument_list|()
expr_stmt|;
name|resume
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* FIXME: This is bogus.  You can't interact with the 	     inferior except when it is stopped.  It apparently 	     happens to work on Irix4, but it depends on /proc 	     allowing us to muck with the memory of a running process, 	     and the kernel deciding to run one instruction of the 	     inferior before it executes our insert_breakpoints code, 	     which seems like an awfully dubious assumption.  */
name|insert_breakpoints
argument_list|()
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_CONTINUABLE_WATCHPOINT
comment|/* It may be possible to simply continue after a watchpoint.  */
name|STOPPED_BY_WATCHPOINT
argument_list|(
name|w
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|stop_frame_address
operator|=
name|FRAME_FP
argument_list|(
name|get_current_frame
argument_list|()
argument_list|)
expr_stmt|;
name|stop_sp
operator|=
name|read_sp
argument_list|()
expr_stmt|;
name|stop_func_start
operator|=
literal|0
expr_stmt|;
name|stop_func_name
operator|=
literal|0
expr_stmt|;
comment|/* Don't care about return value; stop_func_start and stop_func_name 	 will both be 0 if it doesn't work.  */
name|find_pc_partial_function
argument_list|(
name|stop_pc
argument_list|,
operator|&
name|stop_func_name
argument_list|,
operator|&
name|stop_func_start
argument_list|,
operator|&
name|stop_func_end
argument_list|)
expr_stmt|;
name|stop_func_start
operator|+=
name|FUNCTION_START_OFFSET
expr_stmt|;
name|another_trap
operator|=
literal|0
expr_stmt|;
name|bpstat_clear
argument_list|(
operator|&
name|stop_bpstat
argument_list|)
expr_stmt|;
name|stop_step
operator|=
literal|0
expr_stmt|;
name|stop_stack_dummy
operator|=
literal|0
expr_stmt|;
name|stop_print_frame
operator|=
literal|1
expr_stmt|;
name|random_signal
operator|=
literal|0
expr_stmt|;
name|stopped_by_random_signal
operator|=
literal|0
expr_stmt|;
name|breakpoints_failed
operator|=
literal|0
expr_stmt|;
comment|/* Look at the cause of the stop, and decide what to do. 	 The alternatives are: 	 1) break; to really stop and return to the debugger, 	 2) drop through to start up again 	 (set another_trap to 1 to single step once) 	 3) set random_signal to 1, and the decision between 1 and 2 	 will be made according to the signal handling tables.  */
comment|/* First, distinguish signals caused by the debugger from signals 	 that have to do with the program's own actions. 	 Note that breakpoint insns may cause SIGTRAP or SIGILL 	 or SIGEMT, depending on the operating system version. 	 Here we detect when a SIGILL or SIGEMT is really a breakpoint 	 and change it to SIGTRAP.  */
if|if
condition|(
name|stop_signal
operator|==
name|TARGET_SIGNAL_TRAP
operator|||
operator|(
name|breakpoints_inserted
operator|&&
operator|(
name|stop_signal
operator|==
name|TARGET_SIGNAL_ILL
operator|||
name|stop_signal
operator|==
name|TARGET_SIGNAL_EMT
operator|)
operator|)
operator|||
name|stop_soon_quietly
condition|)
block|{
if|if
condition|(
name|stop_signal
operator|==
name|TARGET_SIGNAL_TRAP
operator|&&
name|stop_after_trap
condition|)
block|{
name|stop_print_frame
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|stop_soon_quietly
condition|)
break|break;
comment|/* Don't even think about breakpoints 	     if just proceeded over a breakpoint.  	     However, if we are trying to proceed over a breakpoint 	     and end up in sigtramp, then through_sigtramp_breakpoint 	     will be set and we should check whether we've hit the 	     step breakpoint.  */
if|if
condition|(
name|stop_signal
operator|==
name|TARGET_SIGNAL_TRAP
operator|&&
name|trap_expected
operator|&&
name|through_sigtramp_breakpoint
operator|==
name|NULL
condition|)
name|bpstat_clear
argument_list|(
operator|&
name|stop_bpstat
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* See if there is a breakpoint at the current PC.  */
name|stop_bpstat
operator|=
name|bpstat_stop_status
argument_list|(
operator|&
name|stop_pc
argument_list|,
name|stop_frame_address
argument_list|,
if|#
directive|if
name|DECR_PC_AFTER_BREAK
comment|/* Notice the case of stepping through a jump 		    that lands just after a breakpoint. 		    Don't confuse that with hitting the breakpoint. 		    What we check for is that 1) stepping is going on 		    and 2) the pc before the last insn does not match 		    the address of the breakpoint before the current pc.  */
operator|(
name|prev_pc
operator|!=
name|stop_pc
operator|-
name|DECR_PC_AFTER_BREAK
operator|&&
name|CURRENTLY_STEPPING
argument_list|()
operator|)
else|#
directive|else
comment|/* DECR_PC_AFTER_BREAK zero */
literal|0
endif|#
directive|endif
comment|/* DECR_PC_AFTER_BREAK zero */
argument_list|)
expr_stmt|;
comment|/* Following in case break condition called a 		 function.  */
name|stop_print_frame
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|stop_signal
operator|==
name|TARGET_SIGNAL_TRAP
condition|)
name|random_signal
operator|=
operator|!
operator|(
name|bpstat_explains_signal
argument_list|(
name|stop_bpstat
argument_list|)
operator|||
name|trap_expected
ifndef|#
directive|ifndef
name|CALL_DUMMY_BREAKPOINT_OFFSET
operator|||
name|PC_IN_CALL_DUMMY
argument_list|(
name|stop_pc
argument_list|,
name|stop_sp
argument_list|,
name|stop_frame_address
argument_list|)
endif|#
directive|endif
comment|/* No CALL_DUMMY_BREAKPOINT_OFFSET.  */
operator|||
operator|(
name|step_range_end
operator|&&
name|step_resume_breakpoint
operator|==
name|NULL
operator|)
operator|)
expr_stmt|;
else|else
block|{
name|random_signal
operator|=
operator|!
operator|(
name|bpstat_explains_signal
argument_list|(
name|stop_bpstat
argument_list|)
comment|/* End of a stack dummy.  Some systems (e.g. Sony 		       news) give another signal besides SIGTRAP, 		       so check here as well as above.  */
ifndef|#
directive|ifndef
name|CALL_DUMMY_BREAKPOINT_OFFSET
operator|||
name|PC_IN_CALL_DUMMY
argument_list|(
name|stop_pc
argument_list|,
name|stop_sp
argument_list|,
name|stop_frame_address
argument_list|)
endif|#
directive|endif
comment|/* No CALL_DUMMY_BREAKPOINT_OFFSET.  */
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|random_signal
condition|)
name|stop_signal
operator|=
name|TARGET_SIGNAL_TRAP
expr_stmt|;
block|}
block|}
else|else
name|random_signal
operator|=
literal|1
expr_stmt|;
comment|/* For the program's own signals, act according to 	 the signal handling tables.  */
if|if
condition|(
name|random_signal
condition|)
block|{
comment|/* Signal not for debugging purposes.  */
name|int
name|printed
init|=
literal|0
decl_stmt|;
name|stopped_by_random_signal
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|signal_print
index|[
name|stop_signal
index|]
condition|)
block|{
name|printed
operator|=
literal|1
expr_stmt|;
name|target_terminal_ours_for_output
argument_list|()
expr_stmt|;
name|annotate_signal
argument_list|()
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\nProgram received signal "
argument_list|)
expr_stmt|;
name|annotate_signal_name
argument_list|()
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%s"
argument_list|,
name|target_signal_to_name
argument_list|(
name|stop_signal
argument_list|)
argument_list|)
expr_stmt|;
name|annotate_signal_name_end
argument_list|()
expr_stmt|;
name|printf_filtered
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|annotate_signal_string
argument_list|()
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%s"
argument_list|,
name|target_signal_to_string
argument_list|(
name|stop_signal
argument_list|)
argument_list|)
expr_stmt|;
name|annotate_signal_string_end
argument_list|()
expr_stmt|;
name|printf_filtered
argument_list|(
literal|".\n"
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|signal_stop
index|[
name|stop_signal
index|]
condition|)
break|break;
comment|/* If not going to stop, give terminal back 	     if we took it away.  */
elseif|else
if|if
condition|(
name|printed
condition|)
name|target_terminal_inferior
argument_list|()
expr_stmt|;
comment|/* Clear the signal if it should not be passed.  */
if|if
condition|(
name|signal_program
index|[
name|stop_signal
index|]
operator|==
literal|0
condition|)
name|stop_signal
operator|=
name|TARGET_SIGNAL_0
expr_stmt|;
comment|/* I'm not sure whether this needs to be check_sigtramp2 or 	     whether it could/should be keep_going.  */
goto|goto
name|check_sigtramp2
goto|;
block|}
comment|/* Handle cases caused by hitting a breakpoint.  */
block|{
name|CORE_ADDR
name|jmp_buf_pc
decl_stmt|;
name|struct
name|bpstat_what
name|what
decl_stmt|;
name|what
operator|=
name|bpstat_what
argument_list|(
name|stop_bpstat
argument_list|)
expr_stmt|;
if|if
condition|(
name|what
operator|.
name|call_dummy
condition|)
block|{
name|stop_stack_dummy
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|HP_OS_BUG
name|trap_expected_after_continue
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
switch|switch
condition|(
name|what
operator|.
name|main_action
condition|)
block|{
case|case
name|BPSTAT_WHAT_SET_LONGJMP_RESUME
case|:
comment|/* If we hit the breakpoint at longjmp, disable it for the 	       duration of this command.  Then, install a temporary 	       breakpoint at the target of the jmp_buf. */
name|disable_longjmp_breakpoint
argument_list|()
expr_stmt|;
name|remove_breakpoints
argument_list|()
expr_stmt|;
name|breakpoints_inserted
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|GET_LONGJMP_TARGET
argument_list|(
operator|&
name|jmp_buf_pc
argument_list|)
condition|)
goto|goto
name|keep_going
goto|;
comment|/* Need to blow away step-resume breakpoint, as it 	       interferes with us */
if|if
condition|(
name|step_resume_breakpoint
operator|!=
name|NULL
condition|)
block|{
name|delete_breakpoint
argument_list|(
name|step_resume_breakpoint
argument_list|)
expr_stmt|;
name|step_resume_breakpoint
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Not sure whether we need to blow this away too, but probably 	       it is like the step-resume breakpoint.  */
if|if
condition|(
name|through_sigtramp_breakpoint
operator|!=
name|NULL
condition|)
block|{
name|delete_breakpoint
argument_list|(
name|through_sigtramp_breakpoint
argument_list|)
expr_stmt|;
name|through_sigtramp_breakpoint
operator|=
name|NULL
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* FIXME - Need to implement nested temporary breakpoints */
block|if (step_over_calls> 0) 	      set_longjmp_resume_breakpoint(jmp_buf_pc, 					    get_current_frame()); 	    else
endif|#
directive|endif
comment|/* 0 */
name|set_longjmp_resume_breakpoint
argument_list|(
name|jmp_buf_pc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|handling_longjmp
operator|=
literal|1
expr_stmt|;
comment|/* FIXME */
goto|goto
name|keep_going
goto|;
case|case
name|BPSTAT_WHAT_CLEAR_LONGJMP_RESUME
case|:
case|case
name|BPSTAT_WHAT_CLEAR_LONGJMP_RESUME_SINGLE
case|:
name|remove_breakpoints
argument_list|()
expr_stmt|;
name|breakpoints_inserted
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
comment|/* FIXME - Need to implement nested temporary breakpoints */
block|if (step_over_calls&& (stop_frame_address 		    INNER_THAN step_frame_address)) 	      { 		another_trap = 1; 		goto keep_going; 	      }
endif|#
directive|endif
comment|/* 0 */
name|disable_longjmp_breakpoint
argument_list|()
expr_stmt|;
name|handling_longjmp
operator|=
literal|0
expr_stmt|;
comment|/* FIXME */
if|if
condition|(
name|what
operator|.
name|main_action
operator|==
name|BPSTAT_WHAT_CLEAR_LONGJMP_RESUME
condition|)
break|break;
comment|/* else fallthrough */
case|case
name|BPSTAT_WHAT_SINGLE
case|:
if|if
condition|(
name|breakpoints_inserted
condition|)
name|remove_breakpoints
argument_list|()
expr_stmt|;
name|breakpoints_inserted
operator|=
literal|0
expr_stmt|;
name|another_trap
operator|=
literal|1
expr_stmt|;
comment|/* Still need to check other stuff, at least the case 	       where we are stepping and step out of the right range.  */
break|break;
case|case
name|BPSTAT_WHAT_STOP_NOISY
case|:
name|stop_print_frame
operator|=
literal|1
expr_stmt|;
comment|/* We are about to nuke the step_resume_breakpoint and 	       through_sigtramp_breakpoint via the cleanup chain, so 	       no need to worry about it here.  */
goto|goto
name|stop_stepping
goto|;
case|case
name|BPSTAT_WHAT_STOP_SILENT
case|:
name|stop_print_frame
operator|=
literal|0
expr_stmt|;
comment|/* We are about to nuke the step_resume_breakpoint and 	       through_sigtramp_breakpoint via the cleanup chain, so 	       no need to worry about it here.  */
goto|goto
name|stop_stepping
goto|;
case|case
name|BPSTAT_WHAT_STEP_RESUME
case|:
name|delete_breakpoint
argument_list|(
name|step_resume_breakpoint
argument_list|)
expr_stmt|;
name|step_resume_breakpoint
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|BPSTAT_WHAT_THROUGH_SIGTRAMP
case|:
name|delete_breakpoint
argument_list|(
name|through_sigtramp_breakpoint
argument_list|)
expr_stmt|;
name|through_sigtramp_breakpoint
operator|=
name|NULL
expr_stmt|;
comment|/* If were waiting for a trap, hitting the step_resume_break 	       doesn't count as getting it.  */
if|if
condition|(
name|trap_expected
condition|)
name|another_trap
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|BPSTAT_WHAT_LAST
case|:
comment|/* Not a real code, but listed here to shut up gcc -Wall.  */
case|case
name|BPSTAT_WHAT_KEEP_CHECKING
case|:
break|break;
block|}
block|}
comment|/* We come here if we hit a breakpoint but should not 	 stop for it.  Possibly we also were stepping 	 and should stop for that.  So fall through and 	 test for stepping.  But, if not stepping, 	 do not stop.  */
ifndef|#
directive|ifndef
name|CALL_DUMMY_BREAKPOINT_OFFSET
comment|/* This is the old way of detecting the end of the stack dummy. 	 An architecture which defines CALL_DUMMY_BREAKPOINT_OFFSET gets 	 handled above.  As soon as we can test it on all of them, all 	 architectures should define it.  */
comment|/* If this is the breakpoint at the end of a stack dummy, 	 just stop silently, unless the user was doing an si/ni, in which 	 case she'd better know what she's doing.  */
if|if
condition|(
name|PC_IN_CALL_DUMMY
argument_list|(
name|stop_pc
argument_list|,
name|stop_sp
argument_list|,
name|stop_frame_address
argument_list|)
operator|&&
operator|!
name|step_range_end
condition|)
block|{
name|stop_print_frame
operator|=
literal|0
expr_stmt|;
name|stop_stack_dummy
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|HP_OS_BUG
name|trap_expected_after_continue
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
endif|#
directive|endif
comment|/* No CALL_DUMMY_BREAKPOINT_OFFSET.  */
if|if
condition|(
name|step_resume_breakpoint
condition|)
comment|/* Having a step-resume breakpoint overrides anything 	   else having to do with stepping commands until 	   that breakpoint is reached.  */
comment|/* I'm not sure whether this needs to be check_sigtramp2 or 	   whether it could/should be keep_going.  */
goto|goto
name|check_sigtramp2
goto|;
if|if
condition|(
name|step_range_end
operator|==
literal|0
condition|)
comment|/* Likewise if we aren't even stepping.  */
comment|/* I'm not sure whether this needs to be check_sigtramp2 or 	   whether it could/should be keep_going.  */
goto|goto
name|check_sigtramp2
goto|;
comment|/* If stepping through a line, keep going if still within it.  */
if|if
condition|(
name|stop_pc
operator|>=
name|step_range_start
operator|&&
name|stop_pc
operator|<
name|step_range_end
comment|/* The step range might include the start of the 	     function, so if we are at the start of the 	     step range and either the stack or frame pointers 	     just changed, we've stepped outside */
operator|&&
operator|!
operator|(
name|stop_pc
operator|==
name|step_range_start
operator|&&
name|stop_frame_address
operator|&&
operator|(
name|stop_sp
name|INNER_THAN
name|prev_sp
operator|||
name|stop_frame_address
operator|!=
name|step_frame_address
operator|)
operator|)
condition|)
block|{
comment|/* We might be doing a BPSTAT_WHAT_SINGLE and getting a signal. 	     So definately need to check for sigtramp here.  */
goto|goto
name|check_sigtramp2
goto|;
block|}
comment|/* We stepped out of the stepping range.  See if that was due 	 to a subroutine call that we should proceed to the end of.  */
comment|/* Did we just take a signal?  */
if|if
condition|(
name|IN_SIGTRAMP
argument_list|(
name|stop_pc
argument_list|,
name|stop_func_name
argument_list|)
operator|&&
operator|!
name|IN_SIGTRAMP
argument_list|(
name|prev_pc
argument_list|,
name|prev_func_name
argument_list|)
condition|)
block|{
comment|/* We've just taken a signal; go until we are back to 	     the point where we took it and one more.  */
comment|/* This code is needed at least in the following case: 	     The user types "next" and then a signal arrives (before 	     the "next" is done).  */
comment|/* Note that if we are stopped at a breakpoint, then we need 	     the step_resume breakpoint to override any breakpoints at 	     the same location, so that we will still step over the 	     breakpoint even though the signal happened.  */
block|{
name|struct
name|symtab_and_line
name|sr_sal
decl_stmt|;
name|sr_sal
operator|.
name|pc
operator|=
name|prev_pc
expr_stmt|;
name|sr_sal
operator|.
name|symtab
operator|=
name|NULL
expr_stmt|;
name|sr_sal
operator|.
name|line
operator|=
literal|0
expr_stmt|;
comment|/* We could probably be setting the frame to 	       prev_frame_address; the reason we don't is that it didn't used 	       to exist.  */
name|step_resume_breakpoint
operator|=
name|set_momentary_breakpoint
argument_list|(
name|sr_sal
argument_list|,
name|NULL
argument_list|,
name|bp_step_resume
argument_list|)
expr_stmt|;
if|if
condition|(
name|breakpoints_inserted
condition|)
name|insert_breakpoints
argument_list|()
expr_stmt|;
block|}
comment|/* If this is stepi or nexti, make sure that the stepping range 	     gets us past that instruction.  */
if|if
condition|(
name|step_range_end
operator|==
literal|1
condition|)
comment|/* FIXME: Does this run afoul of the code below which, if 	       we step into the middle of a line, resets the stepping 	       range?  */
name|step_range_end
operator|=
operator|(
name|step_range_start
operator|=
name|prev_pc
operator|)
operator|+
literal|1
expr_stmt|;
name|remove_breakpoints_on_following_step
operator|=
literal|1
expr_stmt|;
goto|goto
name|keep_going
goto|;
block|}
if|#
directive|if
literal|1
if|if
condition|(
name|stop_func_start
condition|)
block|{
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
comment|/* Do this after the IN_SIGTRAMP check; it might give 	     an error.  */
name|prologue_pc
operator|=
name|stop_func_start
expr_stmt|;
comment|/* Don't skip the prologue if this is assembly source */
name|s
operator|=
name|find_pc_symtab
argument_list|(
name|stop_pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|&&
name|s
operator|->
name|language
operator|!=
name|language_asm
condition|)
name|SKIP_PROLOGUE
argument_list|(
name|prologue_pc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
comment|/* Might be a non-recursive call.  If the symbols are missing 	      enough that stop_func_start == prev_func_start even though 	      they are really two functions, we will treat some calls as 	      jumps.  */
name|stop_func_start
operator|!=
name|prev_func_start
comment|/* Might be a recursive call if either we have a prologue 	      or the call instruction itself saves the PC on the stack.  */
operator|||
name|prologue_pc
operator|!=
name|stop_func_start
operator|||
name|stop_sp
operator|!=
name|prev_sp
operator|)
operator|&&
operator|(
comment|/* PC is completely out of bounds of any known objfiles.  Treat 		 like a subroutine call. */
operator|!
name|stop_func_start
comment|/* If we do a call, we will be at the start of a function...  */
operator|||
name|stop_pc
operator|==
name|stop_func_start
comment|/* ...except on the Alpha with -O (and also Irix 5 and 		 perhaps others), in which we might call the address 		 after the load of gp.  Since prologues don't contain 		 calls, we can't return to within one, and we don't 		 jump back into them, so this check is OK.  */
operator|||
name|stop_pc
operator|<
name|prologue_pc
comment|/* ...and if it is a leaf function, the prologue might  		 consist of gp loading only, so the call transfers to  		 the first instruction after the prologue.  */
operator|||
operator|(
name|stop_pc
operator|==
name|prologue_pc
comment|/* Distinguish this from the case where we jump back 		     to the first instruction after the prologue, 		     within a function.  */
operator|&&
name|stop_func_start
operator|!=
name|prev_func_start
operator|)
comment|/* If we end up in certain places, it means we did a subroutine 		 call.  I'm not completely sure this is necessary now that we 		 have the above checks with stop_func_start (and now that 		 find_pc_partial_function is pickier).  */
operator|||
name|IN_SOLIB_TRAMPOLINE
argument_list|(
name|stop_pc
argument_list|,
name|stop_func_name
argument_list|)
comment|/* If none of the above apply, it is a jump within a function, 		 or a return from a subroutine.  The other case is longjmp, 		 which can no longer happen here as long as the 		 handling_longjmp stuff is working.  */
operator|)
condition|)
else|#
directive|else
comment|/* This is experimental code which greatly simplifies the subroutine call    test.  I've actually tested on the Alpha, and it works great. -Stu */
if|if
condition|(
name|in_prologue
argument_list|(
name|stop_pc
argument_list|,
name|NULL
argument_list|)
operator|||
operator|(
name|prev_func_start
operator|!=
literal|0
operator|&&
name|stop_func_start
operator|==
literal|0
operator|)
condition|)
endif|#
directive|endif
block|{
comment|/* It's a subroutine call.  */
if|if
condition|(
name|step_over_calls
operator|==
literal|0
condition|)
block|{
comment|/* I presume that step_over_calls is only 0 when we're 		 supposed to be stepping at the assembly language level 		 ("stepi").  Just stop.  */
name|stop_step
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|step_over_calls
operator|>
literal|0
condition|)
comment|/* We're doing a "next".  */
goto|goto
name|step_over_function
goto|;
comment|/* If we are in a function call trampoline (a stub between 	     the calling routine and the real function), locate the real 	     function.  That's what tells us (a) whether we want to step 	     into it at all, and (b) what prologue we want to run to 	     the end of, if we do step into it.  */
name|tmp
operator|=
name|SKIP_TRAMPOLINE_CODE
argument_list|(
name|stop_pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
literal|0
condition|)
name|stop_func_start
operator|=
name|tmp
expr_stmt|;
comment|/* If we have line number information for the function we 	     are thinking of stepping into, step into it.  	     If there are several symtabs at that PC (e.g. with include 	     files), just want to know whether *any* of them have line 	     numbers.  find_pc_line handles this.  */
block|{
name|struct
name|symtab_and_line
name|tmp_sal
decl_stmt|;
name|tmp_sal
operator|=
name|find_pc_line
argument_list|(
name|stop_func_start
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp_sal
operator|.
name|line
operator|!=
literal|0
condition|)
goto|goto
name|step_into_function
goto|;
block|}
name|step_over_function
label|:
comment|/* A subroutine call has happened.  */
block|{
comment|/* Set a special breakpoint after the return */
name|struct
name|symtab_and_line
name|sr_sal
decl_stmt|;
name|sr_sal
operator|.
name|pc
operator|=
name|ADDR_BITS_REMOVE
argument_list|(
name|SAVED_PC_AFTER_CALL
argument_list|(
name|get_current_frame
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|sr_sal
operator|.
name|symtab
operator|=
name|NULL
expr_stmt|;
name|sr_sal
operator|.
name|line
operator|=
literal|0
expr_stmt|;
name|step_resume_breakpoint
operator|=
name|set_momentary_breakpoint
argument_list|(
name|sr_sal
argument_list|,
name|get_current_frame
argument_list|()
argument_list|,
name|bp_step_resume
argument_list|)
expr_stmt|;
name|step_resume_breakpoint
operator|->
name|frame
operator|=
name|prev_frame_address
expr_stmt|;
if|if
condition|(
name|breakpoints_inserted
condition|)
name|insert_breakpoints
argument_list|()
expr_stmt|;
block|}
goto|goto
name|keep_going
goto|;
name|step_into_function
label|:
comment|/* Subroutine call with source code we should not step over. 	     Do step to the first line of code in it.  */
block|{
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|find_pc_symtab
argument_list|(
name|stop_pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|&&
name|s
operator|->
name|language
operator|!=
name|language_asm
condition|)
name|SKIP_PROLOGUE
argument_list|(
name|stop_func_start
argument_list|)
expr_stmt|;
block|}
name|sal
operator|=
name|find_pc_line
argument_list|(
name|stop_func_start
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Use the step_resume_break to step until 	     the end of the prologue, even if that involves jumps 	     (as it seems to on the vax under 4.2).  */
comment|/* If the prologue ends in the middle of a source line, 	     continue to the end of that source line (if it is still 	     within the function).  Otherwise, just go to end of prologue.  */
ifdef|#
directive|ifdef
name|PROLOGUE_FIRSTLINE_OVERLAP
comment|/* no, don't either.  It skips any code that's 	     legitimately on the first line.  */
else|#
directive|else
if|if
condition|(
name|sal
operator|.
name|end
operator|&&
name|sal
operator|.
name|pc
operator|!=
name|stop_func_start
operator|&&
name|sal
operator|.
name|end
operator|<
name|stop_func_end
condition|)
name|stop_func_start
operator|=
name|sal
operator|.
name|end
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|stop_func_start
operator|==
name|stop_pc
condition|)
block|{
comment|/* We are already there: stop now.  */
name|stop_step
operator|=
literal|1
expr_stmt|;
break|break;
block|}
else|else
comment|/* Put the step-breakpoint there and go until there. */
block|{
name|struct
name|symtab_and_line
name|sr_sal
decl_stmt|;
name|sr_sal
operator|.
name|pc
operator|=
name|stop_func_start
expr_stmt|;
name|sr_sal
operator|.
name|symtab
operator|=
name|NULL
expr_stmt|;
name|sr_sal
operator|.
name|line
operator|=
literal|0
expr_stmt|;
comment|/* Do not specify what the fp should be when we stop 		 since on some machines the prologue 		 is where the new fp value is established.  */
name|step_resume_breakpoint
operator|=
name|set_momentary_breakpoint
argument_list|(
name|sr_sal
argument_list|,
name|NULL
argument_list|,
name|bp_step_resume
argument_list|)
expr_stmt|;
if|if
condition|(
name|breakpoints_inserted
condition|)
name|insert_breakpoints
argument_list|()
expr_stmt|;
comment|/* And make sure stepping stops right away then.  */
name|step_range_end
operator|=
name|step_range_start
expr_stmt|;
block|}
goto|goto
name|keep_going
goto|;
block|}
comment|/* We've wandered out of the step range.  */
name|sal
operator|=
name|find_pc_line
argument_list|(
name|stop_pc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|step_range_end
operator|==
literal|1
condition|)
block|{
comment|/* It is stepi or nexti.  We always want to stop stepping after 	     one instruction.  */
name|stop_step
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|sal
operator|.
name|line
operator|==
literal|0
condition|)
block|{
comment|/* We have no line number information.  That means to stop 	     stepping (does this always happen right after one instruction, 	     when we do "s" in a function with no line numbers, 	     or can this happen as a result of a return or longjmp?).  */
name|stop_step
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|stop_pc
operator|==
name|sal
operator|.
name|pc
operator|&&
operator|(
name|current_line
operator|!=
name|sal
operator|.
name|line
operator|||
name|current_symtab
operator|!=
name|sal
operator|.
name|symtab
operator|)
condition|)
block|{
comment|/* We are at the start of a different line.  So stop.  Note that 	     we don't stop if we step into the middle of a different line. 	     That is said to make things like for (;;) statements work 	     better.  */
name|stop_step
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* We aren't done stepping.  	 Optimize by setting the stepping range to the line. 	 (We might not be in the original line, but if we entered a 	 new line in mid-statement, we continue stepping.  This makes 	 things like for(;;) statements work better.)  */
if|if
condition|(
name|stop_func_end
operator|&&
name|sal
operator|.
name|end
operator|>=
name|stop_func_end
condition|)
block|{
comment|/* If this is the last line of the function, don't keep stepping 	     (it would probably step us out of the function). 	     This is particularly necessary for a one-line function, 	     in which after skipping the prologue we better stop even though 	     we will be in mid-line.  */
name|stop_step
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|step_range_start
operator|=
name|sal
operator|.
name|pc
expr_stmt|;
name|step_range_end
operator|=
name|sal
operator|.
name|end
expr_stmt|;
goto|goto
name|keep_going
goto|;
name|check_sigtramp2
label|:
if|if
condition|(
name|trap_expected
operator|&&
name|IN_SIGTRAMP
argument_list|(
name|stop_pc
argument_list|,
name|stop_func_name
argument_list|)
operator|&&
operator|!
name|IN_SIGTRAMP
argument_list|(
name|prev_pc
argument_list|,
name|prev_func_name
argument_list|)
condition|)
block|{
comment|/* What has happened here is that we have just stepped the inferior 	     with a signal (because it is a signal which shouldn't make 	     us stop), thus stepping into sigtramp.  	     So we need to set a step_resume_break_address breakpoint 	     and continue until we hit it, and then step.  FIXME: This should 	     be more enduring than a step_resume breakpoint; we should know 	     that we will later need to keep going rather than re-hitting 	     the breakpoint here (see testsuite/gdb.t06/signals.exp where 	     it says "exceedingly difficult").  */
name|struct
name|symtab_and_line
name|sr_sal
decl_stmt|;
name|sr_sal
operator|.
name|pc
operator|=
name|prev_pc
expr_stmt|;
name|sr_sal
operator|.
name|symtab
operator|=
name|NULL
expr_stmt|;
name|sr_sal
operator|.
name|line
operator|=
literal|0
expr_stmt|;
comment|/* We perhaps could set the frame if we kept track of what 	     the frame corresponding to prev_pc was.  But we don't, 	     so don't.  */
name|through_sigtramp_breakpoint
operator|=
name|set_momentary_breakpoint
argument_list|(
name|sr_sal
argument_list|,
name|NULL
argument_list|,
name|bp_through_sigtramp
argument_list|)
expr_stmt|;
if|if
condition|(
name|breakpoints_inserted
condition|)
name|insert_breakpoints
argument_list|()
expr_stmt|;
name|remove_breakpoints_on_following_step
operator|=
literal|1
expr_stmt|;
name|another_trap
operator|=
literal|1
expr_stmt|;
block|}
name|keep_going
label|:
comment|/* Come to this label when you need to resume the inferior. 	 It's really much cleaner to do a goto than a maze of if-else 	 conditions.  */
comment|/* Save the pc before execution, to compare with pc after stop.  */
name|prev_pc
operator|=
name|read_pc
argument_list|()
expr_stmt|;
comment|/* Might have been DECR_AFTER_BREAK */
name|prev_func_start
operator|=
name|stop_func_start
expr_stmt|;
comment|/* Ok, since if DECR_PC_AFTER 					  BREAK is defined, the 					  original pc would not have 					  been at the start of a 					  function. */
name|prev_func_name
operator|=
name|stop_func_name
expr_stmt|;
name|prev_sp
operator|=
name|stop_sp
expr_stmt|;
name|prev_frame_address
operator|=
name|stop_frame_address
expr_stmt|;
comment|/* If we did not do break;, it means we should keep 	 running the inferior and not return to debugger.  */
if|if
condition|(
name|trap_expected
operator|&&
name|stop_signal
operator|!=
name|TARGET_SIGNAL_TRAP
condition|)
block|{
comment|/* We took a signal (which we are supposed to pass through to 	     the inferior, else we'd have done a break above) and we 	     haven't yet gotten our trap.  Simply continue.  */
name|resume
argument_list|(
name|CURRENTLY_STEPPING
argument_list|()
argument_list|,
name|stop_signal
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Either the trap was not expected, but we are continuing 	     anyway (the user asked that this signal be passed to the 	     child) 	       -- or -- 	     The signal was SIGTRAP, e.g. it was our signal, but we 	     decided we should resume from it.  	     We're going to run this baby now!  	     Insert breakpoints now, unless we are trying 	     to one-proceed past a breakpoint.  */
comment|/* If we've just finished a special step resume and we don't 	     want to hit a breakpoint, pull em out.  */
if|if
condition|(
name|step_resume_breakpoint
operator|==
name|NULL
operator|&&
name|through_sigtramp_breakpoint
operator|==
name|NULL
operator|&&
name|remove_breakpoints_on_following_step
condition|)
block|{
name|remove_breakpoints_on_following_step
operator|=
literal|0
expr_stmt|;
name|remove_breakpoints
argument_list|()
expr_stmt|;
name|breakpoints_inserted
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|breakpoints_inserted
operator|&&
operator|(
name|through_sigtramp_breakpoint
operator|!=
name|NULL
operator|||
operator|!
name|another_trap
operator|)
condition|)
block|{
name|breakpoints_failed
operator|=
name|insert_breakpoints
argument_list|()
expr_stmt|;
if|if
condition|(
name|breakpoints_failed
condition|)
break|break;
name|breakpoints_inserted
operator|=
literal|1
expr_stmt|;
block|}
name|trap_expected
operator|=
name|another_trap
expr_stmt|;
if|if
condition|(
name|stop_signal
operator|==
name|TARGET_SIGNAL_TRAP
condition|)
name|stop_signal
operator|=
name|TARGET_SIGNAL_0
expr_stmt|;
ifdef|#
directive|ifdef
name|SHIFT_INST_REGS
comment|/* I'm not sure when this following segment applies.  I do know, now, 	     that we shouldn't rewrite the regs when we were stopped by a 	     random signal from the inferior process.  */
comment|/* FIXME: Shouldn't this be based on the valid bit of the SXIP? 	     (this is only used on the 88k).  */
if|if
condition|(
operator|!
name|bpstat_explains_signal
argument_list|(
name|stop_bpstat
argument_list|)
operator|&&
operator|(
name|stop_signal
operator|!=
name|TARGET_SIGNAL_CHLD
operator|)
operator|&&
operator|!
name|stopped_by_random_signal
condition|)
name|SHIFT_INST_REGS
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* SHIFT_INST_REGS */
name|resume
argument_list|(
name|CURRENTLY_STEPPING
argument_list|()
argument_list|,
name|stop_signal
argument_list|)
expr_stmt|;
block|}
block|}
name|stop_stepping
label|:
if|if
condition|(
name|target_has_execution
condition|)
block|{
comment|/* Assuming the inferior still exists, set these up for next 	 time, just like we did above if we didn't break out of the 	 loop.  */
name|prev_pc
operator|=
name|read_pc
argument_list|()
expr_stmt|;
name|prev_func_start
operator|=
name|stop_func_start
expr_stmt|;
name|prev_func_name
operator|=
name|stop_func_name
expr_stmt|;
name|prev_sp
operator|=
name|stop_sp
expr_stmt|;
name|prev_frame_address
operator|=
name|stop_frame_address
expr_stmt|;
block|}
name|do_cleanups
argument_list|(
name|old_cleanups
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Here to return control to GDB when the inferior stops for real.    Print appropriate messages, remove breakpoints, give terminal our modes.     STOP_PRINT_FRAME nonzero means print the executing frame    (pc, function, args, file, line number and line text).    BREAKPOINTS_FAILED nonzero means stop was due to error    attempting to insert breakpoints.  */
end_comment

begin_function
name|void
name|normal_stop
parameter_list|()
block|{
comment|/* Make sure that the current_frame's pc is correct.  This      is a correction for setting up the frame info before doing      DECR_PC_AFTER_BREAK */
if|if
condition|(
name|target_has_execution
operator|&&
name|get_current_frame
argument_list|()
condition|)
operator|(
name|get_current_frame
argument_list|()
operator|)
operator|->
name|pc
operator|=
name|read_pc
argument_list|()
expr_stmt|;
if|if
condition|(
name|breakpoints_failed
condition|)
block|{
name|target_terminal_ours_for_output
argument_list|()
expr_stmt|;
name|print_sys_errmsg
argument_list|(
literal|"ptrace"
argument_list|,
name|breakpoints_failed
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Stopped; cannot insert breakpoints.\n\ The same program may be running in another process.\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|target_has_execution
operator|&&
name|breakpoints_inserted
condition|)
if|if
condition|(
name|remove_breakpoints
argument_list|()
condition|)
block|{
name|target_terminal_ours_for_output
argument_list|()
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Cannot remove breakpoints because program is no longer writable.\n\ It might be running in another process.\n\ Further execution is probably impossible.\n"
argument_list|)
expr_stmt|;
block|}
name|breakpoints_inserted
operator|=
literal|0
expr_stmt|;
comment|/* Delete the breakpoint we stopped at, if it wants to be deleted.      Delete any breakpoint that is to be deleted at the next stop.  */
name|breakpoint_auto_delete
argument_list|(
name|stop_bpstat
argument_list|)
expr_stmt|;
comment|/* If an auto-display called a function and that got a signal,      delete that auto-display to avoid an infinite recursion.  */
if|if
condition|(
name|stopped_by_random_signal
condition|)
name|disable_current_display
argument_list|()
expr_stmt|;
if|if
condition|(
name|step_multi
operator|&&
name|stop_step
condition|)
goto|goto
name|done
goto|;
name|target_terminal_ours
argument_list|()
expr_stmt|;
comment|/* Look up the hook_stop and run it if it exists.  */
if|if
condition|(
name|stop_command
operator|->
name|hook
condition|)
block|{
name|catch_errors
argument_list|(
name|hook_stop_stub
argument_list|,
operator|(
name|char
operator|*
operator|)
name|stop_command
operator|->
name|hook
argument_list|,
literal|"Error while running hook_stop:\n"
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|target_has_stack
condition|)
goto|goto
name|done
goto|;
comment|/* Select innermost stack frame except on return from a stack dummy routine,      or if the program has exited.  Print it without a level number if      we have changed functions or hit a breakpoint.  Print source line      if we have one.  */
if|if
condition|(
operator|!
name|stop_stack_dummy
condition|)
block|{
if|if
condition|(
name|stop_print_frame
condition|)
block|{
name|int
name|source_only
decl_stmt|;
name|source_only
operator|=
name|bpstat_print
argument_list|(
name|stop_bpstat
argument_list|)
expr_stmt|;
name|source_only
operator|=
name|source_only
operator|||
operator|(
name|stop_step
operator|&&
name|step_frame_address
operator|==
name|stop_frame_address
operator|&&
name|step_start_function
operator|==
name|find_pc_function
argument_list|(
name|stop_pc
argument_list|)
operator|)
expr_stmt|;
name|print_stack_frame
argument_list|(
name|selected_frame
argument_list|,
operator|-
literal|1
argument_list|,
name|source_only
condition|?
operator|-
literal|1
else|:
literal|1
argument_list|)
expr_stmt|;
comment|/* Display the auto-display expressions.  */
name|do_displays
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Save the function value return registers, if we care.      We might be about to restore their previous contents.  */
if|if
condition|(
name|proceed_to_finish
condition|)
name|read_register_bytes
argument_list|(
literal|0
argument_list|,
name|stop_registers
argument_list|,
name|REGISTER_BYTES
argument_list|)
expr_stmt|;
if|if
condition|(
name|stop_stack_dummy
condition|)
block|{
comment|/* Pop the empty frame that contains the stack dummy.          POP_FRAME ends with a setting of the current frame, so we 	 can use that next. */
name|POP_FRAME
expr_stmt|;
comment|/* Set stop_pc to what it was before we called the function.  Can't rely 	 on restore_inferior_status because that only gets called if we don't 	 stop in the called function.  */
name|stop_pc
operator|=
name|read_pc
argument_list|()
expr_stmt|;
name|select_frame
argument_list|(
name|get_current_frame
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|done
label|:
name|annotate_stopped
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|hook_stop_stub
parameter_list|(
name|cmd
parameter_list|)
name|char
modifier|*
name|cmd
decl_stmt|;
block|{
name|execute_user_command
argument_list|(
operator|(
expr|struct
name|cmd_list_element
operator|*
operator|)
name|cmd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|signal_stop_state
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
return|return
name|signal_stop
index|[
name|signo
index|]
return|;
block|}
end_function

begin_function
name|int
name|signal_print_state
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
return|return
name|signal_print
index|[
name|signo
index|]
return|;
block|}
end_function

begin_function
name|int
name|signal_pass_state
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
return|return
name|signal_program
index|[
name|signo
index|]
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sig_print_header
parameter_list|()
block|{
name|printf_filtered
argument_list|(
literal|"\ Signal        Stop\tPrint\tPass to program\tDescription\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sig_print_info
parameter_list|(
name|oursig
parameter_list|)
name|enum
name|target_signal
name|oursig
decl_stmt|;
block|{
name|char
modifier|*
name|name
init|=
name|target_signal_to_name
argument_list|(
name|oursig
argument_list|)
decl_stmt|;
name|printf_filtered
argument_list|(
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%*.*s "
argument_list|,
literal|13
operator|-
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
literal|13
operator|-
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"                 "
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%s\t"
argument_list|,
name|signal_stop
index|[
name|oursig
index|]
condition|?
literal|"Yes"
else|:
literal|"No"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%s\t"
argument_list|,
name|signal_print
index|[
name|oursig
index|]
condition|?
literal|"Yes"
else|:
literal|"No"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%s\t\t"
argument_list|,
name|signal_program
index|[
name|oursig
index|]
condition|?
literal|"Yes"
else|:
literal|"No"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%s\n"
argument_list|,
name|target_signal_to_string
argument_list|(
name|oursig
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Specify how various signals in the inferior should be handled.  */
end_comment

begin_function
specifier|static
name|void
name|handle_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|int
name|digits
decl_stmt|,
name|wordlen
decl_stmt|;
name|int
name|sigfirst
decl_stmt|,
name|signum
decl_stmt|,
name|siglast
decl_stmt|;
name|enum
name|target_signal
name|oursig
decl_stmt|;
name|int
name|allsigs
decl_stmt|;
name|int
name|nsigs
decl_stmt|;
name|unsigned
name|char
modifier|*
name|sigs
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
if|if
condition|(
name|args
operator|==
name|NULL
condition|)
block|{
name|error_no_arg
argument_list|(
literal|"signal to handle"
argument_list|)
expr_stmt|;
block|}
comment|/* Allocate and zero an array of flags for which signals to handle. */
name|nsigs
operator|=
operator|(
name|int
operator|)
name|TARGET_SIGNAL_LAST
expr_stmt|;
name|sigs
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|nsigs
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|sigs
argument_list|,
literal|0
argument_list|,
name|nsigs
argument_list|)
expr_stmt|;
comment|/* Break the command line up into args. */
name|argv
operator|=
name|buildargv
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|argv
operator|==
name|NULL
condition|)
block|{
name|nomem
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|freeargv
argument_list|,
operator|(
name|char
operator|*
operator|)
name|argv
argument_list|)
expr_stmt|;
comment|/* Walk through the args, looking for signal oursigs, signal names, and      actions.  Signal numbers and signal names may be interspersed with      actions, with the actions being performed for all signals cumulatively      specified.  Signal ranges can be specified as<LOW>-<HIGH>. */
while|while
condition|(
operator|*
name|argv
operator|!=
name|NULL
condition|)
block|{
name|wordlen
operator|=
name|strlen
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
for|for
control|(
name|digits
operator|=
literal|0
init|;
name|isdigit
argument_list|(
operator|(
operator|*
name|argv
operator|)
index|[
name|digits
index|]
argument_list|)
condition|;
name|digits
operator|++
control|)
block|{
empty_stmt|;
block|}
name|allsigs
operator|=
literal|0
expr_stmt|;
name|sigfirst
operator|=
name|siglast
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|wordlen
operator|>=
literal|1
operator|&&
operator|!
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"all"
argument_list|,
name|wordlen
argument_list|)
condition|)
block|{
comment|/* Apply action to all signals except those used by the 	     debugger.  Silently skip those. */
name|allsigs
operator|=
literal|1
expr_stmt|;
name|sigfirst
operator|=
literal|0
expr_stmt|;
name|siglast
operator|=
name|nsigs
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wordlen
operator|>=
literal|1
operator|&&
operator|!
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"stop"
argument_list|,
name|wordlen
argument_list|)
condition|)
block|{
name|SET_SIGS
argument_list|(
name|nsigs
argument_list|,
name|sigs
argument_list|,
name|signal_stop
argument_list|)
expr_stmt|;
name|SET_SIGS
argument_list|(
name|nsigs
argument_list|,
name|sigs
argument_list|,
name|signal_print
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wordlen
operator|>=
literal|1
operator|&&
operator|!
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"ignore"
argument_list|,
name|wordlen
argument_list|)
condition|)
block|{
name|UNSET_SIGS
argument_list|(
name|nsigs
argument_list|,
name|sigs
argument_list|,
name|signal_program
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wordlen
operator|>=
literal|2
operator|&&
operator|!
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"print"
argument_list|,
name|wordlen
argument_list|)
condition|)
block|{
name|SET_SIGS
argument_list|(
name|nsigs
argument_list|,
name|sigs
argument_list|,
name|signal_print
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wordlen
operator|>=
literal|2
operator|&&
operator|!
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"pass"
argument_list|,
name|wordlen
argument_list|)
condition|)
block|{
name|SET_SIGS
argument_list|(
name|nsigs
argument_list|,
name|sigs
argument_list|,
name|signal_program
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wordlen
operator|>=
literal|3
operator|&&
operator|!
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"nostop"
argument_list|,
name|wordlen
argument_list|)
condition|)
block|{
name|UNSET_SIGS
argument_list|(
name|nsigs
argument_list|,
name|sigs
argument_list|,
name|signal_stop
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wordlen
operator|>=
literal|3
operator|&&
operator|!
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"noignore"
argument_list|,
name|wordlen
argument_list|)
condition|)
block|{
name|SET_SIGS
argument_list|(
name|nsigs
argument_list|,
name|sigs
argument_list|,
name|signal_program
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wordlen
operator|>=
literal|4
operator|&&
operator|!
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"noprint"
argument_list|,
name|wordlen
argument_list|)
condition|)
block|{
name|UNSET_SIGS
argument_list|(
name|nsigs
argument_list|,
name|sigs
argument_list|,
name|signal_print
argument_list|)
expr_stmt|;
name|UNSET_SIGS
argument_list|(
name|nsigs
argument_list|,
name|sigs
argument_list|,
name|signal_stop
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wordlen
operator|>=
literal|4
operator|&&
operator|!
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"nopass"
argument_list|,
name|wordlen
argument_list|)
condition|)
block|{
name|UNSET_SIGS
argument_list|(
name|nsigs
argument_list|,
name|sigs
argument_list|,
name|signal_program
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|digits
operator|>
literal|0
condition|)
block|{
comment|/* It is numeric.  The numeric signal refers to our own internal 	     signal numbering from target.h, not to host/target signal number. 	     This is a feature; users really should be using symbolic names 	     anyway, and the common ones like SIGHUP, SIGINT, SIGALRM, etc. 	     will work right anyway.  */
name|sigfirst
operator|=
name|siglast
operator|=
name|atoi
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|argv
operator|)
index|[
name|digits
index|]
operator|==
literal|'-'
condition|)
block|{
name|siglast
operator|=
name|atoi
argument_list|(
operator|(
operator|*
name|argv
operator|)
operator|+
name|digits
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sigfirst
operator|>
name|siglast
condition|)
block|{
comment|/* Bet he didn't figure we'd think of this case... */
name|signum
operator|=
name|sigfirst
expr_stmt|;
name|sigfirst
operator|=
name|siglast
expr_stmt|;
name|siglast
operator|=
name|signum
expr_stmt|;
block|}
if|if
condition|(
name|sigfirst
operator|<
literal|0
operator|||
name|sigfirst
operator|>=
name|nsigs
condition|)
block|{
name|error
argument_list|(
literal|"Signal %d not in range 0-%d"
argument_list|,
name|sigfirst
argument_list|,
name|nsigs
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|siglast
operator|<
literal|0
operator|||
name|siglast
operator|>=
name|nsigs
condition|)
block|{
name|error
argument_list|(
literal|"Signal %d not in range 0-%d"
argument_list|,
name|siglast
argument_list|,
name|nsigs
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|oursig
operator|=
name|target_signal_from_name
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|oursig
operator|!=
name|TARGET_SIGNAL_UNKNOWN
condition|)
block|{
name|sigfirst
operator|=
name|siglast
operator|=
operator|(
name|int
operator|)
name|oursig
expr_stmt|;
block|}
else|else
block|{
comment|/* Not a number and not a recognized flag word => complain.  */
name|error
argument_list|(
literal|"Unrecognized or ambiguous flag word: \"%s\"."
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If any signal numbers or symbol names were found, set flags for 	 which signals to apply actions to. */
for|for
control|(
name|signum
operator|=
name|sigfirst
init|;
name|signum
operator|>=
literal|0
operator|&&
name|signum
operator|<=
name|siglast
condition|;
name|signum
operator|++
control|)
block|{
switch|switch
condition|(
operator|(
expr|enum
name|target_signal
operator|)
name|signum
condition|)
block|{
case|case
name|TARGET_SIGNAL_TRAP
case|:
case|case
name|TARGET_SIGNAL_INT
case|:
if|if
condition|(
operator|!
name|allsigs
operator|&&
operator|!
name|sigs
index|[
name|signum
index|]
condition|)
block|{
if|if
condition|(
name|query
argument_list|(
literal|"%s is used by the debugger.\n\ Are you sure you want to change it? "
argument_list|,
name|target_signal_to_name
argument_list|(
operator|(
expr|enum
name|target_signal
operator|)
name|signum
argument_list|)
argument_list|)
condition|)
block|{
name|sigs
index|[
name|signum
index|]
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|printf_unfiltered
argument_list|(
literal|"Not confirmed, unchanged.\n"
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|sigs
index|[
name|signum
index|]
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|argv
operator|++
expr_stmt|;
block|}
name|target_notice_signals
argument_list|(
name|inferior_pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
block|{
comment|/* Show the results.  */
name|sig_print_header
argument_list|()
expr_stmt|;
for|for
control|(
name|signum
operator|=
literal|0
init|;
name|signum
operator|<
name|nsigs
condition|;
name|signum
operator|++
control|)
block|{
if|if
condition|(
name|sigs
index|[
name|signum
index|]
condition|)
block|{
name|sig_print_info
argument_list|(
name|signum
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print current contents of the tables set by the handle command.    It is possible we should just be printing signals actually used    by the current target (but for things to work right when switching    targets, all signals should be in the signal tables).  */
end_comment

begin_function
specifier|static
name|void
name|signals_info
parameter_list|(
name|signum_exp
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|signum_exp
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|enum
name|target_signal
name|oursig
decl_stmt|;
name|sig_print_header
argument_list|()
expr_stmt|;
if|if
condition|(
name|signum_exp
condition|)
block|{
comment|/* First see if this is a symbol name.  */
name|oursig
operator|=
name|target_signal_from_name
argument_list|(
name|signum_exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|oursig
operator|==
name|TARGET_SIGNAL_UNKNOWN
condition|)
block|{
comment|/* Nope, maybe it's an address which evaluates to a signal 	     number.  */
comment|/* The numeric signal refers to our own internal 	     signal numbering from target.h, not to host/target signal number. 	     This is a feature; users really should be using symbolic names 	     anyway, and the common ones like SIGHUP, SIGINT, SIGALRM, etc. 	     will work right anyway.  */
name|int
name|i
init|=
name|parse_and_eval_address
argument_list|(
name|signum_exp
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|>=
operator|(
name|int
operator|)
name|TARGET_SIGNAL_LAST
operator|||
name|i
operator|<
literal|0
operator|||
name|i
operator|==
operator|(
name|int
operator|)
name|TARGET_SIGNAL_UNKNOWN
operator|||
name|i
operator|==
operator|(
name|int
operator|)
name|TARGET_SIGNAL_DEFAULT
condition|)
name|error
argument_list|(
literal|"Signal number out of bounds."
argument_list|)
expr_stmt|;
name|oursig
operator|=
operator|(
expr|enum
name|target_signal
operator|)
name|i
expr_stmt|;
block|}
name|sig_print_info
argument_list|(
name|oursig
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* These ugly casts brought to you by the native VAX compiler.  */
for|for
control|(
name|oursig
operator|=
name|TARGET_SIGNAL_FIRST
init|;
operator|(
name|int
operator|)
name|oursig
operator|<
operator|(
name|int
operator|)
name|TARGET_SIGNAL_LAST
condition|;
name|oursig
operator|=
operator|(
expr|enum
name|target_signal
operator|)
operator|(
operator|(
name|int
operator|)
name|oursig
operator|+
literal|1
operator|)
control|)
block|{
name|QUIT
expr_stmt|;
if|if
condition|(
name|oursig
operator|!=
name|TARGET_SIGNAL_UNKNOWN
operator|&&
name|oursig
operator|!=
name|TARGET_SIGNAL_DEFAULT
operator|&&
name|oursig
operator|!=
name|TARGET_SIGNAL_0
condition|)
name|sig_print_info
argument_list|(
name|oursig
argument_list|)
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"\nUse the \"handle\" command to change these tables.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Save all of the information associated with the inferior<==>gdb    connection.  INF_STATUS is a pointer to a "struct inferior_status"    (defined in inferior.h).  */
end_comment

begin_function
name|void
name|save_inferior_status
parameter_list|(
name|inf_status
parameter_list|,
name|restore_stack_info
parameter_list|)
name|struct
name|inferior_status
modifier|*
name|inf_status
decl_stmt|;
name|int
name|restore_stack_info
decl_stmt|;
block|{
name|inf_status
operator|->
name|stop_signal
operator|=
name|stop_signal
expr_stmt|;
name|inf_status
operator|->
name|stop_pc
operator|=
name|stop_pc
expr_stmt|;
name|inf_status
operator|->
name|stop_frame_address
operator|=
name|stop_frame_address
expr_stmt|;
name|inf_status
operator|->
name|stop_step
operator|=
name|stop_step
expr_stmt|;
name|inf_status
operator|->
name|stop_stack_dummy
operator|=
name|stop_stack_dummy
expr_stmt|;
name|inf_status
operator|->
name|stopped_by_random_signal
operator|=
name|stopped_by_random_signal
expr_stmt|;
name|inf_status
operator|->
name|trap_expected
operator|=
name|trap_expected
expr_stmt|;
name|inf_status
operator|->
name|step_range_start
operator|=
name|step_range_start
expr_stmt|;
name|inf_status
operator|->
name|step_range_end
operator|=
name|step_range_end
expr_stmt|;
name|inf_status
operator|->
name|step_frame_address
operator|=
name|step_frame_address
expr_stmt|;
name|inf_status
operator|->
name|step_over_calls
operator|=
name|step_over_calls
expr_stmt|;
name|inf_status
operator|->
name|stop_after_trap
operator|=
name|stop_after_trap
expr_stmt|;
name|inf_status
operator|->
name|stop_soon_quietly
operator|=
name|stop_soon_quietly
expr_stmt|;
comment|/* Save original bpstat chain here; replace it with copy of chain.      If caller's caller is walking the chain, they'll be happier if we      hand them back the original chain when restore_i_s is called.  */
name|inf_status
operator|->
name|stop_bpstat
operator|=
name|stop_bpstat
expr_stmt|;
name|stop_bpstat
operator|=
name|bpstat_copy
argument_list|(
name|stop_bpstat
argument_list|)
expr_stmt|;
name|inf_status
operator|->
name|breakpoint_proceeded
operator|=
name|breakpoint_proceeded
expr_stmt|;
name|inf_status
operator|->
name|restore_stack_info
operator|=
name|restore_stack_info
expr_stmt|;
name|inf_status
operator|->
name|proceed_to_finish
operator|=
name|proceed_to_finish
expr_stmt|;
name|memcpy
argument_list|(
name|inf_status
operator|->
name|stop_registers
argument_list|,
name|stop_registers
argument_list|,
name|REGISTER_BYTES
argument_list|)
expr_stmt|;
name|read_register_bytes
argument_list|(
literal|0
argument_list|,
name|inf_status
operator|->
name|registers
argument_list|,
name|REGISTER_BYTES
argument_list|)
expr_stmt|;
name|record_selected_frame
argument_list|(
operator|&
operator|(
name|inf_status
operator|->
name|selected_frame_address
operator|)
argument_list|,
operator|&
operator|(
name|inf_status
operator|->
name|selected_level
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_struct
struct|struct
name|restore_selected_frame_args
block|{
name|FRAME_ADDR
name|frame_address
decl_stmt|;
name|int
name|level
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|restore_selected_frame
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Restore the selected frame.  args is really a struct    restore_selected_frame_args * (declared as char * for catch_errors)    telling us what frame to restore.  Returns 1 for success, or 0 for    failure.  An error message will have been printed on error.  */
end_comment

begin_function
specifier|static
name|int
name|restore_selected_frame
parameter_list|(
name|args
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
block|{
name|struct
name|restore_selected_frame_args
modifier|*
name|fr
init|=
operator|(
expr|struct
name|restore_selected_frame_args
operator|*
operator|)
name|args
decl_stmt|;
name|FRAME
name|fid
decl_stmt|;
name|int
name|level
init|=
name|fr
operator|->
name|level
decl_stmt|;
name|fid
operator|=
name|find_relative_frame
argument_list|(
name|get_current_frame
argument_list|()
argument_list|,
operator|&
name|level
argument_list|)
expr_stmt|;
comment|/* If inf_status->selected_frame_address is NULL, there was no      previously selected frame.  */
if|if
condition|(
name|fid
operator|==
literal|0
operator|||
name|FRAME_FP
argument_list|(
name|fid
argument_list|)
operator|!=
name|fr
operator|->
name|frame_address
operator|||
name|level
operator|!=
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"Unable to restore previously selected frame.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|select_frame
argument_list|(
name|fid
argument_list|,
name|fr
operator|->
name|level
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|void
name|restore_inferior_status
parameter_list|(
name|inf_status
parameter_list|)
name|struct
name|inferior_status
modifier|*
name|inf_status
decl_stmt|;
block|{
name|stop_signal
operator|=
name|inf_status
operator|->
name|stop_signal
expr_stmt|;
name|stop_pc
operator|=
name|inf_status
operator|->
name|stop_pc
expr_stmt|;
name|stop_frame_address
operator|=
name|inf_status
operator|->
name|stop_frame_address
expr_stmt|;
name|stop_step
operator|=
name|inf_status
operator|->
name|stop_step
expr_stmt|;
name|stop_stack_dummy
operator|=
name|inf_status
operator|->
name|stop_stack_dummy
expr_stmt|;
name|stopped_by_random_signal
operator|=
name|inf_status
operator|->
name|stopped_by_random_signal
expr_stmt|;
name|trap_expected
operator|=
name|inf_status
operator|->
name|trap_expected
expr_stmt|;
name|step_range_start
operator|=
name|inf_status
operator|->
name|step_range_start
expr_stmt|;
name|step_range_end
operator|=
name|inf_status
operator|->
name|step_range_end
expr_stmt|;
name|step_frame_address
operator|=
name|inf_status
operator|->
name|step_frame_address
expr_stmt|;
name|step_over_calls
operator|=
name|inf_status
operator|->
name|step_over_calls
expr_stmt|;
name|stop_after_trap
operator|=
name|inf_status
operator|->
name|stop_after_trap
expr_stmt|;
name|stop_soon_quietly
operator|=
name|inf_status
operator|->
name|stop_soon_quietly
expr_stmt|;
name|bpstat_clear
argument_list|(
operator|&
name|stop_bpstat
argument_list|)
expr_stmt|;
name|stop_bpstat
operator|=
name|inf_status
operator|->
name|stop_bpstat
expr_stmt|;
name|breakpoint_proceeded
operator|=
name|inf_status
operator|->
name|breakpoint_proceeded
expr_stmt|;
name|proceed_to_finish
operator|=
name|inf_status
operator|->
name|proceed_to_finish
expr_stmt|;
name|memcpy
argument_list|(
name|stop_registers
argument_list|,
name|inf_status
operator|->
name|stop_registers
argument_list|,
name|REGISTER_BYTES
argument_list|)
expr_stmt|;
comment|/* The inferior can be gone if the user types "print exit(0)"      (and perhaps other times).  */
if|if
condition|(
name|target_has_execution
condition|)
name|write_register_bytes
argument_list|(
literal|0
argument_list|,
name|inf_status
operator|->
name|registers
argument_list|,
name|REGISTER_BYTES
argument_list|)
expr_stmt|;
comment|/* The inferior can be gone if the user types "print exit(0)"      (and perhaps other times).  */
comment|/* FIXME: If we are being called after stopping in a function which      is called from gdb, we should not be trying to restore the      selected frame; it just prints a spurious error message (The      message is useful, however, in detecting bugs in gdb (like if gdb      clobbers the stack)).  In fact, should we be restoring the      inferior status at all in that case?  .  */
if|if
condition|(
name|target_has_stack
operator|&&
name|inf_status
operator|->
name|restore_stack_info
condition|)
block|{
name|struct
name|restore_selected_frame_args
name|fr
decl_stmt|;
name|fr
operator|.
name|level
operator|=
name|inf_status
operator|->
name|selected_level
expr_stmt|;
name|fr
operator|.
name|frame_address
operator|=
name|inf_status
operator|->
name|selected_frame_address
expr_stmt|;
comment|/* The point of catch_errors is that if the stack is clobbered, 	 walking the stack might encounter a garbage pointer and error() 	 trying to dereference it.  */
if|if
condition|(
name|catch_errors
argument_list|(
name|restore_selected_frame
argument_list|,
operator|&
name|fr
argument_list|,
literal|"Unable to restore previously selected frame:\n"
argument_list|,
name|RETURN_MASK_ERROR
argument_list|)
operator|==
literal|0
condition|)
comment|/* Error in restoring the selected frame.  Select the innermost 	   frame.  */
name|select_frame
argument_list|(
name|get_current_frame
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|_initialize_infrun
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|numsigs
decl_stmt|;
name|add_info
argument_list|(
literal|"signals"
argument_list|,
name|signals_info
argument_list|,
literal|"What debugger does when program gets various signals.\n\ Specify a signal number as argument to print info on that signal only."
argument_list|)
expr_stmt|;
name|add_info_alias
argument_list|(
literal|"handle"
argument_list|,
literal|"signals"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"handle"
argument_list|,
name|class_run
argument_list|,
name|handle_command
argument_list|,
literal|"Specify how to handle a signal.\n\ Args are signal numbers and actions to apply to those signals.\n\ Signal numbers may be numeric (ex. 11) or symbolic (ex. SIGSEGV).\n\ Numeric ranges may be specified with the form LOW-HIGH (ex. 14-21).\n\ The special arg \"all\" is recognized to mean all signals except those\n\ used by the debugger, typically SIGTRAP and SIGINT.\n\ Recognized actions include \"stop\", \"nostop\", \"print\", \"noprint\",\n\ \"pass\", \"nopass\", \"ignore\", or \"noignore\".\n\ Stop means reenter debugger if this signal happens (implies print).\n\ Print means print a message if this signal happens.\n\ Pass means let program see this signal; otherwise program doesn't know.\n\ Ignore is a synonym for nopass and noignore is a synonym for pass.\n\ Pass and Stop may be combined."
argument_list|)
expr_stmt|;
name|stop_command
operator|=
name|add_cmd
argument_list|(
literal|"stop"
argument_list|,
name|class_obscure
argument_list|,
name|not_just_help_class_command
argument_list|,
literal|"There is no `stop' command, but you can set a hook on `stop'.\n\ This allows you to set a list of commands to be run each time execution\n\ of the program stops."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|numsigs
operator|=
operator|(
name|int
operator|)
name|TARGET_SIGNAL_LAST
expr_stmt|;
name|signal_stop
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|signal_stop
index|[
literal|0
index|]
argument_list|)
operator|*
name|numsigs
argument_list|)
expr_stmt|;
name|signal_print
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|signal_print
index|[
literal|0
index|]
argument_list|)
operator|*
name|numsigs
argument_list|)
expr_stmt|;
name|signal_program
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|signal_program
index|[
literal|0
index|]
argument_list|)
operator|*
name|numsigs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numsigs
condition|;
name|i
operator|++
control|)
block|{
name|signal_stop
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|signal_print
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|signal_program
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Signals caused by debugger's own actions      should not be given to the program afterwards.  */
name|signal_program
index|[
name|TARGET_SIGNAL_TRAP
index|]
operator|=
literal|0
expr_stmt|;
name|signal_program
index|[
name|TARGET_SIGNAL_INT
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Signals that are not errors should not normally enter the debugger.  */
name|signal_stop
index|[
name|TARGET_SIGNAL_ALRM
index|]
operator|=
literal|0
expr_stmt|;
name|signal_print
index|[
name|TARGET_SIGNAL_ALRM
index|]
operator|=
literal|0
expr_stmt|;
name|signal_stop
index|[
name|TARGET_SIGNAL_VTALRM
index|]
operator|=
literal|0
expr_stmt|;
name|signal_print
index|[
name|TARGET_SIGNAL_VTALRM
index|]
operator|=
literal|0
expr_stmt|;
name|signal_stop
index|[
name|TARGET_SIGNAL_PROF
index|]
operator|=
literal|0
expr_stmt|;
name|signal_print
index|[
name|TARGET_SIGNAL_PROF
index|]
operator|=
literal|0
expr_stmt|;
name|signal_stop
index|[
name|TARGET_SIGNAL_CHLD
index|]
operator|=
literal|0
expr_stmt|;
name|signal_print
index|[
name|TARGET_SIGNAL_CHLD
index|]
operator|=
literal|0
expr_stmt|;
name|signal_stop
index|[
name|TARGET_SIGNAL_IO
index|]
operator|=
literal|0
expr_stmt|;
name|signal_print
index|[
name|TARGET_SIGNAL_IO
index|]
operator|=
literal|0
expr_stmt|;
name|signal_stop
index|[
name|TARGET_SIGNAL_POLL
index|]
operator|=
literal|0
expr_stmt|;
name|signal_print
index|[
name|TARGET_SIGNAL_POLL
index|]
operator|=
literal|0
expr_stmt|;
name|signal_stop
index|[
name|TARGET_SIGNAL_URG
index|]
operator|=
literal|0
expr_stmt|;
name|signal_print
index|[
name|TARGET_SIGNAL_URG
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

end_unit

