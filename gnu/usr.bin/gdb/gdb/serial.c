begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Generic serial interface routines    Copyright 1992, 1993 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"serial.h"
end_include

begin_comment
comment|/* Linked list of serial I/O handlers */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|serial_ops
modifier|*
name|serial_ops_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the last serial stream opened.  Used by connect command. */
end_comment

begin_decl_stmt
specifier|static
name|serial_t
name|last_serial_opened
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|struct
name|serial_ops
modifier|*
name|serial_interface_lookup
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|serial_ops
modifier|*
name|ops
decl_stmt|;
for|for
control|(
name|ops
operator|=
name|serial_ops_list
init|;
name|ops
condition|;
name|ops
operator|=
name|ops
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|ops
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|ops
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|serial_add_interface
parameter_list|(
name|optable
parameter_list|)
name|struct
name|serial_ops
modifier|*
name|optable
decl_stmt|;
block|{
name|optable
operator|->
name|next
operator|=
name|serial_ops_list
expr_stmt|;
name|serial_ops_list
operator|=
name|optable
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Open up a device or a network socket, depending upon the syntax of NAME. */
end_comment

begin_function
name|serial_t
name|serial_open
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|serial_t
name|scb
decl_stmt|;
name|struct
name|serial_ops
modifier|*
name|ops
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"pc"
argument_list|)
operator|==
literal|0
condition|)
name|ops
operator|=
name|serial_interface_lookup
argument_list|(
literal|"pc"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strchr
argument_list|(
name|name
argument_list|,
literal|':'
argument_list|)
condition|)
name|ops
operator|=
name|serial_interface_lookup
argument_list|(
literal|"tcp"
argument_list|)
expr_stmt|;
else|else
name|ops
operator|=
name|serial_interface_lookup
argument_list|(
literal|"hardwire"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ops
condition|)
return|return
name|NULL
return|;
name|scb
operator|=
operator|(
name|serial_t
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|_serial_t
argument_list|)
argument_list|)
expr_stmt|;
name|scb
operator|->
name|ops
operator|=
name|ops
expr_stmt|;
name|scb
operator|->
name|bufcnt
operator|=
literal|0
expr_stmt|;
name|scb
operator|->
name|bufp
operator|=
name|scb
operator|->
name|buf
expr_stmt|;
if|if
condition|(
name|scb
operator|->
name|ops
operator|->
name|open
argument_list|(
name|scb
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|scb
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|last_serial_opened
operator|=
name|scb
expr_stmt|;
return|return
name|scb
return|;
block|}
end_function

begin_function
name|serial_t
name|serial_fdopen
parameter_list|(
name|fd
parameter_list|)
specifier|const
name|int
name|fd
decl_stmt|;
block|{
name|serial_t
name|scb
decl_stmt|;
name|struct
name|serial_ops
modifier|*
name|ops
decl_stmt|;
name|ops
operator|=
name|serial_interface_lookup
argument_list|(
literal|"hardwire"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ops
condition|)
return|return
name|NULL
return|;
name|scb
operator|=
operator|(
name|serial_t
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|_serial_t
argument_list|)
argument_list|)
expr_stmt|;
name|scb
operator|->
name|ops
operator|=
name|ops
expr_stmt|;
name|scb
operator|->
name|bufcnt
operator|=
literal|0
expr_stmt|;
name|scb
operator|->
name|bufp
operator|=
name|scb
operator|->
name|buf
expr_stmt|;
name|scb
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
name|last_serial_opened
operator|=
name|scb
expr_stmt|;
return|return
name|scb
return|;
block|}
end_function

begin_function
name|void
name|serial_close
parameter_list|(
name|scb
parameter_list|)
name|serial_t
name|scb
decl_stmt|;
block|{
name|last_serial_opened
operator|=
name|NULL
expr_stmt|;
comment|/* This is bogus.  It's not our fault if you pass us a bad scb...!  Rob, you    should fix your code instead.  */
if|if
condition|(
operator|!
name|scb
condition|)
return|return;
name|scb
operator|->
name|ops
operator|->
name|close
argument_list|(
name|scb
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|scb
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* The connect command is #if 0 because I hadn't thought of an elegant way to wait for I/O on two serial_t's simultaneously.  Two solutions came to mind:  	1) Fork, and have have one fork handle the to user direction, 	   and have the other hand the to target direction.  This 	   obviously won't cut it for MSDOS.  	2) Use something like select.  This assumes that stdin and 	   the target side can both be waited on via the same 	   mechanism.  This may not be true for DOS, if GDB is 	   talking to the target via a TCP socket. -grossman, 8 Jun 93 */
end_comment

begin_comment
comment|/* Connect the user directly to the remote system.  This command acts just like    the 'cu' or 'tip' command.  Use<CR>~. or<CR>~^D to break out.  */
end_comment

begin_comment
unit|static serial_t tty_desc;
comment|/* Controlling terminal */
end_comment

begin_comment
unit|static void cleanup_tty(ttystate)      serial_ttystate ttystate; {   printf_unfiltered ("\r\n[Exiting connect mode]\r\n");   SERIAL_SET_TTY_STATE (tty_desc, ttystate);   free (ttystate);   SERIAL_CLOSE (tty_desc); }  static void connect_command (args, fromtty)      char	*args;      int	fromtty; {   int c;   char cur_esc = 0;   serial_ttystate ttystate;   serial_t port_desc;
comment|/* TTY port */
end_comment

begin_comment
unit|dont_repeat();    if (args)     fprintf_unfiltered(gdb_stderr, "This command takes no args.  They have been ignored.\n");    printf_unfiltered("[Entering connect mode.  Use ~. or ~^D to escape]\n");    tty_desc = SERIAL_FDOPEN (0);   port_desc = last_serial_opened;    ttystate = SERIAL_GET_TTY_STATE (tty_desc);    SERIAL_RAW (tty_desc);   SERIAL_RAW (port_desc);    make_cleanup (cleanup_tty, ttystate);    while (1)     {       int mask;        mask = SERIAL_WAIT_2 (tty_desc, port_desc, -1);        if (mask& 2) 	{
comment|/* tty input */
end_comment

begin_comment
unit|char cx;  	  while (1) 	    { 	      c = SERIAL_READCHAR(tty_desc, 0);  	      if (c == SERIAL_TIMEOUT) 		  break;  	      if (c< 0) 		perror_with_name("connect");  	      cx = c; 	      SERIAL_WRITE(port_desc,&cx, 1);  	      switch (cur_esc) 		{ 		case 0: 		  if (c == '\r') 		    cur_esc = c; 		  break; 		case '\r': 		  if (c == '~') 		    cur_esc = c; 		  else 		    cur_esc = 0; 		  break; 		case '~': 		  if (c == '.' || c == '\004') 		    return; 		  else 		    cur_esc = 0; 		} 	    } 	}        if (mask& 1) 	{
comment|/* Port input */
end_comment

begin_endif
unit|char cx;  	  while (1) 	    { 	      c = SERIAL_READCHAR(port_desc, 0);  	      if (c == SERIAL_TIMEOUT) 		  break;  	      if (c< 0) 		perror_with_name("connect");  	      cx = c;  	      SERIAL_WRITE(tty_desc,&cx, 1); 	    } 	}     } }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_function
name|void
name|_initialize_serial
parameter_list|()
block|{
if|#
directive|if
literal|0
block|add_com ("connect", class_obscure, connect_command, 	   "Connect the terminal directly up to the command monitor.\n\ Use<CR>~. or<CR>~^D to break out.");
endif|#
directive|endif
comment|/* 0 */
block|}
end_function

end_unit

