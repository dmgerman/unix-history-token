begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Low level packing and unpacking of values for GDB, the GNU Debugger.    Copyright 1986, 1987, 1989, 1991 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_comment
comment|/* Local function prototypes. */
end_comment

begin_decl_stmt
specifier|static
name|value
name|value_headof
name|PARAMS
argument_list|(
operator|(
name|value
operator|,
expr|struct
name|type
operator|*
operator|,
expr|struct
name|type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|show_values
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|show_convenience
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The value-history records all the values printed    by print commands during this session.  Each chunk    records 60 consecutive values.  The first chunk on    the chain records the most recent values.    The total number of values is in value_history_count.  */
end_comment

begin_define
define|#
directive|define
name|VALUE_HISTORY_CHUNK
value|60
end_define

begin_struct
struct|struct
name|value_history_chunk
block|{
name|struct
name|value_history_chunk
modifier|*
name|next
decl_stmt|;
name|value
name|values
index|[
name|VALUE_HISTORY_CHUNK
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Chain of chunks now in use.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|value_history_chunk
modifier|*
name|value_history_chain
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|value_history_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Abs number of last entry stored */
end_comment

begin_escape
end_escape

begin_comment
comment|/* List of all value objects currently allocated    (except for those released by calls to release_value)    This is so they can be freed after each command.  */
end_comment

begin_decl_stmt
specifier|static
name|value
name|all_values
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Allocate a  value  that has the correct length for type TYPE.  */
end_comment

begin_function
name|value
name|allocate_value
parameter_list|(
name|type
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
block|{
specifier|register
name|value
name|val
decl_stmt|;
name|check_stub_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
name|value
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|value
argument_list|)
operator|+
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|VALUE_NEXT
argument_list|(
name|val
argument_list|)
operator|=
name|all_values
expr_stmt|;
name|all_values
operator|=
name|val
expr_stmt|;
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
operator|=
name|type
expr_stmt|;
name|VALUE_LVAL
argument_list|(
name|val
argument_list|)
operator|=
name|not_lval
expr_stmt|;
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
operator|=
literal|0
expr_stmt|;
name|VALUE_FRAME
argument_list|(
name|val
argument_list|)
operator|=
literal|0
expr_stmt|;
name|VALUE_OFFSET
argument_list|(
name|val
argument_list|)
operator|=
literal|0
expr_stmt|;
name|VALUE_BITPOS
argument_list|(
name|val
argument_list|)
operator|=
literal|0
expr_stmt|;
name|VALUE_BITSIZE
argument_list|(
name|val
argument_list|)
operator|=
literal|0
expr_stmt|;
name|VALUE_REPEATED
argument_list|(
name|val
argument_list|)
operator|=
literal|0
expr_stmt|;
name|VALUE_REPETITIONS
argument_list|(
name|val
argument_list|)
operator|=
literal|0
expr_stmt|;
name|VALUE_REGNO
argument_list|(
name|val
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
name|VALUE_LAZY
argument_list|(
name|val
argument_list|)
operator|=
literal|0
expr_stmt|;
name|VALUE_OPTIMIZED_OUT
argument_list|(
name|val
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Allocate a  value  that has the correct length    for COUNT repetitions type TYPE.  */
end_comment

begin_function
name|value
name|allocate_repeat_value
parameter_list|(
name|type
parameter_list|,
name|count
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|int
name|count
decl_stmt|;
block|{
specifier|register
name|value
name|val
decl_stmt|;
name|val
operator|=
operator|(
name|value
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|value
argument_list|)
operator|+
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|*
name|count
argument_list|)
expr_stmt|;
name|VALUE_NEXT
argument_list|(
name|val
argument_list|)
operator|=
name|all_values
expr_stmt|;
name|all_values
operator|=
name|val
expr_stmt|;
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
operator|=
name|type
expr_stmt|;
name|VALUE_LVAL
argument_list|(
name|val
argument_list|)
operator|=
name|not_lval
expr_stmt|;
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
operator|=
literal|0
expr_stmt|;
name|VALUE_FRAME
argument_list|(
name|val
argument_list|)
operator|=
literal|0
expr_stmt|;
name|VALUE_OFFSET
argument_list|(
name|val
argument_list|)
operator|=
literal|0
expr_stmt|;
name|VALUE_BITPOS
argument_list|(
name|val
argument_list|)
operator|=
literal|0
expr_stmt|;
name|VALUE_BITSIZE
argument_list|(
name|val
argument_list|)
operator|=
literal|0
expr_stmt|;
name|VALUE_REPEATED
argument_list|(
name|val
argument_list|)
operator|=
literal|1
expr_stmt|;
name|VALUE_REPETITIONS
argument_list|(
name|val
argument_list|)
operator|=
name|count
expr_stmt|;
name|VALUE_REGNO
argument_list|(
name|val
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
name|VALUE_LAZY
argument_list|(
name|val
argument_list|)
operator|=
literal|0
expr_stmt|;
name|VALUE_OPTIMIZED_OUT
argument_list|(
name|val
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Return a mark in the value chain.  All values allocated after the    mark is obtained (except for those released) are subject to being freed    if a subsequent value_free_to_mark is passed the mark.  */
end_comment

begin_function
name|value
name|value_mark
parameter_list|()
block|{
return|return
name|all_values
return|;
block|}
end_function

begin_comment
comment|/* Free all values allocated since MARK was obtained by value_mark    (except for those released).  */
end_comment

begin_function
name|void
name|value_free_to_mark
parameter_list|(
name|mark
parameter_list|)
name|value
name|mark
decl_stmt|;
block|{
name|value
name|val
decl_stmt|,
name|next
decl_stmt|;
for|for
control|(
name|val
operator|=
name|all_values
init|;
name|val
operator|&&
name|val
operator|!=
name|mark
condition|;
name|val
operator|=
name|next
control|)
block|{
name|next
operator|=
name|VALUE_NEXT
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|value_free
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
name|all_values
operator|=
name|val
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free all the values that have been allocated (except for those released).    Called after each command, successful or not.  */
end_comment

begin_function
name|void
name|free_all_values
parameter_list|()
block|{
specifier|register
name|value
name|val
decl_stmt|,
name|next
decl_stmt|;
for|for
control|(
name|val
operator|=
name|all_values
init|;
name|val
condition|;
name|val
operator|=
name|next
control|)
block|{
name|next
operator|=
name|VALUE_NEXT
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|value_free
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
name|all_values
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove VAL from the chain all_values    so it will not be freed automatically.  */
end_comment

begin_function
name|void
name|release_value
parameter_list|(
name|val
parameter_list|)
specifier|register
name|value
name|val
decl_stmt|;
block|{
specifier|register
name|value
name|v
decl_stmt|;
if|if
condition|(
name|all_values
operator|==
name|val
condition|)
block|{
name|all_values
operator|=
name|val
operator|->
name|next
expr_stmt|;
return|return;
block|}
for|for
control|(
name|v
operator|=
name|all_values
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|next
control|)
block|{
if|if
condition|(
name|v
operator|->
name|next
operator|==
name|val
condition|)
block|{
name|v
operator|->
name|next
operator|=
name|val
operator|->
name|next
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Return a copy of the value ARG.    It contains the same contents, for same memory address,    but it's a different block of storage.  */
end_comment

begin_function
name|value
name|value_copy
parameter_list|(
name|arg
parameter_list|)
name|value
name|arg
decl_stmt|;
block|{
specifier|register
name|value
name|val
decl_stmt|;
specifier|register
name|struct
name|type
modifier|*
name|type
init|=
name|VALUE_TYPE
argument_list|(
name|arg
argument_list|)
decl_stmt|;
if|if
condition|(
name|VALUE_REPEATED
argument_list|(
name|arg
argument_list|)
condition|)
name|val
operator|=
name|allocate_repeat_value
argument_list|(
name|type
argument_list|,
name|VALUE_REPETITIONS
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|val
operator|=
name|allocate_value
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|VALUE_LVAL
argument_list|(
name|val
argument_list|)
operator|=
name|VALUE_LVAL
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
operator|=
name|VALUE_ADDRESS
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|VALUE_OFFSET
argument_list|(
name|val
argument_list|)
operator|=
name|VALUE_OFFSET
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|VALUE_BITPOS
argument_list|(
name|val
argument_list|)
operator|=
name|VALUE_BITPOS
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|VALUE_BITSIZE
argument_list|(
name|val
argument_list|)
operator|=
name|VALUE_BITSIZE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|VALUE_REGNO
argument_list|(
name|val
argument_list|)
operator|=
name|VALUE_REGNO
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|VALUE_LAZY
argument_list|(
name|val
argument_list|)
operator|=
name|VALUE_LAZY
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|VALUE_LAZY
argument_list|(
name|val
argument_list|)
condition|)
block|{
name|memcpy
argument_list|(
name|VALUE_CONTENTS_RAW
argument_list|(
name|val
argument_list|)
argument_list|,
name|VALUE_CONTENTS_RAW
argument_list|(
name|arg
argument_list|)
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|*
operator|(
name|VALUE_REPEATED
argument_list|(
name|arg
argument_list|)
condition|?
name|VALUE_REPETITIONS
argument_list|(
name|arg
argument_list|)
else|:
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Access to the value history.  */
end_comment

begin_comment
comment|/* Record a new value in the value history.    Returns the absolute history index of the entry.    Result of -1 indicates the value was not saved; otherwise it is the    value history index of this new item.  */
end_comment

begin_function
name|int
name|record_latest_value
parameter_list|(
name|val
parameter_list|)
name|value
name|val
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
comment|/* Check error now if about to store an invalid float.  We return -1      to the caller, but allow them to continue, e.g. to print it as "Nan". */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_FLT
condition|)
block|{
name|unpack_double
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|val
argument_list|)
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Indicate value not saved in history */
block|}
comment|/* Here we treat value_history_count as origin-zero      and applying to the value being stored now.  */
name|i
operator|=
name|value_history_count
operator|%
name|VALUE_HISTORY_CHUNK
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
specifier|register
name|struct
name|value_history_chunk
modifier|*
name|new
init|=
operator|(
expr|struct
name|value_history_chunk
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|value_history_chunk
argument_list|)
argument_list|)
decl_stmt|;
name|memset
argument_list|(
name|new
operator|->
name|values
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|new
operator|->
name|values
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|value_history_chain
expr_stmt|;
name|value_history_chain
operator|=
name|new
expr_stmt|;
block|}
name|value_history_chain
operator|->
name|values
index|[
name|i
index|]
operator|=
name|val
expr_stmt|;
comment|/* We don't want this value to have anything to do with the inferior anymore.      In particular, "set $1 = 50" should not affect the variable from which      the value was taken, and fast watchpoints should be able to assume that      a value on the value history never changes.  */
if|if
condition|(
name|VALUE_LAZY
argument_list|(
name|val
argument_list|)
condition|)
name|value_fetch_lazy
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|VALUE_LVAL
argument_list|(
name|val
argument_list|)
operator|=
name|not_lval
expr_stmt|;
name|release_value
argument_list|(
name|val
argument_list|)
expr_stmt|;
comment|/* Now we regard value_history_count as origin-one      and applying to the value just stored.  */
return|return
operator|++
name|value_history_count
return|;
block|}
end_function

begin_comment
comment|/* Return a copy of the value in the history with sequence number NUM.  */
end_comment

begin_function
name|value
name|access_value_history
parameter_list|(
name|num
parameter_list|)
name|int
name|num
decl_stmt|;
block|{
specifier|register
name|struct
name|value_history_chunk
modifier|*
name|chunk
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|absnum
init|=
name|num
decl_stmt|;
if|if
condition|(
name|absnum
operator|<=
literal|0
condition|)
name|absnum
operator|+=
name|value_history_count
expr_stmt|;
if|if
condition|(
name|absnum
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|num
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"The history is empty."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|num
operator|==
literal|1
condition|)
name|error
argument_list|(
literal|"There is only one value in the history."
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"History does not go back to $$%d."
argument_list|,
operator|-
name|num
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|absnum
operator|>
name|value_history_count
condition|)
name|error
argument_list|(
literal|"History has not yet reached $%d."
argument_list|,
name|absnum
argument_list|)
expr_stmt|;
name|absnum
operator|--
expr_stmt|;
comment|/* Now absnum is always absolute and origin zero.  */
name|chunk
operator|=
name|value_history_chain
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|(
name|value_history_count
operator|-
literal|1
operator|)
operator|/
name|VALUE_HISTORY_CHUNK
operator|-
name|absnum
operator|/
name|VALUE_HISTORY_CHUNK
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
name|chunk
operator|=
name|chunk
operator|->
name|next
expr_stmt|;
return|return
name|value_copy
argument_list|(
name|chunk
operator|->
name|values
index|[
name|absnum
operator|%
name|VALUE_HISTORY_CHUNK
index|]
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Clear the value history entirely.    Must be done when new symbol tables are loaded,    because the type pointers become invalid.  */
end_comment

begin_function
name|void
name|clear_value_history
parameter_list|()
block|{
specifier|register
name|struct
name|value_history_chunk
modifier|*
name|next
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|value
name|val
decl_stmt|;
while|while
condition|(
name|value_history_chain
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VALUE_HISTORY_CHUNK
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|val
operator|=
name|value_history_chain
operator|->
name|values
index|[
name|i
index|]
operator|)
operator|!=
name|NULL
condition|)
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|val
argument_list|)
expr_stmt|;
name|next
operator|=
name|value_history_chain
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|value_history_chain
argument_list|)
expr_stmt|;
name|value_history_chain
operator|=
name|next
expr_stmt|;
block|}
name|value_history_count
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|show_values
parameter_list|(
name|num_exp
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|num_exp
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|value
name|val
decl_stmt|;
specifier|static
name|int
name|num
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|num_exp
condition|)
block|{
comment|/* "info history +" should print from the stored position. 	   "info history<exp>" should print around value number<exp>.  */
if|if
condition|(
name|num_exp
index|[
literal|0
index|]
operator|!=
literal|'+'
operator|||
name|num_exp
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
name|num
operator|=
name|parse_and_eval_address
argument_list|(
name|num_exp
argument_list|)
operator|-
literal|5
expr_stmt|;
block|}
else|else
block|{
comment|/* "info history" means print the last 10 values.  */
name|num
operator|=
name|value_history_count
operator|-
literal|9
expr_stmt|;
block|}
if|if
condition|(
name|num
operator|<=
literal|0
condition|)
name|num
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|num
init|;
name|i
operator|<
name|num
operator|+
literal|10
operator|&&
name|i
operator|<=
name|value_history_count
condition|;
name|i
operator|++
control|)
block|{
name|val
operator|=
name|access_value_history
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"$%d = "
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|value_print
argument_list|(
name|val
argument_list|,
name|stdout
argument_list|,
literal|0
argument_list|,
name|Val_pretty_default
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* The next "info history +" should start after what we just printed.  */
name|num
operator|+=
literal|10
expr_stmt|;
comment|/* Hitting just return after this command should do the same thing as      "info history +".  If num_exp is null, this is unnecessary, since      "info history +" is not useful after "info history".  */
if|if
condition|(
name|from_tty
operator|&&
name|num_exp
condition|)
block|{
name|num_exp
index|[
literal|0
index|]
operator|=
literal|'+'
expr_stmt|;
name|num_exp
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Internal variables.  These are variables within the debugger    that hold values assigned by debugger commands.    The user refers to them with a '$' prefix    that does not appear in the variable names stored internally.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|internalvar
modifier|*
name|internalvars
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Look up an internal variable with name NAME.  NAME should not    normally include a dollar sign.     If the specified internal variable does not exist,    one is created, with a void value.  */
end_comment

begin_function
name|struct
name|internalvar
modifier|*
name|lookup_internalvar
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|struct
name|internalvar
modifier|*
name|var
decl_stmt|;
for|for
control|(
name|var
operator|=
name|internalvars
init|;
name|var
condition|;
name|var
operator|=
name|var
operator|->
name|next
control|)
if|if
condition|(
name|STREQ
argument_list|(
name|var
operator|->
name|name
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|var
return|;
name|var
operator|=
operator|(
expr|struct
name|internalvar
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|internalvar
argument_list|)
argument_list|)
expr_stmt|;
name|var
operator|->
name|name
operator|=
name|concat
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|var
operator|->
name|value
operator|=
name|allocate_value
argument_list|(
name|builtin_type_void
argument_list|)
expr_stmt|;
name|release_value
argument_list|(
name|var
operator|->
name|value
argument_list|)
expr_stmt|;
name|var
operator|->
name|next
operator|=
name|internalvars
expr_stmt|;
name|internalvars
operator|=
name|var
expr_stmt|;
return|return
name|var
return|;
block|}
end_function

begin_function
name|value
name|value_of_internalvar
parameter_list|(
name|var
parameter_list|)
name|struct
name|internalvar
modifier|*
name|var
decl_stmt|;
block|{
specifier|register
name|value
name|val
decl_stmt|;
ifdef|#
directive|ifdef
name|IS_TRAPPED_INTERNALVAR
if|if
condition|(
name|IS_TRAPPED_INTERNALVAR
argument_list|(
name|var
operator|->
name|name
argument_list|)
condition|)
return|return
name|VALUE_OF_TRAPPED_INTERNALVAR
argument_list|(
name|var
argument_list|)
return|;
endif|#
directive|endif
name|val
operator|=
name|value_copy
argument_list|(
name|var
operator|->
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|VALUE_LAZY
argument_list|(
name|val
argument_list|)
condition|)
name|value_fetch_lazy
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|VALUE_LVAL
argument_list|(
name|val
argument_list|)
operator|=
name|lval_internalvar
expr_stmt|;
name|VALUE_INTERNALVAR
argument_list|(
name|val
argument_list|)
operator|=
name|var
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
name|void
name|set_internalvar_component
parameter_list|(
name|var
parameter_list|,
name|offset
parameter_list|,
name|bitpos
parameter_list|,
name|bitsize
parameter_list|,
name|newval
parameter_list|)
name|struct
name|internalvar
modifier|*
name|var
decl_stmt|;
name|int
name|offset
decl_stmt|,
name|bitpos
decl_stmt|,
name|bitsize
decl_stmt|;
name|value
name|newval
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|addr
init|=
name|VALUE_CONTENTS
argument_list|(
name|var
operator|->
name|value
argument_list|)
operator|+
name|offset
decl_stmt|;
ifdef|#
directive|ifdef
name|IS_TRAPPED_INTERNALVAR
if|if
condition|(
name|IS_TRAPPED_INTERNALVAR
argument_list|(
name|var
operator|->
name|name
argument_list|)
condition|)
name|SET_TRAPPED_INTERNALVAR
argument_list|(
name|var
argument_list|,
name|newval
argument_list|,
name|bitpos
argument_list|,
name|bitsize
argument_list|,
name|offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|bitsize
condition|)
name|modify_field
argument_list|(
name|addr
argument_list|,
name|value_as_long
argument_list|(
name|newval
argument_list|)
argument_list|,
name|bitpos
argument_list|,
name|bitsize
argument_list|)
expr_stmt|;
else|else
name|memcpy
argument_list|(
name|addr
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|newval
argument_list|)
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|newval
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|set_internalvar
parameter_list|(
name|var
parameter_list|,
name|val
parameter_list|)
name|struct
name|internalvar
modifier|*
name|var
decl_stmt|;
name|value
name|val
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|IS_TRAPPED_INTERNALVAR
if|if
condition|(
name|IS_TRAPPED_INTERNALVAR
argument_list|(
name|var
operator|->
name|name
argument_list|)
condition|)
name|SET_TRAPPED_INTERNALVAR
argument_list|(
name|var
argument_list|,
name|val
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|var
operator|->
name|value
argument_list|)
expr_stmt|;
name|var
operator|->
name|value
operator|=
name|value_copy
argument_list|(
name|val
argument_list|)
expr_stmt|;
comment|/* Force the value to be fetched from the target now, to avoid problems      later when this internalvar is referenced and the target is gone or      has changed.  */
if|if
condition|(
name|VALUE_LAZY
argument_list|(
name|var
operator|->
name|value
argument_list|)
condition|)
name|value_fetch_lazy
argument_list|(
name|var
operator|->
name|value
argument_list|)
expr_stmt|;
name|release_value
argument_list|(
name|var
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|internalvar_name
parameter_list|(
name|var
parameter_list|)
name|struct
name|internalvar
modifier|*
name|var
decl_stmt|;
block|{
return|return
name|var
operator|->
name|name
return|;
block|}
end_function

begin_comment
comment|/* Free all internalvars.  Done when new symtabs are loaded,    because that makes the values invalid.  */
end_comment

begin_function
name|void
name|clear_internalvars
parameter_list|()
block|{
specifier|register
name|struct
name|internalvar
modifier|*
name|var
decl_stmt|;
while|while
condition|(
name|internalvars
condition|)
block|{
name|var
operator|=
name|internalvars
expr_stmt|;
name|internalvars
operator|=
name|var
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|var
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|var
operator|->
name|value
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|var
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|show_convenience
parameter_list|(
name|ignore
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|ignore
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|register
name|struct
name|internalvar
modifier|*
name|var
decl_stmt|;
name|int
name|varseen
init|=
literal|0
decl_stmt|;
for|for
control|(
name|var
operator|=
name|internalvars
init|;
name|var
condition|;
name|var
operator|=
name|var
operator|->
name|next
control|)
block|{
ifdef|#
directive|ifdef
name|IS_TRAPPED_INTERNALVAR
if|if
condition|(
name|IS_TRAPPED_INTERNALVAR
argument_list|(
name|var
operator|->
name|name
argument_list|)
condition|)
continue|continue;
endif|#
directive|endif
if|if
condition|(
operator|!
name|varseen
condition|)
block|{
name|varseen
operator|=
literal|1
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"$%s = "
argument_list|,
name|var
operator|->
name|name
argument_list|)
expr_stmt|;
name|value_print
argument_list|(
name|var
operator|->
name|value
argument_list|,
name|stdout
argument_list|,
literal|0
argument_list|,
name|Val_pretty_default
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|varseen
condition|)
name|printf
argument_list|(
literal|"No debugger convenience variables now defined.\n\ Convenience variables have names starting with \"$\";\n\ use \"set\" as in \"set $foo = 5\" to define them.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Extract a value as a C number (either long or double).    Knows how to convert fixed values to double, or    floating values to long.    Does not deallocate the value.  */
end_comment

begin_function
name|LONGEST
name|value_as_long
parameter_list|(
name|val
parameter_list|)
specifier|register
name|value
name|val
decl_stmt|;
block|{
comment|/* This coerces arrays and functions, which is necessary (e.g.      in disassemble_command).  It also dereferences references, which      I suspect is the most logical thing to do.  */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_ENUM
condition|)
name|COERCE_ARRAY
argument_list|(
name|val
argument_list|)
expr_stmt|;
return|return
name|unpack_long
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|val
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|double
name|value_as_double
parameter_list|(
name|val
parameter_list|)
specifier|register
name|value
name|val
decl_stmt|;
block|{
name|double
name|foo
decl_stmt|;
name|int
name|inv
decl_stmt|;
name|foo
operator|=
name|unpack_double
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|val
argument_list|)
argument_list|,
operator|&
name|inv
argument_list|)
expr_stmt|;
if|if
condition|(
name|inv
condition|)
name|error
argument_list|(
literal|"Invalid floating value found in program."
argument_list|)
expr_stmt|;
return|return
name|foo
return|;
block|}
end_function

begin_comment
comment|/* Extract a value as a C pointer.    Does not deallocate the value.  */
end_comment

begin_function
name|CORE_ADDR
name|value_as_pointer
parameter_list|(
name|val
parameter_list|)
name|value
name|val
decl_stmt|;
block|{
comment|/* Assume a CORE_ADDR can fit in a LONGEST (for now).  Not sure      whether we want this to be true eventually.  */
if|#
directive|if
literal|0
comment|/* ADDR_BITS_REMOVE is wrong if we are being called for a      non-address (e.g. argument to "signal", "info break", etc.), or      for pointers to char, in which the low bits *are* significant.  */
block|return ADDR_BITS_REMOVE(value_as_long (val));
else|#
directive|else
return|return
name|value_as_long
argument_list|(
name|val
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Unpack raw data (copied from debugee, target byte order) at VALADDR    as a long, or as a double, assuming the raw data is described    by type TYPE.  Knows how to convert different sizes of values    and can convert between fixed and floating point.  We don't assume    any alignment for the raw data.  Return value is in host byte order.     If you want functions and arrays to be coerced to pointers, and    references to be dereferenced, call value_as_long() instead.     C++: It is assumed that the front-end has taken care of    all matters concerning pointers to members.  A pointer    to member which reaches here is considered to be equivalent    to an INT (or some size).  After all, it is only an offset.  */
end_comment

begin_comment
comment|/* FIXME:  This should be rewritten as a switch statement for speed and    ease of comprehension.  */
end_comment

begin_function
name|LONGEST
name|unpack_long
parameter_list|(
name|type
parameter_list|,
name|valaddr
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|char
modifier|*
name|valaddr
decl_stmt|;
block|{
specifier|register
name|enum
name|type_code
name|code
init|=
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|int
name|nosign
init|=
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|TYPE_CODE_ENUM
operator|||
name|code
operator|==
name|TYPE_CODE_BOOL
condition|)
name|code
operator|=
name|TYPE_CODE_INT
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|TYPE_CODE_FLT
condition|)
block|{
if|if
condition|(
name|len
operator|==
sizeof|sizeof
argument_list|(
name|float
argument_list|)
condition|)
block|{
name|float
name|retval
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|retval
argument_list|,
name|valaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|retval
argument_list|)
argument_list|)
expr_stmt|;
name|SWAP_TARGET_AND_HOST
argument_list|(
operator|&
name|retval
argument_list|,
sizeof|sizeof
argument_list|(
name|retval
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
if|if
condition|(
name|len
operator|==
sizeof|sizeof
argument_list|(
name|double
argument_list|)
condition|)
block|{
name|double
name|retval
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|retval
argument_list|,
name|valaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|retval
argument_list|)
argument_list|)
expr_stmt|;
name|SWAP_TARGET_AND_HOST
argument_list|(
operator|&
name|retval
argument_list|,
sizeof|sizeof
argument_list|(
name|retval
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"Unexpected type of floating point number."
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|code
operator|==
name|TYPE_CODE_INT
operator|||
name|code
operator|==
name|TYPE_CODE_CHAR
operator|)
operator|&&
name|nosign
condition|)
block|{
return|return
name|extract_unsigned_integer
argument_list|(
name|valaddr
argument_list|,
name|len
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|TYPE_CODE_INT
operator|||
name|code
operator|==
name|TYPE_CODE_CHAR
condition|)
block|{
return|return
name|extract_signed_integer
argument_list|(
name|valaddr
argument_list|,
name|len
argument_list|)
return|;
block|}
comment|/* Assume a CORE_ADDR can fit in a LONGEST (for now).  Not sure      whether we want this to be true eventually.  */
elseif|else
if|if
condition|(
name|code
operator|==
name|TYPE_CODE_PTR
operator|||
name|code
operator|==
name|TYPE_CODE_REF
condition|)
block|{
return|return
name|extract_address
argument_list|(
name|valaddr
argument_list|,
name|len
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|TYPE_CODE_MEMBER
condition|)
name|error
argument_list|(
literal|"not implemented: member types in unpack_long"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Value not integer or pointer."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* For lint -- never reached */
block|}
end_function

begin_comment
comment|/* Return a double value from the specified type and address.    INVP points to an int which is set to 0 for valid value,    1 for invalid value (bad float format).  In either case,    the returned double is OK to use.  Argument is in target    format, result is in host format.  */
end_comment

begin_function
name|double
name|unpack_double
parameter_list|(
name|type
parameter_list|,
name|valaddr
parameter_list|,
name|invp
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|char
modifier|*
name|valaddr
decl_stmt|;
name|int
modifier|*
name|invp
decl_stmt|;
block|{
specifier|register
name|enum
name|type_code
name|code
init|=
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|int
name|nosign
init|=
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
decl_stmt|;
operator|*
name|invp
operator|=
literal|0
expr_stmt|;
comment|/* Assume valid.   */
if|if
condition|(
name|code
operator|==
name|TYPE_CODE_FLT
condition|)
block|{
if|if
condition|(
name|INVALID_FLOAT
argument_list|(
name|valaddr
argument_list|,
name|len
argument_list|)
condition|)
block|{
operator|*
name|invp
operator|=
literal|1
expr_stmt|;
return|return
literal|1.234567891011121314
return|;
block|}
if|if
condition|(
name|len
operator|==
sizeof|sizeof
argument_list|(
name|float
argument_list|)
condition|)
block|{
name|float
name|retval
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|retval
argument_list|,
name|valaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|retval
argument_list|)
argument_list|)
expr_stmt|;
name|SWAP_TARGET_AND_HOST
argument_list|(
operator|&
name|retval
argument_list|,
sizeof|sizeof
argument_list|(
name|retval
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
if|if
condition|(
name|len
operator|==
sizeof|sizeof
argument_list|(
name|double
argument_list|)
condition|)
block|{
name|double
name|retval
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|retval
argument_list|,
name|valaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|retval
argument_list|)
argument_list|)
expr_stmt|;
name|SWAP_TARGET_AND_HOST
argument_list|(
operator|&
name|retval
argument_list|,
sizeof|sizeof
argument_list|(
name|retval
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"Unexpected type of floating point number."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* Placate lint.  */
block|}
block|}
elseif|else
if|if
condition|(
name|nosign
condition|)
block|{
comment|/* Unsigned -- be sure we compensate for signed LONGEST.  */
return|return
operator|(
name|unsigned
name|LONGEST
operator|)
name|unpack_long
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|)
return|;
block|}
else|else
block|{
comment|/* Signed -- we are OK with unpack_long.  */
return|return
name|unpack_long
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Unpack raw data (copied from debugee, target byte order) at VALADDR    as a CORE_ADDR, assuming the raw data is described by type TYPE.    We don't assume any alignment for the raw data.  Return value is in    host byte order.     If you want functions and arrays to be coerced to pointers, and    references to be dereferenced, call value_as_pointer() instead.     C++: It is assumed that the front-end has taken care of    all matters concerning pointers to members.  A pointer    to member which reaches here is considered to be equivalent    to an INT (or some size).  After all, it is only an offset.  */
end_comment

begin_function
name|CORE_ADDR
name|unpack_pointer
parameter_list|(
name|type
parameter_list|,
name|valaddr
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|char
modifier|*
name|valaddr
decl_stmt|;
block|{
comment|/* Assume a CORE_ADDR can fit in a LONGEST (for now).  Not sure      whether we want this to be true eventually.  */
return|return
name|unpack_long
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a value ARG1 (offset by OFFSET bytes)    of a struct or union type ARG_TYPE,    extract and return the value of one of its fields.    FIELDNO says which field.     For C++, must also be able to return values from static fields */
end_comment

begin_function
name|value
name|value_primitive_field
parameter_list|(
name|arg1
parameter_list|,
name|offset
parameter_list|,
name|fieldno
parameter_list|,
name|arg_type
parameter_list|)
specifier|register
name|value
name|arg1
decl_stmt|;
name|int
name|offset
decl_stmt|;
specifier|register
name|int
name|fieldno
decl_stmt|;
specifier|register
name|struct
name|type
modifier|*
name|arg_type
decl_stmt|;
block|{
specifier|register
name|value
name|v
decl_stmt|;
specifier|register
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|check_stub_type
argument_list|(
name|arg_type
argument_list|)
expr_stmt|;
name|type
operator|=
name|TYPE_FIELD_TYPE
argument_list|(
name|arg_type
argument_list|,
name|fieldno
argument_list|)
expr_stmt|;
comment|/* Handle packed fields */
name|offset
operator|+=
name|TYPE_FIELD_BITPOS
argument_list|(
name|arg_type
argument_list|,
name|fieldno
argument_list|)
operator|/
literal|8
expr_stmt|;
if|if
condition|(
name|TYPE_FIELD_BITSIZE
argument_list|(
name|arg_type
argument_list|,
name|fieldno
argument_list|)
condition|)
block|{
name|v
operator|=
name|value_from_longest
argument_list|(
name|type
argument_list|,
name|unpack_field_as_long
argument_list|(
name|arg_type
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|fieldno
argument_list|)
argument_list|)
expr_stmt|;
name|VALUE_BITPOS
argument_list|(
name|v
argument_list|)
operator|=
name|TYPE_FIELD_BITPOS
argument_list|(
name|arg_type
argument_list|,
name|fieldno
argument_list|)
operator|%
literal|8
expr_stmt|;
name|VALUE_BITSIZE
argument_list|(
name|v
argument_list|)
operator|=
name|TYPE_FIELD_BITSIZE
argument_list|(
name|arg_type
argument_list|,
name|fieldno
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|v
operator|=
name|allocate_value
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|VALUE_LAZY
argument_list|(
name|arg1
argument_list|)
condition|)
name|VALUE_LAZY
argument_list|(
name|v
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
name|memcpy
argument_list|(
name|VALUE_CONTENTS_RAW
argument_list|(
name|v
argument_list|)
argument_list|,
name|VALUE_CONTENTS_RAW
argument_list|(
name|arg1
argument_list|)
operator|+
name|offset
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|VALUE_LVAL
argument_list|(
name|v
argument_list|)
operator|=
name|VALUE_LVAL
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|VALUE_LVAL
argument_list|(
name|arg1
argument_list|)
operator|==
name|lval_internalvar
condition|)
name|VALUE_LVAL
argument_list|(
name|v
argument_list|)
operator|=
name|lval_internalvar_component
expr_stmt|;
name|VALUE_ADDRESS
argument_list|(
name|v
argument_list|)
operator|=
name|VALUE_ADDRESS
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|VALUE_OFFSET
argument_list|(
name|v
argument_list|)
operator|=
name|offset
operator|+
name|VALUE_OFFSET
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_comment
comment|/* Given a value ARG1 of a struct or union type,    extract and return the value of one of its fields.    FIELDNO says which field.     For C++, must also be able to return values from static fields */
end_comment

begin_function
name|value
name|value_field
parameter_list|(
name|arg1
parameter_list|,
name|fieldno
parameter_list|)
specifier|register
name|value
name|arg1
decl_stmt|;
specifier|register
name|int
name|fieldno
decl_stmt|;
block|{
return|return
name|value_primitive_field
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|,
name|fieldno
argument_list|,
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return a non-virtual function as a value.    F is the list of member functions which contains the desired method.    J is an index into F which provides the desired method. */
end_comment

begin_function
name|value
name|value_fn_field
parameter_list|(
name|arg1p
parameter_list|,
name|f
parameter_list|,
name|j
parameter_list|,
name|type
parameter_list|,
name|offset
parameter_list|)
name|value
modifier|*
name|arg1p
decl_stmt|;
name|struct
name|fn_field
modifier|*
name|f
decl_stmt|;
name|int
name|j
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|int
name|offset
decl_stmt|;
block|{
specifier|register
name|value
name|v
decl_stmt|;
specifier|register
name|struct
name|type
modifier|*
name|ftype
init|=
name|TYPE_FN_FIELD_TYPE
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|sym
operator|=
name|lookup_symbol
argument_list|(
name|TYPE_FN_FIELD_PHYSNAME
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VAR_NAMESPACE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sym
condition|)
name|error
argument_list|(
literal|"Internal error: could not find physical method named %s"
argument_list|,
name|TYPE_FN_FIELD_PHYSNAME
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
name|v
operator|=
name|allocate_value
argument_list|(
name|ftype
argument_list|)
expr_stmt|;
name|VALUE_ADDRESS
argument_list|(
name|v
argument_list|)
operator|=
name|BLOCK_START
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|VALUE_TYPE
argument_list|(
name|v
argument_list|)
operator|=
name|ftype
expr_stmt|;
if|if
condition|(
name|arg1p
condition|)
block|{
if|if
condition|(
name|type
operator|!=
name|VALUE_TYPE
argument_list|(
operator|*
name|arg1p
argument_list|)
condition|)
operator|*
name|arg1p
operator|=
name|value_ind
argument_list|(
name|value_cast
argument_list|(
name|lookup_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|value_addr
argument_list|(
operator|*
name|arg1p
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Move the `this' pointer according to the offset.      VALUE_OFFSET (*arg1p) += offset;     */
block|}
return|return
name|v
return|;
block|}
end_function

begin_comment
comment|/* Return a virtual function as a value.    ARG1 is the object which provides the virtual function    table pointer.  *ARG1P is side-effected in calling this function.    F is the list of member functions which contains the desired virtual    function.    J is an index into F which provides the desired virtual function.     TYPE is the type in which F is located.  */
end_comment

begin_function
name|value
name|value_virtual_fn_field
parameter_list|(
name|arg1p
parameter_list|,
name|f
parameter_list|,
name|j
parameter_list|,
name|type
parameter_list|,
name|offset
parameter_list|)
name|value
modifier|*
name|arg1p
decl_stmt|;
name|struct
name|fn_field
modifier|*
name|f
decl_stmt|;
name|int
name|j
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|int
name|offset
decl_stmt|;
block|{
name|value
name|arg1
init|=
operator|*
name|arg1p
decl_stmt|;
comment|/* First, get the virtual function table pointer.  That comes      with a strange type, so cast it to type `pointer to long' (which      should serve just fine as a function type).  Then, index into      the table, and convert final value to appropriate function type.  */
name|value
name|entry
decl_stmt|,
name|vfn
decl_stmt|,
name|vtbl
decl_stmt|;
name|value
name|vi
init|=
name|value_from_longest
argument_list|(
name|builtin_type_int
argument_list|,
operator|(
name|LONGEST
operator|)
name|TYPE_FN_FIELD_VOFFSET
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|fcontext
init|=
name|TYPE_FN_FIELD_FCONTEXT
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|context
decl_stmt|;
if|if
condition|(
name|fcontext
operator|==
name|NULL
condition|)
comment|/* We don't have an fcontext (e.g. the program was compiled with       g++ version 1).  Try to get the vtbl from the TYPE_VPTR_BASETYPE.       This won't work right for multiple inheritance, but at least we       should do as well as GDB 3.x did.  */
name|fcontext
operator|=
name|TYPE_VPTR_BASETYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|context
operator|=
name|lookup_pointer_type
argument_list|(
name|fcontext
argument_list|)
expr_stmt|;
comment|/* Now context is a pointer to the basetype containing the vtbl.  */
if|if
condition|(
name|TYPE_TARGET_TYPE
argument_list|(
name|context
argument_list|)
operator|!=
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
condition|)
name|arg1
operator|=
name|value_ind
argument_list|(
name|value_cast
argument_list|(
name|context
argument_list|,
name|value_addr
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|context
operator|=
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
comment|/* Now context is the basetype containing the vtbl.  */
comment|/* This type may have been defined before its virtual function table      was.  If so, fill in the virtual function table entry for the      type now.  */
if|if
condition|(
name|TYPE_VPTR_FIELDNO
argument_list|(
name|context
argument_list|)
operator|<
literal|0
condition|)
name|fill_in_vptr_fieldno
argument_list|(
name|context
argument_list|)
expr_stmt|;
comment|/* The virtual function table is now an array of structures      which have the form { int16 offset, delta; void *pfn; }.  */
name|vtbl
operator|=
name|value_ind
argument_list|(
name|value_primitive_field
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|,
name|TYPE_VPTR_FIELDNO
argument_list|(
name|context
argument_list|)
argument_list|,
name|TYPE_VPTR_BASETYPE
argument_list|(
name|context
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Index into the virtual function table.  This is hard-coded because      looking up a field is not cheap, and it may be important to save      time, e.g. if the user has set a conditional breakpoint calling      a virtual function.  */
name|entry
operator|=
name|value_subscript
argument_list|(
name|vtbl
argument_list|,
name|vi
argument_list|)
expr_stmt|;
comment|/* Move the `this' pointer according to the virtual function table. */
name|VALUE_OFFSET
argument_list|(
name|arg1
argument_list|)
operator|+=
name|value_as_long
argument_list|(
name|value_field
argument_list|(
name|entry
argument_list|,
literal|0
argument_list|)
argument_list|)
comment|/* + offset*/
expr_stmt|;
if|if
condition|(
operator|!
name|VALUE_LAZY
argument_list|(
name|arg1
argument_list|)
condition|)
block|{
name|VALUE_LAZY
argument_list|(
name|arg1
argument_list|)
operator|=
literal|1
expr_stmt|;
name|value_fetch_lazy
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
block|}
name|vfn
operator|=
name|value_field
argument_list|(
name|entry
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Reinstantiate the function pointer with the correct type.  */
name|VALUE_TYPE
argument_list|(
name|vfn
argument_list|)
operator|=
name|lookup_pointer_type
argument_list|(
name|TYPE_FN_FIELD_TYPE
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|arg1p
operator|=
name|arg1
expr_stmt|;
return|return
name|vfn
return|;
block|}
end_function

begin_comment
comment|/* ARG is a pointer to an object we know to be at least    a DTYPE.  BTYPE is the most derived basetype that has    already been searched (and need not be searched again).    After looking at the vtables between BTYPE and DTYPE,    return the most derived type we find.  The caller must    be satisfied when the return value == DTYPE.     FIXME-tiemann: should work with dossier entries as well.  */
end_comment

begin_function
specifier|static
name|value
name|value_headof
parameter_list|(
name|in_arg
parameter_list|,
name|btype
parameter_list|,
name|dtype
parameter_list|)
name|value
name|in_arg
decl_stmt|;
name|struct
name|type
modifier|*
name|btype
decl_stmt|,
decl|*
name|dtype
decl_stmt|;
end_function

begin_block
block|{
comment|/* First collect the vtables we must look at for this object.  */
comment|/* FIXME-tiemann: right now, just look at top-most vtable.  */
name|value
name|arg
decl_stmt|,
name|vtbl
decl_stmt|,
name|entry
decl_stmt|,
name|best_entry
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nelems
decl_stmt|;
name|int
name|offset
decl_stmt|,
name|best_offset
init|=
literal|0
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|CORE_ADDR
name|pc_for_sym
decl_stmt|;
name|char
modifier|*
name|demangled_name
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
name|btype
operator|=
name|TYPE_VPTR_BASETYPE
argument_list|(
name|dtype
argument_list|)
expr_stmt|;
name|check_stub_type
argument_list|(
name|btype
argument_list|)
expr_stmt|;
name|arg
operator|=
name|in_arg
expr_stmt|;
if|if
condition|(
name|btype
operator|!=
name|dtype
condition|)
name|arg
operator|=
name|value_cast
argument_list|(
name|lookup_pointer_type
argument_list|(
name|btype
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|vtbl
operator|=
name|value_ind
argument_list|(
name|value_field
argument_list|(
name|value_ind
argument_list|(
name|arg
argument_list|)
argument_list|,
name|TYPE_VPTR_FIELDNO
argument_list|(
name|btype
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check that VTBL looks like it points to a virtual function table.  */
name|msymbol
operator|=
name|lookup_minimal_symbol_by_pc
argument_list|(
name|VALUE_ADDRESS
argument_list|(
name|vtbl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|msymbol
operator|==
name|NULL
operator|||
operator|!
name|VTBL_PREFIX_P
argument_list|(
name|demangled_name
operator|=
name|SYMBOL_NAME
argument_list|(
name|msymbol
argument_list|)
argument_list|)
condition|)
block|{
comment|/* If we expected to find a vtable, but did not, let the user 	 know that we aren't happy, but don't throw an error. 	 FIXME: there has to be a better way to do this.  */
name|struct
name|type
modifier|*
name|error_type
init|=
operator|(
expr|struct
name|type
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|type
argument_list|)
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|error_type
argument_list|,
name|VALUE_TYPE
argument_list|(
name|in_arg
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|error_type
argument_list|)
operator|=
name|savestring
argument_list|(
literal|"suspicious *"
argument_list|,
sizeof|sizeof
argument_list|(
literal|"suspicious *"
argument_list|)
argument_list|)
expr_stmt|;
name|VALUE_TYPE
argument_list|(
name|in_arg
argument_list|)
operator|=
name|error_type
expr_stmt|;
return|return
name|in_arg
return|;
block|}
comment|/* Now search through the virtual function table.  */
name|entry
operator|=
name|value_ind
argument_list|(
name|vtbl
argument_list|)
expr_stmt|;
name|nelems
operator|=
name|longest_to_int
argument_list|(
name|value_as_long
argument_list|(
name|value_field
argument_list|(
name|entry
argument_list|,
literal|2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|nelems
condition|;
name|i
operator|++
control|)
block|{
name|entry
operator|=
name|value_subscript
argument_list|(
name|vtbl
argument_list|,
name|value_from_longest
argument_list|(
name|builtin_type_int
argument_list|,
operator|(
name|LONGEST
operator|)
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|longest_to_int
argument_list|(
name|value_as_long
argument_list|(
name|value_field
argument_list|(
name|entry
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we use '<=' we can handle single inheritance        * where all offsets are zero - just use the first entry found. */
if|if
condition|(
name|offset
operator|<=
name|best_offset
condition|)
block|{
name|best_offset
operator|=
name|offset
expr_stmt|;
name|best_entry
operator|=
name|entry
expr_stmt|;
block|}
block|}
comment|/* Move the pointer according to BEST_ENTRY's offset, and figure      out what type we should return as the new pointer.  */
if|if
condition|(
name|best_entry
operator|==
literal|0
condition|)
block|{
comment|/* An alternative method (which should no longer be necessary).        * But we leave it in for future use, when we will hopefully        * have optimizes the vtable to use thunks instead of offsets. */
comment|/* Use the name of vtable itself to extract a base type. */
name|demangled_name
operator|+=
literal|4
expr_stmt|;
comment|/* Skip _vt$ prefix. */
block|}
else|else
block|{
name|pc_for_sym
operator|=
name|value_as_pointer
argument_list|(
name|value_field
argument_list|(
name|best_entry
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|sym
operator|=
name|find_pc_function
argument_list|(
name|pc_for_sym
argument_list|)
expr_stmt|;
name|demangled_name
operator|=
name|cplus_demangle
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|DMGL_ANSI
argument_list|)
expr_stmt|;
operator|*
operator|(
name|strchr
argument_list|(
name|demangled_name
argument_list|,
literal|':'
argument_list|)
operator|)
operator|=
literal|'\0'
expr_stmt|;
block|}
name|sym
operator|=
name|lookup_symbol
argument_list|(
name|demangled_name
argument_list|,
literal|0
argument_list|,
name|VAR_NAMESPACE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"could not find type declaration for `%s'"
argument_list|,
name|demangled_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|best_entry
condition|)
block|{
name|free
argument_list|(
name|demangled_name
argument_list|)
expr_stmt|;
name|arg
operator|=
name|value_add
argument_list|(
name|value_cast
argument_list|(
name|builtin_type_int
argument_list|,
name|arg
argument_list|)
argument_list|,
name|value_field
argument_list|(
name|best_entry
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|arg
operator|=
name|in_arg
expr_stmt|;
name|VALUE_TYPE
argument_list|(
name|arg
argument_list|)
operator|=
name|lookup_pointer_type
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|arg
return|;
block|}
end_block

begin_comment
comment|/* ARG is a pointer object of type TYPE.  If TYPE has virtual    function tables, probe ARG's tables (including the vtables    of its baseclasses) to figure out the most derived type that ARG    could actually be a pointer to.  */
end_comment

begin_function
name|value
name|value_from_vtable_info
parameter_list|(
name|arg
parameter_list|,
name|type
parameter_list|)
name|value
name|arg
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
block|{
comment|/* Take care of preliminaries.  */
if|if
condition|(
name|TYPE_VPTR_FIELDNO
argument_list|(
name|type
argument_list|)
operator|<
literal|0
condition|)
name|fill_in_vptr_fieldno
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_VPTR_FIELDNO
argument_list|(
name|type
argument_list|)
operator|<
literal|0
operator|||
name|VALUE_REPEATED
argument_list|(
name|arg
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|value_headof
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|,
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if the INDEXth field of TYPE is a virtual baseclass    pointer which is for the base class whose type is BASECLASS.  */
end_comment

begin_function
specifier|static
name|int
name|vb_match
parameter_list|(
name|type
parameter_list|,
name|index
parameter_list|,
name|basetype
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|int
name|index
decl_stmt|;
name|struct
name|type
modifier|*
name|basetype
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|fieldtype
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|index
argument_list|)
decl_stmt|;
name|char
modifier|*
name|field_class_name
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|*
name|name
operator|!=
literal|'_'
condition|)
return|return
literal|0
return|;
comment|/* gcc 2.4 uses _vb$.  */
if|if
condition|(
name|name
index|[
literal|1
index|]
operator|==
literal|'v'
operator|&&
name|name
index|[
literal|2
index|]
operator|==
literal|'b'
operator|&&
name|name
index|[
literal|3
index|]
operator|==
name|CPLUS_MARKER
condition|)
name|field_class_name
operator|=
name|name
operator|+
literal|4
expr_stmt|;
comment|/* gcc 2.5 will use __vb_.  */
if|if
condition|(
name|name
index|[
literal|1
index|]
operator|==
literal|'_'
operator|&&
name|name
index|[
literal|2
index|]
operator|==
literal|'v'
operator|&&
name|name
index|[
literal|3
index|]
operator|==
literal|'b'
operator|&&
name|name
index|[
literal|4
index|]
operator|==
literal|'_'
condition|)
name|field_class_name
operator|=
name|name
operator|+
literal|5
expr_stmt|;
if|if
condition|(
name|field_class_name
operator|==
name|NULL
condition|)
comment|/* This field is not a virtual base class pointer.  */
return|return
literal|0
return|;
comment|/* It's a virtual baseclass pointer, now we just need to find out whether      it is for this baseclass.  */
name|fieldtype
operator|=
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|fieldtype
operator|==
name|NULL
operator|||
name|TYPE_CODE
argument_list|(
name|fieldtype
argument_list|)
operator|!=
name|TYPE_CODE_PTR
condition|)
comment|/* "Can't happen".  */
return|return
literal|0
return|;
comment|/* What we check for is that either the types are equal (needed for      nameless types) or have the same name.  This is ugly, and a more      elegant solution should be devised (which would probably just push      the ugliness into symbol reading unless we change the stabs format).  */
if|if
condition|(
name|TYPE_TARGET_TYPE
argument_list|(
name|fieldtype
argument_list|)
operator|==
name|basetype
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|basetype
argument_list|)
operator|!=
name|NULL
operator|&&
name|TYPE_NAME
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|fieldtype
argument_list|)
argument_list|)
operator|!=
name|NULL
operator|&&
name|STREQ
argument_list|(
name|TYPE_NAME
argument_list|(
name|basetype
argument_list|)
argument_list|,
name|TYPE_NAME
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|fieldtype
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Compute the offset of the baseclass which is    the INDEXth baseclass of class TYPE, for a value ARG,    wih extra offset of OFFSET.    The result is the offste of the baseclass value relative    to (the address of)(ARG) + OFFSET.     -1 is returned on error. */
end_comment

begin_function
name|int
name|baseclass_offset
parameter_list|(
name|type
parameter_list|,
name|index
parameter_list|,
name|arg
parameter_list|,
name|offset
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|int
name|index
decl_stmt|;
name|value
name|arg
decl_stmt|;
name|int
name|offset
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|basetype
init|=
name|TYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|BASETYPE_VIA_VIRTUAL
argument_list|(
name|type
argument_list|,
name|index
argument_list|)
condition|)
block|{
comment|/* Must hunt for the pointer to this virtual baseclass.  */
specifier|register
name|int
name|i
decl_stmt|,
name|len
init|=
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|int
name|n_baseclasses
init|=
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/* First look for the virtual baseclass pointer 	 in the fields.  */
for|for
control|(
name|i
operator|=
name|n_baseclasses
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|vb_match
argument_list|(
name|type
argument_list|,
name|i
argument_list|,
name|basetype
argument_list|)
condition|)
block|{
name|CORE_ADDR
name|addr
init|=
name|unpack_pointer
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|arg
argument_list|)
operator|+
name|VALUE_OFFSET
argument_list|(
name|arg
argument_list|)
operator|+
name|offset
operator|+
operator|(
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
operator|/
literal|8
operator|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|VALUE_LVAL
argument_list|(
name|arg
argument_list|)
operator|!=
name|lval_memory
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|addr
operator|-
call|(
name|LONGEST
call|)
argument_list|(
name|VALUE_ADDRESS
argument_list|(
name|arg
argument_list|)
operator|+
name|VALUE_OFFSET
argument_list|(
name|arg
argument_list|)
operator|+
name|offset
argument_list|)
return|;
block|}
block|}
comment|/* Not in the fields, so try looking through the baseclasses.  */
for|for
control|(
name|i
operator|=
name|index
operator|+
literal|1
init|;
name|i
operator|<
name|n_baseclasses
condition|;
name|i
operator|++
control|)
block|{
name|int
name|boffset
init|=
name|baseclass_offset
argument_list|(
name|type
argument_list|,
name|i
argument_list|,
name|arg
argument_list|,
name|offset
argument_list|)
decl_stmt|;
if|if
condition|(
name|boffset
condition|)
return|return
name|boffset
return|;
block|}
comment|/* Not found.  */
return|return
operator|-
literal|1
return|;
block|}
comment|/* Baseclass is easily computed.  */
return|return
name|TYPE_BASECLASS_BITPOS
argument_list|(
name|type
argument_list|,
name|index
argument_list|)
operator|/
literal|8
return|;
block|}
end_function

begin_comment
comment|/* Compute the address of the baseclass which is    the INDEXth baseclass of class TYPE.  The TYPE base    of the object is at VALADDR.     If ERRP is non-NULL, set *ERRP to be the errno code of any error,    or 0 if no error.  In that case the return value is not the address    of the baseclasss, but the address which could not be read    successfully.  */
end_comment

begin_comment
comment|/* FIXME Fix remaining uses of baseclass_addr to use baseclass_offset */
end_comment

begin_function
name|char
modifier|*
name|baseclass_addr
parameter_list|(
name|type
parameter_list|,
name|index
parameter_list|,
name|valaddr
parameter_list|,
name|valuep
parameter_list|,
name|errp
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|int
name|index
decl_stmt|;
name|char
modifier|*
name|valaddr
decl_stmt|;
name|value
modifier|*
name|valuep
decl_stmt|;
name|int
modifier|*
name|errp
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|basetype
init|=
name|TYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|errp
condition|)
operator|*
name|errp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|BASETYPE_VIA_VIRTUAL
argument_list|(
name|type
argument_list|,
name|index
argument_list|)
condition|)
block|{
comment|/* Must hunt for the pointer to this virtual baseclass.  */
specifier|register
name|int
name|i
decl_stmt|,
name|len
init|=
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|int
name|n_baseclasses
init|=
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/* First look for the virtual baseclass pointer 	 in the fields.  */
for|for
control|(
name|i
operator|=
name|n_baseclasses
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|vb_match
argument_list|(
name|type
argument_list|,
name|i
argument_list|,
name|basetype
argument_list|)
condition|)
block|{
name|value
name|val
init|=
name|allocate_value
argument_list|(
name|basetype
argument_list|)
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|int
name|status
decl_stmt|;
name|addr
operator|=
name|unpack_pointer
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|valaddr
operator|+
operator|(
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
operator|/
literal|8
operator|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|target_read_memory
argument_list|(
name|addr
argument_list|,
name|VALUE_CONTENTS_RAW
argument_list|(
name|val
argument_list|)
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|basetype
argument_list|)
argument_list|)
expr_stmt|;
name|VALUE_LVAL
argument_list|(
name|val
argument_list|)
operator|=
name|lval_memory
expr_stmt|;
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
operator|=
name|addr
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|valuep
condition|)
operator|*
name|valuep
operator|=
name|NULL
expr_stmt|;
name|release_value
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|value_free
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|errp
condition|)
operator|*
name|errp
operator|=
name|status
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
name|addr
return|;
block|}
else|else
block|{
if|if
condition|(
name|valuep
condition|)
operator|*
name|valuep
operator|=
name|val
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
name|VALUE_CONTENTS
argument_list|(
name|val
argument_list|)
return|;
block|}
block|}
block|}
comment|/* Not in the fields, so try looking through the baseclasses.  */
for|for
control|(
name|i
operator|=
name|index
operator|+
literal|1
init|;
name|i
operator|<
name|n_baseclasses
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|baddr
decl_stmt|;
name|baddr
operator|=
name|baseclass_addr
argument_list|(
name|type
argument_list|,
name|i
argument_list|,
name|valaddr
argument_list|,
name|valuep
argument_list|,
name|errp
argument_list|)
expr_stmt|;
if|if
condition|(
name|baddr
condition|)
return|return
name|baddr
return|;
block|}
comment|/* Not found.  */
if|if
condition|(
name|valuep
condition|)
operator|*
name|valuep
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Baseclass is easily computed.  */
if|if
condition|(
name|valuep
condition|)
operator|*
name|valuep
operator|=
literal|0
expr_stmt|;
return|return
name|valaddr
operator|+
name|TYPE_BASECLASS_BITPOS
argument_list|(
name|type
argument_list|,
name|index
argument_list|)
operator|/
literal|8
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Unpack a field FIELDNO of the specified TYPE, from the anonymous object at    VALADDR.     Extracting bits depends on endianness of the machine.  Compute the    number of least significant bits to discard.  For big endian machines,    we compute the total number of bits in the anonymous object, subtract    off the bit count from the MSB of the object to the MSB of the    bitfield, then the size of the bitfield, which leaves the LSB discard    count.  For little endian machines, the discard count is simply the    number of bits from the LSB of the anonymous object to the LSB of the    bitfield.     If the field is signed, we also do sign extension. */
end_comment

begin_function
name|LONGEST
name|unpack_field_as_long
parameter_list|(
name|type
parameter_list|,
name|valaddr
parameter_list|,
name|fieldno
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|char
modifier|*
name|valaddr
decl_stmt|;
name|int
name|fieldno
decl_stmt|;
block|{
name|unsigned
name|LONGEST
name|val
decl_stmt|;
name|unsigned
name|LONGEST
name|valmask
decl_stmt|;
name|int
name|bitpos
init|=
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|fieldno
argument_list|)
decl_stmt|;
name|int
name|bitsize
init|=
name|TYPE_FIELD_BITSIZE
argument_list|(
name|type
argument_list|,
name|fieldno
argument_list|)
decl_stmt|;
name|int
name|lsbcount
decl_stmt|;
name|val
operator|=
name|extract_unsigned_integer
argument_list|(
name|valaddr
operator|+
name|bitpos
operator|/
literal|8
argument_list|,
sizeof|sizeof
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Extract bits.  See comment above. */
if|#
directive|if
name|BITS_BIG_ENDIAN
name|lsbcount
operator|=
operator|(
sizeof|sizeof
name|val
operator|*
literal|8
operator|-
name|bitpos
operator|%
literal|8
operator|-
name|bitsize
operator|)
expr_stmt|;
else|#
directive|else
name|lsbcount
operator|=
operator|(
name|bitpos
operator|%
literal|8
operator|)
expr_stmt|;
endif|#
directive|endif
name|val
operator|>>=
name|lsbcount
expr_stmt|;
comment|/* If the field does not entirely fill a LONGEST, then zero the sign bits.      If the field is signed, and is negative, then sign extend. */
if|if
condition|(
operator|(
name|bitsize
operator|>
literal|0
operator|)
operator|&&
operator|(
name|bitsize
operator|<
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|val
argument_list|)
operator|)
condition|)
block|{
name|valmask
operator|=
operator|(
operator|(
operator|(
name|unsigned
name|LONGEST
operator|)
literal|1
operator|)
operator|<<
name|bitsize
operator|)
operator|-
literal|1
expr_stmt|;
name|val
operator|&=
name|valmask
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_UNSIGNED
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|fieldno
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|val
operator|&
operator|(
name|valmask
operator|^
operator|(
name|valmask
operator|>>
literal|1
operator|)
operator|)
condition|)
block|{
name|val
operator||=
operator|~
name|valmask
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Modify the value of a bitfield.  ADDR points to a block of memory in    target byte order; the bitfield starts in the byte pointed to.  FIELDVAL    is the desired value of the field, in host byte order.  BITPOS and BITSIZE    indicate which bits (in target bit order) comprise the bitfield.  */
end_comment

begin_function
name|void
name|modify_field
parameter_list|(
name|addr
parameter_list|,
name|fieldval
parameter_list|,
name|bitpos
parameter_list|,
name|bitsize
parameter_list|)
name|char
modifier|*
name|addr
decl_stmt|;
name|LONGEST
name|fieldval
decl_stmt|;
name|int
name|bitpos
decl_stmt|,
name|bitsize
decl_stmt|;
block|{
name|LONGEST
name|oword
decl_stmt|;
comment|/* Reject values too big to fit in the field in question,      otherwise adjoining fields may be corrupted.  */
if|if
condition|(
name|bitsize
operator|<
operator|(
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|fieldval
argument_list|)
operator|)
operator|&&
literal|0
operator|!=
operator|(
name|fieldval
operator|&
operator|~
operator|(
operator|(
literal|1
operator|<<
name|bitsize
operator|)
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
comment|/* FIXME: would like to include fieldval in the message, but 	 we don't have a sprintf_longest.  */
name|error
argument_list|(
literal|"Value does not fit in %d bits."
argument_list|,
name|bitsize
argument_list|)
expr_stmt|;
block|}
name|oword
operator|=
name|extract_signed_integer
argument_list|(
name|addr
argument_list|,
sizeof|sizeof
name|oword
argument_list|)
expr_stmt|;
comment|/* Shifting for bit field depends on endianness of the target machine.  */
if|#
directive|if
name|BITS_BIG_ENDIAN
name|bitpos
operator|=
sizeof|sizeof
argument_list|(
name|oword
argument_list|)
operator|*
literal|8
operator|-
name|bitpos
operator|-
name|bitsize
expr_stmt|;
endif|#
directive|endif
comment|/* Mask out old value, while avoiding shifts>= size of oword */
if|if
condition|(
name|bitsize
operator|<
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|oword
argument_list|)
condition|)
name|oword
operator|&=
operator|~
operator|(
operator|(
operator|(
operator|(
operator|(
name|unsigned
name|LONGEST
operator|)
literal|1
operator|)
operator|<<
name|bitsize
operator|)
operator|-
literal|1
operator|)
operator|<<
name|bitpos
operator|)
expr_stmt|;
else|else
name|oword
operator|&=
operator|~
operator|(
operator|(
operator|~
operator|(
name|unsigned
name|LONGEST
operator|)
literal|0
operator|)
operator|<<
name|bitpos
operator|)
expr_stmt|;
name|oword
operator||=
name|fieldval
operator|<<
name|bitpos
expr_stmt|;
name|store_signed_integer
argument_list|(
name|addr
argument_list|,
sizeof|sizeof
name|oword
argument_list|,
name|oword
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Convert C numbers into newly allocated values */
end_comment

begin_function
name|value
name|value_from_longest
parameter_list|(
name|type
parameter_list|,
name|num
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
specifier|register
name|LONGEST
name|num
decl_stmt|;
block|{
specifier|register
name|value
name|val
init|=
name|allocate_value
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|enum
name|type_code
name|code
init|=
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|TYPE_CODE_INT
case|:
case|case
name|TYPE_CODE_CHAR
case|:
case|case
name|TYPE_CODE_ENUM
case|:
case|case
name|TYPE_CODE_BOOL
case|:
name|store_signed_integer
argument_list|(
name|VALUE_CONTENTS_RAW
argument_list|(
name|val
argument_list|)
argument_list|,
name|len
argument_list|,
name|num
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_REF
case|:
case|case
name|TYPE_CODE_PTR
case|:
comment|/* This assumes that all pointers of a given length 	 have the same form.  */
name|store_address
argument_list|(
name|VALUE_CONTENTS_RAW
argument_list|(
name|val
argument_list|)
argument_list|,
name|len
argument_list|,
operator|(
name|CORE_ADDR
operator|)
name|num
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Unexpected type encountered for integer constant."
argument_list|)
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
end_function

begin_function
name|value
name|value_from_double
parameter_list|(
name|type
parameter_list|,
name|num
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|double
name|num
decl_stmt|;
block|{
specifier|register
name|value
name|val
init|=
name|allocate_value
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|enum
name|type_code
name|code
init|=
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|TYPE_CODE_FLT
condition|)
block|{
if|if
condition|(
name|len
operator|==
sizeof|sizeof
argument_list|(
name|float
argument_list|)
condition|)
operator|*
operator|(
name|float
operator|*
operator|)
name|VALUE_CONTENTS_RAW
argument_list|(
name|val
argument_list|)
operator|=
name|num
expr_stmt|;
elseif|else
if|if
condition|(
name|len
operator|==
sizeof|sizeof
argument_list|(
name|double
argument_list|)
condition|)
operator|*
operator|(
name|double
operator|*
operator|)
name|VALUE_CONTENTS_RAW
argument_list|(
name|val
argument_list|)
operator|=
name|num
expr_stmt|;
else|else
name|error
argument_list|(
literal|"Floating type encountered with unexpected data length."
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"Unexpected type encountered for floating constant."
argument_list|)
expr_stmt|;
comment|/* num was in host byte order.  So now put the value's contents      into target byte order.  */
name|SWAP_TARGET_AND_HOST
argument_list|(
name|VALUE_CONTENTS_RAW
argument_list|(
name|val
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Deal with the value that is "about to be returned".  */
end_comment

begin_comment
comment|/* Return the value that a function returning now    would be returning to its caller, assuming its type is VALTYPE.    RETBUF is where we look for what ought to be the contents    of the registers (in raw form).  This is because it is often    desirable to restore old values to those registers    after saving the contents of interest, and then call    this function using the saved values.    struct_return is non-zero when the function in question is    using the structure return conventions on the machine in question;    0 when it is using the value returning conventions (this often    means returning pointer to where structure is vs. returning value). */
end_comment

begin_function
name|value
name|value_being_returned
parameter_list|(
name|valtype
parameter_list|,
name|retbuf
parameter_list|,
name|struct_return
parameter_list|)
specifier|register
name|struct
name|type
modifier|*
name|valtype
decl_stmt|;
name|char
name|retbuf
index|[
name|REGISTER_BYTES
index|]
decl_stmt|;
name|int
name|struct_return
decl_stmt|;
comment|/*ARGSUSED*/
block|{
specifier|register
name|value
name|val
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|EXTRACT_STRUCT_VALUE_ADDRESS
argument_list|)
comment|/* If this is not defined, just use EXTRACT_RETURN_VALUE instead.  */
if|if
condition|(
name|struct_return
condition|)
block|{
name|addr
operator|=
name|EXTRACT_STRUCT_VALUE_ADDRESS
argument_list|(
name|retbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|addr
condition|)
name|error
argument_list|(
literal|"Function return value unknown"
argument_list|)
expr_stmt|;
return|return
name|value_at
argument_list|(
name|valtype
argument_list|,
name|addr
argument_list|)
return|;
block|}
endif|#
directive|endif
name|val
operator|=
name|allocate_value
argument_list|(
name|valtype
argument_list|)
expr_stmt|;
name|EXTRACT_RETURN_VALUE
argument_list|(
name|valtype
argument_list|,
name|retbuf
argument_list|,
name|VALUE_CONTENTS_RAW
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Should we use EXTRACT_STRUCT_VALUE_ADDRESS instead of    EXTRACT_RETURN_VALUE?  GCC_P is true if compiled with gcc    and TYPE is the type (which is known to be struct, union or array).     On most machines, the struct convention is used unless we are    using gcc and the type is of a special size.  */
end_comment

begin_comment
comment|/* As of about 31 Mar 93, GCC was changed to be compatible with the    native compiler.  GCC 2.3.3 was the last release that did it the    old way.  Since gcc2_compiled was not changed, we have no    way to correctly win in all cases, so we just do the right thing    for gcc1 and for gcc2 after this change.  Thus it loses for gcc    2.0-2.3.3.  This is somewhat unfortunate, but changing gcc2_compiled    would cause more chaos than dealing with some struct returns being    handled wrong.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|USE_STRUCT_CONVENTION
argument_list|)
end_if

begin_define
define|#
directive|define
name|USE_STRUCT_CONVENTION
parameter_list|(
name|gcc_p
parameter_list|,
name|type
parameter_list|)
define|\
value|(!((gcc_p == 1)&& (TYPE_LENGTH (value_type) == 1                \ 		      || TYPE_LENGTH (value_type) == 2             \ 		      || TYPE_LENGTH (value_type) == 4             \ 		      || TYPE_LENGTH (value_type) == 8             \ 		      )                                            \      ))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Return true if the function specified is using the structure returning    convention on this machine to return arguments, or 0 if it is using    the value returning convention.  FUNCTION is the value representing    the function, FUNCADDR is the address of the function, and VALUE_TYPE    is the type returned by the function.  GCC_P is nonzero if compiled    with GCC.  */
end_comment

begin_function
name|int
name|using_struct_return
parameter_list|(
name|function
parameter_list|,
name|funcaddr
parameter_list|,
name|value_type
parameter_list|,
name|gcc_p
parameter_list|)
name|value
name|function
decl_stmt|;
name|CORE_ADDR
name|funcaddr
decl_stmt|;
name|struct
name|type
modifier|*
name|value_type
decl_stmt|;
name|int
name|gcc_p
decl_stmt|;
comment|/*ARGSUSED*/
block|{
specifier|register
name|enum
name|type_code
name|code
init|=
name|TYPE_CODE
argument_list|(
name|value_type
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|TYPE_CODE_ERROR
condition|)
name|error
argument_list|(
literal|"Function return type unknown."
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|TYPE_CODE_STRUCT
operator|||
name|code
operator|==
name|TYPE_CODE_UNION
operator|||
name|code
operator|==
name|TYPE_CODE_ARRAY
condition|)
return|return
name|USE_STRUCT_CONVENTION
argument_list|(
name|gcc_p
argument_list|,
name|value_type
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Store VAL so it will be returned if a function returns now.    Does not verify that VAL's type matches what the current    function wants to return.  */
end_comment

begin_function
name|void
name|set_return_value
parameter_list|(
name|val
parameter_list|)
name|value
name|val
decl_stmt|;
block|{
specifier|register
name|enum
name|type_code
name|code
init|=
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
decl_stmt|;
name|double
name|dbuf
decl_stmt|;
name|LONGEST
name|lbuf
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|TYPE_CODE_ERROR
condition|)
name|error
argument_list|(
literal|"Function return type unknown."
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|TYPE_CODE_STRUCT
operator|||
name|code
operator|==
name|TYPE_CODE_UNION
condition|)
comment|/* FIXME, implement struct return.  */
name|error
argument_list|(
literal|"GDB does not support specifying a struct or union return value."
argument_list|)
expr_stmt|;
comment|/* FIXME, this is bogus.  We don't know what the return conventions      are, or how values should be promoted.... */
if|if
condition|(
name|code
operator|==
name|TYPE_CODE_FLT
condition|)
block|{
name|dbuf
operator|=
name|value_as_double
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|STORE_RETURN_VALUE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|dbuf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lbuf
operator|=
name|value_as_long
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|STORE_RETURN_VALUE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|lbuf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|_initialize_values
parameter_list|()
block|{
name|add_cmd
argument_list|(
literal|"convenience"
argument_list|,
name|no_class
argument_list|,
name|show_convenience
argument_list|,
literal|"Debugger convenience (\"$foo\") variables.\n\ These variables are created when you assign them values;\n\ thus, \"print $foo=1\" gives \"$foo\" the value 1.  Values may be any type.\n\n\ A few convenience variables are given values automatically:\n\ \"$_\"holds the last address examined with \"x\" or \"info lines\",\n\ \"$__\" holds the contents of the last address examined with \"x\"."
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"values"
argument_list|,
name|no_class
argument_list|,
name|show_values
argument_list|,
literal|"Elements of value history around item number IDX (or last ten)."
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

