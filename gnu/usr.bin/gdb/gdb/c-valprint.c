begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Support for printing C values for GDB, the GNU debugger.    Copyright 1986, 1988, 1989, 1991, 1992, 1993, 1994              Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|"valprint.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_comment
comment|/* BEGIN-FIXME */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|vtblprint
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Controls printing of vtbl's */
end_comment

begin_decl_stmt
specifier|extern
name|void
name|cp_print_class_member
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
expr|struct
name|type
operator|*
operator|,
name|GDB_FILE
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|cp_print_class_method
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
expr|struct
name|type
operator|*
operator|,
name|GDB_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|cp_print_value_fields
name|PARAMS
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|,
name|char
operator|*
operator|,
name|GDB_FILE
operator|*
operator|,
name|int
operator|,
name|int
operator|,
expr|enum
name|val_prettyprint
operator|,
expr|struct
name|type
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|cp_is_vtbl_ptr_type
name|PARAMS
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|cp_is_vtbl_member
name|PARAMS
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* END-FIXME */
end_comment

begin_comment
comment|/* BEGIN-FIXME:  Hooks into c-typeprint.c */
end_comment

begin_decl_stmt
specifier|extern
name|void
name|c_type_print_varspec_prefix
name|PARAMS
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|,
name|GDB_FILE
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|cp_type_print_method_args
name|PARAMS
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|,
name|GDB_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* END-FIXME */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|obstack
name|dont_print_obstack
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Print data of type TYPE located at VALADDR (within GDB), which came from    the inferior at address ADDRESS, onto stdio stream STREAM according to    FORMAT (a letter or 0 for natural format).  The data at VALADDR is in    target byte order.     If the data are a string pointer, returns the number of string characters    printed.     If DEREF_REF is nonzero, then dereference references, otherwise just print    them like pointers.     The PRETTY parameter controls prettyprinting.  */
end_comment

begin_function
name|int
name|c_val_print
parameter_list|(
name|type
parameter_list|,
name|valaddr
parameter_list|,
name|address
parameter_list|,
name|stream
parameter_list|,
name|format
parameter_list|,
name|deref_ref
parameter_list|,
name|recurse
parameter_list|,
name|pretty
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|char
modifier|*
name|valaddr
decl_stmt|;
name|CORE_ADDR
name|address
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|format
decl_stmt|;
name|int
name|deref_ref
decl_stmt|;
name|int
name|recurse
decl_stmt|;
name|enum
name|val_prettyprint
name|pretty
decl_stmt|;
block|{
specifier|register
name|unsigned
name|int
name|i
init|=
literal|0
decl_stmt|;
comment|/* Number of characters printed */
name|unsigned
name|len
decl_stmt|;
name|struct
name|type
modifier|*
name|elttype
decl_stmt|;
name|unsigned
name|eltlen
decl_stmt|;
name|LONGEST
name|val
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_ARRAY
case|:
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|>
literal|0
operator|&&
name|TYPE_LENGTH
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|>
literal|0
condition|)
block|{
name|elttype
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|eltlen
operator|=
name|TYPE_LENGTH
argument_list|(
name|elttype
argument_list|)
expr_stmt|;
name|len
operator|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|/
name|eltlen
expr_stmt|;
if|if
condition|(
name|prettyprint_arrays
condition|)
block|{
name|print_spaces_filtered
argument_list|(
literal|2
operator|+
literal|2
operator|*
name|recurse
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
comment|/* For an array of chars, print with string syntax.  */
if|if
condition|(
name|eltlen
operator|==
literal|1
operator|&&
operator|(
operator|(
name|TYPE_CODE
argument_list|(
name|elttype
argument_list|)
operator|==
name|TYPE_CODE_INT
operator|)
operator|||
operator|(
operator|(
name|current_language
operator|->
name|la_language
operator|==
name|language_m2
operator|)
operator|&&
operator|(
name|TYPE_CODE
argument_list|(
name|elttype
argument_list|)
operator|==
name|TYPE_CODE_CHAR
operator|)
operator|)
operator|)
operator|&&
operator|(
name|format
operator|==
literal|0
operator|||
name|format
operator|==
literal|'s'
operator|)
condition|)
block|{
comment|/* If requested, look for the first null char and only print 		 elements up to it.  */
if|if
condition|(
name|stop_print_at_null
condition|)
block|{
name|int
name|temp_len
decl_stmt|;
comment|/* Look for a NULL char. */
for|for
control|(
name|temp_len
operator|=
literal|0
init|;
name|valaddr
index|[
name|temp_len
index|]
operator|&&
name|temp_len
operator|<
name|len
operator|&&
name|temp_len
operator|<
name|print_max
condition|;
name|temp_len
operator|++
control|)
empty_stmt|;
name|len
operator|=
name|temp_len
expr_stmt|;
block|}
name|LA_PRINT_STRING
argument_list|(
name|stream
argument_list|,
name|valaddr
argument_list|,
name|len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|i
operator|=
name|len
expr_stmt|;
block|}
else|else
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"{"
argument_list|)
expr_stmt|;
comment|/* If this is a virtual function table, print the 0th 		 entry specially, and the rest of the members normally.  */
if|if
condition|(
name|cp_is_vtbl_ptr_type
argument_list|(
name|elttype
argument_list|)
condition|)
block|{
name|i
operator|=
literal|1
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%d vtable entries"
argument_list|,
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
literal|0
expr_stmt|;
block|}
name|val_print_array_elements
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|,
name|address
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|deref_ref
argument_list|,
name|recurse
argument_list|,
name|pretty
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"}"
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
comment|/* Array of unspecified length: treat like pointer to first elt.  */
name|addr
operator|=
name|address
expr_stmt|;
goto|goto
name|print_unpacked_pointer
goto|;
case|case
name|TYPE_CODE_PTR
case|:
if|if
condition|(
name|format
operator|&&
name|format
operator|!=
literal|'s'
condition|)
block|{
name|print_scalar_formatted
argument_list|(
name|valaddr
argument_list|,
name|type
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|vtblprint
operator|&&
name|cp_is_vtbl_ptr_type
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* Print the unmangled name if desired.  */
comment|/* Print vtable entry - we only get here if we ARE using 	     -fvtable_thunks.  (Otherwise, look under TYPE_CODE_STRUCT.) */
name|print_address_demangle
argument_list|(
name|extract_address
argument_list|(
name|valaddr
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|stream
argument_list|,
name|demangle
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_METHOD
condition|)
block|{
name|cp_print_class_method
argument_list|(
name|valaddr
argument_list|,
name|type
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_MEMBER
condition|)
block|{
name|cp_print_class_member
argument_list|(
name|valaddr
argument_list|,
name|TYPE_DOMAIN_TYPE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|"&"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|addr
operator|=
name|unpack_pointer
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|)
expr_stmt|;
name|print_unpacked_pointer
label|:
name|elttype
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|elttype
argument_list|)
operator|==
name|TYPE_CODE_FUNC
condition|)
block|{
comment|/* Try to print what function it points to.  */
name|print_address_demangle
argument_list|(
name|addr
argument_list|,
name|stream
argument_list|,
name|demangle
argument_list|)
expr_stmt|;
comment|/* Return value is irrelevant except for string pointers.  */
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|addressprint
operator|&&
name|format
operator|!=
literal|'s'
condition|)
block|{
name|print_address_numeric
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
comment|/* For a pointer to char or unsigned char, also print the string 	     pointed to, unless pointer is null.  */
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|elttype
argument_list|)
operator|==
literal|1
operator|&&
name|TYPE_CODE
argument_list|(
name|elttype
argument_list|)
operator|==
name|TYPE_CODE_INT
operator|&&
operator|(
name|format
operator|==
literal|0
operator|||
name|format
operator|==
literal|'s'
operator|)
operator|&&
name|addr
operator|!=
literal|0
condition|)
block|{
name|i
operator|=
name|val_print_string
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cp_is_vtbl_member
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* print vtbl's nicely */
name|CORE_ADDR
name|vt_address
init|=
name|unpack_pointer
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|)
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|msymbol
init|=
name|lookup_minimal_symbol_by_pc
argument_list|(
name|vt_address
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|msymbol
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|vt_address
operator|==
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
operator|)
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|"<"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|SYMBOL_SOURCE_NAME
argument_list|(
name|msymbol
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|">"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vt_address
operator|&&
name|vtblprint
condition|)
block|{
name|value_ptr
name|vt_val
decl_stmt|;
name|struct
name|symbol
modifier|*
name|wsym
init|=
operator|(
expr|struct
name|symbol
operator|*
operator|)
name|NULL
decl_stmt|;
name|struct
name|type
modifier|*
name|wtype
decl_stmt|;
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
name|struct
name|block
modifier|*
name|block
init|=
operator|(
expr|struct
name|block
operator|*
operator|)
name|NULL
decl_stmt|;
name|int
name|is_this_fld
decl_stmt|;
if|if
condition|(
name|msymbol
operator|!=
name|NULL
condition|)
name|wsym
operator|=
name|lookup_symbol
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|msymbol
argument_list|)
argument_list|,
name|block
argument_list|,
name|VAR_NAMESPACE
argument_list|,
operator|&
name|is_this_fld
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|wsym
condition|)
block|{
name|wtype
operator|=
name|SYMBOL_TYPE
argument_list|(
name|wsym
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wtype
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
name|vt_val
operator|=
name|value_at
argument_list|(
name|wtype
argument_list|,
name|vt_address
argument_list|)
expr_stmt|;
name|val_print
argument_list|(
name|VALUE_TYPE
argument_list|(
name|vt_val
argument_list|)
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|vt_val
argument_list|)
argument_list|,
name|VALUE_ADDRESS
argument_list|(
name|vt_val
argument_list|)
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|deref_ref
argument_list|,
name|recurse
operator|+
literal|1
argument_list|,
name|pretty
argument_list|)
expr_stmt|;
if|if
condition|(
name|pretty
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|print_spaces_filtered
argument_list|(
literal|2
operator|+
literal|2
operator|*
name|recurse
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Return number of characters printed, including the terminating 	     '\0' if we reached the end.  val_print_string takes care including 	     the terminating '\0' if necessary.  */
return|return
name|i
return|;
block|}
break|break;
case|case
name|TYPE_CODE_MEMBER
case|:
name|error
argument_list|(
literal|"not implemented: member type in c_val_print"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_REF
case|:
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_MEMBER
condition|)
block|{
name|cp_print_class_member
argument_list|(
name|valaddr
argument_list|,
name|TYPE_DOMAIN_TYPE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|""
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|addressprint
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"@"
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|extract_address
argument_list|(
name|valaddr
argument_list|,
name|TARGET_PTR_BIT
operator|/
name|HOST_CHAR_BIT
argument_list|)
argument_list|,
literal|1
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|deref_ref
condition|)
name|fputs_filtered
argument_list|(
literal|": "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
comment|/* De-reference the reference.  */
if|if
condition|(
name|deref_ref
condition|)
block|{
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_UNDEF
condition|)
block|{
name|value_ptr
name|deref_val
init|=
name|value_at
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|unpack_pointer
argument_list|(
name|lookup_pointer_type
argument_list|(
name|builtin_type_void
argument_list|)
argument_list|,
name|valaddr
argument_list|)
argument_list|)
decl_stmt|;
name|val_print
argument_list|(
name|VALUE_TYPE
argument_list|(
name|deref_val
argument_list|)
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|deref_val
argument_list|)
argument_list|,
name|VALUE_ADDRESS
argument_list|(
name|deref_val
argument_list|)
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|deref_ref
argument_list|,
name|recurse
operator|+
literal|1
argument_list|,
name|pretty
argument_list|)
expr_stmt|;
block|}
else|else
name|fputs_filtered
argument_list|(
literal|"???"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_CODE_UNION
case|:
if|if
condition|(
name|recurse
operator|&&
operator|!
name|unionprint
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"{...}"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Fall through.  */
case|case
name|TYPE_CODE_STRUCT
case|:
if|if
condition|(
name|vtblprint
operator|&&
name|cp_is_vtbl_ptr_type
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* Print the unmangled name if desired.  */
comment|/* Print vtable entry - we only get here if NOT using 	     -fvtable_thunks.  (Otherwise, look under TYPE_CODE_PTR.) */
name|print_address_demangle
argument_list|(
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
operator|(
name|valaddr
operator|+
comment|/* FIXME bytesex */
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|VTBL_FNADDR_OFFSET
argument_list|)
operator|/
literal|8
operator|)
operator|)
argument_list|,
name|stream
argument_list|,
name|demangle
argument_list|)
expr_stmt|;
break|break;
block|}
name|cp_print_value_fields
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|recurse
argument_list|,
name|pretty
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_ENUM
case|:
if|if
condition|(
name|format
condition|)
block|{
name|print_scalar_formatted
argument_list|(
name|valaddr
argument_list|,
name|type
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
block|}
name|len
operator|=
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|val
operator|=
name|unpack_long
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|<
name|len
condition|)
block|{
name|fputs_filtered
argument_list|(
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|print_longest
argument_list|(
name|stream
argument_list|,
literal|'d'
argument_list|,
literal|0
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_CODE_FUNC
case|:
if|if
condition|(
name|format
condition|)
block|{
name|print_scalar_formatted
argument_list|(
name|valaddr
argument_list|,
name|type
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* FIXME, we should consider, at least for ANSI C language, eliminating 	 the distinction made between FUNCs and POINTERs to FUNCs.  */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"{"
argument_list|)
expr_stmt|;
name|type_print
argument_list|(
name|type
argument_list|,
literal|""
argument_list|,
name|stream
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"} "
argument_list|)
expr_stmt|;
comment|/* Try to print what function it points to, and its address.  */
name|print_address_demangle
argument_list|(
name|address
argument_list|,
name|stream
argument_list|,
name|demangle
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_BOOL
case|:
comment|/* Do something at least vaguely reasonable, for example if the 	 language is set wrong.  */
case|case
name|TYPE_CODE_RANGE
case|:
comment|/* FIXME: create_range_type does not set the unsigned bit in a 	 range type (I think it probably should copy it from the target 	 type), so we won't print values which are too large to 	 fit in a signed integer correctly.  */
comment|/* FIXME: Doesn't handle ranges of enums correctly.  (Can't just 	 print with the target type, though, because the size of our type 	 and the target type might differ).  */
comment|/* FALLTHROUGH */
case|case
name|TYPE_CODE_INT
case|:
name|format
operator|=
name|format
condition|?
name|format
else|:
name|output_format
expr_stmt|;
if|if
condition|(
name|format
condition|)
block|{
name|print_scalar_formatted
argument_list|(
name|valaddr
argument_list|,
name|type
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|val_print_type_code_int
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|,
name|stream
argument_list|)
expr_stmt|;
comment|/* C and C++ has no single byte int type, char is used instead. 	     Since we don't know whether the value is really intended to 	     be used as an integer or a character, print the character 	     equivalent as well. */
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|==
literal|1
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|" "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|LA_PRINT_CHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|unpack_long
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|TYPE_CODE_CHAR
case|:
name|format
operator|=
name|format
condition|?
name|format
else|:
name|output_format
expr_stmt|;
if|if
condition|(
name|format
condition|)
block|{
name|print_scalar_formatted
argument_list|(
name|valaddr
argument_list|,
name|type
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|?
literal|"%u"
else|:
literal|"%d"
argument_list|,
name|unpack_long
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|)
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|" "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|LA_PRINT_CHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|unpack_long
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_CODE_FLT
case|:
if|if
condition|(
name|format
condition|)
block|{
name|print_scalar_formatted
argument_list|(
name|valaddr
argument_list|,
name|type
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|print_floating
argument_list|(
name|valaddr
argument_list|,
name|type
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_CODE_VOID
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"void"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_ERROR
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<error type>"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_UNDEF
case|:
comment|/* This happens (without TYPE_FLAG_STUB set) on systems which don't use 	 dbx xrefs (NO_DBX_XREFS in gcc) if a file has a "struct foo *bar" 	 and no complete type for struct foo in that file.  */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<incomplete type>"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Invalid C/C++ type code %d in symbol table."
argument_list|,
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|gdb_flush
argument_list|(
name|stream
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|c_value_print
parameter_list|(
name|val
parameter_list|,
name|stream
parameter_list|,
name|format
parameter_list|,
name|pretty
parameter_list|)
name|value_ptr
name|val
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|format
decl_stmt|;
name|enum
name|val_prettyprint
name|pretty
decl_stmt|;
block|{
comment|/* A "repeated" value really contains several values in a row.      They are made by the @ operator.      Print such values as if they were arrays.  */
if|if
condition|(
name|VALUE_REPEATED
argument_list|(
name|val
argument_list|)
condition|)
block|{
specifier|register
name|unsigned
name|int
name|n
init|=
name|VALUE_REPETITIONS
argument_list|(
name|val
argument_list|)
decl_stmt|;
specifier|register
name|unsigned
name|int
name|typelen
init|=
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
decl_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"{"
argument_list|)
expr_stmt|;
comment|/* Print arrays of characters using string syntax.  */
if|if
condition|(
name|typelen
operator|==
literal|1
operator|&&
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_INT
operator|&&
name|format
operator|==
literal|0
condition|)
name|LA_PRINT_STRING
argument_list|(
name|stream
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|val
argument_list|)
argument_list|,
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|value_print_array_elements
argument_list|(
name|val
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|pretty
argument_list|)
expr_stmt|;
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"}"
argument_list|)
expr_stmt|;
return|return
operator|(
name|n
operator|*
name|typelen
operator|)
return|;
block|}
else|else
block|{
name|struct
name|type
modifier|*
name|type
init|=
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
decl_stmt|;
comment|/* If it is a pointer, indicate what it points to.  	 Print type also if it is a reference.           C++: if it is a member pointer, we will take care 	 of that when we print it.  */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_PTR
operator|||
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_REF
condition|)
block|{
comment|/* Hack:  remove (char *) for char strings.  Their 	     type is indicated by the quoted string anyway. */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_PTR
operator|&&
name|TYPE_LENGTH
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|&&
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_INT
operator|&&
operator|!
name|TYPE_UNSIGNED
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Print nothing */
block|}
else|else
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|type_print
argument_list|(
name|type
argument_list|,
literal|""
argument_list|,
name|stream
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|") "
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|val_print
argument_list|(
name|type
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|val
argument_list|)
argument_list|,
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|pretty
argument_list|)
operator|)
return|;
block|}
block|}
end_function

end_unit

