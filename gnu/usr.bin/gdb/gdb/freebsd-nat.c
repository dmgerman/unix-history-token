begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Native-dependent code for BSD Unix running on i386's, for GDB.    Copyright 1988, 1989, 1991, 1992 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  	$Id: freebsd-nat.c,v 1.7 1995/05/30 04:57:05 rgrimes Exp $ */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<machine/reg.h>
end_include

begin_include
include|#
directive|include
file|<machine/frame.h>
end_include

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_comment
comment|/* this table must line up with REGISTER_NAMES in tm-i386v.h */
end_comment

begin_comment
comment|/* symbols like 'tEAX' come from<machine/reg.h> */
end_comment

begin_decl_stmt
specifier|static
name|int
name|tregmap
index|[]
init|=
block|{
name|tEAX
block|,
name|tECX
block|,
name|tEDX
block|,
name|tEBX
block|,
name|tESP
block|,
name|tEBP
block|,
name|tESI
block|,
name|tEDI
block|,
name|tEIP
block|,
name|tEFLAGS
block|,
name|tCS
block|,
name|tSS
block|,
name|tDS
block|,
name|tES
block|,
name|tSS
block|,
name|tSS
block|,
comment|/* lies: no fs or gs */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* blockend is the value of u.u_ar0, and points to the    place where ES is stored.  */
end_comment

begin_function
name|int
name|i386_register_u_addr
parameter_list|(
name|blockend
parameter_list|,
name|regnum
parameter_list|)
name|int
name|blockend
decl_stmt|;
name|int
name|regnum
decl_stmt|;
block|{
return|return
operator|(
name|blockend
operator|+
literal|4
operator|*
name|tregmap
index|[
name|regnum
index|]
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|fpstate
value|save87
end_define

begin_define
define|#
directive|define
name|U_FPSTATE
parameter_list|(
name|u
parameter_list|)
value|u.u_pcb.pcb_savefpu
end_define

begin_function
specifier|static
name|void
name|i387_to_double
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|)
name|char
modifier|*
name|from
decl_stmt|;
name|char
modifier|*
name|to
decl_stmt|;
block|{
name|long
modifier|*
name|lp
decl_stmt|;
comment|/* push extended mode on 387 stack, then pop in double mode    *    * first, set exception masks so no error is generated -    * number will be rounded to inf or 0, if necessary    */
asm|asm ("pushl %eax");
comment|/* grab a stack slot */
asm|asm ("fstcw (%esp)");
comment|/* get 387 control word */
asm|asm ("movl (%esp),%eax");
comment|/* save old value */
asm|asm ("orl $0x3f,%eax");
comment|/* mask all exceptions */
asm|asm ("pushl %eax");
asm|asm ("fldcw (%esp)");
comment|/* load new value into 387 */
asm|asm ("movl 8(%ebp),%eax");
asm|asm ("fldt (%eax)");
comment|/* push extended number on 387 stack */
asm|asm ("fwait");
asm|asm ("movl 12(%ebp),%eax");
asm|asm ("fstpl (%eax)");
comment|/* pop double */
asm|asm ("fwait");
asm|asm ("popl %eax");
comment|/* flush modified control word */
asm|asm ("fnclex");
comment|/* clear exceptions */
asm|asm ("fldcw (%esp)");
comment|/* restore original control word */
asm|asm ("popl %eax");
comment|/* flush saved copy */
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|static void double_to_i387 (from, to)      char *from;      char *to; {
comment|/* push double mode on 387 stack, then pop in extended mode    * no errors are possible because every 64-bit pattern    * can be converted to an extended    */
end_comment

begin_endif
unit|asm ("movl 8(%ebp),%eax");   asm ("fldl (%eax)");   asm ("fwait");   asm ("movl 12(%ebp),%eax");   asm ("fstpt (%eax)");   asm ("fwait"); }
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|env387
block|{
name|unsigned
name|short
name|control
decl_stmt|;
name|unsigned
name|short
name|r0
decl_stmt|;
name|unsigned
name|short
name|status
decl_stmt|;
name|unsigned
name|short
name|r1
decl_stmt|;
name|unsigned
name|short
name|tag
decl_stmt|;
name|unsigned
name|short
name|r2
decl_stmt|;
name|unsigned
name|long
name|eip
decl_stmt|;
name|unsigned
name|short
name|code_seg
decl_stmt|;
name|unsigned
name|short
name|opcode
decl_stmt|;
name|unsigned
name|long
name|operand
decl_stmt|;
name|unsigned
name|short
name|operand_seg
decl_stmt|;
name|unsigned
name|short
name|r3
decl_stmt|;
name|unsigned
name|char
name|regs
index|[
literal|8
index|]
index|[
literal|10
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* static */
end_comment

begin_function
name|void
name|print_387_control_word
parameter_list|(
name|control
parameter_list|)
name|unsigned
name|int
name|control
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"control 0x%04x: "
argument_list|,
name|control
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"compute to "
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|control
operator|>>
literal|8
operator|)
operator|&
literal|3
condition|)
block|{
case|case
literal|0
case|:
name|printf
argument_list|(
literal|"24 bits; "
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|printf
argument_list|(
literal|"(bad); "
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|printf
argument_list|(
literal|"53 bits; "
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|printf
argument_list|(
literal|"64 bits; "
argument_list|)
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|"round "
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|control
operator|>>
literal|10
operator|)
operator|&
literal|3
condition|)
block|{
case|case
literal|0
case|:
name|printf
argument_list|(
literal|"NEAREST; "
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|printf
argument_list|(
literal|"DOWN; "
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|printf
argument_list|(
literal|"UP; "
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|printf
argument_list|(
literal|"CHOP; "
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|control
operator|&
literal|0x3f
condition|)
block|{
name|printf
argument_list|(
literal|"mask:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|&
literal|0x0001
condition|)
name|printf
argument_list|(
literal|" INVALID"
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|&
literal|0x0002
condition|)
name|printf
argument_list|(
literal|" DENORM"
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|&
literal|0x0004
condition|)
name|printf
argument_list|(
literal|" DIVZ"
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|&
literal|0x0008
condition|)
name|printf
argument_list|(
literal|" OVERF"
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|&
literal|0x0010
condition|)
name|printf
argument_list|(
literal|" UNDERF"
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|&
literal|0x0020
condition|)
name|printf
argument_list|(
literal|" LOS"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|";"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|&
literal|0xe080
condition|)
name|printf
argument_list|(
literal|"warning: reserved bits on 0x%x\n"
argument_list|,
name|control
operator|&
literal|0xe080
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* static */
end_comment

begin_function
name|void
name|print_387_status_word
parameter_list|(
name|status
parameter_list|)
name|unsigned
name|int
name|status
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"status 0x%04x: "
argument_list|,
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
literal|0xff
condition|)
block|{
name|printf
argument_list|(
literal|"exceptions:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
literal|0x0001
condition|)
name|printf
argument_list|(
literal|" INVALID"
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
literal|0x0002
condition|)
name|printf
argument_list|(
literal|" DENORM"
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
literal|0x0004
condition|)
name|printf
argument_list|(
literal|" DIVZ"
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
literal|0x0008
condition|)
name|printf
argument_list|(
literal|" OVERF"
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
literal|0x0010
condition|)
name|printf
argument_list|(
literal|" UNDERF"
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
literal|0x0020
condition|)
name|printf
argument_list|(
literal|" LOS"
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
literal|0x0040
condition|)
name|printf
argument_list|(
literal|" FPSTACK"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"; "
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"flags: %d%d%d%d; "
argument_list|,
operator|(
name|status
operator|&
literal|0x4000
operator|)
operator|!=
literal|0
argument_list|,
operator|(
name|status
operator|&
literal|0x0400
operator|)
operator|!=
literal|0
argument_list|,
operator|(
name|status
operator|&
literal|0x0200
operator|)
operator|!=
literal|0
argument_list|,
operator|(
name|status
operator|&
literal|0x0100
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"top %d\n"
argument_list|,
operator|(
name|status
operator|>>
literal|11
operator|)
operator|&
literal|7
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_387_status
parameter_list|(
name|status
parameter_list|,
name|ep
parameter_list|)
name|unsigned
name|short
name|status
decl_stmt|;
name|struct
name|env387
modifier|*
name|ep
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|bothstatus
decl_stmt|;
name|int
name|top
decl_stmt|;
name|int
name|fpreg
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|bothstatus
operator|=
operator|(
operator|(
name|status
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|ep
operator|->
name|status
operator|!=
literal|0
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|bothstatus
condition|)
name|printf
argument_list|(
literal|"u: "
argument_list|)
expr_stmt|;
name|print_387_status_word
argument_list|(
operator|(
name|unsigned
name|int
operator|)
name|status
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ep
operator|->
name|status
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|bothstatus
condition|)
name|printf
argument_list|(
literal|"e: "
argument_list|)
expr_stmt|;
name|print_387_status_word
argument_list|(
operator|(
name|unsigned
name|int
operator|)
name|ep
operator|->
name|status
argument_list|)
expr_stmt|;
block|}
name|print_387_control_word
argument_list|(
operator|(
name|unsigned
name|int
operator|)
name|ep
operator|->
name|control
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"opcode 0x%x; "
argument_list|,
name|ep
operator|->
name|opcode
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"pc 0x%x:0x%x; "
argument_list|,
name|ep
operator|->
name|code_seg
argument_list|,
name|ep
operator|->
name|eip
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"operand 0x%x:0x%x\n"
argument_list|,
name|ep
operator|->
name|operand_seg
argument_list|,
name|ep
operator|->
name|operand
argument_list|)
expr_stmt|;
name|top
operator|=
operator|(
name|ep
operator|->
name|status
operator|>>
literal|11
operator|)
operator|&
literal|7
expr_stmt|;
name|printf
argument_list|(
literal|" regno     tag  msb              lsb  value\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|fpreg
operator|=
literal|7
init|;
name|fpreg
operator|>=
literal|0
condition|;
name|fpreg
operator|--
control|)
block|{
name|int
name|st_regno
decl_stmt|;
name|double
name|val
decl_stmt|;
comment|/* The physical regno `fpreg' is only relevant as an index into the        * tag word.  Logical `%st' numbers are required for indexing ep->regs.        */
name|st_regno
operator|=
operator|(
name|fpreg
operator|+
literal|8
operator|-
name|top
operator|)
operator|&
literal|7
expr_stmt|;
name|printf
argument_list|(
literal|"%%st(%d) %s "
argument_list|,
name|st_regno
argument_list|,
name|fpreg
operator|==
name|top
condition|?
literal|"=>"
else|:
literal|"  "
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|ep
operator|->
name|tag
operator|>>
operator|(
name|fpreg
operator|*
literal|2
operator|)
operator|)
operator|&
literal|3
condition|)
block|{
case|case
literal|0
case|:
name|printf
argument_list|(
literal|"valid "
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|printf
argument_list|(
literal|"zero  "
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|printf
argument_list|(
literal|"trap  "
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|printf
argument_list|(
literal|"empty "
argument_list|)
expr_stmt|;
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|9
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|printf
argument_list|(
literal|"%02x"
argument_list|,
name|ep
operator|->
name|regs
index|[
name|st_regno
index|]
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|i387_to_double
argument_list|(
name|ep
operator|->
name|regs
index|[
name|st_regno
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|val
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  %g\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|i386_float_info
parameter_list|()
block|{
name|struct
name|user
name|u
decl_stmt|;
comment|/* just for address computations */
name|int
name|i
decl_stmt|;
comment|/* fpstate defined in<sys/user.h> */
name|struct
name|fpstate
modifier|*
name|fpstatep
decl_stmt|;
name|char
name|buf
index|[
sizeof|sizeof
argument_list|(
expr|struct
name|fpstate
argument_list|)
operator|+
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
index|]
decl_stmt|;
name|unsigned
name|int
name|uaddr
decl_stmt|;
name|char
name|fpvalid
decl_stmt|;
name|unsigned
name|int
name|rounded_addr
decl_stmt|;
name|unsigned
name|int
name|rounded_size
decl_stmt|;
comment|/*extern int corechan;*/
name|int
name|skip
decl_stmt|;
specifier|extern
name|int
name|inferior_pid
decl_stmt|;
name|uaddr
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|U_FPSTATE
argument_list|(
name|u
argument_list|)
operator|-
operator|(
name|char
operator|*
operator|)
operator|&
name|u
expr_stmt|;
if|if
condition|(
name|inferior_pid
condition|)
block|{
name|int
modifier|*
name|ip
decl_stmt|;
name|rounded_addr
operator|=
name|uaddr
operator|&
operator|-
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|rounded_size
operator|=
operator|(
operator|(
operator|(
name|uaddr
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|fpstate
argument_list|)
operator|)
operator|-
name|uaddr
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|skip
operator|=
name|uaddr
operator|-
name|rounded_addr
expr_stmt|;
name|ip
operator|=
operator|(
name|int
operator|*
operator|)
name|buf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rounded_size
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|ip
operator|++
operator|=
name|ptrace
argument_list|(
name|PT_READ_U
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|caddr_t
operator|)
name|rounded_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rounded_addr
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|#
directive|if
literal|1
name|printf
argument_list|(
literal|"float info: can't do a core file (yet)\n"
argument_list|)
expr_stmt|;
return|return;
else|#
directive|else
if|if
condition|(
name|lseek
argument_list|(
name|corechan
argument_list|,
name|uaddr
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
literal|"seek on core file"
argument_list|)
expr_stmt|;
if|if
condition|(
name|myread
argument_list|(
name|corechan
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fpstate
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
literal|"read from core file"
argument_list|)
expr_stmt|;
name|skip
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
name|fpstatep
operator|=
operator|(
expr|struct
name|fpstate
operator|*
operator|)
operator|(
name|buf
operator|+
name|skip
operator|)
expr_stmt|;
name|print_387_status
argument_list|(
name|fpstatep
operator|->
name|sv_ex_sw
argument_list|,
operator|(
expr|struct
name|env387
operator|*
operator|)
name|fpstatep
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SETUP_ARBITRARY_FRAME
end_ifdef

begin_function
name|FRAME
name|setup_arbitrary_frame
parameter_list|(
name|numargs
parameter_list|,
name|args
parameter_list|)
name|int
name|numargs
decl_stmt|;
name|unsigned
name|int
modifier|*
name|args
decl_stmt|;
block|{
if|if
condition|(
name|numargs
operator|>
literal|2
condition|)
name|error
argument_list|(
literal|"Too many args in frame specification"
argument_list|)
expr_stmt|;
return|return
name|create_new_frame
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|args
index|[
literal|0
index|]
argument_list|,
operator|(
name|CORE_ADDR
operator|)
name|args
index|[
literal|1
index|]
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|KERNEL_DEBUG
end_ifdef

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<machine/vmparam.h>
end_include

begin_include
include|#
directive|include
file|<machine/pcb.h>
end_include

begin_define
define|#
directive|define
name|KERNOFF
value|((unsigned)KERNBASE)
end_define

begin_define
define|#
directive|define
name|INKERNEL
parameter_list|(
name|x
parameter_list|)
value|((x)>= KERNOFF)
end_define

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|sbr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|curpcb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|kstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|found_pcb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|devmem
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|kfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pcb
name|pcb
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|read_pcb
parameter_list|(
name|int
parameter_list|,
name|CORE_ADDR
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|CORE_ADDR
name|kvtophys
parameter_list|(
name|int
parameter_list|,
name|CORE_ADDR
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
specifier|static
name|physrd
argument_list|(
name|int
argument_list|,
name|u_int
argument_list|,
name|char
operator|*
argument_list|,
name|int
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|extern
name|CORE_ADDR
name|ksym_lookup
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* substitutes for the stuff in libkvm which doesn't work */
end_comment

begin_comment
comment|/* most of this was taken from the old kgdb */
end_comment

begin_comment
comment|/* we don't need all this stuff, but the call should look the same */
end_comment

begin_macro
name|kvm_open
argument_list|(
argument|efile
argument_list|,
argument|cfile
argument_list|,
argument|sfile
argument_list|,
argument|perm
argument_list|,
argument|errout
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|efile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|cfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|sfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* makes this kvm_open more compatible to the one in libkvm */
end_comment

begin_decl_stmt
name|int
name|perm
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|errout
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* makes this kvm_open more compatible to the one in libkvm */
end_comment

begin_block
block|{
name|struct
name|stat
name|stb
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|int
name|cfd
decl_stmt|;
if|if
condition|(
operator|(
name|cfd
operator|=
name|open
argument_list|(
name|cfile
argument_list|,
name|perm
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|cfd
operator|)
return|;
name|fstat
argument_list|(
name|cfd
argument_list|,
operator|&
name|stb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stb
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFCHR
operator|&&
name|stb
operator|.
name|st_rdev
operator|==
name|makedev
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|devmem
operator|=
literal|1
expr_stmt|;
name|kfd
operator|=
name|open
argument_list|(
literal|"/dev/kmem"
argument_list|,
name|perm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|physrd
argument_list|(
name|cfd
argument_list|,
name|ksym_lookup
argument_list|(
literal|"IdlePTD"
argument_list|)
operator|-
name|KERNOFF
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sbr
argument_list|,
sizeof|sizeof
name|sbr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"IdlePTD %x\n"
argument_list|,
name|sbr
argument_list|)
expr_stmt|;
name|curpcb
operator|=
name|ksym_lookup
argument_list|(
literal|"curpcb"
argument_list|)
operator|-
name|KERNOFF
expr_stmt|;
name|physrd
argument_list|(
name|cfd
argument_list|,
name|curpcb
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|curpcb
argument_list|,
sizeof|sizeof
name|curpcb
argument_list|)
expr_stmt|;
name|kstack
operator|=
name|ksym_lookup
argument_list|(
literal|"kstack"
argument_list|)
expr_stmt|;
name|found_pcb
operator|=
literal|1
expr_stmt|;
comment|/* for vtophys */
if|if
condition|(
operator|!
name|devmem
condition|)
name|read_pcb
argument_list|(
name|cfd
argument_list|,
name|ksym_lookup
argument_list|(
literal|"dumppcb"
argument_list|)
operator|-
name|KERNOFF
argument_list|)
expr_stmt|;
else|else
name|read_pcb
argument_list|(
name|cfd
argument_list|,
name|kvtophys
argument_list|(
name|cfd
argument_list|,
name|kstack
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|cfd
operator|)
return|;
block|}
end_block

begin_macro
name|kvm_close
argument_list|(
argument|fd
argument_list|)
end_macro

begin_block
block|{
return|return
operator|(
name|close
argument_list|(
name|fd
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|kvm_write
argument_list|(
argument|core_kd
argument_list|,
argument|memaddr
argument_list|,
argument|myaddr
argument_list|,
argument|len
argument_list|)
end_macro

begin_decl_stmt
name|CORE_ADDR
name|memaddr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|myaddr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|cc
decl_stmt|;
if|if
condition|(
name|devmem
condition|)
block|{
if|if
condition|(
name|kfd
operator|>
literal|0
condition|)
block|{
comment|/* 		 	* Just like kvm_read, only we write. 		 	*/
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|kfd
argument_list|,
operator|(
name|off_t
operator|)
name|memaddr
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"kvm_write:invalid address (%x)"
argument_list|,
name|memaddr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|cc
operator|=
name|write
argument_list|(
name|kfd
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"kvm_write:write failed"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|cc
operator|<
name|len
condition|)
name|error
argument_list|(
literal|"kvm_write:short write"
argument_list|)
expr_stmt|;
return|return
operator|(
name|cc
operator|)
return|;
block|}
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"kvm_write not implemented for dead kernels\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* NOTREACHED */
block|}
end_block

begin_macro
name|kvm_read
argument_list|(
argument|core_kd
argument_list|,
argument|memaddr
argument_list|,
argument|myaddr
argument_list|,
argument|len
argument_list|)
end_macro

begin_decl_stmt
name|CORE_ADDR
name|memaddr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|myaddr
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|kernel_core_file_hook
argument_list|(
name|core_kd
argument_list|,
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|kvm_uread
argument_list|(
name|core_kd
argument_list|,
name|p
argument_list|,
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
specifier|register
expr|struct
name|proc
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|CORE_ADDR
name|memaddr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|myaddr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|char
name|procfile
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|ssize_t
name|amount
decl_stmt|;
name|int
name|fd
decl_stmt|;
if|if
condition|(
name|devmem
condition|)
block|{
name|cp
operator|=
name|myaddr
expr_stmt|;
name|sprintf
argument_list|(
name|procfile
argument_list|,
literal|"/proc/%d/mem"
argument_list|,
name|p
operator|->
name|p_pid
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|procfile
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"cannot open %s"
argument_list|,
name|procfile
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
name|memaddr
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"invalid address (%x) in %s"
argument_list|,
name|memaddr
argument_list|,
name|procfile
argument_list|)
expr_stmt|;
break|break;
block|}
name|amount
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|cp
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|amount
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"error reading %s"
argument_list|,
name|procfile
argument_list|)
expr_stmt|;
break|break;
block|}
name|cp
operator|+=
name|amount
expr_stmt|;
name|memaddr
operator|+=
name|amount
expr_stmt|;
name|len
operator|-=
name|amount
expr_stmt|;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
call|(
name|ssize_t
call|)
argument_list|(
name|cp
operator|-
name|myaddr
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|kernel_core_file_hook
argument_list|(
name|core_kd
argument_list|,
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
operator|)
return|;
block|}
block|}
end_block

begin_expr_stmt
specifier|static
name|physrd
argument_list|(
argument|cfd
argument_list|,
argument|addr
argument_list|,
argument|dat
argument_list|,
argument|len
argument_list|)
name|u_int
name|addr
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|dat
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|lseek
argument_list|(
name|cfd
argument_list|,
operator|(
name|off_t
operator|)
name|addr
argument_list|,
name|L_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|read
argument_list|(
name|cfd
argument_list|,
name|dat
argument_list|,
name|len
argument_list|)
operator|)
return|;
block|}
end_block

begin_function
specifier|static
name|CORE_ADDR
name|kvtophys
parameter_list|(
name|fd
parameter_list|,
name|addr
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
block|{
name|CORE_ADDR
name|v
decl_stmt|;
name|struct
name|pte
name|pte
decl_stmt|;
specifier|static
name|CORE_ADDR
name|PTD
init|=
operator|-
literal|1
decl_stmt|;
name|CORE_ADDR
name|current_ptd
decl_stmt|;
comment|/* 	 * If we're looking at the kernel stack, 	 * munge the address to refer to the user space mapping instead; 	 * that way we get the requested process's kstack, not the running one. 	 */
if|if
condition|(
name|addr
operator|>=
name|kstack
operator|&&
name|addr
operator|<
name|kstack
operator|+
name|ctob
argument_list|(
name|UPAGES
argument_list|)
condition|)
name|addr
operator|=
operator|(
name|addr
operator|-
name|kstack
operator|)
operator|+
name|curpcb
expr_stmt|;
comment|/* 	 * We may no longer have a linear system page table... 	 * 	 * Here's the scoop.  IdlePTD contains the physical address 	 * of a page table directory that always maps the kernel. 	 * IdlePTD is in memory that is mapped 1-to-1, so we can 	 * find it easily given its 'virtual' address from ksym_lookup(). 	 * For hysterical reasons, the value of IdlePTD is stored in sbr. 	 * 	 * To look up a kernel address, we first convert it to a 1st-level 	 * address and look it up in IdlePTD.  This gives us the physical 	 * address of a page table page; we extract the 2nd-level part of 	 * VA and read the 2nd-level pte.  Finally, we add the offset part 	 * of the VA into the physical address from the pte and return it. 	 * 	 * User addresses are a little more complicated.  If we don't have 	 * a current PCB from read_pcb(), we use PTD, which is the (fixed) 	 * virtual address of the current ptd.  Since it's NOT in 1-to-1 	 * kernel space, we must look it up using IdlePTD.  If we do have 	 * a pcb, we get the ptd from pcb_ptd. 	 */
if|if
condition|(
name|INKERNEL
argument_list|(
name|addr
argument_list|)
condition|)
name|current_ptd
operator|=
name|sbr
expr_stmt|;
elseif|else
if|if
condition|(
name|found_pcb
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|PTD
operator|==
operator|-
literal|1
condition|)
name|PTD
operator|=
name|kvtophys
argument_list|(
name|fd
argument_list|,
name|ksym_lookup
argument_list|(
literal|"PTD"
argument_list|)
argument_list|)
expr_stmt|;
name|current_ptd
operator|=
name|PTD
expr_stmt|;
block|}
else|else
name|current_ptd
operator|=
name|pcb
operator|.
name|pcb_ptd
expr_stmt|;
comment|/* 	 * Read the first-level page table (ptd). 	 */
name|v
operator|=
name|current_ptd
operator|+
operator|(
operator|(
name|unsigned
operator|)
name|addr
operator|>>
name|PD_SHIFT
operator|)
operator|*
sizeof|sizeof
name|pte
expr_stmt|;
if|if
condition|(
name|physrd
argument_list|(
name|fd
argument_list|,
name|v
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pte
argument_list|,
sizeof|sizeof
name|pte
argument_list|)
operator|<
literal|0
operator|||
name|pte
operator|.
name|pg_v
operator|==
literal|0
condition|)
return|return
operator|(
operator|~
literal|0
operator|)
return|;
comment|/* 	 * Read the second-level page table. 	 */
name|v
operator|=
name|i386_ptob
argument_list|(
name|pte
operator|.
name|pg_pfnum
argument_list|)
operator|+
operator|(
operator|(
name|addr
operator|&
name|PT_MASK
operator|)
operator|>>
name|PG_SHIFT
operator|)
operator|*
sizeof|sizeof
name|pte
expr_stmt|;
if|if
condition|(
name|physrd
argument_list|(
name|fd
argument_list|,
name|v
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pte
argument_list|,
sizeof|sizeof
argument_list|(
name|pte
argument_list|)
argument_list|)
operator|<
literal|0
operator|||
name|pte
operator|.
name|pg_v
operator|==
literal|0
condition|)
return|return
operator|(
operator|~
literal|0
operator|)
return|;
name|addr
operator|=
name|i386_ptob
argument_list|(
name|pte
operator|.
name|pg_pfnum
argument_list|)
operator|+
operator|(
name|addr
operator|&
name|PGOFSET
operator|)
expr_stmt|;
if|#
directive|if
literal|0
block|printf("vtophys(%x) -> %x\n", oldaddr, addr);
endif|#
directive|endif
return|return
operator|(
name|addr
operator|)
return|;
block|}
end_function

begin_macro
name|read_pcb
argument_list|(
argument|fd
argument_list|,
argument|uaddr
argument_list|)
end_macro

begin_decl_stmt
name|CORE_ADDR
name|uaddr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|int
modifier|*
name|pcb_regs
init|=
operator|(
name|int
operator|*
operator|)
operator|&
name|pcb
decl_stmt|;
name|int
name|eip
decl_stmt|;
if|if
condition|(
name|physrd
argument_list|(
name|fd
argument_list|,
name|uaddr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pcb
argument_list|,
sizeof|sizeof
name|pcb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"cannot read pcb at %x\n"
argument_list|,
name|uaddr
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|printf
argument_list|(
literal|"current pcb at %x\n"
argument_list|,
name|uaddr
argument_list|)
expr_stmt|;
comment|/* 	 * get the register values out of the sys pcb and 	 * store them where `read_register' will find them. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
operator|++
name|i
control|)
name|supply_register
argument_list|(
name|i
argument_list|,
operator|&
name|pcb_regs
index|[
name|i
operator|+
literal|10
index|]
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
literal|8
argument_list|,
operator|&
name|pcb_regs
index|[
literal|8
index|]
argument_list|)
expr_stmt|;
comment|/* eip */
name|supply_register
argument_list|(
literal|9
argument_list|,
operator|&
name|pcb_regs
index|[
literal|9
index|]
argument_list|)
expr_stmt|;
comment|/* eflags */
for|for
control|(
name|i
operator|=
literal|10
init|;
name|i
operator|<
literal|13
condition|;
operator|++
name|i
control|)
comment|/* cs, ss, ds */
name|supply_register
argument_list|(
name|i
argument_list|,
operator|&
name|pcb_regs
index|[
name|i
operator|+
literal|9
index|]
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
literal|13
argument_list|,
operator|&
name|pcb_regs
index|[
literal|18
index|]
argument_list|)
expr_stmt|;
comment|/* es */
for|for
control|(
name|i
operator|=
literal|14
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
comment|/* fs, gs */
name|supply_register
argument_list|(
name|i
argument_list|,
operator|&
name|pcb_regs
index|[
name|i
operator|+
literal|8
index|]
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* doesn't work ??? */
comment|/* Hmm... */
block|if (target_read_memory(pcb_regs[5+10]+4,&eip, sizeof eip, 0)) 		error("Cannot read PC."); 	supply_register(8,&eip);
comment|/* eip */
endif|#
directive|endif
comment|/* XXX 80387 registers? */
block|}
end_block

begin_comment
comment|/*  * read len bytes from kernel virtual address 'addr' into local  * buffer 'buf'.  Return numbert of bytes if read ok, 0 otherwise.  On read  * errors, portion of buffer not read is zeroed.  */
end_comment

begin_macro
name|kernel_core_file_hook
argument_list|(
argument|fd
argument_list|,
argument|addr
argument_list|,
argument|buf
argument_list|,
argument|len
argument_list|)
end_macro

begin_decl_stmt
name|CORE_ADDR
name|addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|CORE_ADDR
name|paddr
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|cc
decl_stmt|;
name|cp
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|paddr
operator|=
name|kvtophys
argument_list|(
name|fd
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|paddr
operator|==
operator|~
literal|0
condition|)
block|{
name|bzero
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* we can't read across a page boundary */
name|i
operator|=
name|min
argument_list|(
name|len
argument_list|,
name|NBPG
operator|-
operator|(
name|addr
operator|&
name|PGOFSET
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cc
operator|=
name|physrd
argument_list|(
name|fd
argument_list|,
name|paddr
argument_list|,
name|cp
argument_list|,
name|i
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
name|bzero
argument_list|(
name|cp
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
name|cp
operator|-
name|buf
operator|)
return|;
block|}
name|cp
operator|+=
name|cc
expr_stmt|;
name|addr
operator|+=
name|cc
expr_stmt|;
name|len
operator|-=
name|cc
expr_stmt|;
block|}
return|return
operator|(
name|cp
operator|-
name|buf
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* KERNEL_DEBUG */
end_comment

end_unit

