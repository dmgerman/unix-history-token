begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Native-dependent code for BSD Unix running on i386's, for GDB.    Copyright 1988, 1989, 1991, 1992 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|<machine/reg.h>
end_include

begin_comment
comment|/* this table must line up with REGISTER_NAMES in tm-i386.h */
end_comment

begin_comment
comment|/* symbols like 'tEAX' come from<machine/reg.h> */
end_comment

begin_decl_stmt
specifier|static
name|int
name|tregmap
index|[]
init|=
block|{
name|tEAX
block|,
name|tECX
block|,
name|tEDX
block|,
name|tEBX
block|,
name|tESP
block|,
name|tEBP
block|,
name|tESI
block|,
name|tEDI
block|,
name|tEIP
block|,
name|tEFLAGS
block|,
name|tCS
block|,
name|tSS
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|sEAX
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|sregmap
index|[]
init|=
block|{
name|sEAX
block|,
name|sECX
block|,
name|sEDX
block|,
name|sEBX
block|,
name|sESP
block|,
name|sEBP
block|,
name|sESI
block|,
name|sEDI
block|,
name|sEIP
block|,
name|sEFLAGS
block|,
name|sCS
block|,
name|sSS
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* blockend is the value of u.u_ar0, and points to the    place where ES is stored.  */
end_comment

begin_function
name|int
name|i386_register_u_addr
parameter_list|(
name|blockend
parameter_list|,
name|regnum
parameter_list|)
name|int
name|blockend
decl_stmt|;
name|int
name|regnum
decl_stmt|;
block|{
comment|/* The following condition is a kludge to get at the proper register map      depending upon the state of pcb_flag.      The proper condition would be      if (u.u_pcb.pcb_flag& FM_TRAP)      but that would require a ptrace call here and wouldn't work      for corefiles.  */
ifdef|#
directive|ifdef
name|sEAX
if|if
condition|(
name|blockend
operator|<
literal|0x1fcc
condition|)
return|return
operator|(
name|blockend
operator|+
literal|4
operator|*
name|tregmap
index|[
name|regnum
index|]
operator|)
return|;
else|else
return|return
operator|(
name|blockend
operator|+
literal|4
operator|*
name|sregmap
index|[
name|regnum
index|]
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|blockend
operator|+
literal|4
operator|*
name|tregmap
index|[
name|regnum
index|]
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|FLOAT_INFO
end_ifdef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_define
define|#
directive|define
name|curpcb
value|Xcurpcb
end_define

begin_comment
comment|/* XXX avoid leaking declaration from pcb.h */
end_comment

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_undef
undef|#
directive|undef
name|curpcb
end_undef

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_define
define|#
directive|define
name|fpstate
value|save87
end_define

begin_define
define|#
directive|define
name|U_FPSTATE
parameter_list|(
name|u
parameter_list|)
value|u.u_pcb.pcb_savefpu
end_define

begin_macro
name|i387_to_double
argument_list|(
argument|from
argument_list|,
argument|to
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|from
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|to
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|long
modifier|*
name|lp
decl_stmt|;
comment|/* push extended mode on 387 stack, then pop in double mode    *    * first, set exception masks so no error is generated -    * number will be rounded to inf or 0, if necessary     */
asm|asm ("pushl %eax");
comment|/* grab a stack slot */
asm|asm ("fstcw (%esp)");
comment|/* get 387 control word */
asm|asm ("movl (%esp),%eax");
comment|/* save old value */
asm|asm ("orl $0x3f,%eax");
comment|/* mask all exceptions */
asm|asm ("pushl %eax");
asm|asm ("fldcw (%esp)");
comment|/* load new value into 387 */
asm|asm ("movl 8(%ebp),%eax");
asm|asm ("fldt (%eax)");
comment|/* push extended number on 387 stack */
asm|asm ("fwait");
asm|asm ("movl 12(%ebp),%eax");
asm|asm ("fstpl (%eax)");
comment|/* pop double */
asm|asm ("fwait");
asm|asm ("popl %eax");
comment|/* flush modified control word */
asm|asm ("fnclex");
comment|/* clear exceptions */
asm|asm ("fldcw (%esp)");
comment|/* restore original control word */
asm|asm ("popl %eax");
comment|/* flush saved copy */
block|}
end_block

begin_macro
name|double_to_i387
argument_list|(
argument|from
argument_list|,
argument|to
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|from
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|to
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* push double mode on 387 stack, then pop in extended mode    * no errors are possible because every 64-bit pattern    * can be converted to an extended    */
asm|asm ("movl 8(%ebp),%eax");
asm|asm ("fldl (%eax)");
asm|asm ("fwait");
asm|asm ("movl 12(%ebp),%eax");
asm|asm ("fstpt (%eax)");
asm|asm ("fwait");
block|}
end_block

begin_struct
struct|struct
name|env387
block|{
name|unsigned
name|short
name|control
decl_stmt|;
name|unsigned
name|short
name|r0
decl_stmt|;
name|unsigned
name|short
name|status
decl_stmt|;
name|unsigned
name|short
name|r1
decl_stmt|;
name|unsigned
name|short
name|tag
decl_stmt|;
name|unsigned
name|short
name|r2
decl_stmt|;
name|unsigned
name|long
name|eip
decl_stmt|;
name|unsigned
name|short
name|code_seg
decl_stmt|;
name|unsigned
name|short
name|opcode
decl_stmt|;
name|unsigned
name|long
name|operand
decl_stmt|;
name|unsigned
name|short
name|operand_seg
decl_stmt|;
name|unsigned
name|short
name|r3
decl_stmt|;
name|unsigned
name|char
name|regs
index|[
literal|8
index|]
index|[
literal|10
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|void
name|print_387_control_word
parameter_list|(
name|control
parameter_list|)
name|unsigned
name|int
name|control
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"control 0x%04x: "
argument_list|,
name|control
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"compute to "
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|control
operator|>>
literal|8
operator|)
operator|&
literal|3
condition|)
block|{
case|case
literal|0
case|:
name|printf
argument_list|(
literal|"24 bits; "
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|printf
argument_list|(
literal|"(bad); "
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|printf
argument_list|(
literal|"53 bits; "
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|printf
argument_list|(
literal|"64 bits; "
argument_list|)
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|"round "
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|control
operator|>>
literal|10
operator|)
operator|&
literal|3
condition|)
block|{
case|case
literal|0
case|:
name|printf
argument_list|(
literal|"NEAREST; "
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|printf
argument_list|(
literal|"DOWN; "
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|printf
argument_list|(
literal|"UP; "
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|printf
argument_list|(
literal|"CHOP; "
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|control
operator|&
literal|0x3f
condition|)
block|{
name|printf
argument_list|(
literal|"mask:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|&
literal|0x0001
condition|)
name|printf
argument_list|(
literal|" INVALID"
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|&
literal|0x0002
condition|)
name|printf
argument_list|(
literal|" DENORM"
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|&
literal|0x0004
condition|)
name|printf
argument_list|(
literal|" DIVZ"
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|&
literal|0x0008
condition|)
name|printf
argument_list|(
literal|" OVERF"
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|&
literal|0x0010
condition|)
name|printf
argument_list|(
literal|" UNDERF"
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|&
literal|0x0020
condition|)
name|printf
argument_list|(
literal|" LOS"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|";"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|&
literal|0xe080
condition|)
name|printf
argument_list|(
literal|"warning: reserved bits on 0x%x\n"
argument_list|,
name|control
operator|&
literal|0xe080
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|print_387_status_word
parameter_list|(
name|status
parameter_list|)
name|unsigned
name|int
name|status
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"status 0x%04x: "
argument_list|,
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
literal|0xff
condition|)
block|{
name|printf
argument_list|(
literal|"exceptions:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
literal|0x0001
condition|)
name|printf
argument_list|(
literal|" INVALID"
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
literal|0x0002
condition|)
name|printf
argument_list|(
literal|" DENORM"
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
literal|0x0004
condition|)
name|printf
argument_list|(
literal|" DIVZ"
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
literal|0x0008
condition|)
name|printf
argument_list|(
literal|" OVERF"
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
literal|0x0010
condition|)
name|printf
argument_list|(
literal|" UNDERF"
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
literal|0x0020
condition|)
name|printf
argument_list|(
literal|" LOS"
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
literal|0x0040
condition|)
name|printf
argument_list|(
literal|" FPSTACK"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"; "
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"flags: %d%d%d%d; "
argument_list|,
operator|(
name|status
operator|&
literal|0x4000
operator|)
operator|!=
literal|0
argument_list|,
operator|(
name|status
operator|&
literal|0x0400
operator|)
operator|!=
literal|0
argument_list|,
operator|(
name|status
operator|&
literal|0x0200
operator|)
operator|!=
literal|0
argument_list|,
operator|(
name|status
operator|&
literal|0x0100
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"top %d\n"
argument_list|,
operator|(
name|status
operator|>>
literal|11
operator|)
operator|&
literal|7
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
specifier|static
name|print_387_status
argument_list|(
argument|status
argument_list|,
argument|ep
argument_list|)
name|unsigned
name|short
name|status
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|env387
modifier|*
name|ep
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|int
name|bothstatus
decl_stmt|;
name|int
name|top
decl_stmt|;
name|int
name|fpreg
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|bothstatus
operator|=
operator|(
operator|(
name|status
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|ep
operator|->
name|status
operator|!=
literal|0
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|bothstatus
condition|)
name|printf
argument_list|(
literal|"u: "
argument_list|)
expr_stmt|;
name|print_387_status_word
argument_list|(
operator|(
name|unsigned
name|int
operator|)
name|status
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ep
operator|->
name|status
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|bothstatus
condition|)
name|printf
argument_list|(
literal|"e: "
argument_list|)
expr_stmt|;
name|print_387_status_word
argument_list|(
operator|(
name|unsigned
name|int
operator|)
name|ep
operator|->
name|status
argument_list|)
expr_stmt|;
block|}
name|print_387_control_word
argument_list|(
operator|(
name|unsigned
name|int
operator|)
name|ep
operator|->
name|control
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"last exception: "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"opcode 0x%x; "
argument_list|,
name|ep
operator|->
name|opcode
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"pc 0x%x:0x%x; "
argument_list|,
name|ep
operator|->
name|code_seg
argument_list|,
name|ep
operator|->
name|eip
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"operand 0x%x:0x%x\n"
argument_list|,
name|ep
operator|->
name|operand_seg
argument_list|,
name|ep
operator|->
name|operand
argument_list|)
expr_stmt|;
name|top
operator|=
operator|(
name|ep
operator|->
name|status
operator|>>
literal|11
operator|)
operator|&
literal|7
expr_stmt|;
name|printf
argument_list|(
literal|" regno     tag  msb              lsb  value\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|fpreg
operator|=
literal|7
init|;
name|fpreg
operator|>=
literal|0
condition|;
name|fpreg
operator|--
control|)
block|{
name|int
name|st_regno
decl_stmt|;
name|double
name|val
decl_stmt|;
comment|/* The physical regno `fpreg' is only relevant as an index into the        * tag word.  Logical `%st' numbers are required for indexing `p->regs.        */
name|st_regno
operator|=
operator|(
name|fpreg
operator|+
literal|8
operator|-
name|top
operator|)
operator|&
literal|0x7
expr_stmt|;
name|printf
argument_list|(
literal|"%%st(%d) %s "
argument_list|,
name|st_regno
argument_list|,
name|fpreg
operator|==
name|top
condition|?
literal|"=>"
else|:
literal|"  "
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|ep
operator|->
name|tag
operator|>>
operator|(
name|fpreg
operator|*
literal|2
operator|)
operator|)
operator|&
literal|3
condition|)
block|{
case|case
literal|0
case|:
name|printf
argument_list|(
literal|"valid "
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|printf
argument_list|(
literal|"zero  "
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|printf
argument_list|(
literal|"trap  "
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|printf
argument_list|(
literal|"empty "
argument_list|)
expr_stmt|;
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|9
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|printf
argument_list|(
literal|"%02x"
argument_list|,
name|ep
operator|->
name|regs
index|[
name|st_regno
index|]
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|i387_to_double
argument_list|(
name|ep
operator|->
name|regs
index|[
name|st_regno
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|val
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  %g\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|i386_float_info
argument_list|()
end_macro

begin_block
block|{
name|struct
name|user
name|u
decl_stmt|;
comment|/* just for address computations */
name|int
name|i
decl_stmt|;
comment|/* fpstate defined in<sys/user.h> */
name|struct
name|fpstate
modifier|*
name|fpstatep
decl_stmt|;
name|char
name|buf
index|[
sizeof|sizeof
argument_list|(
expr|struct
name|fpstate
argument_list|)
operator|+
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
index|]
decl_stmt|;
name|unsigned
name|int
name|uaddr
decl_stmt|;
name|char
name|fpvalid
decl_stmt|;
name|unsigned
name|int
name|rounded_addr
decl_stmt|;
name|unsigned
name|int
name|rounded_size
decl_stmt|;
comment|/*extern int corechan;*/
name|int
name|skip
decl_stmt|;
specifier|extern
name|int
name|inferior_pid
decl_stmt|;
name|uaddr
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|U_FPSTATE
argument_list|(
name|u
argument_list|)
operator|-
operator|(
name|char
operator|*
operator|)
operator|&
name|u
expr_stmt|;
if|if
condition|(
name|inferior_pid
condition|)
block|{
name|int
modifier|*
name|ip
decl_stmt|;
name|rounded_addr
operator|=
name|uaddr
operator|&
operator|-
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|rounded_size
operator|=
operator|(
operator|(
operator|(
name|uaddr
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|fpstate
argument_list|)
operator|)
operator|-
name|uaddr
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|skip
operator|=
name|uaddr
operator|-
name|rounded_addr
expr_stmt|;
name|ip
operator|=
operator|(
name|int
operator|*
operator|)
name|buf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rounded_size
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|ip
operator|++
operator|=
name|ptrace
argument_list|(
name|PT_READ_U
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|caddr_t
operator|)
name|rounded_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rounded_addr
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|printf
argument_list|(
literal|"float info: can't do a core file (yet)\n"
argument_list|)
expr_stmt|;
return|return;
if|#
directive|if
literal|0
block|if (lseek (corechan, uaddr, 0)< 0) 	perror_with_name ("seek on core file");       if (myread (corechan, buf, sizeof (struct fpstate))< 0)  	perror_with_name ("read from core file");       skip = 0;
endif|#
directive|endif
block|}
name|print_387_status
argument_list|(
literal|0
argument_list|,
operator|(
expr|struct
name|env387
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

