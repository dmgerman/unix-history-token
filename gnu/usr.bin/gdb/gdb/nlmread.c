begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Read NLM (NetWare Loadable Module) format executable files for GDB.    Copyright 1993, 1994 Free Software Foundation, Inc.    Written by Fred Fish at Cygnus Support (fnf@cygnus.com).  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"gdb-stabs.h"
end_include

begin_include
include|#
directive|include
file|"buildsym.h"
end_include

begin_include
include|#
directive|include
file|"stabsread.h"
end_include

begin_decl_stmt
specifier|static
name|void
name|nlm_new_init
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|nlm_symfile_init
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|nlm_symfile_read
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|,
expr|struct
name|section_offsets
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|nlm_symfile_finish
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|nlm_symtab_read
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|CORE_ADDR
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|section_offsets
modifier|*
name|nlm_symfile_offsets
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|,
name|CORE_ADDR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|record_minimal_symbol
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|CORE_ADDR
operator|,
expr|enum
name|minimal_symbol_type
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize anything that needs initializing when a completely new symbol    file is specified (not just adding some symbols from another file, e.g. a    shared library).     We reinitialize buildsym, since gdb will be able to read stabs from an NLM    file at some point in the near future.  */
end_comment

begin_function
specifier|static
name|void
name|nlm_new_init
parameter_list|(
name|ignore
parameter_list|)
name|struct
name|objfile
modifier|*
name|ignore
decl_stmt|;
block|{
name|stabsread_new_init
argument_list|()
expr_stmt|;
name|buildsym_new_init
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* NLM specific initialization routine for reading symbols.     It is passed a pointer to a struct sym_fns which contains, among other    things, the BFD for the file whose symbols are being read, and a slot for    a pointer to "private data" which we can fill with goodies.     For now at least, we have nothing in particular to do, so this function is    just a stub. */
end_comment

begin_function
specifier|static
name|void
name|nlm_symfile_init
parameter_list|(
name|ignore
parameter_list|)
name|struct
name|objfile
modifier|*
name|ignore
decl_stmt|;
block|{ }
end_function

begin_function
specifier|static
name|void
name|record_minimal_symbol
parameter_list|(
name|name
parameter_list|,
name|address
parameter_list|,
name|ms_type
parameter_list|,
name|objfile
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|CORE_ADDR
name|address
decl_stmt|;
name|enum
name|minimal_symbol_type
name|ms_type
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|name
operator|=
name|obsavestring
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|)
expr_stmt|;
name|prim_record_minimal_symbol
argument_list|(
name|name
argument_list|,
name|address
argument_list|,
name|ms_type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	nlm_symtab_read -- read the symbol table of an NLM file  SYNOPSIS  	void nlm_symtab_read (bfd *abfd, CORE_ADDR addr, 			      struct objfile *objfile)  DESCRIPTION  	Given an open bfd, a base address to relocate symbols to, and a 	flag that specifies whether or not this bfd is for an executable 	or not (may be shared library for example), add all the global 	function and data symbols to the minimal symbol table. */
end_comment

begin_function
specifier|static
name|void
name|nlm_symtab_read
parameter_list|(
name|abfd
parameter_list|,
name|addr
parameter_list|,
name|objfile
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|long
name|storage_needed
decl_stmt|;
name|asymbol
modifier|*
name|sym
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbol_table
decl_stmt|;
name|long
name|number_of_symbols
decl_stmt|;
name|long
name|i
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|back_to
decl_stmt|;
name|CORE_ADDR
name|symaddr
decl_stmt|;
name|enum
name|minimal_symbol_type
name|ms_type
decl_stmt|;
name|storage_needed
operator|=
name|bfd_get_symtab_upper_bound
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|storage_needed
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"Can't read symbols from %s: %s"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|storage_needed
operator|>
literal|0
condition|)
block|{
name|symbol_table
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|storage_needed
argument_list|)
expr_stmt|;
name|back_to
operator|=
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|symbol_table
argument_list|)
expr_stmt|;
name|number_of_symbols
operator|=
name|bfd_canonicalize_symtab
argument_list|(
name|abfd
argument_list|,
name|symbol_table
argument_list|)
expr_stmt|;
if|if
condition|(
name|number_of_symbols
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"Can't read symbols from %s: %s"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|number_of_symbols
condition|;
name|i
operator|++
control|)
block|{
name|sym
operator|=
name|symbol_table
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
comment|/*sym -> flags& BSF_GLOBAL*/
literal|1
condition|)
block|{
comment|/* Bfd symbols are section relative. */
name|symaddr
operator|=
name|sym
operator|->
name|value
operator|+
name|sym
operator|->
name|section
operator|->
name|vma
expr_stmt|;
comment|/* Relocate all non-absolute symbols by base address.  */
if|if
condition|(
name|sym
operator|->
name|section
operator|!=
operator|&
name|bfd_abs_section
condition|)
name|symaddr
operator|+=
name|addr
expr_stmt|;
comment|/* For non-absolute symbols, use the type of the section 		 they are relative to, to intuit text/data.  BFD provides 		 no way of figuring this out for absolute symbols. */
if|if
condition|(
name|sym
operator|->
name|section
operator|->
name|flags
operator|&
name|SEC_CODE
condition|)
name|ms_type
operator|=
name|mst_text
expr_stmt|;
elseif|else
if|if
condition|(
name|sym
operator|->
name|section
operator|->
name|flags
operator|&
name|SEC_DATA
condition|)
name|ms_type
operator|=
name|mst_data
expr_stmt|;
else|else
name|ms_type
operator|=
name|mst_unknown
expr_stmt|;
name|record_minimal_symbol
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sym
operator|->
name|name
argument_list|,
name|symaddr
argument_list|,
name|ms_type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
block|}
name|do_cleanups
argument_list|(
name|back_to
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Scan and build partial symbols for a symbol file.    We have been initialized by a call to nlm_symfile_init, which    currently does nothing.     SECTION_OFFSETS is a set of offsets to apply to relocate the symbols    in each section.  We simplify it down to a single offset for all    symbols.  FIXME.     MAINLINE is true if we are reading the main symbol    table (as opposed to a shared lib or dynamically loaded file).     This function only does the minimum work necessary for letting the    user "name" things symbolically; it does not read the entire symtab.    Instead, it reads the external and static symbols and puts them in partial    symbol tables.  When more extensive information is requested of a    file, the corresponding partial symbol table is mutated into a full    fledged symbol table by going back and reading the symbols    for real.     Note that NLM files have two sets of information that is potentially    useful for building gdb's minimal symbol table.  The first is a list    of the publically exported symbols, and is currently used to build    bfd's canonical symbol table.  The second is an optional native debugging    format which contains additional symbols (and possibly duplicates of    the publically exported symbols).  The optional native debugging format    is not currently used. */
end_comment

begin_function
specifier|static
name|void
name|nlm_symfile_read
parameter_list|(
name|objfile
parameter_list|,
name|section_offsets
parameter_list|,
name|mainline
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|section_offsets
modifier|*
name|section_offsets
decl_stmt|;
name|int
name|mainline
decl_stmt|;
block|{
name|bfd
modifier|*
name|abfd
init|=
name|objfile
operator|->
name|obfd
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|back_to
decl_stmt|;
name|CORE_ADDR
name|offset
decl_stmt|;
name|struct
name|symbol
modifier|*
name|mainsym
decl_stmt|;
name|init_minimal_symbol_collection
argument_list|()
expr_stmt|;
name|back_to
operator|=
name|make_cleanup
argument_list|(
name|discard_minimal_symbols
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* FIXME, should take a section_offsets param, not just an offset.  */
name|offset
operator|=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Process the NLM export records, which become the bfd's canonical symbol      table. */
name|nlm_symtab_read
argument_list|(
name|abfd
argument_list|,
name|offset
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|stabsect_build_psymtabs
argument_list|(
name|objfile
argument_list|,
name|section_offsets
argument_list|,
name|mainline
argument_list|,
literal|".stab"
argument_list|,
literal|".stabstr"
argument_list|,
literal|".text"
argument_list|)
expr_stmt|;
name|mainsym
operator|=
name|lookup_symbol
argument_list|(
literal|"main"
argument_list|,
name|NULL
argument_list|,
name|VAR_NAMESPACE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mainsym
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|mainsym
argument_list|)
operator|==
name|LOC_BLOCK
condition|)
block|{
name|objfile
operator|->
name|ei
operator|.
name|main_func_lowpc
operator|=
name|BLOCK_START
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|mainsym
argument_list|)
argument_list|)
expr_stmt|;
name|objfile
operator|->
name|ei
operator|.
name|main_func_highpc
operator|=
name|BLOCK_END
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|mainsym
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* FIXME:  We could locate and read the optional native debugging format      here and add the symbols to the minimal symbol table. */
comment|/* Install any minimal symbols that have been collected as the current      minimal symbols for this objfile. */
name|install_minimal_symbols
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|back_to
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Perform any local cleanups required when we are done with a particular    objfile.  I.E, we are in the process of discarding all symbol information    for an objfile, freeing up all memory held for it, and unlinking the    objfile struct from the global list of known objfiles. */
end_comment

begin_function
specifier|static
name|void
name|nlm_symfile_finish
parameter_list|(
name|objfile
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
if|if
condition|(
name|objfile
operator|->
name|sym_private
operator|!=
name|NULL
condition|)
block|{
name|mfree
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
name|objfile
operator|->
name|sym_private
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* NLM specific parsing routine for section offsets.    FIXME:  This may or may not be necessary.  All the symbol readers seem    to have similar code.  See if it can be generalized and moved elsewhere. */
end_comment

begin_function
specifier|static
name|struct
name|section_offsets
modifier|*
name|nlm_symfile_offsets
parameter_list|(
name|objfile
parameter_list|,
name|addr
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
block|{
name|struct
name|section_offsets
modifier|*
name|section_offsets
decl_stmt|;
name|int
name|i
decl_stmt|;
name|objfile
operator|->
name|num_sections
operator|=
name|SECT_OFF_MAX
expr_stmt|;
name|section_offsets
operator|=
operator|(
expr|struct
name|section_offsets
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|section_offsets
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|section_offsets
operator|->
name|offsets
argument_list|)
operator|*
operator|(
name|SECT_OFF_MAX
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SECT_OFF_MAX
condition|;
name|i
operator|++
control|)
block|{
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|i
argument_list|)
operator|=
name|addr
expr_stmt|;
block|}
return|return
operator|(
name|section_offsets
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Register that we are able to handle NLM file format. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sym_fns
name|nlm_sym_fns
init|=
block|{
name|bfd_target_nlm_flavour
block|,
name|nlm_new_init
block|,
comment|/* sym_new_init: init anything gbl to entire symtab */
name|nlm_symfile_init
block|,
comment|/* sym_init: read initial info, setup for sym_read() */
name|nlm_symfile_read
block|,
comment|/* sym_read: read a symbol file into symtab */
name|nlm_symfile_finish
block|,
comment|/* sym_finish: finished with file, cleanup */
name|nlm_symfile_offsets
block|,
comment|/* sym_offsets:  Translate ext. to int. relocation */
name|NULL
comment|/* next: pointer to next struct sym_fns */
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|_initialize_nlmread
parameter_list|()
block|{
name|add_symtab_fns
argument_list|(
operator|&
name|nlm_sym_fns
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

