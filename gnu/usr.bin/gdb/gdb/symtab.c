begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Symbol table lookup for the GNU debugger, GDB.    Copyright 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994              Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"call-cmds.h"
end_include

begin_include
include|#
directive|include
file|"regex.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|<obstack.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_comment
comment|/* Prototypes for local functions */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|find_methods
name|PARAMS
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|,
name|char
operator|*
operator|,
expr|struct
name|symbol
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|completion_list_add_name
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|build_canonical_line_spec
name|PARAMS
argument_list|(
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|symtabs_and_lines
name|decode_line_2
name|PARAMS
argument_list|(
operator|(
expr|struct
name|symbol
operator|*
index|[]
operator|,
name|int
operator|,
name|int
operator|,
name|char
operator|*
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|rbreak_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|types_info
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|functions_info
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|variables_info
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sources_info
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|list_symbols
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_source_filename
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|operator_chars
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|find_line_common
name|PARAMS
argument_list|(
operator|(
expr|struct
name|linetable
operator|*
operator|,
name|int
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|partial_symbol
modifier|*
name|lookup_partial_symbol
name|PARAMS
argument_list|(
operator|(
expr|struct
name|partial_symtab
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|,
expr|enum
name|namespace
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|symtab
modifier|*
name|lookup_symtab_1
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* */
end_comment

begin_comment
comment|/* The single non-language-specific builtin type */
end_comment

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_error
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Block in which the most recently searched-for symbol was found.    Might be better to make this a parameter to lookup_symbol and     value_of_this. */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|block
modifier|*
name|block_found
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|no_symtab_msg
index|[]
init|=
literal|"No symbol table is loaded.  Use the \"file\" command."
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* While the C++ support is still in flux, issue a possibly helpful hint on    using the new command completion feature on single quoted demangled C++    symbols.  Remove when loose ends are cleaned up.   FIXME -fnf */
end_comment

begin_function
name|void
name|cplusplus_hint
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|printf_filtered
argument_list|(
literal|"Hint: try '%s<TAB> or '%s<ESC-?>\n"
argument_list|,
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"(Note leading single quote.)\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check for a symtab of a specific name; first in symtabs, then in    psymtabs.  *If* there is no '/' in the name, a match after a '/'    in the symtab filename will also work.  */
end_comment

begin_function
specifier|static
name|struct
name|symtab
modifier|*
name|lookup_symtab_1
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
specifier|register
name|struct
name|partial_symtab
modifier|*
name|ps
decl_stmt|;
specifier|register
name|char
modifier|*
name|slash
decl_stmt|;
specifier|register
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|got_symtab
label|:
comment|/* First, search for an exact match */
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
if|if
condition|(
name|STREQ
argument_list|(
name|name
argument_list|,
name|s
operator|->
name|filename
argument_list|)
condition|)
return|return
name|s
return|;
name|slash
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
comment|/* Now, search for a matching tail (only if name doesn't have any dirs) */
if|if
condition|(
operator|!
name|slash
condition|)
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
name|char
modifier|*
name|p
init|=
name|s
operator|->
name|filename
decl_stmt|;
name|char
modifier|*
name|tail
init|=
name|strrchr
argument_list|(
name|p
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
if|if
condition|(
name|tail
condition|)
name|p
operator|=
name|tail
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|STREQ
argument_list|(
name|p
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|s
return|;
block|}
comment|/* Same search rules as above apply here, but now we look thru the      psymtabs.  */
name|ps
operator|=
name|lookup_partial_symtab
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ps
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|ps
operator|->
name|readin
condition|)
name|error
argument_list|(
literal|"Internal: readin %s pst for `%s' found when no symtab found."
argument_list|,
name|ps
operator|->
name|filename
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|s
operator|=
name|PSYMTAB_TO_SYMTAB
argument_list|(
name|ps
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
condition|)
return|return
name|s
return|;
comment|/* At this point, we have located the psymtab for this file, but      the conversion to a symtab has failed.  This usually happens      when we are looking up an include file.  In this case,      PSYMTAB_TO_SYMTAB doesn't return a symtab, even though one has      been created.  So, we need to run through the symtabs again in      order to find the file.      XXX - This is a crock, and should be fixed inside of the the      symbol parsing routines. */
goto|goto
name|got_symtab
goto|;
block|}
end_function

begin_comment
comment|/* Lookup the symbol table of a source file named NAME.  Try a couple    of variations if the first lookup doesn't work.  */
end_comment

begin_function
name|struct
name|symtab
modifier|*
name|lookup_symtab
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
if|#
directive|if
literal|0
block|register char *copy;
endif|#
directive|endif
name|s
operator|=
name|lookup_symtab_1
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
condition|)
return|return
name|s
return|;
if|#
directive|if
literal|0
comment|/* This screws c-exp.y:yylex if there is both a type "tree" and a symtab      "tree.c".  */
comment|/* If name not found as specified, see if adding ".c" helps.  */
comment|/* Why is this?  Is it just a user convenience?  (If so, it's pretty      questionable in the presence of C++, FORTRAN, etc.).  It's not in      the GDB manual.  */
block|copy = (char *) alloca (strlen (name) + 3);   strcpy (copy, name);   strcat (copy, ".c");   s = lookup_symtab_1 (copy);   if (s) return s;
endif|#
directive|endif
comment|/* 0 */
comment|/* We didn't find anything; die.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Lookup the partial symbol table of a source file named NAME.    *If* there is no '/' in the name, a match after a '/'    in the psymtab filename will also work.  */
end_comment

begin_function
name|struct
name|partial_symtab
modifier|*
name|lookup_partial_symtab
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
specifier|register
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|ALL_PSYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|pst
argument_list|)
block|{
if|if
condition|(
name|STREQ
argument_list|(
name|name
argument_list|,
name|pst
operator|->
name|filename
argument_list|)
condition|)
block|{
return|return
operator|(
name|pst
operator|)
return|;
block|}
block|}
comment|/* Now, search for a matching tail (only if name doesn't have any dirs) */
if|if
condition|(
operator|!
name|strchr
argument_list|(
name|name
argument_list|,
literal|'/'
argument_list|)
condition|)
name|ALL_PSYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|pst
argument_list|)
block|{
name|char
modifier|*
name|p
init|=
name|pst
operator|->
name|filename
decl_stmt|;
name|char
modifier|*
name|tail
init|=
name|strrchr
argument_list|(
name|p
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
if|if
condition|(
name|tail
condition|)
name|p
operator|=
name|tail
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|STREQ
argument_list|(
name|p
argument_list|,
name|name
argument_list|)
condition|)
return|return
operator|(
name|pst
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Demangle a GDB method stub type.    Note that this function is g++ specific. */
end_comment

begin_function
name|char
modifier|*
name|gdb_mangle_name
parameter_list|(
name|type
parameter_list|,
name|i
parameter_list|,
name|j
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
block|{
name|int
name|mangled_name_len
decl_stmt|;
name|char
modifier|*
name|mangled_name
decl_stmt|;
name|struct
name|fn_field
modifier|*
name|f
init|=
name|TYPE_FN_FIELDLIST1
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|struct
name|fn_field
modifier|*
name|method
init|=
operator|&
name|f
index|[
name|j
index|]
decl_stmt|;
name|char
modifier|*
name|field_name
init|=
name|TYPE_FN_FIELDLIST_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|char
modifier|*
name|physname
init|=
name|TYPE_FN_FIELD_PHYSNAME
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
decl_stmt|;
name|char
modifier|*
name|newname
init|=
name|type_name_no_tag
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/* Does the form of physname indicate that it is the full mangled name      of a constructor (not just the args)?  */
name|int
name|is_full_physname_constructor
decl_stmt|;
name|int
name|is_constructor
decl_stmt|;
name|int
name|is_destructor
init|=
name|DESTRUCTOR_PREFIX_P
argument_list|(
name|physname
argument_list|)
decl_stmt|;
comment|/* Need a new type prefix.  */
name|char
modifier|*
name|const_prefix
init|=
name|method
operator|->
name|is_const
condition|?
literal|"C"
else|:
literal|""
decl_stmt|;
name|char
modifier|*
name|volatile_prefix
init|=
name|method
operator|->
name|is_volatile
condition|?
literal|"V"
else|:
literal|""
decl_stmt|;
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
name|int
name|len
init|=
operator|(
name|newname
operator|==
name|NULL
condition|?
literal|0
else|:
name|strlen
argument_list|(
name|newname
argument_list|)
operator|)
decl_stmt|;
name|is_full_physname_constructor
operator|=
operator|(
operator|(
name|physname
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|physname
index|[
literal|1
index|]
operator|==
literal|'_'
operator|&&
operator|(
name|isdigit
argument_list|(
name|physname
index|[
literal|2
index|]
argument_list|)
operator|||
name|physname
index|[
literal|2
index|]
operator|==
literal|'Q'
operator|||
name|physname
index|[
literal|2
index|]
operator|==
literal|'t'
operator|)
operator|)
operator|||
operator|(
name|strncmp
argument_list|(
name|physname
argument_list|,
literal|"__ct"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|)
operator|)
expr_stmt|;
name|is_constructor
operator|=
name|is_full_physname_constructor
operator|||
operator|(
name|newname
operator|&&
name|STREQ
argument_list|(
name|field_name
argument_list|,
name|newname
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_destructor
condition|)
name|is_destructor
operator|=
operator|(
name|strncmp
argument_list|(
name|physname
argument_list|,
literal|"__dt"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
ifndef|#
directive|ifndef
name|GCC_MANGLE_BUG
if|if
condition|(
name|is_destructor
operator|||
name|is_full_physname_constructor
condition|)
block|{
name|mangled_name
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|physname
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|mangled_name
argument_list|,
name|physname
argument_list|)
expr_stmt|;
return|return
name|mangled_name
return|;
block|}
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"__%s%s"
argument_list|,
name|const_prefix
argument_list|,
name|volatile_prefix
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|buf
argument_list|,
literal|"__"
argument_list|)
operator|==
literal|0
condition|)
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"__%s%s%d"
argument_list|,
name|const_prefix
argument_list|,
name|volatile_prefix
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
name|mangled_name_len
operator|=
operator|(
operator|(
name|is_constructor
condition|?
literal|0
else|:
name|strlen
argument_list|(
name|field_name
argument_list|)
operator|)
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
operator|+
name|len
operator|+
name|strlen
argument_list|(
name|physname
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* Only needed for GNU-mangled names.  ANSI-mangled names      work with the normal mechanisms.  */
if|if
condition|(
name|OPNAME_PREFIX_P
argument_list|(
name|field_name
argument_list|)
condition|)
block|{
name|char
modifier|*
name|opname
init|=
name|cplus_mangle_opname
argument_list|(
name|field_name
operator|+
literal|3
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|opname
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"No mangling for \"%s\""
argument_list|,
name|field_name
argument_list|)
expr_stmt|;
name|mangled_name_len
operator|+=
name|strlen
argument_list|(
name|opname
argument_list|)
expr_stmt|;
name|mangled_name
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|mangled_name_len
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|mangled_name
argument_list|,
name|field_name
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|mangled_name
index|[
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strcat
argument_list|(
name|mangled_name
argument_list|,
name|opname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mangled_name
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|mangled_name_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_constructor
condition|)
name|mangled_name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|mangled_name
argument_list|,
name|field_name
argument_list|)
expr_stmt|;
block|}
name|strcat
argument_list|(
name|mangled_name
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* If the class doesn't have a name, i.e. newname NULL, then we just      mangle it using 0 for the length of the class.  Thus it gets mangled      as something starting with `::' rather than `classname::'. */
if|if
condition|(
name|newname
operator|!=
name|NULL
condition|)
name|strcat
argument_list|(
name|mangled_name
argument_list|,
name|newname
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|is_constructor
condition|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"__%s%s"
argument_list|,
name|const_prefix
argument_list|,
name|volatile_prefix
argument_list|)
expr_stmt|;
block|}
name|mangled_name_len
operator|=
operator|(
operator|(
name|is_constructor
condition|?
literal|0
else|:
name|strlen
argument_list|(
name|field_name
argument_list|)
operator|)
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
operator|+
name|strlen
argument_list|(
name|physname
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* Only needed for GNU-mangled names.  ANSI-mangled names      work with the normal mechanisms.  */
if|if
condition|(
name|OPNAME_PREFIX_P
argument_list|(
name|field_name
argument_list|)
condition|)
block|{
name|char
modifier|*
name|opname
decl_stmt|;
name|opname
operator|=
name|cplus_mangle_opname
argument_list|(
name|field_name
operator|+
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|opname
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"No mangling for \"%s\""
argument_list|,
name|field_name
argument_list|)
expr_stmt|;
block|}
name|mangled_name_len
operator|+=
name|strlen
argument_list|(
name|opname
argument_list|)
expr_stmt|;
name|mangled_name
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|mangled_name_len
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|mangled_name
argument_list|,
name|field_name
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|mangled_name
operator|+
literal|3
argument_list|,
name|opname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mangled_name
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|mangled_name_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_constructor
condition|)
block|{
name|mangled_name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|strcpy
argument_list|(
name|mangled_name
argument_list|,
name|field_name
argument_list|)
expr_stmt|;
block|}
block|}
name|strcat
argument_list|(
name|mangled_name
argument_list|,
name|buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|strcat
argument_list|(
name|mangled_name
argument_list|,
name|physname
argument_list|)
expr_stmt|;
return|return
operator|(
name|mangled_name
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find which partial symtab on contains PC.  Return 0 if none.  */
end_comment

begin_function
name|struct
name|partial_symtab
modifier|*
name|find_pc_psymtab
parameter_list|(
name|pc
parameter_list|)
specifier|register
name|CORE_ADDR
name|pc
decl_stmt|;
block|{
specifier|register
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
specifier|register
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|ALL_PSYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|pst
argument_list|)
block|{
if|if
condition|(
name|pc
operator|>=
name|pst
operator|->
name|textlow
operator|&&
name|pc
operator|<
name|pst
operator|->
name|texthigh
condition|)
return|return
operator|(
name|pst
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Find which partial symbol within a psymtab contains PC.  Return 0    if none.  Check all psymtabs if PSYMTAB is 0.  */
end_comment

begin_function
name|struct
name|partial_symbol
modifier|*
name|find_pc_psymbol
parameter_list|(
name|psymtab
parameter_list|,
name|pc
parameter_list|)
name|struct
name|partial_symtab
modifier|*
name|psymtab
decl_stmt|;
name|CORE_ADDR
name|pc
decl_stmt|;
block|{
name|struct
name|partial_symbol
modifier|*
name|best
init|=
name|NULL
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|CORE_ADDR
name|best_pc
decl_stmt|;
if|if
condition|(
operator|!
name|psymtab
condition|)
name|psymtab
operator|=
name|find_pc_psymtab
argument_list|(
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|psymtab
condition|)
return|return
literal|0
return|;
name|best_pc
operator|=
name|psymtab
operator|->
name|textlow
operator|-
literal|1
expr_stmt|;
comment|/* Search the global symbols as well as the static symbols, so that      find_pc_partial_function doesn't use a minimal symbol and thus      cache a bad endaddr.  */
for|for
control|(
name|p
operator|=
name|psymtab
operator|->
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
operator|+
name|psymtab
operator|->
name|globals_offset
init|;
operator|(
name|p
operator|-
operator|(
name|psymtab
operator|->
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
operator|+
name|psymtab
operator|->
name|globals_offset
operator|)
operator|<
name|psymtab
operator|->
name|n_global_syms
operator|)
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|SYMBOL_NAMESPACE
argument_list|(
name|p
argument_list|)
operator|==
name|VAR_NAMESPACE
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|p
argument_list|)
operator|==
name|LOC_BLOCK
operator|&&
name|pc
operator|>=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|p
argument_list|)
operator|&&
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|p
argument_list|)
operator|>
name|best_pc
condition|)
block|{
name|best_pc
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|best
operator|=
name|p
expr_stmt|;
block|}
for|for
control|(
name|p
operator|=
name|psymtab
operator|->
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
operator|+
name|psymtab
operator|->
name|statics_offset
init|;
operator|(
name|p
operator|-
operator|(
name|psymtab
operator|->
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
operator|+
name|psymtab
operator|->
name|statics_offset
operator|)
operator|<
name|psymtab
operator|->
name|n_static_syms
operator|)
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|SYMBOL_NAMESPACE
argument_list|(
name|p
argument_list|)
operator|==
name|VAR_NAMESPACE
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|p
argument_list|)
operator|==
name|LOC_BLOCK
operator|&&
name|pc
operator|>=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|p
argument_list|)
operator|&&
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|p
argument_list|)
operator|>
name|best_pc
condition|)
block|{
name|best_pc
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|best
operator|=
name|p
expr_stmt|;
block|}
if|if
condition|(
name|best_pc
operator|==
name|psymtab
operator|->
name|textlow
operator|-
literal|1
condition|)
return|return
literal|0
return|;
return|return
name|best
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find the definition for a specified symbol name NAME    in namespace NAMESPACE, visible from lexical block BLOCK.    Returns the struct symbol pointer, or zero if no symbol is found.    If SYMTAB is non-NULL, store the symbol table in which the    symbol was found there, or NULL if not found.    C++: if IS_A_FIELD_OF_THIS is nonzero on entry, check to see if    NAME is a field of the current implied argument `this'.  If so set    *IS_A_FIELD_OF_THIS to 1, otherwise set it to zero.     BLOCK_FOUND is set to the block in which NAME is found (in the case of    a field of `this', value_of_this sets BLOCK_FOUND to the proper value.) */
end_comment

begin_comment
comment|/* This function has a bunch of loops in it and it would seem to be    attractive to put in some QUIT's (though I'm not really sure    whether it can run long enough to be really important).  But there    are a few calls for which it would appear to be bad news to quit    out of here: find_proc_desc in alpha-tdep.c and mips-tdep.c, and    nindy_frame_chain_valid in nindy-tdep.c.  (Note that there is C++    code below which can error(), but that probably doesn't affect    these calls since they are looking for a known variable and thus    can probably assume it will never hit the C++ code).  */
end_comment

begin_function
name|struct
name|symbol
modifier|*
name|lookup_symbol
parameter_list|(
name|name
parameter_list|,
name|block
parameter_list|,
name|namespace
parameter_list|,
name|is_a_field_of_this
parameter_list|,
name|symtab
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
specifier|const
name|struct
name|block
modifier|*
name|block
decl_stmt|;
specifier|const
name|enum
name|namespace
name|namespace
decl_stmt|;
name|int
modifier|*
name|is_a_field_of_this
decl_stmt|;
name|struct
name|symtab
modifier|*
modifier|*
name|symtab
decl_stmt|;
block|{
specifier|register
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
specifier|register
name|struct
name|symtab
modifier|*
name|s
init|=
name|NULL
decl_stmt|;
specifier|register
name|struct
name|partial_symtab
modifier|*
name|ps
decl_stmt|;
name|struct
name|blockvector
modifier|*
name|bv
decl_stmt|;
specifier|register
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
specifier|register
name|struct
name|block
modifier|*
name|b
decl_stmt|;
specifier|register
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
comment|/* Search specified block and its superiors.  */
while|while
condition|(
name|block
operator|!=
literal|0
condition|)
block|{
name|sym
operator|=
name|lookup_block_symbol
argument_list|(
name|block
argument_list|,
name|name
argument_list|,
name|namespace
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
condition|)
block|{
name|block_found
operator|=
name|block
expr_stmt|;
if|if
condition|(
name|symtab
operator|!=
name|NULL
condition|)
block|{
comment|/* Search the list of symtabs for one which contains the 		 address of the start of this block.  */
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|BLOCK_START
argument_list|(
name|b
argument_list|)
operator|<=
name|BLOCK_START
argument_list|(
name|block
argument_list|)
operator|&&
name|BLOCK_END
argument_list|(
name|b
argument_list|)
operator|>
name|BLOCK_START
argument_list|(
name|block
argument_list|)
condition|)
goto|goto
name|found
goto|;
block|}
name|found
label|:
operator|*
name|symtab
operator|=
name|s
expr_stmt|;
block|}
return|return
operator|(
name|sym
operator|)
return|;
block|}
name|block
operator|=
name|BLOCK_SUPERBLOCK
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
comment|/* FIXME: this code is never executed--block is always NULL at this      point.  What is it trying to do, anyway?  We already should have      checked the STATIC_BLOCK above (it is the superblock of top-level      blocks).  Why is VAR_NAMESPACE special-cased?  */
comment|/* Don't need to mess with the psymtabs; if we have a block,      that file is read in.  If we don't, then we deal later with      all the psymtab stuff that needs checking.  */
if|if
condition|(
name|namespace
operator|==
name|VAR_NAMESPACE
operator|&&
name|block
operator|!=
name|NULL
condition|)
block|{
name|struct
name|block
modifier|*
name|b
decl_stmt|;
comment|/* Find the right symtab.  */
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|STATIC_BLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|BLOCK_START
argument_list|(
name|b
argument_list|)
operator|<=
name|BLOCK_START
argument_list|(
name|block
argument_list|)
operator|&&
name|BLOCK_END
argument_list|(
name|b
argument_list|)
operator|>
name|BLOCK_START
argument_list|(
name|block
argument_list|)
condition|)
block|{
name|sym
operator|=
name|lookup_block_symbol
argument_list|(
name|b
argument_list|,
name|name
argument_list|,
name|VAR_NAMESPACE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
condition|)
block|{
name|block_found
operator|=
name|b
expr_stmt|;
if|if
condition|(
name|symtab
operator|!=
name|NULL
condition|)
operator|*
name|symtab
operator|=
name|s
expr_stmt|;
return|return
name|sym
return|;
block|}
block|}
block|}
block|}
comment|/* C++: If requested to do so by the caller,       check to see if NAME is a field of `this'. */
if|if
condition|(
name|is_a_field_of_this
condition|)
block|{
name|struct
name|value
modifier|*
name|v
init|=
name|value_of_this
argument_list|(
literal|0
argument_list|)
decl_stmt|;
operator|*
name|is_a_field_of_this
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|v
operator|&&
name|check_field
argument_list|(
name|v
argument_list|,
name|name
argument_list|)
condition|)
block|{
operator|*
name|is_a_field_of_this
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|symtab
operator|!=
name|NULL
condition|)
operator|*
name|symtab
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/* Now search all global blocks.  Do the symtab's first, then      check the psymtab's */
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|block
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
expr_stmt|;
name|sym
operator|=
name|lookup_block_symbol
argument_list|(
name|block
argument_list|,
name|name
argument_list|,
name|namespace
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
condition|)
block|{
name|block_found
operator|=
name|block
expr_stmt|;
if|if
condition|(
name|symtab
operator|!=
name|NULL
condition|)
operator|*
name|symtab
operator|=
name|s
expr_stmt|;
return|return
name|sym
return|;
block|}
block|}
comment|/* Check for the possibility of the symbol being a global function      that is stored in one of the minimal symbol tables.  Eventually, all      global symbols might be resolved in this way.  */
if|if
condition|(
name|namespace
operator|==
name|VAR_NAMESPACE
condition|)
block|{
name|msymbol
operator|=
name|lookup_minimal_symbol
argument_list|(
name|name
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|msymbol
operator|!=
name|NULL
condition|)
block|{
name|s
operator|=
name|find_pc_symtab
argument_list|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If S is NULL, there are no debug symbols for this file. 	     Skip this stuff and check for matching static symbols below. */
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|block
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
expr_stmt|;
name|sym
operator|=
name|lookup_block_symbol
argument_list|(
name|block
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|msymbol
argument_list|)
argument_list|,
name|namespace
argument_list|)
expr_stmt|;
comment|/* We kept static functions in minimal symbol table as well as 		 in static scope. We want to find them in the symbol table. */
if|if
condition|(
operator|!
name|sym
condition|)
block|{
name|block
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|STATIC_BLOCK
argument_list|)
expr_stmt|;
name|sym
operator|=
name|lookup_block_symbol
argument_list|(
name|block
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|msymbol
argument_list|)
argument_list|,
name|namespace
argument_list|)
expr_stmt|;
block|}
comment|/* sym == 0 if symbol was found in the minimal symbol table 		 but not in the symtab. 		 Return 0 to use the msymbol definition of "foo_".  		 This happens for Fortran  "foo_" symbols, 		 which are "foo" in the symtab.  		 This can also happen if "asm" is used to make a 		 regular symbol but not a debugging symbol, e.g. 		 asm(".globl _main"); 		 asm("_main:"); 		 */
if|if
condition|(
name|symtab
operator|!=
name|NULL
condition|)
operator|*
name|symtab
operator|=
name|s
expr_stmt|;
return|return
name|sym
return|;
block|}
block|}
block|}
name|ALL_PSYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|ps
argument_list|)
block|{
if|if
condition|(
operator|!
name|ps
operator|->
name|readin
operator|&&
name|lookup_partial_symbol
argument_list|(
name|ps
argument_list|,
name|name
argument_list|,
literal|1
argument_list|,
name|namespace
argument_list|)
condition|)
block|{
name|s
operator|=
name|PSYMTAB_TO_SYMTAB
argument_list|(
name|ps
argument_list|)
expr_stmt|;
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|block
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
expr_stmt|;
name|sym
operator|=
name|lookup_block_symbol
argument_list|(
name|block
argument_list|,
name|name
argument_list|,
name|namespace
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sym
condition|)
name|error
argument_list|(
literal|"Internal: global symbol `%s' found in %s psymtab but not in symtab"
argument_list|,
name|name
argument_list|,
name|ps
operator|->
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|symtab
operator|!=
name|NULL
condition|)
operator|*
name|symtab
operator|=
name|s
expr_stmt|;
return|return
name|sym
return|;
block|}
block|}
comment|/* Now search all per-file blocks.      Not strictly correct, but more useful than an error.      Do the symtabs first, then check the psymtabs */
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|block
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|STATIC_BLOCK
argument_list|)
expr_stmt|;
name|sym
operator|=
name|lookup_block_symbol
argument_list|(
name|block
argument_list|,
name|name
argument_list|,
name|namespace
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
condition|)
block|{
name|block_found
operator|=
name|block
expr_stmt|;
if|if
condition|(
name|symtab
operator|!=
name|NULL
condition|)
operator|*
name|symtab
operator|=
name|s
expr_stmt|;
return|return
name|sym
return|;
block|}
block|}
name|ALL_PSYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|ps
argument_list|)
block|{
if|if
condition|(
operator|!
name|ps
operator|->
name|readin
operator|&&
name|lookup_partial_symbol
argument_list|(
name|ps
argument_list|,
name|name
argument_list|,
literal|0
argument_list|,
name|namespace
argument_list|)
condition|)
block|{
name|s
operator|=
name|PSYMTAB_TO_SYMTAB
argument_list|(
name|ps
argument_list|)
expr_stmt|;
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|block
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|STATIC_BLOCK
argument_list|)
expr_stmt|;
name|sym
operator|=
name|lookup_block_symbol
argument_list|(
name|block
argument_list|,
name|name
argument_list|,
name|namespace
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sym
condition|)
name|error
argument_list|(
literal|"Internal: static symbol `%s' found in %s psymtab but not in symtab"
argument_list|,
name|name
argument_list|,
name|ps
operator|->
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|symtab
operator|!=
name|NULL
condition|)
operator|*
name|symtab
operator|=
name|s
expr_stmt|;
return|return
name|sym
return|;
block|}
block|}
comment|/* Now search all per-file blocks for static mangled symbols.      Do the symtabs first, then check the psymtabs.  */
if|if
condition|(
name|namespace
operator|==
name|VAR_NAMESPACE
condition|)
block|{
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|block
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|STATIC_BLOCK
argument_list|)
expr_stmt|;
name|sym
operator|=
name|lookup_block_symbol
argument_list|(
name|block
argument_list|,
name|name
argument_list|,
name|VAR_NAMESPACE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
condition|)
block|{
name|block_found
operator|=
name|block
expr_stmt|;
if|if
condition|(
name|symtab
operator|!=
name|NULL
condition|)
operator|*
name|symtab
operator|=
name|s
expr_stmt|;
return|return
name|sym
return|;
block|}
block|}
name|ALL_PSYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|ps
argument_list|)
block|{
if|if
condition|(
operator|!
name|ps
operator|->
name|readin
operator|&&
name|lookup_partial_symbol
argument_list|(
name|ps
argument_list|,
name|name
argument_list|,
literal|0
argument_list|,
name|VAR_NAMESPACE
argument_list|)
condition|)
block|{
name|s
operator|=
name|PSYMTAB_TO_SYMTAB
argument_list|(
name|ps
argument_list|)
expr_stmt|;
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|block
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|STATIC_BLOCK
argument_list|)
expr_stmt|;
name|sym
operator|=
name|lookup_block_symbol
argument_list|(
name|block
argument_list|,
name|name
argument_list|,
name|VAR_NAMESPACE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sym
condition|)
name|error
argument_list|(
literal|"Internal: mangled static symbol `%s' found in %s psymtab but not in symtab"
argument_list|,
name|name
argument_list|,
name|ps
operator|->
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|symtab
operator|!=
name|NULL
condition|)
operator|*
name|symtab
operator|=
name|s
expr_stmt|;
return|return
name|sym
return|;
block|}
block|}
block|}
if|if
condition|(
name|symtab
operator|!=
name|NULL
condition|)
operator|*
name|symtab
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Look, in partial_symtab PST, for symbol NAME.  Check the global    symbols if GLOBAL, the static symbols if not */
end_comment

begin_function
specifier|static
name|struct
name|partial_symbol
modifier|*
name|lookup_partial_symbol
parameter_list|(
name|pst
parameter_list|,
name|name
parameter_list|,
name|global
parameter_list|,
name|namespace
parameter_list|)
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|global
decl_stmt|;
name|enum
name|namespace
name|namespace
decl_stmt|;
block|{
name|struct
name|partial_symbol
modifier|*
name|start
decl_stmt|,
modifier|*
name|psym
decl_stmt|;
name|struct
name|partial_symbol
modifier|*
name|top
decl_stmt|,
modifier|*
name|bottom
decl_stmt|,
modifier|*
name|center
decl_stmt|;
name|int
name|length
init|=
operator|(
name|global
condition|?
name|pst
operator|->
name|n_global_syms
else|:
name|pst
operator|->
name|n_static_syms
operator|)
decl_stmt|;
name|int
name|do_linear_search
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|start
operator|=
operator|(
name|global
condition|?
name|pst
operator|->
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
operator|+
name|pst
operator|->
name|globals_offset
else|:
name|pst
operator|->
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
operator|+
name|pst
operator|->
name|statics_offset
operator|)
expr_stmt|;
if|if
condition|(
name|global
condition|)
comment|/* This means we can use a binary search. */
block|{
name|do_linear_search
operator|=
literal|0
expr_stmt|;
comment|/* Binary search.  This search is guaranteed to end with center          pointing at the earliest partial symbol with the correct 	 name.  At that point *all* partial symbols with that name 	 will be checked against the correct namespace. */
name|bottom
operator|=
name|start
expr_stmt|;
name|top
operator|=
name|start
operator|+
name|length
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|top
operator|>
name|bottom
condition|)
block|{
name|center
operator|=
name|bottom
operator|+
operator|(
name|top
operator|-
name|bottom
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|center
operator|<
name|top
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|do_linear_search
operator|&&
name|SYMBOL_LANGUAGE
argument_list|(
name|center
argument_list|)
operator|==
name|language_cplus
condition|)
block|{
name|do_linear_search
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|STRCMP
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|center
argument_list|)
argument_list|,
name|name
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|top
operator|=
name|center
expr_stmt|;
block|}
else|else
block|{
name|bottom
operator|=
name|center
operator|+
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|top
operator|==
name|bottom
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
while|while
condition|(
name|STREQ
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|top
argument_list|)
argument_list|,
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|SYMBOL_NAMESPACE
argument_list|(
name|top
argument_list|)
operator|==
name|namespace
condition|)
block|{
return|return
name|top
return|;
block|}
name|top
operator|++
expr_stmt|;
block|}
block|}
comment|/* Can't use a binary search or else we found during the binary search that      we should also do a linear search. */
if|if
condition|(
name|do_linear_search
condition|)
block|{
for|for
control|(
name|psym
operator|=
name|start
init|;
name|psym
operator|<
name|start
operator|+
name|length
condition|;
name|psym
operator|++
control|)
block|{
if|if
condition|(
name|namespace
operator|==
name|SYMBOL_NAMESPACE
argument_list|(
name|psym
argument_list|)
condition|)
block|{
if|if
condition|(
name|SYMBOL_MATCHES_NAME
argument_list|(
name|psym
argument_list|,
name|name
argument_list|)
condition|)
block|{
return|return
operator|(
name|psym
operator|)
return|;
block|}
block|}
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Find the psymtab containing main(). */
end_comment

begin_comment
comment|/* FIXME:  What about languages without main() or specially linked    executables that have no main() ? */
end_comment

begin_function
name|struct
name|partial_symtab
modifier|*
name|find_main_psymtab
parameter_list|()
block|{
specifier|register
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
specifier|register
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|ALL_PSYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|pst
argument_list|)
block|{
if|if
condition|(
name|lookup_partial_symbol
argument_list|(
name|pst
argument_list|,
literal|"main"
argument_list|,
literal|1
argument_list|,
name|VAR_NAMESPACE
argument_list|)
condition|)
block|{
return|return
operator|(
name|pst
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Search BLOCK for symbol NAME in NAMESPACE.     Note that if NAME is the demangled form of a C++ symbol, we will fail    to find a match during the binary search of the non-encoded names, but    for now we don't worry about the slight inefficiency of looking for    a match we'll never find, since it will go pretty quick.  Once the    binary search terminates, we drop through and do a straight linear    search on the symbols.  Each symbol which is marked as being a C++    symbol (language_cplus set) has both the encoded and non-encoded names    tested for a match. */
end_comment

begin_function
name|struct
name|symbol
modifier|*
name|lookup_block_symbol
parameter_list|(
name|block
parameter_list|,
name|name
parameter_list|,
name|namespace
parameter_list|)
specifier|register
specifier|const
name|struct
name|block
modifier|*
name|block
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|enum
name|namespace
name|namespace
decl_stmt|;
block|{
specifier|register
name|int
name|bot
decl_stmt|,
name|top
decl_stmt|,
name|inc
decl_stmt|;
specifier|register
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
specifier|register
name|struct
name|symbol
modifier|*
name|sym_found
init|=
name|NULL
decl_stmt|;
specifier|register
name|int
name|do_linear_search
init|=
literal|1
decl_stmt|;
comment|/* If the blocks's symbols were sorted, start with a binary search.  */
if|if
condition|(
name|BLOCK_SHOULD_SORT
argument_list|(
name|block
argument_list|)
condition|)
block|{
comment|/* Reset the linear search flag so if the binary search fails, we 	 won't do the linear search once unless we find some reason to 	 do so, such as finding a C++ symbol during the binary search. 	 Note that for C++ modules, ALL the symbols in a block should 	 end up marked as C++ symbols. */
name|do_linear_search
operator|=
literal|0
expr_stmt|;
name|top
operator|=
name|BLOCK_NSYMS
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|bot
operator|=
literal|0
expr_stmt|;
comment|/* Advance BOT to not far before the first symbol whose name is NAME. */
while|while
condition|(
literal|1
condition|)
block|{
name|inc
operator|=
operator|(
name|top
operator|-
name|bot
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* No need to keep binary searching for the last few bits worth.  */
if|if
condition|(
name|inc
operator|<
literal|4
condition|)
block|{
break|break;
block|}
name|inc
operator|=
operator|(
name|inc
operator|>>
literal|1
operator|)
operator|+
name|bot
expr_stmt|;
name|sym
operator|=
name|BLOCK_SYM
argument_list|(
name|block
argument_list|,
name|inc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|do_linear_search
operator|&&
name|SYMBOL_LANGUAGE
argument_list|(
name|sym
argument_list|)
operator|==
name|language_cplus
condition|)
block|{
name|do_linear_search
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
index|[
literal|0
index|]
operator|<
name|name
index|[
literal|0
index|]
condition|)
block|{
name|bot
operator|=
name|inc
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
index|[
literal|0
index|]
operator|>
name|name
index|[
literal|0
index|]
condition|)
block|{
name|top
operator|=
name|inc
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STRCMP
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|name
argument_list|)
operator|<
literal|0
condition|)
block|{
name|bot
operator|=
name|inc
expr_stmt|;
block|}
else|else
block|{
name|top
operator|=
name|inc
expr_stmt|;
block|}
block|}
comment|/* Now scan forward until we run out of symbols, find one whose 	 name is greater than NAME, or find one we want.  If there is 	 more than one symbol with the right name and namespace, we 	 return the first one; I believe it is now impossible for us 	 to encounter two symbols with the same name and namespace 	 here, because blocks containing argument symbols are no 	 longer sorted.  */
name|top
operator|=
name|BLOCK_NSYMS
argument_list|(
name|block
argument_list|)
expr_stmt|;
while|while
condition|(
name|bot
operator|<
name|top
condition|)
block|{
name|sym
operator|=
name|BLOCK_SYM
argument_list|(
name|block
argument_list|,
name|bot
argument_list|)
expr_stmt|;
name|inc
operator|=
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
index|[
literal|0
index|]
operator|-
name|name
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|inc
operator|==
literal|0
condition|)
block|{
name|inc
operator|=
name|STRCMP
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inc
operator|==
literal|0
operator|&&
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|==
name|namespace
condition|)
block|{
return|return
operator|(
name|sym
operator|)
return|;
block|}
if|if
condition|(
name|inc
operator|>
literal|0
condition|)
block|{
break|break;
block|}
name|bot
operator|++
expr_stmt|;
block|}
block|}
comment|/* Here if block isn't sorted, or we fail to find a match during the      binary search above.  If during the binary search above, we find a      symbol which is a C++ symbol, then we have re-enabled the linear      search flag which was reset when starting the binary search.       This loop is equivalent to the loop above, but hacked greatly for speed.       Note that parameter symbols do not always show up last in the      list; this loop makes sure to take anything else other than      parameter symbols first; it only uses parameter symbols as a      last resort.  Note that this only takes up extra computation      time on a match.  */
if|if
condition|(
name|do_linear_search
condition|)
block|{
name|top
operator|=
name|BLOCK_NSYMS
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|bot
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|bot
operator|<
name|top
condition|)
block|{
name|sym
operator|=
name|BLOCK_SYM
argument_list|(
name|block
argument_list|,
name|bot
argument_list|)
expr_stmt|;
if|if
condition|(
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|==
name|namespace
operator|&&
name|SYMBOL_MATCHES_NAME
argument_list|(
name|sym
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|sym_found
operator|=
name|sym
expr_stmt|;
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|!=
name|LOC_ARG
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|!=
name|LOC_LOCAL_ARG
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|!=
name|LOC_REF_ARG
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|!=
name|LOC_REGPARM
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|!=
name|LOC_REGPARM_ADDR
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|!=
name|LOC_BASEREG_ARG
condition|)
block|{
break|break;
block|}
block|}
name|bot
operator|++
expr_stmt|;
block|}
block|}
return|return
operator|(
name|sym_found
operator|)
return|;
comment|/* Will be NULL if not found. */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the symbol for the function which contains a specified    lexical block, described by a struct block BL.  */
end_comment

begin_function
name|struct
name|symbol
modifier|*
name|block_function
parameter_list|(
name|bl
parameter_list|)
name|struct
name|block
modifier|*
name|bl
decl_stmt|;
block|{
while|while
condition|(
name|BLOCK_FUNCTION
argument_list|(
name|bl
argument_list|)
operator|==
literal|0
operator|&&
name|BLOCK_SUPERBLOCK
argument_list|(
name|bl
argument_list|)
operator|!=
literal|0
condition|)
name|bl
operator|=
name|BLOCK_SUPERBLOCK
argument_list|(
name|bl
argument_list|)
expr_stmt|;
return|return
name|BLOCK_FUNCTION
argument_list|(
name|bl
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Find the symtab associated with PC.  Look through the psymtabs and read in    another symtab if necessary. */
end_comment

begin_function
name|struct
name|symtab
modifier|*
name|find_pc_symtab
parameter_list|(
name|pc
parameter_list|)
specifier|register
name|CORE_ADDR
name|pc
decl_stmt|;
block|{
specifier|register
name|struct
name|block
modifier|*
name|b
decl_stmt|;
name|struct
name|blockvector
modifier|*
name|bv
decl_stmt|;
specifier|register
name|struct
name|symtab
modifier|*
name|s
init|=
name|NULL
decl_stmt|;
specifier|register
name|struct
name|symtab
modifier|*
name|best_s
init|=
name|NULL
decl_stmt|;
specifier|register
name|struct
name|partial_symtab
modifier|*
name|ps
decl_stmt|;
specifier|register
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|int
name|distance
init|=
literal|0
decl_stmt|;
comment|/* Search all symtabs for the one whose file contains our address, and which      is the smallest of all the ones containing the address.  This is designed      to deal with a case like symtab a is at 0x1000-0x2000 and 0x3000-0x4000      and symtab b is at 0x2000-0x3000.  So the GLOBAL_BLOCK for a is from      0x1000-0x4000, but for address 0x2345 we want to return symtab b.      This is said to happen for the mips; it might be swifter to create      several symtabs with the same name like xcoff does (I'm not sure).  */
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|BLOCK_START
argument_list|(
name|b
argument_list|)
operator|<=
name|pc
operator|&&
name|BLOCK_END
argument_list|(
name|b
argument_list|)
operator|>
name|pc
operator|&&
operator|(
name|distance
operator|==
literal|0
operator|||
name|BLOCK_END
argument_list|(
name|b
argument_list|)
operator|-
name|BLOCK_START
argument_list|(
name|b
argument_list|)
operator|<
name|distance
operator|)
condition|)
block|{
name|distance
operator|=
name|BLOCK_END
argument_list|(
name|b
argument_list|)
operator|-
name|BLOCK_START
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|best_s
operator|=
name|s
expr_stmt|;
block|}
block|}
if|if
condition|(
name|best_s
operator|!=
name|NULL
condition|)
return|return
operator|(
name|best_s
operator|)
return|;
name|s
operator|=
name|NULL
expr_stmt|;
name|ps
operator|=
name|find_pc_psymtab
argument_list|(
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ps
condition|)
block|{
if|if
condition|(
name|ps
operator|->
name|readin
condition|)
comment|/* Might want to error() here (in case symtab is corrupt and 	   will cause a core dump), but maybe we can successfully 	   continue, so let's not.  */
comment|/* FIXME-32x64: assumes pc fits in a long */
name|warning
argument_list|(
literal|"\ (Internal error: pc 0x%lx in read in psymtab, but not in symtab.)\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|pc
argument_list|)
expr_stmt|;
name|s
operator|=
name|PSYMTAB_TO_SYMTAB
argument_list|(
name|ps
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Find the closest symbol value (of any sort -- function or variable)    for a given address value.  Slow but complete.  (currently unused,    mainly because it is too slow.  We could fix it if each symtab and    psymtab had contained in it the addresses ranges of each of its    sections, which also would be required to make things like "info    line *0x2345" cause psymtabs to be converted to symtabs).  */
end_comment

begin_comment
unit|struct symbol * find_addr_symbol (addr, symtabp, symaddrp)      CORE_ADDR addr;      struct symtab **symtabp;      CORE_ADDR *symaddrp; {   struct symtab *symtab, *best_symtab;   struct objfile *objfile;   register int bot, top;   register struct symbol *sym;   register CORE_ADDR sym_addr;   struct block *block;   int blocknum;
comment|/* Info on best symbol seen so far */
end_comment

begin_comment
unit|register CORE_ADDR best_sym_addr = 0;   struct symbol *best_sym = 0;
comment|/* FIXME -- we should pull in all the psymtabs, too!  */
end_comment

begin_comment
unit|ALL_SYMTABS (objfile, symtab)     {
comment|/* Search the global and static blocks in this symtab for 	 the closest symbol-address to the desired address.  */
end_comment

begin_comment
unit|for (blocknum = GLOBAL_BLOCK; blocknum<= STATIC_BLOCK; blocknum++) 	{ 	  QUIT; 	  block = BLOCKVECTOR_BLOCK (BLOCKVECTOR (symtab), blocknum); 	  top = BLOCK_NSYMS (block); 	  for (bot = 0; bot< top; bot++) 	    { 	      sym = BLOCK_SYM (block, bot); 	      switch (SYMBOL_CLASS (sym)) 		{ 		case LOC_STATIC:	 		case LOC_LABEL:	 		  sym_addr = SYMBOL_VALUE_ADDRESS (sym); 		  break;  		case LOC_BLOCK: 		  sym_addr = BLOCK_START (SYMBOL_BLOCK_VALUE (sym)); 		  break;  		default: 		  continue; 		}  		if (sym_addr<= addr) 		  if (sym_addr> best_sym_addr) 		    {
comment|/* Quit if we found an exact match.  */
end_comment

begin_endif
unit|best_sym = sym; 		      best_sym_addr = sym_addr; 		      best_symtab = symtab; 		      if (sym_addr == addr) 			goto done; 		    } 	    } 	}     }   done:   if (symtabp)     *symtabp = best_symtab;   if (symaddrp)     *symaddrp = best_sym_addr;   return best_sym; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_comment
comment|/* Find the source file and line number for a given PC value.    Return a structure containing a symtab pointer, a line number,    and a pc range for the entire source line.    The value's .pc field is NOT the specified pc.    NOTCURRENT nonzero means, if specified pc is on a line boundary,    use the line that ends there.  Otherwise, in that case, the line    that begins there is used.  */
end_comment

begin_comment
comment|/* The big complication here is that a line may start in one file, and end just    before the start of another file.  This usually occurs when you #include    code in the middle of a subroutine.  To properly find the end of a line's PC    range, we must search all symtabs associated with this compilation unit, and    find the one whose first PC is closer than that of the next line in this    symtab.  */
end_comment

begin_comment
comment|/* If it's worth the effort, we could be using a binary search.  */
end_comment

begin_function
name|struct
name|symtab_and_line
name|find_pc_line
parameter_list|(
name|pc
parameter_list|,
name|notcurrent
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
name|int
name|notcurrent
decl_stmt|;
block|{
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
specifier|register
name|struct
name|linetable
modifier|*
name|l
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|linetable_entry
modifier|*
name|item
decl_stmt|;
name|struct
name|symtab_and_line
name|val
decl_stmt|;
name|struct
name|blockvector
modifier|*
name|bv
decl_stmt|;
comment|/* Info on best line seen so far, and where it starts, and its file.  */
name|struct
name|linetable_entry
modifier|*
name|best
init|=
name|NULL
decl_stmt|;
name|CORE_ADDR
name|best_end
init|=
literal|0
decl_stmt|;
name|struct
name|symtab
modifier|*
name|best_symtab
init|=
literal|0
decl_stmt|;
comment|/* Store here the first line number      of a file which contains the line at the smallest pc after PC.      If we don't find a line whose range contains PC,      we will use a line one less than this,      with a range from the start of that file to the first line's pc.  */
name|struct
name|linetable_entry
modifier|*
name|alt
init|=
name|NULL
decl_stmt|;
name|struct
name|symtab
modifier|*
name|alt_symtab
init|=
literal|0
decl_stmt|;
comment|/* Info on best line seen in this file.  */
name|struct
name|linetable_entry
modifier|*
name|prev
decl_stmt|;
comment|/* If this pc is not from the current frame,      it is the address of the end of a call instruction.      Quite likely that is the start of the following statement.      But what we want is the statement containing the instruction.      Fudge the pc to make sure we get that.  */
if|if
condition|(
name|notcurrent
condition|)
name|pc
operator|-=
literal|1
expr_stmt|;
name|s
operator|=
name|find_pc_symtab
argument_list|(
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
block|{
name|val
operator|.
name|symtab
operator|=
literal|0
expr_stmt|;
name|val
operator|.
name|line
operator|=
literal|0
expr_stmt|;
name|val
operator|.
name|pc
operator|=
name|pc
expr_stmt|;
name|val
operator|.
name|end
operator|=
literal|0
expr_stmt|;
return|return
name|val
return|;
block|}
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Look at all the symtabs that share this blockvector.      They all have the same apriori range, that we found was right;      but they have different line tables.  */
for|for
control|(
init|;
name|s
operator|&&
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
operator|==
name|bv
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
comment|/* Find the best line in this symtab.  */
name|l
operator|=
name|LINETABLE
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|l
condition|)
continue|continue;
name|len
operator|=
name|l
operator|->
name|nitems
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
comment|/* I think len can be zero if the symtab lacks line numbers 	     (e.g. gcc -g1).  (Either that or the LINETABLE is NULL; 	     I'm not sure which, and maybe it depends on the symbol 	     reader).  */
continue|continue;
block|}
name|prev
operator|=
name|NULL
expr_stmt|;
name|item
operator|=
name|l
operator|->
name|item
expr_stmt|;
comment|/* Get first line info */
comment|/* Is this file's first line closer than the first lines of other files? 	 If so, record this file, and its first line, as best alternate.  */
if|if
condition|(
name|item
operator|->
name|pc
operator|>
name|pc
operator|&&
operator|(
operator|!
name|alt
operator|||
name|item
operator|->
name|pc
operator|<
name|alt
operator|->
name|pc
operator|)
condition|)
block|{
name|alt
operator|=
name|item
expr_stmt|;
name|alt_symtab
operator|=
name|s
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
operator|,
name|item
operator|++
control|)
block|{
comment|/* Return the last line that did not start after PC.  */
if|if
condition|(
name|item
operator|->
name|pc
operator|>
name|pc
condition|)
break|break;
name|prev
operator|=
name|item
expr_stmt|;
block|}
comment|/* At this point, prev points at the line whose start addr is<= pc, and 	 item points at the next line.  If we ran off the end of the linetable 	 (pc>= start of the last line), then prev == item.  If pc< start of 	 the first line, prev will not be set.  */
comment|/* Is this file's best line closer than the best in the other files? 	 If so, record this file, and its best line, as best so far.  */
if|if
condition|(
name|prev
operator|&&
operator|(
operator|!
name|best
operator|||
name|prev
operator|->
name|pc
operator|>
name|best
operator|->
name|pc
operator|)
condition|)
block|{
name|best
operator|=
name|prev
expr_stmt|;
name|best_symtab
operator|=
name|s
expr_stmt|;
comment|/* If another line is in the linetable, and its PC is closer 	     than the best_end we currently have, take it as best_end.  */
if|if
condition|(
name|i
operator|<
name|len
operator|&&
operator|(
name|best_end
operator|==
literal|0
operator|||
name|best_end
operator|>
name|item
operator|->
name|pc
operator|)
condition|)
name|best_end
operator|=
name|item
operator|->
name|pc
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|best_symtab
condition|)
block|{
if|if
condition|(
operator|!
name|alt_symtab
condition|)
block|{
comment|/* If we didn't find any line # info, just 				 return zeros.  */
name|val
operator|.
name|symtab
operator|=
literal|0
expr_stmt|;
name|val
operator|.
name|line
operator|=
literal|0
expr_stmt|;
name|val
operator|.
name|pc
operator|=
name|pc
expr_stmt|;
name|val
operator|.
name|end
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|val
operator|.
name|symtab
operator|=
name|alt_symtab
expr_stmt|;
name|val
operator|.
name|line
operator|=
name|alt
operator|->
name|line
operator|-
literal|1
expr_stmt|;
name|val
operator|.
name|pc
operator|=
name|BLOCK_END
argument_list|(
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator|.
name|end
operator|=
name|alt
operator|->
name|pc
expr_stmt|;
block|}
block|}
else|else
block|{
name|val
operator|.
name|symtab
operator|=
name|best_symtab
expr_stmt|;
name|val
operator|.
name|line
operator|=
name|best
operator|->
name|line
expr_stmt|;
name|val
operator|.
name|pc
operator|=
name|best
operator|->
name|pc
expr_stmt|;
if|if
condition|(
name|best_end
operator|&&
operator|(
operator|!
name|alt
operator|||
name|best_end
operator|<
name|alt
operator|->
name|pc
operator|)
condition|)
name|val
operator|.
name|end
operator|=
name|best_end
expr_stmt|;
elseif|else
if|if
condition|(
name|alt
condition|)
name|val
operator|.
name|end
operator|=
name|alt
operator|->
name|pc
expr_stmt|;
else|else
name|val
operator|.
name|end
operator|=
name|BLOCK_END
argument_list|(
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|int
name|find_line_symtab
name|PARAMS
argument_list|(
operator|(
expr|struct
name|symtab
operator|*
operator|,
name|int
operator|,
expr|struct
name|linetable
operator|*
operator|*
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Find line number LINE in any symtab whose name is the same as    SYMTAB.     If found, return 1, set *LINETABLE to the linetable in which it was    found, set *INDEX to the index in the linetable of the best entry    found, and set *EXACT_MATCH nonzero if the value returned is an    exact match.     If not found, return 0.  */
end_comment

begin_function
specifier|static
name|int
name|find_line_symtab
parameter_list|(
name|symtab
parameter_list|,
name|line
parameter_list|,
name|linetable
parameter_list|,
name|index
parameter_list|,
name|exact_match
parameter_list|)
name|struct
name|symtab
modifier|*
name|symtab
decl_stmt|;
name|int
name|line
decl_stmt|;
name|struct
name|linetable
modifier|*
modifier|*
name|linetable
decl_stmt|;
name|int
modifier|*
name|index
decl_stmt|;
name|int
modifier|*
name|exact_match
decl_stmt|;
block|{
name|int
name|exact
decl_stmt|;
comment|/* BEST_INDEX and BEST_LINETABLE identify the smallest linenumber> LINE      so far seen.  */
name|int
name|best_index
decl_stmt|;
name|struct
name|linetable
modifier|*
name|best_linetable
decl_stmt|;
comment|/* First try looking it up in the given symtab.  */
name|best_linetable
operator|=
name|LINETABLE
argument_list|(
name|symtab
argument_list|)
expr_stmt|;
name|best_index
operator|=
name|find_line_common
argument_list|(
name|best_linetable
argument_list|,
name|line
argument_list|,
operator|&
name|exact
argument_list|)
expr_stmt|;
if|if
condition|(
name|best_index
operator|<
literal|0
operator|||
operator|!
name|exact
condition|)
block|{
comment|/* Didn't find an exact match.  So we better keep looking for 	 another symtab with the same name.  In the case of xcoff, 	 multiple csects for one source file (produced by IBM's FORTRAN 	 compiler) produce multiple symtabs (this is unavoidable 	 assuming csects can be at arbitrary places in memory and that 	 the GLOBAL_BLOCK of a symtab has a begin and end address).  */
comment|/* BEST is the smallest linenumber> LINE so far seen, 	 or 0 if none has been seen so far. 	 BEST_INDEX and BEST_LINETABLE identify the item for it.  */
name|int
name|best
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|best_index
operator|>=
literal|0
condition|)
name|best
operator|=
name|best_linetable
operator|->
name|item
index|[
name|best_index
index|]
operator|.
name|line
expr_stmt|;
else|else
name|best
operator|=
literal|0
expr_stmt|;
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
name|struct
name|linetable
modifier|*
name|l
decl_stmt|;
name|int
name|ind
decl_stmt|;
if|if
condition|(
operator|!
name|STREQ
argument_list|(
name|symtab
operator|->
name|filename
argument_list|,
name|s
operator|->
name|filename
argument_list|)
condition|)
continue|continue;
name|l
operator|=
name|LINETABLE
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ind
operator|=
name|find_line_common
argument_list|(
name|l
argument_list|,
name|line
argument_list|,
operator|&
name|exact
argument_list|)
expr_stmt|;
if|if
condition|(
name|ind
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|exact
condition|)
block|{
name|best_index
operator|=
name|ind
expr_stmt|;
name|best_linetable
operator|=
name|l
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|best
operator|==
literal|0
operator|||
name|l
operator|->
name|item
index|[
name|ind
index|]
operator|.
name|line
operator|<
name|best
condition|)
block|{
name|best
operator|=
name|l
operator|->
name|item
index|[
name|ind
index|]
operator|.
name|line
expr_stmt|;
name|best_index
operator|=
name|ind
expr_stmt|;
name|best_linetable
operator|=
name|l
expr_stmt|;
block|}
block|}
block|}
block|}
name|done
label|:
if|if
condition|(
name|best_index
operator|<
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|index
condition|)
operator|*
name|index
operator|=
name|best_index
expr_stmt|;
if|if
condition|(
name|linetable
condition|)
operator|*
name|linetable
operator|=
name|best_linetable
expr_stmt|;
if|if
condition|(
name|exact_match
condition|)
operator|*
name|exact_match
operator|=
name|exact
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find the PC value for a given source file and line number.    Returns zero for invalid line number.    The source file is specified with a struct symtab.  */
end_comment

begin_function
name|CORE_ADDR
name|find_line_pc
parameter_list|(
name|symtab
parameter_list|,
name|line
parameter_list|)
name|struct
name|symtab
modifier|*
name|symtab
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
name|struct
name|linetable
modifier|*
name|l
decl_stmt|;
name|int
name|ind
decl_stmt|;
if|if
condition|(
name|symtab
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|find_line_symtab
argument_list|(
name|symtab
argument_list|,
name|line
argument_list|,
operator|&
name|l
argument_list|,
operator|&
name|ind
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
name|l
operator|->
name|item
index|[
name|ind
index|]
operator|.
name|pc
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Find the range of pc values in a line.    Store the starting pc of the line into *STARTPTR    and the ending pc (start of next line) into *ENDPTR.    Returns 1 to indicate success.    Returns 0 if could not find the specified line.  */
end_comment

begin_function
name|int
name|find_line_pc_range
parameter_list|(
name|sal
parameter_list|,
name|startptr
parameter_list|,
name|endptr
parameter_list|)
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|CORE_ADDR
modifier|*
name|startptr
decl_stmt|,
decl|*
name|endptr
decl_stmt|;
end_function

begin_block
block|{
name|CORE_ADDR
name|startaddr
decl_stmt|;
name|struct
name|symtab_and_line
name|found_sal
decl_stmt|;
name|startaddr
operator|=
name|sal
operator|.
name|pc
expr_stmt|;
if|if
condition|(
name|startaddr
operator|==
literal|0
condition|)
block|{
name|startaddr
operator|=
name|find_line_pc
argument_list|(
name|sal
operator|.
name|symtab
argument_list|,
name|sal
operator|.
name|line
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|startaddr
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* This whole function is based on address.  For example, if line 10 has      two parts, one from 0x100 to 0x200 and one from 0x300 to 0x400, then      "info line *0x123" should say the line goes from 0x100 to 0x200      and "info line *0x355" should say the line goes from 0x300 to 0x400.      This also insures that we never give a range like "starts at 0x134      and ends at 0x12c".  */
name|found_sal
operator|=
name|find_pc_line
argument_list|(
name|startaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|found_sal
operator|.
name|line
operator|!=
name|sal
operator|.
name|line
condition|)
block|{
comment|/* The specified line (sal) has zero bytes.  */
operator|*
name|startptr
operator|=
name|found_sal
operator|.
name|pc
expr_stmt|;
operator|*
name|endptr
operator|=
name|found_sal
operator|.
name|pc
expr_stmt|;
block|}
else|else
block|{
operator|*
name|startptr
operator|=
name|found_sal
operator|.
name|pc
expr_stmt|;
operator|*
name|endptr
operator|=
name|found_sal
operator|.
name|end
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/* Given a line table and a line number, return the index into the line    table for the pc of the nearest line whose number is>= the specified one.    Return -1 if none is found.  The value is>= 0 if it is an index.     Set *EXACT_MATCH nonzero if the value returned is an exact match.  */
end_comment

begin_function
specifier|static
name|int
name|find_line_common
parameter_list|(
name|l
parameter_list|,
name|lineno
parameter_list|,
name|exact_match
parameter_list|)
specifier|register
name|struct
name|linetable
modifier|*
name|l
decl_stmt|;
specifier|register
name|int
name|lineno
decl_stmt|;
name|int
modifier|*
name|exact_match
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
comment|/* BEST is the smallest linenumber> LINENO so far seen,      or 0 if none has been seen so far.      BEST_INDEX identifies the item for it.  */
name|int
name|best_index
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|best
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|lineno
operator|<=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|l
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|len
operator|=
name|l
operator|->
name|nitems
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|struct
name|linetable_entry
modifier|*
name|item
init|=
operator|&
operator|(
name|l
operator|->
name|item
index|[
name|i
index|]
operator|)
decl_stmt|;
if|if
condition|(
name|item
operator|->
name|line
operator|==
name|lineno
condition|)
block|{
comment|/* Return the first (lowest address) entry which matches.  */
operator|*
name|exact_match
operator|=
literal|1
expr_stmt|;
return|return
name|i
return|;
block|}
if|if
condition|(
name|item
operator|->
name|line
operator|>
name|lineno
operator|&&
operator|(
name|best
operator|==
literal|0
operator|||
name|item
operator|->
name|line
operator|<
name|best
operator|)
condition|)
block|{
name|best
operator|=
name|item
operator|->
name|line
expr_stmt|;
name|best_index
operator|=
name|i
expr_stmt|;
block|}
block|}
comment|/* If we got here, we didn't get an exact match.  */
operator|*
name|exact_match
operator|=
literal|0
expr_stmt|;
return|return
name|best_index
return|;
block|}
end_function

begin_function
name|int
name|find_pc_line_pc_range
parameter_list|(
name|pc
parameter_list|,
name|startptr
parameter_list|,
name|endptr
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
name|CORE_ADDR
modifier|*
name|startptr
decl_stmt|,
decl|*
name|endptr
decl_stmt|;
end_function

begin_block
block|{
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|sal
operator|=
name|find_pc_line
argument_list|(
name|pc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|startptr
operator|=
name|sal
operator|.
name|pc
expr_stmt|;
operator|*
name|endptr
operator|=
name|sal
operator|.
name|end
expr_stmt|;
return|return
name|sal
operator|.
name|symtab
operator|!=
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Given a function symbol SYM, find the symtab and line for the start    of the function.    If the argument FUNFIRSTLINE is nonzero, we want the first line    of real code inside the function.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|symtab_and_line
name|find_function_start_sal
name|PARAMS
argument_list|(
operator|(
expr|struct
name|symbol
operator|*
name|sym
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|struct
name|symtab_and_line
name|find_function_start_sal
parameter_list|(
name|sym
parameter_list|,
name|funfirstline
parameter_list|)
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|int
name|funfirstline
decl_stmt|;
block|{
name|CORE_ADDR
name|pc
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|pc
operator|=
name|BLOCK_START
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|funfirstline
condition|)
block|{
name|pc
operator|+=
name|FUNCTION_START_OFFSET
expr_stmt|;
name|SKIP_PROLOGUE
argument_list|(
name|pc
argument_list|)
expr_stmt|;
block|}
name|sal
operator|=
name|find_pc_line
argument_list|(
name|pc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PROLOGUE_FIRSTLINE_OVERLAP
comment|/* Convex: no need to suppress code on first line, if any */
name|sal
operator|.
name|pc
operator|=
name|pc
expr_stmt|;
else|#
directive|else
comment|/* Check if SKIP_PROLOGUE left us in mid-line, and the next      line is still part of the same function.  */
if|if
condition|(
name|sal
operator|.
name|pc
operator|!=
name|pc
operator|&&
name|BLOCK_START
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|<=
name|sal
operator|.
name|end
operator|&&
name|sal
operator|.
name|end
operator|<
name|BLOCK_END
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|)
block|{
comment|/* First pc of next line */
name|pc
operator|=
name|sal
operator|.
name|end
expr_stmt|;
comment|/* Recalculate the line number (might not be N+1).  */
name|sal
operator|=
name|find_pc_line
argument_list|(
name|pc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|sal
operator|.
name|pc
operator|=
name|pc
expr_stmt|;
endif|#
directive|endif
return|return
name|sal
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If P is of the form "operator[ \t]+..." where `...' is    some legitimate operator text, return a pointer to the    beginning of the substring of the operator text.    Otherwise, return "".  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|operator_chars
parameter_list|(
name|p
parameter_list|,
name|end
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
modifier|*
name|end
decl_stmt|;
block|{
operator|*
name|end
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"operator"
argument_list|,
literal|8
argument_list|)
condition|)
return|return
operator|*
name|end
return|;
name|p
operator|+=
literal|8
expr_stmt|;
comment|/* Don't get faked out by `operator' being part of a longer      identifier.  */
if|if
condition|(
name|isalpha
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'_'
operator|||
operator|*
name|p
operator|==
literal|'$'
operator|||
operator|*
name|p
operator|==
literal|'\0'
condition|)
return|return
operator|*
name|end
return|;
comment|/* Allow some whitespace between `operator' and the operator symbol.  */
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
comment|/* Recognize 'operator TYPENAME'. */
if|if
condition|(
name|isalpha
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'_'
operator|||
operator|*
name|p
operator|==
literal|'$'
condition|)
block|{
specifier|register
name|char
modifier|*
name|q
init|=
name|p
operator|+
literal|1
decl_stmt|;
while|while
condition|(
name|isalnum
argument_list|(
operator|*
name|q
argument_list|)
operator|||
operator|*
name|q
operator|==
literal|'_'
operator|||
operator|*
name|q
operator|==
literal|'$'
condition|)
name|q
operator|++
expr_stmt|;
operator|*
name|end
operator|=
name|q
expr_stmt|;
return|return
name|p
return|;
block|}
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'!'
case|:
case|case
literal|'='
case|:
case|case
literal|'*'
case|:
case|case
literal|'/'
case|:
case|case
literal|'%'
case|:
case|case
literal|'^'
case|:
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'='
condition|)
operator|*
name|end
operator|=
name|p
operator|+
literal|2
expr_stmt|;
else|else
operator|*
name|end
operator|=
name|p
operator|+
literal|1
expr_stmt|;
return|return
name|p
return|;
case|case
literal|'<'
case|:
case|case
literal|'>'
case|:
case|case
literal|'+'
case|:
case|case
literal|'-'
case|:
case|case
literal|'&'
case|:
case|case
literal|'|'
case|:
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'='
operator|||
name|p
index|[
literal|1
index|]
operator|==
name|p
index|[
literal|0
index|]
condition|)
operator|*
name|end
operator|=
name|p
operator|+
literal|2
expr_stmt|;
else|else
operator|*
name|end
operator|=
name|p
operator|+
literal|1
expr_stmt|;
return|return
name|p
return|;
case|case
literal|'~'
case|:
case|case
literal|','
case|:
operator|*
name|end
operator|=
name|p
operator|+
literal|1
expr_stmt|;
return|return
name|p
return|;
case|case
literal|'('
case|:
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|!=
literal|')'
condition|)
name|error
argument_list|(
literal|"`operator ()' must be specified without whitespace in `()'"
argument_list|)
expr_stmt|;
operator|*
name|end
operator|=
name|p
operator|+
literal|2
expr_stmt|;
return|return
name|p
return|;
case|case
literal|'?'
case|:
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|!=
literal|':'
condition|)
name|error
argument_list|(
literal|"`operator ?:' must be specified without whitespace in `?:'"
argument_list|)
expr_stmt|;
operator|*
name|end
operator|=
name|p
operator|+
literal|2
expr_stmt|;
return|return
name|p
return|;
case|case
literal|'['
case|:
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|!=
literal|']'
condition|)
name|error
argument_list|(
literal|"`operator []' must be specified without whitespace in `[]'"
argument_list|)
expr_stmt|;
operator|*
name|end
operator|=
name|p
operator|+
literal|2
expr_stmt|;
return|return
name|p
return|;
default|default:
name|error
argument_list|(
literal|"`operator %s' not supported"
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
operator|*
name|end
operator|=
literal|""
expr_stmt|;
return|return
operator|*
name|end
return|;
block|}
end_function

begin_comment
comment|/* Recursive helper function for decode_line_1.  * Look for methods named NAME in type T.  * Return number of matches.  * Put matches in SYM_ARR (which better be big enough!).  * These allocations seem to define "big enough":  * sym_arr = (struct symbol **) alloca(TYPE_NFN_FIELDS_TOTAL (t) * sizeof(struct symbol*));  * Note that this function is g++ specific.  */
end_comment

begin_function
name|int
name|find_methods
parameter_list|(
name|t
parameter_list|,
name|name
parameter_list|,
name|sym_arr
parameter_list|)
name|struct
name|type
modifier|*
name|t
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|symbol
modifier|*
modifier|*
name|sym_arr
decl_stmt|;
block|{
name|int
name|i1
init|=
literal|0
decl_stmt|;
name|int
name|ibase
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym_class
decl_stmt|;
name|char
modifier|*
name|class_name
init|=
name|type_name_no_tag
argument_list|(
name|t
argument_list|)
decl_stmt|;
comment|/* Ignore this class if it doesn't have a name.  This is ugly, but      unless we figure out how to get the physname without the name of      the class, then the loop can't do any good.  */
if|if
condition|(
name|class_name
operator|&&
operator|(
name|sym_class
operator|=
name|lookup_symbol
argument_list|(
name|class_name
argument_list|,
operator|(
expr|struct
name|block
operator|*
operator|)
name|NULL
argument_list|,
name|STRUCT_NAMESPACE
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|*
operator|)
name|NULL
argument_list|)
operator|)
condition|)
block|{
name|int
name|method_counter
decl_stmt|;
comment|/* FIXME: Shouldn't this just be check_stub_type (t)?  */
name|t
operator|=
name|SYMBOL_TYPE
argument_list|(
name|sym_class
argument_list|)
expr_stmt|;
for|for
control|(
name|method_counter
operator|=
name|TYPE_NFN_FIELDS
argument_list|(
name|t
argument_list|)
operator|-
literal|1
init|;
name|method_counter
operator|>=
literal|0
condition|;
operator|--
name|method_counter
control|)
block|{
name|int
name|field_counter
decl_stmt|;
name|struct
name|fn_field
modifier|*
name|f
init|=
name|TYPE_FN_FIELDLIST1
argument_list|(
name|t
argument_list|,
name|method_counter
argument_list|)
decl_stmt|;
name|char
modifier|*
name|method_name
init|=
name|TYPE_FN_FIELDLIST_NAME
argument_list|(
name|t
argument_list|,
name|method_counter
argument_list|)
decl_stmt|;
name|char
name|dem_opname
index|[
literal|64
index|]
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|method_name
argument_list|,
literal|"__"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|method_name
argument_list|,
literal|"op"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|method_name
argument_list|,
literal|"type"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|cplus_demangle_opname
argument_list|(
name|method_name
argument_list|,
name|dem_opname
argument_list|,
name|DMGL_ANSI
argument_list|)
condition|)
name|method_name
operator|=
name|dem_opname
expr_stmt|;
elseif|else
if|if
condition|(
name|cplus_demangle_opname
argument_list|(
name|method_name
argument_list|,
name|dem_opname
argument_list|,
literal|0
argument_list|)
condition|)
name|method_name
operator|=
name|dem_opname
expr_stmt|;
block|}
if|if
condition|(
name|STREQ
argument_list|(
name|name
argument_list|,
name|method_name
argument_list|)
condition|)
comment|/* Find all the fields with that name.  */
for|for
control|(
name|field_counter
operator|=
name|TYPE_FN_FIELDLIST_LENGTH
argument_list|(
name|t
argument_list|,
name|method_counter
argument_list|)
operator|-
literal|1
init|;
name|field_counter
operator|>=
literal|0
condition|;
operator|--
name|field_counter
control|)
block|{
name|char
modifier|*
name|phys_name
decl_stmt|;
if|if
condition|(
name|TYPE_FN_FIELD_STUB
argument_list|(
name|f
argument_list|,
name|field_counter
argument_list|)
condition|)
name|check_stub_method
argument_list|(
name|t
argument_list|,
name|method_counter
argument_list|,
name|field_counter
argument_list|)
expr_stmt|;
name|phys_name
operator|=
name|TYPE_FN_FIELD_PHYSNAME
argument_list|(
name|f
argument_list|,
name|field_counter
argument_list|)
expr_stmt|;
comment|/* Destructor is handled by caller, dont add it to the list */
if|if
condition|(
name|DESTRUCTOR_PREFIX_P
argument_list|(
name|phys_name
argument_list|)
condition|)
continue|continue;
comment|/* FIXME: Why are we looking this up in the 		   SYMBOL_BLOCK_VALUE (sym_class)?  It is intended as a hook 		   for nested types?  If so, it should probably hook to the 		   type, not the symbol.  mipsread.c is the only symbol 		   reader which sets the SYMBOL_BLOCK_VALUE for types, and 		   this is not documented in symtab.h.  -26Aug93.  */
name|sym_arr
index|[
name|i1
index|]
operator|=
name|lookup_symbol
argument_list|(
name|phys_name
argument_list|,
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|sym_class
argument_list|)
argument_list|,
name|VAR_NAMESPACE
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym_arr
index|[
name|i1
index|]
condition|)
name|i1
operator|++
expr_stmt|;
else|else
block|{
name|fputs_filtered
argument_list|(
literal|"(Cannot find method "
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|fprintf_symbol_filtered
argument_list|(
name|gdb_stdout
argument_list|,
name|phys_name
argument_list|,
name|language_cplus
argument_list|,
name|DMGL_PARAMS
operator||
name|DMGL_ANSI
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|" - possibly inlined.)\n"
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Only search baseclasses if there is no match yet, since names in      derived classes override those in baseclasses.       FIXME: The above is not true; it is only true of member functions      if they have the same number of arguments (??? - section 13.1 of the      ARM says the function members are not in the same scope but doesn't      really spell out the rules in a way I understand.  In any case, if      the number of arguments differ this is a case in which we can overload      rather than hiding without any problem, and gcc 2.4.5 does overload      rather than hiding in this case).  */
if|if
condition|(
name|i1
condition|)
return|return
name|i1
return|;
for|for
control|(
name|ibase
operator|=
literal|0
init|;
name|ibase
operator|<
name|TYPE_N_BASECLASSES
argument_list|(
name|t
argument_list|)
condition|;
name|ibase
operator|++
control|)
name|i1
operator|+=
name|find_methods
argument_list|(
name|TYPE_BASECLASS
argument_list|(
name|t
argument_list|,
name|ibase
argument_list|)
argument_list|,
name|name
argument_list|,
name|sym_arr
operator|+
name|i1
argument_list|)
expr_stmt|;
return|return
name|i1
return|;
block|}
end_function

begin_comment
comment|/* Helper function for decode_line_1.    Build a canonical line spec in CANONICAL if it is non-NULL and if    the SAL has a symtab.    If SYMNAME is non-NULL the canonical line spec is `filename:symname'.    If SYMNAME is NULL the line number from SAL is used and the canonical    line spec is `filename:linenum'.  */
end_comment

begin_function
specifier|static
name|void
name|build_canonical_line_spec
parameter_list|(
name|sal
parameter_list|,
name|symname
parameter_list|,
name|canonical
parameter_list|)
name|struct
name|symtab_and_line
modifier|*
name|sal
decl_stmt|;
name|char
modifier|*
name|symname
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|canonical
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|canonical_arr
decl_stmt|;
name|char
modifier|*
name|canonical_name
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|struct
name|symtab
modifier|*
name|s
init|=
name|sal
operator|->
name|symtab
decl_stmt|;
if|if
condition|(
name|s
operator|==
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|NULL
operator|||
name|s
operator|->
name|filename
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
operator|||
name|canonical
operator|==
operator|(
name|char
operator|*
operator|*
operator|*
operator|)
name|NULL
condition|)
return|return;
name|canonical_arr
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|canonical
operator|=
name|canonical_arr
expr_stmt|;
name|filename
operator|=
name|s
operator|->
name|filename
expr_stmt|;
if|if
condition|(
name|symname
operator|!=
name|NULL
condition|)
block|{
name|canonical_name
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
name|strlen
argument_list|(
name|symname
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|canonical_name
argument_list|,
literal|"%s:%s"
argument_list|,
name|filename
argument_list|,
name|symname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|canonical_name
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
literal|30
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|canonical_name
argument_list|,
literal|"%s:%d"
argument_list|,
name|filename
argument_list|,
name|sal
operator|->
name|line
argument_list|)
expr_stmt|;
block|}
name|canonical_arr
index|[
literal|0
index|]
operator|=
name|canonical_name
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse a string that specifies a line number.    Pass the address of a char * variable; that variable will be    advanced over the characters actually parsed.     The string can be:     LINENUM -- that line number in current file.  PC returned is 0.    FILE:LINENUM -- that line in that file.  PC returned is 0.    FUNCTION -- line number of openbrace of that function.       PC returned is the start of the function.    VARIABLE -- line number of definition of that variable.       PC returned is 0.    FILE:FUNCTION -- likewise, but prefer functions in that file.    *EXPR -- line in which address EXPR appears.     FUNCTION may be an undebuggable function found in minimal symbol table.     If the argument FUNFIRSTLINE is nonzero, we want the first line    of real code inside a function when a function is specified.     DEFAULT_SYMTAB specifies the file to use if none is specified.    It defaults to current_source_symtab.    DEFAULT_LINE specifies the line number to use for relative    line numbers (that start with signs).  Defaults to current_source_line.    If CANONICAL is non-NULL, store an array of strings containing the canonical    line specs there if necessary. Currently overloaded member functions and    line numbers or static functions without a filename yield a canonical    line spec. The array and the line spec strings are allocated on the heap,    it is the callers responsibility to free them.     Note that it is possible to return zero for the symtab    if no file is validly specified.  Callers must check that.    Also, the line number returned may be invalid.  */
end_comment

begin_comment
comment|/* We allow single quotes in various places.  This is a hideous    kludge, which exists because the completer can't yet deal with the    lack of single quotes.  FIXME: write a linespec_completer which we    can use as appropriate instead of make_symbol_completion_list.  */
end_comment

begin_function
name|struct
name|symtabs_and_lines
name|decode_line_1
parameter_list|(
name|argptr
parameter_list|,
name|funfirstline
parameter_list|,
name|default_symtab
parameter_list|,
name|default_line
parameter_list|,
name|canonical
parameter_list|)
name|char
modifier|*
modifier|*
name|argptr
decl_stmt|;
name|int
name|funfirstline
decl_stmt|;
name|struct
name|symtab
modifier|*
name|default_symtab
decl_stmt|;
name|int
name|default_line
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|canonical
decl_stmt|;
block|{
name|struct
name|symtabs_and_lines
name|values
decl_stmt|;
ifdef|#
directive|ifdef
name|HPPA_COMPILER_BUG
comment|/* FIXME: The native HP 9000/700 compiler has a bug which appears      when optimizing this file with target i960-vxworks.  I haven't      been able to construct a simple test case.  The problem is that      in the second call to SKIP_PROLOGUE below, the compiler somehow      does not realize that the statement val = find_pc_line (...) will      change the values of the fields of val.  It extracts the elements      into registers at the top of the block, and does not update the      registers after the call to find_pc_line.  You can check this by      inserting a printf at the end of find_pc_line to show what values      it is returning for val.pc and val.end and another printf after      the call to see what values the function actually got (remember,      this is compiling with cc -O, with this patch removed).  You can      also examine the assembly listing: search for the second call to      skip_prologue; the LDO statement before the next call to      find_pc_line loads the address of the structure which      find_pc_line will return; if there is a LDW just before the LDO,      which fetches an element of the structure, then the compiler      still has the bug.       Setting val to volatile avoids the problem.  We must undef      volatile, because the HPPA native compiler does not define      __STDC__, although it does understand volatile, and so volatile      will have been defined away in defs.h.  */
undef|#
directive|undef
name|volatile
specifier|volatile
name|struct
name|symtab_and_line
name|val
decl_stmt|;
define|#
directive|define
name|volatile
comment|/*nothing*/
else|#
directive|else
name|struct
name|symtab_and_line
name|val
decl_stmt|;
endif|#
directive|endif
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|p1
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|,
modifier|*
name|pp
decl_stmt|;
if|#
directive|if
literal|0
block|char *q1;
endif|#
directive|endif
specifier|register
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
specifier|register
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
comment|/* The symtab that SYM was found in.  */
name|struct
name|symtab
modifier|*
name|sym_symtab
decl_stmt|;
specifier|register
name|CORE_ADDR
name|pc
decl_stmt|;
specifier|register
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
name|char
modifier|*
name|copy
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym_class
decl_stmt|;
name|int
name|i1
decl_stmt|;
name|int
name|is_quoted
decl_stmt|,
name|has_parens
decl_stmt|;
name|struct
name|symbol
modifier|*
modifier|*
name|sym_arr
decl_stmt|;
name|struct
name|type
modifier|*
name|t
decl_stmt|;
name|char
modifier|*
name|saved_arg
init|=
operator|*
name|argptr
decl_stmt|;
specifier|extern
name|char
modifier|*
name|gdb_completer_quote_characters
decl_stmt|;
comment|/* Defaults have defaults.  */
if|if
condition|(
name|default_symtab
operator|==
literal|0
condition|)
block|{
name|default_symtab
operator|=
name|current_source_symtab
expr_stmt|;
name|default_line
operator|=
name|current_source_line
expr_stmt|;
block|}
comment|/* See if arg is *PC */
if|if
condition|(
operator|*
operator|*
name|argptr
operator|==
literal|'*'
condition|)
block|{
if|if
condition|(
operator|*
operator|*
name|argptr
operator|==
literal|'*'
condition|)
block|{
operator|(
operator|*
name|argptr
operator|)
operator|++
expr_stmt|;
block|}
name|pc
operator|=
name|parse_and_eval_address_1
argument_list|(
name|argptr
argument_list|)
expr_stmt|;
name|values
operator|.
name|sals
operator|=
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symtab_and_line
argument_list|)
argument_list|)
expr_stmt|;
name|values
operator|.
name|nelts
operator|=
literal|1
expr_stmt|;
name|values
operator|.
name|sals
index|[
literal|0
index|]
operator|=
name|find_pc_line
argument_list|(
name|pc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|values
operator|.
name|sals
index|[
literal|0
index|]
operator|.
name|pc
operator|=
name|pc
expr_stmt|;
name|build_canonical_line_spec
argument_list|(
name|values
operator|.
name|sals
argument_list|,
name|NULL
argument_list|,
name|canonical
argument_list|)
expr_stmt|;
return|return
name|values
return|;
block|}
comment|/* Maybe arg is FILE : LINENUM or FILE : FUNCTION */
name|s
operator|=
name|NULL
expr_stmt|;
name|is_quoted
operator|=
operator|(
name|strchr
argument_list|(
name|gdb_completer_quote_characters
argument_list|,
operator|*
operator|*
name|argptr
argument_list|)
operator|!=
name|NULL
operator|)
expr_stmt|;
name|has_parens
operator|=
operator|(
operator|(
name|pp
operator|=
name|strchr
argument_list|(
operator|*
name|argptr
argument_list|,
literal|'('
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|(
name|pp
operator|=
name|strchr
argument_list|(
name|pp
argument_list|,
literal|')'
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|*
name|argptr
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'<'
condition|)
block|{
while|while
condition|(
operator|++
name|p
operator|&&
operator|*
name|p
operator|!=
literal|'>'
condition|)
empty_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
block|{
name|error
argument_list|(
literal|"non-matching '<' and '>' in command"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|':'
operator|||
name|p
index|[
literal|0
index|]
operator|==
literal|' '
operator|||
name|p
index|[
literal|0
index|]
operator|==
literal|'\t'
condition|)
break|break;
block|}
while|while
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|' '
operator|||
name|p
index|[
literal|0
index|]
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|p
index|[
literal|0
index|]
operator|==
literal|':'
operator|)
operator|&&
operator|!
name|has_parens
condition|)
block|{
comment|/*  C++  */
if|if
condition|(
name|is_quoted
condition|)
operator|*
name|argptr
operator|=
operator|*
name|argptr
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
block|{
comment|/* Extract the class name.  */
name|p1
operator|=
name|p
expr_stmt|;
while|while
condition|(
name|p
operator|!=
operator|*
name|argptr
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
operator|--
name|p
expr_stmt|;
name|copy
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|p
operator|-
operator|*
name|argptr
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|copy
argument_list|,
operator|*
name|argptr
argument_list|,
name|p
operator|-
operator|*
name|argptr
argument_list|)
expr_stmt|;
name|copy
index|[
name|p
operator|-
operator|*
name|argptr
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Discard the class name from the arg.  */
name|p
operator|=
name|p1
operator|+
literal|2
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
operator|*
name|argptr
operator|=
name|p
expr_stmt|;
name|sym_class
operator|=
name|lookup_symbol
argument_list|(
name|copy
argument_list|,
literal|0
argument_list|,
name|STRUCT_NAMESPACE
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym_class
operator|&&
operator|(
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym_class
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
operator|||
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym_class
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_UNION
operator|)
condition|)
block|{
comment|/* Arg token is not digits => try it as a function name 		 Find the next token(everything up to end or next blank). */
if|if
condition|(
name|strchr
argument_list|(
name|gdb_completer_quote_characters
argument_list|,
operator|*
operator|*
name|argptr
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
name|skip_quoted
argument_list|(
operator|*
name|argptr
argument_list|)
expr_stmt|;
operator|*
name|argptr
operator|=
operator|*
name|argptr
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
operator|*
name|argptr
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|' '
operator|&&
operator|*
name|p
operator|!=
literal|'\t'
operator|&&
operator|*
name|p
operator|!=
literal|','
operator|&&
operator|*
name|p
operator|!=
literal|':'
condition|)
name|p
operator|++
expr_stmt|;
block|}
comment|/* 	      q = operator_chars (*argptr,&q1); 	      if (q1 - q) 		{ 		  char *opname; 		  char *tmp = alloca (q1 - q + 1); 		  memcpy (tmp, q, q1 - q); 		  tmp[q1 - q] = '\0'; 		  opname = cplus_mangle_opname (tmp, DMGL_ANSI); 		  if (opname == NULL) 		    { 		      error_begin (); 		      printf_filtered ("no mangling for \"%s\"\n", tmp); 		      cplusplus_hint (saved_arg); 		      return_to_top_level (RETURN_ERROR); 		    } 		  copy = (char*) alloca (3 + strlen(opname)); 		  sprintf (copy, "__%s", opname); 		  p = q1; 		} 	      else */
block|{
name|copy
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|p
operator|-
operator|*
name|argptr
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|copy
argument_list|,
operator|*
name|argptr
argument_list|,
name|p
operator|-
operator|*
name|argptr
argument_list|)
expr_stmt|;
name|copy
index|[
name|p
operator|-
operator|*
name|argptr
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|gdb_completer_quote_characters
argument_list|,
name|copy
index|[
name|p
operator|-
operator|*
name|argptr
operator|-
literal|1
index|]
argument_list|)
operator|!=
name|NULL
condition|)
name|copy
index|[
name|p
operator|-
operator|*
name|argptr
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* no line number may be specified */
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
operator|*
name|argptr
operator|=
name|p
expr_stmt|;
name|sym
operator|=
literal|0
expr_stmt|;
name|i1
operator|=
literal|0
expr_stmt|;
comment|/*  counter for the symbol array */
name|t
operator|=
name|SYMBOL_TYPE
argument_list|(
name|sym_class
argument_list|)
expr_stmt|;
name|sym_arr
operator|=
operator|(
expr|struct
name|symbol
operator|*
operator|*
operator|)
name|alloca
argument_list|(
name|TYPE_NFN_FIELDS_TOTAL
argument_list|(
name|t
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Cfront objects don't have fieldlists.  */
if|if
condition|(
name|destructor_name_p
argument_list|(
name|copy
argument_list|,
name|t
argument_list|)
operator|&&
name|TYPE_FN_FIELDLISTS
argument_list|(
name|t
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* destructors are a special case.  */
name|struct
name|fn_field
modifier|*
name|f
init|=
name|TYPE_FN_FIELDLIST1
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|TYPE_FN_FIELDLIST_LENGTH
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
decl_stmt|;
comment|/* gcc 1.x puts destructor in last field, 		     gcc 2.x puts destructor in first field.  */
name|char
modifier|*
name|phys_name
init|=
name|TYPE_FN_FIELD_PHYSNAME
argument_list|(
name|f
argument_list|,
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|DESTRUCTOR_PREFIX_P
argument_list|(
name|phys_name
argument_list|)
condition|)
block|{
name|phys_name
operator|=
name|TYPE_FN_FIELD_PHYSNAME
argument_list|(
name|f
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DESTRUCTOR_PREFIX_P
argument_list|(
name|phys_name
argument_list|)
condition|)
name|phys_name
operator|=
literal|""
expr_stmt|;
block|}
name|sym_arr
index|[
name|i1
index|]
operator|=
name|lookup_symbol
argument_list|(
name|phys_name
argument_list|,
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|sym_class
argument_list|)
argument_list|,
name|VAR_NAMESPACE
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym_arr
index|[
name|i1
index|]
condition|)
name|i1
operator|++
expr_stmt|;
block|}
else|else
name|i1
operator|=
name|find_methods
argument_list|(
name|t
argument_list|,
name|copy
argument_list|,
name|sym_arr
argument_list|)
expr_stmt|;
if|if
condition|(
name|i1
operator|==
literal|1
condition|)
block|{
comment|/* There is exactly one field with that name.  */
name|sym
operator|=
name|sym_arr
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|sym
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_BLOCK
condition|)
block|{
name|values
operator|.
name|sals
operator|=
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symtab_and_line
argument_list|)
argument_list|)
expr_stmt|;
name|values
operator|.
name|nelts
operator|=
literal|1
expr_stmt|;
name|values
operator|.
name|sals
index|[
literal|0
index|]
operator|=
name|find_function_start_sal
argument_list|(
name|sym
argument_list|,
name|funfirstline
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|values
operator|.
name|nelts
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|values
return|;
block|}
if|if
condition|(
name|i1
operator|>
literal|0
condition|)
block|{
comment|/* There is more than one field with that name 		     (overloaded).  Ask the user which one to use.  */
return|return
name|decode_line_2
argument_list|(
name|sym_arr
argument_list|,
name|i1
argument_list|,
name|funfirstline
argument_list|,
name|canonical
argument_list|)
return|;
block|}
else|else
block|{
name|char
modifier|*
name|tmp
decl_stmt|;
if|if
condition|(
name|OPNAME_PREFIX_P
argument_list|(
name|copy
argument_list|)
condition|)
block|{
name|tmp
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|copy
operator|+
literal|3
argument_list|)
operator|+
literal|9
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|tmp
argument_list|,
literal|"operator "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmp
argument_list|,
name|copy
operator|+
literal|3
argument_list|)
expr_stmt|;
block|}
else|else
name|tmp
operator|=
name|copy
expr_stmt|;
name|error_begin
argument_list|()
expr_stmt|;
if|if
condition|(
name|tmp
index|[
literal|0
index|]
operator|==
literal|'~'
condition|)
name|printf_filtered
argument_list|(
literal|"the class `%s' does not have destructor defined\n"
argument_list|,
name|SYMBOL_SOURCE_NAME
argument_list|(
name|sym_class
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|"the class %s does not have any method named %s\n"
argument_list|,
name|SYMBOL_SOURCE_NAME
argument_list|(
name|sym_class
argument_list|)
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|cplusplus_hint
argument_list|(
name|saved_arg
argument_list|)
expr_stmt|;
name|return_to_top_level
argument_list|(
name|RETURN_ERROR
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|error_begin
argument_list|()
expr_stmt|;
comment|/* The quotes are important if copy is empty.  */
name|printf_filtered
argument_list|(
literal|"can't find class, struct, or union named \"%s\"\n"
argument_list|,
name|copy
argument_list|)
expr_stmt|;
name|cplusplus_hint
argument_list|(
name|saved_arg
argument_list|)
expr_stmt|;
name|return_to_top_level
argument_list|(
name|RETURN_ERROR
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  end of C++  */
comment|/* Extract the file name.  */
name|p1
operator|=
name|p
expr_stmt|;
while|while
condition|(
name|p
operator|!=
operator|*
name|argptr
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
operator|--
name|p
expr_stmt|;
name|copy
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|p
operator|-
operator|*
name|argptr
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|copy
argument_list|,
operator|*
name|argptr
argument_list|,
name|p
operator|-
operator|*
name|argptr
argument_list|)
expr_stmt|;
name|copy
index|[
name|p
operator|-
operator|*
name|argptr
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Find that file's data.  */
name|s
operator|=
name|lookup_symtab
argument_list|(
name|copy
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|have_full_symbols
argument_list|()
operator|&&
operator|!
name|have_partial_symbols
argument_list|()
condition|)
name|error
argument_list|(
name|no_symtab_msg
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"No source file named %s."
argument_list|,
name|copy
argument_list|)
expr_stmt|;
block|}
comment|/* Discard the file name from the arg.  */
name|p
operator|=
name|p1
operator|+
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
operator|*
name|argptr
operator|=
name|p
expr_stmt|;
block|}
comment|/* S is specified file's symtab, or 0 if no file specified.      arg no longer contains the file name.  */
comment|/* Check whether arg is all digits (and sign) */
name|q
operator|=
operator|*
name|argptr
expr_stmt|;
if|if
condition|(
operator|*
name|q
operator|==
literal|'-'
operator|||
operator|*
name|q
operator|==
literal|'+'
condition|)
name|q
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|q
operator|>=
literal|'0'
operator|&&
operator|*
name|q
operator|<=
literal|'9'
condition|)
name|q
operator|++
expr_stmt|;
if|if
condition|(
name|q
operator|!=
operator|*
name|argptr
operator|&&
operator|(
operator|*
name|q
operator|==
literal|0
operator|||
operator|*
name|q
operator|==
literal|' '
operator|||
operator|*
name|q
operator|==
literal|'\t'
operator|||
operator|*
name|q
operator|==
literal|','
operator|)
condition|)
block|{
comment|/* We found a token consisting of all digits -- at least one digit.  */
enum|enum
name|sign
block|{
name|none
block|,
name|plus
block|,
name|minus
block|}
name|sign
init|=
name|none
enum|;
comment|/* We might need a canonical line spec if no file was specified.  */
name|int
name|need_canonical
init|=
operator|(
name|s
operator|==
literal|0
operator|)
condition|?
literal|1
else|:
literal|0
decl_stmt|;
comment|/* This is where we need to make sure that we have good defaults. 	 We must guarantee that this section of code is never executed 	 when we are called with just a function name, since 	 select_source_symtab calls us with such an argument  */
if|if
condition|(
name|s
operator|==
literal|0
operator|&&
name|default_symtab
operator|==
literal|0
condition|)
block|{
name|select_source_symtab
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|default_symtab
operator|=
name|current_source_symtab
expr_stmt|;
name|default_line
operator|=
name|current_source_line
expr_stmt|;
block|}
if|if
condition|(
operator|*
operator|*
name|argptr
operator|==
literal|'+'
condition|)
name|sign
operator|=
name|plus
operator|,
operator|(
operator|*
name|argptr
operator|)
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
operator|*
name|argptr
operator|==
literal|'-'
condition|)
name|sign
operator|=
name|minus
operator|,
operator|(
operator|*
name|argptr
operator|)
operator|++
expr_stmt|;
name|val
operator|.
name|line
operator|=
name|atoi
argument_list|(
operator|*
name|argptr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sign
condition|)
block|{
case|case
name|plus
case|:
if|if
condition|(
name|q
operator|==
operator|*
name|argptr
condition|)
name|val
operator|.
name|line
operator|=
literal|5
expr_stmt|;
if|if
condition|(
name|s
operator|==
literal|0
condition|)
name|val
operator|.
name|line
operator|=
name|default_line
operator|+
name|val
operator|.
name|line
expr_stmt|;
break|break;
case|case
name|minus
case|:
if|if
condition|(
name|q
operator|==
operator|*
name|argptr
condition|)
name|val
operator|.
name|line
operator|=
literal|15
expr_stmt|;
if|if
condition|(
name|s
operator|==
literal|0
condition|)
name|val
operator|.
name|line
operator|=
name|default_line
operator|-
name|val
operator|.
name|line
expr_stmt|;
else|else
name|val
operator|.
name|line
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|none
case|:
break|break;
comment|/* No need to adjust val.line.  */
block|}
while|while
condition|(
operator|*
name|q
operator|==
literal|' '
operator|||
operator|*
name|q
operator|==
literal|'\t'
condition|)
name|q
operator|++
expr_stmt|;
operator|*
name|argptr
operator|=
name|q
expr_stmt|;
if|if
condition|(
name|s
operator|==
literal|0
condition|)
name|s
operator|=
name|default_symtab
expr_stmt|;
name|val
operator|.
name|symtab
operator|=
name|s
expr_stmt|;
name|val
operator|.
name|pc
operator|=
literal|0
expr_stmt|;
name|values
operator|.
name|sals
operator|=
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symtab_and_line
argument_list|)
argument_list|)
expr_stmt|;
name|values
operator|.
name|sals
index|[
literal|0
index|]
operator|=
name|val
expr_stmt|;
name|values
operator|.
name|nelts
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|need_canonical
condition|)
name|build_canonical_line_spec
argument_list|(
name|values
operator|.
name|sals
argument_list|,
name|NULL
argument_list|,
name|canonical
argument_list|)
expr_stmt|;
return|return
name|values
return|;
block|}
comment|/* Arg token is not digits => try it as a variable name      Find the next token (everything up to end or next whitespace).  */
if|if
condition|(
name|is_quoted
condition|)
block|{
name|p
operator|=
name|skip_quoted
argument_list|(
operator|*
name|argptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\''
condition|)
name|error
argument_list|(
literal|"Unmatched single quote."
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|has_parens
condition|)
block|{
name|p
operator|=
name|pp
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|skip_quoted
argument_list|(
operator|*
name|argptr
argument_list|)
expr_stmt|;
block|}
name|copy
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|p
operator|-
operator|*
name|argptr
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|copy
argument_list|,
operator|*
name|argptr
argument_list|,
name|p
operator|-
operator|*
name|argptr
argument_list|)
expr_stmt|;
name|copy
index|[
name|p
operator|-
operator|*
name|argptr
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|p
operator|!=
operator|*
name|argptr
operator|&&
operator|(
name|copy
index|[
literal|0
index|]
operator|==
name|copy
index|[
name|p
operator|-
operator|*
name|argptr
operator|-
literal|1
index|]
operator|)
operator|&&
name|strchr
argument_list|(
name|gdb_completer_quote_characters
argument_list|,
name|copy
index|[
literal|0
index|]
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|copy
index|[
name|p
operator|-
operator|*
name|argptr
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|copy
operator|++
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
operator|*
name|argptr
operator|=
name|p
expr_stmt|;
comment|/* Look up that token as a variable.      If file specified, use that file's per-file block to start with.  */
name|sym
operator|=
name|lookup_symbol
argument_list|(
name|copy
argument_list|,
operator|(
name|s
condition|?
name|BLOCKVECTOR_BLOCK
argument_list|(
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
argument_list|,
name|STATIC_BLOCK
argument_list|)
else|:
name|get_selected_block
argument_list|()
operator|)
argument_list|,
name|VAR_NAMESPACE
argument_list|,
literal|0
argument_list|,
operator|&
name|sym_symtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_BLOCK
condition|)
block|{
comment|/* Arg is the name of a function */
name|values
operator|.
name|sals
operator|=
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symtab_and_line
argument_list|)
argument_list|)
expr_stmt|;
name|values
operator|.
name|sals
index|[
literal|0
index|]
operator|=
name|find_function_start_sal
argument_list|(
name|sym
argument_list|,
name|funfirstline
argument_list|)
expr_stmt|;
name|values
operator|.
name|nelts
operator|=
literal|1
expr_stmt|;
comment|/* Don't use the SYMBOL_LINE; if used at all it points to 	     the line containing the parameters or thereabouts, not 	     the first line of code.  */
comment|/* We might need a canonical line spec if it is a static 	     function.  */
if|if
condition|(
name|s
operator|==
literal|0
condition|)
block|{
name|struct
name|blockvector
modifier|*
name|bv
init|=
name|BLOCKVECTOR
argument_list|(
name|sym_symtab
argument_list|)
decl_stmt|;
name|struct
name|block
modifier|*
name|b
init|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|STATIC_BLOCK
argument_list|)
decl_stmt|;
if|if
condition|(
name|lookup_block_symbol
argument_list|(
name|b
argument_list|,
name|copy
argument_list|,
name|VAR_NAMESPACE
argument_list|)
operator|!=
name|NULL
condition|)
name|build_canonical_line_spec
argument_list|(
name|values
operator|.
name|sals
argument_list|,
name|copy
argument_list|,
name|canonical
argument_list|)
expr_stmt|;
block|}
return|return
name|values
return|;
block|}
elseif|else
if|if
condition|(
name|SYMBOL_LINE
argument_list|(
name|sym
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* We know its line number.  */
name|values
operator|.
name|sals
operator|=
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symtab_and_line
argument_list|)
argument_list|)
expr_stmt|;
name|values
operator|.
name|nelts
operator|=
literal|1
expr_stmt|;
name|memset
argument_list|(
operator|&
name|values
operator|.
name|sals
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|values
operator|.
name|sals
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|values
operator|.
name|sals
index|[
literal|0
index|]
operator|.
name|symtab
operator|=
name|sym_symtab
expr_stmt|;
name|values
operator|.
name|sals
index|[
literal|0
index|]
operator|.
name|line
operator|=
name|SYMBOL_LINE
argument_list|(
name|sym
argument_list|)
expr_stmt|;
return|return
name|values
return|;
block|}
else|else
comment|/* This can happen if it is compiled with a compiler which doesn't 	   put out line numbers for variables.  */
comment|/* FIXME: Shouldn't we just set .line and .symtab to zero and 	   return?  For example, "info line foo" could print the address.  */
name|error
argument_list|(
literal|"Line number not known for symbol \"%s\""
argument_list|,
name|copy
argument_list|)
expr_stmt|;
block|}
name|msymbol
operator|=
name|lookup_minimal_symbol
argument_list|(
name|copy
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|msymbol
operator|!=
name|NULL
condition|)
block|{
name|val
operator|.
name|symtab
operator|=
literal|0
expr_stmt|;
name|val
operator|.
name|line
operator|=
literal|0
expr_stmt|;
name|val
operator|.
name|pc
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|funfirstline
condition|)
block|{
name|val
operator|.
name|pc
operator|+=
name|FUNCTION_START_OFFSET
expr_stmt|;
name|SKIP_PROLOGUE
argument_list|(
name|val
operator|.
name|pc
argument_list|)
expr_stmt|;
block|}
name|values
operator|.
name|sals
operator|=
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symtab_and_line
argument_list|)
argument_list|)
expr_stmt|;
name|values
operator|.
name|sals
index|[
literal|0
index|]
operator|=
name|val
expr_stmt|;
name|values
operator|.
name|nelts
operator|=
literal|1
expr_stmt|;
return|return
name|values
return|;
block|}
if|if
condition|(
operator|!
name|have_full_symbols
argument_list|()
operator|&&
operator|!
name|have_partial_symbols
argument_list|()
operator|&&
operator|!
name|have_minimal_symbols
argument_list|()
condition|)
name|error
argument_list|(
name|no_symtab_msg
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Function \"%s\" not defined."
argument_list|,
name|copy
argument_list|)
expr_stmt|;
return|return
name|values
return|;
comment|/* for lint */
block|}
end_function

begin_function
name|struct
name|symtabs_and_lines
name|decode_line_spec
parameter_list|(
name|string
parameter_list|,
name|funfirstline
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|funfirstline
decl_stmt|;
block|{
name|struct
name|symtabs_and_lines
name|sals
decl_stmt|;
if|if
condition|(
name|string
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Empty line specification."
argument_list|)
expr_stmt|;
name|sals
operator|=
name|decode_line_1
argument_list|(
operator|&
name|string
argument_list|,
name|funfirstline
argument_list|,
name|current_source_symtab
argument_list|,
name|current_source_line
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|string
condition|)
name|error
argument_list|(
literal|"Junk at end of line specification: %s"
argument_list|,
name|string
argument_list|)
expr_stmt|;
return|return
name|sals
return|;
block|}
end_function

begin_comment
comment|/* Given a list of NELTS symbols in SYM_ARR, return a list of lines to    operate on (ask user if necessary).    If CANONICAL is non-NULL return a corresponding array of mangled names    as canonical line specs there.  */
end_comment

begin_function
specifier|static
name|struct
name|symtabs_and_lines
name|decode_line_2
parameter_list|(
name|sym_arr
parameter_list|,
name|nelts
parameter_list|,
name|funfirstline
parameter_list|,
name|canonical
parameter_list|)
name|struct
name|symbol
modifier|*
name|sym_arr
index|[]
decl_stmt|;
name|int
name|nelts
decl_stmt|;
name|int
name|funfirstline
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|canonical
decl_stmt|;
block|{
name|struct
name|symtabs_and_lines
name|values
decl_stmt|,
name|return_values
decl_stmt|;
name|char
modifier|*
name|args
decl_stmt|,
modifier|*
name|arg1
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|prompt
decl_stmt|;
name|char
modifier|*
name|symname
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|char
modifier|*
modifier|*
name|canonical_arr
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
name|values
operator|.
name|sals
operator|=
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
name|alloca
argument_list|(
name|nelts
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|symtab_and_line
argument_list|)
argument_list|)
expr_stmt|;
name|return_values
operator|.
name|sals
operator|=
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
name|xmalloc
argument_list|(
name|nelts
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|symtab_and_line
argument_list|)
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|return_values
operator|.
name|sals
argument_list|)
expr_stmt|;
if|if
condition|(
name|canonical
condition|)
block|{
name|canonical_arr
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|nelts
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|canonical_arr
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|canonical_arr
argument_list|,
literal|0
argument_list|,
name|nelts
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|canonical
operator|=
name|canonical_arr
expr_stmt|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"[0] cancel\n[1] all\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|nelts
condition|)
block|{
if|if
condition|(
name|sym_arr
index|[
name|i
index|]
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym_arr
index|[
name|i
index|]
argument_list|)
operator|==
name|LOC_BLOCK
condition|)
block|{
name|values
operator|.
name|sals
index|[
name|i
index|]
operator|=
name|find_function_start_sal
argument_list|(
name|sym_arr
index|[
name|i
index|]
argument_list|,
name|funfirstline
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"[%d] %s at %s:%d\n"
argument_list|,
operator|(
name|i
operator|+
literal|2
operator|)
argument_list|,
name|SYMBOL_SOURCE_NAME
argument_list|(
name|sym_arr
index|[
name|i
index|]
argument_list|)
argument_list|,
name|values
operator|.
name|sals
index|[
name|i
index|]
operator|.
name|symtab
operator|->
name|filename
argument_list|,
name|values
operator|.
name|sals
index|[
name|i
index|]
operator|.
name|line
argument_list|)
expr_stmt|;
block|}
else|else
name|printf_unfiltered
argument_list|(
literal|"?HERE\n"
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|prompt
operator|=
name|getenv
argument_list|(
literal|"PS2"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|prompt
operator|=
literal|">"
expr_stmt|;
block|}
name|printf_unfiltered
argument_list|(
literal|"%s "
argument_list|,
name|prompt
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
name|args
operator|=
name|command_line_input
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
literal|"overload-choice"
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|==
literal|0
operator|||
operator|*
name|args
operator|==
literal|0
condition|)
name|error_no_arg
argument_list|(
literal|"one or more choice numbers"
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|args
condition|)
block|{
name|int
name|num
decl_stmt|;
name|arg1
operator|=
name|args
expr_stmt|;
while|while
condition|(
operator|*
name|arg1
operator|>=
literal|'0'
operator|&&
operator|*
name|arg1
operator|<=
literal|'9'
condition|)
name|arg1
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|arg1
operator|&&
operator|*
name|arg1
operator|!=
literal|' '
operator|&&
operator|*
name|arg1
operator|!=
literal|'\t'
condition|)
name|error
argument_list|(
literal|"Arguments must be choice numbers."
argument_list|)
expr_stmt|;
name|num
operator|=
name|atoi
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|num
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"cancelled"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|num
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|canonical_arr
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nelts
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|canonical_arr
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
name|symname
operator|=
name|SYMBOL_NAME
argument_list|(
name|sym_arr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|canonical_arr
index|[
name|i
index|]
operator|=
name|savestring
argument_list|(
name|symname
argument_list|,
name|strlen
argument_list|(
name|symname
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|memcpy
argument_list|(
name|return_values
operator|.
name|sals
argument_list|,
name|values
operator|.
name|sals
argument_list|,
operator|(
name|nelts
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|symtab_and_line
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|return_values
operator|.
name|nelts
operator|=
name|nelts
expr_stmt|;
name|discard_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
name|return_values
return|;
block|}
if|if
condition|(
name|num
operator|>
name|nelts
operator|+
literal|2
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"No choice number %d.\n"
argument_list|,
name|num
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|num
operator|-=
literal|2
expr_stmt|;
if|if
condition|(
name|values
operator|.
name|sals
index|[
name|num
index|]
operator|.
name|pc
condition|)
block|{
if|if
condition|(
name|canonical_arr
condition|)
block|{
name|symname
operator|=
name|SYMBOL_NAME
argument_list|(
name|sym_arr
index|[
name|num
index|]
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|symname
argument_list|)
expr_stmt|;
name|canonical_arr
index|[
name|i
index|]
operator|=
name|savestring
argument_list|(
name|symname
argument_list|,
name|strlen
argument_list|(
name|symname
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|return_values
operator|.
name|sals
index|[
name|i
operator|++
index|]
operator|=
name|values
operator|.
name|sals
index|[
name|num
index|]
expr_stmt|;
name|values
operator|.
name|sals
index|[
name|num
index|]
operator|.
name|pc
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|printf_unfiltered
argument_list|(
literal|"duplicate request for %d ignored.\n"
argument_list|,
name|num
argument_list|)
expr_stmt|;
block|}
block|}
name|args
operator|=
name|arg1
expr_stmt|;
while|while
condition|(
operator|*
name|args
operator|==
literal|' '
operator|||
operator|*
name|args
operator|==
literal|'\t'
condition|)
name|args
operator|++
expr_stmt|;
block|}
name|return_values
operator|.
name|nelts
operator|=
name|i
expr_stmt|;
name|discard_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
name|return_values
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Slave routine for sources_info.  Force line breaks at ,'s.    NAME is the name to print and *FIRST is nonzero if this is the first    name printed.  Set *FIRST to zero.  */
end_comment

begin_function
specifier|static
name|void
name|output_source_filename
parameter_list|(
name|name
parameter_list|,
name|first
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
modifier|*
name|first
decl_stmt|;
block|{
comment|/* Table of files printed so far.  Since a single source file can      result in several partial symbol tables, we need to avoid printing      it more than once.  Note: if some of the psymtabs are read in and      some are not, it gets printed both under "Source files for which      symbols have been read" and "Source files for which symbols will      be read in on demand".  I consider this a reasonable way to deal      with the situation.  I'm not sure whether this can also happen for      symtabs; it doesn't hurt to check.  */
specifier|static
name|char
modifier|*
modifier|*
name|tab
init|=
name|NULL
decl_stmt|;
comment|/* Allocated size of tab in elements.      Start with one 256-byte block (when using GNU malloc.c).      24 is the malloc overhead when range checking is in effect.  */
specifier|static
name|int
name|tab_alloc_size
init|=
operator|(
literal|256
operator|-
literal|24
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
decl_stmt|;
comment|/* Current size of tab in elements.  */
specifier|static
name|int
name|tab_cur_size
decl_stmt|;
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|*
name|first
condition|)
block|{
if|if
condition|(
name|tab
operator|==
name|NULL
condition|)
name|tab
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|tab_alloc_size
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|tab
argument_list|)
argument_list|)
expr_stmt|;
name|tab_cur_size
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Is NAME in tab?  */
for|for
control|(
name|p
operator|=
name|tab
init|;
name|p
operator|<
name|tab
operator|+
name|tab_cur_size
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|STREQ
argument_list|(
operator|*
name|p
argument_list|,
name|name
argument_list|)
condition|)
comment|/* Yes; don't print it again.  */
return|return;
comment|/* No; add it to tab.  */
if|if
condition|(
name|tab_cur_size
operator|==
name|tab_alloc_size
condition|)
block|{
name|tab_alloc_size
operator|*=
literal|2
expr_stmt|;
name|tab
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tab
argument_list|,
name|tab_alloc_size
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|tab
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|tab
index|[
name|tab_cur_size
operator|++
index|]
operator|=
name|name
expr_stmt|;
if|if
condition|(
operator|*
name|first
condition|)
block|{
operator|*
name|first
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|printf_filtered
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|name
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sources_info
parameter_list|(
name|ignore
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|ignore
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|register
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
specifier|register
name|struct
name|partial_symtab
modifier|*
name|ps
decl_stmt|;
specifier|register
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|int
name|first
decl_stmt|;
if|if
condition|(
operator|!
name|have_full_symbols
argument_list|()
operator|&&
operator|!
name|have_partial_symbols
argument_list|()
condition|)
block|{
name|error
argument_list|(
name|no_symtab_msg
argument_list|)
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"Source files for which symbols have been read in:\n\n"
argument_list|)
expr_stmt|;
name|first
operator|=
literal|1
expr_stmt|;
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
name|output_source_filename
argument_list|(
name|s
operator|->
name|filename
argument_list|,
operator|&
name|first
argument_list|)
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Source files for which symbols will be read in on demand:\n\n"
argument_list|)
expr_stmt|;
name|first
operator|=
literal|1
expr_stmt|;
name|ALL_PSYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|ps
argument_list|)
block|{
if|if
condition|(
operator|!
name|ps
operator|->
name|readin
condition|)
block|{
name|output_source_filename
argument_list|(
name|ps
operator|->
name|filename
argument_list|,
operator|&
name|first
argument_list|)
expr_stmt|;
block|}
block|}
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* List all symbols (if REGEXP is NULL) or all symbols matching REGEXP.    If CLASS is zero, list all symbols except functions, type names, and 		     constants (enums).    If CLASS is 1, list only functions.    If CLASS is 2, list only type names.    If CLASS is 3, list only method names.     BPT is non-zero if we should set a breakpoint at the functions    we find.  */
end_comment

begin_function
specifier|static
name|void
name|list_symbols
parameter_list|(
name|regexp
parameter_list|,
name|class
parameter_list|,
name|bpt
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|regexp
decl_stmt|;
name|int
name|class
decl_stmt|;
name|int
name|bpt
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|register
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
specifier|register
name|struct
name|partial_symtab
modifier|*
name|ps
decl_stmt|;
specifier|register
name|struct
name|blockvector
modifier|*
name|bv
decl_stmt|;
name|struct
name|blockvector
modifier|*
name|prev_bv
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|block
modifier|*
name|b
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|struct
name|partial_symbol
modifier|*
name|psym
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
specifier|static
name|char
modifier|*
name|classnames
index|[]
init|=
block|{
literal|"variable"
block|,
literal|"function"
block|,
literal|"type"
block|,
literal|"method"
block|}
decl_stmt|;
name|int
name|found_in_file
init|=
literal|0
decl_stmt|;
name|int
name|found_misc
init|=
literal|0
decl_stmt|;
specifier|static
name|enum
name|minimal_symbol_type
name|types
index|[]
init|=
block|{
name|mst_data
block|,
name|mst_text
block|,
name|mst_abs
block|,
name|mst_unknown
block|}
decl_stmt|;
specifier|static
name|enum
name|minimal_symbol_type
name|types2
index|[]
init|=
block|{
name|mst_bss
block|,
name|mst_file_text
block|,
name|mst_abs
block|,
name|mst_unknown
block|}
decl_stmt|;
specifier|static
name|enum
name|minimal_symbol_type
name|types3
index|[]
init|=
block|{
name|mst_file_data
block|,
name|mst_solib_trampoline
block|,
name|mst_abs
block|,
name|mst_unknown
block|}
decl_stmt|;
specifier|static
name|enum
name|minimal_symbol_type
name|types4
index|[]
init|=
block|{
name|mst_file_bss
block|,
name|mst_text
block|,
name|mst_abs
block|,
name|mst_unknown
block|}
decl_stmt|;
name|enum
name|minimal_symbol_type
name|ourtype
init|=
name|types
index|[
name|class
index|]
decl_stmt|;
name|enum
name|minimal_symbol_type
name|ourtype2
init|=
name|types2
index|[
name|class
index|]
decl_stmt|;
name|enum
name|minimal_symbol_type
name|ourtype3
init|=
name|types3
index|[
name|class
index|]
decl_stmt|;
name|enum
name|minimal_symbol_type
name|ourtype4
init|=
name|types4
index|[
name|class
index|]
decl_stmt|;
if|if
condition|(
name|regexp
operator|!=
name|NULL
condition|)
block|{
comment|/* Make sure spacing is right for C++ operators. 	 This is just a courtesy to make the matching less sensitive 	 to how many spaces the user leaves between 'operator' 	 and<TYPENAME> or<OPERATOR>. */
name|char
modifier|*
name|opend
decl_stmt|;
name|char
modifier|*
name|opname
init|=
name|operator_chars
argument_list|(
name|regexp
argument_list|,
operator|&
name|opend
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|opname
condition|)
block|{
name|int
name|fix
init|=
operator|-
literal|1
decl_stmt|;
comment|/* -1 means ok; otherwise number of spaces needed. */
if|if
condition|(
name|isalpha
argument_list|(
operator|*
name|opname
argument_list|)
operator|||
operator|*
name|opname
operator|==
literal|'_'
operator|||
operator|*
name|opname
operator|==
literal|'$'
condition|)
block|{
comment|/* There should 1 space between 'operator' and 'TYPENAME'. */
if|if
condition|(
name|opname
index|[
operator|-
literal|1
index|]
operator|!=
literal|' '
operator|||
name|opname
index|[
operator|-
literal|2
index|]
operator|==
literal|' '
condition|)
name|fix
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* There should 0 spaces between 'operator' and 'OPERATOR'. */
if|if
condition|(
name|opname
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
name|fix
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If wrong number of spaces, fix it. */
if|if
condition|(
name|fix
operator|>=
literal|0
condition|)
block|{
name|char
modifier|*
name|tmp
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|opend
operator|-
name|opname
operator|+
literal|10
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"operator%.*s%s"
argument_list|,
name|fix
argument_list|,
literal|" "
argument_list|,
name|opname
argument_list|)
expr_stmt|;
name|regexp
operator|=
name|tmp
expr_stmt|;
block|}
block|}
if|if
condition|(
literal|0
operator|!=
operator|(
name|val
operator|=
name|re_comp
argument_list|(
name|regexp
argument_list|)
operator|)
condition|)
name|error
argument_list|(
literal|"Invalid regexp (%s): %s"
argument_list|,
name|val
argument_list|,
name|regexp
argument_list|)
expr_stmt|;
block|}
comment|/* Search through the partial symtabs *first* for all symbols      matching the regexp.  That way we don't have to reproduce all of      the machinery below. */
name|ALL_PSYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|ps
argument_list|)
block|{
name|struct
name|partial_symbol
modifier|*
name|bound
decl_stmt|,
modifier|*
name|gbound
decl_stmt|,
modifier|*
name|sbound
decl_stmt|;
name|int
name|keep_going
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|ps
operator|->
name|readin
condition|)
continue|continue;
name|gbound
operator|=
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
operator|+
name|ps
operator|->
name|globals_offset
operator|+
name|ps
operator|->
name|n_global_syms
expr_stmt|;
name|sbound
operator|=
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
operator|+
name|ps
operator|->
name|statics_offset
operator|+
name|ps
operator|->
name|n_static_syms
expr_stmt|;
name|bound
operator|=
name|gbound
expr_stmt|;
comment|/* Go through all of the symbols stored in a partial 	 symtab in one loop. */
name|psym
operator|=
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
operator|+
name|ps
operator|->
name|globals_offset
expr_stmt|;
while|while
condition|(
name|keep_going
condition|)
block|{
if|if
condition|(
name|psym
operator|>=
name|bound
condition|)
block|{
if|if
condition|(
name|bound
operator|==
name|gbound
operator|&&
name|ps
operator|->
name|n_static_syms
operator|!=
literal|0
condition|)
block|{
name|psym
operator|=
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
operator|+
name|ps
operator|->
name|statics_offset
expr_stmt|;
name|bound
operator|=
name|sbound
expr_stmt|;
block|}
else|else
name|keep_going
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|QUIT
expr_stmt|;
comment|/* If it would match (logic taken from loop below) 		 load the file and go on to the next one */
if|if
condition|(
operator|(
name|regexp
operator|==
name|NULL
operator|||
name|SYMBOL_MATCHES_REGEXP
argument_list|(
name|psym
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|class
operator|==
literal|0
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|psym
argument_list|)
operator|!=
name|LOC_TYPEDEF
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|psym
argument_list|)
operator|!=
name|LOC_BLOCK
operator|)
operator|||
operator|(
name|class
operator|==
literal|1
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|psym
argument_list|)
operator|==
name|LOC_BLOCK
operator|)
operator|||
operator|(
name|class
operator|==
literal|2
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|psym
argument_list|)
operator|==
name|LOC_TYPEDEF
operator|)
operator|||
operator|(
name|class
operator|==
literal|3
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|psym
argument_list|)
operator|==
name|LOC_BLOCK
operator|)
operator|)
condition|)
block|{
name|PSYMTAB_TO_SYMTAB
argument_list|(
name|ps
argument_list|)
expr_stmt|;
name|keep_going
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|psym
operator|++
expr_stmt|;
block|}
block|}
comment|/* Here, we search through the minimal symbol tables for functions that      match, and call find_pc_symtab on them to force their symbols to      be read.  The symbol will then be found during the scan of symtabs      below.  If find_pc_symtab fails, set found_misc so that we will      rescan to print any matching symbols without debug info.  */
if|if
condition|(
name|class
operator|==
literal|1
condition|)
block|{
name|ALL_MSYMBOLS
argument_list|(
argument|objfile
argument_list|,
argument|msymbol
argument_list|)
block|{
if|if
condition|(
name|MSYMBOL_TYPE
argument_list|(
name|msymbol
argument_list|)
operator|==
name|ourtype
operator|||
name|MSYMBOL_TYPE
argument_list|(
name|msymbol
argument_list|)
operator|==
name|ourtype2
operator|||
name|MSYMBOL_TYPE
argument_list|(
name|msymbol
argument_list|)
operator|==
name|ourtype3
operator|||
name|MSYMBOL_TYPE
argument_list|(
name|msymbol
argument_list|)
operator|==
name|ourtype4
condition|)
block|{
if|if
condition|(
name|regexp
operator|==
name|NULL
operator|||
name|SYMBOL_MATCHES_REGEXP
argument_list|(
name|msymbol
argument_list|)
condition|)
block|{
if|if
condition|(
literal|0
operator|==
name|find_pc_symtab
argument_list|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
argument_list|)
condition|)
block|{
name|found_misc
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/* Printout here so as to get after the "Reading in symbols"      messages which will be generated above.  */
if|if
condition|(
operator|!
name|bpt
condition|)
name|printf_filtered
argument_list|(
name|regexp
condition|?
literal|"All %ss matching regular expression \"%s\":\n"
else|:
literal|"All defined %ss:\n"
argument_list|,
name|classnames
index|[
name|class
index|]
argument_list|,
name|regexp
argument_list|)
expr_stmt|;
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
name|found_in_file
operator|=
literal|0
expr_stmt|;
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Often many files share a blockvector. 	 Scan each blockvector only once so that 	 we don't get every symbol many times. 	 It happens that the first symtab in the list 	 for any given blockvector is the main file.  */
if|if
condition|(
name|bv
operator|!=
name|prev_bv
condition|)
for|for
control|(
name|i
operator|=
name|GLOBAL_BLOCK
init|;
name|i
operator|<=
name|STATIC_BLOCK
condition|;
name|i
operator|++
control|)
block|{
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Skip the sort if this block is always sorted.  */
if|if
condition|(
operator|!
name|BLOCK_SHOULD_SORT
argument_list|(
name|b
argument_list|)
condition|)
name|sort_block_syms
argument_list|(
name|b
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|BLOCK_NSYMS
argument_list|(
name|b
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
name|sym
operator|=
name|BLOCK_SYM
argument_list|(
name|b
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|regexp
operator|==
name|NULL
operator|||
name|SYMBOL_MATCHES_REGEXP
argument_list|(
name|sym
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|class
operator|==
literal|0
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|!=
name|LOC_TYPEDEF
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|!=
name|LOC_BLOCK
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|!=
name|LOC_CONST
operator|)
operator|||
operator|(
name|class
operator|==
literal|1
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_BLOCK
operator|)
operator|||
operator|(
name|class
operator|==
literal|2
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_TYPEDEF
operator|)
operator|||
operator|(
name|class
operator|==
literal|3
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_BLOCK
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|bpt
condition|)
block|{
comment|/* Set a breakpoint here, if it's a function */
if|if
condition|(
name|class
operator|==
literal|1
condition|)
block|{
comment|/* There may be more than one function with the 			       same name but in different files.  In order to 			       set breakpoints on all of them, we must give 			       both the file name and the function name to 			       break_command. 			       Quoting the symbol name gets rid of problems 			       with mangled symbol names that contain 			       CPLUS_MARKER characters.  */
name|char
modifier|*
name|string
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|s
operator|->
name|filename
argument_list|)
operator|+
name|strlen
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|+
literal|4
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|string
argument_list|,
name|s
operator|->
name|filename
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|string
argument_list|,
literal|":'"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|string
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|string
argument_list|,
literal|"'"
argument_list|)
expr_stmt|;
name|break_command
argument_list|(
name|string
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|found_in_file
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|"\nFile "
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|s
operator|->
name|filename
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|":\n"
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
name|found_in_file
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|class
operator|!=
literal|2
operator|&&
name|i
operator|==
name|STATIC_BLOCK
condition|)
name|printf_filtered
argument_list|(
literal|"static "
argument_list|)
expr_stmt|;
comment|/* Typedef that is not a C++ class */
if|if
condition|(
name|class
operator|==
literal|2
operator|&&
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|!=
name|STRUCT_NAMESPACE
condition|)
name|c_typedef_print
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|,
name|sym
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
comment|/* variable, func, or typedef-that-is-c++-class */
elseif|else
if|if
condition|(
name|class
operator|<
literal|2
operator|||
operator|(
name|class
operator|==
literal|2
operator|&&
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|==
name|STRUCT_NAMESPACE
operator|)
condition|)
block|{
name|type_print
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|,
operator|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_TYPEDEF
condition|?
literal|""
else|:
name|SYMBOL_SOURCE_NAME
argument_list|(
name|sym
argument_list|)
operator|)
argument_list|,
name|gdb_stdout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|";\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
literal|0
comment|/* FIXME, why is this zapped out? */
block|char buf[1024]; 			c_type_print_base (TYPE_FN_FIELD_TYPE(t, i), 					   gdb_stdout, 0, 0);  			c_type_print_varspec_prefix (TYPE_FN_FIELD_TYPE(t, i), 						     gdb_stdout, 0);  			sprintf (buf, " %s::", type_name_no_tag (t)); 			cp_type_print_method_args (TYPE_FN_FIELD_ARGS (t, i), 						   buf, name, gdb_stdout);
endif|#
directive|endif
block|}
block|}
block|}
block|}
name|prev_bv
operator|=
name|bv
expr_stmt|;
block|}
comment|/* If there are no eyes, avoid all contact.  I mean, if there are      no debug symbols, then print directly from the msymbol_vector.  */
if|if
condition|(
name|found_misc
operator|||
name|class
operator|!=
literal|1
condition|)
block|{
name|found_in_file
operator|=
literal|0
expr_stmt|;
name|ALL_MSYMBOLS
argument_list|(
argument|objfile
argument_list|,
argument|msymbol
argument_list|)
block|{
if|if
condition|(
name|MSYMBOL_TYPE
argument_list|(
name|msymbol
argument_list|)
operator|==
name|ourtype
operator|||
name|MSYMBOL_TYPE
argument_list|(
name|msymbol
argument_list|)
operator|==
name|ourtype2
operator|||
name|MSYMBOL_TYPE
argument_list|(
name|msymbol
argument_list|)
operator|==
name|ourtype3
operator|||
name|MSYMBOL_TYPE
argument_list|(
name|msymbol
argument_list|)
operator|==
name|ourtype4
condition|)
block|{
if|if
condition|(
name|regexp
operator|==
name|NULL
operator|||
name|SYMBOL_MATCHES_REGEXP
argument_list|(
name|msymbol
argument_list|)
condition|)
block|{
comment|/* Functions:  Look up by address. */
if|if
condition|(
name|class
operator|!=
literal|1
operator|||
operator|(
literal|0
operator|==
name|find_pc_symtab
argument_list|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
argument_list|)
operator|)
condition|)
block|{
comment|/* Variables/Absolutes:  Look up by name */
if|if
condition|(
name|lookup_symbol
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|msymbol
argument_list|)
argument_list|,
operator|(
expr|struct
name|block
operator|*
operator|)
name|NULL
argument_list|,
name|VAR_NAMESPACE
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|*
operator|)
name|NULL
argument_list|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|found_in_file
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"\nNon-debugging symbols:\n"
argument_list|)
expr_stmt|;
name|found_in_file
operator|=
literal|1
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"	%08lx  %s\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
argument_list|,
name|SYMBOL_SOURCE_NAME
argument_list|(
name|msymbol
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|variables_info
parameter_list|(
name|regexp
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|regexp
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|list_symbols
argument_list|(
name|regexp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|functions_info
parameter_list|(
name|regexp
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|regexp
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|list_symbols
argument_list|(
name|regexp
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|types_info
parameter_list|(
name|regexp
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|regexp
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|list_symbols
argument_list|(
name|regexp
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Tiemann says: "info methods was never implemented."  */
end_comment

begin_endif
unit|static void methods_info (regexp)      char *regexp; {   list_symbols (regexp, 3, 0, from_tty); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_comment
comment|/* Breakpoint all functions matching regular expression. */
end_comment

begin_function
specifier|static
name|void
name|rbreak_command
parameter_list|(
name|regexp
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|regexp
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|list_symbols
argument_list|(
name|regexp
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return Nonzero if block a is lexically nested within block b,    or if a and b have the same pc range.    Return zero otherwise. */
end_comment

begin_function
name|int
name|contained_in
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|struct
name|block
modifier|*
name|a
decl_stmt|,
decl|*
name|b
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
operator|!
name|a
operator|||
operator|!
name|b
condition|)
return|return
literal|0
return|;
return|return
name|BLOCK_START
argument_list|(
name|a
argument_list|)
operator|>=
name|BLOCK_START
argument_list|(
name|b
argument_list|)
operator|&&
name|BLOCK_END
argument_list|(
name|a
argument_list|)
operator|<=
name|BLOCK_END
argument_list|(
name|b
argument_list|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Helper routine for make_symbol_completion_list.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|return_val_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|return_val_index
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|return_val
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|COMPLETION_LIST_ADD_SYMBOL
parameter_list|(
name|symbol
parameter_list|,
name|sym_text
parameter_list|,
name|len
parameter_list|,
name|text
parameter_list|,
name|word
parameter_list|)
define|\
value|do { \     if (SYMBOL_DEMANGLED_NAME (symbol) != NULL) \
comment|/* Put only the mangled name on the list.  */
value|\
comment|/* Advantage:  "b foo<TAB>" completes to "b foo(int, int)" */
value|\
comment|/* Disadvantage:  "b foo__i<TAB>" doesn't complete.  */
value|\       completion_list_add_name \ 	(SYMBOL_DEMANGLED_NAME (symbol), (sym_text), (len), (text), (word)); \     else \       completion_list_add_name \ 	(SYMBOL_NAME (symbol), (sym_text), (len), (text), (word)); \   } while (0)
end_define

begin_comment
comment|/*  Test to see if the symbol specified by SYMNAME (which is already     demangled for C++ symbols) matches SYM_TEXT in the first SYM_TEXT_LEN     characters.  If so, add it to the current completion list. */
end_comment

begin_function
specifier|static
name|void
name|completion_list_add_name
parameter_list|(
name|symname
parameter_list|,
name|sym_text
parameter_list|,
name|sym_text_len
parameter_list|,
name|text
parameter_list|,
name|word
parameter_list|)
name|char
modifier|*
name|symname
decl_stmt|;
name|char
modifier|*
name|sym_text
decl_stmt|;
name|int
name|sym_text_len
decl_stmt|;
name|char
modifier|*
name|text
decl_stmt|;
name|char
modifier|*
name|word
decl_stmt|;
block|{
name|int
name|newsize
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* clip symbols that cannot match */
if|if
condition|(
name|strncmp
argument_list|(
name|symname
argument_list|,
name|sym_text
argument_list|,
name|sym_text_len
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return;
block|}
comment|/* Clip any symbol names that we've already considered.  (This is a      time optimization)  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|return_val_index
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|STREQ
argument_list|(
name|symname
argument_list|,
name|return_val
index|[
name|i
index|]
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
comment|/* We have a match for a completion, so add SYMNAME to the current list      of matches. Note that the name is moved to freshly malloc'd space. */
block|{
name|char
modifier|*
name|new
decl_stmt|;
if|if
condition|(
name|word
operator|==
name|sym_text
condition|)
block|{
name|new
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|symname
argument_list|)
operator|+
literal|5
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|new
argument_list|,
name|symname
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|word
operator|>
name|sym_text
condition|)
block|{
comment|/* Return some portion of symname.  */
name|new
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|symname
argument_list|)
operator|+
literal|5
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|new
argument_list|,
name|symname
operator|+
operator|(
name|word
operator|-
name|sym_text
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Return some of SYM_TEXT plus symname.  */
name|new
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|symname
argument_list|)
operator|+
operator|(
name|sym_text
operator|-
name|word
operator|)
operator|+
literal|5
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|new
argument_list|,
name|word
argument_list|,
name|sym_text
operator|-
name|word
argument_list|)
expr_stmt|;
name|new
index|[
name|sym_text
operator|-
name|word
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strcat
argument_list|(
name|new
argument_list|,
name|symname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|return_val_index
operator|+
literal|3
operator|>
name|return_val_size
condition|)
block|{
name|newsize
operator|=
operator|(
name|return_val_size
operator|*=
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
expr_stmt|;
name|return_val
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|return_val
argument_list|,
name|newsize
argument_list|)
expr_stmt|;
block|}
name|return_val
index|[
name|return_val_index
operator|++
index|]
operator|=
name|new
expr_stmt|;
name|return_val
index|[
name|return_val_index
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return a NULL terminated array of all symbols (regardless of class) which    begin by matching TEXT.  If the answer is no symbols, then the return value    is an array which contains only a NULL pointer.     Problem: All of the symbols have to be copied because readline frees them.    I'm not going to worry about this; hopefully there won't be that many.  */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|make_symbol_completion_list
parameter_list|(
name|text
parameter_list|,
name|word
parameter_list|)
name|char
modifier|*
name|text
decl_stmt|;
name|char
modifier|*
name|word
decl_stmt|;
block|{
specifier|register
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
specifier|register
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
specifier|register
name|struct
name|partial_symtab
modifier|*
name|ps
decl_stmt|;
specifier|register
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
specifier|register
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
specifier|register
name|struct
name|block
modifier|*
name|b
decl_stmt|,
modifier|*
name|surrounding_static_block
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|partial_symbol
modifier|*
name|psym
decl_stmt|;
comment|/* The symbol we are completing on.  Points in same buffer as text.  */
name|char
modifier|*
name|sym_text
decl_stmt|;
comment|/* Length of sym_text.  */
name|int
name|sym_text_len
decl_stmt|;
comment|/* Now look for the symbol we are supposed to complete on.      FIXME: This should be language-specific.  */
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|quote_found
decl_stmt|;
name|char
modifier|*
name|quote_pos
init|=
name|NULL
decl_stmt|;
comment|/* First see if this is a quoted string.  */
name|quote_found
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|p
operator|=
name|text
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
operator|++
name|p
control|)
block|{
if|if
condition|(
name|quote_found
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
name|quote_found
condition|)
comment|/* Found close quote.  */
name|quote_found
operator|=
literal|'\0'
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
name|quote_found
condition|)
comment|/* A backslash followed by the quote character 		 doesn't end the string.  */
operator|++
name|p
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'\''
operator|||
operator|*
name|p
operator|==
literal|'"'
condition|)
block|{
name|quote_found
operator|=
operator|*
name|p
expr_stmt|;
name|quote_pos
operator|=
name|p
expr_stmt|;
block|}
block|}
if|if
condition|(
name|quote_found
operator|==
literal|'\''
condition|)
comment|/* A string within single quotes can be a symbol, so complete on it.  */
name|sym_text
operator|=
name|quote_pos
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|quote_found
operator|==
literal|'"'
condition|)
comment|/* A double-quoted string is never a symbol, nor does it make sense 	 to complete it any other way.  */
return|return
name|NULL
return|;
else|else
block|{
comment|/* It is not a quoted string.  Break it based on the characters 	   which are in symbols.  */
while|while
condition|(
name|p
operator|>
name|text
condition|)
block|{
if|if
condition|(
name|isalnum
argument_list|(
name|p
index|[
operator|-
literal|1
index|]
argument_list|)
operator|||
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'_'
operator|||
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'\0'
condition|)
operator|--
name|p
expr_stmt|;
else|else
break|break;
block|}
name|sym_text
operator|=
name|p
expr_stmt|;
block|}
block|}
name|sym_text_len
operator|=
name|strlen
argument_list|(
name|sym_text
argument_list|)
expr_stmt|;
name|return_val_size
operator|=
literal|100
expr_stmt|;
name|return_val_index
operator|=
literal|0
expr_stmt|;
name|return_val
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|return_val_size
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|return_val
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* Look through the partial symtabs for all symbols which begin      by matching SYM_TEXT.  Add each one that you find to the list.  */
name|ALL_PSYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|ps
argument_list|)
block|{
comment|/* If the psymtab's been read in we'll get it when we search 	 through the blockvector.  */
if|if
condition|(
name|ps
operator|->
name|readin
condition|)
continue|continue;
for|for
control|(
name|psym
operator|=
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
operator|+
name|ps
operator|->
name|globals_offset
init|;
name|psym
operator|<
operator|(
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
operator|+
name|ps
operator|->
name|globals_offset
operator|+
name|ps
operator|->
name|n_global_syms
operator|)
condition|;
name|psym
operator|++
control|)
block|{
comment|/* If interrupted, then quit. */
name|QUIT
expr_stmt|;
name|COMPLETION_LIST_ADD_SYMBOL
argument_list|(
name|psym
argument_list|,
name|sym_text
argument_list|,
name|sym_text_len
argument_list|,
name|text
argument_list|,
name|word
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|psym
operator|=
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
operator|+
name|ps
operator|->
name|statics_offset
init|;
name|psym
operator|<
operator|(
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
operator|+
name|ps
operator|->
name|statics_offset
operator|+
name|ps
operator|->
name|n_static_syms
operator|)
condition|;
name|psym
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
name|COMPLETION_LIST_ADD_SYMBOL
argument_list|(
name|psym
argument_list|,
name|sym_text
argument_list|,
name|sym_text_len
argument_list|,
name|text
argument_list|,
name|word
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* At this point scan through the misc symbol vectors and add each      symbol you find to the list.  Eventually we want to ignore      anything that isn't a text symbol (everything else will be      handled by the psymtab code above).  */
name|ALL_MSYMBOLS
argument_list|(
argument|objfile
argument_list|,
argument|msymbol
argument_list|)
block|{
name|QUIT
expr_stmt|;
name|COMPLETION_LIST_ADD_SYMBOL
argument_list|(
name|msymbol
argument_list|,
name|sym_text
argument_list|,
name|sym_text_len
argument_list|,
name|text
argument_list|,
name|word
argument_list|)
expr_stmt|;
block|}
comment|/* Search upwards from currently selected frame (so that we can      complete on local vars.  */
for|for
control|(
name|b
operator|=
name|get_selected_block
argument_list|()
init|;
name|b
operator|!=
name|NULL
condition|;
name|b
operator|=
name|BLOCK_SUPERBLOCK
argument_list|(
name|b
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|BLOCK_SUPERBLOCK
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|surrounding_static_block
operator|=
name|b
expr_stmt|;
comment|/* For elmin of dups */
block|}
comment|/* Also catch fields of types defined in this places which match our 	 text string.  Only complete on types visible from current context. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BLOCK_NSYMS
argument_list|(
name|b
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|sym
operator|=
name|BLOCK_SYM
argument_list|(
name|b
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|COMPLETION_LIST_ADD_SYMBOL
argument_list|(
name|sym
argument_list|,
name|sym_text
argument_list|,
name|sym_text_len
argument_list|,
name|text
argument_list|,
name|word
argument_list|)
expr_stmt|;
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_TYPEDEF
condition|)
block|{
name|struct
name|type
modifier|*
name|t
init|=
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
decl_stmt|;
name|enum
name|type_code
name|c
init|=
name|TYPE_CODE
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|TYPE_CODE_UNION
operator|||
name|c
operator|==
name|TYPE_CODE_STRUCT
condition|)
block|{
for|for
control|(
name|j
operator|=
name|TYPE_N_BASECLASSES
argument_list|(
name|t
argument_list|)
init|;
name|j
operator|<
name|TYPE_NFIELDS
argument_list|(
name|t
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|TYPE_FIELD_NAME
argument_list|(
name|t
argument_list|,
name|j
argument_list|)
condition|)
block|{
name|completion_list_add_name
argument_list|(
name|TYPE_FIELD_NAME
argument_list|(
name|t
argument_list|,
name|j
argument_list|)
argument_list|,
name|sym_text
argument_list|,
name|sym_text_len
argument_list|,
name|text
argument_list|,
name|word
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
comment|/* Go through the symtabs and check the externs and statics for      symbols which match.  */
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
name|QUIT
expr_stmt|;
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BLOCK_NSYMS
argument_list|(
name|b
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|sym
operator|=
name|BLOCK_SYM
argument_list|(
name|b
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|COMPLETION_LIST_ADD_SYMBOL
argument_list|(
name|sym
argument_list|,
name|sym_text
argument_list|,
name|sym_text_len
argument_list|,
name|text
argument_list|,
name|word
argument_list|)
expr_stmt|;
block|}
block|}
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
name|QUIT
expr_stmt|;
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
argument_list|,
name|STATIC_BLOCK
argument_list|)
expr_stmt|;
comment|/* Don't do this block twice.  */
if|if
condition|(
name|b
operator|==
name|surrounding_static_block
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BLOCK_NSYMS
argument_list|(
name|b
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|sym
operator|=
name|BLOCK_SYM
argument_list|(
name|b
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|COMPLETION_LIST_ADD_SYMBOL
argument_list|(
name|sym
argument_list|,
name|sym_text
argument_list|,
name|sym_text_len
argument_list|,
name|text
argument_list|,
name|word
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|return_val
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Add the type of the symbol sym to the type of the current    function whose block we are in (assumed).  The type of    this current function is contained in *TYPE.        This basically works as follows:  When we find a function    symbol (N_FUNC with a 'f' or 'F' in the symbol name), we record    a pointer to its type in the global in_function_type.  Every     time we come across a parameter symbol ('p' in its name), then    this procedure adds the name and type of that parameter    to the function type pointed to by *TYPE.  (Which should correspond    to in_function_type if it was called correctly).     Note that since we are modifying a type, the result of     lookup_function_type() should be memcpy()ed before calling    this.  When not in strict typing mode, the expression    evaluator can choose to ignore this.     Assumption:  All of a function's parameter symbols will    appear before another function symbol is found.  The parameters     appear in the same order in the argument list as they do in the    symbol table. */
end_comment

begin_endif
unit|void add_param_to_type (type,sym)    struct type **type;    struct symbol *sym; {    int num = ++(TYPE_NFIELDS(*type));     if(TYPE_NFIELDS(*type)-1)       TYPE_FIELDS(*type) = (struct field *) 	  (*current_objfile->xrealloc) ((char *)(TYPE_FIELDS(*type)), 					num*sizeof(struct field));    else       TYPE_FIELDS(*type) = (struct field *) 	  (*current_objfile->xmalloc) (num*sizeof(struct field));        TYPE_FIELD_BITPOS(*type,num-1) = num-1;    TYPE_FIELD_BITSIZE(*type,num-1) = 0;    TYPE_FIELD_TYPE(*type,num-1) = SYMBOL_TYPE(sym);    TYPE_FIELD_NAME(*type,num-1) = SYMBOL_NAME(sym); }
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_function
name|void
name|_initialize_symtab
parameter_list|()
block|{
name|add_info
argument_list|(
literal|"variables"
argument_list|,
name|variables_info
argument_list|,
literal|"All global and static variable names, or those matching REGEXP."
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"functions"
argument_list|,
name|functions_info
argument_list|,
literal|"All function names, or those matching REGEXP."
argument_list|)
expr_stmt|;
comment|/* FIXME:  This command has at least the following problems:      1.  It prints builtin types (in a very strange and confusing fashion).      2.  It doesn't print right, e.g. with          typedef struct foo *FOO 	 type_print prints "FOO" when we want to make it (in this situation) 	 print "struct foo *".      I also think "ptype" or "whatis" is more likely to be useful (but if      there is much disagreement "info types" can be fixed).  */
name|add_info
argument_list|(
literal|"types"
argument_list|,
name|types_info
argument_list|,
literal|"All type names, or those matching REGEXP."
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|add_info ("methods", methods_info, 	    "All method names, or those matching REGEXP::REGEXP.\n\ If the class qualifier is omitted, it is assumed to be the current scope.\n\ If the first REGEXP is omitted, then all methods matching the second REGEXP\n\ are listed.");
endif|#
directive|endif
name|add_info
argument_list|(
literal|"sources"
argument_list|,
name|sources_info
argument_list|,
literal|"Source files in the program."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"rbreak"
argument_list|,
name|no_class
argument_list|,
name|rbreak_command
argument_list|,
literal|"Set a breakpoint for all functions matching REGEXP."
argument_list|)
expr_stmt|;
comment|/* Initialize the one built-in type that isn't language dependent... */
name|builtin_type_error
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_ERROR
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"<unknown type>"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

