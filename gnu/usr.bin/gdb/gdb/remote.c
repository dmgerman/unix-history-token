begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Remote target communications for serial-line targets in custom GDB protocol    Copyright 1988, 1991, 1992, 1993 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* Remote communication protocol.     A debug packet whose contents are<data>    is encapsulated for transmission in the form:  	$<data> # CSUM1 CSUM2<data> must be ASCII alphanumeric and cannot include characters 	'$' or '#'  	CSUM1 and CSUM2 are ascii hex representation of an 8-bit  	checksum of<data>, the most significant nibble is sent first. 	the hex digits 0-9,a-f are used.     Receiver responds with:  	+	- if CSUM is correct and ready for next packet 	-	- if CSUM is incorrect<data> is as follows:    All values are encoded in ascii hex digits.  	Request		Packet  	read registers  g 	reply		XX....X		Each byte of register data 					is described by two hex digits. 					Registers are in the internal order 					for GDB, and the bytes in a register 					are in the same order the machine uses. 			or ENN		for an error.  	write regs	GXX..XX		Each byte of register data 					is described by two hex digits. 	reply		OK		for success 			ENN		for an error  	read mem	mAA..AA,LLLL	AA..AA is address, LLLL is length. 	reply		XX..XX		XX..XX is mem contents 					Can be fewer bytes than requested 					if able to read only part of the data. 			or ENN		NN is errno  	write mem	MAA..AA,LLLL:XX..XX 					AA..AA is address, 					LLLL is number of bytes, 					XX..XX is data 	reply		OK		for success 			ENN		for an error (this includes the case 					where only part of the data was 					written).  	cont		cAA..AA		AA..AA is address to resume 					If AA..AA is omitted, 					resume at same address.  	step		sAA..AA		AA..AA is address to resume 					If AA..AA is omitted, 					resume at same address.  	last signal     ?               Reply the current reason for stopping.                                         This is the same reply as is generated 					for step or cont : SAA where AA is the 					signal number.  	There is no immediate reply to step or cont. 	The reply comes when the machine stops. 	It is		SAA		AA is the "signal number"  	or...		TAAn...:r...;n:r...;n...:r...; 					AA = signal number 					n... = register number 					r... = register contents 	or...		WAA		The process extited, and AA is 					the exit status.  This is only 					applicable for certains sorts of 					targets. 	or...		NAATT;DD;BB	Relocate the object file. 					AA = signal number 					TT = text address 					DD = data address 					BB = bss address 					This is used by the NLM stub, 					which is why it only has three 					addresses rather than one per 					section: the NLM stub always 					sees only three sections, even 					though gdb may see more.  	kill request	k  	toggle debug	d		toggle debug flag (see 386& 68k stubs) 	reset		r		reset -- see sparc stub. 	reserved<other>		On other requests, the stub should 					ignore the request and send an empty 					response ($#<checksum>).  This way 					we can extend the protocol and GDB 					can tell whether the stub it is 					talking to uses the old or the new. */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"wait.h"
end_include

begin_include
include|#
directive|include
file|"terminal.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"gdb-stabs.h"
end_include

begin_include
include|#
directive|include
file|"dcache.h"
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DONT_USE_REMOTE
argument_list|)
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"serial.h"
end_include

begin_comment
comment|/* Prototypes for local functions */
end_comment

begin_decl_stmt
specifier|static
name|int
name|remote_write_bytes
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
name|memaddr
operator|,
name|unsigned
name|char
operator|*
name|myaddr
operator|,
name|int
name|len
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|remote_read_bytes
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
name|memaddr
operator|,
name|unsigned
name|char
operator|*
name|myaddr
operator|,
name|int
name|len
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remote_files_info
name|PARAMS
argument_list|(
operator|(
expr|struct
name|target_ops
operator|*
name|ignore
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|remote_xfer_memory
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
name|memaddr
operator|,
name|char
operator|*
name|myaddr
operator|,
name|int
name|len
operator|,
name|int
name|should_write
operator|,
expr|struct
name|target_ops
operator|*
name|target
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remote_prepare_to_store
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remote_fetch_registers
name|PARAMS
argument_list|(
operator|(
name|int
name|regno
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remote_resume
name|PARAMS
argument_list|(
operator|(
name|int
name|pid
operator|,
name|int
name|step
operator|,
name|int
name|siggnal
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|remote_start_remote
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|dummy
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remote_open
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|name
operator|,
name|int
name|from_tty
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remote_close
name|PARAMS
argument_list|(
operator|(
name|int
name|quitting
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remote_store_registers
name|PARAMS
argument_list|(
operator|(
name|int
name|regno
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|getpkt
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|buf
operator|,
name|int
name|forever
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|putpkt
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|buf
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remote_send
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|buf
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|readchar
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|remote_wait
name|PARAMS
argument_list|(
operator|(
name|int
name|pid
operator|,
name|WAITTYPE
operator|*
name|status
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tohex
name|PARAMS
argument_list|(
operator|(
name|int
name|nib
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fromhex
name|PARAMS
argument_list|(
operator|(
name|int
name|a
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remote_detach
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|args
operator|,
name|int
name|from_tty
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remote_interrupt
name|PARAMS
argument_list|(
operator|(
name|int
name|signo
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remote_interrupt_twice
name|PARAMS
argument_list|(
operator|(
name|int
name|signo
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|interrupt_query
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|target_ops
name|remote_ops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward decl */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|baud_rate
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|remote_debug
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This was 5 seconds, which is a long time to sit and wait.    Unless this is going though some terminal server or multiplexer or    other form of hairy serial connection, I would think 2 seconds would    be plenty.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|timeout
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|int icache;
endif|#
directive|endif
end_endif

begin_comment
comment|/* Descriptor for I/O to remote machine.  Initialize it to NULL so that    remote_open knows that we don't have a file open when the program    starts.  */
end_comment

begin_decl_stmt
name|serial_t
name|remote_desc
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|PBUFSIZ
value|1024
end_define

begin_comment
comment|/* Maximum number of bytes to read/write at once.  The value here    is chosen to fill up a packet (the headers account for the 32).  */
end_comment

begin_define
define|#
directive|define
name|MAXBUFBYTES
value|((PBUFSIZ-32)/2)
end_define

begin_comment
comment|/* Round up PBUFSIZ to hold all the registers, at least.  */
end_comment

begin_if
if|#
directive|if
name|REGISTER_BYTES
operator|>
name|MAXBUFBYTES
end_if

begin_undef
undef|#
directive|undef
name|PBUFSIZ
end_undef

begin_define
define|#
directive|define
name|PBUFSIZ
value|(REGISTER_BYTES * 2 + 32)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Clean up connection to a remote debugger.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|remote_close
parameter_list|(
name|quitting
parameter_list|)
name|int
name|quitting
decl_stmt|;
block|{
if|if
condition|(
name|remote_desc
condition|)
name|SERIAL_CLOSE
argument_list|(
name|remote_desc
argument_list|)
expr_stmt|;
name|remote_desc
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Stub for catch_errors.  */
end_comment

begin_function
specifier|static
name|int
name|remote_start_remote
parameter_list|(
name|dummy
parameter_list|)
name|char
modifier|*
name|dummy
decl_stmt|;
block|{
name|immediate_quit
operator|=
literal|1
expr_stmt|;
comment|/* Allow user to interrupt it */
comment|/* Ack any packet which the remote side has already sent.  */
comment|/* I'm not sure this \r is needed; we don't use it any other time we      send an ack.  */
name|SERIAL_WRITE
argument_list|(
name|remote_desc
argument_list|,
literal|"+\r"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|putpkt
argument_list|(
literal|"?"
argument_list|)
expr_stmt|;
comment|/* initiate a query from remote machine */
name|immediate_quit
operator|=
literal|0
expr_stmt|;
name|start_remote
argument_list|()
expr_stmt|;
comment|/* Initialize gdb process mechanisms */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Open a connection to a remote debugger.    NAME is the filename used for communication.  */
end_comment

begin_decl_stmt
specifier|static
name|DCACHE
modifier|*
name|remote_dcache
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|remote_open
parameter_list|(
name|name
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
if|if
condition|(
name|name
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"To open a remote debug connection, you need to specify what serial\n\ device is attached to the remote system (e.g. /dev/ttya)."
argument_list|)
expr_stmt|;
name|target_preopen
argument_list|(
name|from_tty
argument_list|)
expr_stmt|;
name|unpush_target
argument_list|(
operator|&
name|remote_ops
argument_list|)
expr_stmt|;
name|remote_dcache
operator|=
name|dcache_init
argument_list|(
name|remote_read_bytes
argument_list|,
name|remote_write_bytes
argument_list|)
expr_stmt|;
name|remote_desc
operator|=
name|SERIAL_OPEN
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|remote_desc
condition|)
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|SERIAL_SETBAUDRATE
argument_list|(
name|remote_desc
argument_list|,
name|baud_rate
argument_list|)
condition|)
block|{
name|SERIAL_CLOSE
argument_list|(
name|remote_desc
argument_list|)
expr_stmt|;
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
name|SERIAL_RAW
argument_list|(
name|remote_desc
argument_list|)
expr_stmt|;
comment|/* If there is something sitting in the buffer we might take it as a      response to a command, which would be bad.  */
name|SERIAL_FLUSH_INPUT
argument_list|(
name|remote_desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
block|{
name|puts_filtered
argument_list|(
literal|"Remote debugging using "
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|push_target
argument_list|(
operator|&
name|remote_ops
argument_list|)
expr_stmt|;
comment|/* Switch to using remote target now */
comment|/* Start the remote connection; if error (0), discard this target.      In particular, if the user quits, be sure to discard it      (we'd be in an inconsistent state otherwise).  */
if|if
condition|(
operator|!
name|catch_errors
argument_list|(
name|remote_start_remote
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
literal|"Couldn't establish connection to remote target\n"
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
condition|)
name|pop_target
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* remote_detach()    takes a program previously attached to and detaches it.    We better not have left any breakpoints    in the program or it'll die when it hits one.    Close the open connection to the remote debugger.    Use this when you want to detach and do something else    with your gdb.  */
end_comment

begin_function
specifier|static
name|void
name|remote_detach
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
if|if
condition|(
name|args
condition|)
name|error
argument_list|(
literal|"Argument given to \"detach\" when remotely debugging."
argument_list|)
expr_stmt|;
name|pop_target
argument_list|()
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
name|puts_filtered
argument_list|(
literal|"Ending remote debugging.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Convert hex digit A to a number.  */
end_comment

begin_function
specifier|static
name|int
name|fromhex
parameter_list|(
name|a
parameter_list|)
name|int
name|a
decl_stmt|;
block|{
if|if
condition|(
name|a
operator|>=
literal|'0'
operator|&&
name|a
operator|<=
literal|'9'
condition|)
return|return
name|a
operator|-
literal|'0'
return|;
elseif|else
if|if
condition|(
name|a
operator|>=
literal|'a'
operator|&&
name|a
operator|<=
literal|'f'
condition|)
return|return
name|a
operator|-
literal|'a'
operator|+
literal|10
return|;
else|else
name|error
argument_list|(
literal|"Reply contains invalid hex digit"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Convert number NIB to a hex digit.  */
end_comment

begin_function
specifier|static
name|int
name|tohex
parameter_list|(
name|nib
parameter_list|)
name|int
name|nib
decl_stmt|;
block|{
if|if
condition|(
name|nib
operator|<
literal|10
condition|)
return|return
literal|'0'
operator|+
name|nib
return|;
else|else
return|return
literal|'a'
operator|+
name|nib
operator|-
literal|10
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Tell the remote machine to resume.  */
end_comment

begin_function
specifier|static
name|void
name|remote_resume
parameter_list|(
name|pid
parameter_list|,
name|step
parameter_list|,
name|siggnal
parameter_list|)
name|int
name|pid
decl_stmt|,
name|step
decl_stmt|,
name|siggnal
decl_stmt|;
block|{
name|char
name|buf
index|[
name|PBUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|siggnal
condition|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|target_terminal_ours_for_output
argument_list|()
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Can't send signals to a remote system.  "
argument_list|)
expr_stmt|;
name|name
operator|=
name|strsigno
argument_list|(
name|siggnal
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
name|printf_filtered
argument_list|(
name|name
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|"Signal %d"
argument_list|,
name|siggnal
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" not sent.\n"
argument_list|)
expr_stmt|;
name|target_terminal_inferior
argument_list|()
expr_stmt|;
block|}
name|dcache_flush
argument_list|(
name|remote_dcache
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
name|step
condition|?
literal|"s"
else|:
literal|"c"
argument_list|)
expr_stmt|;
name|putpkt
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Send ^C to target to halt it.  Target will respond, and send us a    packet.  */
end_comment

begin_function
specifier|static
name|void
name|remote_interrupt
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
comment|/* If this doesn't work, try more severe steps.  */
name|signal
argument_list|(
name|signo
argument_list|,
name|remote_interrupt_twice
argument_list|)
expr_stmt|;
if|if
condition|(
name|remote_debug
condition|)
name|printf
argument_list|(
literal|"remote_interrupt called\n"
argument_list|)
expr_stmt|;
name|SERIAL_WRITE
argument_list|(
name|remote_desc
argument_list|,
literal|"\003"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Send a ^C */
block|}
end_function

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
name|ofunc
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* The user typed ^C twice.  */
end_comment

begin_function
specifier|static
name|void
name|remote_interrupt_twice
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
name|signal
argument_list|(
name|signo
argument_list|,
name|ofunc
argument_list|)
expr_stmt|;
name|interrupt_query
argument_list|()
expr_stmt|;
name|signal
argument_list|(
name|signo
argument_list|,
name|remote_interrupt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Ask the user what to do when an interrupt is received.  */
end_comment

begin_function
specifier|static
name|void
name|interrupt_query
parameter_list|()
block|{
name|target_terminal_ours
argument_list|()
expr_stmt|;
if|if
condition|(
name|query
argument_list|(
literal|"Interrupted while waiting for the program.\n\ Give up (and stop debugging it)? "
argument_list|)
condition|)
block|{
name|target_mourn_inferior
argument_list|()
expr_stmt|;
name|return_to_top_level
argument_list|(
name|RETURN_QUIT
argument_list|)
expr_stmt|;
block|}
name|target_terminal_inferior
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Wait until the remote machine stops, then return,    storing status in STATUS just as `wait' would.    Returns "pid" (though it's not clear what, if anything, that    means in the case of this target).  */
end_comment

begin_function
specifier|static
name|int
name|remote_wait
parameter_list|(
name|pid
parameter_list|,
name|status
parameter_list|)
name|int
name|pid
decl_stmt|;
name|WAITTYPE
modifier|*
name|status
decl_stmt|;
block|{
name|unsigned
name|char
name|buf
index|[
name|PBUFSIZ
index|]
decl_stmt|;
name|WSETEXIT
argument_list|(
operator|(
operator|*
name|status
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|ofunc
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|remote_interrupt
argument_list|)
expr_stmt|;
name|getpkt
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|ofunc
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'E'
condition|)
name|warning
argument_list|(
literal|"Remote failure reply: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'T'
condition|)
block|{
name|int
name|i
decl_stmt|;
name|long
name|regno
decl_stmt|;
name|char
name|regs
index|[
name|MAX_REGISTER_RAW_SIZE
index|]
decl_stmt|;
comment|/* Expedited reply, containing Signal, {regno, reg} repeat */
comment|/*  format is:  'Tssn...:r...;n...:r...;n...:r...;#cc', where 	      ss = signal number 	      n... = register number 	      r... = register contents 	      */
name|p
operator|=
operator|&
name|buf
index|[
literal|3
index|]
expr_stmt|;
comment|/* after Txx */
while|while
condition|(
operator|*
name|p
condition|)
block|{
name|unsigned
name|char
modifier|*
name|p1
decl_stmt|;
name|regno
operator|=
name|strtol
argument_list|(
name|p
argument_list|,
operator|&
name|p1
argument_list|,
literal|16
argument_list|)
expr_stmt|;
comment|/* Read the register number */
if|if
condition|(
name|p1
operator|==
name|p
condition|)
name|warning
argument_list|(
literal|"Remote sent badly formed register number: %s\nPacket: '%s'\n"
argument_list|,
name|p1
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|p
operator|=
name|p1
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
literal|':'
condition|)
name|warning
argument_list|(
literal|"Malformed packet (missing colon): %s\nPacket: '%s'\n"
argument_list|,
name|p
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|>=
name|NUM_REGS
condition|)
name|warning
argument_list|(
literal|"Remote sent bad register number %d: %s\nPacket: '%s'\n"
argument_list|,
name|regno
argument_list|,
name|p
argument_list|,
name|buf
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|0
operator|||
name|p
index|[
literal|1
index|]
operator|==
literal|0
condition|)
name|warning
argument_list|(
literal|"Remote reply is too short: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|regs
index|[
name|i
index|]
operator|=
name|fromhex
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
operator|*
literal|16
operator|+
name|fromhex
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
literal|';'
condition|)
name|warning
argument_list|(
literal|"Remote register badly formatted: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|regno
argument_list|,
name|regs
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
elseif|else
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'N'
condition|)
block|{
name|unsigned
name|char
modifier|*
name|p1
decl_stmt|;
name|bfd_vma
name|text_addr
decl_stmt|,
name|data_addr
decl_stmt|,
name|bss_addr
decl_stmt|;
comment|/* Relocate object file.  Format is NAATT;DD;BB where AA is 	     the signal number, TT is the new text address, DD is the 	     new data address, and BB is the new bss address.  This is 	     used by the NLM stub; gdb may see more sections.  */
name|p
operator|=
operator|&
name|buf
index|[
literal|3
index|]
expr_stmt|;
name|text_addr
operator|=
name|strtoul
argument_list|(
name|p
argument_list|,
operator|&
name|p1
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
operator|==
name|p
operator|||
operator|*
name|p1
operator|!=
literal|';'
condition|)
name|warning
argument_list|(
literal|"Malformed relocation packet: Packet '%s'"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|p
operator|=
name|p1
operator|+
literal|1
expr_stmt|;
name|data_addr
operator|=
name|strtoul
argument_list|(
name|p
argument_list|,
operator|&
name|p1
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
operator|==
name|p
operator|||
operator|*
name|p1
operator|!=
literal|';'
condition|)
name|warning
argument_list|(
literal|"Malformed relocation packet: Packet '%s'"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|p
operator|=
name|p1
operator|+
literal|1
expr_stmt|;
name|bss_addr
operator|=
name|strtoul
argument_list|(
name|p
argument_list|,
operator|&
name|p1
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
operator|==
name|p
condition|)
name|warning
argument_list|(
literal|"Malformed relocation packet: Packet '%s'"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|symfile_objfile
operator|!=
name|NULL
operator|&&
operator|(
name|ANOFFSET
argument_list|(
name|symfile_objfile
operator|->
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
operator|!=
name|text_addr
operator|||
name|ANOFFSET
argument_list|(
name|symfile_objfile
operator|->
name|section_offsets
argument_list|,
name|SECT_OFF_DATA
argument_list|)
operator|!=
name|data_addr
operator|||
name|ANOFFSET
argument_list|(
name|symfile_objfile
operator|->
name|section_offsets
argument_list|,
name|SECT_OFF_BSS
argument_list|)
operator|!=
name|bss_addr
operator|)
condition|)
block|{
name|struct
name|section_offsets
modifier|*
name|offs
decl_stmt|;
comment|/* FIXME: This code assumes gdb-stabs.h is being used; 		 it's broken for xcoff, dwarf, sdb-coff, etc.  But 		 there is no simple canonical representation for this 		 stuff.  (Just what does "text" as seen by the stub 		 mean, anyway?).  */
comment|/* FIXME: Why don't the various symfile_offsets routines 		 in the sym_fns vectors set this? 		 (no good reason -kingdon).  */
if|if
condition|(
name|symfile_objfile
operator|->
name|num_sections
operator|==
literal|0
condition|)
name|symfile_objfile
operator|->
name|num_sections
operator|=
name|SECT_OFF_MAX
expr_stmt|;
name|offs
operator|=
operator|(
operator|(
expr|struct
name|section_offsets
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|section_offsets
argument_list|)
operator|+
operator|(
name|symfile_objfile
operator|->
name|num_sections
operator|*
sizeof|sizeof
argument_list|(
name|offs
operator|->
name|offsets
argument_list|)
operator|)
argument_list|)
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|offs
argument_list|,
name|symfile_objfile
operator|->
name|section_offsets
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|section_offsets
argument_list|)
operator|+
operator|(
name|symfile_objfile
operator|->
name|num_sections
operator|*
sizeof|sizeof
argument_list|(
name|offs
operator|->
name|offsets
argument_list|)
operator|)
operator|)
argument_list|)
expr_stmt|;
name|ANOFFSET
argument_list|(
name|offs
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
operator|=
name|text_addr
expr_stmt|;
name|ANOFFSET
argument_list|(
name|offs
argument_list|,
name|SECT_OFF_DATA
argument_list|)
operator|=
name|data_addr
expr_stmt|;
name|ANOFFSET
argument_list|(
name|offs
argument_list|,
name|SECT_OFF_BSS
argument_list|)
operator|=
name|bss_addr
expr_stmt|;
name|objfile_relocate
argument_list|(
name|symfile_objfile
argument_list|,
name|offs
argument_list|)
expr_stmt|;
block|{
name|struct
name|obj_section
modifier|*
name|s
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|abfd
operator|=
name|symfile_objfile
operator|->
name|obfd
expr_stmt|;
for|for
control|(
name|s
operator|=
name|symfile_objfile
operator|->
name|sections
init|;
name|s
operator|<
name|symfile_objfile
operator|->
name|sections_end
condition|;
operator|++
name|s
control|)
block|{
name|flagword
name|flags
decl_stmt|;
name|flags
operator|=
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
operator|->
name|sec_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SEC_CODE
condition|)
block|{
name|s
operator|->
name|addr
operator|+=
name|text_addr
expr_stmt|;
name|s
operator|->
name|endaddr
operator|+=
name|text_addr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
operator|(
name|SEC_DATA
operator||
name|SEC_LOAD
operator|)
condition|)
block|{
name|s
operator|->
name|addr
operator|+=
name|data_addr
expr_stmt|;
name|s
operator|->
name|endaddr
operator|+=
name|data_addr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|SEC_ALLOC
condition|)
block|{
name|s
operator|->
name|addr
operator|+=
name|bss_addr
expr_stmt|;
name|s
operator|->
name|endaddr
operator|+=
name|bss_addr
expr_stmt|;
block|}
block|}
block|}
block|}
break|break;
block|}
elseif|else
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'W'
condition|)
block|{
comment|/* The remote process exited.  */
name|WSETEXIT
argument_list|(
operator|*
name|status
argument_list|,
operator|(
name|fromhex
argument_list|(
name|buf
index|[
literal|1
index|]
argument_list|)
operator|<<
literal|4
operator|)
operator|+
name|fromhex
argument_list|(
name|buf
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'S'
condition|)
break|break;
else|else
name|warning
argument_list|(
literal|"Invalid remote reply: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|WSETSTOP
argument_list|(
operator|(
operator|*
name|status
operator|)
argument_list|,
operator|(
operator|(
operator|(
name|fromhex
argument_list|(
name|buf
index|[
literal|1
index|]
argument_list|)
operator|)
operator|<<
literal|4
operator|)
operator|+
operator|(
name|fromhex
argument_list|(
name|buf
index|[
literal|2
index|]
argument_list|)
operator|)
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Number of bytes of registers this stub implements.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|register_bytes_found
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Read the remote registers into the block REGS.  */
end_comment

begin_comment
comment|/* Currently we just read all the registers, so we don't use regno.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|remote_fetch_registers
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
name|char
name|buf
index|[
name|PBUFSIZ
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|regs
index|[
name|REGISTER_BYTES
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"g"
argument_list|)
expr_stmt|;
name|remote_send
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* Unimplemented registers read as all bits zero.  */
name|memset
argument_list|(
name|regs
argument_list|,
literal|0
argument_list|,
name|REGISTER_BYTES
argument_list|)
expr_stmt|;
comment|/* We can get out of synch in various cases.  If the first character      in the buffer is not a hex character, assume that has happened      and try to fetch another packet to read.  */
while|while
condition|(
operator|(
name|buf
index|[
literal|0
index|]
operator|<
literal|'0'
operator|||
name|buf
index|[
literal|0
index|]
operator|>
literal|'9'
operator|)
operator|&&
operator|(
name|buf
index|[
literal|0
index|]
operator|<
literal|'a'
operator|||
name|buf
index|[
literal|0
index|]
operator|>
literal|'f'
operator|)
condition|)
block|{
if|if
condition|(
name|remote_debug
condition|)
name|printf
argument_list|(
literal|"Bad register packet; fetching a new packet\n"
argument_list|)
expr_stmt|;
name|getpkt
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Reply describes registers byte by byte, each byte encoded as two      hex characters.  Suck them all up, then supply them to the      register cacheing/storage mechanism.  */
name|p
operator|=
name|buf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGISTER_BYTES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"Remote reply is of odd length: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* Don't change register_bytes_found in this case, and don't 	     print a second warning.  */
goto|goto
name|supply_them
goto|;
block|}
name|regs
index|[
name|i
index|]
operator|=
name|fromhex
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
operator|*
literal|16
operator|+
name|fromhex
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|!=
name|register_bytes_found
condition|)
block|{
name|register_bytes_found
operator|=
name|i
expr_stmt|;
ifdef|#
directive|ifdef
name|REGISTER_BYTES_OK
if|if
condition|(
operator|!
name|REGISTER_BYTES_OK
argument_list|(
name|i
argument_list|)
condition|)
name|warning
argument_list|(
literal|"Remote reply is too short: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|supply_them
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_REGS
condition|;
name|i
operator|++
control|)
name|supply_register
argument_list|(
name|i
argument_list|,
operator|&
name|regs
index|[
name|REGISTER_BYTE
argument_list|(
name|i
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Prepare to store registers.  Since we send them all, we have to    read out the ones we don't want to change first.  */
end_comment

begin_function
specifier|static
name|void
name|remote_prepare_to_store
parameter_list|()
block|{
comment|/* Make sure the entire registers array is valid.  */
name|read_register_bytes
argument_list|(
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|REGISTER_BYTES
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Store the remote registers from the contents of the block REGISTERS.     FIXME, eventually just store one register if that's all that is needed.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|remote_store_registers
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
name|char
name|buf
index|[
name|PBUFSIZ
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|'G'
expr_stmt|;
comment|/* Command describes registers byte by byte,      each byte encoded as two hex characters.  */
name|p
operator|=
name|buf
operator|+
literal|1
expr_stmt|;
comment|/* remote_prepare_to_store insures that register_bytes_found gets set.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|register_bytes_found
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|p
operator|++
operator|=
name|tohex
argument_list|(
operator|(
name|registers
index|[
name|i
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0xf
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|tohex
argument_list|(
name|registers
index|[
name|i
index|]
operator|&
literal|0xf
argument_list|)
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|remote_send
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Use of the data cache is disabled because it loses for looking at    and changing hardware I/O ports and the like.  Accepting `volatile'    would perhaps be one way to fix it, but a better way which would    win for more cases would be to use the executable file for the text    segment, like the `icache' code below but done cleanly (in some    target-independent place, perhaps in target_xfer_memory, perhaps    based on assigning each target a speed or perhaps by some simpler    mechanism).  */
end_comment

begin_comment
comment|/* Read a word from remote address ADDR and return it.    This goes through the data cache.  */
end_comment

begin_if
unit|static int remote_fetch_word (addr)      CORE_ADDR addr; {
if|#
directive|if
literal|0
end_if

begin_endif
unit|if (icache)     {       extern CORE_ADDR text_start, text_end;        if (addr>= text_start&& addr< text_end) 	{ 	  int buffer; 	  xfer_core_file (addr,&buffer, sizeof (int)); 	  return buffer; 	}     }
endif|#
directive|endif
end_endif

begin_comment
unit|return dcache_fetch (remote_dcache, addr); }
comment|/* Write a word WORD into remote address ADDR.    This goes through the data cache.  */
end_comment

begin_endif
unit|static void remote_store_word (addr, word)      CORE_ADDR addr;      int word; {   dcache_poke (remote_dcache, addr, word); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Write memory data directly to the remote machine.    This does not inform the data cache; the data cache uses this.    MEMADDR is the address in the remote memory space.    MYADDR is the address of the buffer in our space.    LEN is the number of bytes.     Returns number of bytes transferred, or 0 for error.  */
end_comment

begin_function
specifier|static
name|int
name|remote_write_bytes
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|unsigned
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|char
name|buf
index|[
name|PBUFSIZ
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|len
operator|>
name|PBUFSIZ
operator|/
literal|2
operator|-
literal|20
condition|)
name|abort
argument_list|()
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"M%x,%x:"
argument_list|,
name|memaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* We send target system values byte by byte, in increasing byte addresses,      each byte encoded as two hex characters.  */
name|p
operator|=
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|p
operator|++
operator|=
name|tohex
argument_list|(
operator|(
name|myaddr
index|[
name|i
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0xf
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|tohex
argument_list|(
name|myaddr
index|[
name|i
index|]
operator|&
literal|0xf
argument_list|)
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|putpkt
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|getpkt
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'E'
condition|)
block|{
comment|/* There is no correspondance between what the remote protocol uses 	 for errors and errno codes.  We would like a cleaner way of 	 representing errors (big enough to include errno codes, bfd_error 	 codes, and others).  But for now just return EIO.  */
name|errno
operator|=
name|EIO
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/* Read memory data directly from the remote machine.    This does not use the data cache; the data cache uses this.    MEMADDR is the address in the remote memory space.    MYADDR is the address of the buffer in our space.    LEN is the number of bytes.     Returns number of bytes transferred, or 0 for error.  */
end_comment

begin_function
specifier|static
name|int
name|remote_read_bytes
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|unsigned
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|char
name|buf
index|[
name|PBUFSIZ
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|len
operator|>
name|PBUFSIZ
operator|/
literal|2
operator|-
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"m%x,%x"
argument_list|,
name|memaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|putpkt
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|getpkt
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'E'
condition|)
block|{
comment|/* There is no correspondance between what the remote protocol uses 	 for errors and errno codes.  We would like a cleaner way of 	 representing errors (big enough to include errno codes, bfd_error 	 codes, and others).  But for now just return EIO.  */
name|errno
operator|=
name|EIO
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Reply describes memory byte by byte,      each byte encoded as two hex characters.  */
name|p
operator|=
name|buf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|0
operator|||
name|p
index|[
literal|1
index|]
operator|==
literal|0
condition|)
comment|/* Reply is short.  This means that we were able to read only part 	   of what we wanted to.  */
break|break;
name|myaddr
index|[
name|i
index|]
operator|=
name|fromhex
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
operator|*
literal|16
operator|+
name|fromhex
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
block|}
return|return
name|i
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read or write LEN bytes from inferior memory at MEMADDR, transferring    to or from debugger address MYADDR.  Write to inferior if SHOULD_WRITE is    nonzero.  Returns length of data written or read; 0 for error.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|remote_xfer_memory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|,
name|should_write
parameter_list|,
name|target
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|should_write
decl_stmt|;
name|struct
name|target_ops
modifier|*
name|target
decl_stmt|;
comment|/* ignored */
block|{
name|int
name|xfersize
decl_stmt|;
name|int
name|bytes_xferred
decl_stmt|;
name|int
name|total_xferred
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|len
operator|>
name|MAXBUFBYTES
condition|)
name|xfersize
operator|=
name|MAXBUFBYTES
expr_stmt|;
else|else
name|xfersize
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|should_write
condition|)
name|bytes_xferred
operator|=
name|remote_write_bytes
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|xfersize
argument_list|)
expr_stmt|;
else|else
name|bytes_xferred
operator|=
name|remote_read_bytes
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|xfersize
argument_list|)
expr_stmt|;
comment|/* If we get an error, we are done xferring.  */
if|if
condition|(
name|bytes_xferred
operator|==
literal|0
condition|)
break|break;
name|memaddr
operator|+=
name|bytes_xferred
expr_stmt|;
name|myaddr
operator|+=
name|bytes_xferred
expr_stmt|;
name|len
operator|-=
name|bytes_xferred
expr_stmt|;
name|total_xferred
operator|+=
name|bytes_xferred
expr_stmt|;
block|}
return|return
name|total_xferred
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|remote_files_info
parameter_list|(
name|ignore
parameter_list|)
name|struct
name|target_ops
modifier|*
name|ignore
decl_stmt|;
block|{
name|puts_filtered
argument_list|(
literal|"Debugging a target over a serial line.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Stuff for dealing with the packets which are part of this protocol.    See comment at top of file for details.  */
end_comment

begin_comment
comment|/* Read a single character from the remote end, masking it down to 7 bits. */
end_comment

begin_function
specifier|static
name|int
name|readchar
parameter_list|()
block|{
name|int
name|ch
decl_stmt|;
name|ch
operator|=
name|SERIAL_READCHAR
argument_list|(
name|remote_desc
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|<
literal|0
condition|)
return|return
name|ch
return|;
return|return
name|ch
operator|&
literal|0x7f
return|;
block|}
end_function

begin_comment
comment|/* Send the command in BUF to the remote machine,    and read the reply into BUF.    Report an error if we get an error reply.  */
end_comment

begin_function
specifier|static
name|void
name|remote_send
parameter_list|(
name|buf
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
block|{
name|putpkt
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|getpkt
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'E'
condition|)
name|error
argument_list|(
literal|"Remote failure reply: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Send a packet to the remote machine, with error checking.    The data of the packet is in BUF.  */
end_comment

begin_function
specifier|static
name|void
name|putpkt
parameter_list|(
name|buf
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|char
name|csum
init|=
literal|0
decl_stmt|;
name|char
name|buf2
index|[
name|PBUFSIZ
index|]
decl_stmt|;
name|int
name|cnt
init|=
name|strlen
argument_list|(
name|buf
argument_list|)
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Copy the packet into buffer BUF2, encapsulating it      and giving it a checksum.  */
if|if
condition|(
name|cnt
operator|>
sizeof|sizeof
argument_list|(
name|buf2
argument_list|)
operator|-
literal|5
condition|)
comment|/* Prosanity check */
name|abort
argument_list|()
expr_stmt|;
name|p
operator|=
name|buf2
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'$'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
block|{
name|csum
operator|+=
name|buf
index|[
name|i
index|]
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|buf
index|[
name|i
index|]
expr_stmt|;
block|}
operator|*
name|p
operator|++
operator|=
literal|'#'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|tohex
argument_list|(
operator|(
name|csum
operator|>>
literal|4
operator|)
operator|&
literal|0xf
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|tohex
argument_list|(
name|csum
operator|&
literal|0xf
argument_list|)
expr_stmt|;
comment|/* Send it over and over until we get a positive ack.  */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|remote_debug
condition|)
block|{
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|printf
argument_list|(
literal|"Sending packet: %s..."
argument_list|,
name|buf2
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SERIAL_WRITE
argument_list|(
name|remote_desc
argument_list|,
name|buf2
argument_list|,
name|p
operator|-
name|buf2
argument_list|)
condition|)
name|perror_with_name
argument_list|(
literal|"putpkt: write failed"
argument_list|)
expr_stmt|;
comment|/* read until either a timeout occurs (-2) or '+' is read */
while|while
condition|(
literal|1
condition|)
block|{
name|ch
operator|=
name|readchar
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'+'
case|:
if|if
condition|(
name|remote_debug
condition|)
name|printf
argument_list|(
literal|"Ack\n"
argument_list|)
expr_stmt|;
return|return;
case|case
name|SERIAL_TIMEOUT
case|:
break|break;
comment|/* Retransmit buffer */
case|case
name|SERIAL_ERROR
case|:
name|perror_with_name
argument_list|(
literal|"putpkt: couldn't read ACK"
argument_list|)
expr_stmt|;
case|case
name|SERIAL_EOF
case|:
name|error
argument_list|(
literal|"putpkt: EOF while trying to read ACK"
argument_list|)
expr_stmt|;
default|default:
if|if
condition|(
name|remote_debug
condition|)
name|printf
argument_list|(
literal|"%02X %c "
argument_list|,
name|ch
operator|&
literal|0xFF
argument_list|,
name|ch
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
comment|/* Here to retransmit */
block|}
if|if
condition|(
name|quit_flag
condition|)
block|{
name|quit_flag
operator|=
literal|0
expr_stmt|;
name|interrupt_query
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Read a packet from the remote machine, with error checking,    and store it in BUF.  BUF is expected to be of size PBUFSIZ.    If FOREVER, wait forever rather than timing out; this is used    while the target is executing user code.  */
end_comment

begin_function
specifier|static
name|void
name|getpkt
parameter_list|(
name|buf
parameter_list|,
name|forever
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|forever
decl_stmt|;
block|{
name|char
modifier|*
name|bp
decl_stmt|;
name|unsigned
name|char
name|csum
decl_stmt|;
name|int
name|c
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
name|c1
decl_stmt|,
name|c2
decl_stmt|;
name|int
name|retries
init|=
literal|0
decl_stmt|;
define|#
directive|define
name|MAX_RETRIES
value|10
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|quit_flag
condition|)
block|{
name|quit_flag
operator|=
literal|0
expr_stmt|;
name|interrupt_query
argument_list|()
expr_stmt|;
block|}
comment|/* This can loop forever if the remote side sends us characters 	 continuously, but if it pauses, we'll get a zero from readchar 	 because of timeout.  Then we'll count that as a retry.  */
name|c
operator|=
name|readchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|>
literal|0
operator|&&
name|c
operator|!=
literal|'$'
condition|)
continue|continue;
if|if
condition|(
name|c
operator|==
name|SERIAL_TIMEOUT
condition|)
block|{
if|if
condition|(
name|forever
condition|)
continue|continue;
if|if
condition|(
operator|++
name|retries
operator|>=
name|MAX_RETRIES
condition|)
if|if
condition|(
name|remote_debug
condition|)
name|puts_filtered
argument_list|(
literal|"Timed out.\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|c
operator|==
name|SERIAL_EOF
condition|)
name|error
argument_list|(
literal|"Remote connection closed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|SERIAL_ERROR
condition|)
name|perror_with_name
argument_list|(
literal|"Remote communication error"
argument_list|)
expr_stmt|;
comment|/* Force csum to be zero here because of possible error retry.  */
name|csum
operator|=
literal|0
expr_stmt|;
name|bp
operator|=
name|buf
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
name|readchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|SERIAL_TIMEOUT
condition|)
block|{
if|if
condition|(
name|remote_debug
condition|)
name|puts_filtered
argument_list|(
literal|"Timeout in mid-packet, retrying\n"
argument_list|)
expr_stmt|;
goto|goto
name|whole
goto|;
comment|/* Start a new packet, count retries */
block|}
if|if
condition|(
name|c
operator|==
literal|'$'
condition|)
block|{
if|if
condition|(
name|remote_debug
condition|)
name|puts_filtered
argument_list|(
literal|"Saw new packet start in middle of old one\n"
argument_list|)
expr_stmt|;
goto|goto
name|whole
goto|;
comment|/* Start a new packet, count retries */
block|}
if|if
condition|(
name|c
operator|==
literal|'#'
condition|)
break|break;
if|if
condition|(
name|bp
operator|>=
name|buf
operator|+
name|PBUFSIZ
operator|-
literal|1
condition|)
block|{
operator|*
name|bp
operator|=
literal|'\0'
expr_stmt|;
name|puts_filtered
argument_list|(
literal|"Remote packet too long: "
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
goto|goto
name|whole
goto|;
block|}
operator|*
name|bp
operator|++
operator|=
name|c
expr_stmt|;
name|csum
operator|+=
name|c
expr_stmt|;
block|}
operator|*
name|bp
operator|=
literal|0
expr_stmt|;
name|c1
operator|=
name|fromhex
argument_list|(
name|readchar
argument_list|()
argument_list|)
expr_stmt|;
name|c2
operator|=
name|fromhex
argument_list|(
name|readchar
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|csum
operator|&
literal|0xff
operator|)
operator|==
operator|(
name|c1
operator|<<
literal|4
operator|)
operator|+
name|c2
condition|)
break|break;
name|printf_filtered
argument_list|(
literal|"Bad checksum, sentsum=0x%x, csum=0x%x, buf="
argument_list|,
operator|(
name|c1
operator|<<
literal|4
operator|)
operator|+
name|c2
argument_list|,
name|csum
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* Try the whole thing again.  */
name|whole
label|:
if|if
condition|(
operator|++
name|retries
operator|<
name|MAX_RETRIES
condition|)
block|{
name|SERIAL_WRITE
argument_list|(
name|remote_desc
argument_list|,
literal|"-"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"Ignoring packet error, continuing...\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|out
label|:
name|SERIAL_WRITE
argument_list|(
name|remote_desc
argument_list|,
literal|"+"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|remote_debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Packet received: %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|remote_kill
parameter_list|()
block|{
name|putpkt
argument_list|(
literal|"k"
argument_list|)
expr_stmt|;
comment|/* Don't wait for it to die.  I'm not really sure it matters whether      we do or not.  For the existing stubs, kill is a noop.  */
name|target_mourn_inferior
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|remote_mourn
parameter_list|()
block|{
name|unpush_target
argument_list|(
operator|&
name|remote_ops
argument_list|)
expr_stmt|;
name|generic_mourn_inferior
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|REMOTE_BREAKPOINT
end_ifdef

begin_comment
comment|/* On some machines, e.g. 68k, we may use a different breakpoint instruction    than other targets.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|break_insn
index|[]
init|=
name|REMOTE_BREAKPOINT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Check that it fits in BREAKPOINT_MAX bytes.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|check_break_insn_size
index|[
name|BREAKPOINT_MAX
index|]
init|=
name|REMOTE_BREAKPOINT
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* No REMOTE_BREAKPOINT.  */
end_comment

begin_comment
comment|/* Same old breakpoint instruction.  This code does nothing different    than mem-break.c.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|break_insn
index|[]
init|=
name|BREAKPOINT
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* No REMOTE_BREAKPOINT.  */
end_comment

begin_comment
comment|/* Insert a breakpoint on targets that don't have any better breakpoint    support.  We read the contents of the target location and stash it,    then overwrite it with a breakpoint instruction.  ADDR is the target    location in the target machine.  CONTENTS_CACHE is a pointer to     memory allocated for saving the target contents.  It is guaranteed    by the caller to be long enough to save sizeof BREAKPOINT bytes (this    is accomplished via BREAKPOINT_MAX).  */
end_comment

begin_function
specifier|static
name|int
name|remote_insert_breakpoint
parameter_list|(
name|addr
parameter_list|,
name|contents_cache
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
name|char
modifier|*
name|contents_cache
decl_stmt|;
block|{
name|int
name|val
decl_stmt|;
name|val
operator|=
name|target_read_memory
argument_list|(
name|addr
argument_list|,
name|contents_cache
argument_list|,
sizeof|sizeof
name|break_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
name|val
operator|=
name|target_write_memory
argument_list|(
name|addr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|break_insn
argument_list|,
sizeof|sizeof
name|break_insn
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|remote_remove_breakpoint
parameter_list|(
name|addr
parameter_list|,
name|contents_cache
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
name|char
modifier|*
name|contents_cache
decl_stmt|;
block|{
return|return
name|target_write_memory
argument_list|(
name|addr
argument_list|,
name|contents_cache
argument_list|,
sizeof|sizeof
name|break_insn
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Define the target subroutine names */
end_comment

begin_decl_stmt
name|struct
name|target_ops
name|remote_ops
init|=
block|{
literal|"remote"
block|,
comment|/* to_shortname */
literal|"Remote serial target in gdb-specific protocol"
block|,
comment|/* to_longname */
literal|"Use a remote computer via a serial line, using a gdb-specific protocol.\n\ Specify the serial device it is connected to (e.g. /dev/ttya)."
block|,
comment|/* to_doc */
name|remote_open
block|,
comment|/* to_open */
name|remote_close
block|,
comment|/* to_close */
name|NULL
block|,
comment|/* to_attach */
name|remote_detach
block|,
comment|/* to_detach */
name|remote_resume
block|,
comment|/* to_resume */
name|remote_wait
block|,
comment|/* to_wait */
name|remote_fetch_registers
block|,
comment|/* to_fetch_registers */
name|remote_store_registers
block|,
comment|/* to_store_registers */
name|remote_prepare_to_store
block|,
comment|/* to_prepare_to_store */
name|remote_xfer_memory
block|,
comment|/* to_xfer_memory */
name|remote_files_info
block|,
comment|/* to_files_info */
name|remote_insert_breakpoint
block|,
comment|/* to_insert_breakpoint */
name|remote_remove_breakpoint
block|,
comment|/* to_remove_breakpoint */
name|NULL
block|,
comment|/* to_terminal_init */
name|NULL
block|,
comment|/* to_terminal_inferior */
name|NULL
block|,
comment|/* to_terminal_ours_for_output */
name|NULL
block|,
comment|/* to_terminal_ours */
name|NULL
block|,
comment|/* to_terminal_info */
name|remote_kill
block|,
comment|/* to_kill */
name|generic_load
block|,
comment|/* to_load */
name|NULL
block|,
comment|/* to_lookup_symbol */
name|NULL
block|,
comment|/* to_create_inferior */
name|remote_mourn
block|,
comment|/* to_mourn_inferior */
literal|0
block|,
comment|/* to_can_run */
literal|0
block|,
comment|/* to_notice_signals */
name|process_stratum
block|,
comment|/* to_stratum */
name|NULL
block|,
comment|/* to_next */
literal|1
block|,
comment|/* to_has_all_memory */
literal|1
block|,
comment|/* to_has_memory */
literal|1
block|,
comment|/* to_has_stack */
literal|1
block|,
comment|/* to_has_registers */
literal|1
block|,
comment|/* to_has_execution */
name|NULL
block|,
comment|/* sections */
name|NULL
block|,
comment|/* sections_end */
name|OPS_MAGIC
comment|/* to_magic */
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|_initialize_remote
parameter_list|()
block|{
name|add_target
argument_list|(
operator|&
name|remote_ops
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

