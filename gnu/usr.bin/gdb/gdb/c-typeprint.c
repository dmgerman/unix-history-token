begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Support for printing C and C++ types for GDB, the GNU debugger.    Copyright 1986, 1988, 1989, 1991 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_comment
comment|/* Binary File Description */
end_comment

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|"c-lang.h"
end_include

begin_include
include|#
directive|include
file|"typeprint.h"
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_decl_stmt
specifier|static
name|void
name|c_type_print_args
name|PARAMS
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|,
name|GDB_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|c_type_print_varspec_suffix
name|PARAMS
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|,
name|GDB_FILE
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cp_type_print_derivation_info
name|PARAMS
argument_list|(
operator|(
name|GDB_FILE
operator|*
operator|,
expr|struct
name|type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|c_type_print_varspec_prefix
name|PARAMS
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|,
name|GDB_FILE
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|c_type_print_base
name|PARAMS
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|,
name|GDB_FILE
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Print a description of a type in the format of a    typedef for the current language.    NEW is the new name for a type TYPE. */
end_comment

begin_function
name|void
name|c_typedef_print
parameter_list|(
name|type
parameter_list|,
name|new
parameter_list|,
name|stream
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|struct
name|symbol
modifier|*
name|new
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
block|{
switch|switch
condition|(
name|current_language
operator|->
name|la_language
condition|)
block|{
ifdef|#
directive|ifdef
name|_LANG_c
case|case
name|language_c
case|:
case|case
name|language_cplus
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"typedef "
argument_list|)
expr_stmt|;
name|type_print
argument_list|(
name|type
argument_list|,
literal|""
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_NAME
argument_list|(
operator|(
name|SYMBOL_TYPE
argument_list|(
name|new
argument_list|)
operator|)
argument_list|)
operator|==
literal|0
operator|||
operator|!
name|STREQ
argument_list|(
name|TYPE_NAME
argument_list|(
operator|(
name|SYMBOL_TYPE
argument_list|(
name|new
argument_list|)
operator|)
argument_list|)
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|new
argument_list|)
argument_list|)
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" %s"
argument_list|,
name|SYMBOL_SOURCE_NAME
argument_list|(
name|new
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|_LANG_m2
case|case
name|language_m2
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"TYPE "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_NAME
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|new
argument_list|)
argument_list|)
operator|||
operator|!
name|STREQ
argument_list|(
name|TYPE_NAME
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|new
argument_list|)
argument_list|)
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|new
argument_list|)
argument_list|)
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%s = "
argument_list|,
name|SYMBOL_SOURCE_NAME
argument_list|(
name|new
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<builtin> = "
argument_list|)
expr_stmt|;
name|type_print
argument_list|(
name|type
argument_list|,
literal|""
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|_LANG_chill
case|case
name|language_chill
case|:
name|error
argument_list|(
literal|"Missing Chill support in function c_typedef_print."
argument_list|)
expr_stmt|;
comment|/*FIXME*/
endif|#
directive|endif
default|default:
name|error
argument_list|(
literal|"Language not supported."
argument_list|)
expr_stmt|;
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|";\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* LEVEL is the depth to indent lines by.  */
end_comment

begin_function
name|void
name|c_print_type
parameter_list|(
name|type
parameter_list|,
name|varstring
parameter_list|,
name|stream
parameter_list|,
name|show
parameter_list|,
name|level
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|char
modifier|*
name|varstring
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|show
decl_stmt|;
name|int
name|level
decl_stmt|;
block|{
specifier|register
name|enum
name|type_code
name|code
decl_stmt|;
name|int
name|demangled_args
decl_stmt|;
name|c_type_print_base
argument_list|(
name|type
argument_list|,
name|stream
argument_list|,
name|show
argument_list|,
name|level
argument_list|)
expr_stmt|;
name|code
operator|=
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|varstring
operator|!=
name|NULL
operator|&&
operator|*
name|varstring
operator|!=
literal|'\0'
operator|)
operator|||
comment|/* Need a space if going to print stars or brackets; 	 but not if we will print just a type name.  */
operator|(
operator|(
name|show
operator|>
literal|0
operator|||
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|code
operator|==
name|TYPE_CODE_PTR
operator|||
name|code
operator|==
name|TYPE_CODE_FUNC
operator|||
name|code
operator|==
name|TYPE_CODE_METHOD
operator|||
name|code
operator|==
name|TYPE_CODE_ARRAY
operator|||
name|code
operator|==
name|TYPE_CODE_MEMBER
operator|||
name|code
operator|==
name|TYPE_CODE_REF
operator|)
operator|)
condition|)
name|fputs_filtered
argument_list|(
literal|" "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|c_type_print_varspec_prefix
argument_list|(
name|type
argument_list|,
name|stream
argument_list|,
name|show
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|varstring
argument_list|,
name|stream
argument_list|)
expr_stmt|;
comment|/* For demangled function names, we have the arglist as part of the name,      so don't print an additional pair of ()'s */
name|demangled_args
operator|=
name|varstring
index|[
name|strlen
argument_list|(
name|varstring
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|')'
expr_stmt|;
name|c_type_print_varspec_suffix
argument_list|(
name|type
argument_list|,
name|stream
argument_list|,
name|show
argument_list|,
literal|0
argument_list|,
name|demangled_args
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print the C++ method arguments ARGS to the file STREAM.  */
end_comment

begin_function
name|void
name|cp_type_print_method_args
parameter_list|(
name|args
parameter_list|,
name|prefix
parameter_list|,
name|varstring
parameter_list|,
name|staticp
parameter_list|,
name|stream
parameter_list|)
name|struct
name|type
modifier|*
modifier|*
name|args
decl_stmt|;
name|char
modifier|*
name|prefix
decl_stmt|;
name|char
modifier|*
name|varstring
decl_stmt|;
name|int
name|staticp
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|fprintf_symbol_filtered
argument_list|(
name|stream
argument_list|,
name|prefix
argument_list|,
name|language_cplus
argument_list|,
name|DMGL_ANSI
argument_list|)
expr_stmt|;
name|fprintf_symbol_filtered
argument_list|(
name|stream
argument_list|,
name|varstring
argument_list|,
name|language_cplus
argument_list|,
name|DMGL_ANSI
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|" ("
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|&&
name|args
index|[
operator|!
name|staticp
index|]
operator|&&
name|args
index|[
operator|!
name|staticp
index|]
operator|->
name|code
operator|!=
name|TYPE_CODE_VOID
condition|)
block|{
name|i
operator|=
operator|!
name|staticp
expr_stmt|;
comment|/* skip the class variable */
while|while
condition|(
literal|1
condition|)
block|{
name|type_print
argument_list|(
name|args
index|[
name|i
operator|++
index|]
argument_list|,
literal|""
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|args
index|[
name|i
index|]
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" ..."
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|args
index|[
name|i
index|]
operator|->
name|code
operator|!=
name|TYPE_CODE_VOID
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
block|}
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If TYPE is a derived type, then print out derivation information.    Print only the actual base classes of this type, not the base classes    of the base classes.  I.E.  for the derivation hierarchy:  	class A { int a; }; 	class B : public A {int b; }; 	class C : public B {int c; };     Print the type of class C as:     	class C : public B { 		int c; 	}     Not as the following (like gdb used to), which is not legal C++ syntax for    derived types and may be confused with the multiple inheritance form:  	class C : public B : public A { 		int c; 	}     In general, gdb should try to print the types as closely as possible to    the form that they appear in the source code. */
end_comment

begin_function
specifier|static
name|void
name|cp_type_print_derivation_info
parameter_list|(
name|stream
parameter_list|,
name|type
parameter_list|)
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|fputs_filtered
argument_list|(
name|i
operator|==
literal|0
condition|?
literal|": "
else|:
literal|", "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%s%s "
argument_list|,
name|BASETYPE_VIA_PUBLIC
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|?
literal|"public"
else|:
literal|"private"
argument_list|,
name|BASETYPE_VIA_VIRTUAL
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|?
literal|" virtual"
else|:
literal|""
argument_list|)
expr_stmt|;
name|name
operator|=
name|type_name_no_tag
argument_list|(
name|TYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|name
condition|?
name|name
else|:
literal|"(null)"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|" "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print any asterisks or open-parentheses needed before the    variable name (to describe its type).     On outermost call, pass 0 for PASSED_A_PTR.    On outermost call, SHOW> 0 means should ignore    any typename for TYPE and show its details.    SHOW is always zero on recursive calls.  */
end_comment

begin_function
name|void
name|c_type_print_varspec_prefix
parameter_list|(
name|type
parameter_list|,
name|stream
parameter_list|,
name|show
parameter_list|,
name|passed_a_ptr
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|show
decl_stmt|;
name|int
name|passed_a_ptr
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|type
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|&&
name|show
operator|<=
literal|0
condition|)
return|return;
name|QUIT
expr_stmt|;
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_PTR
case|:
name|c_type_print_varspec_prefix
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_MEMBER
case|:
if|if
condition|(
name|passed_a_ptr
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|c_type_print_varspec_prefix
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|name
operator|=
name|type_name_no_tag
argument_list|(
name|TYPE_DOMAIN_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
name|fputs_filtered
argument_list|(
name|name
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|c_type_print_base
argument_list|(
name|TYPE_DOMAIN_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
name|passed_a_ptr
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"::"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_METHOD
case|:
if|if
condition|(
name|passed_a_ptr
condition|)
name|fprintf_unfiltered
argument_list|(
name|stream
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|c_type_print_varspec_prefix
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|passed_a_ptr
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|c_type_print_base
argument_list|(
name|TYPE_DOMAIN_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
name|passed_a_ptr
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"::"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_CODE_REF
case|:
name|c_type_print_varspec_prefix
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"&"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_FUNC
case|:
name|c_type_print_varspec_prefix
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|passed_a_ptr
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_ARRAY
case|:
name|c_type_print_varspec_prefix
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|passed_a_ptr
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_UNDEF
case|:
case|case
name|TYPE_CODE_STRUCT
case|:
case|case
name|TYPE_CODE_UNION
case|:
case|case
name|TYPE_CODE_ENUM
case|:
case|case
name|TYPE_CODE_INT
case|:
case|case
name|TYPE_CODE_FLT
case|:
case|case
name|TYPE_CODE_VOID
case|:
case|case
name|TYPE_CODE_ERROR
case|:
case|case
name|TYPE_CODE_CHAR
case|:
case|case
name|TYPE_CODE_BOOL
case|:
case|case
name|TYPE_CODE_SET
case|:
case|case
name|TYPE_CODE_RANGE
case|:
case|case
name|TYPE_CODE_STRING
case|:
case|case
name|TYPE_CODE_BITSTRING
case|:
comment|/* These types need no prefix.  They are listed here so that 	 gcc -Wall will reveal any types that haven't been handled.  */
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|c_type_print_args
parameter_list|(
name|type
parameter_list|,
name|stream
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|struct
name|type
modifier|*
modifier|*
name|args
decl_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|args
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|args
index|[
literal|1
index|]
operator|==
name|NULL
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"..."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|args
index|[
name|i
index|]
operator|!=
name|NULL
operator|&&
name|args
index|[
name|i
index|]
operator|->
name|code
operator|!=
name|TYPE_CODE_VOID
condition|;
name|i
operator|++
control|)
block|{
name|c_print_type
argument_list|(
name|args
index|[
name|i
index|]
argument_list|,
literal|""
argument_list|,
name|stream
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
index|[
name|i
operator|+
literal|1
index|]
operator|==
name|NULL
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"..."
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|args
index|[
name|i
operator|+
literal|1
index|]
operator|->
name|code
operator|!=
name|TYPE_CODE_VOID
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|"    "
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print any array sizes, function arguments or close parentheses    needed after the variable name (to describe its type).    Args work like c_type_print_varspec_prefix.  */
end_comment

begin_function
specifier|static
name|void
name|c_type_print_varspec_suffix
parameter_list|(
name|type
parameter_list|,
name|stream
parameter_list|,
name|show
parameter_list|,
name|passed_a_ptr
parameter_list|,
name|demangled_args
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|show
decl_stmt|;
name|int
name|passed_a_ptr
decl_stmt|;
name|int
name|demangled_args
decl_stmt|;
block|{
if|if
condition|(
name|type
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|&&
name|show
operator|<=
literal|0
condition|)
return|return;
name|QUIT
expr_stmt|;
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_ARRAY
case|:
if|if
condition|(
name|passed_a_ptr
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"["
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|>
literal|0
operator|&&
name|TYPE_LENGTH
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|>
literal|0
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%d"
argument_list|,
operator|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|/
name|TYPE_LENGTH
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"]"
argument_list|)
expr_stmt|;
name|c_type_print_varspec_suffix
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_MEMBER
case|:
if|if
condition|(
name|passed_a_ptr
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
name|c_type_print_varspec_suffix
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_METHOD
case|:
if|if
condition|(
name|passed_a_ptr
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
name|c_type_print_varspec_suffix
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|passed_a_ptr
condition|)
block|{
name|c_type_print_args
argument_list|(
name|type
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_CODE_PTR
case|:
case|case
name|TYPE_CODE_REF
case|:
name|c_type_print_varspec_suffix
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_FUNC
case|:
if|if
condition|(
name|passed_a_ptr
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|demangled_args
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"()"
argument_list|)
expr_stmt|;
name|c_type_print_varspec_suffix
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
name|passed_a_ptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_UNDEF
case|:
case|case
name|TYPE_CODE_STRUCT
case|:
case|case
name|TYPE_CODE_UNION
case|:
case|case
name|TYPE_CODE_ENUM
case|:
case|case
name|TYPE_CODE_INT
case|:
case|case
name|TYPE_CODE_FLT
case|:
case|case
name|TYPE_CODE_VOID
case|:
case|case
name|TYPE_CODE_ERROR
case|:
case|case
name|TYPE_CODE_CHAR
case|:
case|case
name|TYPE_CODE_BOOL
case|:
case|case
name|TYPE_CODE_SET
case|:
case|case
name|TYPE_CODE_RANGE
case|:
case|case
name|TYPE_CODE_STRING
case|:
case|case
name|TYPE_CODE_BITSTRING
case|:
comment|/* These types do not need a suffix.  They are listed so that 	 gcc -Wall will report types that may not have been considered.  */
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Print the name of the type (or the ultimate pointer target,    function value or array element), or the description of a    structure or union.     SHOW positive means print details about the type (e.g. enum values),    and print structure elements passing SHOW - 1 for show.    SHOW negative means just print the type name or struct tag if there is one.    If there is no name, print something sensible but concise like    "struct {...}".    SHOW zero means just print the type name or struct tag if there is one.    If there is no name, print something sensible but not as concise like    "struct {int x; int y;}".     LEVEL is the number of spaces to indent by.    We increase it for some recursive calls.  */
end_comment

begin_function
name|void
name|c_type_print_base
parameter_list|(
name|type
parameter_list|,
name|stream
parameter_list|,
name|show
parameter_list|,
name|level
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|show
decl_stmt|;
name|int
name|level
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
specifier|register
name|int
name|lastval
decl_stmt|;
name|char
modifier|*
name|mangled_name
decl_stmt|;
name|char
modifier|*
name|demangled_name
decl_stmt|;
enum|enum
block|{
name|s_none
block|,
name|s_public
block|,
name|s_private
block|,
name|s_protected
block|}
name|section_type
enum|;
name|QUIT
expr_stmt|;
name|wrap_here
argument_list|(
literal|"    "
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|"<type unknown>"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* When SHOW is zero or less, and there is a valid type name, then always      just print the type name directly from the type.  */
comment|/* If we have "typedef struct foo {. . .} bar;" do we want to print it      as "struct foo" or as "bar"?  Pick the latter, because C++ folk tend      to expect things like "class5 *foo" rather than "struct class5 *foo".  */
if|if
condition|(
name|show
operator|<=
literal|0
operator|&&
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|fputs_filtered
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
block|}
name|check_stub_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_ARRAY
case|:
case|case
name|TYPE_CODE_PTR
case|:
case|case
name|TYPE_CODE_MEMBER
case|:
case|case
name|TYPE_CODE_REF
case|:
case|case
name|TYPE_CODE_FUNC
case|:
case|case
name|TYPE_CODE_METHOD
case|:
name|c_type_print_base
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
name|show
argument_list|,
name|level
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_STRUCT
case|:
if|if
condition|(
name|HAVE_CPLUS_STRUCT
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"class "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"struct "
argument_list|)
expr_stmt|;
block|}
goto|goto
name|struct_union
goto|;
case|case
name|TYPE_CODE_UNION
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"union "
argument_list|)
expr_stmt|;
name|struct_union
label|:
if|if
condition|(
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|fputs_filtered
argument_list|(
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|show
operator|>
literal|0
condition|)
name|fputs_filtered
argument_list|(
literal|" "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
name|wrap_here
argument_list|(
literal|"    "
argument_list|)
expr_stmt|;
if|if
condition|(
name|show
operator|<
literal|0
condition|)
block|{
comment|/* If we just printed a tag name, no need to print anything else.  */
if|if
condition|(
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
operator|==
name|NULL
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"{...}"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|show
operator|>
literal|0
operator|||
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|cp_type_print_derivation_info
argument_list|(
name|stream
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"{\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|TYPE_NFN_FIELDS
argument_list|(
name|type
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator|&
name|TYPE_FLAG_STUB
condition|)
name|fprintfi_filtered
argument_list|(
name|level
operator|+
literal|4
argument_list|,
name|stream
argument_list|,
literal|"<incomplete type>\n"
argument_list|)
expr_stmt|;
else|else
name|fprintfi_filtered
argument_list|(
name|level
operator|+
literal|4
argument_list|,
name|stream
argument_list|,
literal|"<no data fields>\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Start off with no specific section type, so we can print 	     one for the first field we find, and use that section type 	     thereafter until we find another type. */
name|section_type
operator|=
name|s_none
expr_stmt|;
comment|/* If there is a base class for this type, 	     do not print the field that it occupies.  */
name|len
operator|=
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
comment|/* Don't print out virtual function table.  */
if|if
condition|(
operator|(
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
operator|)
index|[
literal|5
index|]
operator|==
name|CPLUS_MARKER
operator|&&
operator|!
name|strncmp
argument_list|(
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
literal|"_vptr"
argument_list|,
literal|5
argument_list|)
condition|)
continue|continue;
comment|/* If this is a C++ class we can print the various C++ section 		 labels. */
if|if
condition|(
name|HAVE_CPLUS_STRUCT
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_FIELD_PROTECTED
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
if|if
condition|(
name|section_type
operator|!=
name|s_protected
condition|)
block|{
name|section_type
operator|=
name|s_protected
expr_stmt|;
name|fprintfi_filtered
argument_list|(
name|level
operator|+
literal|2
argument_list|,
name|stream
argument_list|,
literal|"protected:\n"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TYPE_FIELD_PRIVATE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
if|if
condition|(
name|section_type
operator|!=
name|s_private
condition|)
block|{
name|section_type
operator|=
name|s_private
expr_stmt|;
name|fprintfi_filtered
argument_list|(
name|level
operator|+
literal|2
argument_list|,
name|stream
argument_list|,
literal|"private:\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|section_type
operator|!=
name|s_public
condition|)
block|{
name|section_type
operator|=
name|s_public
expr_stmt|;
name|fprintfi_filtered
argument_list|(
name|level
operator|+
literal|2
argument_list|,
name|stream
argument_list|,
literal|"public:\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|print_spaces_filtered
argument_list|(
name|level
operator|+
literal|4
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_FIELD_STATIC
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"static "
argument_list|)
expr_stmt|;
block|}
name|c_print_type
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|stream
argument_list|,
name|show
operator|-
literal|1
argument_list|,
name|level
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_FIELD_STATIC
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
operator|&&
name|TYPE_FIELD_PACKED
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
comment|/* It is a bitfield.  This code does not attempt 		     to look at the bitpos and reconstruct filler, 		     unnamed fields.  This would lead to misleading 		     results if the compiler does not put out fields 		     for such things (I don't know what it does).  */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" : %d"
argument_list|,
name|TYPE_FIELD_BITSIZE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|";\n"
argument_list|)
expr_stmt|;
block|}
comment|/* If there are both fields and methods, put a space between. */
name|len
operator|=
name|TYPE_NFN_FIELDS
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|&&
name|section_type
operator|!=
name|s_none
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* C++: print out the methods */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|fn_field
modifier|*
name|f
init|=
name|TYPE_FN_FIELDLIST1
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|int
name|j
decl_stmt|,
name|len2
init|=
name|TYPE_FN_FIELDLIST_LENGTH
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|char
modifier|*
name|method_name
init|=
name|TYPE_FN_FIELDLIST_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|type_name_no_tag
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|is_constructor
init|=
name|name
operator|&&
name|STREQ
argument_list|(
name|method_name
argument_list|,
name|name
argument_list|)
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|len2
condition|;
name|j
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
if|if
condition|(
name|TYPE_FN_FIELD_PROTECTED
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
condition|)
block|{
if|if
condition|(
name|section_type
operator|!=
name|s_protected
condition|)
block|{
name|section_type
operator|=
name|s_protected
expr_stmt|;
name|fprintfi_filtered
argument_list|(
name|level
operator|+
literal|2
argument_list|,
name|stream
argument_list|,
literal|"protected:\n"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TYPE_FN_FIELD_PRIVATE
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
condition|)
block|{
if|if
condition|(
name|section_type
operator|!=
name|s_private
condition|)
block|{
name|section_type
operator|=
name|s_private
expr_stmt|;
name|fprintfi_filtered
argument_list|(
name|level
operator|+
literal|2
argument_list|,
name|stream
argument_list|,
literal|"private:\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|section_type
operator|!=
name|s_public
condition|)
block|{
name|section_type
operator|=
name|s_public
expr_stmt|;
name|fprintfi_filtered
argument_list|(
name|level
operator|+
literal|2
argument_list|,
name|stream
argument_list|,
literal|"public:\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|print_spaces_filtered
argument_list|(
name|level
operator|+
literal|4
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_FN_FIELD_VIRTUAL_P
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"virtual "
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_FN_FIELD_STATIC_P
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"static "
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_TARGET_TYPE
argument_list|(
name|TYPE_FN_FIELD_TYPE
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Keep GDB from crashing here.  */
name|fprintf_unfiltered
argument_list|(
name|stream
argument_list|,
literal|"<undefined type> %s;\n"
argument_list|,
name|TYPE_FN_FIELD_PHYSNAME
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|!
name|is_constructor
condition|)
block|{
name|type_print
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|TYPE_FN_FIELD_TYPE
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
argument_list|)
argument_list|,
literal|""
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|" "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_FN_FIELD_STUB
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
condition|)
block|{
comment|/* Build something we can demangle.  */
name|mangled_name
operator|=
name|gdb_mangle_name
argument_list|(
name|type
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|demangled_name
operator|=
name|cplus_demangle
argument_list|(
name|mangled_name
argument_list|,
name|DMGL_ANSI
operator||
name|DMGL_PARAMS
argument_list|)
expr_stmt|;
if|if
condition|(
name|demangled_name
operator|==
name|NULL
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<badly mangled name %s>"
argument_list|,
name|mangled_name
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|demangled_no_class
init|=
name|strchr
argument_list|(
name|demangled_name
argument_list|,
literal|':'
argument_list|)
decl_stmt|;
if|if
condition|(
name|demangled_no_class
operator|==
name|NULL
condition|)
name|demangled_no_class
operator|=
name|demangled_name
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|*
operator|++
name|demangled_no_class
operator|==
literal|':'
condition|)
operator|++
name|demangled_no_class
expr_stmt|;
block|}
name|fputs_filtered
argument_list|(
name|demangled_no_class
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|demangled_name
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|mangled_name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_FN_FIELD_PHYSNAME
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|TYPE_FN_FIELD_PHYSNAME
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
index|[
literal|1
index|]
operator|==
name|CPLUS_MARKER
condition|)
name|cp_type_print_method_args
argument_list|(
name|TYPE_FN_FIELD_ARGS
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
operator|+
literal|1
argument_list|,
literal|"~"
argument_list|,
name|method_name
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|cp_type_print_method_args
argument_list|(
name|TYPE_FN_FIELD_ARGS
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
argument_list|,
literal|""
argument_list|,
name|method_name
argument_list|,
name|TYPE_FN_FIELD_STATIC_P
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|";\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintfi_filtered
argument_list|(
name|level
argument_list|,
name|stream
argument_list|,
literal|"}"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_CODE_ENUM
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"enum "
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|fputs_filtered
argument_list|(
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|show
operator|>
literal|0
condition|)
name|fputs_filtered
argument_list|(
literal|" "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
name|wrap_here
argument_list|(
literal|"    "
argument_list|)
expr_stmt|;
if|if
condition|(
name|show
operator|<
literal|0
condition|)
block|{
comment|/* If we just printed a tag name, no need to print anything else.  */
if|if
condition|(
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
operator|==
name|NULL
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"{...}"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|show
operator|>
literal|0
operator|||
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"{"
argument_list|)
expr_stmt|;
name|len
operator|=
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|lastval
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
if|if
condition|(
name|i
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|"    "
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastval
operator|!=
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" = %d"
argument_list|,
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|lastval
operator|=
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|lastval
operator|++
expr_stmt|;
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"}"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_CODE_VOID
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"void"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_UNDEF
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"struct<unknown>"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_ERROR
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<unknown type>"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_RANGE
case|:
comment|/* This should not occur */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<range type>"
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Handle types not explicitly handled by the other cases, 	 such as fundamental types.  For these, just print whatever 	 the type name is, as recorded in the type itself.  If there 	 is no type name, then complain. */
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|fputs_filtered
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* At least for dump_symtab, it is important that this not be 	     an error ().  */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<invalid type code %d>"
argument_list|,
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

end_unit

