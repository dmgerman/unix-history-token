begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Core dump and executable file functions below target vector, for GDB.    Copyright 1986, 1987, 1989, 1991, 1992 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.   $FreeBSD$ */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|KERNEL_DEBUG
end_ifdef

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_comment
comment|/* required by inferior.h */
end_comment

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_decl_stmt
specifier|static
name|void
name|kcore_files_info
name|PARAMS
argument_list|(
operator|(
expr|struct
name|target_ops
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|kcore_close
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|get_kcore_registers
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|xfer_mem
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
operator|,
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|,
expr|struct
name|target_ops
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|xfer_umem
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
operator|,
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|core_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|core_kd
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|proc
modifier|*
name|cur_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|kernel_start
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Read the "thing" at kernel address 'addr' into the space pointed to  * by point.  The length of the "thing" is determined by the type of p.  * Result is non-zero if transfer fails.  */
end_comment

begin_define
define|#
directive|define
name|kvread
parameter_list|(
name|addr
parameter_list|,
name|p
parameter_list|)
define|\
value|(target_read_memory((CORE_ADDR)(addr), (char *)(p), sizeof(*(p))))
end_define

begin_extern
extern|extern read_pcb (int
operator|,
extern|CORE_ADDR
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_function
name|CORE_ADDR
name|ksym_lookup
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|minimal_symbol
modifier|*
name|sym
decl_stmt|;
name|sym
operator|=
name|lookup_minimal_symbol
argument_list|(
name|name
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"kernel symbol `%s' not found."
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|proc
modifier|*
name|curProc
parameter_list|()
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|CORE_ADDR
name|addr
init|=
name|ksym_lookup
argument_list|(
literal|"curproc"
argument_list|)
decl_stmt|;
if|if
condition|(
name|kvread
argument_list|(
name|addr
argument_list|,
operator|&
name|p
argument_list|)
condition|)
name|error
argument_list|(
literal|"cannot read proc pointer at %x\n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/*  * Set the process context to that of the proc structure at  * system address paddr.  */
end_comment

begin_function
specifier|static
name|int
name|set_proc_context
parameter_list|(
name|paddr
parameter_list|)
name|CORE_ADDR
name|paddr
decl_stmt|;
block|{
name|struct
name|proc
name|p
decl_stmt|;
if|if
condition|(
name|paddr
operator|<
name|kernel_start
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|cur_proc
operator|=
operator|(
expr|struct
name|proc
operator|*
operator|)
name|paddr
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
name|set_kernel_boundaries
argument_list|(
name|cur_proc
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Fetch all registers from core file */
name|target_fetch_registers
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Now, set up the frame cache, and print the top of stack */
name|flush_cached_frames
argument_list|()
expr_stmt|;
name|set_current_frame
argument_list|(
name|create_new_frame
argument_list|(
name|read_fp
argument_list|()
argument_list|,
name|read_pc
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|select_frame
argument_list|(
name|get_current_frame
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Discard all vestiges of any previous core file    and mark data and stack spaces as empty.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|kcore_close
parameter_list|(
name|quitting
parameter_list|)
name|int
name|quitting
decl_stmt|;
block|{
name|inferior_pid
operator|=
literal|0
expr_stmt|;
comment|/* Avoid confusion from thread stuff */
if|if
condition|(
name|core_kd
condition|)
block|{
name|kvm_close
argument_list|(
name|core_kd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|core_file
argument_list|)
expr_stmt|;
name|core_file
operator|=
name|NULL
expr_stmt|;
name|core_kd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This routine opens and sets up the core file bfd */
end_comment

begin_function
name|void
name|kcore_open
parameter_list|(
name|filename
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|int
name|ontop
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|struct
name|pcb
name|pcb
decl_stmt|;
name|target_preopen
argument_list|(
name|from_tty
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|filename
condition|)
block|{
comment|/*error (core_kd?*/
name|error
argument_list|(
operator|(
name|core_kd
operator|>=
literal|0
operator|)
condition|?
literal|"No core file specified.  (Use `detach' to stop debugging a core file.)"
else|:
literal|"No core file specified."
argument_list|)
expr_stmt|;
block|}
name|filename
operator|=
name|tilde_expand
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|filename
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
block|{
name|cp
operator|=
name|concat
argument_list|(
name|current_directory
argument_list|,
literal|"/"
argument_list|,
name|filename
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|filename
operator|=
name|cp
expr_stmt|;
block|}
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|filename
argument_list|)
expr_stmt|;
comment|/*        * gdb doesn't really do anything if the exec-file couldn't        * be opened (in that case exec_bfd is NULL). Usually that's        * no big deal, but kvm_open needs the exec-file's name,        * which results in dereferencing a NULL pointer, a real NO-NO !        * So, check here if the open of the exec-file succeeded.        */
if|if
condition|(
name|exec_bfd
operator|==
name|NULL
condition|)
comment|/* the open failed */
name|error
argument_list|(
literal|"kgdb could not open the exec-file, please check the name you used !"
argument_list|)
expr_stmt|;
name|core_kd
operator|=
name|kvm_open
argument_list|(
name|exec_bfd
operator|->
name|filename
argument_list|,
name|filename
argument_list|,
name|NULL
argument_list|,
name|kernel_writablecore
condition|?
name|O_RDWR
else|:
name|O_RDONLY
argument_list|,
literal|"kgdb: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|core_kd
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
comment|/* Looks semi-reasonable. Toss the old core file and work on the new. */
name|discard_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
comment|/* Don't free filename any more */
name|core_file
operator|=
name|filename
expr_stmt|;
name|unpush_target
argument_list|(
operator|&
name|kcore_ops
argument_list|)
expr_stmt|;
name|ontop
operator|=
operator|!
name|push_target
argument_list|(
operator|&
name|kcore_ops
argument_list|)
expr_stmt|;
name|kernel_start
operator|=
name|bfd_get_start_address
argument_list|(
name|exec_bfd
argument_list|)
expr_stmt|;
comment|/* XXX */
comment|/* print out the panic string if there is one */
if|if
condition|(
name|kvread
argument_list|(
name|ksym_lookup
argument_list|(
literal|"panicstr"
argument_list|)
argument_list|,
operator|&
name|addr
argument_list|)
operator|==
literal|0
operator|&&
name|addr
operator|!=
literal|0
operator|&&
name|target_read_memory
argument_list|(
name|addr
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|cp
operator|=
name|buf
init|;
name|cp
operator|<
operator|&
name|buf
index|[
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
index|]
operator|&&
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
if|if
condition|(
operator|!
name|isascii
argument_list|(
operator|*
name|cp
argument_list|)
operator|||
operator|(
operator|!
name|isprint
argument_list|(
operator|*
name|cp
argument_list|)
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
operator|)
condition|)
operator|*
name|cp
operator|=
literal|'?'
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|printf
argument_list|(
literal|"panic: %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ontop
condition|)
block|{
name|warning
argument_list|(
literal|"you won't be able to access this core file until you terminate\n\ your %s; do ``info files''"
argument_list|,
name|current_target
operator|->
name|to_longname
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* we may need this later */
name|cur_proc
operator|=
operator|(
expr|struct
name|proc
operator|*
operator|)
name|curProc
argument_list|()
expr_stmt|;
comment|/* Now, set up the frame cache, and print the top of stack */
name|flush_cached_frames
argument_list|()
expr_stmt|;
name|set_current_frame
argument_list|(
name|create_new_frame
argument_list|(
name|read_fp
argument_list|()
argument_list|,
name|read_pc
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|select_frame
argument_list|(
name|get_current_frame
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|print_stack_frame
argument_list|(
name|selected_frame
argument_list|,
name|selected_frame_level
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|kcore_detach
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
if|if
condition|(
name|args
condition|)
name|error
argument_list|(
literal|"Too many arguments"
argument_list|)
expr_stmt|;
name|unpush_target
argument_list|(
operator|&
name|kcore_ops
argument_list|)
expr_stmt|;
name|reinit_frame_cache
argument_list|()
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
name|printf_filtered
argument_list|(
literal|"No kernel core file now.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get the registers out of a core file.  This is the machine-    independent part.  Fetch_core_registers is the machine-dependent    part, typically implemented in the xm-file for each architecture.  */
end_comment

begin_comment
comment|/* We just get all the registers, so we don't use regno.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|get_kcore_registers
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
name|struct
name|user
modifier|*
name|uaddr
decl_stmt|;
comment|/* find the pcb for the current process */
if|if
condition|(
name|kvread
argument_list|(
operator|&
name|cur_proc
operator|->
name|p_addr
argument_list|,
operator|&
name|uaddr
argument_list|)
condition|)
name|error
argument_list|(
literal|"cannot read u area ptr for proc at %#x"
argument_list|,
name|cur_proc
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_pcb
argument_list|(
name|core_kd
argument_list|,
operator|(
name|CORE_ADDR
operator|)
operator|&
name|uaddr
operator|->
name|u_pcb
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"cannot read pcb at %#x"
argument_list|,
operator|&
name|uaddr
operator|->
name|u_pcb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If mourn is being called in all the right places, this could be say    `gdb internal error' (since generic_mourn calls breakpoint_init_inferior).  */
end_comment

begin_function
specifier|static
name|int
name|ignore
parameter_list|(
name|addr
parameter_list|,
name|contents
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
name|char
modifier|*
name|contents
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|kcore_files_info
parameter_list|(
name|t
parameter_list|)
name|struct
name|target_ops
modifier|*
name|t
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"\t`%s'\n"
argument_list|,
name|core_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|xfer_kmem
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|,
name|write
parameter_list|,
name|target
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|write
decl_stmt|;
name|struct
name|target_ops
modifier|*
name|target
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
if|if
condition|(
operator|!
name|memaddr
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|memaddr
operator|<
name|kernel_start
condition|)
return|return
name|xfer_umem
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|,
name|write
argument_list|)
return|;
name|n
operator|=
name|write
condition|?
name|kvm_write
argument_list|(
name|core_kd
argument_list|,
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
else|:
name|kvm_read
argument_list|(
name|core_kd
argument_list|,
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|n
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xfer_umem
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|,
name|write
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|write
decl_stmt|;
comment|/* ignored */
block|{
name|int
name|n
decl_stmt|;
name|struct
name|proc
name|proc
decl_stmt|;
if|if
condition|(
name|kvread
argument_list|(
name|cur_proc
argument_list|,
operator|&
name|proc
argument_list|)
condition|)
name|error
argument_list|(
literal|"cannot read proc at %#x"
argument_list|,
name|cur_proc
argument_list|)
expr_stmt|;
name|n
operator|=
name|kvm_uread
argument_list|(
name|core_kd
argument_list|,
operator|&
name|proc
argument_list|,
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|n
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_proc_cmd
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|CORE_ADDR
name|paddr
decl_stmt|;
if|if
condition|(
operator|!
name|arg
condition|)
name|error_no_arg
argument_list|(
literal|"proc address for new current process"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|kernel_debugging
condition|)
name|error
argument_list|(
literal|"not debugging kernel"
argument_list|)
expr_stmt|;
name|paddr
operator|=
operator|(
name|CORE_ADDR
operator|)
name|parse_and_eval_address
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|set_proc_context
argument_list|(
name|paddr
argument_list|)
condition|)
name|error
argument_list|(
literal|"invalid proc address"
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|struct
name|target_ops
name|kcore_ops
init|=
block|{
literal|"kcore"
block|,
literal|"Kernel core dump file"
block|,
literal|"Use a core file as a target.  Specify the filename of the core file."
block|,
name|kcore_open
block|,
name|kcore_close
block|,
name|find_default_attach
block|,
name|kcore_detach
block|,
literal|0
block|,
literal|0
block|,
comment|/* resume, wait */
name|get_kcore_registers
block|,
literal|0
block|,
literal|0
block|,
comment|/* store_regs, prepare_to_store */
name|xfer_kmem
block|,
name|kcore_files_info
block|,
name|ignore
block|,
name|ignore
block|,
comment|/* core_insert_breakpoint, core_remove_breakpoint, */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* terminal stuff */
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* kill, load, lookup sym */
name|find_default_create_inferior
block|,
literal|0
block|,
comment|/* mourn_inferior */
literal|0
block|,
comment|/* can_run */
literal|0
block|,
comment|/* notice_signals */
name|kcore_stratum
block|,
literal|0
block|,
comment|/* next */
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
comment|/* all mem, mem, stack, regs, exec */
literal|0
block|,
literal|0
block|,
comment|/* section pointers */
name|OPS_MAGIC
block|,
comment|/* Always the last thing */
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|_initialize_kcorelow
parameter_list|()
block|{
name|add_target
argument_list|(
operator|&
name|kcore_ops
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"proc"
argument_list|,
name|class_obscure
argument_list|,
name|set_proc_cmd
argument_list|,
literal|"Set current process context"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* KERNEL_DEBUG */
end_comment

end_unit

