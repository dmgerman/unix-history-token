begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Top level stuff for GDB, the GNU debugger.    Copyright 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994    Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|"top.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"call-cmds.h"
end_include

begin_include
include|#
directive|include
file|"getopt.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|/* R_OK lives in either unistd.h or sys/file.h.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NO_SYS_FILE
end_ifndef

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Temporary variable for SET_TOP_LEVEL.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|top_level_val
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Do a setjmp on error_return and quit_return.  catch_errors is    generally a cleaner way to do this, but main() would look pretty    ugly if it had to use catch_errors each time.  */
end_comment

begin_define
define|#
directive|define
name|SET_TOP_LEVEL
parameter_list|()
define|\
value|(((top_level_val = setjmp (error_return)) \     ? (PTR) 0 : (PTR) memcpy (quit_return, error_return, sizeof (jmp_buf))) \    , top_level_val)
end_define

begin_decl_stmt
specifier|extern
name|void
name|gdb_init
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|count
decl_stmt|;
specifier|static
name|int
name|quiet
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|batch
init|=
literal|0
decl_stmt|;
comment|/* Pointers to various arguments from command line.  */
name|char
modifier|*
name|symarg
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|execarg
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|corearg
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|cdarg
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|ttyarg
init|=
name|NULL
decl_stmt|;
comment|/* These are static so that we can take their address in an initializer.  */
specifier|static
name|int
name|print_help
decl_stmt|;
specifier|static
name|int
name|print_version
decl_stmt|;
comment|/* Pointers to all arguments of --command option.  */
name|char
modifier|*
modifier|*
name|cmdarg
decl_stmt|;
comment|/* Allocated size of cmdarg.  */
name|int
name|cmdsize
decl_stmt|;
comment|/* Number of elements of cmdarg used.  */
name|int
name|ncmd
decl_stmt|;
comment|/* Indices of all arguments of --directory option.  */
name|char
modifier|*
modifier|*
name|dirarg
decl_stmt|;
comment|/* Allocated size.  */
name|int
name|dirsize
decl_stmt|;
comment|/* Number of elements used.  */
name|int
name|ndir
decl_stmt|;
name|struct
name|stat
name|homebuf
decl_stmt|,
name|cwdbuf
decl_stmt|;
name|char
modifier|*
name|homedir
decl_stmt|,
modifier|*
name|homeinit
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* This needs to happen before the first use of malloc.  */
name|init_malloc
argument_list|(
operator|(
name|PTR
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|ALIGN_STACK_ON_STARTUP
argument_list|)
name|i
operator|=
operator|(
name|int
operator|)
operator|&
name|count
operator|&
literal|0x3
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|alloca
argument_list|(
literal|4
operator|-
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If error() is called from initialization code, just exit */
if|if
condition|(
name|SET_TOP_LEVEL
argument_list|()
condition|)
block|{
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|cmdsize
operator|=
literal|1
expr_stmt|;
name|cmdarg
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|cmdsize
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|cmdarg
argument_list|)
argument_list|)
expr_stmt|;
name|ncmd
operator|=
literal|0
expr_stmt|;
name|dirsize
operator|=
literal|1
expr_stmt|;
name|dirarg
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|dirsize
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|dirarg
argument_list|)
argument_list|)
expr_stmt|;
name|ndir
operator|=
literal|0
expr_stmt|;
name|quit_flag
operator|=
literal|0
expr_stmt|;
name|line
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|linesize
argument_list|)
expr_stmt|;
name|line
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Terminate saved (now empty) cmd line */
name|instream
operator|=
name|stdin
expr_stmt|;
name|getcwd
argument_list|(
name|gdb_dirbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|gdb_dirbuf
argument_list|)
argument_list|)
expr_stmt|;
name|current_directory
operator|=
name|gdb_dirbuf
expr_stmt|;
ifdef|#
directive|ifdef
name|KERNEL_DEBUG
if|if
condition|(
name|strstr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"kgdb"
argument_list|)
operator|!=
name|NULL
condition|)
name|kernel_debugging
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* Parse arguments and options.  */
block|{
name|int
name|c
decl_stmt|;
comment|/* When var field is 0, use flag field to record the equivalent        short option (or arbitrary numbers starting at 10 for those        with no equivalent).  */
specifier|static
name|struct
name|option
name|long_options
index|[]
init|=
block|{
block|{
literal|"readnow"
block|,
name|no_argument
block|,
operator|&
name|readnow_symbol_files
block|,
literal|1
block|}
block|,
block|{
literal|"r"
block|,
name|no_argument
block|,
operator|&
name|readnow_symbol_files
block|,
literal|1
block|}
block|,
block|{
literal|"mapped"
block|,
name|no_argument
block|,
operator|&
name|mapped_symbol_files
block|,
literal|1
block|}
block|,
block|{
literal|"m"
block|,
name|no_argument
block|,
operator|&
name|mapped_symbol_files
block|,
literal|1
block|}
block|,
block|{
literal|"quiet"
block|,
name|no_argument
block|,
operator|&
name|quiet
block|,
literal|1
block|}
block|,
block|{
literal|"q"
block|,
name|no_argument
block|,
operator|&
name|quiet
block|,
literal|1
block|}
block|,
block|{
literal|"silent"
block|,
name|no_argument
block|,
operator|&
name|quiet
block|,
literal|1
block|}
block|,
block|{
literal|"nx"
block|,
name|no_argument
block|,
operator|&
name|inhibit_gdbinit
block|,
literal|1
block|}
block|,
block|{
literal|"n"
block|,
name|no_argument
block|,
operator|&
name|inhibit_gdbinit
block|,
literal|1
block|}
block|,
block|{
literal|"batch"
block|,
name|no_argument
block|,
operator|&
name|batch
block|,
literal|1
block|}
block|,
block|{
literal|"epoch"
block|,
name|no_argument
block|,
operator|&
name|epoch_interface
block|,
literal|1
block|}
block|,
comment|/* This is a synonym for "--annotate=1".  --annotate is now preferred, 	   but keep this here for a long time because people will be running 	   emacses which use --fullname.  */
block|{
literal|"fullname"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'f'
block|}
block|,
block|{
literal|"f"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'f'
block|}
block|,
block|{
literal|"annotate"
block|,
name|required_argument
block|,
literal|0
block|,
literal|12
block|}
block|,
block|{
literal|"help"
block|,
name|no_argument
block|,
operator|&
name|print_help
block|,
literal|1
block|}
block|,
block|{
literal|"se"
block|,
name|required_argument
block|,
literal|0
block|,
literal|10
block|}
block|,
block|{
literal|"symbols"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'s'
block|}
block|,
block|{
literal|"s"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'s'
block|}
block|,
block|{
literal|"exec"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'e'
block|}
block|,
block|{
literal|"e"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'e'
block|}
block|,
block|{
literal|"core"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'c'
block|}
block|,
block|{
literal|"c"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'c'
block|}
block|,
block|{
literal|"command"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'x'
block|}
block|,
block|{
literal|"version"
block|,
name|no_argument
block|,
operator|&
name|print_version
block|,
literal|1
block|}
block|,
block|{
literal|"x"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'x'
block|}
block|,
block|{
literal|"directory"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'d'
block|}
block|,
block|{
literal|"cd"
block|,
name|required_argument
block|,
literal|0
block|,
literal|11
block|}
block|,
block|{
literal|"tty"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'t'
block|}
block|,
block|{
literal|"baud"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'b'
block|}
block|,
block|{
literal|"b"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'b'
block|}
block|,
ifdef|#
directive|ifdef
name|KERNEL_DEBUG
block|{
literal|"kernel"
block|,
name|no_argument
block|,
operator|&
name|kernel_debugging
block|,
literal|1
block|}
block|,
block|{
literal|"k"
block|,
name|no_argument
block|,
operator|&
name|kernel_debugging
block|,
literal|1
block|}
block|,
block|{
literal|"wcore"
block|,
name|no_argument
block|,
operator|&
name|kernel_writablecore
block|,
literal|1
block|}
block|,
block|{
literal|"w"
block|,
name|no_argument
block|,
operator|&
name|kernel_writablecore
block|,
literal|1
block|}
block|,
endif|#
directive|endif
comment|/* Allow machine descriptions to add more options... */
ifdef|#
directive|ifdef
name|ADDITIONAL_OPTIONS
name|ADDITIONAL_OPTIONS
endif|#
directive|endif
block|{
literal|0
block|,
name|no_argument
block|,
literal|0
block|,
literal|0
block|}
block|,       }
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|option_index
decl_stmt|;
name|c
operator|=
name|getopt_long_only
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|""
argument_list|,
name|long_options
argument_list|,
operator|&
name|option_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
comment|/* Long option that takes an argument.  */
if|if
condition|(
name|c
operator|==
literal|0
operator|&&
name|long_options
index|[
name|option_index
index|]
operator|.
name|flag
operator|==
literal|0
condition|)
name|c
operator|=
name|long_options
index|[
name|option_index
index|]
operator|.
name|val
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|0
case|:
comment|/* Long option that just sets a flag.  */
break|break;
case|case
literal|10
case|:
name|symarg
operator|=
name|optarg
expr_stmt|;
name|execarg
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|11
case|:
name|cdarg
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|12
case|:
comment|/* FIXME: what if the syntax is wrong (e.g. not digits)?  */
name|annotation_level
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|annotation_level
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|symarg
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|execarg
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|corearg
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|cmdarg
index|[
name|ncmd
operator|++
index|]
operator|=
name|optarg
expr_stmt|;
if|if
condition|(
name|ncmd
operator|>=
name|cmdsize
condition|)
block|{
name|cmdsize
operator|*=
literal|2
expr_stmt|;
name|cmdarg
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cmdarg
argument_list|,
name|cmdsize
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|cmdarg
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'d'
case|:
name|dirarg
index|[
name|ndir
operator|++
index|]
operator|=
name|optarg
expr_stmt|;
if|if
condition|(
name|ndir
operator|>=
name|dirsize
condition|)
block|{
name|dirsize
operator|*=
literal|2
expr_stmt|;
name|dirarg
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dirarg
argument_list|,
name|dirsize
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|dirarg
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'t'
case|:
name|ttyarg
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|quiet
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|i
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
operator|&
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
name|p
operator|==
name|optarg
condition|)
comment|/* Don't use *_filtered or warning() (which relies on                    current_target) until after initialize_all_files(). */
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"warning: could not set baud rate to `%s'.\n"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
else|else
name|baud_rate
operator|=
name|i
expr_stmt|;
block|}
break|break;
ifdef|#
directive|ifdef
name|KERNEL_DEBUG
case|case
literal|'k'
case|:
name|kernel_debugging
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|kernel_writablecore
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ADDITIONAL_OPTION_CASES
name|ADDITIONAL_OPTION_CASES
endif|#
directive|endif
case|case
literal|'?'
case|:
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Use `%s --help' for a complete list of options.\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* OK, that's all the options.  The other arguments are filenames.  */
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|optind
operator|<
name|argc
condition|;
name|optind
operator|++
control|)
switch|switch
condition|(
operator|++
name|count
condition|)
block|{
case|case
literal|1
case|:
name|symarg
operator|=
name|argv
index|[
name|optind
index|]
expr_stmt|;
name|execarg
operator|=
name|argv
index|[
name|optind
index|]
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|corearg
operator|=
name|argv
index|[
name|optind
index|]
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Excess command line arguments ignored. (%s%s)\n"
argument_list|,
name|argv
index|[
name|optind
index|]
argument_list|,
operator|(
name|optind
operator|==
name|argc
operator|-
literal|1
operator|)
condition|?
literal|""
else|:
literal|" ..."
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|batch
condition|)
name|quiet
operator|=
literal|1
expr_stmt|;
block|}
name|gdb_init
argument_list|()
expr_stmt|;
comment|/* Do these (and anything which might call wrap_here or *_filtered)      after initialize_all_files.  */
if|if
condition|(
name|print_version
condition|)
block|{
name|print_gdb_version
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|print_help
condition|)
block|{
comment|/* --version is intentionally not documented here, because we 	 are printing the version here, and the help is long enough 	 already.  */
name|print_gdb_version
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
comment|/* Make sure the output gets printed.  */
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* But don't use *_filtered here.  We don't want to prompt for continue 	 no matter how small the screen or how much we're going to print.  */
name|fputs_unfiltered
argument_list|(
literal|"\ This is the GNU debugger.  Usage:\n\     gdb [options] [executable-file [core-file or process-id]]\n\ Options:\n\   --help             Print this message.\n\   --quiet            Do not print version number on startup.\n\   --fullname         Output information used by emacs-GDB interface.\n\   --epoch            Output information used by epoch emacs-GDB interface.\n\   --batch            Exit after processing options.\n\   --nx               Do not read .gdbinit file.\n\   --tty=TTY          Use TTY for input/output by the program being debugged.\n\   --cd=DIR           Change current directory to DIR.\n\   --directory=DIR    Search for source files in DIR.\n\   --command=FILE     Execute GDB commands from FILE.\n\   --symbols=SYMFILE  Read symbols from SYMFILE.\n\   --exec=EXECFILE    Use EXECFILE as the executable.\n\   --se=FILE          Use FILE as symbol file and executable file.\n\   --core=COREFILE    Analyze the core dump COREFILE.\n\   -b BAUDRATE        Set serial port baud rate used for remote debugging.\n\   --mapped           Use mapped symbol files if supported on this system.\n\   --readnow          Fully read symbol files on first access.\n\ "
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KERNEL_DEBUG
name|fputs_unfiltered
argument_list|(
literal|"\   --kernel           Enable kernel debugging.\n\   --wcore            Make core file writable (only works for /dev/mem).\n\                      This option only works while debugging a kernel !!\n\ "
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* KERNEL_DEBUGGING */
ifdef|#
directive|ifdef
name|ADDITIONAL_OPTION_HELP
name|fputs_unfiltered
argument_list|(
name|ADDITIONAL_OPTION_HELP
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fputs_unfiltered
argument_list|(
literal|"\n\ For more information, type \"help\" from within GDB, or consult the\n\ GDB manual (available as on-line info or a printed manual).\n"
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|quiet
condition|)
block|{
comment|/* Print all the junk at the top, with trailing "..." if we are about 	 to read a symbol file (possibly slowly).  */
name|print_gnu_advertisement
argument_list|()
expr_stmt|;
name|print_gdb_version
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|symarg
condition|)
name|printf_filtered
argument_list|(
literal|".."
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
comment|/* Force to screen during slow operations */
block|}
name|error_pre_print
operator|=
literal|"\n\n"
expr_stmt|;
comment|/* We may get more than one warning, don't double space all of them... */
name|warning_pre_print
operator|=
literal|"\nwarning: "
expr_stmt|;
comment|/* Read and execute $HOME/.gdbinit file, if it exists.  This is done      *before* all the command line arguments are processed; it sets      global parameters, which are independent of what file you are      debugging or what directory you are in.  */
name|homedir
operator|=
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
expr_stmt|;
if|if
condition|(
name|homedir
condition|)
block|{
name|homeinit
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
argument_list|)
operator|+
name|strlen
argument_list|(
name|gdbinit
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|homeinit
argument_list|,
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|homeinit
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|homeinit
argument_list|,
name|gdbinit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|inhibit_gdbinit
operator|&&
name|access
argument_list|(
name|homeinit
argument_list|,
name|R_OK
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|SET_TOP_LEVEL
argument_list|()
condition|)
name|source_command
argument_list|(
name|homeinit
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|do_cleanups
argument_list|(
name|ALL_CLEANUPS
argument_list|)
expr_stmt|;
comment|/* Do stats; no need to do them elsewhere since we'll only 	 need them if homedir is set.  Make sure that they are 	 zero in case one of them fails (this guarantees that they 	 won't match if either exists).  */
name|memset
argument_list|(
operator|&
name|homebuf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|stat
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|cwdbuf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|stat
argument_list|)
argument_list|)
expr_stmt|;
name|stat
argument_list|(
name|homeinit
argument_list|,
operator|&
name|homebuf
argument_list|)
expr_stmt|;
name|stat
argument_list|(
name|gdbinit
argument_list|,
operator|&
name|cwdbuf
argument_list|)
expr_stmt|;
comment|/* We'll only need this if 				       homedir was set.  */
block|}
comment|/* Now perform all the actions indicated by the arguments.  */
if|if
condition|(
name|cdarg
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|SET_TOP_LEVEL
argument_list|()
condition|)
block|{
name|cd_command
argument_list|(
name|cdarg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|do_cleanups
argument_list|(
name|ALL_CLEANUPS
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ndir
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|SET_TOP_LEVEL
argument_list|()
condition|)
name|directory_command
argument_list|(
name|dirarg
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|dirarg
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|ALL_CLEANUPS
argument_list|)
expr_stmt|;
if|if
condition|(
name|execarg
operator|!=
name|NULL
operator|&&
name|symarg
operator|!=
name|NULL
operator|&&
name|STREQ
argument_list|(
name|execarg
argument_list|,
name|symarg
argument_list|)
condition|)
block|{
comment|/* The exec file and the symbol-file are the same.  If we can't open 	 it, better only print one error message.  */
if|if
condition|(
operator|!
name|SET_TOP_LEVEL
argument_list|()
condition|)
block|{
name|exec_file_command
argument_list|(
name|execarg
argument_list|,
operator|!
name|batch
argument_list|)
expr_stmt|;
name|symbol_file_command
argument_list|(
name|symarg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|execarg
operator|!=
name|NULL
condition|)
if|if
condition|(
operator|!
name|SET_TOP_LEVEL
argument_list|()
condition|)
name|exec_file_command
argument_list|(
name|execarg
argument_list|,
operator|!
name|batch
argument_list|)
expr_stmt|;
if|if
condition|(
name|symarg
operator|!=
name|NULL
condition|)
if|if
condition|(
operator|!
name|SET_TOP_LEVEL
argument_list|()
condition|)
name|symbol_file_command
argument_list|(
name|symarg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|do_cleanups
argument_list|(
name|ALL_CLEANUPS
argument_list|)
expr_stmt|;
comment|/* After the symbol file has been read, print a newline to get us      beyond the copyright line...  But errors should still set off      the error message with a (single) blank line.  */
if|if
condition|(
operator|!
name|quiet
condition|)
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|error_pre_print
operator|=
literal|"\n"
expr_stmt|;
name|warning_pre_print
operator|=
literal|"\nwarning: "
expr_stmt|;
if|if
condition|(
name|corearg
operator|!=
name|NULL
condition|)
if|if
condition|(
operator|!
name|SET_TOP_LEVEL
argument_list|()
condition|)
name|core_file_command
argument_list|(
name|corearg
argument_list|,
operator|!
name|batch
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|isdigit
argument_list|(
name|corearg
index|[
literal|0
index|]
argument_list|)
operator|&&
operator|!
name|SET_TOP_LEVEL
argument_list|()
condition|)
name|attach_command
argument_list|(
name|corearg
argument_list|,
operator|!
name|batch
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|ALL_CLEANUPS
argument_list|)
expr_stmt|;
if|if
condition|(
name|ttyarg
operator|!=
name|NULL
condition|)
if|if
condition|(
operator|!
name|SET_TOP_LEVEL
argument_list|()
condition|)
name|tty_command
argument_list|(
name|ttyarg
argument_list|,
operator|!
name|batch
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|ALL_CLEANUPS
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ADDITIONAL_OPTION_HANDLER
name|ADDITIONAL_OPTION_HANDLER
expr_stmt|;
endif|#
directive|endif
comment|/* Error messages should no longer be distinguished with extra output. */
name|error_pre_print
operator|=
literal|0
expr_stmt|;
name|warning_pre_print
operator|=
literal|"warning: "
expr_stmt|;
comment|/* Read the .gdbinit file in the current directory, *if* it isn't      the same as the $HOME/.gdbinit file (it should exist, also).  */
if|if
condition|(
operator|!
name|homedir
operator|||
name|memcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|homebuf
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|cwdbuf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|stat
argument_list|)
argument_list|)
condition|)
if|if
condition|(
operator|!
name|inhibit_gdbinit
operator|&&
name|access
argument_list|(
name|gdbinit
argument_list|,
name|R_OK
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|SET_TOP_LEVEL
argument_list|()
condition|)
name|source_command
argument_list|(
name|gdbinit
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|do_cleanups
argument_list|(
name|ALL_CLEANUPS
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ncmd
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|SET_TOP_LEVEL
argument_list|()
condition|)
block|{
if|if
condition|(
name|cmdarg
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|cmdarg
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
name|read_command_file
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
else|else
name|source_command
argument_list|(
name|cmdarg
index|[
name|i
index|]
argument_list|,
operator|!
name|batch
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|ALL_CLEANUPS
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|cmdarg
argument_list|)
expr_stmt|;
comment|/* Read in the old history after all the command files have been read. */
name|init_history
argument_list|()
expr_stmt|;
if|if
condition|(
name|batch
condition|)
block|{
comment|/* We have hit the end of the batch file.  */
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Do any host- or target-specific hacks.  This is used for i960 targets      to force the user to set a nindy target and spec its parameters.  */
ifdef|#
directive|ifdef
name|BEFORE_MAIN_LOOP_HOOK
name|BEFORE_MAIN_LOOP_HOOK
expr_stmt|;
endif|#
directive|endif
comment|/* The command loop.  */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|SET_TOP_LEVEL
argument_list|()
condition|)
block|{
name|do_cleanups
argument_list|(
name|ALL_CLEANUPS
argument_list|)
expr_stmt|;
comment|/* Do complete cleanup */
name|command_loop
argument_list|()
expr_stmt|;
name|quit_command
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|instream
operator|==
name|stdin
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* No exit -- exit is through quit_command.  */
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|init_proc
parameter_list|()
block|{ }
end_function

begin_function
name|int
name|proc_wait
parameter_list|(
name|pid
parameter_list|,
name|status
parameter_list|)
name|int
name|pid
decl_stmt|;
name|int
modifier|*
name|status
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|__GO32__
return|return
name|wait
argument_list|(
name|status
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|proc_remove_foreign
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{ }
end_function

begin_function
name|void
name|fputs_unfiltered
parameter_list|(
name|linebuffer
parameter_list|,
name|stream
parameter_list|)
specifier|const
name|char
modifier|*
name|linebuffer
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|fputs
argument_list|(
name|linebuffer
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

