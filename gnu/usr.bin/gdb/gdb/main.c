begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Top level `main' program for GDB, the GNU debugger.    Copyright 1986, 1987, 1988, 1989, 1990, 1991, 1992    Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"call-cmds.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"signals.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"breakpoint.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"terminal.h"
end_include

begin_comment
comment|/* For job_control.  */
end_comment

begin_include
include|#
directive|include
file|"getopt.h"
end_include

begin_comment
comment|/* readline include files */
end_comment

begin_include
include|#
directive|include
file|"readline.h"
end_include

begin_include
include|#
directive|include
file|"history.h"
end_include

begin_comment
comment|/* readline defines this.  */
end_comment

begin_undef
undef|#
directive|undef
name|savestring
end_undef

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|NO_SYS_FILE
end_ifndef

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SET_STACK_LIMIT_HUGE
end_ifdef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_decl_stmt
name|int
name|original_stack_limit
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Prototypes for local functions */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|symbol_completion_function
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|command_loop
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|command_loop_marker
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_gdb_version
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|quit_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_main
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_history
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_cmd_lists
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|float_handler
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|source_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cd_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_gnu_advertisement
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_signals
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|read_command_file
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_verbose
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
expr|struct
name|cmd_list_element
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|show_history
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_history
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_history_size_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
expr|struct
name|cmd_list_element
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|show_commands
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|echo_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pwd_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|show_version
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|document_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|define_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|validate_comname
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|help_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|show_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|info_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_nothing
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|quit_cover
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|disconnect
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|source_cleanup
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If this definition isn't overridden by the header files, assume    that isatty and fileno exist on this system.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ISATTY
end_ifndef

begin_define
define|#
directive|define
name|ISATTY
parameter_list|(
name|FP
parameter_list|)
value|(isatty (fileno (FP)))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Initialization file name for gdb.  This is overridden in some configs.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|GDBINIT_FILENAME
end_ifndef

begin_define
define|#
directive|define
name|GDBINIT_FILENAME
value|".gdbinit"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|char
name|gdbinit
index|[]
init|=
name|GDBINIT_FILENAME
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|inhibit_gdbinit
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ALL_CLEANUPS
value|((struct cleanup *)0)
end_define

begin_comment
comment|/* Version number of GDB, as a string.  */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|version
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Canonical host name as a string. */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|host_canonical
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Canonical target name as a string. */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|target_canonical
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Message to be printed before the error message, when an error occurs.  */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|error_pre_print
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Message to be printed before the warning message, when a warning occurs.  */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|warning_pre_print
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|lang_frame_mismatch_warn
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* language.c */
end_comment

begin_comment
comment|/* Flag for whether we want all the "from_tty" gubbish printed.  */
end_comment

begin_decl_stmt
name|int
name|caution
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default is yes, sigh. */
end_comment

begin_comment
comment|/*  * Define all cmd_list_element's  */
end_comment

begin_comment
comment|/* Chain containing all defined commands.  */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|cmdlist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined info subcommands.  */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|infolist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined enable subcommands. */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|enablelist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined disable subcommands. */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|disablelist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined delete subcommands. */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|deletelist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined "enable breakpoint" subcommands. */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|enablebreaklist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined set subcommands */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|setlist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined unset subcommands */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|unsetlist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined show subcommands.  */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|showlist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined \"set history\".  */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|sethistlist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined \"show history\".  */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|showhistlist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined \"unset history\".  */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|unsethistlist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined maintenance subcommands. */
end_comment

begin_if
if|#
directive|if
name|MAINTENANCE_CMDS
end_if

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|maintenancelist
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Chain containing all defined "maintenance info" subcommands. */
end_comment

begin_if
if|#
directive|if
name|MAINTENANCE_CMDS
end_if

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|maintenanceinfolist
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Chain containing all defined "maintenance print" subcommands. */
end_comment

begin_if
if|#
directive|if
name|MAINTENANCE_CMDS
end_if

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|maintenanceprintlist
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|setprintlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|showprintlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|setchecklist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|showchecklist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* stdio stream that command input is being read from.  Set to stdin normally.    Set by source_command to the file we are sourcing.  Set to NULL if we are    executing a user-defined command.  */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|instream
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current working directory.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|current_directory
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The directory name is actually stored here (usually).  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|dirbuf
index|[
literal|1024
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function to call before reading a command, if nonzero.    The function receives two args: an input stream,    and a prompt string.  */
end_comment

begin_macro
name|void
argument_list|(
argument|*window_hook
argument_list|)
end_macro

begin_expr_stmt
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|extern
name|int
name|mapped_symbol_files
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|readnow_symbol_files
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|epoch_interface
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|xgdb_verbose
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* gdb prints this when reading a command interactively */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|prompt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer used for reading command lines, and the size    allocated for it so far.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|linesize
init|=
literal|100
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Baud rate specified for talking to serial target systems.  Default    is left as -1, so targets can choose their own defaults.  */
end_comment

begin_decl_stmt
name|int
name|baud_rate
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero tells remote* modules to output debugging info.  */
end_comment

begin_decl_stmt
name|int
name|remote_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Signal to catch ^Z typed while reading a command: SIGTSTP or SIGCONT.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|STOP_SIGNAL
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|SIGTSTP
end_ifdef

begin_define
define|#
directive|define
name|STOP_SIGNAL
value|SIGTSTP
end_define

begin_decl_stmt
specifier|static
name|void
name|stop_sig
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Some System V have job control but not sigsetmask(). */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_SIGSETMASK
argument_list|)
end_if

begin_define
define|#
directive|define
name|HAVE_SIGSETMASK
value|!defined (USG)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
literal|0
operator|==
operator|(
name|HAVE_SIGSETMASK
operator|)
end_if

begin_define
define|#
directive|define
name|sigsetmask
parameter_list|(
name|n
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Where to go for return_to_top_level (RETURN_ERROR).  */
end_comment

begin_decl_stmt
specifier|static
name|jmp_buf
name|error_return
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Where to go for return_to_top_level (RETURN_QUIT).  */
end_comment

begin_decl_stmt
specifier|static
name|jmp_buf
name|quit_return
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Temporary variable for SET_TOP_LEVEL.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|top_level_val
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Do a setjmp on error_return and quit_return.  catch_errors is    generally a cleaner way to do this, but main() would look pretty    ugly if it had to use catch_errors each time.  */
end_comment

begin_define
define|#
directive|define
name|SET_TOP_LEVEL
parameter_list|()
define|\
value|(((top_level_val = setjmp (error_return)) \     ? (PTR) 0 : (PTR) memcpy (quit_return, error_return, sizeof (jmp_buf))) \    , top_level_val)
end_define

begin_comment
comment|/* Return for reason REASON.  This generally gets back to the command    loop, but can be caught via catch_errors.  */
end_comment

begin_function
name|NORETURN
name|void
name|return_to_top_level
parameter_list|(
name|reason
parameter_list|)
name|enum
name|return_reason
name|reason
decl_stmt|;
block|{
name|quit_flag
operator|=
literal|0
expr_stmt|;
name|immediate_quit
operator|=
literal|0
expr_stmt|;
comment|/* Perhaps it would be cleaner to do this via the cleanup chain (not sure      I can think of a reason why that is vital, though).  */
name|bpstat_clear_actions
argument_list|(
name|stop_bpstat
argument_list|)
expr_stmt|;
comment|/* Clear queued breakpoint commands */
name|disable_current_display
argument_list|()
expr_stmt|;
name|do_cleanups
argument_list|(
name|ALL_CLEANUPS
argument_list|)
expr_stmt|;
operator|(
name|NORETURN
name|void
operator|)
name|longjmp
argument_list|(
name|reason
operator|==
name|RETURN_ERROR
condition|?
name|error_return
else|:
name|quit_return
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Call FUNC with arg ARGS, catching any errors.  If there is no    error, return the value returned by FUNC.  If there is an error,    print ERRSTRING, print the specific error message, then return    zero.     Must not be called with immediate_quit in effect (bad things might    happen, say we got a signal in the middle of a memcpy to quit_return).    This is an OK restriction; with very few exceptions immediate_quit can    be replaced by judicious use of QUIT.     MASK specifies what to catch; it is normally set to    RETURN_MASK_ALL, if for no other reason than that the code which    calls catch_errors might not be set up to deal with a quit which    isn't caught.  But if the code can deal with it, it generally    should be RETURN_MASK_ERROR, unless for some reason it is more    useful to abort only the portion of the operation inside the    catch_errors.  Note that quit should return to the command line    fairly quickly, even if some further processing is being done.  */
end_comment

begin_function_decl
name|int
name|catch_errors
parameter_list|(
name|func
parameter_list|,
name|args
parameter_list|,
name|errstring
parameter_list|,
name|mask
parameter_list|)
function_decl|int
parameter_list|(
function_decl|*func
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|PTR
name|args
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|errstring
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|return_mask
name|mask
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|jmp_buf
name|saved_error
decl_stmt|;
name|jmp_buf
name|saved_quit
decl_stmt|;
name|jmp_buf
name|tmp_jmp
decl_stmt|;
name|int
name|val
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|saved_cleanup_chain
decl_stmt|;
name|char
modifier|*
name|saved_error_pre_print
decl_stmt|;
name|saved_cleanup_chain
operator|=
name|save_cleanups
argument_list|()
expr_stmt|;
name|saved_error_pre_print
operator|=
name|error_pre_print
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|RETURN_MASK_ERROR
condition|)
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|saved_error
argument_list|,
operator|(
name|char
operator|*
operator|)
name|error_return
argument_list|,
sizeof|sizeof
argument_list|(
name|jmp_buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|RETURN_MASK_QUIT
condition|)
name|memcpy
argument_list|(
name|saved_quit
argument_list|,
name|quit_return
argument_list|,
sizeof|sizeof
argument_list|(
name|jmp_buf
argument_list|)
argument_list|)
expr_stmt|;
name|error_pre_print
operator|=
name|errstring
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|tmp_jmp
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|mask
operator|&
name|RETURN_MASK_ERROR
condition|)
name|memcpy
argument_list|(
name|error_return
argument_list|,
name|tmp_jmp
argument_list|,
sizeof|sizeof
argument_list|(
name|jmp_buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|RETURN_MASK_QUIT
condition|)
name|memcpy
argument_list|(
name|quit_return
argument_list|,
name|tmp_jmp
argument_list|,
sizeof|sizeof
argument_list|(
name|jmp_buf
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator|=
call|(
modifier|*
name|func
call|)
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
else|else
name|val
operator|=
literal|0
expr_stmt|;
name|restore_cleanups
argument_list|(
name|saved_cleanup_chain
argument_list|)
expr_stmt|;
name|error_pre_print
operator|=
name|saved_error_pre_print
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|RETURN_MASK_ERROR
condition|)
name|memcpy
argument_list|(
name|error_return
argument_list|,
name|saved_error
argument_list|,
sizeof|sizeof
argument_list|(
name|jmp_buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|RETURN_MASK_QUIT
condition|)
name|memcpy
argument_list|(
name|quit_return
argument_list|,
name|saved_quit
argument_list|,
sizeof|sizeof
argument_list|(
name|jmp_buf
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_block

begin_comment
comment|/* Handler for SIGHUP.  */
end_comment

begin_function
specifier|static
name|void
name|disconnect
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
name|catch_errors
argument_list|(
name|quit_cover
argument_list|,
name|NULL
argument_list|,
literal|"Could not kill the program being debugged"
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|SIGHUP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Just a little helper function for disconnect().  */
end_comment

begin_function
specifier|static
name|int
name|quit_cover
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|caution
operator|=
literal|0
expr_stmt|;
comment|/* Throw caution to the wind -- we're exiting. 			   This prevents asking the user dumb questions.  */
name|quit_command
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Clean up on error during a "source" command (or execution of a    user-defined command).  */
end_comment

begin_function
specifier|static
name|void
name|source_cleanup
parameter_list|(
name|stream
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
comment|/* Restore the previous input stream.  */
name|instream
operator|=
name|stream
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read commands from STREAM.  */
end_comment

begin_function
specifier|static
name|void
name|read_command_file
parameter_list|(
name|stream
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|struct
name|cleanup
modifier|*
name|cleanups
decl_stmt|;
name|cleanups
operator|=
name|make_cleanup
argument_list|(
name|source_cleanup
argument_list|,
name|instream
argument_list|)
expr_stmt|;
name|instream
operator|=
name|stream
expr_stmt|;
name|command_loop
argument_list|()
expr_stmt|;
name|do_cleanups
argument_list|(
name|cleanups
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|count
decl_stmt|;
specifier|static
name|int
name|quiet
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|batch
init|=
literal|0
decl_stmt|;
comment|/* Pointers to various arguments from command line.  */
name|char
modifier|*
name|symarg
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|execarg
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|corearg
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|cdarg
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|ttyarg
init|=
name|NULL
decl_stmt|;
comment|/* These are static so that we can take their address in an initializer.  */
specifier|static
name|int
name|print_help
decl_stmt|;
specifier|static
name|int
name|print_version
decl_stmt|;
comment|/* Pointers to all arguments of --command option.  */
name|char
modifier|*
modifier|*
name|cmdarg
decl_stmt|;
comment|/* Allocated size of cmdarg.  */
name|int
name|cmdsize
decl_stmt|;
comment|/* Number of elements of cmdarg used.  */
name|int
name|ncmd
decl_stmt|;
comment|/* Indices of all arguments of --directory option.  */
name|char
modifier|*
modifier|*
name|dirarg
decl_stmt|;
comment|/* Allocated size.  */
name|int
name|dirsize
decl_stmt|;
comment|/* Number of elements used.  */
name|int
name|ndir
decl_stmt|;
name|struct
name|stat
name|homebuf
decl_stmt|,
name|cwdbuf
decl_stmt|;
name|char
modifier|*
name|homedir
decl_stmt|,
modifier|*
name|homeinit
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* This needs to happen before the first use of malloc.  */
name|init_malloc
argument_list|(
operator|(
name|PTR
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|ALIGN_STACK_ON_STARTUP
argument_list|)
name|i
operator|=
operator|(
name|int
operator|)
operator|&
name|count
operator|&
literal|0x3
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|alloca
argument_list|(
literal|4
operator|-
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If error() is called from initialization code, just exit */
if|if
condition|(
name|SET_TOP_LEVEL
argument_list|()
condition|)
block|{
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|cmdsize
operator|=
literal|1
expr_stmt|;
name|cmdarg
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|cmdsize
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|cmdarg
argument_list|)
argument_list|)
expr_stmt|;
name|ncmd
operator|=
literal|0
expr_stmt|;
name|dirsize
operator|=
literal|1
expr_stmt|;
name|dirarg
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|dirsize
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|dirarg
argument_list|)
argument_list|)
expr_stmt|;
name|ndir
operator|=
literal|0
expr_stmt|;
name|quit_flag
operator|=
literal|0
expr_stmt|;
name|line
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|linesize
argument_list|)
expr_stmt|;
name|line
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Terminate saved (now empty) cmd line */
name|instream
operator|=
name|stdin
expr_stmt|;
name|getcwd
argument_list|(
name|dirbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|dirbuf
argument_list|)
argument_list|)
expr_stmt|;
name|current_directory
operator|=
name|dirbuf
expr_stmt|;
ifdef|#
directive|ifdef
name|SET_STACK_LIMIT_HUGE
block|{
name|struct
name|rlimit
name|rlim
decl_stmt|;
comment|/* Set the stack limit huge so that alloca (particularly stringtab      * in dbxread.c) does not fail. */
name|getrlimit
argument_list|(
name|RLIMIT_STACK
argument_list|,
operator|&
name|rlim
argument_list|)
expr_stmt|;
name|original_stack_limit
operator|=
name|rlim
operator|.
name|rlim_cur
expr_stmt|;
name|rlim
operator|.
name|rlim_cur
operator|=
name|rlim
operator|.
name|rlim_max
expr_stmt|;
name|setrlimit
argument_list|(
name|RLIMIT_STACK
argument_list|,
operator|&
name|rlim
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SET_STACK_LIMIT_HUGE */
comment|/* Parse arguments and options.  */
block|{
name|int
name|c
decl_stmt|;
comment|/* When var field is 0, use flag field to record the equivalent        short option (or arbitrary numbers starting at 10 for those        with no equivalent).  */
specifier|static
name|struct
name|option
name|long_options
index|[]
init|=
block|{
block|{
literal|"readnow"
block|,
name|no_argument
block|,
operator|&
name|readnow_symbol_files
block|,
literal|1
block|}
block|,
block|{
literal|"r"
block|,
name|no_argument
block|,
operator|&
name|readnow_symbol_files
block|,
literal|1
block|}
block|,
block|{
literal|"mapped"
block|,
name|no_argument
block|,
operator|&
name|mapped_symbol_files
block|,
literal|1
block|}
block|,
block|{
literal|"m"
block|,
name|no_argument
block|,
operator|&
name|mapped_symbol_files
block|,
literal|1
block|}
block|,
block|{
literal|"quiet"
block|,
name|no_argument
block|,
operator|&
name|quiet
block|,
literal|1
block|}
block|,
block|{
literal|"q"
block|,
name|no_argument
block|,
operator|&
name|quiet
block|,
literal|1
block|}
block|,
block|{
literal|"silent"
block|,
name|no_argument
block|,
operator|&
name|quiet
block|,
literal|1
block|}
block|,
block|{
literal|"nx"
block|,
name|no_argument
block|,
operator|&
name|inhibit_gdbinit
block|,
literal|1
block|}
block|,
block|{
literal|"n"
block|,
name|no_argument
block|,
operator|&
name|inhibit_gdbinit
block|,
literal|1
block|}
block|,
block|{
literal|"batch"
block|,
name|no_argument
block|,
operator|&
name|batch
block|,
literal|1
block|}
block|,
block|{
literal|"epoch"
block|,
name|no_argument
block|,
operator|&
name|epoch_interface
block|,
literal|1
block|}
block|,
block|{
literal|"fullname"
block|,
name|no_argument
block|,
operator|&
name|frame_file_full_name
block|,
literal|1
block|}
block|,
block|{
literal|"f"
block|,
name|no_argument
block|,
operator|&
name|frame_file_full_name
block|,
literal|1
block|}
block|,
block|{
literal|"help"
block|,
name|no_argument
block|,
operator|&
name|print_help
block|,
literal|1
block|}
block|,
block|{
literal|"se"
block|,
name|required_argument
block|,
literal|0
block|,
literal|10
block|}
block|,
block|{
literal|"symbols"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'s'
block|}
block|,
block|{
literal|"s"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'s'
block|}
block|,
block|{
literal|"exec"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'e'
block|}
block|,
block|{
literal|"e"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'e'
block|}
block|,
block|{
literal|"core"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'c'
block|}
block|,
block|{
literal|"c"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'c'
block|}
block|,
block|{
literal|"command"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'x'
block|}
block|,
block|{
literal|"version"
block|,
name|no_argument
block|,
operator|&
name|print_version
block|,
literal|1
block|}
block|,
block|{
literal|"x"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'x'
block|}
block|,
block|{
literal|"directory"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'d'
block|}
block|,
block|{
literal|"cd"
block|,
name|required_argument
block|,
literal|0
block|,
literal|11
block|}
block|,
block|{
literal|"tty"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'t'
block|}
block|,
block|{
literal|"baud"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'b'
block|}
block|,
block|{
literal|"b"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'b'
block|}
block|,
comment|/* Allow machine descriptions to add more options... */
ifdef|#
directive|ifdef
name|ADDITIONAL_OPTIONS
name|ADDITIONAL_OPTIONS
endif|#
directive|endif
block|{
literal|0
block|,
name|no_argument
block|,
literal|0
block|,
literal|0
block|}
block|,       }
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|option_index
decl_stmt|;
name|c
operator|=
name|getopt_long_only
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|""
argument_list|,
name|long_options
argument_list|,
operator|&
name|option_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
comment|/* Long option that takes an argument.  */
if|if
condition|(
name|c
operator|==
literal|0
operator|&&
name|long_options
index|[
name|option_index
index|]
operator|.
name|flag
operator|==
literal|0
condition|)
name|c
operator|=
name|long_options
index|[
name|option_index
index|]
operator|.
name|val
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|0
case|:
comment|/* Long option that just sets a flag.  */
break|break;
case|case
literal|10
case|:
name|symarg
operator|=
name|optarg
expr_stmt|;
name|execarg
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|11
case|:
name|cdarg
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|symarg
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|execarg
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|corearg
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|cmdarg
index|[
name|ncmd
operator|++
index|]
operator|=
name|optarg
expr_stmt|;
if|if
condition|(
name|ncmd
operator|>=
name|cmdsize
condition|)
block|{
name|cmdsize
operator|*=
literal|2
expr_stmt|;
name|cmdarg
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cmdarg
argument_list|,
name|cmdsize
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|cmdarg
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'d'
case|:
name|dirarg
index|[
name|ndir
operator|++
index|]
operator|=
name|optarg
expr_stmt|;
if|if
condition|(
name|ndir
operator|>=
name|dirsize
condition|)
block|{
name|dirsize
operator|*=
literal|2
expr_stmt|;
name|dirarg
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dirarg
argument_list|,
name|dirsize
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|dirarg
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'t'
case|:
name|ttyarg
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|quiet
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|i
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
operator|&
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
name|p
operator|==
name|optarg
condition|)
name|warning
argument_list|(
literal|"Could not set baud rate to `%s'.\n"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
else|else
name|baud_rate
operator|=
name|i
expr_stmt|;
block|}
break|break;
ifdef|#
directive|ifdef
name|ADDITIONAL_OPTION_CASES
name|ADDITIONAL_OPTION_CASES
endif|#
directive|endif
case|case
literal|'?'
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Use `%s --help' for a complete list of options.\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* OK, that's all the options.  The other arguments are filenames.  */
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|optind
operator|<
name|argc
condition|;
name|optind
operator|++
control|)
switch|switch
condition|(
operator|++
name|count
condition|)
block|{
case|case
literal|1
case|:
name|symarg
operator|=
name|argv
index|[
name|optind
index|]
expr_stmt|;
name|execarg
operator|=
name|argv
index|[
name|optind
index|]
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|corearg
operator|=
name|argv
index|[
name|optind
index|]
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Excess command line arguments ignored. (%s%s)\n"
argument_list|,
name|argv
index|[
name|optind
index|]
argument_list|,
operator|(
name|optind
operator|==
name|argc
operator|-
literal|1
operator|)
condition|?
literal|""
else|:
literal|" ..."
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|batch
condition|)
name|quiet
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Run the init function of each source file */
name|init_cmd_lists
argument_list|()
expr_stmt|;
comment|/* This needs to be done first */
name|initialize_all_files
argument_list|()
expr_stmt|;
name|init_main
argument_list|()
expr_stmt|;
comment|/* But that omits this file!  Do it now */
name|init_signals
argument_list|()
expr_stmt|;
comment|/* Do these (and anything which might call wrap_here or *_filtered)      after initialize_all_files.  */
if|if
condition|(
name|print_version
condition|)
block|{
name|print_gdb_version
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|print_help
condition|)
block|{
comment|/* --version is intentionally not documented here, because we 	 are printing the version here, and the help is long enough 	 already.  */
name|print_gdb_version
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* Make sure the output gets printed.  */
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* But don't use *_filtered here.  We don't want to prompt for continue 	 no matter how small the screen or how much we're going to print.  */
name|fputs
argument_list|(
literal|"\ This is the GNU debugger.  Usage:\n\     gdb [options] [executable-file [core-file or process-id]]\n\ Options:\n\   --help             Print this message.\n\   --quiet            Do not print version number on startup.\n\   --fullname         Output information used by emacs-GDB interface.\n\   --epoch            Output information used by epoch emacs-GDB interface.\n\   --batch            Exit after processing options.\n\   --nx               Do not read .gdbinit file.\n\   --tty=TTY          Use TTY for input/output by the program being debugged.\n\   --cd=DIR           Change current directory to DIR.\n\   --directory=DIR    Search for source files in DIR.\n\   --command=FILE     Execute GDB commands from FILE.\n\   --symbols=SYMFILE  Read symbols from SYMFILE.\n\   --exec=EXECFILE    Use EXECFILE as the executable.\n\   --se=FILE          Use FILE as symbol file and executable file.\n\   --core=COREFILE    Analyze the core dump COREFILE.\n\   -b BAUDRATE        Set serial port baud rate used for remote debugging.\n\   --mapped           Use mapped symbol files if supported on this system.\n\   --readnow          Fully read symbol files on first access.\n\ "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ADDITIONAL_OPTION_HELP
name|fputs
argument_list|(
name|ADDITIONAL_OPTION_HELP
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fputs
argument_list|(
literal|"\n\ For more information, type \"help\" from within GDB, or consult the\n\ GDB manual (available as on-line info or a printed manual).\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|quiet
condition|)
block|{
comment|/* Print all the junk at the top, with trailing "..." if we are about 	 to read a symbol file (possibly slowly).  */
name|print_gnu_advertisement
argument_list|()
expr_stmt|;
name|print_gdb_version
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|symarg
condition|)
name|printf_filtered
argument_list|(
literal|".."
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* Force to screen during slow operations */
block|}
name|error_pre_print
operator|=
literal|"\n\n"
expr_stmt|;
comment|/* We may get more than one warning, don't double space all of them... */
name|warning_pre_print
operator|=
literal|"\nwarning: "
expr_stmt|;
comment|/* We need a default language for parsing expressions, so simple things like      "set width 0" won't fail if no language is explicitly set in a config file      or implicitly set by reading an executable during startup. */
name|set_language
argument_list|(
name|language_c
argument_list|)
expr_stmt|;
name|expected_language
operator|=
name|current_language
expr_stmt|;
comment|/* don't warn about the change.  */
comment|/* Read and execute $HOME/.gdbinit file, if it exists.  This is done      *before* all the command line arguments are processed; it sets      global parameters, which are independent of what file you are      debugging or what directory you are in.  */
name|homedir
operator|=
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
expr_stmt|;
if|if
condition|(
name|homedir
condition|)
block|{
name|homeinit
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
argument_list|)
operator|+
name|strlen
argument_list|(
name|gdbinit
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|homeinit
argument_list|,
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|homeinit
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|homeinit
argument_list|,
name|gdbinit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|inhibit_gdbinit
operator|&&
name|access
argument_list|(
name|homeinit
argument_list|,
name|R_OK
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|SET_TOP_LEVEL
argument_list|()
condition|)
name|source_command
argument_list|(
name|homeinit
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|do_cleanups
argument_list|(
name|ALL_CLEANUPS
argument_list|)
expr_stmt|;
comment|/* Do stats; no need to do them elsewhere since we'll only 	 need them if homedir is set.  Make sure that they are 	 zero in case one of them fails (this guarantees that they 	 won't match if either exists).  */
name|memset
argument_list|(
operator|&
name|homebuf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|stat
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|cwdbuf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|stat
argument_list|)
argument_list|)
expr_stmt|;
name|stat
argument_list|(
name|homeinit
argument_list|,
operator|&
name|homebuf
argument_list|)
expr_stmt|;
name|stat
argument_list|(
name|gdbinit
argument_list|,
operator|&
name|cwdbuf
argument_list|)
expr_stmt|;
comment|/* We'll only need this if 				       homedir was set.  */
block|}
comment|/* Now perform all the actions indicated by the arguments.  */
if|if
condition|(
name|cdarg
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|SET_TOP_LEVEL
argument_list|()
condition|)
block|{
name|cd_command
argument_list|(
name|cdarg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|init_source_path
argument_list|()
expr_stmt|;
block|}
block|}
name|do_cleanups
argument_list|(
name|ALL_CLEANUPS
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ndir
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|SET_TOP_LEVEL
argument_list|()
condition|)
name|directory_command
argument_list|(
name|dirarg
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|dirarg
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|ALL_CLEANUPS
argument_list|)
expr_stmt|;
if|if
condition|(
name|execarg
operator|!=
name|NULL
operator|&&
name|symarg
operator|!=
name|NULL
operator|&&
name|STREQ
argument_list|(
name|execarg
argument_list|,
name|symarg
argument_list|)
condition|)
block|{
comment|/* The exec file and the symbol-file are the same.  If we can't open 	 it, better only print one error message.  */
if|if
condition|(
operator|!
name|SET_TOP_LEVEL
argument_list|()
condition|)
block|{
name|exec_file_command
argument_list|(
name|execarg
argument_list|,
operator|!
name|batch
argument_list|)
expr_stmt|;
name|symbol_file_command
argument_list|(
name|symarg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|execarg
operator|!=
name|NULL
condition|)
if|if
condition|(
operator|!
name|SET_TOP_LEVEL
argument_list|()
condition|)
name|exec_file_command
argument_list|(
name|execarg
argument_list|,
operator|!
name|batch
argument_list|)
expr_stmt|;
if|if
condition|(
name|symarg
operator|!=
name|NULL
condition|)
if|if
condition|(
operator|!
name|SET_TOP_LEVEL
argument_list|()
condition|)
name|symbol_file_command
argument_list|(
name|symarg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|do_cleanups
argument_list|(
name|ALL_CLEANUPS
argument_list|)
expr_stmt|;
comment|/* After the symbol file has been read, print a newline to get us      beyond the copyright line...  But errors should still set off      the error message with a (single) blank line.  */
if|if
condition|(
operator|!
name|quiet
condition|)
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|error_pre_print
operator|=
literal|"\n"
expr_stmt|;
name|warning_pre_print
operator|=
literal|"\nwarning: "
expr_stmt|;
if|if
condition|(
name|corearg
operator|!=
name|NULL
condition|)
if|if
condition|(
operator|!
name|SET_TOP_LEVEL
argument_list|()
condition|)
name|core_file_command
argument_list|(
name|corearg
argument_list|,
operator|!
name|batch
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|isdigit
argument_list|(
name|corearg
index|[
literal|0
index|]
argument_list|)
operator|&&
operator|!
name|SET_TOP_LEVEL
argument_list|()
condition|)
name|attach_command
argument_list|(
name|corearg
argument_list|,
operator|!
name|batch
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|ALL_CLEANUPS
argument_list|)
expr_stmt|;
if|if
condition|(
name|ttyarg
operator|!=
name|NULL
condition|)
if|if
condition|(
operator|!
name|SET_TOP_LEVEL
argument_list|()
condition|)
name|tty_command
argument_list|(
name|ttyarg
argument_list|,
operator|!
name|batch
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|ALL_CLEANUPS
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ADDITIONAL_OPTION_HANDLER
name|ADDITIONAL_OPTION_HANDLER
expr_stmt|;
endif|#
directive|endif
comment|/* Error messages should no longer be distinguished with extra output. */
name|error_pre_print
operator|=
literal|0
expr_stmt|;
name|warning_pre_print
operator|=
literal|"warning: "
expr_stmt|;
comment|/* Read the .gdbinit file in the current directory, *if* it isn't      the same as the $HOME/.gdbinit file (it should exist, also).  */
if|if
condition|(
operator|!
name|homedir
operator|||
name|memcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|homebuf
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|cwdbuf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|stat
argument_list|)
argument_list|)
condition|)
if|if
condition|(
operator|!
name|inhibit_gdbinit
operator|&&
name|access
argument_list|(
name|gdbinit
argument_list|,
name|R_OK
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|SET_TOP_LEVEL
argument_list|()
condition|)
name|source_command
argument_list|(
name|gdbinit
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|do_cleanups
argument_list|(
name|ALL_CLEANUPS
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ncmd
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|SET_TOP_LEVEL
argument_list|()
condition|)
block|{
if|if
condition|(
name|cmdarg
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|cmdarg
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
name|read_command_file
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
else|else
name|source_command
argument_list|(
name|cmdarg
index|[
name|i
index|]
argument_list|,
operator|!
name|batch
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|ALL_CLEANUPS
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|cmdarg
argument_list|)
expr_stmt|;
comment|/* Read in the old history after all the command files have been read. */
name|init_history
argument_list|()
expr_stmt|;
if|if
condition|(
name|batch
condition|)
block|{
comment|/* We have hit the end of the batch file.  */
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Do any host- or target-specific hacks.  This is used for i960 targets      to force the user to set a nindy target and spec its parameters.  */
ifdef|#
directive|ifdef
name|BEFORE_MAIN_LOOP_HOOK
name|BEFORE_MAIN_LOOP_HOOK
expr_stmt|;
endif|#
directive|endif
comment|/* The command loop.  */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|SET_TOP_LEVEL
argument_list|()
condition|)
block|{
name|do_cleanups
argument_list|(
name|ALL_CLEANUPS
argument_list|)
expr_stmt|;
comment|/* Do complete cleanup */
name|command_loop
argument_list|()
expr_stmt|;
name|quit_command
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|instream
operator|==
name|stdin
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* No exit -- exit is through quit_command.  */
block|}
end_function

begin_function
name|void
name|execute_user_command
parameter_list|(
name|c
parameter_list|,
name|args
parameter_list|)
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
name|char
modifier|*
name|args
decl_stmt|;
block|{
specifier|register
name|struct
name|command_line
modifier|*
name|cmdlines
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
if|if
condition|(
name|args
condition|)
name|error
argument_list|(
literal|"User-defined commands cannot take arguments."
argument_list|)
expr_stmt|;
name|cmdlines
operator|=
name|c
operator|->
name|user_commands
expr_stmt|;
if|if
condition|(
name|cmdlines
operator|==
literal|0
condition|)
comment|/* Null command */
return|return;
comment|/* Set the instream to 0, indicating execution of a      user-defined function.  */
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|source_cleanup
argument_list|,
name|instream
argument_list|)
expr_stmt|;
name|instream
operator|=
operator|(
name|FILE
operator|*
operator|)
literal|0
expr_stmt|;
while|while
condition|(
name|cmdlines
condition|)
block|{
name|execute_command
argument_list|(
name|cmdlines
operator|->
name|line
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cmdlines
operator|=
name|cmdlines
operator|->
name|next
expr_stmt|;
block|}
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Execute the line P as a command.    Pass FROM_TTY as second argument to the defining function.  */
end_comment

begin_function
name|void
name|execute_command
parameter_list|(
name|p
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|register
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
specifier|register
name|enum
name|language
name|flang
decl_stmt|;
specifier|static
name|int
name|warned
init|=
literal|0
decl_stmt|;
name|free_all_values
argument_list|()
expr_stmt|;
comment|/* This can happen when command_line_input hits end of file.  */
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
block|{
name|char
modifier|*
name|arg
decl_stmt|;
name|c
operator|=
name|lookup_cmd
argument_list|(
operator|&
name|p
argument_list|,
name|cmdlist
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Pass null arg rather than an empty one.  */
name|arg
operator|=
operator|*
name|p
condition|?
name|p
else|:
literal|0
expr_stmt|;
comment|/* If this command has been hooked, run the hook first. */
if|if
condition|(
name|c
operator|->
name|hook
condition|)
name|execute_user_command
argument_list|(
name|c
operator|->
name|hook
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|class
operator|==
name|class_user
condition|)
name|execute_user_command
argument_list|(
name|c
argument_list|,
name|arg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|->
name|type
operator|==
name|set_cmd
operator|||
name|c
operator|->
name|type
operator|==
name|show_cmd
condition|)
name|do_setshow_command
argument_list|(
name|arg
argument_list|,
name|from_tty
operator|&
name|caution
argument_list|,
name|c
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|->
name|function
operator|.
name|cfunc
operator|==
name|NO_FUNCTION
condition|)
name|error
argument_list|(
literal|"That is not a command, just a help topic."
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|c
operator|->
name|function
operator|.
name|cfunc
call|)
argument_list|(
name|arg
argument_list|,
name|from_tty
operator|&
name|caution
argument_list|)
expr_stmt|;
block|}
comment|/* Tell the user if the language has changed (except first time).  */
if|if
condition|(
name|current_language
operator|!=
name|expected_language
condition|)
block|{
if|if
condition|(
name|language_mode
operator|==
name|language_mode_auto
condition|)
block|{
name|language_info
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Print what changed.  */
block|}
name|warned
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Warn the user if the working language does not match the      language of the current frame.  Only warn the user if we are      actually running the program, i.e. there is a stack. */
comment|/* FIXME:  This should be cacheing the frame and only running when      the frame changes.  */
if|if
condition|(
name|target_has_stack
condition|)
block|{
name|flang
operator|=
name|get_frame_language
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|warned
operator|&&
name|flang
operator|!=
name|language_unknown
operator|&&
name|flang
operator|!=
name|current_language
operator|->
name|la_language
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"%s\n"
argument_list|,
name|lang_frame_mismatch_warn
argument_list|)
expr_stmt|;
name|warned
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|command_loop_marker
parameter_list|(
name|foo
parameter_list|)
name|int
name|foo
decl_stmt|;
block|{ }
end_function

begin_comment
comment|/* Read commands from `instream' and execute them    until end of file or error reading instream.  */
end_comment

begin_function
specifier|static
name|void
name|command_loop
parameter_list|()
block|{
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|char
modifier|*
name|command
decl_stmt|;
name|int
name|stdin_is_tty
init|=
name|ISATTY
argument_list|(
name|stdin
argument_list|)
decl_stmt|;
while|while
condition|(
operator|!
name|feof
argument_list|(
name|instream
argument_list|)
condition|)
block|{
if|if
condition|(
name|window_hook
operator|&&
name|instream
operator|==
name|stdin
condition|)
call|(
modifier|*
name|window_hook
call|)
argument_list|(
name|instream
argument_list|,
name|prompt
argument_list|)
expr_stmt|;
name|quit_flag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|instream
operator|==
name|stdin
operator|&&
name|stdin_is_tty
condition|)
name|reinitialize_more_filter
argument_list|()
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|command_loop_marker
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|command
operator|=
name|command_line_input
argument_list|(
name|instream
operator|==
name|stdin
condition|?
name|prompt
else|:
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|instream
operator|==
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
name|command
operator|==
literal|0
condition|)
return|return;
name|execute_command
argument_list|(
name|command
argument_list|,
name|instream
operator|==
name|stdin
argument_list|)
expr_stmt|;
comment|/* Do any commands attached to breakpoint we stopped at.  */
name|bpstat_do_actions
argument_list|(
operator|&
name|stop_bpstat
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Commands call this if they do not want to be repeated by null lines.  */
end_comment

begin_function
name|void
name|dont_repeat
parameter_list|()
block|{
comment|/* If we aren't reading from standard input, we are saving the last      thing read from stdin in line and don't want to delete it.  Null lines      won't repeat here in any case.  */
if|if
condition|(
name|instream
operator|==
name|stdin
condition|)
operator|*
name|line
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read a line from the stream "instream" without command line editing.     It prints PRROMPT once at the start.    Action is compatible with "readline", e.g. space for the result is     malloc'd and should be freed by the caller.     A NULL return means end of file.  */
end_comment

begin_function
name|char
modifier|*
name|gdb_readline
parameter_list|(
name|prrompt
parameter_list|)
name|char
modifier|*
name|prrompt
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
name|int
name|input_index
init|=
literal|0
decl_stmt|;
name|int
name|result_size
init|=
literal|80
decl_stmt|;
if|if
condition|(
name|prrompt
condition|)
block|{
comment|/* Don't use a _filtered function here.  It causes the assumed 	 character position to be off, since the newline we read from 	 the user is not accounted for.  */
name|fputs
argument_list|(
name|prrompt
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|result_size
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Read from stdin if we are executing a user defined command. 	 This is the right thing for prompt_for_continue, at least.  */
name|c
operator|=
name|fgetc
argument_list|(
name|instream
condition|?
name|instream
else|:
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|input_index
operator|>
literal|0
condition|)
comment|/* The last line does not end with a newline.  Return it, and 	       if we are called again fgetc will still return EOF and 	       we'll return NULL then.  */
break|break;
name|free
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
break|break;
name|result
index|[
name|input_index
operator|++
index|]
operator|=
name|c
expr_stmt|;
while|while
condition|(
name|input_index
operator|>=
name|result_size
condition|)
block|{
name|result_size
operator|*=
literal|2
expr_stmt|;
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|result
argument_list|,
name|result_size
argument_list|)
expr_stmt|;
block|}
block|}
name|result
index|[
name|input_index
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Variables which control command line editing and history    substitution.  These variables are given default values at the end    of this file.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|command_editing_p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|history_expansion_p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|write_history_p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|history_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|history_filename
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* readline uses the word breaks for two things:    (1) In figuring out where to point the TEXT parameter to the    rl_completion_entry_function.  Since we don't use TEXT for much,    it doesn't matter a lot what the word breaks are for this purpose, but    it does affect how much stuff M-? lists.    (2) If one of the matches contains a word break character, readline    will quote it.  That's why we switch between    gdb_completer_word_break_characters and    gdb_completer_command_word_break_characters.  I'm not sure when    we need this behavior (perhaps for funky characters in C++ symbols?).  */
end_comment

begin_comment
comment|/* Variables which are necessary for fancy command line editing.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|gdb_completer_word_break_characters
init|=
literal|" \t\n!@#$%^&*()+=|~`}{[]\"';:?/>.<,-"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When completing on command names, we remove '-' from the list of    word break characters, since we use it in command names.  If the    readline library sees one in any of the current completion strings,    it thinks that the string needs to be quoted and automatically supplies    a leading quote. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|gdb_completer_command_word_break_characters
init|=
literal|" \t\n!@#$%^&*()+=|~`}{[]\"';:?/>.<,"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Characters that can be used to quote completion strings.  Note that we    can't include '"' because the gdb C parser treats such quoted sequences    as strings. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|gdb_completer_quote_characters
init|=
literal|"'"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Functions that are used as part of the fancy command line editing.  */
end_comment

begin_comment
comment|/* This can be used for functions which don't want to complete on symbols    but don't want to complete on anything else either.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|noop_completer
parameter_list|(
name|text
parameter_list|,
name|prefix
parameter_list|)
name|char
modifier|*
name|text
decl_stmt|;
name|char
modifier|*
name|prefix
decl_stmt|;
block|{
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Complete on filenames.  */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|filename_completer
parameter_list|(
name|text
parameter_list|,
name|word
parameter_list|)
name|char
modifier|*
name|text
decl_stmt|;
name|char
modifier|*
name|word
decl_stmt|;
block|{
comment|/* From readline.  */
specifier|extern
name|char
modifier|*
name|filename_completion_function
parameter_list|()
function_decl|;
name|int
name|subsequent_name
decl_stmt|;
name|char
modifier|*
modifier|*
name|return_val
decl_stmt|;
name|int
name|return_val_used
decl_stmt|;
name|int
name|return_val_alloced
decl_stmt|;
name|return_val_used
operator|=
literal|0
expr_stmt|;
comment|/* Small for testing.  */
name|return_val_alloced
operator|=
literal|1
expr_stmt|;
name|return_val
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|return_val_alloced
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|subsequent_name
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|filename_completion_function
argument_list|(
name|text
argument_list|,
name|subsequent_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_val_used
operator|>=
name|return_val_alloced
condition|)
block|{
name|return_val_alloced
operator|*=
literal|2
expr_stmt|;
name|return_val
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|return_val
argument_list|,
name|return_val_alloced
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|return_val
index|[
name|return_val_used
operator|++
index|]
operator|=
name|p
expr_stmt|;
break|break;
block|}
comment|/* Like emacs, don't complete on old versions.  Especially useful 	 in the "source" command.  */
if|if
condition|(
name|p
index|[
name|strlen
argument_list|(
name|p
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'~'
condition|)
continue|continue;
block|{
name|char
modifier|*
name|q
decl_stmt|;
if|if
condition|(
name|word
operator|==
name|text
condition|)
comment|/* Return exactly p.  */
name|return_val
index|[
name|return_val_used
operator|++
index|]
operator|=
name|p
expr_stmt|;
elseif|else
if|if
condition|(
name|word
operator|>
name|text
condition|)
block|{
comment|/* Return some portion of p.  */
name|q
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
literal|5
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|q
argument_list|,
name|p
operator|+
operator|(
name|word
operator|-
name|text
operator|)
argument_list|)
expr_stmt|;
name|return_val
index|[
name|return_val_used
operator|++
index|]
operator|=
name|q
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Return some of TEXT plus p.  */
name|q
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
operator|(
name|text
operator|-
name|word
operator|)
operator|+
literal|5
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|q
argument_list|,
name|word
argument_list|,
name|text
operator|-
name|word
argument_list|)
expr_stmt|;
name|q
index|[
name|text
operator|-
name|word
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strcat
argument_list|(
name|q
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|return_val
index|[
name|return_val_used
operator|++
index|]
operator|=
name|q
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
name|subsequent_name
operator|=
literal|1
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* There is no way to do this just long enough to affect quote inserting      without also affecting the next completion.  This should be fixed in      readline.  FIXME.  */
comment|/* Insure that readline does the right thing      with respect to inserting quotes.  */
block|rl_completer_word_break_characters = "";
endif|#
directive|endif
return|return
name|return_val
return|;
block|}
end_function

begin_comment
comment|/* Here are some useful test cases for completion.  FIXME: These should    be put in the test suite.  They should be tested with both M-? and TAB.     "show output-" "radix"    "show output" "-radix"    "p" ambiguous (commands starting with p--path, print, printf, etc.)    "p "  ambiguous (all symbols)    "info t foo" no completions    "info t " no completions    "info t" ambiguous ("info target", "info terminal", etc.)    "info ajksdlfk" no completions    "info ajksdlfk " no completions    "info" " "    "info " ambiguous (all info commands)    "p \"a" no completions (string constant)    "p 'a" ambiguous (all symbols starting with a)    "p b-a" ambiguous (all symbols starting with a)    "p b-" ambiguous (all symbols)    "file Make" "file" (word break hard to screw up here)    "file ../gdb.stabs/wi" "erd" (needs to not break word at slash)    */
end_comment

begin_comment
comment|/* Generate completions one by one for the completer.  Each time we are    called return another potential completion to the caller.  The function    is misnamed; it just completes on commands or passes the buck to the    command's completer function; the stuff specific to symbol completion    is in make_symbol_completion_list.     TEXT is readline's idea of the "word" we are looking at; we don't really    like readline's ideas about word breaking so we ignore it.     MATCHES is the number of matches that have currently been collected from    calling this completion function.  When zero, then we need to initialize,    otherwise the initialization has already taken place and we can just    return the next potential completion string.     Returns NULL if there are no more completions, else a pointer to a string    which is a possible completion.     RL_LINE_BUFFER is available to be looked at; it contains the entire text    of the line.  RL_POINT is the offset in that line of the cursor.  You    should pretend that the line ends at RL_POINT. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|symbol_completion_function
parameter_list|(
name|text
parameter_list|,
name|matches
parameter_list|)
name|char
modifier|*
name|text
decl_stmt|;
name|int
name|matches
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
modifier|*
name|list
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
comment|/* Cache of completions */
specifier|static
name|int
name|index
decl_stmt|;
comment|/* Next cached completion */
name|char
modifier|*
name|output
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|tmp_command
decl_stmt|,
modifier|*
name|p
decl_stmt|;
comment|/* Pointer within tmp_command which corresponds to text.  */
name|char
modifier|*
name|word
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|,
modifier|*
name|result_list
decl_stmt|;
specifier|extern
name|char
modifier|*
name|rl_line_buffer
decl_stmt|;
specifier|extern
name|int
name|rl_point
decl_stmt|;
if|if
condition|(
name|matches
operator|==
literal|0
condition|)
block|{
comment|/* The caller is beginning to accumulate a new set of completions, so 	 we need to find all of them now, and cache them for returning one at 	 a time on future calls. */
if|if
condition|(
name|list
condition|)
block|{
comment|/* Free the storage used by LIST, but not by the strings inside. 	     This is because rl_complete_internal () frees the strings. */
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|list
argument_list|)
expr_stmt|;
block|}
name|list
operator|=
literal|0
expr_stmt|;
name|index
operator|=
literal|0
expr_stmt|;
comment|/* Choose the default set of word break characters to break completions. 	 If we later find out that we are doing completions on command strings 	 (as opposed to strings supplied by the individual command completer 	 functions, which can be any string) then we will switch to the 	 special word break set for command strings, which leaves out the 	 '-' character used in some commands.  */
name|rl_completer_word_break_characters
operator|=
name|gdb_completer_word_break_characters
expr_stmt|;
comment|/* Decide whether to complete on a list of gdb commands or on symbols. */
name|tmp_command
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|rl_point
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
name|tmp_command
expr_stmt|;
name|strncpy
argument_list|(
name|tmp_command
argument_list|,
name|rl_line_buffer
argument_list|,
name|rl_point
argument_list|)
expr_stmt|;
name|tmp_command
index|[
name|rl_point
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Since text always contains some number of characters leading up 	 to rl_point, we can find the equivalent position in tmp_command 	 by subtracting that many characters from the end of tmp_command.  */
name|word
operator|=
name|tmp_command
operator|+
name|rl_point
operator|-
name|strlen
argument_list|(
name|text
argument_list|)
expr_stmt|;
if|if
condition|(
name|rl_point
operator|==
literal|0
condition|)
block|{
comment|/* An empty line we want to consider ambiguous; that is, it 	     could be any command.  */
name|c
operator|=
operator|(
expr|struct
name|cmd_list_element
operator|*
operator|)
operator|-
literal|1
expr_stmt|;
name|result_list
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|c
operator|=
name|lookup_cmd_1
argument_list|(
operator|&
name|p
argument_list|,
name|cmdlist
argument_list|,
operator|&
name|result_list
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Move p up to the next interesting thing.  */
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
block|{
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|c
condition|)
block|{
comment|/* It is an unrecognized command.  So there are no 	     possible completions.  */
name|list
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
operator|(
expr|struct
name|cmd_list_element
operator|*
operator|)
operator|-
literal|1
condition|)
block|{
name|char
modifier|*
name|q
decl_stmt|;
comment|/* lookup_cmd_1 advances p up to the first ambiguous thing, but 	     doesn't advance over that thing itself.  Do so now.  */
name|q
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|q
operator|&&
operator|(
name|isalnum
argument_list|(
operator|*
name|q
argument_list|)
operator|||
operator|*
name|q
operator|==
literal|'-'
operator|||
operator|*
name|q
operator|==
literal|'_'
operator|)
condition|)
operator|++
name|q
expr_stmt|;
if|if
condition|(
name|q
operator|!=
name|tmp_command
operator|+
name|rl_point
condition|)
block|{
comment|/* There is something beyond the ambiguous 		 command, so there are no possible completions.  For 		 example, "info t " or "info t foo" does not complete 		 to anything, because "info t" can be "info target" or 		 "info terminal".  */
name|list
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* We're trying to complete on the command which was ambiguous. 		 This we can deal with.  */
if|if
condition|(
name|result_list
condition|)
block|{
name|list
operator|=
name|complete_on_cmdlist
argument_list|(
operator|*
name|result_list
operator|->
name|prefixlist
argument_list|,
name|p
argument_list|,
name|word
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|list
operator|=
name|complete_on_cmdlist
argument_list|(
name|cmdlist
argument_list|,
name|p
argument_list|,
name|word
argument_list|)
expr_stmt|;
block|}
comment|/* Insure that readline does the right thing with respect to 		 inserting quotes.  */
name|rl_completer_word_break_characters
operator|=
name|gdb_completer_command_word_break_characters
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* We've recognized a full command.  */
if|if
condition|(
name|p
operator|==
name|tmp_command
operator|+
name|rl_point
condition|)
block|{
comment|/* There is no non-whitespace in the line beyond the command.  */
if|if
condition|(
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
operator|||
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'\t'
condition|)
block|{
comment|/* The command is followed by whitespace; we need to complete 		     on whatever comes after command.  */
if|if
condition|(
name|c
operator|->
name|prefixlist
condition|)
block|{
comment|/* It is a prefix command; what comes after it is 			 a subcommand (e.g. "info ").  */
name|list
operator|=
name|complete_on_cmdlist
argument_list|(
operator|*
name|c
operator|->
name|prefixlist
argument_list|,
name|p
argument_list|,
name|word
argument_list|)
expr_stmt|;
comment|/* Insure that readline does the right thing 			 with respect to inserting quotes.  */
name|rl_completer_word_break_characters
operator|=
name|gdb_completer_command_word_break_characters
expr_stmt|;
block|}
else|else
block|{
comment|/* It is a normal command; what comes after it is 			 completed by the command's completer function.  */
name|list
operator|=
call|(
modifier|*
name|c
operator|->
name|completer
call|)
argument_list|(
name|p
argument_list|,
name|word
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* The command is not followed by whitespace; we need to 		     complete on the command itself.  e.g. "p" which is a 		     command itself but also can complete to "print", "ptype" 		     etc.  */
name|char
modifier|*
name|q
decl_stmt|;
comment|/* Find the command we are completing on.  */
name|q
operator|=
name|p
expr_stmt|;
while|while
condition|(
name|q
operator|>
name|tmp_command
condition|)
block|{
if|if
condition|(
name|isalnum
argument_list|(
name|q
index|[
operator|-
literal|1
index|]
argument_list|)
operator|||
name|q
index|[
operator|-
literal|1
index|]
operator|==
literal|'-'
operator|||
name|q
index|[
operator|-
literal|1
index|]
operator|==
literal|'_'
condition|)
operator|--
name|q
expr_stmt|;
else|else
break|break;
block|}
name|list
operator|=
name|complete_on_cmdlist
argument_list|(
name|result_list
argument_list|,
name|q
argument_list|,
name|word
argument_list|)
expr_stmt|;
comment|/* Insure that readline does the right thing 		     with respect to inserting quotes.  */
name|rl_completer_word_break_characters
operator|=
name|gdb_completer_command_word_break_characters
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* There is non-whitespace beyond the command.  */
if|if
condition|(
name|c
operator|->
name|prefixlist
operator|&&
operator|!
name|c
operator|->
name|allow_unknown
condition|)
block|{
comment|/* It is an unrecognized subcommand of a prefix command, 		     e.g. "info adsfkdj".  */
name|list
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* It is a normal command.  */
name|list
operator|=
call|(
modifier|*
name|c
operator|->
name|completer
call|)
argument_list|(
name|p
argument_list|,
name|word
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* If we found a list of potential completions during initialization then      dole them out one at a time.  The vector of completions is NULL      terminated, so after returning the last one, return NULL (and continue      to do so) each time we are called after that, until a new list is      available. */
if|if
condition|(
name|list
condition|)
block|{
name|output
operator|=
name|list
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
name|output
condition|)
block|{
name|index
operator|++
expr_stmt|;
block|}
block|}
if|#
directive|if
literal|0
comment|/* Can't do this because readline hasn't yet checked the word breaks      for figuring out whether to insert a quote.  */
block|if (output == NULL)
comment|/* Make sure the word break characters are set back to normal for the        next time that readline tries to complete something.  */
block|rl_completer_word_break_characters =       gdb_completer_word_break_characters;
endif|#
directive|endif
return|return
operator|(
name|output
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Skip over a possibly quoted word (as defined by the quote characters    and word break characters the completer uses).  Returns pointer to the    location after the "word". */
end_comment

begin_function
name|char
modifier|*
name|skip_quoted
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|char
name|quote_char
init|=
literal|'\0'
decl_stmt|;
name|char
modifier|*
name|scan
decl_stmt|;
for|for
control|(
name|scan
operator|=
name|str
init|;
operator|*
name|scan
operator|!=
literal|'\0'
condition|;
name|scan
operator|++
control|)
block|{
if|if
condition|(
name|quote_char
operator|!=
literal|'\0'
condition|)
block|{
comment|/* Ignore everything until the matching close quote char */
if|if
condition|(
operator|*
name|scan
operator|==
name|quote_char
condition|)
block|{
comment|/* Found matching close quote. */
name|scan
operator|++
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|strchr
argument_list|(
name|gdb_completer_quote_characters
argument_list|,
operator|*
name|scan
argument_list|)
condition|)
block|{
comment|/* Found start of a quoted string. */
name|quote_char
operator|=
operator|*
name|scan
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strchr
argument_list|(
name|gdb_completer_word_break_characters
argument_list|,
operator|*
name|scan
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
return|return
operator|(
name|scan
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|STOP_SIGNAL
end_ifdef

begin_function
specifier|static
name|void
name|stop_sig
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
if|#
directive|if
name|STOP_SIGNAL
operator|==
name|SIGTSTP
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|sigsetmask
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|SIGTSTP
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|stop_sig
argument_list|)
expr_stmt|;
else|#
directive|else
name|signal
argument_list|(
name|STOP_SIGNAL
argument_list|,
name|stop_sig
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|prompt
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* Forget about any previous command -- null line now will do nothing.  */
name|dont_repeat
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* STOP_SIGNAL */
end_comment

begin_comment
comment|/* Initialize signal handlers. */
end_comment

begin_function
specifier|static
name|void
name|do_nothing
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{ }
end_function

begin_function
specifier|static
name|void
name|init_signals
parameter_list|()
block|{
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|request_quit
argument_list|)
expr_stmt|;
comment|/* If we initialize SIGQUIT to SIG_IGN, then the SIG_IGN will get      passed to the inferior, which we don't want.  It would be      possible to do a "signal (SIGQUIT, SIG_DFL)" after we fork, but      on BSD4.3 systems using vfork, that can affect the      GDB process as well as the inferior (the signal handling tables      might be in memory, shared between the two).  Since we establish      a handler for SIGQUIT, when we call exec it will set the signal      to SIG_DFL for us.  */
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|do_nothing
argument_list|)
expr_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|do_nothing
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|disconnect
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGFPE
argument_list|,
name|float_handler
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SIGWINCH
argument_list|)
operator|&&
name|defined
argument_list|(
name|SIGWINCH_HANDLER
argument_list|)
name|signal
argument_list|(
name|SIGWINCH
argument_list|,
name|SIGWINCH_HANDLER
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read one line from the command input stream `instream'    into the local static buffer `linebuffer' (whose current length    is `linelength').    The buffer is made bigger as necessary.    Returns the address of the start of the line.     NULL is returned for end of file.     *If* the instream == stdin& stdin is a terminal, the line read    is copied into the file line saver (global var char *line,    length linesize) so that it can be duplicated.     This routine either uses fancy command line editing or    simple input as the user has requested.  */
end_comment

begin_function
name|char
modifier|*
name|command_line_input
parameter_list|(
name|prrompt
parameter_list|,
name|repeat
parameter_list|)
name|char
modifier|*
name|prrompt
decl_stmt|;
name|int
name|repeat
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|linebuffer
init|=
literal|0
decl_stmt|;
specifier|static
name|unsigned
name|linelength
init|=
literal|0
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|p1
decl_stmt|;
name|char
modifier|*
name|rl
decl_stmt|;
name|char
modifier|*
name|local_prompt
init|=
name|prrompt
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|nline
decl_stmt|;
name|char
name|got_eof
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|linebuffer
operator|==
literal|0
condition|)
block|{
name|linelength
operator|=
literal|80
expr_stmt|;
name|linebuffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|linelength
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|linebuffer
expr_stmt|;
comment|/* Control-C quits instantly if typed while in this loop      since it should not wait until the user types a newline.  */
name|immediate_quit
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|STOP_SIGNAL
if|if
condition|(
name|job_control
condition|)
name|signal
argument_list|(
name|STOP_SIGNAL
argument_list|,
name|stop_sig
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Reports are that some Sys V's don't flush stdout/err on reads 	 from stdin, when stdin/out are sockets rather than ttys.  So we 	 have to do it ourselves, to make emacs-gdb and xxgdb work. 	 On other machines, doing this once per input should be a cheap nop.  */
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
comment|/* Don't use fancy stuff if not talking to stdin.  */
if|if
condition|(
name|command_editing_p
operator|&&
name|instream
operator|==
name|stdin
operator|&&
name|ISATTY
argument_list|(
name|instream
argument_list|)
condition|)
name|rl
operator|=
name|readline
argument_list|(
name|local_prompt
argument_list|)
expr_stmt|;
else|else
name|rl
operator|=
name|gdb_readline
argument_list|(
name|local_prompt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rl
operator|||
name|rl
operator|==
operator|(
name|char
operator|*
operator|)
name|EOF
condition|)
block|{
name|got_eof
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|strlen
argument_list|(
name|rl
argument_list|)
operator|+
literal|1
operator|+
operator|(
name|p
operator|-
name|linebuffer
operator|)
operator|>
name|linelength
condition|)
block|{
name|linelength
operator|=
name|strlen
argument_list|(
name|rl
argument_list|)
operator|+
literal|1
operator|+
operator|(
name|p
operator|-
name|linebuffer
operator|)
expr_stmt|;
name|nline
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|linebuffer
argument_list|,
name|linelength
argument_list|)
expr_stmt|;
name|p
operator|+=
name|nline
operator|-
name|linebuffer
expr_stmt|;
name|linebuffer
operator|=
name|nline
expr_stmt|;
block|}
name|p1
operator|=
name|rl
expr_stmt|;
comment|/* Copy line.  Don't copy null at end.  (Leaves line alone          if this was just a newline)  */
while|while
condition|(
operator|*
name|p1
condition|)
operator|*
name|p
operator|++
operator|=
operator|*
name|p1
operator|++
expr_stmt|;
name|free
argument_list|(
name|rl
argument_list|)
expr_stmt|;
comment|/* Allocated in readline.  */
if|if
condition|(
name|p
operator|==
name|linebuffer
operator|||
operator|*
operator|(
name|p
operator|-
literal|1
operator|)
operator|!=
literal|'\\'
condition|)
break|break;
name|p
operator|--
expr_stmt|;
comment|/* Put on top of '\'.  */
name|local_prompt
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|STOP_SIGNAL
if|if
condition|(
name|job_control
condition|)
name|signal
argument_list|(
name|STOP_SIGNAL
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|immediate_quit
operator|--
expr_stmt|;
if|if
condition|(
name|got_eof
condition|)
return|return
name|NULL
return|;
comment|/* Do history expansion if that is wished.  */
if|if
condition|(
name|history_expansion_p
operator|&&
name|instream
operator|==
name|stdin
operator|&&
name|ISATTY
argument_list|(
name|instream
argument_list|)
condition|)
block|{
name|char
modifier|*
name|history_value
decl_stmt|;
name|int
name|expanded
decl_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
comment|/* Insert null now.  */
name|expanded
operator|=
name|history_expand
argument_list|(
name|linebuffer
argument_list|,
operator|&
name|history_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|expanded
condition|)
block|{
comment|/* Print the changes.  */
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|history_value
argument_list|)
expr_stmt|;
comment|/* If there was an error, call this function again.  */
if|if
condition|(
name|expanded
operator|<
literal|0
condition|)
block|{
name|free
argument_list|(
name|history_value
argument_list|)
expr_stmt|;
return|return
name|command_line_input
argument_list|(
name|prrompt
argument_list|,
name|repeat
argument_list|)
return|;
block|}
if|if
condition|(
name|strlen
argument_list|(
name|history_value
argument_list|)
operator|>
name|linelength
condition|)
block|{
name|linelength
operator|=
name|strlen
argument_list|(
name|history_value
argument_list|)
operator|+
literal|1
expr_stmt|;
name|linebuffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|linebuffer
argument_list|,
name|linelength
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|linebuffer
argument_list|,
name|history_value
argument_list|)
expr_stmt|;
name|p
operator|=
name|linebuffer
operator|+
name|strlen
argument_list|(
name|linebuffer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|history_value
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If we just got an empty line, and that is supposed      to repeat the previous command, return the value in the      global buffer.  */
if|if
condition|(
name|repeat
condition|)
block|{
if|if
condition|(
name|p
operator|==
name|linebuffer
condition|)
return|return
name|line
return|;
name|p1
operator|=
name|linebuffer
expr_stmt|;
while|while
condition|(
operator|*
name|p1
operator|==
literal|' '
operator|||
operator|*
name|p1
operator|==
literal|'\t'
condition|)
name|p1
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|p1
condition|)
return|return
name|line
return|;
block|}
operator|*
name|p
operator|=
literal|0
expr_stmt|;
comment|/* Add line to history if appropriate.  */
if|if
condition|(
name|instream
operator|==
name|stdin
operator|&&
name|ISATTY
argument_list|(
name|stdin
argument_list|)
operator|&&
operator|*
name|linebuffer
condition|)
name|add_history
argument_list|(
name|linebuffer
argument_list|)
expr_stmt|;
comment|/* Note: lines consisting soley of comments are added to the command      history.  This is useful when you type a command, and then      realize you don't want to execute it quite yet.  You can comment      out the command and then later fetch it from the value history      and remove the '#'.  The kill ring is probably better, but some      people are in the habit of commenting things out.  */
name|p1
operator|=
name|linebuffer
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p1
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'"'
condition|)
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p1
operator|++
operator|)
operator|!=
literal|'"'
condition|)
block|{
comment|/* Make sure an escaped '"' doesn't make us think the string 	       is ended.  */
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
name|parse_escape
argument_list|(
operator|&
name|p1
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\''
condition|)
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p1
operator|++
operator|)
operator|!=
literal|'\''
condition|)
block|{
comment|/* Make sure an escaped '\'' doesn't make us think the string 	       is ended.  */
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
name|parse_escape
argument_list|(
operator|&
name|p1
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'#'
condition|)
block|{
comment|/* Found a comment.  */
name|p1
index|[
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
block|}
comment|/* Save into global buffer if appropriate.  */
if|if
condition|(
name|repeat
condition|)
block|{
if|if
condition|(
name|linelength
operator|>
name|linesize
condition|)
block|{
name|line
operator|=
name|xrealloc
argument_list|(
name|line
argument_list|,
name|linelength
argument_list|)
expr_stmt|;
name|linesize
operator|=
name|linelength
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|line
argument_list|,
name|linebuffer
argument_list|)
expr_stmt|;
return|return
name|line
return|;
block|}
return|return
name|linebuffer
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read lines from the input stream    and accumulate them in a chain of struct command_line's    which is then returned.  */
end_comment

begin_function
name|struct
name|command_line
modifier|*
name|read_command_lines
parameter_list|()
block|{
name|struct
name|command_line
modifier|*
name|first
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|command_line
modifier|*
name|next
decl_stmt|,
modifier|*
name|tail
init|=
literal|0
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|p1
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|dont_repeat
argument_list|()
expr_stmt|;
name|p
operator|=
name|command_line_input
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|instream
operator|==
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
comment|/* Treat end of file like "end".  */
break|break;
comment|/* Remove leading and trailing blanks.  */
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
name|p1
operator|=
name|p
operator|+
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
while|while
condition|(
name|p1
operator|!=
name|p
operator|&&
operator|(
name|p1
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
operator|||
name|p1
index|[
operator|-
literal|1
index|]
operator|==
literal|'\t'
operator|)
condition|)
name|p1
operator|--
expr_stmt|;
comment|/* Is this "end"?  */
if|if
condition|(
name|p1
operator|-
name|p
operator|==
literal|3
operator|&&
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"end"
argument_list|,
literal|3
argument_list|)
condition|)
break|break;
comment|/* No => add this line to the chain of command lines.  */
name|next
operator|=
operator|(
expr|struct
name|command_line
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|command_line
argument_list|)
argument_list|)
expr_stmt|;
name|next
operator|->
name|line
operator|=
name|savestring
argument_list|(
name|p
argument_list|,
name|p1
operator|-
name|p
argument_list|)
expr_stmt|;
name|next
operator|->
name|next
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tail
condition|)
block|{
name|tail
operator|->
name|next
operator|=
name|next
expr_stmt|;
block|}
else|else
block|{
comment|/* We just read the first line. 	     From now on, arrange to throw away the lines we have 	     if we quit or get an error while inside this function.  */
name|first
operator|=
name|next
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|free_command_lines
argument_list|,
operator|&
name|first
argument_list|)
expr_stmt|;
block|}
name|tail
operator|=
name|next
expr_stmt|;
block|}
name|dont_repeat
argument_list|()
expr_stmt|;
comment|/* Now we are about to return the chain to our caller,      so freeing it becomes his responsibility.  */
if|if
condition|(
name|first
condition|)
name|discard_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
name|first
return|;
block|}
end_function

begin_comment
comment|/* Free a chain of struct command_line's.  */
end_comment

begin_function
name|void
name|free_command_lines
parameter_list|(
name|lptr
parameter_list|)
name|struct
name|command_line
modifier|*
modifier|*
name|lptr
decl_stmt|;
block|{
specifier|register
name|struct
name|command_line
modifier|*
name|l
init|=
operator|*
name|lptr
decl_stmt|;
specifier|register
name|struct
name|command_line
modifier|*
name|next
decl_stmt|;
while|while
condition|(
name|l
condition|)
block|{
name|next
operator|=
name|l
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|l
operator|->
name|line
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|l
argument_list|)
expr_stmt|;
name|l
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add an element to the list of info subcommands.  */
end_comment

begin_function_decl
name|void
name|add_info
parameter_list|(
name|name
parameter_list|,
name|fun
parameter_list|,
name|doc
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
function_decl|void
parameter_list|(
function_decl|*fun
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|doc
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|add_cmd
argument_list|(
name|name
argument_list|,
name|no_class
argument_list|,
name|fun
argument_list|,
name|doc
argument_list|,
operator|&
name|infolist
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Add an alias to the list of info subcommands.  */
end_comment

begin_function
name|void
name|add_info_alias
parameter_list|(
name|name
parameter_list|,
name|oldname
parameter_list|,
name|abbrev_flag
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|oldname
decl_stmt|;
name|int
name|abbrev_flag
decl_stmt|;
block|{
name|add_alias_cmd
argument_list|(
name|name
argument_list|,
name|oldname
argument_list|,
literal|0
argument_list|,
name|abbrev_flag
argument_list|,
operator|&
name|infolist
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The "info" command is defined as a prefix, with allow_unknown = 0.    Therefore, its own definition is called only for "info" with no args.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|info_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"\"info\" must be followed by the name of an info command.\n"
argument_list|)
expr_stmt|;
name|help_list
argument_list|(
name|infolist
argument_list|,
literal|"info "
argument_list|,
operator|-
literal|1
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The "show" command with no arguments shows all the settings.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|show_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|cmd_show_list
argument_list|(
name|showlist
argument_list|,
name|from_tty
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add an element to the list of commands.  */
end_comment

begin_function_decl
name|void
name|add_com
parameter_list|(
name|name
parameter_list|,
name|class
parameter_list|,
name|fun
parameter_list|,
name|doc
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|enum
name|command_class
name|class
decl_stmt|;
function_decl|void
parameter_list|(
function_decl|*fun
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|doc
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|add_cmd
argument_list|(
name|name
argument_list|,
name|class
argument_list|,
name|fun
argument_list|,
name|doc
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Add an alias or abbreviation command to the list of commands.  */
end_comment

begin_function
name|void
name|add_com_alias
parameter_list|(
name|name
parameter_list|,
name|oldname
parameter_list|,
name|class
parameter_list|,
name|abbrev_flag
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|oldname
decl_stmt|;
name|enum
name|command_class
name|class
decl_stmt|;
name|int
name|abbrev_flag
decl_stmt|;
block|{
name|add_alias_cmd
argument_list|(
name|name
argument_list|,
name|oldname
argument_list|,
name|class
argument_list|,
name|abbrev_flag
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|error_no_arg
parameter_list|(
name|why
parameter_list|)
name|char
modifier|*
name|why
decl_stmt|;
block|{
name|error
argument_list|(
literal|"Argument required (%s)."
argument_list|,
name|why
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|help_command
parameter_list|(
name|command
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|command
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
comment|/* Ignored */
block|{
name|help_cmd
argument_list|(
name|command
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|validate_comname
parameter_list|(
name|comname
parameter_list|)
name|char
modifier|*
name|comname
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|comname
operator|==
literal|0
condition|)
name|error_no_arg
argument_list|(
literal|"name of command to define"
argument_list|)
expr_stmt|;
name|p
operator|=
name|comname
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
operator|!
name|isalnum
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
operator|*
name|p
operator|!=
literal|'-'
condition|)
name|error
argument_list|(
literal|"Junk in argument list: \"%s\""
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This is just a placeholder in the command data structures.  */
end_comment

begin_function
specifier|static
name|void
name|user_defined_command
parameter_list|(
name|ignore
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|ignore
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{ }
end_function

begin_function
specifier|static
name|void
name|define_command
parameter_list|(
name|comname
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|comname
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|register
name|struct
name|command_line
modifier|*
name|cmds
decl_stmt|;
specifier|register
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|,
modifier|*
name|newc
decl_stmt|,
modifier|*
name|hookc
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|tem
init|=
name|comname
decl_stmt|;
define|#
directive|define
name|HOOK_STRING
value|"hook-"
define|#
directive|define
name|HOOK_LEN
value|5
name|validate_comname
argument_list|(
name|comname
argument_list|)
expr_stmt|;
comment|/* Look it up, and verify that we got an exact match.  */
name|c
operator|=
name|lookup_cmd
argument_list|(
operator|&
name|tem
argument_list|,
name|cmdlist
argument_list|,
literal|""
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|&&
operator|!
name|STREQ
argument_list|(
name|comname
argument_list|,
name|c
operator|->
name|name
argument_list|)
condition|)
name|c
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|class
operator|==
name|class_user
operator|||
name|c
operator|->
name|class
operator|==
name|class_alias
condition|)
name|tem
operator|=
literal|"Redefine command \"%s\"? "
expr_stmt|;
else|else
name|tem
operator|=
literal|"Really redefine built-in command \"%s\"? "
expr_stmt|;
if|if
condition|(
operator|!
name|query
argument_list|(
name|tem
argument_list|,
name|c
operator|->
name|name
argument_list|)
condition|)
name|error
argument_list|(
literal|"Command \"%s\" not redefined."
argument_list|,
name|c
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* If this new command is a hook, then mark the command which it      is hooking.  Note that we allow hooking `help' commands, so that      we can hook the `stop' pseudo-command.  */
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|comname
argument_list|,
name|HOOK_STRING
argument_list|,
name|HOOK_LEN
argument_list|)
condition|)
block|{
comment|/* Look up cmd it hooks, and verify that we got an exact match.  */
name|tem
operator|=
name|comname
operator|+
name|HOOK_LEN
expr_stmt|;
name|hookc
operator|=
name|lookup_cmd
argument_list|(
operator|&
name|tem
argument_list|,
name|cmdlist
argument_list|,
literal|""
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|hookc
operator|&&
operator|!
name|STREQ
argument_list|(
name|comname
operator|+
name|HOOK_LEN
argument_list|,
name|hookc
operator|->
name|name
argument_list|)
condition|)
name|hookc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|hookc
condition|)
block|{
name|warning
argument_list|(
literal|"Your new `%s' command does not hook any existing command."
argument_list|,
name|comname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|query
argument_list|(
literal|"Proceed? "
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
condition|)
name|error
argument_list|(
literal|"Not confirmed."
argument_list|)
expr_stmt|;
block|}
block|}
name|comname
operator|=
name|savestring
argument_list|(
name|comname
argument_list|,
name|strlen
argument_list|(
name|comname
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the rest of the commands will be case insensitive, this one       should behave in the same manner. */
for|for
control|(
name|tem
operator|=
name|comname
init|;
operator|*
name|tem
condition|;
name|tem
operator|++
control|)
if|if
condition|(
name|isupper
argument_list|(
operator|*
name|tem
argument_list|)
condition|)
operator|*
name|tem
operator|=
name|tolower
argument_list|(
operator|*
name|tem
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
block|{
name|printf
argument_list|(
literal|"Type commands for definition of \"%s\".\n\ End with a line saying just \"end\".\n"
argument_list|,
name|comname
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|cmds
operator|=
name|read_command_lines
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|&&
name|c
operator|->
name|class
operator|==
name|class_user
condition|)
name|free_command_lines
argument_list|(
operator|&
name|c
operator|->
name|user_commands
argument_list|)
expr_stmt|;
name|newc
operator|=
name|add_cmd
argument_list|(
name|comname
argument_list|,
name|class_user
argument_list|,
name|user_defined_command
argument_list|,
operator|(
name|c
operator|&&
name|c
operator|->
name|class
operator|==
name|class_user
operator|)
condition|?
name|c
operator|->
name|doc
else|:
name|savestring
argument_list|(
literal|"User-defined."
argument_list|,
literal|13
argument_list|)
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|newc
operator|->
name|user_commands
operator|=
name|cmds
expr_stmt|;
comment|/* If this new command is a hook, then mark both commands as being      tied.  */
if|if
condition|(
name|hookc
condition|)
block|{
name|hookc
operator|->
name|hook
operator|=
name|newc
expr_stmt|;
comment|/* Target gets hooked.  */
name|newc
operator|->
name|hookee
operator|=
name|hookc
expr_stmt|;
comment|/* We are marked as hooking target cmd.  */
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|document_command
parameter_list|(
name|comname
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|comname
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|struct
name|command_line
modifier|*
name|doclines
decl_stmt|;
specifier|register
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
name|char
modifier|*
name|tem
init|=
name|comname
decl_stmt|;
name|validate_comname
argument_list|(
name|comname
argument_list|)
expr_stmt|;
name|c
operator|=
name|lookup_cmd
argument_list|(
operator|&
name|tem
argument_list|,
name|cmdlist
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|class
operator|!=
name|class_user
condition|)
name|error
argument_list|(
literal|"Command \"%s\" is built-in."
argument_list|,
name|comname
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
name|printf
argument_list|(
literal|"Type documentation for \"%s\".\n\ End with a line saying just \"end\".\n"
argument_list|,
name|comname
argument_list|)
expr_stmt|;
name|doclines
operator|=
name|read_command_lines
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|doc
condition|)
name|free
argument_list|(
name|c
operator|->
name|doc
argument_list|)
expr_stmt|;
block|{
specifier|register
name|struct
name|command_line
modifier|*
name|cl1
decl_stmt|;
specifier|register
name|int
name|len
init|=
literal|0
decl_stmt|;
for|for
control|(
name|cl1
operator|=
name|doclines
init|;
name|cl1
condition|;
name|cl1
operator|=
name|cl1
operator|->
name|next
control|)
name|len
operator|+=
name|strlen
argument_list|(
name|cl1
operator|->
name|line
argument_list|)
operator|+
literal|1
expr_stmt|;
name|c
operator|->
name|doc
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|*
name|c
operator|->
name|doc
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|cl1
operator|=
name|doclines
init|;
name|cl1
condition|;
name|cl1
operator|=
name|cl1
operator|->
name|next
control|)
block|{
name|strcat
argument_list|(
name|c
operator|->
name|doc
argument_list|,
name|cl1
operator|->
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|cl1
operator|->
name|next
condition|)
name|strcat
argument_list|(
name|c
operator|->
name|doc
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|free_command_lines
argument_list|(
operator|&
name|doclines
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|print_gnu_advertisement
parameter_list|()
block|{
name|printf
argument_list|(
literal|"\ GDB is free software and you are welcome to distribute copies of it\n\  under certain conditions; type \"show copying\" to see the conditions.\n\ There is absolutely no warranty for GDB; type \"show warranty\" for details.\n\ "
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_gdb_version
parameter_list|(
name|stream
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\ GDB %s (%s"
argument_list|,
name|version
argument_list|,
name|host_canonical
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|host_canonical
argument_list|,
name|target_canonical
argument_list|)
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" --target %s"
argument_list|,
name|target_canonical
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"), "
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"Copyright 1993 Free Software Foundation, Inc."
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|show_version
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|immediate_quit
operator|++
expr_stmt|;
name|print_gnu_advertisement
argument_list|()
expr_stmt|;
name|print_gdb_version
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|immediate_quit
operator|--
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* xgdb calls this to reprint the usual GDB prompt.  */
end_comment

begin_function
name|void
name|print_prompt
parameter_list|()
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|prompt
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|quit_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
if|if
condition|(
name|inferior_pid
operator|!=
literal|0
operator|&&
name|target_has_execution
condition|)
block|{
if|if
condition|(
name|attach_flag
condition|)
block|{
if|if
condition|(
name|query
argument_list|(
literal|"The program is running.  Quit anyway (and detach it)? "
argument_list|)
condition|)
name|target_detach
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"Not confirmed."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|query
argument_list|(
literal|"The program is running.  Quit anyway (and kill it)? "
argument_list|)
condition|)
name|target_kill
argument_list|()
expr_stmt|;
else|else
name|error
argument_list|(
literal|"Not confirmed."
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Save the history information if it is appropriate to do so.  */
if|if
condition|(
name|write_history_p
operator|&&
name|history_filename
condition|)
name|write_history
argument_list|(
name|history_filename
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns whether GDB is running on a terminal and whether the user    desires that questions be asked of them on that terminal.  */
end_comment

begin_function
name|int
name|input_from_terminal_p
parameter_list|()
block|{
return|return
name|gdb_has_a_terminal
argument_list|()
operator|&&
operator|(
name|instream
operator|==
name|stdin
operator|)
operator|&
name|caution
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|pwd_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
if|if
condition|(
name|args
condition|)
name|error
argument_list|(
literal|"The \"pwd\" command does not take an argument: %s"
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|getcwd
argument_list|(
name|dirbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|dirbuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|STREQ
argument_list|(
name|dirbuf
argument_list|,
name|current_directory
argument_list|)
condition|)
name|printf
argument_list|(
literal|"Working directory %s\n (canonically %s).\n"
argument_list|,
name|current_directory
argument_list|,
name|dirbuf
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"Working directory %s.\n"
argument_list|,
name|current_directory
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cd_command
parameter_list|(
name|dir
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
comment|/* Found something other than leading repetitions of "/..".  */
name|int
name|found_real_path
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/* If the new directory is absolute, repeat is a no-op; if relative,      repeat might be useful but is more likely to be a mistake.  */
name|dont_repeat
argument_list|()
expr_stmt|;
if|if
condition|(
name|dir
operator|==
literal|0
condition|)
name|error_no_arg
argument_list|(
literal|"new working directory"
argument_list|)
expr_stmt|;
name|dir
operator|=
name|tilde_expand
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
name|dir
argument_list|)
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|dir
operator|=
name|savestring
argument_list|(
name|dir
argument_list|,
name|len
operator|-
operator|(
name|len
operator|>
literal|1
operator|&&
name|dir
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'/'
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
name|current_directory
operator|=
name|dir
expr_stmt|;
else|else
block|{
if|if
condition|(
name|current_directory
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
name|current_directory
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
name|current_directory
operator|=
name|concat
argument_list|(
name|current_directory
argument_list|,
name|dir
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|current_directory
operator|=
name|concat
argument_list|(
name|current_directory
argument_list|,
literal|"/"
argument_list|,
name|dir
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dir
argument_list|)
expr_stmt|;
block|}
comment|/* Now simplify any occurrences of `.' and `..' in the pathname.  */
name|found_real_path
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|current_directory
init|;
operator|*
name|p
condition|;
control|)
block|{
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|p
index|[
literal|2
index|]
operator|==
literal|0
operator|||
name|p
index|[
literal|2
index|]
operator|==
literal|'/'
operator|)
condition|)
name|strcpy
argument_list|(
name|p
argument_list|,
name|p
operator|+
literal|2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|p
index|[
literal|2
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|p
index|[
literal|3
index|]
operator|==
literal|0
operator|||
name|p
index|[
literal|3
index|]
operator|==
literal|'/'
operator|)
condition|)
block|{
if|if
condition|(
name|found_real_path
condition|)
block|{
comment|/* Search backwards for the directory just before the "/.." 		 and obliterate it and the "/..".  */
name|char
modifier|*
name|q
init|=
name|p
decl_stmt|;
while|while
condition|(
name|q
operator|!=
name|current_directory
operator|&&
name|q
index|[
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
operator|--
name|q
expr_stmt|;
if|if
condition|(
name|q
operator|==
name|current_directory
condition|)
comment|/* current_directory is 		   a relative pathname ("can't happen"--leave it alone).  */
operator|++
name|p
expr_stmt|;
else|else
block|{
name|strcpy
argument_list|(
name|q
operator|-
literal|1
argument_list|,
name|p
operator|+
literal|3
argument_list|)
expr_stmt|;
name|p
operator|=
name|q
operator|-
literal|1
expr_stmt|;
block|}
block|}
else|else
comment|/* We are dealing with leading repetitions of "/..", for example 	       "/../..", which is the Mach super-root.  */
name|p
operator|+=
literal|3
expr_stmt|;
block|}
else|else
block|{
name|found_real_path
operator|=
literal|1
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
block|}
name|forget_cached_source_info
argument_list|()
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
name|pwd_command
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|source_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|FILE
modifier|*
name|stream
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|cleanups
decl_stmt|;
name|char
modifier|*
name|file
init|=
name|args
decl_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"source command requires pathname of file to source."
argument_list|)
expr_stmt|;
block|}
name|file
operator|=
name|tilde_expand
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|stream
operator|=
name|fopen
argument_list|(
name|file
argument_list|,
name|FOPEN_RT
argument_list|)
expr_stmt|;
if|if
condition|(
name|stream
operator|==
literal|0
condition|)
name|perror_with_name
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|cleanups
operator|=
name|make_cleanup
argument_list|(
name|fclose
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|read_command_file
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|cleanups
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|echo_command
parameter_list|(
name|text
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|text
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|char
modifier|*
name|p
init|=
name|text
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
if|if
condition|(
name|text
condition|)
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
comment|/* \ at end of argument is used after spaces 	       so they won't be lost.  */
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
return|return;
name|c
operator|=
name|parse_escape
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|0
condition|)
name|printf_filtered
argument_list|(
literal|"%c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
else|else
name|printf_filtered
argument_list|(
literal|"%c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
comment|/* Force this output to appear now.  */
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Functions to manipulate command line editing control variables.  */
end_comment

begin_comment
comment|/* Number of commands to print in each call to show_commands.  */
end_comment

begin_define
define|#
directive|define
name|Hist_print
value|10
end_define

begin_function
specifier|static
name|void
name|show_commands
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
comment|/* Index for history commands.  Relative to history_base.  */
name|int
name|offset
decl_stmt|;
comment|/* Number of the history entry which we are planning to display next.      Relative to history_base.  */
specifier|static
name|int
name|num
init|=
literal|0
decl_stmt|;
comment|/* The first command in the history which doesn't exist (i.e. one more      than the number of the last command).  Relative to history_base.  */
name|int
name|hist_len
decl_stmt|;
specifier|extern
name|struct
name|_hist_entry
modifier|*
name|history_get
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|history_base
decl_stmt|;
comment|/* Print out some of the commands from the command history.  */
comment|/* First determine the length of the history list.  */
name|hist_len
operator|=
name|history_size
expr_stmt|;
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|offset
operator|<
name|history_size
condition|;
name|offset
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|history_get
argument_list|(
name|history_base
operator|+
name|offset
argument_list|)
condition|)
block|{
name|hist_len
operator|=
name|offset
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|args
condition|)
block|{
if|if
condition|(
name|args
index|[
literal|0
index|]
operator|==
literal|'+'
operator|&&
name|args
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
comment|/* "info editing +" should print from the stored position.  */
empty_stmt|;
else|else
comment|/* "info editing<exp>" should print around command number<exp>.  */
name|num
operator|=
operator|(
name|parse_and_eval_address
argument_list|(
name|args
argument_list|)
operator|-
name|history_base
operator|)
operator|-
name|Hist_print
operator|/
literal|2
expr_stmt|;
block|}
comment|/* "show commands" means print the last Hist_print commands.  */
else|else
block|{
name|num
operator|=
name|hist_len
operator|-
name|Hist_print
expr_stmt|;
block|}
if|if
condition|(
name|num
operator|<
literal|0
condition|)
name|num
operator|=
literal|0
expr_stmt|;
comment|/* If there are at least Hist_print commands, we want to display the last      Hist_print rather than, say, the last 6.  */
if|if
condition|(
name|hist_len
operator|-
name|num
operator|<
name|Hist_print
condition|)
block|{
name|num
operator|=
name|hist_len
operator|-
name|Hist_print
expr_stmt|;
if|if
condition|(
name|num
operator|<
literal|0
condition|)
name|num
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|offset
operator|=
name|num
init|;
name|offset
operator|<
name|num
operator|+
name|Hist_print
operator|&&
name|offset
operator|<
name|hist_len
condition|;
name|offset
operator|++
control|)
block|{
name|printf_filtered
argument_list|(
literal|"%5d  %s\n"
argument_list|,
name|history_base
operator|+
name|offset
argument_list|,
operator|(
name|history_get
argument_list|(
name|history_base
operator|+
name|offset
argument_list|)
operator|)
operator|->
name|line
argument_list|)
expr_stmt|;
block|}
comment|/* The next command we want to display is the next one that we haven't      displayed yet.  */
name|num
operator|+=
name|Hist_print
expr_stmt|;
comment|/* If the user repeats this command with return, it should do what      "show commands +" does.  This is unnecessary if arg is null,      because "show commands +" is not useful after "show commands".  */
if|if
condition|(
name|from_tty
operator|&&
name|args
condition|)
block|{
name|args
index|[
literal|0
index|]
operator|=
literal|'+'
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Called by do_setshow_command.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|set_history_size_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|,
name|c
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
block|{
if|if
condition|(
name|history_size
operator|==
name|INT_MAX
condition|)
name|unstifle_history
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|history_size
operator|>=
literal|0
condition|)
name|stifle_history
argument_list|(
name|history_size
argument_list|)
expr_stmt|;
else|else
block|{
name|history_size
operator|=
name|INT_MAX
expr_stmt|;
name|error
argument_list|(
literal|"History size must be non-negative"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|set_history
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"\"set history\" must be followed by the name of a history subcommand.\n"
argument_list|)
expr_stmt|;
name|help_list
argument_list|(
name|sethistlist
argument_list|,
literal|"set history "
argument_list|,
operator|-
literal|1
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|show_history
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|cmd_show_list
argument_list|(
name|showhistlist
argument_list|,
name|from_tty
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|int
name|info_verbose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default verbose msgs off */
end_comment

begin_comment
comment|/* Called by do_setshow_command.  An elaborate joke.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|set_verbose
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|,
name|c
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
block|{
name|char
modifier|*
name|cmdname
init|=
literal|"verbose"
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
name|showcmd
decl_stmt|;
name|showcmd
operator|=
name|lookup_cmd_1
argument_list|(
operator|&
name|cmdname
argument_list|,
name|showlist
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_verbose
condition|)
block|{
name|c
operator|->
name|doc
operator|=
literal|"Set verbose printing of informational messages."
expr_stmt|;
name|showcmd
operator|->
name|doc
operator|=
literal|"Show verbose printing of informational messages."
expr_stmt|;
block|}
else|else
block|{
name|c
operator|->
name|doc
operator|=
literal|"Set verbosity."
expr_stmt|;
name|showcmd
operator|->
name|doc
operator|=
literal|"Show verbosity."
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|float_handler
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
comment|/* This message is based on ANSI C, section 4.7.  Note that integer      divide by zero causes this, so "float" is a misnomer.  */
name|signal
argument_list|(
name|SIGFPE
argument_list|,
name|float_handler
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Erroneous arithmetic operation."
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return whether we are running a batch file or from terminal.  */
end_comment

begin_function
name|int
name|batch_mode
parameter_list|()
block|{
return|return
operator|!
operator|(
name|instream
operator|==
name|stdin
operator|&&
name|ISATTY
argument_list|(
name|stdin
argument_list|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|init_cmd_lists
parameter_list|()
block|{
name|cmdlist
operator|=
name|NULL
expr_stmt|;
name|infolist
operator|=
name|NULL
expr_stmt|;
name|enablelist
operator|=
name|NULL
expr_stmt|;
name|disablelist
operator|=
name|NULL
expr_stmt|;
name|deletelist
operator|=
name|NULL
expr_stmt|;
name|enablebreaklist
operator|=
name|NULL
expr_stmt|;
name|setlist
operator|=
name|NULL
expr_stmt|;
name|unsetlist
operator|=
name|NULL
expr_stmt|;
name|showlist
operator|=
name|NULL
expr_stmt|;
name|sethistlist
operator|=
name|NULL
expr_stmt|;
name|showhistlist
operator|=
name|NULL
expr_stmt|;
name|unsethistlist
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
name|MAINTENANCE_CMDS
name|maintenancelist
operator|=
name|NULL
expr_stmt|;
name|maintenanceinfolist
operator|=
name|NULL
expr_stmt|;
name|maintenanceprintlist
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
name|setprintlist
operator|=
name|NULL
expr_stmt|;
name|showprintlist
operator|=
name|NULL
expr_stmt|;
name|setchecklist
operator|=
name|NULL
expr_stmt|;
name|showchecklist
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Init the history buffer.  Note that we are called after the init file(s)  * have been read so that the user can change the history file via his  * .gdbinit file (for instance).  The GDBHISTFILE environment variable  * overrides all of this.  */
end_comment

begin_function
specifier|static
name|void
name|init_history
parameter_list|()
block|{
name|char
modifier|*
name|tmpenv
decl_stmt|;
name|tmpenv
operator|=
name|getenv
argument_list|(
literal|"HISTSIZE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpenv
condition|)
name|history_size
operator|=
name|atoi
argument_list|(
name|tmpenv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|history_size
condition|)
name|history_size
operator|=
literal|256
expr_stmt|;
name|stifle_history
argument_list|(
name|history_size
argument_list|)
expr_stmt|;
name|tmpenv
operator|=
name|getenv
argument_list|(
literal|"GDBHISTFILE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpenv
condition|)
name|history_filename
operator|=
name|savestring
argument_list|(
name|tmpenv
argument_list|,
name|strlen
argument_list|(
name|tmpenv
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|history_filename
condition|)
block|{
comment|/* We include the current directory so that if the user changes        directories the file written will be the same as the one        that was read.  */
name|history_filename
operator|=
name|concat
argument_list|(
name|current_directory
argument_list|,
literal|"/.gdb_history"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|read_history
argument_list|(
name|history_filename
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_main
parameter_list|()
block|{
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
ifdef|#
directive|ifdef
name|DEFAULT_PROMPT
name|prompt
operator|=
name|savestring
argument_list|(
name|DEFAULT_PROMPT
argument_list|,
name|strlen
argument_list|(
name|DEFAULT_PROMPT
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|prompt
operator|=
name|savestring
argument_list|(
literal|"(gdb) "
argument_list|,
literal|6
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Set the important stuff up for command editing.  */
name|command_editing_p
operator|=
literal|1
expr_stmt|;
name|history_expansion_p
operator|=
literal|0
expr_stmt|;
name|write_history_p
operator|=
literal|0
expr_stmt|;
comment|/* Setup important stuff for command line editing.  */
name|rl_completion_entry_function
operator|=
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|symbol_completion_function
expr_stmt|;
name|rl_completer_word_break_characters
operator|=
name|gdb_completer_word_break_characters
expr_stmt|;
name|rl_completer_quote_characters
operator|=
name|gdb_completer_quote_characters
expr_stmt|;
name|rl_readline_name
operator|=
literal|"gdb"
expr_stmt|;
comment|/* Define the classes of commands.      They will appear in the help list in the reverse of this order.  */
name|add_cmd
argument_list|(
literal|"internals"
argument_list|,
name|class_maintenance
argument_list|,
name|NO_FUNCTION
argument_list|,
literal|"Maintenance commands.\n\ Some gdb commands are provided just for use by gdb maintainers.\n\ These commands are subject to frequent change, and may not be as\n\ well documented as user commands."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"obscure"
argument_list|,
name|class_obscure
argument_list|,
name|NO_FUNCTION
argument_list|,
literal|"Obscure features."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"aliases"
argument_list|,
name|class_alias
argument_list|,
name|NO_FUNCTION
argument_list|,
literal|"Aliases of other commands."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"user-defined"
argument_list|,
name|class_user
argument_list|,
name|NO_FUNCTION
argument_list|,
literal|"User-defined commands.\n\ The commands in this class are those defined by the user.\n\ Use the \"define\" command to define a command."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"support"
argument_list|,
name|class_support
argument_list|,
name|NO_FUNCTION
argument_list|,
literal|"Support facilities."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"status"
argument_list|,
name|class_info
argument_list|,
name|NO_FUNCTION
argument_list|,
literal|"Status inquiries."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"files"
argument_list|,
name|class_files
argument_list|,
name|NO_FUNCTION
argument_list|,
literal|"Specifying and examining files."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"breakpoints"
argument_list|,
name|class_breakpoint
argument_list|,
name|NO_FUNCTION
argument_list|,
literal|"Making program stop at certain points."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"data"
argument_list|,
name|class_vars
argument_list|,
name|NO_FUNCTION
argument_list|,
literal|"Examining data."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"stack"
argument_list|,
name|class_stack
argument_list|,
name|NO_FUNCTION
argument_list|,
literal|"Examining the stack.\n\ The stack is made up of stack frames.  Gdb assigns numbers to stack frames\n\ counting from zero for the innermost (currently executing) frame.\n\n\ At any time gdb identifies one frame as the \"selected\" frame.\n\ Variable lookups are done with respect to the selected frame.\n\ When the program being debugged stops, gdb selects the innermost frame.\n\ The commands below can be used to select other frames by number or address."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"running"
argument_list|,
name|class_run
argument_list|,
name|NO_FUNCTION
argument_list|,
literal|"Running the program."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"pwd"
argument_list|,
name|class_files
argument_list|,
name|pwd_command
argument_list|,
literal|"Print working directory.  This is used for your program as well."
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_cmd
argument_list|(
literal|"cd"
argument_list|,
name|class_files
argument_list|,
name|cd_command
argument_list|,
literal|"Set working directory to DIR for debugger and program being debugged.\n\ The change does not take effect for the program being debugged\n\ until the next time it is started."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|c
operator|->
name|completer
operator|=
name|filename_completer
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"prompt"
argument_list|,
name|class_support
argument_list|,
name|var_string
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|prompt
argument_list|,
literal|"Set gdb's prompt"
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"echo"
argument_list|,
name|class_support
argument_list|,
name|echo_command
argument_list|,
literal|"Print a constant string.  Give string as argument.\n\ C escape sequences may be used in the argument.\n\ No newline is added at the end of the argument;\n\ use \"\\n\" if you want a newline to be printed.\n\ Since leading and trailing whitespace are ignored in command arguments,\n\ if you want to print some you must use \"\\\" before leading whitespace\n\ to be printed or after trailing whitespace."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"document"
argument_list|,
name|class_support
argument_list|,
name|document_command
argument_list|,
literal|"Document a user-defined command.\n\ Give command name as argument.  Give documentation on following lines.\n\ End with a line of just \"end\"."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"define"
argument_list|,
name|class_support
argument_list|,
name|define_command
argument_list|,
literal|"Define a new command name.  Command name is argument.\n\ Definition appears on following lines, one command per line.\n\ End with a line of just \"end\".\n\ Use the \"document\" command to give documentation for the new command.\n\ Commands defined in this way do not take arguments."
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__STDC__
name|c
operator|=
name|add_cmd
argument_list|(
literal|"source"
argument_list|,
name|class_support
argument_list|,
name|source_command
argument_list|,
literal|"Read commands from a file named FILE.\n\ Note that the file \""
name|GDBINIT_FILENAME
literal|"\" is read automatically in this way\n\ when gdb is started."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Punt file name, we can't help it easily.  */
name|c
operator|=
name|add_cmd
argument_list|(
literal|"source"
argument_list|,
name|class_support
argument_list|,
name|source_command
argument_list|,
literal|"Read commands from a file named FILE.\n\ Note that the file \".gdbinit\" is read automatically in this way\n\ when gdb is started."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|c
operator|->
name|completer
operator|=
name|filename_completer
expr_stmt|;
name|add_com
argument_list|(
literal|"quit"
argument_list|,
name|class_support
argument_list|,
name|quit_command
argument_list|,
literal|"Exit gdb."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"help"
argument_list|,
name|class_support
argument_list|,
name|help_command
argument_list|,
literal|"Print list of commands."
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"q"
argument_list|,
literal|"quit"
argument_list|,
name|class_support
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"h"
argument_list|,
literal|"help"
argument_list|,
name|class_support
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_set_cmd
argument_list|(
literal|"verbose"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|info_verbose
argument_list|,
literal|"Set "
argument_list|,
operator|&
name|setlist
argument_list|)
operator|,
name|add_show_from_set
argument_list|(
name|c
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|c
operator|->
name|function
operator|.
name|sfunc
operator|=
name|set_verbose
expr_stmt|;
name|set_verbose
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"editing"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|command_editing_p
argument_list|,
literal|"Set editing of command lines as they are typed.\n\ Use \"on\" to enable to enable the editing, and \"off\" to disable it.\n\ Without an argument, command line editing is enabled.  To edit, use\n\ EMACS-like or VI-like commands like control-P or ESC."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"history"
argument_list|,
name|class_support
argument_list|,
name|set_history
argument_list|,
literal|"Generic command for setting command history parameters."
argument_list|,
operator|&
name|sethistlist
argument_list|,
literal|"set history "
argument_list|,
literal|0
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"history"
argument_list|,
name|class_support
argument_list|,
name|show_history
argument_list|,
literal|"Generic command for showing command history parameters."
argument_list|,
operator|&
name|showhistlist
argument_list|,
literal|"show history "
argument_list|,
literal|0
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"expansion"
argument_list|,
name|no_class
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|history_expansion_p
argument_list|,
literal|"Set history expansion on command input.\n\ Without an argument, history expansion is enabled."
argument_list|,
operator|&
name|sethistlist
argument_list|)
argument_list|,
operator|&
name|showhistlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"save"
argument_list|,
name|no_class
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|write_history_p
argument_list|,
literal|"Set saving of the history record on exit.\n\ Use \"on\" to enable to enable the saving, and \"off\" to disable it.\n\ Without an argument, saving is enabled."
argument_list|,
operator|&
name|sethistlist
argument_list|)
argument_list|,
operator|&
name|showhistlist
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_set_cmd
argument_list|(
literal|"size"
argument_list|,
name|no_class
argument_list|,
name|var_integer
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|history_size
argument_list|,
literal|"Set the size of the command history, \n\ ie. the number of previous commands to keep a record of."
argument_list|,
operator|&
name|sethistlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|c
argument_list|,
operator|&
name|showhistlist
argument_list|)
expr_stmt|;
name|c
operator|->
name|function
operator|.
name|sfunc
operator|=
name|set_history_size_command
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"filename"
argument_list|,
name|no_class
argument_list|,
name|var_filename
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|history_filename
argument_list|,
literal|"Set the filename in which to record the command history\n\  (the list of previous commands of which a record is kept)."
argument_list|,
operator|&
name|sethistlist
argument_list|)
argument_list|,
operator|&
name|showhistlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"confirm"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|caution
argument_list|,
literal|"Set whether to confirm potentially dangerous operations."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"info"
argument_list|,
name|class_info
argument_list|,
name|info_command
argument_list|,
literal|"Generic command for showing things about the program being debugged."
argument_list|,
operator|&
name|infolist
argument_list|,
literal|"info "
argument_list|,
literal|0
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"i"
argument_list|,
literal|"info"
argument_list|,
name|class_info
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"show"
argument_list|,
name|class_info
argument_list|,
name|show_command
argument_list|,
literal|"Generic command for showing things about the debugger."
argument_list|,
operator|&
name|showlist
argument_list|,
literal|"show "
argument_list|,
literal|0
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
comment|/* Another way to get at the same thing.  */
name|add_info
argument_list|(
literal|"set"
argument_list|,
name|show_command
argument_list|,
literal|"Show all GDB settings."
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"commands"
argument_list|,
name|no_class
argument_list|,
name|show_commands
argument_list|,
literal|"Show the the history of commands you typed.\n\ You can supply a command number to start with, or a `+' to start after\n\ the previous command number shown."
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"version"
argument_list|,
name|no_class
argument_list|,
name|show_version
argument_list|,
literal|"Show what version of GDB this is."
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"remotedebug"
argument_list|,
name|no_class
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|remote_debug
argument_list|,
literal|"Set debugging of remote protocol.\n\ When enabled, each packet sent or received with the remote target\n\ is displayed."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

