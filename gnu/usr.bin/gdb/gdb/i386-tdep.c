begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Intel 386 target-dependent stuff.    Copyright (C) 1988, 1989, 1991, 1994 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"floatformat.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_decl_stmt
specifier|static
name|long
name|i386_get_frame_setup
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|i386_follow_jump
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|codestream_read
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|codestream_seek
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|codestream_fill
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* helper functions for tm-i386.h */
end_comment

begin_comment
comment|/* Stdio style buffering was used to minimize calls to ptrace, but this    buffering did not take into account that the code section being accessed    may not be an even number of buffers long (even if the buffer is only    sizeof(int) long).  In cases where the code section size happened to    be a non-integral number of buffers long, attempting to read the last    buffer would fail.  Simply using target_read_memory and ignoring errors,    rather than read_memory, is not the correct solution, since legitimate    access errors would then be totally ignored.  To properly handle this    situation and continue to use buffering would require that this code    be able to determine the minimum code section size granularity (not the    alignment of the section itself, since the actual failing case that    pointed out this problem had a section alignment of 4 but was not a    multiple of 4 bytes long), on a target by target basis, and then    adjust it's buffer size accordingly.  This is messy, but potentially    feasible.  It probably needs the bfd library's help and support.  For    now, the buffer size is set to 1.  (FIXME -fnf) */
end_comment

begin_define
define|#
directive|define
name|CODESTREAM_BUFSIZ
value|1
end_define

begin_comment
comment|/* Was sizeof(int), see note above. */
end_comment

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|codestream_next_addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|codestream_addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|codestream_buf
index|[
name|CODESTREAM_BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|codestream_off
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|codestream_cnt
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|codestream_tell
parameter_list|()
value|(codestream_addr + codestream_off)
end_define

begin_define
define|#
directive|define
name|codestream_peek
parameter_list|()
value|(codestream_cnt == 0 ? \ 			   codestream_fill(1): codestream_buf[codestream_off])
end_define

begin_define
define|#
directive|define
name|codestream_get
parameter_list|()
value|(codestream_cnt-- == 0 ? \ 			 codestream_fill(0) : codestream_buf[codestream_off++])
end_define

begin_function
specifier|static
name|unsigned
name|char
name|codestream_fill
parameter_list|(
name|peek_flag
parameter_list|)
name|int
name|peek_flag
decl_stmt|;
block|{
name|codestream_addr
operator|=
name|codestream_next_addr
expr_stmt|;
name|codestream_next_addr
operator|+=
name|CODESTREAM_BUFSIZ
expr_stmt|;
name|codestream_off
operator|=
literal|0
expr_stmt|;
name|codestream_cnt
operator|=
name|CODESTREAM_BUFSIZ
expr_stmt|;
name|read_memory
argument_list|(
name|codestream_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|codestream_buf
argument_list|,
name|CODESTREAM_BUFSIZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|peek_flag
condition|)
return|return
operator|(
name|codestream_peek
argument_list|()
operator|)
return|;
else|else
return|return
operator|(
name|codestream_get
argument_list|()
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|codestream_seek
parameter_list|(
name|place
parameter_list|)
name|int
name|place
decl_stmt|;
block|{
name|codestream_next_addr
operator|=
name|place
operator|/
name|CODESTREAM_BUFSIZ
expr_stmt|;
name|codestream_next_addr
operator|*=
name|CODESTREAM_BUFSIZ
expr_stmt|;
name|codestream_cnt
operator|=
literal|0
expr_stmt|;
name|codestream_fill
argument_list|(
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|codestream_tell
argument_list|()
operator|!=
name|place
condition|)
name|codestream_get
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|codestream_read
parameter_list|(
name|buf
parameter_list|,
name|count
parameter_list|)
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|count
decl_stmt|;
block|{
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
name|codestream_get
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* next instruction is a jump, move to target */
end_comment

begin_function
specifier|static
name|void
name|i386_follow_jump
parameter_list|()
block|{
name|unsigned
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|long
name|delta
decl_stmt|;
name|int
name|data16
decl_stmt|;
name|CORE_ADDR
name|pos
decl_stmt|;
name|pos
operator|=
name|codestream_tell
argument_list|()
expr_stmt|;
name|data16
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|codestream_peek
argument_list|()
operator|==
literal|0x66
condition|)
block|{
name|codestream_get
argument_list|()
expr_stmt|;
name|data16
operator|=
literal|1
expr_stmt|;
block|}
switch|switch
condition|(
name|codestream_get
argument_list|()
condition|)
block|{
case|case
literal|0xe9
case|:
comment|/* relative jump: if data16 == 0, disp32, else disp16 */
if|if
condition|(
name|data16
condition|)
block|{
name|codestream_read
argument_list|(
name|buf
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|delta
operator|=
name|extract_signed_integer
argument_list|(
name|buf
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* include size of jmp inst (including the 0x66 prefix).  */
name|pos
operator|+=
name|delta
operator|+
literal|4
expr_stmt|;
block|}
else|else
block|{
name|codestream_read
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|delta
operator|=
name|extract_signed_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|delta
operator|+
literal|5
expr_stmt|;
block|}
break|break;
case|case
literal|0xeb
case|:
comment|/* relative jump, disp8 (ignore data16) */
name|codestream_read
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Sign-extend it.  */
name|delta
operator|=
name|extract_signed_integer
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|delta
operator|+
literal|2
expr_stmt|;
break|break;
block|}
name|codestream_seek
argument_list|(
name|pos
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * find& return amound a local space allocated, and advance codestream to  * first register push (if any)  *  * if entry sequence doesn't make sense, return -1, and leave  * codestream pointer random  */
end_comment

begin_function
specifier|static
name|long
name|i386_get_frame_setup
parameter_list|(
name|pc
parameter_list|)
name|int
name|pc
decl_stmt|;
block|{
name|unsigned
name|char
name|op
decl_stmt|;
name|codestream_seek
argument_list|(
name|pc
argument_list|)
expr_stmt|;
name|i386_follow_jump
argument_list|()
expr_stmt|;
name|op
operator|=
name|codestream_get
argument_list|()
expr_stmt|;
if|if
condition|(
name|op
operator|==
literal|0x58
condition|)
comment|/* popl %eax */
block|{
comment|/*        * this function must start with        *        *    popl %eax		  0x58        *    xchgl %eax, (%esp)  0x87 0x04 0x24        * or xchgl %eax, 0(%esp) 0x87 0x44 0x24 0x00        *        * (the system 5 compiler puts out the second xchg        * inst, and the assembler doesn't try to optimize it,        * so the 'sib' form gets generated)        *        * this sequence is used to get the address of the return        * buffer for a function that returns a structure        */
name|int
name|pos
decl_stmt|;
name|unsigned
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
specifier|static
name|unsigned
name|char
name|proto1
index|[
literal|3
index|]
init|=
block|{
literal|0x87
block|,
literal|0x04
block|,
literal|0x24
block|}
decl_stmt|;
specifier|static
name|unsigned
name|char
name|proto2
index|[
literal|4
index|]
init|=
block|{
literal|0x87
block|,
literal|0x44
block|,
literal|0x24
block|,
literal|0x00
block|}
decl_stmt|;
name|pos
operator|=
name|codestream_tell
argument_list|()
expr_stmt|;
name|codestream_read
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|buf
argument_list|,
name|proto1
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
name|pos
operator|+=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|memcmp
argument_list|(
name|buf
argument_list|,
name|proto2
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
name|pos
operator|+=
literal|4
expr_stmt|;
name|codestream_seek
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|op
operator|=
name|codestream_get
argument_list|()
expr_stmt|;
comment|/* update next opcode */
block|}
if|if
condition|(
name|op
operator|==
literal|0x55
condition|)
comment|/* pushl %ebp */
block|{
comment|/* check for movl %esp, %ebp - can be written two ways */
switch|switch
condition|(
name|codestream_get
argument_list|()
condition|)
block|{
case|case
literal|0x8b
case|:
if|if
condition|(
name|codestream_get
argument_list|()
operator|!=
literal|0xec
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
break|break;
case|case
literal|0x89
case|:
if|if
condition|(
name|codestream_get
argument_list|()
operator|!=
literal|0xe5
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
break|break;
default|default:
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* check for stack adjustment        *        *  subl $XXX, %esp        *        * note: you can't subtract a 16 bit immediate        * from a 32 bit reg, so we don't have to worry        * about a data16 prefix        */
name|op
operator|=
name|codestream_peek
argument_list|()
expr_stmt|;
if|if
condition|(
name|op
operator|==
literal|0x83
condition|)
block|{
comment|/* subl with 8 bit immed */
name|codestream_get
argument_list|()
expr_stmt|;
if|if
condition|(
name|codestream_get
argument_list|()
operator|!=
literal|0xec
condition|)
comment|/* Some instruction starting with 0x83 other than subl.  */
block|{
name|codestream_seek
argument_list|(
name|codestream_tell
argument_list|()
operator|-
literal|2
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* subl with signed byte immediate 	   * (though it wouldn't make sense to be negative) 	   */
return|return
operator|(
name|codestream_get
argument_list|()
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
literal|0x81
condition|)
block|{
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
comment|/* Maybe it is subl with 32 bit immedediate.  */
name|codestream_get
argument_list|()
expr_stmt|;
if|if
condition|(
name|codestream_get
argument_list|()
operator|!=
literal|0xec
condition|)
comment|/* Some instruction starting with 0x81 other than subl.  */
block|{
name|codestream_seek
argument_list|(
name|codestream_tell
argument_list|()
operator|-
literal|2
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* It is subl with 32 bit immediate.  */
name|codestream_read
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
return|return
name|extract_signed_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|op
operator|==
literal|0xc8
condition|)
block|{
name|char
name|buf
index|[
literal|2
index|]
decl_stmt|;
comment|/* enter instruction: arg is 16 bit unsigned immed */
name|codestream_read
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|buf
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|codestream_get
argument_list|()
expr_stmt|;
comment|/* flush final byte of enter instruction */
return|return
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|2
argument_list|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return number of args passed to a frame.    Can return -1, meaning no way to tell.  */
end_comment

begin_function
name|int
name|i386_frame_num_args
parameter_list|(
name|fi
parameter_list|)
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
block|{
if|#
directive|if
literal|1
return|return
operator|-
literal|1
return|;
else|#
directive|else
comment|/* This loses because not only might the compiler not be popping the      args right after the function call, it might be popping args from both      this call and a previous one, and we would say there are more args      than there really are.  */
name|int
name|retpc
decl_stmt|;
name|unsigned
name|char
name|op
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|pfi
decl_stmt|;
comment|/* on the 386, the instruction following the call could be:      popl %ecx        -  one arg      addl $imm, %esp  -  imm/4 args; imm may be 8 or 32 bits      anything else    -  zero args  */
name|int
name|frameless
decl_stmt|;
name|FRAMELESS_FUNCTION_INVOCATION
argument_list|(
name|fi
argument_list|,
name|frameless
argument_list|)
expr_stmt|;
if|if
condition|(
name|frameless
condition|)
comment|/* In the absence of a frame pointer, GDB doesn't get correct values        for nameless arguments.  Return -1, so it doesn't print any        nameless arguments.  */
return|return
operator|-
literal|1
return|;
name|pfi
operator|=
name|get_prev_frame_info
argument_list|(
name|fi
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfi
operator|==
literal|0
condition|)
block|{
comment|/* Note:  this can happen if we are looking at the frame for 	 main, because FRAME_CHAIN_VALID won't let us go into 	 start.  If we have debugging symbols, that's not really 	 a big deal; it just means it will only show as many arguments 	 to main as are declared.  */
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
name|retpc
operator|=
name|pfi
operator|->
name|pc
expr_stmt|;
name|op
operator|=
name|read_memory_integer
argument_list|(
name|retpc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
literal|0x59
condition|)
comment|/* pop %ecx */
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|op
operator|==
literal|0x83
condition|)
block|{
name|op
operator|=
name|read_memory_integer
argument_list|(
name|retpc
operator|+
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
literal|0xc4
condition|)
comment|/* addl $<signed imm 8 bits>, %esp */
return|return
operator|(
name|read_memory_integer
argument_list|(
name|retpc
operator|+
literal|2
argument_list|,
literal|1
argument_list|)
operator|&
literal|0xff
operator|)
operator|/
literal|4
return|;
else|else
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
literal|0x81
condition|)
block|{
comment|/* add with 32 bit immediate */
name|op
operator|=
name|read_memory_integer
argument_list|(
name|retpc
operator|+
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
literal|0xc4
condition|)
comment|/* addl $<imm 32>, %esp */
return|return
name|read_memory_integer
argument_list|(
name|retpc
operator|+
literal|2
argument_list|,
literal|4
argument_list|)
operator|/
literal|4
return|;
else|else
return|return
literal|0
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * parse the first few instructions of the function to see  * what registers were stored.  *  * We handle these cases:  *  * The startup sequence can be at the start of the function,  * or the function can start with a branch to startup code at the end.  *  * %ebp can be set up with either the 'enter' instruction, or  * 'pushl %ebp, movl %esp, %ebp' (enter is too slow to be useful,  * but was once used in the sys5 compiler)  *  * Local space is allocated just below the saved %ebp by either the  * 'enter' instruction, or by 'subl $<size>, %esp'.  'enter' has  * a 16 bit unsigned argument for space to allocate, and the  * 'addl' instruction could have either a signed byte, or  * 32 bit immediate.  *  * Next, the registers used by this function are pushed.  In  * the sys5 compiler they will always be in the order: %edi, %esi, %ebx  * (and sometimes a harmless bug causes it to also save but not restore %eax);  * however, the code below is willing to see the pushes in any order,  * and will handle up to 8 of them.  *  * If the setup sequence is at the end of the function, then the  * next instruction will be a branch back to the start.  */
end_comment

begin_function
name|void
name|i386_frame_find_saved_regs
parameter_list|(
name|fip
parameter_list|,
name|fsrp
parameter_list|)
name|struct
name|frame_info
modifier|*
name|fip
decl_stmt|;
name|struct
name|frame_saved_regs
modifier|*
name|fsrp
decl_stmt|;
block|{
name|long
name|locals
decl_stmt|;
name|unsigned
name|char
name|op
decl_stmt|;
name|CORE_ADDR
name|dummy_bottom
decl_stmt|;
name|CORE_ADDR
name|adr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|memset
argument_list|(
name|fsrp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|fsrp
argument_list|)
expr_stmt|;
comment|/* if frame is the end of a dummy, compute where the    * beginning would be    */
name|dummy_bottom
operator|=
name|fip
operator|->
name|frame
operator|-
literal|4
operator|-
name|REGISTER_BYTES
operator|-
name|CALL_DUMMY_LENGTH
expr_stmt|;
comment|/* check if the PC is in the stack, in a dummy frame */
if|if
condition|(
name|dummy_bottom
operator|<=
name|fip
operator|->
name|pc
operator|&&
name|fip
operator|->
name|pc
operator|<=
name|fip
operator|->
name|frame
condition|)
block|{
comment|/* all regs were saved by push_call_dummy () */
name|adr
operator|=
name|fip
operator|->
name|frame
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_REGS
condition|;
name|i
operator|++
control|)
block|{
name|adr
operator|-=
name|REGISTER_RAW_SIZE
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|fsrp
operator|->
name|regs
index|[
name|i
index|]
operator|=
name|adr
expr_stmt|;
block|}
return|return;
block|}
name|locals
operator|=
name|i386_get_frame_setup
argument_list|(
name|get_pc_function_start
argument_list|(
name|fip
operator|->
name|pc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|locals
operator|>=
literal|0
condition|)
block|{
name|adr
operator|=
name|fip
operator|->
name|frame
operator|-
literal|4
operator|-
name|locals
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|op
operator|=
name|codestream_get
argument_list|()
expr_stmt|;
if|if
condition|(
name|op
operator|<
literal|0x50
operator|||
name|op
operator|>
literal|0x57
condition|)
break|break;
ifdef|#
directive|ifdef
name|I386_REGNO_TO_SYMMETRY
comment|/* Dynix uses different internal numbering.  Ick.  */
name|fsrp
operator|->
name|regs
index|[
name|I386_REGNO_TO_SYMMETRY
argument_list|(
name|op
operator|-
literal|0x50
argument_list|)
index|]
operator|=
name|adr
expr_stmt|;
else|#
directive|else
name|fsrp
operator|->
name|regs
index|[
name|op
operator|-
literal|0x50
index|]
operator|=
name|adr
expr_stmt|;
endif|#
directive|endif
name|adr
operator|-=
literal|4
expr_stmt|;
block|}
block|}
name|fsrp
operator|->
name|regs
index|[
name|PC_REGNUM
index|]
operator|=
name|fip
operator|->
name|frame
operator|+
literal|4
expr_stmt|;
name|fsrp
operator|->
name|regs
index|[
name|FP_REGNUM
index|]
operator|=
name|fip
operator|->
name|frame
expr_stmt|;
block|}
end_function

begin_comment
comment|/* return pc of first real instruction */
end_comment

begin_function
name|int
name|i386_skip_prologue
parameter_list|(
name|pc
parameter_list|)
name|int
name|pc
decl_stmt|;
block|{
name|unsigned
name|char
name|op
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|static
name|unsigned
name|char
name|pic_pat
index|[
literal|6
index|]
init|=
block|{
literal|0xe8
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* call   0x0 */
literal|0x5b
block|,
comment|/* popl   %ebx */
block|}
decl_stmt|;
name|CORE_ADDR
name|pos
decl_stmt|;
if|if
condition|(
name|i386_get_frame_setup
argument_list|(
name|pc
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|pc
operator|)
return|;
comment|/* found valid frame setup - codestream now points to    * start of push instructions for saving registers    */
comment|/* skip over register saves */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|op
operator|=
name|codestream_peek
argument_list|()
expr_stmt|;
comment|/* break if not pushl inst */
if|if
condition|(
name|op
operator|<
literal|0x50
operator|||
name|op
operator|>
literal|0x57
condition|)
break|break;
name|codestream_get
argument_list|()
expr_stmt|;
block|}
comment|/* The native cc on SVR4 in -K PIC mode inserts the following code to get      the address of the global offset table (GOT) into register %ebx.       call	0x0       popl	%ebx       movl	%ebx,x(%ebp)	(optional)       addl	y,%ebx      This code is with the rest of the prologue (at the end of the      function), so we have to skip it to get to the first real      instruction at the start of the function.  */
name|pos
operator|=
name|codestream_tell
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
block|{
name|op
operator|=
name|codestream_get
argument_list|()
expr_stmt|;
if|if
condition|(
name|pic_pat
index|[
name|i
index|]
operator|!=
name|op
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
literal|6
condition|)
block|{
name|unsigned
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|long
name|delta
init|=
literal|6
decl_stmt|;
name|op
operator|=
name|codestream_get
argument_list|()
expr_stmt|;
if|if
condition|(
name|op
operator|==
literal|0x89
condition|)
comment|/* movl %ebx, x(%ebp) */
block|{
name|op
operator|=
name|codestream_get
argument_list|()
expr_stmt|;
if|if
condition|(
name|op
operator|==
literal|0x5d
condition|)
comment|/* one byte offset from %ebp */
block|{
name|delta
operator|+=
literal|3
expr_stmt|;
name|codestream_read
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
literal|0x9d
condition|)
comment|/* four byte offset from %ebp */
block|{
name|delta
operator|+=
literal|6
expr_stmt|;
name|codestream_read
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* unexpected instruction */
name|delta
operator|=
operator|-
literal|1
expr_stmt|;
name|op
operator|=
name|codestream_get
argument_list|()
expr_stmt|;
block|}
comment|/* addl y,%ebx */
if|if
condition|(
name|delta
operator|>
literal|0
operator|&&
name|op
operator|==
literal|0x81
operator|&&
name|codestream_get
argument_list|()
operator|==
literal|0xc3
condition|)
block|{
name|pos
operator|+=
name|delta
operator|+
literal|6
expr_stmt|;
block|}
block|}
name|codestream_seek
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|i386_follow_jump
argument_list|()
expr_stmt|;
return|return
operator|(
name|codestream_tell
argument_list|()
operator|)
return|;
block|}
end_function

begin_function
name|void
name|i386_push_dummy_frame
parameter_list|()
block|{
name|CORE_ADDR
name|sp
init|=
name|read_register
argument_list|(
name|SP_REGNUM
argument_list|)
decl_stmt|;
name|int
name|regnum
decl_stmt|;
name|char
name|regbuf
index|[
name|MAX_REGISTER_RAW_SIZE
index|]
decl_stmt|;
name|sp
operator|=
name|push_word
argument_list|(
name|sp
argument_list|,
name|read_register
argument_list|(
name|PC_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|=
name|push_word
argument_list|(
name|sp
argument_list|,
name|read_register
argument_list|(
name|FP_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|FP_REGNUM
argument_list|,
name|sp
argument_list|)
expr_stmt|;
for|for
control|(
name|regnum
operator|=
literal|0
init|;
name|regnum
operator|<
name|NUM_REGS
condition|;
name|regnum
operator|++
control|)
block|{
name|read_register_gen
argument_list|(
name|regnum
argument_list|,
name|regbuf
argument_list|)
expr_stmt|;
name|sp
operator|=
name|push_bytes
argument_list|(
name|sp
argument_list|,
name|regbuf
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|write_register
argument_list|(
name|SP_REGNUM
argument_list|,
name|sp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|i386_pop_frame
parameter_list|()
block|{
name|FRAME
name|frame
init|=
name|get_current_frame
argument_list|()
decl_stmt|;
name|CORE_ADDR
name|fp
decl_stmt|;
name|int
name|regnum
decl_stmt|;
name|struct
name|frame_saved_regs
name|fsr
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
name|char
name|regbuf
index|[
name|MAX_REGISTER_RAW_SIZE
index|]
decl_stmt|;
name|fi
operator|=
name|get_frame_info
argument_list|(
name|frame
argument_list|)
expr_stmt|;
name|fp
operator|=
name|fi
operator|->
name|frame
expr_stmt|;
name|get_frame_saved_regs
argument_list|(
name|fi
argument_list|,
operator|&
name|fsr
argument_list|)
expr_stmt|;
for|for
control|(
name|regnum
operator|=
literal|0
init|;
name|regnum
operator|<
name|NUM_REGS
condition|;
name|regnum
operator|++
control|)
block|{
name|CORE_ADDR
name|adr
decl_stmt|;
name|adr
operator|=
name|fsr
operator|.
name|regs
index|[
name|regnum
index|]
expr_stmt|;
if|if
condition|(
name|adr
condition|)
block|{
name|read_memory
argument_list|(
name|adr
argument_list|,
name|regbuf
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
name|write_register_bytes
argument_list|(
name|REGISTER_BYTE
argument_list|(
name|regnum
argument_list|)
argument_list|,
name|regbuf
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|write_register
argument_list|(
name|FP_REGNUM
argument_list|,
name|read_memory_integer
argument_list|(
name|fp
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|PC_REGNUM
argument_list|,
name|read_memory_integer
argument_list|(
name|fp
operator|+
literal|4
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|SP_REGNUM
argument_list|,
name|fp
operator|+
literal|8
argument_list|)
expr_stmt|;
name|flush_cached_frames
argument_list|()
expr_stmt|;
name|set_current_frame
argument_list|(
name|create_new_frame
argument_list|(
name|read_register
argument_list|(
name|FP_REGNUM
argument_list|)
argument_list|,
name|read_pc
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|GET_LONGJMP_TARGET
end_ifdef

begin_comment
comment|/* Figure out where the longjmp will land.  Slurp the args out of the stack.    We expect the first arg to be a pointer to the jmp_buf structure from which    we extract the pc (JB_PC) that we will land at.  The pc is copied into PC.    This routine returns true on success. */
end_comment

begin_function
name|int
name|get_longjmp_target
parameter_list|(
name|pc
parameter_list|)
name|CORE_ADDR
modifier|*
name|pc
decl_stmt|;
block|{
name|char
name|buf
index|[
name|TARGET_PTR_BIT
operator|/
name|TARGET_CHAR_BIT
index|]
decl_stmt|;
name|CORE_ADDR
name|sp
decl_stmt|,
name|jb_addr
decl_stmt|;
name|sp
operator|=
name|read_register
argument_list|(
name|SP_REGNUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_read_memory
argument_list|(
name|sp
operator|+
name|SP_ARG0
argument_list|,
comment|/* Offset of first arg on stack */
name|buf
argument_list|,
name|TARGET_PTR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|)
condition|)
return|return
literal|0
return|;
name|jb_addr
operator|=
name|extract_address
argument_list|(
name|buf
argument_list|,
name|TARGET_PTR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_read_memory
argument_list|(
name|jb_addr
operator|+
name|JB_PC
operator|*
name|JB_ELEMENT_SIZE
argument_list|,
name|buf
argument_list|,
name|TARGET_PTR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|)
condition|)
return|return
literal|0
return|;
operator|*
name|pc
operator|=
name|extract_address
argument_list|(
name|buf
argument_list|,
name|TARGET_PTR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* GET_LONGJMP_TARGET */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|I386_AIX_TARGET
end_ifdef

begin_comment
comment|/* On AIX, floating point values are returned in floating point registers.  */
end_comment

begin_function
name|void
name|i386_extract_return_value
parameter_list|(
name|type
parameter_list|,
name|regbuf
parameter_list|,
name|valbuf
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|char
name|regbuf
index|[
name|REGISTER_BYTES
index|]
decl_stmt|;
name|char
modifier|*
name|valbuf
decl_stmt|;
block|{
if|if
condition|(
name|TYPE_CODE_FLT
operator|==
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|double
name|d
decl_stmt|;
comment|/* 387 %st(0), gcc uses this */
name|floatformat_to_double
argument_list|(
operator|&
name|floatformat_i387_ext
argument_list|,
operator|&
name|regbuf
index|[
name|REGISTER_BYTE
argument_list|(
name|FP0_REGNUM
argument_list|)
index|]
argument_list|,
operator|&
name|d
argument_list|)
expr_stmt|;
name|store_floating
argument_list|(
name|valbuf
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|valbuf
argument_list|,
name|regbuf
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* I386_AIX_TARGET */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|I386V4_SIGTRAMP_SAVED_PC
end_ifdef

begin_comment
comment|/* Get saved user PC for sigtramp from the pushed ucontext on the stack    for all three variants of SVR4 sigtramps.  */
end_comment

begin_function
name|CORE_ADDR
name|i386v4_sigtramp_saved_pc
parameter_list|(
name|frame
parameter_list|)
name|FRAME
name|frame
decl_stmt|;
block|{
name|CORE_ADDR
name|saved_pc_offset
init|=
literal|4
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
name|find_pc_partial_function
argument_list|(
name|frame
operator|->
name|pc
argument_list|,
operator|&
name|name
argument_list|,
operator|(
name|CORE_ADDR
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|CORE_ADDR
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
block|{
if|if
condition|(
name|STREQ
argument_list|(
name|name
argument_list|,
literal|"_sigreturn"
argument_list|)
condition|)
name|saved_pc_offset
operator|=
literal|132
operator|+
literal|14
operator|*
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|name
argument_list|,
literal|"_sigacthandler"
argument_list|)
condition|)
name|saved_pc_offset
operator|=
literal|80
operator|+
literal|14
operator|*
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|name
argument_list|,
literal|"sigvechandler"
argument_list|)
condition|)
name|saved_pc_offset
operator|=
literal|120
operator|+
literal|14
operator|*
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|frame
operator|->
name|next
condition|)
return|return
name|read_memory_integer
argument_list|(
name|frame
operator|->
name|next
operator|->
name|frame
operator|+
name|saved_pc_offset
argument_list|,
literal|4
argument_list|)
return|;
return|return
name|read_memory_integer
argument_list|(
name|read_register
argument_list|(
name|SP_REGNUM
argument_list|)
operator|+
name|saved_pc_offset
argument_list|,
literal|4
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* I386V4_SIGTRAMP_SAVED_PC */
end_comment

end_unit

