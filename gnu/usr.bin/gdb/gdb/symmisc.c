begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Do various things to symbol tables (other than lookup), for GDB.    Copyright 1986, 1987, 1989, 1991, 1992, 1993, 1994    Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"breakpoint.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|DEV_TTY
end_ifndef

begin_define
define|#
directive|define
name|DEV_TTY
value|"/dev/tty"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Unfortunately for debugging, stderr is usually a macro.  This is painful    when calling functions that take FILE *'s from the debugger.    So we make a variable which has the same value and which is accessible when    debugging GDB with itself.  Because stdin et al need not be constants,    we initialize them in the _initialize_symmisc function at the bottom    of the file.  */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|std_in
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|std_out
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|std_err
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Prototypes for local functions */
end_comment

begin_decl_stmt
specifier|static
name|void
name|dump_symtab
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|,
expr|struct
name|symtab
operator|*
operator|,
name|GDB_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_psymtab
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|,
expr|struct
name|partial_symtab
operator|*
operator|,
name|GDB_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_msymbols
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|,
name|GDB_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_objfile
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|block_depth
name|PARAMS
argument_list|(
operator|(
expr|struct
name|block
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_partial_symbol
name|PARAMS
argument_list|(
operator|(
expr|struct
name|partial_symbol
operator|*
operator|,
name|int
operator|,
name|char
operator|*
operator|,
name|GDB_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|print_symbol_args
block|{
name|struct
name|symbol
modifier|*
name|symbol
decl_stmt|;
name|int
name|depth
decl_stmt|;
name|GDB_FILE
modifier|*
name|outfile
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|print_symbol
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_symtab_block
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|,
expr|struct
name|block
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Free a struct block<- B and all the symbols defined in that block.  */
end_comment

begin_function
specifier|static
name|void
name|free_symtab_block
parameter_list|(
name|objfile
parameter_list|,
name|b
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|block
modifier|*
name|b
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|n
operator|=
name|BLOCK_NSYMS
argument_list|(
name|b
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|mfree
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|BLOCK_SYM
argument_list|(
name|b
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|mfree
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
operator|(
name|PTR
operator|)
name|BLOCK_SYM
argument_list|(
name|b
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|mfree
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
operator|(
name|PTR
operator|)
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free all the storage associated with the struct symtab<- S.    Note that some symtabs have contents malloc'ed structure by structure,    while some have contents that all live inside one big block of memory,    and some share the contents of another symbol table and so you should    not free the contents on their behalf (except sometimes the linetable,    which maybe per symtab even when the rest is not).    It is s->free_code that says which alternative to use.  */
end_comment

begin_function
name|void
name|free_symtab
parameter_list|(
name|s
parameter_list|)
specifier|register
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
specifier|register
name|struct
name|blockvector
modifier|*
name|bv
decl_stmt|;
switch|switch
condition|(
name|s
operator|->
name|free_code
condition|)
block|{
case|case
name|free_nothing
case|:
comment|/* All the contents are part of a big block of memory (an obstack), 	 and some other symtab is in charge of freeing that block. 	 Therefore, do nothing.  */
break|break;
case|case
name|free_contents
case|:
comment|/* Here all the contents were malloc'ed structure by structure 	 and must be freed that way.  */
comment|/* First free the blocks (and their symbols.  */
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|n
operator|=
name|BLOCKVECTOR_NBLOCKS
argument_list|(
name|bv
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|free_symtab_block
argument_list|(
name|s
operator|->
name|objfile
argument_list|,
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Free the blockvector itself.  */
name|mfree
argument_list|(
name|s
operator|->
name|objfile
operator|->
name|md
argument_list|,
operator|(
name|PTR
operator|)
name|bv
argument_list|)
expr_stmt|;
comment|/* Also free the linetable.  */
case|case
name|free_linetable
case|:
comment|/* Everything will be freed either by our `free_ptr' 	 or by some other symtab, except for our linetable. 	 Free that now.  */
if|if
condition|(
name|LINETABLE
argument_list|(
name|s
argument_list|)
condition|)
name|mfree
argument_list|(
name|s
operator|->
name|objfile
operator|->
name|md
argument_list|,
operator|(
name|PTR
operator|)
name|LINETABLE
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* If there is a single block of memory to free, free it.  */
if|if
condition|(
name|s
operator|->
name|free_ptr
operator|!=
name|NULL
condition|)
name|mfree
argument_list|(
name|s
operator|->
name|objfile
operator|->
name|md
argument_list|,
name|s
operator|->
name|free_ptr
argument_list|)
expr_stmt|;
comment|/* Free source-related stuff */
if|if
condition|(
name|s
operator|->
name|line_charpos
operator|!=
name|NULL
condition|)
name|mfree
argument_list|(
name|s
operator|->
name|objfile
operator|->
name|md
argument_list|,
operator|(
name|PTR
operator|)
name|s
operator|->
name|line_charpos
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|fullname
operator|!=
name|NULL
condition|)
name|mfree
argument_list|(
name|s
operator|->
name|objfile
operator|->
name|md
argument_list|,
name|s
operator|->
name|fullname
argument_list|)
expr_stmt|;
name|mfree
argument_list|(
name|s
operator|->
name|objfile
operator|->
name|md
argument_list|,
operator|(
name|PTR
operator|)
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|MAINTENANCE_CMDS
end_if

begin_function
specifier|static
name|void
name|dump_objfile
parameter_list|(
name|objfile
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|struct
name|symtab
modifier|*
name|symtab
decl_stmt|;
name|struct
name|partial_symtab
modifier|*
name|psymtab
decl_stmt|;
name|printf_filtered
argument_list|(
literal|"\nObject file %s:  "
argument_list|,
name|objfile
operator|->
name|name
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Objfile at "
argument_list|)
expr_stmt|;
name|gdb_print_address
argument_list|(
name|objfile
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|", bfd at "
argument_list|)
expr_stmt|;
name|gdb_print_address
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|", %d minsyms\n\n"
argument_list|,
name|objfile
operator|->
name|minimal_symbol_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|objfile
operator|->
name|psymtabs
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Psymtabs:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|psymtab
operator|=
name|objfile
operator|->
name|psymtabs
init|;
name|psymtab
operator|!=
name|NULL
condition|;
name|psymtab
operator|=
name|psymtab
operator|->
name|next
control|)
block|{
name|printf_filtered
argument_list|(
literal|"%s at "
argument_list|,
name|psymtab
operator|->
name|filename
argument_list|)
expr_stmt|;
name|gdb_print_address
argument_list|(
name|psymtab
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
if|if
condition|(
name|psymtab
operator|->
name|objfile
operator|!=
name|objfile
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"NOT ON CHAIN!  "
argument_list|)
expr_stmt|;
block|}
name|wrap_here
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|objfile
operator|->
name|symtabs
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Symtabs:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|symtab
operator|=
name|objfile
operator|->
name|symtabs
init|;
name|symtab
operator|!=
name|NULL
condition|;
name|symtab
operator|=
name|symtab
operator|->
name|next
control|)
block|{
name|printf_filtered
argument_list|(
literal|"%s at "
argument_list|,
name|symtab
operator|->
name|filename
argument_list|)
expr_stmt|;
name|gdb_print_address
argument_list|(
name|symtab
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
if|if
condition|(
name|symtab
operator|->
name|objfile
operator|!=
name|objfile
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"NOT ON CHAIN!  "
argument_list|)
expr_stmt|;
block|}
name|wrap_here
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print minimal symbols from this objfile.  */
end_comment

begin_function
specifier|static
name|void
name|dump_msymbols
parameter_list|(
name|objfile
parameter_list|,
name|outfile
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|GDB_FILE
modifier|*
name|outfile
decl_stmt|;
block|{
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
name|int
name|index
decl_stmt|;
name|char
name|ms_type
decl_stmt|;
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|"\nObject file %s:\n\n"
argument_list|,
name|objfile
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|objfile
operator|->
name|minimal_symbol_count
operator|==
literal|0
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|"No minimal symbols found.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|index
operator|=
literal|0
operator|,
name|msymbol
operator|=
name|objfile
operator|->
name|msymbols
init|;
name|SYMBOL_NAME
argument_list|(
name|msymbol
argument_list|)
operator|!=
name|NULL
condition|;
name|msymbol
operator|++
operator|,
name|index
operator|++
control|)
block|{
switch|switch
condition|(
name|msymbol
operator|->
name|type
condition|)
block|{
case|case
name|mst_unknown
case|:
name|ms_type
operator|=
literal|'u'
expr_stmt|;
break|break;
case|case
name|mst_text
case|:
name|ms_type
operator|=
literal|'T'
expr_stmt|;
break|break;
case|case
name|mst_solib_trampoline
case|:
name|ms_type
operator|=
literal|'S'
expr_stmt|;
break|break;
case|case
name|mst_data
case|:
name|ms_type
operator|=
literal|'D'
expr_stmt|;
break|break;
case|case
name|mst_bss
case|:
name|ms_type
operator|=
literal|'B'
expr_stmt|;
break|break;
case|case
name|mst_abs
case|:
name|ms_type
operator|=
literal|'A'
expr_stmt|;
break|break;
case|case
name|mst_file_text
case|:
name|ms_type
operator|=
literal|'t'
expr_stmt|;
break|break;
case|case
name|mst_file_data
case|:
name|ms_type
operator|=
literal|'d'
expr_stmt|;
break|break;
case|case
name|mst_file_bss
case|:
name|ms_type
operator|=
literal|'b'
expr_stmt|;
break|break;
default|default:
name|ms_type
operator|=
literal|'?'
expr_stmt|;
break|break;
block|}
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|"[%2d] %c %#10lx %s"
argument_list|,
name|index
argument_list|,
name|ms_type
argument_list|,
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|msymbol
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SYMBOL_DEMANGLED_NAME
argument_list|(
name|msymbol
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|"  %s"
argument_list|,
name|SYMBOL_DEMANGLED_NAME
argument_list|(
name|msymbol
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fputs_filtered
argument_list|(
literal|"\n"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|objfile
operator|->
name|minimal_symbol_count
operator|!=
name|index
condition|)
block|{
name|warning
argument_list|(
literal|"internal error:  minimal symbol count %d != %d"
argument_list|,
name|objfile
operator|->
name|minimal_symbol_count
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_psymtab
parameter_list|(
name|objfile
parameter_list|,
name|psymtab
parameter_list|,
name|outfile
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|partial_symtab
modifier|*
name|psymtab
decl_stmt|;
name|GDB_FILE
modifier|*
name|outfile
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|"\nPartial symtab for source file %s "
argument_list|,
name|psymtab
operator|->
name|filename
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|"(object "
argument_list|)
expr_stmt|;
name|gdb_print_address
argument_list|(
name|psymtab
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|")\n\n"
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|outfile
argument_list|,
literal|"  Read from object file %s ("
argument_list|,
name|objfile
operator|->
name|name
argument_list|)
expr_stmt|;
name|gdb_print_address
argument_list|(
name|objfile
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|outfile
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|psymtab
operator|->
name|readin
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|"  Full symtab was read (at "
argument_list|)
expr_stmt|;
name|gdb_print_address
argument_list|(
name|psymtab
operator|->
name|symtab
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|" by function at "
argument_list|)
expr_stmt|;
name|gdb_print_address
argument_list|(
operator|(
name|PTR
operator|)
name|psymtab
operator|->
name|read_symtab
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|"  Relocate symbols by "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|psymtab
operator|->
name|objfile
operator|->
name|num_sections
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|"    "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|ANOFFSET
argument_list|(
name|psymtab
operator|->
name|section_offsets
argument_list|,
name|i
argument_list|)
argument_list|,
literal|1
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
block|}
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|"  Symbols cover text addresses "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|psymtab
operator|->
name|textlow
argument_list|,
literal|1
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|psymtab
operator|->
name|texthigh
argument_list|,
literal|1
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|"  Depends on %d other partial symtabs.\n"
argument_list|,
name|psymtab
operator|->
name|number_of_dependencies
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|psymtab
operator|->
name|number_of_dependencies
condition|;
name|i
operator|++
control|)
block|{
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|"    %d "
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|gdb_print_address
argument_list|(
name|psymtab
operator|->
name|dependencies
index|[
name|i
index|]
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|" %s\n"
argument_list|,
name|psymtab
operator|->
name|dependencies
index|[
name|i
index|]
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|psymtab
operator|->
name|n_global_syms
operator|>
literal|0
condition|)
block|{
name|print_partial_symbol
argument_list|(
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
operator|+
name|psymtab
operator|->
name|globals_offset
argument_list|,
name|psymtab
operator|->
name|n_global_syms
argument_list|,
literal|"Global"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|psymtab
operator|->
name|n_static_syms
operator|>
literal|0
condition|)
block|{
name|print_partial_symbol
argument_list|(
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
operator|+
name|psymtab
operator|->
name|statics_offset
argument_list|,
name|psymtab
operator|->
name|n_static_syms
argument_list|,
literal|"Static"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
block|}
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_symtab
parameter_list|(
name|objfile
parameter_list|,
name|symtab
parameter_list|,
name|outfile
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|symtab
modifier|*
name|symtab
decl_stmt|;
name|GDB_FILE
modifier|*
name|outfile
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|len
decl_stmt|,
name|blen
decl_stmt|;
specifier|register
name|struct
name|linetable
modifier|*
name|l
decl_stmt|;
name|struct
name|blockvector
modifier|*
name|bv
decl_stmt|;
specifier|register
name|struct
name|block
modifier|*
name|b
decl_stmt|;
name|int
name|depth
decl_stmt|;
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|"\nSymtab for file %s\n"
argument_list|,
name|symtab
operator|->
name|filename
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|"Read from object file %s ("
argument_list|,
name|objfile
operator|->
name|name
argument_list|)
expr_stmt|;
name|gdb_print_address
argument_list|(
name|objfile
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|"Language: %s\n"
argument_list|,
name|language_str
argument_list|(
name|symtab
operator|->
name|language
argument_list|)
argument_list|)
expr_stmt|;
comment|/* First print the line table.  */
name|l
operator|=
name|LINETABLE
argument_list|(
name|symtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|"\nLine table:\n\n"
argument_list|)
expr_stmt|;
name|len
operator|=
name|l
operator|->
name|nitems
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|" line %d at "
argument_list|,
name|l
operator|->
name|item
index|[
name|i
index|]
operator|.
name|line
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|l
operator|->
name|item
index|[
name|i
index|]
operator|.
name|pc
argument_list|,
literal|1
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now print the block info.  */
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|"\nBlockvector:\n\n"
argument_list|)
expr_stmt|;
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|symtab
argument_list|)
expr_stmt|;
name|len
operator|=
name|BLOCKVECTOR_NBLOCKS
argument_list|(
name|bv
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|depth
operator|=
name|block_depth
argument_list|(
name|b
argument_list|)
operator|*
literal|2
expr_stmt|;
name|print_spaces
argument_list|(
name|depth
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|"block #%03d (object "
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|gdb_print_address
argument_list|(
name|b
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|") "
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|"["
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|BLOCK_START
argument_list|(
name|b
argument_list|)
argument_list|,
literal|1
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|".."
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|BLOCK_END
argument_list|(
name|b
argument_list|)
argument_list|,
literal|1
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|"]"
argument_list|)
expr_stmt|;
if|if
condition|(
name|BLOCK_SUPERBLOCK
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|" (under "
argument_list|)
expr_stmt|;
name|gdb_print_address
argument_list|(
name|BLOCK_SUPERBLOCK
argument_list|(
name|b
argument_list|)
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|BLOCK_FUNCTION
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|" %s"
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|BLOCK_FUNCTION
argument_list|(
name|b
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SYMBOL_DEMANGLED_NAME
argument_list|(
name|BLOCK_FUNCTION
argument_list|(
name|b
argument_list|)
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|" %s"
argument_list|,
name|SYMBOL_DEMANGLED_NAME
argument_list|(
name|BLOCK_FUNCTION
argument_list|(
name|b
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|BLOCK_GCC_COMPILED
argument_list|(
name|b
argument_list|)
condition|)
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|" gcc%d compiled"
argument_list|,
name|BLOCK_GCC_COMPILED
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|blen
operator|=
name|BLOCK_NSYMS
argument_list|(
name|b
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|blen
condition|;
name|j
operator|++
control|)
block|{
name|struct
name|print_symbol_args
name|s
decl_stmt|;
name|s
operator|.
name|symbol
operator|=
name|BLOCK_SYM
argument_list|(
name|b
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|s
operator|.
name|depth
operator|=
name|depth
operator|+
literal|1
expr_stmt|;
name|s
operator|.
name|outfile
operator|=
name|outfile
expr_stmt|;
name|catch_errors
argument_list|(
name|print_symbol
argument_list|,
operator|&
name|s
argument_list|,
literal|"Error printing symbol:\n"
argument_list|,
name|RETURN_MASK_ERROR
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|maintenance_print_symbols
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|GDB_FILE
modifier|*
name|outfile
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|cleanups
decl_stmt|;
name|char
modifier|*
name|symname
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|filename
init|=
name|DEV_TTY
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
name|dont_repeat
argument_list|()
expr_stmt|;
if|if
condition|(
name|args
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"\ Arguments missing: an output file name and an optional symbol file name"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|argv
operator|=
name|buildargv
argument_list|(
name|args
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|nomem
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|cleanups
operator|=
name|make_cleanup
argument_list|(
name|freeargv
argument_list|,
operator|(
name|char
operator|*
operator|)
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|argv
index|[
literal|0
index|]
operator|!=
name|NULL
condition|)
block|{
name|filename
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
comment|/* If a second arg is supplied, it is a source file name to match on */
if|if
condition|(
name|argv
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
block|{
name|symname
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
block|}
block|}
name|filename
operator|=
name|tilde_expand
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|outfile
operator|=
name|gdb_fopen
argument_list|(
name|filename
argument_list|,
name|FOPEN_WT
argument_list|)
expr_stmt|;
if|if
condition|(
name|outfile
operator|==
literal|0
condition|)
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|fclose
argument_list|,
operator|(
name|char
operator|*
operator|)
name|outfile
argument_list|)
expr_stmt|;
name|immediate_quit
operator|++
expr_stmt|;
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
if|if
condition|(
name|symname
operator|==
name|NULL
operator|||
operator|(
name|STREQ
argument_list|(
name|symname
argument_list|,
name|s
operator|->
name|filename
argument_list|)
operator|)
condition|)
name|dump_symtab
argument_list|(
name|objfile
argument_list|,
name|s
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|immediate_quit
operator|--
expr_stmt|;
name|do_cleanups
argument_list|(
name|cleanups
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print symbol ARGS->SYMBOL on ARGS->OUTFILE.  ARGS->DEPTH says how    far to indent.  ARGS is really a struct print_symbol_args *, but is    declared as char * to get it past catch_errors.  Returns 0 for error,    1 for success.  */
end_comment

begin_function
specifier|static
name|int
name|print_symbol
parameter_list|(
name|args
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
block|{
name|struct
name|symbol
modifier|*
name|symbol
init|=
operator|(
operator|(
expr|struct
name|print_symbol_args
operator|*
operator|)
name|args
operator|)
operator|->
name|symbol
decl_stmt|;
name|int
name|depth
init|=
operator|(
operator|(
expr|struct
name|print_symbol_args
operator|*
operator|)
name|args
operator|)
operator|->
name|depth
decl_stmt|;
name|GDB_FILE
modifier|*
name|outfile
init|=
operator|(
operator|(
expr|struct
name|print_symbol_args
operator|*
operator|)
name|args
operator|)
operator|->
name|outfile
decl_stmt|;
name|print_spaces
argument_list|(
name|depth
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|SYMBOL_NAMESPACE
argument_list|(
name|symbol
argument_list|)
operator|==
name|LABEL_NAMESPACE
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|"label %s at "
argument_list|,
name|SYMBOL_SOURCE_NAME
argument_list|(
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|symbol
argument_list|)
argument_list|,
literal|1
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|SYMBOL_NAMESPACE
argument_list|(
name|symbol
argument_list|)
operator|==
name|STRUCT_NAMESPACE
condition|)
block|{
if|if
condition|(
name|TYPE_TAG_NAME
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|symbol
argument_list|)
argument_list|)
condition|)
block|{
name|LA_PRINT_TYPE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|symbol
argument_list|)
argument_list|,
literal|""
argument_list|,
name|outfile
argument_list|,
literal|1
argument_list|,
name|depth
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|"%s %s = "
argument_list|,
operator|(
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|symbol
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_ENUM
condition|?
literal|"enum"
else|:
operator|(
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|symbol
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
condition|?
literal|"struct"
else|:
literal|"union"
operator|)
operator|)
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|LA_PRINT_TYPE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|symbol
argument_list|)
argument_list|,
literal|""
argument_list|,
name|outfile
argument_list|,
literal|1
argument_list|,
name|depth
argument_list|)
expr_stmt|;
block|}
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|";\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|symbol
argument_list|)
operator|==
name|LOC_TYPEDEF
condition|)
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|"typedef "
argument_list|)
expr_stmt|;
if|if
condition|(
name|SYMBOL_TYPE
argument_list|(
name|symbol
argument_list|)
condition|)
block|{
comment|/* Print details of types, except for enums where it's clutter.  */
name|LA_PRINT_TYPE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|symbol
argument_list|)
argument_list|,
name|SYMBOL_SOURCE_NAME
argument_list|(
name|symbol
argument_list|)
argument_list|,
name|outfile
argument_list|,
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|symbol
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_ENUM
argument_list|,
name|depth
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|"; "
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|"%s "
argument_list|,
name|SYMBOL_SOURCE_NAME
argument_list|(
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|SYMBOL_CLASS
argument_list|(
name|symbol
argument_list|)
condition|)
block|{
case|case
name|LOC_CONST
case|:
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|"const %ld (0x%lx),"
argument_list|,
name|SYMBOL_VALUE
argument_list|(
name|symbol
argument_list|)
argument_list|,
name|SYMBOL_VALUE
argument_list|(
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_CONST_BYTES
case|:
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|"const %u hex bytes:"
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|symbol
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|{
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TYPE_LENGTH
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|symbol
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|" %02x"
argument_list|,
operator|(
name|unsigned
operator|)
name|SYMBOL_VALUE_BYTES
argument_list|(
name|symbol
argument_list|)
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|","
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LOC_STATIC
case|:
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|"static at "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|symbol
argument_list|)
argument_list|,
literal|1
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|","
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_REGISTER
case|:
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|"register %ld,"
argument_list|,
name|SYMBOL_VALUE
argument_list|(
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_ARG
case|:
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|"arg at offset 0x%lx,"
argument_list|,
name|SYMBOL_VALUE
argument_list|(
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_LOCAL_ARG
case|:
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|"arg at offset 0x%lx from fp,"
argument_list|,
name|SYMBOL_VALUE
argument_list|(
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_REF_ARG
case|:
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|"reference arg at 0x%lx,"
argument_list|,
name|SYMBOL_VALUE
argument_list|(
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_REGPARM
case|:
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|"parameter register %ld,"
argument_list|,
name|SYMBOL_VALUE
argument_list|(
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_REGPARM_ADDR
case|:
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|"address parameter register %ld,"
argument_list|,
name|SYMBOL_VALUE
argument_list|(
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_LOCAL
case|:
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|"local at offset 0x%lx,"
argument_list|,
name|SYMBOL_VALUE
argument_list|(
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_BASEREG
case|:
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|"local at 0x%lx from register %d"
argument_list|,
name|SYMBOL_VALUE
argument_list|(
name|symbol
argument_list|)
argument_list|,
name|SYMBOL_BASEREG
argument_list|(
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_BASEREG_ARG
case|:
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|"arg at 0x%lx from register %d,"
argument_list|,
name|SYMBOL_VALUE
argument_list|(
name|symbol
argument_list|)
argument_list|,
name|SYMBOL_BASEREG
argument_list|(
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_TYPEDEF
case|:
break|break;
case|case
name|LOC_LABEL
case|:
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|"label at "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|symbol
argument_list|)
argument_list|,
literal|1
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_BLOCK
case|:
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|"block (object "
argument_list|)
expr_stmt|;
name|gdb_print_address
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|symbol
argument_list|)
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|") starting at "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|BLOCK_START
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|symbol
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|","
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_OPTIMIZED_OUT
case|:
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|"optimized out"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|"botched symbol class %x"
argument_list|,
name|SYMBOL_CLASS
argument_list|(
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|maintenance_print_psymbols
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|GDB_FILE
modifier|*
name|outfile
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|cleanups
decl_stmt|;
name|char
modifier|*
name|symname
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|filename
init|=
name|DEV_TTY
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|partial_symtab
modifier|*
name|ps
decl_stmt|;
name|dont_repeat
argument_list|()
expr_stmt|;
if|if
condition|(
name|args
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"print-psymbols takes an output file name and optional symbol file name"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|argv
operator|=
name|buildargv
argument_list|(
name|args
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|nomem
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|cleanups
operator|=
name|make_cleanup
argument_list|(
name|freeargv
argument_list|,
operator|(
name|char
operator|*
operator|)
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|argv
index|[
literal|0
index|]
operator|!=
name|NULL
condition|)
block|{
name|filename
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
comment|/* If a second arg is supplied, it is a source file name to match on */
if|if
condition|(
name|argv
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
block|{
name|symname
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
block|}
block|}
name|filename
operator|=
name|tilde_expand
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|outfile
operator|=
name|gdb_fopen
argument_list|(
name|filename
argument_list|,
name|FOPEN_WT
argument_list|)
expr_stmt|;
if|if
condition|(
name|outfile
operator|==
literal|0
condition|)
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|fclose
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|immediate_quit
operator|++
expr_stmt|;
name|ALL_PSYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|ps
argument_list|)
if|if
condition|(
name|symname
operator|==
name|NULL
operator|||
operator|(
name|STREQ
argument_list|(
name|symname
argument_list|,
name|ps
operator|->
name|filename
argument_list|)
operator|)
condition|)
name|dump_psymtab
argument_list|(
name|objfile
argument_list|,
name|ps
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|immediate_quit
operator|--
expr_stmt|;
name|do_cleanups
argument_list|(
name|cleanups
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_partial_symbol
parameter_list|(
name|p
parameter_list|,
name|count
parameter_list|,
name|what
parameter_list|,
name|outfile
parameter_list|)
name|struct
name|partial_symbol
modifier|*
name|p
decl_stmt|;
name|int
name|count
decl_stmt|;
name|char
modifier|*
name|what
decl_stmt|;
name|GDB_FILE
modifier|*
name|outfile
decl_stmt|;
block|{
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|"  %s partial symbols:\n"
argument_list|,
name|what
argument_list|)
expr_stmt|;
while|while
condition|(
name|count
operator|--
operator|>
literal|0
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|"    `%s'"
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SYMBOL_DEMANGLED_NAME
argument_list|(
name|p
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|"  `%s'"
argument_list|,
name|SYMBOL_DEMANGLED_NAME
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fputs_filtered
argument_list|(
literal|", "
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|SYMBOL_NAMESPACE
argument_list|(
name|p
argument_list|)
condition|)
block|{
case|case
name|UNDEF_NAMESPACE
case|:
name|fputs_filtered
argument_list|(
literal|"undefined namespace, "
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|VAR_NAMESPACE
case|:
comment|/* This is the usual thing -- don't print it */
break|break;
case|case
name|STRUCT_NAMESPACE
case|:
name|fputs_filtered
argument_list|(
literal|"struct namespace, "
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|LABEL_NAMESPACE
case|:
name|fputs_filtered
argument_list|(
literal|"label namespace, "
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fputs_filtered
argument_list|(
literal|"<invalid namespace>, "
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|SYMBOL_CLASS
argument_list|(
name|p
argument_list|)
condition|)
block|{
case|case
name|LOC_UNDEF
case|:
name|fputs_filtered
argument_list|(
literal|"undefined"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_CONST
case|:
name|fputs_filtered
argument_list|(
literal|"constant int"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_STATIC
case|:
name|fputs_filtered
argument_list|(
literal|"static"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_REGISTER
case|:
name|fputs_filtered
argument_list|(
literal|"register"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_ARG
case|:
name|fputs_filtered
argument_list|(
literal|"pass by value"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_REF_ARG
case|:
name|fputs_filtered
argument_list|(
literal|"pass by reference"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_REGPARM
case|:
name|fputs_filtered
argument_list|(
literal|"register parameter"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_REGPARM_ADDR
case|:
name|fputs_filtered
argument_list|(
literal|"register address parameter"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_LOCAL
case|:
name|fputs_filtered
argument_list|(
literal|"stack parameter"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_TYPEDEF
case|:
name|fputs_filtered
argument_list|(
literal|"type"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_LABEL
case|:
name|fputs_filtered
argument_list|(
literal|"label"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_BLOCK
case|:
name|fputs_filtered
argument_list|(
literal|"function"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_CONST_BYTES
case|:
name|fputs_filtered
argument_list|(
literal|"constant bytes"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_LOCAL_ARG
case|:
name|fputs_filtered
argument_list|(
literal|"shuffled arg"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_OPTIMIZED_OUT
case|:
name|fputs_filtered
argument_list|(
literal|"optimized out"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fputs_filtered
argument_list|(
literal|"<invalid location>"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
break|break;
block|}
name|fputs_filtered
argument_list|(
literal|", "
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
comment|/* FIXME-32x64: Need to use SYMBOL_VALUE_ADDRESS, etc.; this 	 could be 32 bits when some of the other fields in the union 	 are 64.  */
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|"0x%lx\n"
argument_list|,
name|SYMBOL_VALUE
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|maintenance_print_msymbols
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|GDB_FILE
modifier|*
name|outfile
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|cleanups
decl_stmt|;
name|char
modifier|*
name|filename
init|=
name|DEV_TTY
decl_stmt|;
name|char
modifier|*
name|symname
init|=
name|NULL
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|dont_repeat
argument_list|()
expr_stmt|;
if|if
condition|(
name|args
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"print-msymbols takes an output file name and optional symbol file name"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|argv
operator|=
name|buildargv
argument_list|(
name|args
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|nomem
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|cleanups
operator|=
name|make_cleanup
argument_list|(
name|freeargv
argument_list|,
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|argv
index|[
literal|0
index|]
operator|!=
name|NULL
condition|)
block|{
name|filename
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
comment|/* If a second arg is supplied, it is a source file name to match on */
if|if
condition|(
name|argv
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
block|{
name|symname
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
block|}
block|}
name|filename
operator|=
name|tilde_expand
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|outfile
operator|=
name|gdb_fopen
argument_list|(
name|filename
argument_list|,
name|FOPEN_WT
argument_list|)
expr_stmt|;
if|if
condition|(
name|outfile
operator|==
literal|0
condition|)
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|fclose
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|immediate_quit
operator|++
expr_stmt|;
name|ALL_OBJFILES
argument_list|(
argument|objfile
argument_list|)
if|if
condition|(
name|symname
operator|==
name|NULL
operator|||
operator|(
name|STREQ
argument_list|(
name|symname
argument_list|,
name|objfile
operator|->
name|name
argument_list|)
operator|)
condition|)
name|dump_msymbols
argument_list|(
name|objfile
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|immediate_quit
operator|--
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|outfile
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|cleanups
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|maintenance_print_objfiles
parameter_list|(
name|ignore
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|ignore
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|dont_repeat
argument_list|()
expr_stmt|;
name|immediate_quit
operator|++
expr_stmt|;
name|ALL_OBJFILES
argument_list|(
argument|objfile
argument_list|)
name|dump_objfile
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|immediate_quit
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check consistency of psymtabs and symtabs.  */
end_comment

begin_function
name|void
name|maintenance_check_symtabs
parameter_list|(
name|ignore
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|ignore
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|register
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
specifier|register
name|struct
name|partial_symbol
modifier|*
name|psym
decl_stmt|;
specifier|register
name|struct
name|symtab
modifier|*
name|s
init|=
name|NULL
decl_stmt|;
specifier|register
name|struct
name|partial_symtab
modifier|*
name|ps
decl_stmt|;
name|struct
name|blockvector
modifier|*
name|bv
decl_stmt|;
specifier|register
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
specifier|register
name|struct
name|block
modifier|*
name|b
decl_stmt|;
name|int
name|length
decl_stmt|;
name|ALL_PSYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|ps
argument_list|)
block|{
name|s
operator|=
name|PSYMTAB_TO_SYMTAB
argument_list|(
name|ps
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
continue|continue;
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|STATIC_BLOCK
argument_list|)
expr_stmt|;
name|psym
operator|=
name|ps
operator|->
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
operator|+
name|ps
operator|->
name|statics_offset
expr_stmt|;
name|length
operator|=
name|ps
operator|->
name|n_static_syms
expr_stmt|;
while|while
condition|(
name|length
operator|--
condition|)
block|{
name|sym
operator|=
name|lookup_block_symbol
argument_list|(
name|b
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|psym
argument_list|)
argument_list|,
name|SYMBOL_NAMESPACE
argument_list|(
name|psym
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sym
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Static symbol `"
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|psym
argument_list|)
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"' only found in "
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
name|ps
operator|->
name|filename
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" psymtab\n"
argument_list|)
expr_stmt|;
block|}
name|psym
operator|++
expr_stmt|;
block|}
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
expr_stmt|;
name|psym
operator|=
name|ps
operator|->
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
operator|+
name|ps
operator|->
name|globals_offset
expr_stmt|;
name|length
operator|=
name|ps
operator|->
name|n_global_syms
expr_stmt|;
while|while
condition|(
name|length
operator|--
condition|)
block|{
name|sym
operator|=
name|lookup_block_symbol
argument_list|(
name|b
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|psym
argument_list|)
argument_list|,
name|SYMBOL_NAMESPACE
argument_list|(
name|psym
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sym
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Global symbol `"
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|psym
argument_list|)
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"' only found in "
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
name|ps
operator|->
name|filename
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" psymtab\n"
argument_list|)
expr_stmt|;
block|}
name|psym
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|ps
operator|->
name|texthigh
operator|<
name|ps
operator|->
name|textlow
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Psymtab "
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
name|ps
operator|->
name|filename
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" covers bad range "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|ps
operator|->
name|textlow
argument_list|,
literal|1
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" - "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|ps
operator|->
name|texthigh
argument_list|,
literal|1
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ps
operator|->
name|texthigh
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|ps
operator|->
name|textlow
operator|<
name|BLOCK_START
argument_list|(
name|b
argument_list|)
operator|||
name|ps
operator|->
name|texthigh
operator|>
name|BLOCK_END
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Psymtab "
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
name|ps
operator|->
name|filename
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" covers "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|ps
operator|->
name|textlow
argument_list|,
literal|1
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" - "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|ps
operator|->
name|texthigh
argument_list|,
literal|1
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" but symtab covers only "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|BLOCK_START
argument_list|(
name|b
argument_list|)
argument_list|,
literal|1
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" - "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|BLOCK_END
argument_list|(
name|b
argument_list|)
argument_list|,
literal|1
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the nexting depth of a block within other blocks in its symtab.  */
end_comment

begin_function
specifier|static
name|int
name|block_depth
parameter_list|(
name|block
parameter_list|)
name|struct
name|block
modifier|*
name|block
decl_stmt|;
block|{
specifier|register
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|block
operator|=
name|BLOCK_SUPERBLOCK
argument_list|(
name|block
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|i
operator|++
expr_stmt|;
block|}
return|return
name|i
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MAINTENANCE_CMDS */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Increase the space allocated for LISTP, which is probably    global_psymbol_list or static_psymbol_list. This space will eventually    be freed in free_objfile().  */
end_comment

begin_function
name|void
name|extend_psymbol_list
parameter_list|(
name|listp
parameter_list|,
name|objfile
parameter_list|)
specifier|register
name|struct
name|psymbol_allocation_list
modifier|*
name|listp
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|int
name|new_size
decl_stmt|;
if|if
condition|(
name|listp
operator|->
name|size
operator|==
literal|0
condition|)
block|{
name|new_size
operator|=
literal|255
expr_stmt|;
name|listp
operator|->
name|list
operator|=
operator|(
expr|struct
name|partial_symbol
operator|*
operator|)
name|xmmalloc
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
name|new_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|partial_symbol
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|new_size
operator|=
name|listp
operator|->
name|size
operator|*
literal|2
expr_stmt|;
name|listp
operator|->
name|list
operator|=
operator|(
expr|struct
name|partial_symbol
operator|*
operator|)
name|xmrealloc
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
operator|(
name|char
operator|*
operator|)
name|listp
operator|->
name|list
argument_list|,
name|new_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|partial_symbol
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Next assumes we only went one over.  Should be good if      program works correctly */
name|listp
operator|->
name|next
operator|=
name|listp
operator|->
name|list
operator|+
name|listp
operator|->
name|size
expr_stmt|;
name|listp
operator|->
name|size
operator|=
name|new_size
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Do early runtime initializations. */
end_comment

begin_function
name|void
name|_initialize_symmisc
parameter_list|()
block|{
name|std_in
operator|=
name|stdin
expr_stmt|;
name|std_out
operator|=
name|stdout
expr_stmt|;
name|std_err
operator|=
name|stderr
expr_stmt|;
block|}
end_function

end_unit

