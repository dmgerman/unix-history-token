begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Parse expressions for GDB.    Copyright (C) 1986, 1989, 1990, 1991 Free Software Foundation, Inc.    Modified from expread.y by the Department of Computer Science at the    State University of New York at Buffalo, 1991.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* Parse an expression from text in a string,    and return the result as a  struct expression  pointer.    That structure contains arithmetic operations in reverse polish,    with constants represented by operations that are followed by special data.    See expression.h for the details of the format.    What is important here is that it can be built up sequentially    during the process of parsing; the lower levels of the tree always    come first in the result.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"parser-defs.h"
end_include

begin_decl_stmt
specifier|static
name|void
name|free_funcalls
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|prefixify_expression
name|PARAMS
argument_list|(
operator|(
expr|struct
name|expression
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|length_of_subexp
name|PARAMS
argument_list|(
operator|(
expr|struct
name|expression
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|prefixify_subexp
name|PARAMS
argument_list|(
operator|(
expr|struct
name|expression
operator|*
operator|,
expr|struct
name|expression
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Data structure for saving values of arglist_len for function calls whose    arguments contain other function calls.  */
end_comment

begin_struct
struct|struct
name|funcall
block|{
name|struct
name|funcall
modifier|*
name|next
decl_stmt|;
name|int
name|arglist_len
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|funcall
modifier|*
name|funcall_chain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Assign machine-independent names to certain registers     (unless overridden by the REGISTER_NAMES table) */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NO_STD_REGS
end_ifdef

begin_decl_stmt
name|unsigned
name|num_std_regs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|std_regs
name|std_regs
index|[
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|struct
name|std_regs
name|std_regs
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|PC_REGNUM
block|{
literal|"pc"
block|,
name|PC_REGNUM
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|FP_REGNUM
block|{
literal|"fp"
block|,
name|FP_REGNUM
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SP_REGNUM
block|{
literal|"sp"
block|,
name|SP_REGNUM
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PS_REGNUM
block|{
literal|"ps"
block|,
name|PS_REGNUM
block|}
block|,
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|num_std_regs
init|=
operator|(
sizeof|sizeof
name|std_regs
operator|/
sizeof|sizeof
name|std_regs
index|[
literal|0
index|]
operator|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Begin counting arguments for a function call,    saving the data about any containing call.  */
end_comment

begin_function
name|void
name|start_arglist
parameter_list|()
block|{
specifier|register
name|struct
name|funcall
modifier|*
name|new
decl_stmt|;
name|new
operator|=
operator|(
expr|struct
name|funcall
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|funcall
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|funcall_chain
expr_stmt|;
name|new
operator|->
name|arglist_len
operator|=
name|arglist_len
expr_stmt|;
name|arglist_len
operator|=
literal|0
expr_stmt|;
name|funcall_chain
operator|=
name|new
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the number of arguments in a function call just terminated,    and restore the data for the containing function call.  */
end_comment

begin_function
name|int
name|end_arglist
parameter_list|()
block|{
specifier|register
name|int
name|val
init|=
name|arglist_len
decl_stmt|;
specifier|register
name|struct
name|funcall
modifier|*
name|call
init|=
name|funcall_chain
decl_stmt|;
name|funcall_chain
operator|=
name|call
operator|->
name|next
expr_stmt|;
name|arglist_len
operator|=
name|call
operator|->
name|arglist_len
expr_stmt|;
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|call
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Free everything in the funcall chain.    Used when there is an error inside parsing.  */
end_comment

begin_function
specifier|static
name|void
name|free_funcalls
parameter_list|()
block|{
specifier|register
name|struct
name|funcall
modifier|*
name|call
decl_stmt|,
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|call
operator|=
name|funcall_chain
init|;
name|call
condition|;
name|call
operator|=
name|next
control|)
block|{
name|next
operator|=
name|call
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|call
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This page contains the functions for adding data to the  struct expression    being constructed.  */
end_comment

begin_comment
comment|/* Add one element to the end of the expression.  */
end_comment

begin_comment
comment|/* To avoid a bug in the Sun 4 compiler, we pass things that can fit into    a register through here */
end_comment

begin_function
name|void
name|write_exp_elt
parameter_list|(
name|expelt
parameter_list|)
name|union
name|exp_element
name|expelt
decl_stmt|;
block|{
if|if
condition|(
name|expout_ptr
operator|>=
name|expout_size
condition|)
block|{
name|expout_size
operator|*=
literal|2
expr_stmt|;
name|expout
operator|=
operator|(
expr|struct
name|expression
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|expout
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|expression
argument_list|)
operator|+
name|EXP_ELEM_TO_BYTES
argument_list|(
name|expout_size
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|expout
operator|->
name|elts
index|[
name|expout_ptr
operator|++
index|]
operator|=
name|expelt
expr_stmt|;
block|}
end_function

begin_function
name|void
name|write_exp_elt_opcode
parameter_list|(
name|expelt
parameter_list|)
name|enum
name|exp_opcode
name|expelt
decl_stmt|;
block|{
name|union
name|exp_element
name|tmp
decl_stmt|;
name|tmp
operator|.
name|opcode
operator|=
name|expelt
expr_stmt|;
name|write_exp_elt
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|write_exp_elt_sym
parameter_list|(
name|expelt
parameter_list|)
name|struct
name|symbol
modifier|*
name|expelt
decl_stmt|;
block|{
name|union
name|exp_element
name|tmp
decl_stmt|;
name|tmp
operator|.
name|symbol
operator|=
name|expelt
expr_stmt|;
name|write_exp_elt
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|write_exp_elt_block
parameter_list|(
name|b
parameter_list|)
name|struct
name|block
modifier|*
name|b
decl_stmt|;
block|{
name|union
name|exp_element
name|tmp
decl_stmt|;
name|tmp
operator|.
name|block
operator|=
name|b
expr_stmt|;
name|write_exp_elt
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|write_exp_elt_longcst
parameter_list|(
name|expelt
parameter_list|)
name|LONGEST
name|expelt
decl_stmt|;
block|{
name|union
name|exp_element
name|tmp
decl_stmt|;
name|tmp
operator|.
name|longconst
operator|=
name|expelt
expr_stmt|;
name|write_exp_elt
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|write_exp_elt_dblcst
parameter_list|(
name|expelt
parameter_list|)
name|double
name|expelt
decl_stmt|;
block|{
name|union
name|exp_element
name|tmp
decl_stmt|;
name|tmp
operator|.
name|doubleconst
operator|=
name|expelt
expr_stmt|;
name|write_exp_elt
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|write_exp_elt_type
parameter_list|(
name|expelt
parameter_list|)
name|struct
name|type
modifier|*
name|expelt
decl_stmt|;
block|{
name|union
name|exp_element
name|tmp
decl_stmt|;
name|tmp
operator|.
name|type
operator|=
name|expelt
expr_stmt|;
name|write_exp_elt
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|write_exp_elt_intern
parameter_list|(
name|expelt
parameter_list|)
name|struct
name|internalvar
modifier|*
name|expelt
decl_stmt|;
block|{
name|union
name|exp_element
name|tmp
decl_stmt|;
name|tmp
operator|.
name|internalvar
operator|=
name|expelt
expr_stmt|;
name|write_exp_elt
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a string constant to the end of the expression.     String constants are stored by first writing an expression element    that contains the length of the string, then stuffing the string    constant itself into however many expression elements are needed    to hold it, and then writing another expression element that contains    the length of the string.  I.E. an expression element at each end of    the string records the string length, so you can skip over the     expression elements containing the actual string bytes from either    end of the string.  Note that this also allows gdb to handle    strings with embedded null bytes, as is required for some languages.     Don't be fooled by the fact that the string is null byte terminated,    this is strictly for the convenience of debugging gdb itself.  Gdb    Gdb does not depend up the string being null terminated, since the    actual length is recorded in expression elements at each end of the    string.  The null byte is taken into consideration when computing how    many expression elements are required to hold the string constant, of    course. */
end_comment

begin_function
name|void
name|write_exp_string
parameter_list|(
name|str
parameter_list|)
name|struct
name|stoken
name|str
decl_stmt|;
block|{
specifier|register
name|int
name|len
init|=
name|str
operator|.
name|length
decl_stmt|;
specifier|register
name|int
name|lenelt
decl_stmt|;
specifier|register
name|char
modifier|*
name|strdata
decl_stmt|;
comment|/* Compute the number of expression elements required to hold the string      (including a null byte terminator), along with one expression element      at each end to record the actual string length (not including the      null byte terminator). */
name|lenelt
operator|=
literal|2
operator|+
name|BYTES_TO_EXP_ELEM
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Ensure that we have enough available expression elements to store      everything. */
if|if
condition|(
operator|(
name|expout_ptr
operator|+
name|lenelt
operator|)
operator|>=
name|expout_size
condition|)
block|{
name|expout_size
operator|=
name|max
argument_list|(
name|expout_size
operator|*
literal|2
argument_list|,
name|expout_ptr
operator|+
name|lenelt
operator|+
literal|10
argument_list|)
expr_stmt|;
name|expout
operator|=
operator|(
expr|struct
name|expression
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|expout
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|expression
argument_list|)
operator|+
name|EXP_ELEM_TO_BYTES
argument_list|(
name|expout_size
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Write the leading length expression element (which advances the current      expression element index), then write the string constant followed by a      terminating null byte, and then write the trailing length expression      element. */
name|write_exp_elt_longcst
argument_list|(
operator|(
name|LONGEST
operator|)
name|len
argument_list|)
expr_stmt|;
name|strdata
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|expout
operator|->
name|elts
index|[
name|expout_ptr
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|strdata
argument_list|,
name|str
operator|.
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|*
operator|(
name|strdata
operator|+
name|len
operator|)
operator|=
literal|'\0'
expr_stmt|;
name|expout_ptr
operator|+=
name|lenelt
operator|-
literal|2
expr_stmt|;
name|write_exp_elt_longcst
argument_list|(
operator|(
name|LONGEST
operator|)
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a bitstring constant to the end of the expression.     Bitstring constants are stored by first writing an expression element    that contains the length of the bitstring (in bits), then stuffing the    bitstring constant itself into however many expression elements are    needed to hold it, and then writing another expression element that    contains the length of the bitstring.  I.E. an expression element at    each end of the bitstring records the bitstring length, so you can skip    over the expression elements containing the actual bitstring bytes from    either end of the bitstring. */
end_comment

begin_function
name|void
name|write_exp_bitstring
parameter_list|(
name|str
parameter_list|)
name|struct
name|stoken
name|str
decl_stmt|;
block|{
specifier|register
name|int
name|bits
init|=
name|str
operator|.
name|length
decl_stmt|;
comment|/* length in bits */
specifier|register
name|int
name|len
init|=
operator|(
name|bits
operator|+
name|HOST_CHAR_BIT
operator|-
literal|1
operator|)
operator|/
name|HOST_CHAR_BIT
decl_stmt|;
specifier|register
name|int
name|lenelt
decl_stmt|;
specifier|register
name|char
modifier|*
name|strdata
decl_stmt|;
comment|/* Compute the number of expression elements required to hold the bitstring,      along with one expression element at each end to record the actual      bitstring length in bits. */
name|lenelt
operator|=
literal|2
operator|+
name|BYTES_TO_EXP_ELEM
argument_list|(
name|len
argument_list|)
expr_stmt|;
comment|/* Ensure that we have enough available expression elements to store      everything. */
if|if
condition|(
operator|(
name|expout_ptr
operator|+
name|lenelt
operator|)
operator|>=
name|expout_size
condition|)
block|{
name|expout_size
operator|=
name|max
argument_list|(
name|expout_size
operator|*
literal|2
argument_list|,
name|expout_ptr
operator|+
name|lenelt
operator|+
literal|10
argument_list|)
expr_stmt|;
name|expout
operator|=
operator|(
expr|struct
name|expression
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|expout
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|expression
argument_list|)
operator|+
name|EXP_ELEM_TO_BYTES
argument_list|(
name|expout_size
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Write the leading length expression element (which advances the current      expression element index), then write the bitstring constant, and then      write the trailing length expression element. */
name|write_exp_elt_longcst
argument_list|(
operator|(
name|LONGEST
operator|)
name|bits
argument_list|)
expr_stmt|;
name|strdata
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|expout
operator|->
name|elts
index|[
name|expout_ptr
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|strdata
argument_list|,
name|str
operator|.
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|expout_ptr
operator|+=
name|lenelt
operator|-
literal|2
expr_stmt|;
name|write_exp_elt_longcst
argument_list|(
operator|(
name|LONGEST
operator|)
name|bits
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a null-terminated temporary copy of the name    of a string token.  */
end_comment

begin_function
name|char
modifier|*
name|copy_name
parameter_list|(
name|token
parameter_list|)
name|struct
name|stoken
name|token
decl_stmt|;
block|{
name|memcpy
argument_list|(
name|namecopy
argument_list|,
name|token
operator|.
name|ptr
argument_list|,
name|token
operator|.
name|length
argument_list|)
expr_stmt|;
name|namecopy
index|[
name|token
operator|.
name|length
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|namecopy
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Reverse an expression from suffix form (in which it is constructed)    to prefix form (in which we can conveniently print or execute it).  */
end_comment

begin_function
specifier|static
name|void
name|prefixify_expression
parameter_list|(
name|expr
parameter_list|)
specifier|register
name|struct
name|expression
modifier|*
name|expr
decl_stmt|;
block|{
specifier|register
name|int
name|len
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|expression
argument_list|)
operator|+
name|EXP_ELEM_TO_BYTES
argument_list|(
name|expr
operator|->
name|nelts
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|expression
modifier|*
name|temp
decl_stmt|;
specifier|register
name|int
name|inpos
init|=
name|expr
operator|->
name|nelts
decl_stmt|,
name|outpos
init|=
literal|0
decl_stmt|;
name|temp
operator|=
operator|(
expr|struct
name|expression
operator|*
operator|)
name|alloca
argument_list|(
name|len
argument_list|)
expr_stmt|;
comment|/* Copy the original expression into temp.  */
name|memcpy
argument_list|(
name|temp
argument_list|,
name|expr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|prefixify_subexp
argument_list|(
name|temp
argument_list|,
name|expr
argument_list|,
name|inpos
argument_list|,
name|outpos
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the number of exp_elements in the subexpression of EXPR    whose last exp_element is at index ENDPOS - 1 in EXPR.  */
end_comment

begin_function
specifier|static
name|int
name|length_of_subexp
parameter_list|(
name|expr
parameter_list|,
name|endpos
parameter_list|)
specifier|register
name|struct
name|expression
modifier|*
name|expr
decl_stmt|;
specifier|register
name|int
name|endpos
decl_stmt|;
block|{
specifier|register
name|int
name|oplen
init|=
literal|1
decl_stmt|;
specifier|register
name|int
name|args
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|endpos
operator|<
literal|1
condition|)
name|error
argument_list|(
literal|"?error in length_of_subexp"
argument_list|)
expr_stmt|;
name|i
operator|=
operator|(
name|int
operator|)
name|expr
operator|->
name|elts
index|[
name|endpos
operator|-
literal|1
index|]
operator|.
name|opcode
expr_stmt|;
switch|switch
condition|(
name|i
condition|)
block|{
comment|/* C++  */
case|case
name|OP_SCOPE
case|:
name|oplen
operator|=
name|longest_to_int
argument_list|(
name|expr
operator|->
name|elts
index|[
name|endpos
operator|-
literal|2
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
name|oplen
operator|=
literal|5
operator|+
name|BYTES_TO_EXP_ELEM
argument_list|(
name|oplen
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_LONG
case|:
case|case
name|OP_DOUBLE
case|:
case|case
name|OP_VAR_VALUE
case|:
name|oplen
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|OP_TYPE
case|:
case|case
name|OP_BOOL
case|:
case|case
name|OP_LAST
case|:
case|case
name|OP_REGISTER
case|:
case|case
name|OP_INTERNALVAR
case|:
name|oplen
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|OP_FUNCALL
case|:
name|oplen
operator|=
literal|3
expr_stmt|;
name|args
operator|=
literal|1
operator|+
name|longest_to_int
argument_list|(
name|expr
operator|->
name|elts
index|[
name|endpos
operator|-
literal|2
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNOP_MAX
case|:
case|case
name|UNOP_MIN
case|:
name|oplen
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|BINOP_VAL
case|:
case|case
name|UNOP_CAST
case|:
case|case
name|UNOP_MEMVAL
case|:
name|oplen
operator|=
literal|3
expr_stmt|;
name|args
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|UNOP_ABS
case|:
case|case
name|UNOP_CAP
case|:
case|case
name|UNOP_CHR
case|:
case|case
name|UNOP_FLOAT
case|:
case|case
name|UNOP_HIGH
case|:
case|case
name|UNOP_ODD
case|:
case|case
name|UNOP_ORD
case|:
case|case
name|UNOP_TRUNC
case|:
name|oplen
operator|=
literal|1
expr_stmt|;
name|args
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|STRUCTOP_STRUCT
case|:
case|case
name|STRUCTOP_PTR
case|:
name|args
operator|=
literal|1
expr_stmt|;
comment|/* fall through */
case|case
name|OP_M2_STRING
case|:
case|case
name|OP_STRING
case|:
name|oplen
operator|=
name|longest_to_int
argument_list|(
name|expr
operator|->
name|elts
index|[
name|endpos
operator|-
literal|2
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
name|oplen
operator|=
literal|4
operator|+
name|BYTES_TO_EXP_ELEM
argument_list|(
name|oplen
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_BITSTRING
case|:
name|oplen
operator|=
name|longest_to_int
argument_list|(
name|expr
operator|->
name|elts
index|[
name|endpos
operator|-
literal|2
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
name|oplen
operator|=
operator|(
name|oplen
operator|+
name|HOST_CHAR_BIT
operator|-
literal|1
operator|)
operator|/
name|HOST_CHAR_BIT
expr_stmt|;
name|oplen
operator|=
literal|4
operator|+
name|BYTES_TO_EXP_ELEM
argument_list|(
name|oplen
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_ARRAY
case|:
name|oplen
operator|=
literal|4
expr_stmt|;
name|args
operator|=
name|longest_to_int
argument_list|(
name|expr
operator|->
name|elts
index|[
name|endpos
operator|-
literal|2
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
name|args
operator|-=
name|longest_to_int
argument_list|(
name|expr
operator|->
name|elts
index|[
name|endpos
operator|-
literal|3
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
name|args
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|TERNOP_COND
case|:
name|args
operator|=
literal|3
expr_stmt|;
break|break;
comment|/* Modula-2 */
case|case
name|MULTI_SUBSCRIPT
case|:
name|oplen
operator|=
literal|3
expr_stmt|;
name|args
operator|=
literal|1
operator|+
name|longest_to_int
argument_list|(
name|expr
operator|->
name|elts
index|[
name|endpos
operator|-
literal|2
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_ASSIGN_MODIFY
case|:
name|oplen
operator|=
literal|3
expr_stmt|;
name|args
operator|=
literal|2
expr_stmt|;
break|break;
comment|/* C++ */
case|case
name|OP_THIS
case|:
name|oplen
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
name|args
operator|=
literal|1
operator|+
operator|(
name|i
operator|<
operator|(
name|int
operator|)
name|BINOP_END
operator|)
expr_stmt|;
block|}
while|while
condition|(
name|args
operator|>
literal|0
condition|)
block|{
name|oplen
operator|+=
name|length_of_subexp
argument_list|(
name|expr
argument_list|,
name|endpos
operator|-
name|oplen
argument_list|)
expr_stmt|;
name|args
operator|--
expr_stmt|;
block|}
return|return
name|oplen
return|;
block|}
end_function

begin_comment
comment|/* Copy the subexpression ending just before index INEND in INEXPR    into OUTEXPR, starting at index OUTBEG.    In the process, convert it from suffix to prefix form.  */
end_comment

begin_function
specifier|static
name|void
name|prefixify_subexp
parameter_list|(
name|inexpr
parameter_list|,
name|outexpr
parameter_list|,
name|inend
parameter_list|,
name|outbeg
parameter_list|)
specifier|register
name|struct
name|expression
modifier|*
name|inexpr
decl_stmt|;
name|struct
name|expression
modifier|*
name|outexpr
decl_stmt|;
specifier|register
name|int
name|inend
decl_stmt|;
name|int
name|outbeg
decl_stmt|;
block|{
specifier|register
name|int
name|oplen
init|=
literal|1
decl_stmt|;
specifier|register
name|int
name|args
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
modifier|*
name|arglens
decl_stmt|;
name|enum
name|exp_opcode
name|opcode
decl_stmt|;
comment|/* Compute how long the last operation is (in OPLEN),      and also how many preceding subexpressions serve as      arguments for it (in ARGS).  */
name|opcode
operator|=
name|inexpr
operator|->
name|elts
index|[
name|inend
operator|-
literal|1
index|]
operator|.
name|opcode
expr_stmt|;
switch|switch
condition|(
name|opcode
condition|)
block|{
comment|/* C++  */
case|case
name|OP_SCOPE
case|:
name|oplen
operator|=
name|longest_to_int
argument_list|(
name|inexpr
operator|->
name|elts
index|[
name|inend
operator|-
literal|2
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
name|oplen
operator|=
literal|5
operator|+
name|BYTES_TO_EXP_ELEM
argument_list|(
name|oplen
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_LONG
case|:
case|case
name|OP_DOUBLE
case|:
case|case
name|OP_VAR_VALUE
case|:
name|oplen
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|OP_TYPE
case|:
case|case
name|OP_BOOL
case|:
case|case
name|OP_LAST
case|:
case|case
name|OP_REGISTER
case|:
case|case
name|OP_INTERNALVAR
case|:
name|oplen
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|OP_FUNCALL
case|:
name|oplen
operator|=
literal|3
expr_stmt|;
name|args
operator|=
literal|1
operator|+
name|longest_to_int
argument_list|(
name|inexpr
operator|->
name|elts
index|[
name|inend
operator|-
literal|2
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNOP_MIN
case|:
case|case
name|UNOP_MAX
case|:
name|oplen
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|UNOP_CAST
case|:
case|case
name|UNOP_MEMVAL
case|:
name|oplen
operator|=
literal|3
expr_stmt|;
name|args
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|UNOP_ABS
case|:
case|case
name|UNOP_CAP
case|:
case|case
name|UNOP_CHR
case|:
case|case
name|UNOP_FLOAT
case|:
case|case
name|UNOP_HIGH
case|:
case|case
name|UNOP_ODD
case|:
case|case
name|UNOP_ORD
case|:
case|case
name|UNOP_TRUNC
case|:
name|oplen
operator|=
literal|1
expr_stmt|;
name|args
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|STRUCTOP_STRUCT
case|:
case|case
name|STRUCTOP_PTR
case|:
name|args
operator|=
literal|1
expr_stmt|;
comment|/* fall through */
case|case
name|OP_M2_STRING
case|:
case|case
name|OP_STRING
case|:
name|oplen
operator|=
name|longest_to_int
argument_list|(
name|inexpr
operator|->
name|elts
index|[
name|inend
operator|-
literal|2
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
name|oplen
operator|=
literal|4
operator|+
name|BYTES_TO_EXP_ELEM
argument_list|(
name|oplen
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_BITSTRING
case|:
name|oplen
operator|=
name|longest_to_int
argument_list|(
name|inexpr
operator|->
name|elts
index|[
name|inend
operator|-
literal|2
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
name|oplen
operator|=
operator|(
name|oplen
operator|+
name|HOST_CHAR_BIT
operator|-
literal|1
operator|)
operator|/
name|HOST_CHAR_BIT
expr_stmt|;
name|oplen
operator|=
literal|4
operator|+
name|BYTES_TO_EXP_ELEM
argument_list|(
name|oplen
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_ARRAY
case|:
name|oplen
operator|=
literal|4
expr_stmt|;
name|args
operator|=
name|longest_to_int
argument_list|(
name|inexpr
operator|->
name|elts
index|[
name|inend
operator|-
literal|2
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
name|args
operator|-=
name|longest_to_int
argument_list|(
name|inexpr
operator|->
name|elts
index|[
name|inend
operator|-
literal|3
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
name|args
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|TERNOP_COND
case|:
name|args
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|BINOP_ASSIGN_MODIFY
case|:
name|oplen
operator|=
literal|3
expr_stmt|;
name|args
operator|=
literal|2
expr_stmt|;
break|break;
comment|/* Modula-2 */
case|case
name|MULTI_SUBSCRIPT
case|:
name|oplen
operator|=
literal|3
expr_stmt|;
name|args
operator|=
literal|1
operator|+
name|longest_to_int
argument_list|(
name|inexpr
operator|->
name|elts
index|[
name|inend
operator|-
literal|2
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
break|break;
comment|/* C++ */
case|case
name|OP_THIS
case|:
name|oplen
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
name|args
operator|=
literal|1
operator|+
operator|(
operator|(
name|int
operator|)
name|opcode
operator|<
operator|(
name|int
operator|)
name|BINOP_END
operator|)
expr_stmt|;
block|}
comment|/* Copy the final operator itself, from the end of the input      to the beginning of the output.  */
name|inend
operator|-=
name|oplen
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|outexpr
operator|->
name|elts
index|[
name|outbeg
index|]
argument_list|,
operator|&
name|inexpr
operator|->
name|elts
index|[
name|inend
index|]
argument_list|,
name|EXP_ELEM_TO_BYTES
argument_list|(
name|oplen
argument_list|)
argument_list|)
expr_stmt|;
name|outbeg
operator|+=
name|oplen
expr_stmt|;
comment|/* Find the lengths of the arg subexpressions.  */
name|arglens
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|args
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|args
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|oplen
operator|=
name|length_of_subexp
argument_list|(
name|inexpr
argument_list|,
name|inend
argument_list|)
expr_stmt|;
name|arglens
index|[
name|i
index|]
operator|=
name|oplen
expr_stmt|;
name|inend
operator|-=
name|oplen
expr_stmt|;
block|}
comment|/* Now copy each subexpression, preserving the order of      the subexpressions, but prefixifying each one.      In this loop, inend starts at the beginning of      the expression this level is working on      and marches forward over the arguments.      outbeg does similarly in the output.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|args
condition|;
name|i
operator|++
control|)
block|{
name|oplen
operator|=
name|arglens
index|[
name|i
index|]
expr_stmt|;
name|inend
operator|+=
name|oplen
expr_stmt|;
name|prefixify_subexp
argument_list|(
name|inexpr
argument_list|,
name|outexpr
argument_list|,
name|inend
argument_list|,
name|outbeg
argument_list|)
expr_stmt|;
name|outbeg
operator|+=
name|oplen
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This page contains the two entry points to this file.  */
end_comment

begin_comment
comment|/* Read an expression from the string *STRINGPTR points to,    parse it, and return a pointer to a  struct expression  that we malloc.    Use block BLOCK as the lexical context for variable names;    if BLOCK is zero, use the block of the selected stack frame.    Meanwhile, advance *STRINGPTR to point after the expression,    at the first nonwhite character that is not part of the expression    (possibly a null character).     If COMMA is nonzero, stop if a comma is reached.  */
end_comment

begin_function
name|struct
name|expression
modifier|*
name|parse_exp_1
parameter_list|(
name|stringptr
parameter_list|,
name|block
parameter_list|,
name|comma
parameter_list|)
name|char
modifier|*
modifier|*
name|stringptr
decl_stmt|;
name|struct
name|block
modifier|*
name|block
decl_stmt|;
name|int
name|comma
decl_stmt|;
block|{
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|lexptr
operator|=
operator|*
name|stringptr
expr_stmt|;
name|paren_depth
operator|=
literal|0
expr_stmt|;
name|type_stack_depth
operator|=
literal|0
expr_stmt|;
name|comma_terminates
operator|=
name|comma
expr_stmt|;
if|if
condition|(
name|lexptr
operator|==
literal|0
operator|||
operator|*
name|lexptr
operator|==
literal|0
condition|)
name|error_no_arg
argument_list|(
literal|"expression to compute"
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|free_funcalls
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|funcall_chain
operator|=
literal|0
expr_stmt|;
name|expression_context_block
operator|=
name|block
condition|?
name|block
else|:
name|get_selected_block
argument_list|()
expr_stmt|;
name|namecopy
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|lexptr
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|expout_size
operator|=
literal|10
expr_stmt|;
name|expout_ptr
operator|=
literal|0
expr_stmt|;
name|expout
operator|=
operator|(
expr|struct
name|expression
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|expression
argument_list|)
operator|+
name|EXP_ELEM_TO_BYTES
argument_list|(
name|expout_size
argument_list|)
argument_list|)
expr_stmt|;
name|expout
operator|->
name|language_defn
operator|=
name|current_language
expr_stmt|;
name|make_cleanup
argument_list|(
name|free_current_contents
argument_list|,
operator|&
name|expout
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_language
operator|->
name|la_parser
argument_list|()
condition|)
name|current_language
operator|->
name|la_error
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|discard_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
comment|/* Record the actual number of expression elements, and then      reallocate the expression memory so that we free up any      excess elements. */
name|expout
operator|->
name|nelts
operator|=
name|expout_ptr
expr_stmt|;
name|expout
operator|=
operator|(
expr|struct
name|expression
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|expout
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|expression
argument_list|)
operator|+
name|EXP_ELEM_TO_BYTES
argument_list|(
name|expout_ptr
argument_list|)
argument_list|)
expr_stmt|;
empty_stmt|;
comment|/* Convert expression from postfix form as generated by yacc      parser, to a prefix form. */
name|DUMP_EXPRESSION
argument_list|(
name|expout
argument_list|,
name|stdout
argument_list|,
literal|"before conversion to prefix form"
argument_list|)
expr_stmt|;
name|prefixify_expression
argument_list|(
name|expout
argument_list|)
expr_stmt|;
name|DUMP_EXPRESSION
argument_list|(
name|expout
argument_list|,
name|stdout
argument_list|,
literal|"after conversion to prefix form"
argument_list|)
expr_stmt|;
operator|*
name|stringptr
operator|=
name|lexptr
expr_stmt|;
return|return
name|expout
return|;
block|}
end_function

begin_comment
comment|/* Parse STRING as an expression, and complain if this fails    to use up all of the contents of STRING.  */
end_comment

begin_function
name|struct
name|expression
modifier|*
name|parse_expression
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
specifier|register
name|struct
name|expression
modifier|*
name|exp
decl_stmt|;
name|exp
operator|=
name|parse_exp_1
argument_list|(
operator|&
name|string
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|string
condition|)
name|error
argument_list|(
literal|"Junk after end of expression."
argument_list|)
expr_stmt|;
return|return
name|exp
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Stuff for maintaining a stack of types.  Currently just used by C, but    probably useful for any language which declares its types "backwards".  */
end_comment

begin_function
name|void
name|push_type
parameter_list|(
name|tp
parameter_list|)
name|enum
name|type_pieces
name|tp
decl_stmt|;
block|{
if|if
condition|(
name|type_stack_depth
operator|==
name|type_stack_size
condition|)
block|{
name|type_stack_size
operator|*=
literal|2
expr_stmt|;
name|type_stack
operator|=
operator|(
expr|union
name|type_stack_elt
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|type_stack
argument_list|,
name|type_stack_size
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|type_stack
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|type_stack
index|[
name|type_stack_depth
operator|++
index|]
operator|.
name|piece
operator|=
name|tp
expr_stmt|;
block|}
end_function

begin_function
name|void
name|push_type_int
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
if|if
condition|(
name|type_stack_depth
operator|==
name|type_stack_size
condition|)
block|{
name|type_stack_size
operator|*=
literal|2
expr_stmt|;
name|type_stack
operator|=
operator|(
expr|union
name|type_stack_elt
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|type_stack
argument_list|,
name|type_stack_size
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|type_stack
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|type_stack
index|[
name|type_stack_depth
operator|++
index|]
operator|.
name|int_val
operator|=
name|n
expr_stmt|;
block|}
end_function

begin_function
name|enum
name|type_pieces
name|pop_type
parameter_list|()
block|{
if|if
condition|(
name|type_stack_depth
condition|)
return|return
name|type_stack
index|[
operator|--
name|type_stack_depth
index|]
operator|.
name|piece
return|;
return|return
name|tp_end
return|;
block|}
end_function

begin_function
name|int
name|pop_type_int
parameter_list|()
block|{
if|if
condition|(
name|type_stack_depth
condition|)
return|return
name|type_stack
index|[
operator|--
name|type_stack_depth
index|]
operator|.
name|int_val
return|;
comment|/* "Can't happen".  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Pop the type stack and return the type which corresponds to FOLLOW_TYPE    as modified by all the stuff on the stack.  */
end_comment

begin_function
name|struct
name|type
modifier|*
name|follow_types
parameter_list|(
name|follow_type
parameter_list|)
name|struct
name|type
modifier|*
name|follow_type
decl_stmt|;
block|{
name|int
name|done
init|=
literal|0
decl_stmt|;
name|int
name|array_size
decl_stmt|;
name|struct
name|type
modifier|*
name|range_type
decl_stmt|;
while|while
condition|(
operator|!
name|done
condition|)
switch|switch
condition|(
name|pop_type
argument_list|()
condition|)
block|{
case|case
name|tp_end
case|:
name|done
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|tp_pointer
case|:
name|follow_type
operator|=
name|lookup_pointer_type
argument_list|(
name|follow_type
argument_list|)
expr_stmt|;
break|break;
case|case
name|tp_reference
case|:
name|follow_type
operator|=
name|lookup_reference_type
argument_list|(
name|follow_type
argument_list|)
expr_stmt|;
break|break;
case|case
name|tp_array
case|:
name|array_size
operator|=
name|pop_type_int
argument_list|()
expr_stmt|;
if|if
condition|(
name|array_size
operator|!=
operator|-
literal|1
condition|)
block|{
name|range_type
operator|=
name|create_range_type
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|)
name|NULL
argument_list|,
name|builtin_type_int
argument_list|,
literal|0
argument_list|,
name|array_size
operator|-
literal|1
argument_list|)
expr_stmt|;
name|follow_type
operator|=
name|create_array_type
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|)
name|NULL
argument_list|,
name|follow_type
argument_list|,
name|range_type
argument_list|)
expr_stmt|;
block|}
else|else
name|follow_type
operator|=
name|lookup_pointer_type
argument_list|(
name|follow_type
argument_list|)
expr_stmt|;
break|break;
case|case
name|tp_function
case|:
name|follow_type
operator|=
name|lookup_function_type
argument_list|(
name|follow_type
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|follow_type
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|_initialize_parse
parameter_list|()
block|{
name|type_stack_size
operator|=
literal|80
expr_stmt|;
name|type_stack_depth
operator|=
literal|0
expr_stmt|;
name|type_stack
operator|=
operator|(
expr|union
name|type_stack_elt
operator|*
operator|)
name|xmalloc
argument_list|(
name|type_stack_size
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|type_stack
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

