begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Extended support for using signal values.    Copyright (C) 1992 Free Software Foundation, Inc.    Written by Fred Fish.  fnf@cygnus.com  This file is part of the libiberty library. Libiberty is free software; you can redistribute it and/or modify it under the terms of the GNU Library General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  Libiberty is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for more details.  You should have received a copy of the GNU Library General Public License along with libiberty; see the file COPYING.LIB.  If not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|<ansidecl.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|LOSING_SYS_SIGLIST
end_ifdef

begin_define
define|#
directive|define
name|sys_siglist
value|no_such_symbol
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_comment
comment|/*  Routines imported from standard C runtime libraries. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_function_decl
specifier|extern
name|void
modifier|*
name|malloc
parameter_list|(
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* 4.10.3.3 */
end_comment

begin_function_decl
specifier|extern
name|void
modifier|*
name|memset
parameter_list|(
name|void
modifier|*
name|s
parameter_list|,
name|int
name|c
parameter_list|,
name|size_t
name|n
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* 4.11.6.1 */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !__STDC__ */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|const
end_ifndef

begin_define
define|#
directive|define
name|const
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|extern
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Standard memory allocater */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|memset
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __STDC__ */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|LOSING_SYS_SIGLIST
end_ifdef

begin_undef
undef|#
directive|undef
name|sys_siglist
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NULL
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_define
define|#
directive|define
name|NULL
value|(void *) 0
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NULL
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MAX
end_ifndef

begin_define
define|#
directive|define
name|MAX
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)> (b) ? (a) : (b))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Translation table for signal values.     Note that this table is generally only accessed when it is used at runtime    to initialize signal name and message tables that are indexed by signal    value.     Not all of these signals will exist on all systems.  This table is the only    thing that should have to be updated as new signal numbers are introduced.    It's sort of ugly, but at least its portable. */
end_comment

begin_struct
struct|struct
name|signal_info
block|{
name|int
name|value
decl_stmt|;
comment|/* The numeric value from<signal.h> */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* The equivalent symbolic value */
name|char
modifier|*
name|msg
decl_stmt|;
comment|/* Short message about this value */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|signal_info
name|signal_table
index|[]
init|=
block|{
if|#
directive|if
name|defined
argument_list|(
name|SIGHUP
argument_list|)
block|{
name|SIGHUP
block|,
literal|"SIGHUP"
block|,
literal|"Hangup"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGINT
argument_list|)
block|{
name|SIGINT
block|,
literal|"SIGINT"
block|,
literal|"Interrupt"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGQUIT
argument_list|)
block|{
name|SIGQUIT
block|,
literal|"SIGQUIT"
block|,
literal|"Quit"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGILL
argument_list|)
block|{
name|SIGILL
block|,
literal|"SIGILL"
block|,
literal|"Illegal instruction"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGTRAP
argument_list|)
block|{
name|SIGTRAP
block|,
literal|"SIGTRAP"
block|,
literal|"Trace/breakpoint trap"
block|}
block|,
endif|#
directive|endif
comment|/* Put SIGIOT before SIGABRT, so that if SIGIOT==SIGABRT then SIGABRT    overrides SIGIOT.  SIGABRT is in ANSI and POSIX.1, and SIGIOT isn't. */
if|#
directive|if
name|defined
argument_list|(
name|SIGIOT
argument_list|)
block|{
name|SIGIOT
block|,
literal|"SIGIOT"
block|,
literal|"IOT trap"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGABRT
argument_list|)
block|{
name|SIGABRT
block|,
literal|"SIGABRT"
block|,
literal|"Aborted"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGEMT
argument_list|)
block|{
name|SIGEMT
block|,
literal|"SIGEMT"
block|,
literal|"Emulation trap"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGFPE
argument_list|)
block|{
name|SIGFPE
block|,
literal|"SIGFPE"
block|,
literal|"Arithmetic exception"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGKILL
argument_list|)
block|{
name|SIGKILL
block|,
literal|"SIGKILL"
block|,
literal|"Killed"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGBUS
argument_list|)
block|{
name|SIGBUS
block|,
literal|"SIGBUS"
block|,
literal|"Bus error"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGSEGV
argument_list|)
block|{
name|SIGSEGV
block|,
literal|"SIGSEGV"
block|,
literal|"Segmentation fault"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGSYS
argument_list|)
block|{
name|SIGSYS
block|,
literal|"SIGSYS"
block|,
literal|"Bad system call"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGPIPE
argument_list|)
block|{
name|SIGPIPE
block|,
literal|"SIGPIPE"
block|,
literal|"Broken pipe"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGALRM
argument_list|)
block|{
name|SIGALRM
block|,
literal|"SIGALRM"
block|,
literal|"Alarm clock"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGTERM
argument_list|)
block|{
name|SIGTERM
block|,
literal|"SIGTERM"
block|,
literal|"Terminated"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGUSR1
argument_list|)
block|{
name|SIGUSR1
block|,
literal|"SIGUSR1"
block|,
literal|"User defined signal 1"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGUSR2
argument_list|)
block|{
name|SIGUSR2
block|,
literal|"SIGUSR2"
block|,
literal|"User defined signal 2"
block|}
block|,
endif|#
directive|endif
comment|/* Put SIGCLD before SIGCHLD, so that if SIGCLD==SIGCHLD then SIGCHLD    overrides SIGCLD.  SIGCHLD is in POXIX.1 */
if|#
directive|if
name|defined
argument_list|(
name|SIGCLD
argument_list|)
block|{
name|SIGCLD
block|,
literal|"SIGCLD"
block|,
literal|"Child status changed"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGCHLD
argument_list|)
block|{
name|SIGCHLD
block|,
literal|"SIGCHLD"
block|,
literal|"Child status changed"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGPWR
argument_list|)
block|{
name|SIGPWR
block|,
literal|"SIGPWR"
block|,
literal|"Power fail/restart"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGWINCH
argument_list|)
block|{
name|SIGWINCH
block|,
literal|"SIGWINCH"
block|,
literal|"Window size changed"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGURG
argument_list|)
block|{
name|SIGURG
block|,
literal|"SIGURG"
block|,
literal|"Urgent I/O condition"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGIO
argument_list|)
comment|/* "I/O pending" has also been suggested, but is misleading since the      signal only happens when the process has asked for it, not everytime      I/O is pending. */
block|{
name|SIGIO
block|,
literal|"SIGIO"
block|,
literal|"I/O possible"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGPOLL
argument_list|)
block|{
name|SIGPOLL
block|,
literal|"SIGPOLL"
block|,
literal|"Pollable event occurred"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGSTOP
argument_list|)
block|{
name|SIGSTOP
block|,
literal|"SIGSTOP"
block|,
literal|"Stopped (signal)"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGTSTP
argument_list|)
block|{
name|SIGTSTP
block|,
literal|"SIGTSTP"
block|,
literal|"Stopped (user)"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGCONT
argument_list|)
block|{
name|SIGCONT
block|,
literal|"SIGCONT"
block|,
literal|"Continued"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGTTIN
argument_list|)
block|{
name|SIGTTIN
block|,
literal|"SIGTTIN"
block|,
literal|"Stopped (tty input)"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGTTOU
argument_list|)
block|{
name|SIGTTOU
block|,
literal|"SIGTTOU"
block|,
literal|"Stopped (tty output)"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGVTALRM
argument_list|)
block|{
name|SIGVTALRM
block|,
literal|"SIGVTALRM"
block|,
literal|"Virtual timer expired"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGPROF
argument_list|)
block|{
name|SIGPROF
block|,
literal|"SIGPROF"
block|,
literal|"Profiling timer expired"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGXCPU
argument_list|)
block|{
name|SIGXCPU
block|,
literal|"SIGXCPU"
block|,
literal|"CPU time limit exceeded"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGXFSZ
argument_list|)
block|{
name|SIGXFSZ
block|,
literal|"SIGXFSZ"
block|,
literal|"File size limit exceeded"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGWIND
argument_list|)
block|{
name|SIGWIND
block|,
literal|"SIGWIND"
block|,
literal|"SIGWIND"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGPHONE
argument_list|)
block|{
name|SIGPHONE
block|,
literal|"SIGPHONE"
block|,
literal|"SIGPHONE"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGLOST
argument_list|)
block|{
name|SIGLOST
block|,
literal|"SIGLOST"
block|,
literal|"Resource lost"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGWAITING
argument_list|)
block|{
name|SIGWAITING
block|,
literal|"SIGWAITING"
block|,
literal|"Process's LWPs are blocked"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGLWP
argument_list|)
block|{
name|SIGLWP
block|,
literal|"SIGLWP"
block|,
literal|"Signal LWP"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGDANGER
argument_list|)
block|{
name|SIGDANGER
block|,
literal|"SIGDANGER"
block|,
literal|"Swap space dangerously low"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGGRANT
argument_list|)
block|{
name|SIGGRANT
block|,
literal|"SIGGRANT"
block|,
literal|"Monitor mode granted"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGRETRACT
argument_list|)
block|{
name|SIGRETRACT
block|,
literal|"SIGRETRACT"
block|,
literal|"Need to relinguish monitor mode"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGMSG
argument_list|)
block|{
name|SIGMSG
block|,
literal|"SIGMSG"
block|,
literal|"Monitor mode data available"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGSOUND
argument_list|)
block|{
name|SIGSOUND
block|,
literal|"SIGSOUND"
block|,
literal|"Sound completed"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGSAK
argument_list|)
block|{
name|SIGSAK
block|,
literal|"SIGSAK"
block|,
literal|"Secure attention"
block|}
block|,
endif|#
directive|endif
block|{
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Translation table allocated and initialized at runtime.  Indexed by the    signal value to find the equivalent symbolic value. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|signal_names
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|num_signal_names
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Translation table allocated and initialized at runtime, if it does not    already exist in the host environment.  Indexed by the signal value to find    the descriptive string.     We don't export it for use in other modules because even though it has the    same name, it differs from other implementations in that it is dynamically    initialized rather than statically initialized. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NEED_sys_siglist
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|sys_nsig
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|sys_siglist
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|int
name|sys_nsig
init|=
name|NSIG
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
specifier|const
name|char
modifier|*
specifier|const
name|sys_siglist
index|[]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  NAME  	init_signal_tables -- initialize the name and message tables  SYNOPSIS  	static void init_signal_tables ();  DESCRIPTION  	Using the signal_table, which is initialized at compile time, generate 	the signal_names and the sys_siglist (if needed) tables, which are 	indexed at runtime by a specific signal value.  BUGS  	The initialization of the tables may fail under low memory conditions, 	in which case we don't do anything particularly useful, but we don't 	bomb either.  Who knows, it might succeed at a later point if we free 	some memory in the meantime.  In any case, the other routines know 	how to deal with lack of a table after trying to initialize it.  This 	may or may not be considered to be a bug, that we don't specifically 	warn about this particular failure mode.  */
end_comment

begin_function
specifier|static
name|void
name|init_signal_tables
parameter_list|()
block|{
specifier|const
name|struct
name|signal_info
modifier|*
name|eip
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
comment|/* If we haven't already scanned the signal_table once to find the maximum      signal value, then go find it now. */
if|if
condition|(
name|num_signal_names
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|eip
operator|=
name|signal_table
init|;
name|eip
operator|->
name|name
operator|!=
name|NULL
condition|;
name|eip
operator|++
control|)
block|{
if|if
condition|(
name|eip
operator|->
name|value
operator|>=
name|num_signal_names
condition|)
block|{
name|num_signal_names
operator|=
name|eip
operator|->
name|value
operator|+
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/* Now attempt to allocate the signal_names table, zero it out, and then      initialize it from the statically initialized signal_table. */
if|if
condition|(
name|signal_names
operator|==
name|NULL
condition|)
block|{
name|nbytes
operator|=
name|num_signal_names
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|signal_names
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|nbytes
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|memset
argument_list|(
name|signal_names
argument_list|,
literal|0
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
for|for
control|(
name|eip
operator|=
name|signal_table
init|;
name|eip
operator|->
name|name
operator|!=
name|NULL
condition|;
name|eip
operator|++
control|)
block|{
name|signal_names
index|[
name|eip
operator|->
name|value
index|]
operator|=
name|eip
operator|->
name|name
expr_stmt|;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|NEED_sys_siglist
comment|/* Now attempt to allocate the sys_siglist table, zero it out, and then      initialize it from the statically initialized signal_table. */
if|if
condition|(
name|sys_siglist
operator|==
name|NULL
condition|)
block|{
name|nbytes
operator|=
name|num_signal_names
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sys_siglist
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|nbytes
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|memset
argument_list|(
name|sys_siglist
argument_list|,
literal|0
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
name|sys_nsig
operator|=
name|num_signal_names
expr_stmt|;
for|for
control|(
name|eip
operator|=
name|signal_table
init|;
name|eip
operator|->
name|name
operator|!=
name|NULL
condition|;
name|eip
operator|++
control|)
block|{
name|sys_siglist
index|[
name|eip
operator|->
name|value
index|]
operator|=
name|eip
operator|->
name|msg
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  NAME  	signo_max -- return the max signo value  SYNOPSIS  	int signo_max ();  DESCRIPTION  	Returns the maximum signo value for which a corresponding symbolic 	name or message is available.  Note that in the case where 	we use the sys_siglist supplied by the system, it is possible for 	there to be more symbolic names than messages, or vice versa. 	In fact, the manual page for psignal(3b) explicitly warns that one 	should check the size of the table (NSIG) before indexing it, 	since new signal codes may be added to the system before they are 	added to the table.  Thus NSIG might be smaller than value 	implied by the largest signo value defined in<signal.h>.  	We return the maximum value that can be used to obtain a meaningful 	symbolic name or message.  */
end_comment

begin_function
name|int
name|signo_max
parameter_list|()
block|{
name|int
name|maxsize
decl_stmt|;
if|if
condition|(
name|signal_names
operator|==
name|NULL
condition|)
block|{
name|init_signal_tables
argument_list|()
expr_stmt|;
block|}
name|maxsize
operator|=
name|MAX
argument_list|(
name|sys_nsig
argument_list|,
name|num_signal_names
argument_list|)
expr_stmt|;
return|return
operator|(
name|maxsize
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  NAME  	strsignal -- map a signal number to a signal message string  SYNOPSIS  	char *strsignal (int signo)  DESCRIPTION  	Maps an signal number to an signal message string, the contents of 	which are implementation defined.  On systems which have the external 	variable sys_siglist, these strings will be the same as the ones used 	by psignal().  	If the supplied signal number is within the valid range of indices 	for the sys_siglist, but no message is available for the particular 	signal number, then returns the string "Signal NUM", where NUM is the 	signal number.  	If the supplied signal number is not a valid index into sys_siglist, 	returns NULL.  	The returned string is only guaranteed to be valid only until the 	next call to strsignal.  */
end_comment

begin_function
name|char
modifier|*
name|strsignal
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
name|char
modifier|*
name|msg
decl_stmt|;
specifier|static
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|NEED_sys_siglist
if|if
condition|(
name|signal_names
operator|==
name|NULL
condition|)
block|{
name|init_signal_tables
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|signo
operator|<
literal|0
operator|)
operator|||
operator|(
name|signo
operator|>=
name|sys_nsig
operator|)
condition|)
block|{
comment|/* Out of range, just return NULL */
name|msg
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|sys_siglist
operator|==
name|NULL
operator|)
operator|||
operator|(
name|sys_siglist
index|[
name|signo
index|]
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* In range, but no sys_siglist or no entry at this index. */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"Signal %d"
argument_list|,
name|signo
argument_list|)
expr_stmt|;
name|msg
operator|=
name|buf
expr_stmt|;
block|}
else|else
block|{
comment|/* In range, and a valid message.  Just return the message. */
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
name|sys_siglist
index|[
name|signo
index|]
expr_stmt|;
block|}
return|return
operator|(
name|msg
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  NAME  	strsigno -- map an signal number to a symbolic name string  SYNOPSIS  	char *strsigno (int signo)  DESCRIPTION  	Given an signal number, returns a pointer to a string containing 	the symbolic name of that signal number, as found in<signal.h>.  	If the supplied signal number is within the valid range of indices 	for symbolic names, but no name is available for the particular 	signal number, then returns the string "Signal NUM", where NUM is 	the signal number.  	If the supplied signal number is not within the range of valid 	indices, then returns NULL.  BUGS  	The contents of the location pointed to are only guaranteed to be 	valid until the next call to strsigno.  */
end_comment

begin_function
name|char
modifier|*
name|strsigno
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
specifier|static
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
if|if
condition|(
name|signal_names
operator|==
name|NULL
condition|)
block|{
name|init_signal_tables
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|signo
operator|<
literal|0
operator|)
operator|||
operator|(
name|signo
operator|>=
name|num_signal_names
operator|)
condition|)
block|{
comment|/* Out of range, just return NULL */
name|name
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|signal_names
operator|==
name|NULL
operator|)
operator|||
operator|(
name|signal_names
index|[
name|signo
index|]
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* In range, but no signal_names or no entry at this index. */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"Signal %d"
argument_list|,
name|signo
argument_list|)
expr_stmt|;
name|name
operator|=
name|buf
expr_stmt|;
block|}
else|else
block|{
comment|/* In range, and a valid name.  Just return the name. */
name|name
operator|=
name|signal_names
index|[
name|signo
index|]
expr_stmt|;
block|}
return|return
operator|(
name|name
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  NAME  	strtosigno -- map a symbolic signal name to a numeric value  SYNOPSIS  	int strtosigno (char *name)  DESCRIPTION  	Given the symbolic name of a signal, map it to a signal number. 	If no translation is found, returns 0.  */
end_comment

begin_function
name|int
name|strtosigno
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|signo
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|signal_names
operator|==
name|NULL
condition|)
block|{
name|init_signal_tables
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|signo
operator|=
literal|0
init|;
name|signo
operator|<
name|num_signal_names
condition|;
name|signo
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|signal_names
index|[
name|signo
index|]
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|signal_names
index|[
name|signo
index|]
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|signo
operator|==
name|num_signal_names
condition|)
block|{
name|signo
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
operator|(
name|signo
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  NAME  	psignal -- print message about signal to stderr  SYNOPSIS  	void psignal (unsigned signo, char *message);  DESCRIPTION  	Print to the standard error the message, followed by a colon, 	followed by the description of the signal specified by signo, 	followed by a newline. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NEED_psignal
end_ifdef

begin_function
name|void
name|psignal
parameter_list|(
name|signo
parameter_list|,
name|message
parameter_list|)
name|unsigned
name|signo
decl_stmt|;
name|char
modifier|*
name|message
decl_stmt|;
block|{
if|if
condition|(
name|signal_names
operator|==
name|NULL
condition|)
block|{
name|init_signal_tables
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|signo
operator|<=
literal|0
operator|)
operator|||
operator|(
name|signo
operator|>=
name|sys_nsig
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: unknown signal\n"
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|message
argument_list|,
name|sys_siglist
index|[
name|signo
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NEED_psignal */
end_comment

begin_comment
comment|/* A simple little main that does nothing but print all the signal translations    if MAIN is defined and this file is compiled and linked. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MAIN
end_ifdef

begin_function
name|main
parameter_list|()
block|{
name|int
name|signo
decl_stmt|;
name|int
name|maxsigno
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
name|char
modifier|*
name|strsigno
parameter_list|()
function_decl|;
name|char
modifier|*
name|strsignal
parameter_list|()
function_decl|;
name|maxsigno
operator|=
name|signo_max
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"%d entries in names table.\n"
argument_list|,
name|num_signal_names
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d entries in messages table.\n"
argument_list|,
name|sys_nsig
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d is max useful index.\n"
argument_list|,
name|maxsigno
argument_list|)
expr_stmt|;
comment|/* Keep printing values until we get to the end of *both* tables, not      *either* table.  Note that knowing the maximum useful index does *not*      relieve us of the responsibility of testing the return pointer for      NULL. */
for|for
control|(
name|signo
operator|=
literal|0
init|;
name|signo
operator|<=
name|maxsigno
condition|;
name|signo
operator|++
control|)
block|{
name|name
operator|=
name|strsigno
argument_list|(
name|signo
argument_list|)
expr_stmt|;
name|name
operator|=
operator|(
name|name
operator|==
name|NULL
operator|)
condition|?
literal|"<NULL>"
else|:
name|name
expr_stmt|;
name|msg
operator|=
name|strsignal
argument_list|(
name|signo
argument_list|)
expr_stmt|;
name|msg
operator|=
operator|(
name|msg
operator|==
name|NULL
operator|)
condition|?
literal|"<NULL>"
else|:
name|msg
expr_stmt|;
name|printf
argument_list|(
literal|"%-4d%-18s%s\n"
argument_list|,
name|signo
argument_list|,
name|name
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

