begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* IEEE floating point support routines, for GDB, the GNU Debugger.    Copyright (C) 1991 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"ieee-float.h"
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_comment
comment|/* ldexp */
end_comment

begin_comment
comment|/* Convert an IEEE extended float to a double.    FROM is the address of the extended float.    Store the double in *TO.  */
end_comment

begin_function
name|void
name|ieee_extended_to_double
parameter_list|(
name|ext_format
parameter_list|,
name|from
parameter_list|,
name|to
parameter_list|)
name|CONST
name|struct
name|ext_format
modifier|*
name|ext_format
decl_stmt|;
name|char
modifier|*
name|from
decl_stmt|;
name|double
modifier|*
name|to
decl_stmt|;
block|{
name|unsigned
name|char
modifier|*
name|ufrom
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|from
decl_stmt|;
name|double
name|dto
decl_stmt|;
name|unsigned
name|long
name|mant0
decl_stmt|,
name|mant1
decl_stmt|,
name|exponent
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|mant0
argument_list|,
operator|&
name|from
index|[
name|MANBYTE_H
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|mant1
argument_list|,
operator|&
name|from
index|[
name|MANBYTE_L
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|exponent
operator|=
operator|(
operator|(
name|ufrom
index|[
name|EXPBYTE_H
index|]
operator|&
operator|(
name|unsigned
name|char
operator|)
operator|~
name|SIGNMASK
operator|)
operator|<<
literal|8
operator|)
operator||
name|ufrom
index|[
name|EXPBYTE_L
index|]
expr_stmt|;
if|#
directive|if
literal|0
comment|/* We can't do anything useful with a NaN anyway, so ignore its      difference.  It will end up as Infinity or something close.  */
block|if (exponent == EXT_EXP_NAN) {
comment|/* We have a NaN source.  */
block|dto = 0.123456789;
comment|/* Not much else useful to do -- we don't know if  			   the host system even *has* NaNs, nor how to 			   generate an innocuous one if it does.  */
block|} else
endif|#
directive|endif
if|if
condition|(
name|exponent
operator|==
literal|0
operator|&&
name|mant0
operator|==
literal|0
operator|&&
name|mant1
operator|==
literal|0
condition|)
block|{
name|dto
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Build the result algebraically.  Might go infinite, underflow, etc;        who cares. */
name|mant0
operator||=
literal|0x80000000
expr_stmt|;
name|dto
operator|=
name|ldexp
argument_list|(
operator|(
name|double
operator|)
name|mant0
argument_list|,
name|exponent
operator|-
name|EXT_EXP_BIAS
operator|-
literal|31
argument_list|)
expr_stmt|;
name|dto
operator|+=
name|ldexp
argument_list|(
operator|(
name|double
operator|)
name|mant1
argument_list|,
name|exponent
operator|-
name|EXT_EXP_BIAS
operator|-
literal|31
operator|-
literal|32
argument_list|)
expr_stmt|;
if|if
condition|(
name|ufrom
index|[
name|EXPBYTE_H
index|]
operator|&
name|SIGNMASK
condition|)
comment|/* If negative... */
name|dto
operator|=
operator|-
name|dto
expr_stmt|;
comment|/* ...negate.  */
block|}
name|memcpy
argument_list|(
name|to
argument_list|,
operator|&
name|dto
argument_list|,
sizeof|sizeof
argument_list|(
name|dto
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The converse: convert the double *FROM to an extended float    and store where TO points.  Neither FROM nor TO have any alignment    restrictions.  */
end_comment

begin_function
name|void
name|double_to_ieee_extended
parameter_list|(
name|ext_format
parameter_list|,
name|from
parameter_list|,
name|to
parameter_list|)
name|CONST
name|struct
name|ext_format
modifier|*
name|ext_format
decl_stmt|;
name|double
modifier|*
name|from
decl_stmt|;
name|char
modifier|*
name|to
decl_stmt|;
block|{
name|double
name|dfrom
decl_stmt|;
name|unsigned
name|long
name|twolongs
index|[
literal|2
index|]
decl_stmt|;
name|unsigned
name|long
name|mant0
decl_stmt|,
name|mant1
decl_stmt|,
name|exponent
decl_stmt|;
name|unsigned
name|char
name|tobytes
index|[
literal|8
index|]
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|dfrom
argument_list|,
name|from
argument_list|,
sizeof|sizeof
argument_list|(
name|dfrom
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|to
argument_list|,
literal|0
argument_list|,
name|TOTALSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|dfrom
operator|==
literal|0
condition|)
return|return;
comment|/* Result is zero */
if|if
condition|(
name|dfrom
operator|!=
name|dfrom
condition|)
block|{
comment|/* From is NaN */
name|to
index|[
name|EXPBYTE_H
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|EXT_EXP_NAN
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|to
index|[
name|EXPBYTE_L
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|EXT_EXP_NAN
expr_stmt|;
name|to
index|[
name|MANBYTE_H
index|]
operator|=
literal|1
expr_stmt|;
comment|/* Be sure it's not infinity, but NaN value is irrel */
return|return;
comment|/* Result is NaN */
block|}
if|if
condition|(
name|dfrom
operator|<
literal|0
condition|)
name|to
index|[
name|SIGNBYTE
index|]
operator||=
name|SIGNMASK
expr_stmt|;
comment|/* Set negative sign */
comment|/* How to tell an infinity from an ordinary number?  FIXME-someday */
comment|/* The following code assumes that the host has IEEE doubles.  FIXME-someday.      It also assumes longs are 32 bits!  FIXME-someday.  */
name|memcpy
argument_list|(
name|twolongs
argument_list|,
name|from
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|tobytes
argument_list|,
name|from
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|#
directive|if
name|HOST_BYTE_ORDER
operator|==
name|BIG_ENDIAN
name|exponent
operator|=
operator|(
operator|(
name|tobytes
index|[
literal|1
index|]
operator|&
literal|0xF0
operator|)
operator|>>
literal|4
operator|)
operator||
operator|(
name|tobytes
index|[
literal|0
index|]
operator|&
literal|0x7F
operator|)
operator|<<
literal|4
expr_stmt|;
name|mant0
operator|=
operator|(
name|twolongs
index|[
literal|0
index|]
operator|<<
literal|11
operator|)
operator||
name|twolongs
index|[
literal|1
index|]
operator|>>
literal|21
expr_stmt|;
name|mant1
operator|=
operator|(
name|twolongs
index|[
literal|1
index|]
operator|<<
literal|11
operator|)
expr_stmt|;
else|#
directive|else
name|exponent
operator|=
operator|(
operator|(
name|tobytes
index|[
literal|6
index|]
operator|&
literal|0xF0
operator|)
operator|>>
literal|4
operator|)
operator||
operator|(
name|tobytes
index|[
literal|7
index|]
operator|&
literal|0x7F
operator|)
operator|<<
literal|4
expr_stmt|;
name|mant0
operator|=
operator|(
name|twolongs
index|[
literal|1
index|]
operator|<<
literal|11
operator|)
operator||
name|twolongs
index|[
literal|0
index|]
operator|>>
literal|21
expr_stmt|;
name|mant1
operator|=
operator|(
name|twolongs
index|[
literal|0
index|]
operator|<<
literal|11
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* Fiddle with leading 1-bit, implied in double, explicit in extended. */
if|if
condition|(
name|exponent
operator|==
literal|0
condition|)
name|mant0
operator|&=
literal|0x7FFFFFFF
expr_stmt|;
else|else
name|mant0
operator||=
literal|0x80000000
expr_stmt|;
name|exponent
operator|-=
name|DBL_EXP_BIAS
expr_stmt|;
comment|/* Get integer exp */
name|exponent
operator|+=
name|EXT_EXP_BIAS
expr_stmt|;
comment|/* Offset for extended */
comment|/* OK, now store it in extended format. */
name|to
index|[
name|EXPBYTE_H
index|]
operator||=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|exponent
operator|>>
literal|8
argument_list|)
expr_stmt|;
comment|/* Retain sign */
name|to
index|[
name|EXPBYTE_L
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|exponent
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|to
index|[
name|MANBYTE_H
index|]
argument_list|,
operator|&
name|mant0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|to
index|[
name|MANBYTE_L
index|]
argument_list|,
operator|&
name|mant1
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE_DEBUG
end_ifdef

begin_comment
comment|/* Test some numbers to see that extended/double conversion works for them.  */
end_comment

begin_macro
name|ieee_test
argument_list|(
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
union|union
block|{
name|double
name|d
decl_stmt|;
name|int
name|i
index|[
literal|2
index|]
decl_stmt|;
block|}
name|di
union|;
name|double
name|result
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
name|exten
index|[
literal|16
index|]
decl_stmt|;
specifier|extern
name|struct
name|ext_format
name|ext_format_68881
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|di
operator|.
name|i
index|[
literal|0
index|]
operator|=
operator|(
name|random
argument_list|()
operator|<<
literal|16
operator|)
operator||
operator|(
name|random
argument_list|()
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|di
operator|.
name|i
index|[
literal|1
index|]
operator|=
operator|(
name|random
argument_list|()
operator|<<
literal|16
operator|)
operator||
operator|(
name|random
argument_list|()
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|double_to_ieee_extended
argument_list|(
operator|&
name|ext_format_68881
argument_list|,
operator|&
name|di
operator|.
name|d
argument_list|,
name|exten
argument_list|)
expr_stmt|;
name|ieee_extended_to_double
argument_list|(
operator|&
name|ext_format_68881
argument_list|,
name|exten
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|di
operator|.
name|d
operator|!=
name|result
condition|)
name|printf
argument_list|(
literal|"Differ: %x %x %g => %x %x %g\n"
argument_list|,
name|di
operator|.
name|d
argument_list|,
name|di
operator|.
name|d
argument_list|,
name|result
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

