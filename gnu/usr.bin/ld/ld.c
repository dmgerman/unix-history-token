begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * This code is derived from software copyrighted by the Free Software  * Foundation.  *  * Modified 1991 by Donn Seeley at UUNET Technologies, Inc.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)ld.c	6.10 (Berkeley) 5/22/91"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/* Linker `ld' for GNU    Copyright (C) 1988 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 1, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* Written by Richard Stallman with some help from Eric Albert.    Set, indirect, and warning symbol features added by Randy Smith.  */
end_comment

begin_comment
comment|/* Define how to initialize system-dependent header fields.  */
end_comment

begin_include
include|#
directive|include
file|<ar.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_include
include|#
directive|include
file|<stab.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|/* symseg.h defines the obsolete GNU debugging format; we should nuke it.  */
end_comment

begin_define
define|#
directive|define
name|CORE_ADDR
value|unsigned long
end_define

begin_comment
comment|/* For symseg.h */
end_comment

begin_include
include|#
directive|include
file|"symseg.h"
end_include

begin_define
define|#
directive|define
name|N_SET_MAGIC
parameter_list|(
name|exec
parameter_list|,
name|val
parameter_list|)
value|((exec).a_magic = val)
end_define

begin_comment
comment|/* If compiled with GNU C, use the built-in alloca */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_define
define|#
directive|define
name|alloca
value|__builtin_alloca
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|min
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)< (b) ? (a) : (b))
end_define

begin_comment
comment|/* Macro to control the number of undefined references printed */
end_comment

begin_define
define|#
directive|define
name|MAX_UREFS_PRINTED
value|10
end_define

begin_comment
comment|/* Size of a page; obtained from the operating system.  */
end_comment

begin_decl_stmt
name|int
name|page_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name this program was invoked by.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* System dependencies */
end_comment

begin_comment
comment|/* Define this to specify the default executable format.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DEFAULT_MAGIC
end_ifndef

begin_define
define|#
directive|define
name|DEFAULT_MAGIC
value|ZMAGIC
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|hp300
end_ifdef

begin_define
define|#
directive|define
name|INITIALIZE_HEADER
value|outheader.a_mid = MID_HP300
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* create screwball format for 386BSD to save space on floppies -wfj */
end_comment

begin_decl_stmt
name|int
name|screwballmode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Ok.  Following are the relocation information macros.  If your  * system should not be able to use the default set (below), you must  * define the following:   *   relocation_info: This must be typedef'd (or #define'd) to the type  * of structure that is stored in the relocation info section of your  * a.out files.  Often this is defined in the a.out.h for your system.  *  *   RELOC_ADDRESS (rval): Offset into the current section of the  *<whatever> to be relocated.  *Must be an lvalue*.  *  *   RELOC_EXTERN_P (rval):  Is this relocation entry based on an  * external symbol (1), or was it fully resolved upon entering the  * loader (0) in which case some combination of the value in memory  * (if RELOC_MEMORY_ADD_P) and the extra (if RELOC_ADD_EXTRA) contains  * what the value of the relocation actually was.  *Must be an lvalue*.  *  *   RELOC_TYPE (rval): If this entry was fully resolved upon  * entering the loader, what type should it be relocated as?  *  *   RELOC_SYMBOL (rval): If this entry was not fully resolved upon  * entering the loader, what is the index of it's symbol in the symbol  * table?  *Must be a lvalue*.  *  *   RELOC_MEMORY_ADD_P (rval): This should return true if the final  * relocation value output here should be added to memory, or if the  * section of memory described should simply be set to the relocation  * value.  *  *   RELOC_ADD_EXTRA (rval): (Optional) This macro, if defined, gives  * an extra value to be added to the relocation value based on the  * individual relocation entry.  *Must be an lvalue if defined*.  *  *   RELOC_PCREL_P (rval): True if the relocation value described is  * pc relative.  *  *   RELOC_VALUE_RIGHTSHIFT (rval): Number of bits right to shift the  * final relocation value before putting it where it belongs.  *  *   RELOC_TARGET_SIZE (rval): log to the base 2 of the number of  * bytes of size this relocation entry describes; 1 byte == 0; 2 bytes  * == 1; 4 bytes == 2, and etc.  This is somewhat redundant (we could  * do everything in terms of the bit operators below), but having this  * macro could end up producing better code on machines without fancy  * bit twiddling.  Also, it's easier to understand/code big/little  * endian distinctions with this macro.  *  *   RELOC_TARGET_BITPOS (rval): The starting bit position within the  * object described in RELOC_TARGET_SIZE in which the relocation value  * will go.  *  *   RELOC_TARGET_BITSIZE (rval): How many bits are to be replaced  * with the bits of the relocation value.  It may be assumed by the  * code that the relocation value will fit into this many bits.  This  * may be larger than RELOC_TARGET_SIZE if such be useful.  *  *  *		Things I haven't implemented  *		----------------------------  *  *    Values for RELOC_TARGET_SIZE other than 0, 1, or 2.  *  *    Pc relative relocation for External references.  *  *  */
end_comment

begin_comment
comment|/* The following #if has been modifed for cross compilation */
end_comment

begin_comment
comment|/* It originally read:  #if defined(sun)&& defined(sparc)  */
end_comment

begin_comment
comment|/* Marc Ullman, Stanford University    Nov. 1 1989  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
operator|&&
operator|(
name|TARGET
operator|==
name|SUN4
operator|)
end_if

begin_comment
comment|/* Sparc (Sun 4) macros */
end_comment

begin_undef
undef|#
directive|undef
name|relocation_info
end_undef

begin_define
define|#
directive|define
name|relocation_info
value|reloc_info_sparc
end_define

begin_define
define|#
directive|define
name|RELOC_ADDRESS
parameter_list|(
name|r
parameter_list|)
value|((r)->r_address)
end_define

begin_define
define|#
directive|define
name|RELOC_EXTERN_P
parameter_list|(
name|r
parameter_list|)
value|((r)->r_extern)
end_define

begin_define
define|#
directive|define
name|RELOC_TYPE
parameter_list|(
name|r
parameter_list|)
value|((r)->r_index)
end_define

begin_define
define|#
directive|define
name|RELOC_SYMBOL
parameter_list|(
name|r
parameter_list|)
value|((r)->r_index)
end_define

begin_define
define|#
directive|define
name|RELOC_MEMORY_SUB_P
parameter_list|(
name|r
parameter_list|)
value|0
end_define

begin_define
define|#
directive|define
name|RELOC_MEMORY_ADD_P
parameter_list|(
name|r
parameter_list|)
value|0
end_define

begin_define
define|#
directive|define
name|RELOC_ADD_EXTRA
parameter_list|(
name|r
parameter_list|)
value|((r)->r_addend)
end_define

begin_define
define|#
directive|define
name|RELOC_PCREL_P
parameter_list|(
name|r
parameter_list|)
define|\
value|((r)->r_type>= RELOC_DISP8&& (r)->r_type<= RELOC_WDISP22)
end_define

begin_define
define|#
directive|define
name|RELOC_VALUE_RIGHTSHIFT
parameter_list|(
name|r
parameter_list|)
value|(reloc_target_rightshift[(r)->r_type])
end_define

begin_define
define|#
directive|define
name|RELOC_TARGET_SIZE
parameter_list|(
name|r
parameter_list|)
value|(reloc_target_size[(r)->r_type])
end_define

begin_define
define|#
directive|define
name|RELOC_TARGET_BITPOS
parameter_list|(
name|r
parameter_list|)
value|0
end_define

begin_define
define|#
directive|define
name|RELOC_TARGET_BITSIZE
parameter_list|(
name|r
parameter_list|)
value|(reloc_target_bitsize[(r)->r_type])
end_define

begin_comment
comment|/* Note that these are very dependent on the order of the enums in    enum reloc_type (in a.out.h); if they change the following must be    changed */
end_comment

begin_comment
comment|/* Also note that the last few may be incorrect; I have no information */
end_comment

begin_decl_stmt
specifier|static
name|int
name|reloc_target_rightshift
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|2
block|,
literal|10
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reloc_target_size
index|[]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reloc_target_bitsize
index|[]
init|=
block|{
literal|8
block|,
literal|16
block|,
literal|32
block|,
literal|8
block|,
literal|16
block|,
literal|32
block|,
literal|30
block|,
literal|22
block|,
literal|22
block|,
literal|22
block|,
literal|13
block|,
literal|10
block|,
literal|32
block|,
literal|32
block|,
literal|16
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MAX_ALIGNMENT
value|(sizeof (double))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Default macros */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|RELOC_ADDRESS
end_ifndef

begin_define
define|#
directive|define
name|RELOC_ADDRESS
parameter_list|(
name|r
parameter_list|)
value|((r)->r_address)
end_define

begin_define
define|#
directive|define
name|RELOC_EXTERN_P
parameter_list|(
name|r
parameter_list|)
value|((r)->r_extern)
end_define

begin_define
define|#
directive|define
name|RELOC_TYPE
parameter_list|(
name|r
parameter_list|)
value|((r)->r_symbolnum)
end_define

begin_define
define|#
directive|define
name|RELOC_SYMBOL
parameter_list|(
name|r
parameter_list|)
value|((r)->r_symbolnum)
end_define

begin_define
define|#
directive|define
name|RELOC_MEMORY_SUB_P
parameter_list|(
name|r
parameter_list|)
value|0
end_define

begin_define
define|#
directive|define
name|RELOC_MEMORY_ADD_P
parameter_list|(
name|r
parameter_list|)
value|1
end_define

begin_undef
undef|#
directive|undef
name|RELOC_ADD_EXTRA
end_undef

begin_define
define|#
directive|define
name|RELOC_PCREL_P
parameter_list|(
name|r
parameter_list|)
value|((r)->r_pcrel)
end_define

begin_define
define|#
directive|define
name|RELOC_VALUE_RIGHTSHIFT
parameter_list|(
name|r
parameter_list|)
value|0
end_define

begin_define
define|#
directive|define
name|RELOC_TARGET_SIZE
parameter_list|(
name|r
parameter_list|)
value|((r)->r_length)
end_define

begin_define
define|#
directive|define
name|RELOC_TARGET_BITPOS
parameter_list|(
name|r
parameter_list|)
value|0
end_define

begin_define
define|#
directive|define
name|RELOC_TARGET_BITSIZE
parameter_list|(
name|r
parameter_list|)
value|32
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MAX_ALIGNMENT
end_ifndef

begin_define
define|#
directive|define
name|MAX_ALIGNMENT
value|(sizeof (int))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|nounderscore
end_ifdef

begin_define
define|#
directive|define
name|LPREFIX
value|'.'
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|LPREFIX
value|'L'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TEXT_START
end_ifndef

begin_define
define|#
directive|define
name|TEXT_START
parameter_list|(
name|x
parameter_list|)
value|N_TXTADDR(x)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Special global symbol types understood by GNU LD.  */
end_comment

begin_comment
comment|/* The following type indicates the definition of a symbol as being    an indirect reference to another symbol.  The other symbol    appears as an undefined reference, immediately following this symbol.     Indirection is asymmetrical.  The other symbol's value will be used    to satisfy requests for the indirect symbol, but not vice versa.    If the other symbol does not have a definition, libraries will    be searched to find a definition.     So, for example, the following two lines placed in an assembler    input file would result in an object file which would direct gnu ld    to resolve all references to symbol "foo" as references to symbol    "bar".  	.stabs "_foo",11,0,0,0 	.stabs "_bar",1,0,0,0     Note that (11 == (N_INDR | N_EXT)) and (1 == (N_UNDF | N_EXT)).  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|N_INDR
end_ifndef

begin_define
define|#
directive|define
name|N_INDR
value|0xa
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The following symbols refer to set elements.  These are expected    only in input to the loader; they should not appear in loader    output (unless relocatable output is requested).  To be recognized    by the loader, the input symbols must have their N_EXT bit set.    All the N_SET[ATDB] symbols with the same name form one set.  The    loader collects all of these elements at load time and outputs a    vector for each name.    Space (an array of 32 bit words) is allocated for the set in the    data section, and the n_value field of each set element value is    stored into one word of the array.    The first word of the array is the length of the set (number of    elements).  The last word of the vector is set to zero for possible    use by incremental loaders.  The array is ordered by the linkage    order; the first symbols which the linker encounters will be first    in the array.     In C syntax this looks like:  	struct set_vector { 	  unsigned int length; 	  unsigned int vector[length]; 	  unsigned int always_zero; 	};     Before being placed into the array, each element is relocated    according to its type.  This allows the loader to create an array    of pointers to objects automatically.  N_SETA type symbols will not    be relocated.     The address of the set is made into an N_SETV symbol    whose name is the same as the name of the set.    This symbol acts like a N_DATA global symbol    in that it can satisfy undefined external references.     For the purposes of determining whether or not to load in a library    file, set element definitions are not considered "real    definitions"; they will not cause the loading of a library    member.     If relocatable output is requested, none of this processing is    done.  The symbols are simply relocated and passed through to the    output file.     So, for example, the following three lines of assembler code    (whether in one file or scattered between several different ones)    will produce a three element vector (total length is five words;    see above), referenced by the symbol "_xyzzy", which will have the    addresses of the routines _init1, _init2, and _init3.     *NOTE*: If symbolic addresses are used in the n_value field of the    defining .stabs, those symbols must be defined in the same file as    that containing the .stabs.  	.stabs "_xyzzy",23,0,0,_init1 	.stabs "_xyzzy",23,0,0,_init2 	.stabs "_xyzzy",23,0,0,_init3     Note that (23 == (N_SETT | N_EXT)).  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|N_SETA
end_ifndef

begin_define
define|#
directive|define
name|N_SETA
value|0x14
end_define

begin_comment
comment|/* Absolute set element symbol */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This is input to LD, in a .o file.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|N_SETT
end_ifndef

begin_define
define|#
directive|define
name|N_SETT
value|0x16
end_define

begin_comment
comment|/* Text set element symbol */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This is input to LD, in a .o file.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|N_SETD
end_ifndef

begin_define
define|#
directive|define
name|N_SETD
value|0x18
end_define

begin_comment
comment|/* Data set element symbol */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This is input to LD, in a .o file.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|N_SETB
end_ifndef

begin_define
define|#
directive|define
name|N_SETB
value|0x1A
end_define

begin_comment
comment|/* Bss set element symbol */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This is input to LD, in a .o file.  */
end_comment

begin_comment
comment|/* Macros dealing with the set element symbols defined in a.out.h */
end_comment

begin_define
define|#
directive|define
name|SET_ELEMENT_P
parameter_list|(
name|x
parameter_list|)
value|((x)>=N_SETA&&(x)<=(N_SETB|N_EXT))
end_define

begin_define
define|#
directive|define
name|TYPE_OF_SET_ELEMENT
parameter_list|(
name|x
parameter_list|)
value|((x)-N_SETA+N_ABS)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|N_SETV
end_ifndef

begin_define
define|#
directive|define
name|N_SETV
value|0x1C
end_define

begin_comment
comment|/* Pointer to set vector in data area.  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This is output from LD.  */
end_comment

begin_comment
comment|/* If a this type of symbol is encountered, its name is a warning    message to print each time the symbol referenced by the next symbol    table entry is referenced.     This feature may be used to allow backwards compatibility with    certain functions (eg. gets) but to discourage programmers from    their use.     So if, for example, you wanted to have ld print a warning whenever    the function "gets" was used in their C program, you would add the    following to the assembler file in which gets is defined:  	.stabs "Obsolete function \"gets\" referenced",30,0,0,0 	.stabs "_gets",1,0,0,0     These .stabs do not necessarily have to be in the same file as the    gets function, they simply must exist somewhere in the compilation.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|N_WARNING
end_ifndef

begin_define
define|#
directive|define
name|N_WARNING
value|0x1E
end_define

begin_comment
comment|/* Warning message to print if symbol 				   included */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This is input to ld */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__GNU_STAB__
end_ifndef

begin_comment
comment|/* Line number for the data section.  This is to be used to describe    the source location of a variable declaration.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|N_DSLINE
end_ifndef

begin_define
define|#
directive|define
name|N_DSLINE
value|(N_SLINE+N_DATA-N_TEXT)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Line number for the bss section.  This is to be used to describe    the source location of a variable declaration.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|N_BSLINE
end_ifndef

begin_define
define|#
directive|define
name|N_BSLINE
value|(N_SLINE+N_BSS-N_TEXT)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not __GNU_STAB__ */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Symbol table */
end_comment

begin_comment
comment|/* Global symbol data is recorded in these structures,    one for each global symbol.    They are found via hashing in 'symtab', which points to a vector of buckets.    Each bucket is a chain of these structures through the link field.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|glosym
block|{
comment|/* Pointer to next symbol in this symbol's hash bucket.  */
name|struct
name|glosym
modifier|*
name|link
decl_stmt|;
comment|/* Name of this symbol.  */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Value of this symbol as a global symbol.  */
name|long
name|value
decl_stmt|;
comment|/* Chain of external 'nlist's in files for this symbol, both defs 	 and refs.  */
name|struct
name|nlist
modifier|*
name|refs
decl_stmt|;
comment|/* Any warning message that might be associated with this symbol          from an N_WARNING symbol encountered. */
name|char
modifier|*
name|warning
decl_stmt|;
comment|/* Nonzero means definitions of this symbol as common have been seen, 	 and the value here is the largest size specified by any of them.  */
name|int
name|max_common_size
decl_stmt|;
comment|/* For relocatable_output, records the index of this global sym in the 	 symbol table to be written, with the first global sym given index 0.*/
name|int
name|def_count
decl_stmt|;
comment|/* Nonzero means a definition of this global symbol is known to exist. 	 Library members should not be loaded on its account.  */
name|char
name|defined
decl_stmt|;
comment|/* Nonzero means a reference to this global symbol has been seen 	 in a file that is surely being loaded. 	 A value higher than 1 is the n_type code for the symbol's 	 definition.  */
name|char
name|referenced
decl_stmt|;
comment|/* A count of the number of undefined references printed for a 	 specific symbol.  If a symbol is unresolved at the end of 	 digest_symbols (and the loading run is supposed to produce 	 relocatable output) do_file_warnings keeps track of how many 	 unresolved reference error messages have been printed for 	 each symbol here.  When the number hits MAX_UREFS_PRINTED, 	 messages stop. */
name|unsigned
name|char
name|undef_refs
decl_stmt|;
comment|/* 1 means that this symbol has multiple definitions.  2 means          that it has multiple definitions, and some of them are set 	 elements, one of which has been printed out already.  */
name|unsigned
name|char
name|multiply_defined
decl_stmt|;
comment|/* Nonzero means print a message at all refs or defs of this symbol */
name|char
name|trace
decl_stmt|;
block|}
name|symbol
typedef|;
end_typedef

begin_comment
comment|/* Demangler for C++. */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|cplus_demangle
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Demangler function to use. */
end_comment

begin_function_decl
name|char
modifier|*
function_decl|(
modifier|*
name|demangler
function_decl|)
parameter_list|()
init|=
name|NULL
function_decl|;
end_function_decl

begin_comment
comment|/* Number of buckets in symbol hash table */
end_comment

begin_define
define|#
directive|define
name|TABSIZE
value|1009
end_define

begin_comment
comment|/* The symbol hash table: a vector of TABSIZE pointers to struct glosym. */
end_comment

begin_decl_stmt
name|symbol
modifier|*
name|symtab
index|[
name|TABSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of symbols in symbol hash table. */
end_comment

begin_decl_stmt
name|int
name|num_hash_tab_syms
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Count the number of nlist entries that are for local symbols.    This count and the three following counts    are incremented as as symbols are entered in the symbol table.  */
end_comment

begin_decl_stmt
name|int
name|local_sym_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Count number of nlist entries that are for local symbols    whose names don't start with L. */
end_comment

begin_decl_stmt
name|int
name|non_L_local_sym_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Count the number of nlist entries for debugger info.  */
end_comment

begin_decl_stmt
name|int
name|debugger_sym_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Count the number of global symbols referenced and not defined.  */
end_comment

begin_decl_stmt
name|int
name|undefined_global_sym_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Count the number of global symbols multiply defined.  */
end_comment

begin_decl_stmt
name|int
name|multiple_def_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Count the number of defined global symbols.    Each symbol is counted only once    regardless of how many different nlist entries refer to it,    since the output file will need only one nlist entry for it.    This count is computed by `digest_symbols';    it is undefined while symbols are being loaded. */
end_comment

begin_decl_stmt
name|int
name|defined_global_sym_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Count the number of symbols defined through common declarations.    This count is kept in symdef_library, linear_library, and    enter_global_ref.  It is incremented when the defined flag is set    in a symbol because of a common definition, and decremented when    the symbol is defined "for real" (ie. by something besides a common    definition).  */
end_comment

begin_decl_stmt
name|int
name|common_defined_global_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Count the number of set element type symbols and the number of    separate vectors which these symbols will fit into.  See the    GNU a.out.h for more info.    This count is computed by 'enter_file_symbols' */
end_comment

begin_decl_stmt
name|int
name|set_symbol_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|set_vector_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Define a linked list of strings which define symbols which should    be treated as set elements even though they aren't.  Any symbol    with a prefix matching one of these should be treated as a set    element.     This is to make up for deficiencies in many assemblers which aren't    willing to pass any stabs through to the loader which they don't    understand.  */
end_comment

begin_struct
struct|struct
name|string_list_element
block|{
name|char
modifier|*
name|str
decl_stmt|;
name|struct
name|string_list_element
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|string_list_element
modifier|*
name|set_element_prefixes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Count the number of definitions done indirectly (ie. done relative    to the value of some other symbol. */
end_comment

begin_decl_stmt
name|int
name|global_indirect_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Count the number of warning symbols encountered. */
end_comment

begin_decl_stmt
name|int
name|warning_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Total number of symbols to be written in the output file.    Computed by digest_symbols from the variables above.  */
end_comment

begin_decl_stmt
name|int
name|nsyms
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means ptr to symbol entry for symbol to use as start addr.    -e sets this.  */
end_comment

begin_decl_stmt
name|symbol
modifier|*
name|entry_symbol
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|symbol
modifier|*
name|edata_symbol
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the symbol _edata */
end_comment

begin_decl_stmt
name|symbol
modifier|*
name|etext_symbol
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the symbol _etext */
end_comment

begin_decl_stmt
name|symbol
modifier|*
name|end_symbol
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the symbol _end */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Each input file, and each library member ("subfile") being loaded,    has a `file_entry' structure for it.     For files specified by command args, these are contained in the vector    which `file_table' points to.     For library members, they are dynamically allocated,    and chained through the `chain' field.    The chain is found in the `subfiles' field of the `file_entry'.    The `file_entry' objects for the members have `superfile' fields pointing    to the one for the library.  */
end_comment

begin_struct
struct|struct
name|file_entry
block|{
comment|/* Name of this file.  */
name|char
modifier|*
name|filename
decl_stmt|;
comment|/* Name to use for the symbol giving address of text start */
comment|/* Usually the same as filename, but for a file spec'd with -l      this is the -l switch itself rather than the filename.  */
name|char
modifier|*
name|local_sym_name
decl_stmt|;
comment|/* Describe the layout of the contents of the file */
comment|/* The file's a.out header.  */
name|struct
name|exec
name|header
decl_stmt|;
comment|/* Offset in file of GDB symbol segment, or 0 if there is none.  */
name|int
name|symseg_offset
decl_stmt|;
comment|/* Describe data from the file loaded into core */
comment|/* Symbol table of the file.  */
name|struct
name|nlist
modifier|*
name|symbols
decl_stmt|;
comment|/* Size in bytes of string table.  */
name|int
name|string_size
decl_stmt|;
comment|/* Pointer to the string table.      The string table is not kept in core all the time,      but when it is in core, its address is here.  */
name|char
modifier|*
name|strings
decl_stmt|;
comment|/* Next two used only if `relocatable_output' or if needed for */
comment|/* output of undefined reference line numbers. */
comment|/* Text reloc info saved by `write_text' for `coptxtrel'.  */
name|struct
name|relocation_info
modifier|*
name|textrel
decl_stmt|;
comment|/* Data reloc info saved by `write_data' for `copdatrel'.  */
name|struct
name|relocation_info
modifier|*
name|datarel
decl_stmt|;
comment|/* Relation of this file's segments to the output file */
comment|/* Start of this file's text seg in the output file core image.  */
name|int
name|text_start_address
decl_stmt|;
comment|/* Start of this file's data seg in the output file core image.  */
name|int
name|data_start_address
decl_stmt|;
comment|/* Start of this file's bss seg in the output file core image.  */
name|int
name|bss_start_address
decl_stmt|;
comment|/* Offset in bytes in the output file symbol table      of the first local symbol for this file.  Set by `write_file_symbols'.  */
name|int
name|local_syms_offset
decl_stmt|;
comment|/* For library members only */
comment|/* For a library, points to chain of entries for the library members.  */
name|struct
name|file_entry
modifier|*
name|subfiles
decl_stmt|;
comment|/* For a library member, offset of the member within the archive.      Zero for files that are not library members.  */
name|int
name|starting_offset
decl_stmt|;
comment|/* Size of contents of this file, if library member.  */
name|int
name|total_size
decl_stmt|;
comment|/* For library member, points to the library's own entry.  */
name|struct
name|file_entry
modifier|*
name|superfile
decl_stmt|;
comment|/* For library member, points to next entry for next member.  */
name|struct
name|file_entry
modifier|*
name|chain
decl_stmt|;
comment|/* 1 if file is a library. */
name|char
name|library_flag
decl_stmt|;
comment|/* 1 if file's header has been read into this structure.  */
name|char
name|header_read_flag
decl_stmt|;
comment|/* 1 means search a set of directories for this file.  */
name|char
name|search_dirs_flag
decl_stmt|;
comment|/* 1 means this is base file of incremental load.      Do not load this file's text or data.      Also default text_start to after this file's bss. */
name|char
name|just_syms_flag
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Vector of entries for input files specified by arguments.    These are all the input files except for members of specified libraries.  */
end_comment

begin_decl_stmt
name|struct
name|file_entry
modifier|*
name|file_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Length of that vector.  */
end_comment

begin_decl_stmt
name|int
name|number_of_files
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* When loading the text and data, we can avoid doing a close    and another open between members of the same library.     These two variables remember the file that is currently open.    Both are zero if no file is open.     See `each_file' and `file_close'.  */
end_comment

begin_decl_stmt
name|struct
name|file_entry
modifier|*
name|input_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|input_desc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The name of the file to write; "a.out" by default.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|output_filename
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Descriptor for writing that file with `mywrite'.  */
end_comment

begin_decl_stmt
name|int
name|outdesc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Header for that file (filled in by `write_header').  */
end_comment

begin_decl_stmt
name|struct
name|exec
name|outheader
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|COFF_ENCAPSULATE
end_ifdef

begin_decl_stmt
name|struct
name|coffheader
name|coffheader
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|need_coff_header
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The following are computed by `digest_symbols'.  */
end_comment

begin_decl_stmt
name|int
name|text_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* total size of text of all input files.  */
end_comment

begin_decl_stmt
name|int
name|data_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* total size of data of all input files.  */
end_comment

begin_decl_stmt
name|int
name|bss_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* total size of bss of all input files.  */
end_comment

begin_decl_stmt
name|int
name|text_reloc_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* total size of text relocation of all input files.  */
end_comment

begin_decl_stmt
name|int
name|data_reloc_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* total size of data relocation of all input */
end_comment

begin_comment
comment|/* files.  */
end_comment

begin_comment
comment|/* Specifications of start and length of the area reserved at the end    of the text segment for the set vectors.  Computed in 'digest_symbols' */
end_comment

begin_decl_stmt
name|int
name|set_sect_start
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|set_sect_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer for in core storage for the above vectors, before they are    written. */
end_comment

begin_decl_stmt
name|unsigned
name|long
modifier|*
name|set_vectors
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Amount of cleared space to leave between the text and data segments.  */
end_comment

begin_decl_stmt
name|int
name|text_pad
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Amount of bss segment to include as part of the data segment.  */
end_comment

begin_decl_stmt
name|int
name|data_pad
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Format of __.SYMDEF:    First, a longword containing the size of the 'symdef' data that follows.    Second, zero or more 'symdef' structures.    Third, a longword containing the length of symbol name strings.    Fourth, zero or more symbol name strings (each followed by a null).  */
end_comment

begin_struct
struct|struct
name|symdef
block|{
name|int
name|symbol_name_string_index
decl_stmt|;
name|int
name|library_member_offset
decl_stmt|;
block|}
struct|;
end_struct

begin_escape
end_escape

begin_comment
comment|/* Record most of the command options.  */
end_comment

begin_comment
comment|/* Address we assume the text section will be loaded at.    We relocate symbols and text and data for this, but we do not    write any padding in the output file for it.  */
end_comment

begin_decl_stmt
name|int
name|text_start
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Offset of default entry-pc within the text section.  */
end_comment

begin_decl_stmt
name|int
name|entry_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Address we decide the data section will be loaded at.  */
end_comment

begin_decl_stmt
name|int
name|data_start
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* `text-start' address is normally this much plus a page boundary.    This is not a user option; it is fixed for each system.  */
end_comment

begin_decl_stmt
name|int
name|text_start_alignment
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if -T was specified in the command line.    This prevents text_start from being set later to default values.  */
end_comment

begin_decl_stmt
name|int
name|T_flag_specified
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if -Tdata was specified in the command line.    This prevents data_start from being set later to default values.  */
end_comment

begin_decl_stmt
name|int
name|Tdata_flag_specified
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size to pad data section up to.    We simply increase the size of the data section, padding with zeros,    and reduce the size of the bss section to match.  */
end_comment

begin_decl_stmt
name|int
name|specified_data_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Magic number to use for the output file, set by switch.  */
end_comment

begin_decl_stmt
name|int
name|magic
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means print names of input files as processed.  */
end_comment

begin_decl_stmt
name|int
name|trace_files
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Which symbols should be stripped (omitted from the output):    none, all, or debugger symbols.  */
end_comment

begin_enum
enum|enum
block|{
name|STRIP_NONE
block|,
name|STRIP_ALL
block|,
name|STRIP_DEBUGGER
block|}
name|strip_symbols
enum|;
end_enum

begin_comment
comment|/* Which local symbols should be omitted:    none, all, or those starting with L.    This is irrelevant if STRIP_NONE.  */
end_comment

begin_enum
enum|enum
block|{
name|DISCARD_NONE
block|,
name|DISCARD_ALL
block|,
name|DISCARD_L
block|}
name|discard_locals
enum|;
end_enum

begin_comment
comment|/* 1 => write load map.  */
end_comment

begin_decl_stmt
name|int
name|write_map
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 => write relocation into output file so can re-input it later.  */
end_comment

begin_decl_stmt
name|int
name|relocatable_output
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 => assign space to common symbols even if `relocatable_output'.  */
end_comment

begin_decl_stmt
name|int
name|force_common_definition
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Standard directories to search for files specified by -l.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|standard_search_dirs
index|[]
init|=
ifdef|#
directive|ifdef
name|STANDARD_SEARCH_DIRS
block|{
name|STANDARD_SEARCH_DIRS
block|}
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|NON_NATIVE
end_ifdef

begin_block
block|{
literal|"/usr/local/lib/gnu"
block|}
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_else
else|#
directive|else
end_else

begin_block
block|{
literal|"/lib"
operator|,
literal|"/usr/lib"
operator|,
literal|"/usr/local/lib"
block|}
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Actual vector of directories to search;    this contains those specified with -L plus the standard ones.  */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|search_dirs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Length of the vector `search_dirs'.  */
end_comment

begin_decl_stmt
name|int
name|n_search_dirs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non zero means to create the output executable. */
end_comment

begin_comment
comment|/* Cleared by nonfatal errors.  */
end_comment

begin_decl_stmt
name|int
name|make_executable
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Force the executable to be output, even if there are non-fatal    errors */
end_comment

begin_decl_stmt
name|int
name|force_executable
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Keep a list of any symbols referenced from the command line (so    that error messages for these guys can be generated). This list is    zero terminated. */
end_comment

begin_decl_stmt
name|struct
name|glosym
modifier|*
modifier|*
name|cmdline_references
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cl_refs_allocated
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|bcopy
argument_list|()
decl_stmt|,
name|bzero
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|malloc
argument_list|()
decl_stmt|,
name|realloc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|alloca
end_ifndef

begin_function_decl
name|int
name|alloca
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|int
name|free
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|xmalloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|xrealloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|fatal
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|fatal_with_file
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|perror_name
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|perror_file
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|error
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|digest_symbols
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|print_symbols
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|load_symbols
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|decode_command
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|list_undefined_symbols
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|list_unresolved_references
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|write_output
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|write_header
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|write_text
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|read_file_relocation
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|write_data
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|write_rel
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|write_syms
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|write_symsegs
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|mywrite
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|symtab_init
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|padfile
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|concat
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|get_file_name
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|symbol
modifier|*
name|getsym
argument_list|()
decl_stmt|,
modifier|*
name|getsym_soft
argument_list|()
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|int
name|argc
decl_stmt|;
block|{
comment|/*   Added this to stop ld core-dumping on very large .o files.    */
ifdef|#
directive|ifdef
name|RLIMIT_STACK
comment|/* Get rid of any avoidable limit on stack size.  */
block|{
name|struct
name|rlimit
name|rlim
decl_stmt|;
comment|/* Set the stack limit huge so that alloca does not fail. */
name|getrlimit
argument_list|(
name|RLIMIT_STACK
argument_list|,
operator|&
name|rlim
argument_list|)
expr_stmt|;
name|rlim
operator|.
name|rlim_cur
operator|=
name|rlim
operator|.
name|rlim_max
expr_stmt|;
name|setrlimit
argument_list|(
name|RLIMIT_STACK
argument_list|,
operator|&
name|rlim
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* RLIMIT_STACK */
name|page_size
operator|=
name|getpagesize
argument_list|()
expr_stmt|;
name|progname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
comment|/* Clear the cumulative info on the output file.  */
name|text_size
operator|=
literal|0
expr_stmt|;
name|data_size
operator|=
literal|0
expr_stmt|;
name|bss_size
operator|=
literal|0
expr_stmt|;
name|text_reloc_size
operator|=
literal|0
expr_stmt|;
name|data_reloc_size
operator|=
literal|0
expr_stmt|;
name|data_pad
operator|=
literal|0
expr_stmt|;
name|text_pad
operator|=
literal|0
expr_stmt|;
comment|/* Initialize the data about options.  */
name|specified_data_size
operator|=
literal|0
expr_stmt|;
name|strip_symbols
operator|=
name|STRIP_NONE
expr_stmt|;
name|trace_files
operator|=
literal|0
expr_stmt|;
name|discard_locals
operator|=
name|DISCARD_NONE
expr_stmt|;
name|entry_symbol
operator|=
literal|0
expr_stmt|;
name|write_map
operator|=
literal|0
expr_stmt|;
name|relocatable_output
operator|=
literal|0
expr_stmt|;
name|force_common_definition
operator|=
literal|0
expr_stmt|;
name|T_flag_specified
operator|=
literal|0
expr_stmt|;
name|Tdata_flag_specified
operator|=
literal|0
expr_stmt|;
name|magic
operator|=
name|DEFAULT_MAGIC
expr_stmt|;
name|make_executable
operator|=
literal|1
expr_stmt|;
name|force_executable
operator|=
literal|0
expr_stmt|;
name|set_element_prefixes
operator|=
literal|0
expr_stmt|;
comment|/* Initialize the cumulative counts of symbols.  */
name|local_sym_count
operator|=
literal|0
expr_stmt|;
name|non_L_local_sym_count
operator|=
literal|0
expr_stmt|;
name|debugger_sym_count
operator|=
literal|0
expr_stmt|;
name|undefined_global_sym_count
operator|=
literal|0
expr_stmt|;
name|set_symbol_count
operator|=
literal|0
expr_stmt|;
name|set_vector_count
operator|=
literal|0
expr_stmt|;
name|global_indirect_count
operator|=
literal|0
expr_stmt|;
name|warning_count
operator|=
literal|0
expr_stmt|;
name|multiple_def_count
operator|=
literal|0
expr_stmt|;
name|common_defined_global_count
operator|=
literal|0
expr_stmt|;
comment|/* Keep a list of symbols referenced from the command line */
name|cl_refs_allocated
operator|=
literal|10
expr_stmt|;
name|cmdline_references
operator|=
operator|(
expr|struct
name|glosym
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|cl_refs_allocated
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|glosym
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|cmdline_references
operator|=
literal|0
expr_stmt|;
comment|/* Completely decode ARGV.  */
name|decode_command
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
comment|/* Create the symbols `etext', `edata' and `end'.  */
if|if
condition|(
operator|!
name|relocatable_output
condition|)
name|symtab_init
argument_list|()
expr_stmt|;
comment|/* Determine whether to count the header as part of      the text size, and initialize the text size accordingly.      This depends on the kind of system and on the output format selected.  */
name|N_SET_MAGIC
argument_list|(
name|outheader
argument_list|,
name|magic
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INITIALIZE_HEADER
name|INITIALIZE_HEADER
expr_stmt|;
endif|#
directive|endif
name|text_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|exec
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COFF_ENCAPSULATE
if|if
condition|(
name|relocatable_output
operator|==
literal|0
operator|&&
name|file_table
index|[
literal|0
index|]
operator|.
name|just_syms_flag
operator|==
literal|0
condition|)
block|{
name|need_coff_header
operator|=
literal|1
expr_stmt|;
comment|/* set this flag now, since it will change the values of N_TXTOFF, etc */
name|N_SET_FLAGS
argument_list|(
name|outheader
argument_list|,
name|N_FLAGS_COFF_ENCAPSULATE
argument_list|)
expr_stmt|;
name|text_size
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|coffheader
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|text_size
operator|-=
name|N_TXTOFF
argument_list|(
name|outheader
argument_list|)
expr_stmt|;
if|if
condition|(
name|text_size
operator|<
literal|0
condition|)
name|text_size
operator|=
literal|0
expr_stmt|;
name|entry_offset
operator|=
name|text_size
expr_stmt|;
if|if
condition|(
operator|!
name|T_flag_specified
operator|&&
operator|!
name|relocatable_output
operator|&&
operator|!
name|screwballmode
condition|)
name|text_start
operator|=
name|TEXT_START
argument_list|(
name|outheader
argument_list|)
expr_stmt|;
comment|/* The text-start address is normally this far past a page boundary.  */
name|text_start_alignment
operator|=
name|text_start
operator|%
name|page_size
expr_stmt|;
comment|/* Load symbols of all input files.      Also search all libraries and decide which library members to load.  */
name|load_symbols
argument_list|()
expr_stmt|;
comment|/* Compute where each file's sections go, and relocate symbols.  */
name|digest_symbols
argument_list|()
expr_stmt|;
comment|/* Print error messages for any missing symbols, for any warning      symbols, and possibly multiple definitions */
name|do_warnings
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
comment|/* Print a map, if requested.  */
if|if
condition|(
name|write_map
condition|)
name|print_symbols
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* Write the output file.  */
if|if
condition|(
name|make_executable
operator|||
name|force_executable
condition|)
name|write_output
argument_list|()
expr_stmt|;
name|exit
argument_list|(
operator|!
name|make_executable
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function_decl
name|void
name|decode_option
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Analyze a command line argument.    Return 0 if the argument is a filename.    Return 1 if the argument is a option complete in itself.    Return 2 if the argument is a option which uses an argument.     Thus, the value is the number of consecutive arguments    that are part of options.  */
end_comment

begin_function
name|int
name|classify_arg
parameter_list|(
name|arg
parameter_list|)
specifier|register
name|char
modifier|*
name|arg
decl_stmt|;
block|{
if|if
condition|(
operator|*
name|arg
operator|!=
literal|'-'
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|arg
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'A'
case|:
case|case
literal|'D'
case|:
case|case
literal|'e'
case|:
case|case
literal|'L'
case|:
case|case
literal|'l'
case|:
case|case
literal|'o'
case|:
case|case
literal|'u'
case|:
case|case
literal|'V'
case|:
case|case
literal|'y'
case|:
if|if
condition|(
name|arg
index|[
literal|2
index|]
condition|)
return|return
literal|1
return|;
return|return
literal|2
return|;
case|case
literal|'B'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|&
name|arg
index|[
literal|2
index|]
argument_list|,
literal|"static"
argument_list|)
condition|)
return|return
literal|1
return|;
case|case
literal|'T'
case|:
if|if
condition|(
name|arg
index|[
literal|2
index|]
operator|==
literal|0
condition|)
return|return
literal|2
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|&
name|arg
index|[
literal|2
index|]
argument_list|,
literal|"text"
argument_list|)
condition|)
return|return
literal|2
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|&
name|arg
index|[
literal|2
index|]
argument_list|,
literal|"data"
argument_list|)
condition|)
return|return
literal|2
return|;
return|return
literal|1
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Process the command arguments,    setting up file_table with an entry for each input file,    and setting variables according to the options.  */
end_comment

begin_function
name|void
name|decode_command
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|int
name|argc
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|file_entry
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|number_of_files
operator|=
literal|0
expr_stmt|;
name|output_filename
operator|=
literal|"a.out"
expr_stmt|;
name|n_search_dirs
operator|=
literal|0
expr_stmt|;
name|search_dirs
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* First compute number_of_files so we know how long to make file_table.  */
comment|/* Also process most options completely.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|int
name|code
init|=
name|classify_arg
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
condition|)
block|{
if|if
condition|(
name|i
operator|+
name|code
operator|>
name|argc
condition|)
name|fatal
argument_list|(
literal|"no argument following %s\n"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|decode_option
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|argv
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'l'
operator|||
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'A'
condition|)
name|number_of_files
operator|++
expr_stmt|;
name|i
operator|+=
name|code
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|number_of_files
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|number_of_files
condition|)
name|fatal
argument_list|(
literal|"no input files"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|=
name|file_table
operator|=
operator|(
expr|struct
name|file_entry
operator|*
operator|)
name|xmalloc
argument_list|(
name|number_of_files
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|file_entry
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|p
argument_list|,
name|number_of_files
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|file_entry
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now scan again and fill in file_table.  */
comment|/* All options except -A and -l are ignored here.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|int
name|code
init|=
name|classify_arg
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
condition|)
block|{
name|char
modifier|*
name|string
decl_stmt|;
if|if
condition|(
name|code
operator|==
literal|2
condition|)
name|string
operator|=
name|argv
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
else|else
name|string
operator|=
operator|&
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'A'
condition|)
block|{
if|if
condition|(
name|p
operator|!=
name|file_table
condition|)
name|fatal
argument_list|(
literal|"-A specified before an input file other than the first"
argument_list|)
expr_stmt|;
name|p
operator|->
name|filename
operator|=
name|string
expr_stmt|;
name|p
operator|->
name|local_sym_name
operator|=
name|string
expr_stmt|;
name|p
operator|->
name|just_syms_flag
operator|=
literal|1
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'l'
condition|)
block|{
if|if
condition|(
name|cp
operator|=
name|rindex
argument_list|(
name|string
argument_list|,
literal|'/'
argument_list|)
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|cp
operator|=
name|concat
argument_list|(
name|string
argument_list|,
literal|"/lib"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|p
operator|->
name|filename
operator|=
name|concat
argument_list|(
name|cp
argument_list|,
literal|".a"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
name|p
operator|->
name|filename
operator|=
name|concat
argument_list|(
literal|"lib"
argument_list|,
name|string
argument_list|,
literal|".a"
argument_list|)
expr_stmt|;
name|p
operator|->
name|local_sym_name
operator|=
name|concat
argument_list|(
literal|"-l"
argument_list|,
name|string
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|p
operator|->
name|search_dirs_flag
operator|=
literal|1
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
name|i
operator|+=
name|code
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|filename
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
name|p
operator|->
name|local_sym_name
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
block|}
comment|/* Now check some option settings for consistency.  */
ifdef|#
directive|ifdef
name|NMAGIC
if|if
condition|(
operator|(
name|magic
operator|==
name|ZMAGIC
operator|||
name|magic
operator|==
name|NMAGIC
operator|)
else|#
directive|else
if|if
condition|(
operator|(
name|magic
operator|==
name|ZMAGIC
operator|)
endif|#
directive|endif
operator|&&
operator|(
name|text_start
operator|-
name|text_start_alignment
operator|)
operator|&
operator|(
name|page_size
operator|-
literal|1
operator|)
condition|)
name|fatal
argument_list|(
literal|"-T argument not multiple of page size, with sharable output"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Append the standard search directories to the user-specified ones.  */
block|{
name|int
name|n
init|=
sizeof|sizeof
name|standard_search_dirs
operator|/
sizeof|sizeof
name|standard_search_dirs
index|[
literal|0
index|]
decl_stmt|;
name|n_search_dirs
operator|+=
name|n
expr_stmt|;
name|search_dirs
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|search_dirs
argument_list|,
name|n_search_dirs
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|standard_search_dirs
argument_list|,
operator|&
name|search_dirs
index|[
name|n_search_dirs
operator|-
name|n
index|]
argument_list|,
name|n
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|add_cmdline_ref
parameter_list|(
name|sp
parameter_list|)
name|struct
name|glosym
modifier|*
name|sp
decl_stmt|;
block|{
name|struct
name|glosym
modifier|*
modifier|*
name|ptr
decl_stmt|;
for|for
control|(
name|ptr
operator|=
name|cmdline_references
init|;
name|ptr
operator|<
name|cmdline_references
operator|+
name|cl_refs_allocated
operator|&&
operator|*
name|ptr
condition|;
name|ptr
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|ptr
operator|>=
name|cmdline_references
operator|+
name|cl_refs_allocated
operator|-
literal|1
condition|)
block|{
name|int
name|diff
init|=
name|ptr
operator|-
name|cmdline_references
decl_stmt|;
name|cl_refs_allocated
operator|*=
literal|2
expr_stmt|;
name|cmdline_references
operator|=
operator|(
expr|struct
name|glosym
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|cmdline_references
argument_list|,
name|cl_refs_allocated
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|glosym
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|cmdline_references
operator|+
name|diff
expr_stmt|;
block|}
operator|*
name|ptr
operator|++
operator|=
name|sp
expr_stmt|;
operator|*
name|ptr
operator|=
operator|(
expr|struct
name|glosym
operator|*
operator|)
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|int
name|set_element_prefixed_p
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|string_list_element
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|p
operator|=
name|set_element_prefixes
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|p
operator|->
name|str
index|[
name|i
index|]
operator|!=
literal|'\0'
operator|&&
operator|(
name|p
operator|->
name|str
index|[
name|i
index|]
operator|==
name|name
index|[
name|i
index|]
operator|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|p
operator|->
name|str
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function_decl
name|int
name|parse
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Record an option and arrange to act on it later.    ARG should be the following command argument,    which may or may not be used by this option.     The `l' and `A' options are ignored here since they actually    specify input files.  */
end_comment

begin_function
name|void
name|decode_option
parameter_list|(
name|swt
parameter_list|,
name|arg
parameter_list|)
specifier|register
name|char
modifier|*
name|swt
decl_stmt|,
decl|*
name|arg
decl_stmt|;
end_function

begin_block
block|{
comment|/* We get Bstatic from gcc on suns.  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|swt
operator|+
literal|1
argument_list|,
literal|"Bstatic"
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|swt
operator|+
literal|1
argument_list|,
literal|"Ttext"
argument_list|)
condition|)
block|{
name|text_start
operator|=
name|parse
argument_list|(
name|arg
argument_list|,
literal|"%x"
argument_list|,
literal|"invalid argument to -Ttext"
argument_list|)
expr_stmt|;
name|T_flag_specified
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|swt
operator|+
literal|1
argument_list|,
literal|"Tdata"
argument_list|)
condition|)
block|{
name|data_start
operator|=
name|parse
argument_list|(
name|arg
argument_list|,
literal|"%x"
argument_list|,
literal|"invalid argument to -Tdata"
argument_list|)
expr_stmt|;
name|Tdata_flag_specified
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|swt
operator|+
literal|1
argument_list|,
literal|"noinhibit-exec"
argument_list|)
condition|)
block|{
name|force_executable
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|swt
operator|+
literal|1
argument_list|,
literal|"screwballmode"
argument_list|)
condition|)
block|{
name|screwballmode
operator|=
literal|1
expr_stmt|;
name|magic
operator|=
name|OMAGIC
expr_stmt|;
name|text_start
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|exec
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|swt
index|[
literal|2
index|]
operator|!=
literal|0
condition|)
name|arg
operator|=
operator|&
name|swt
index|[
literal|2
index|]
expr_stmt|;
switch|switch
condition|(
name|swt
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'A'
case|:
return|return;
case|case
literal|'D'
case|:
name|specified_data_size
operator|=
name|parse
argument_list|(
name|arg
argument_list|,
literal|"%x"
argument_list|,
literal|"invalid argument to -D"
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'d'
case|:
name|force_common_definition
operator|=
literal|1
expr_stmt|;
return|return;
case|case
literal|'e'
case|:
name|entry_symbol
operator|=
name|getsym
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|entry_symbol
operator|->
name|defined
operator|&&
operator|!
name|entry_symbol
operator|->
name|referenced
condition|)
name|undefined_global_sym_count
operator|++
expr_stmt|;
name|entry_symbol
operator|->
name|referenced
operator|=
literal|1
expr_stmt|;
name|add_cmdline_ref
argument_list|(
name|entry_symbol
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'l'
case|:
comment|/* If linking with libg++, use the C++ demangler. */
if|if
condition|(
name|arg
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"g++"
argument_list|)
operator|==
literal|0
condition|)
name|demangler
operator|=
name|cplus_demangle
expr_stmt|;
return|return;
name|magic
operator|=
name|OMAGIC
expr_stmt|;
case|case
literal|'L'
case|:
name|n_search_dirs
operator|++
expr_stmt|;
name|search_dirs
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|search_dirs
argument_list|,
name|n_search_dirs
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|search_dirs
index|[
name|n_search_dirs
operator|-
literal|1
index|]
operator|=
name|arg
expr_stmt|;
return|return;
case|case
literal|'M'
case|:
name|write_map
operator|=
literal|1
expr_stmt|;
return|return;
case|case
literal|'N'
case|:
name|magic
operator|=
name|OMAGIC
expr_stmt|;
ifdef|#
directive|ifdef
name|notnow
name|text_start
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|exec
argument_list|)
expr_stmt|;
comment|/* XXX */
name|screwballmode
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
return|return;
ifdef|#
directive|ifdef
name|NMAGIC
case|case
literal|'n'
case|:
name|magic
operator|=
name|NMAGIC
expr_stmt|;
return|return;
endif|#
directive|endif
case|case
literal|'o'
case|:
name|output_filename
operator|=
name|arg
expr_stmt|;
return|return;
case|case
literal|'r'
case|:
name|relocatable_output
operator|=
literal|1
expr_stmt|;
name|magic
operator|=
name|OMAGIC
expr_stmt|;
name|text_start
operator|=
literal|0
expr_stmt|;
return|return;
case|case
literal|'S'
case|:
name|strip_symbols
operator|=
name|STRIP_DEBUGGER
expr_stmt|;
return|return;
case|case
literal|'s'
case|:
name|strip_symbols
operator|=
name|STRIP_ALL
expr_stmt|;
return|return;
case|case
literal|'T'
case|:
name|text_start
operator|=
name|parse
argument_list|(
name|arg
argument_list|,
literal|"%x"
argument_list|,
literal|"invalid argument to -T"
argument_list|)
expr_stmt|;
name|T_flag_specified
operator|=
literal|1
expr_stmt|;
return|return;
case|case
literal|'t'
case|:
name|trace_files
operator|=
literal|1
expr_stmt|;
return|return;
case|case
literal|'u'
case|:
block|{
specifier|register
name|symbol
modifier|*
name|sp
init|=
name|getsym
argument_list|(
name|arg
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sp
operator|->
name|defined
operator|&&
operator|!
name|sp
operator|->
name|referenced
condition|)
name|undefined_global_sym_count
operator|++
expr_stmt|;
name|sp
operator|->
name|referenced
operator|=
literal|1
expr_stmt|;
name|add_cmdline_ref
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
literal|'V'
case|:
block|{
name|struct
name|string_list_element
modifier|*
name|new
init|=
operator|(
expr|struct
name|string_list_element
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|string_list_element
argument_list|)
argument_list|)
decl_stmt|;
name|new
operator|->
name|str
operator|=
name|arg
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|set_element_prefixes
expr_stmt|;
name|set_element_prefixes
operator|=
name|new
expr_stmt|;
return|return;
block|}
case|case
literal|'X'
case|:
name|discard_locals
operator|=
name|DISCARD_L
expr_stmt|;
return|return;
case|case
literal|'x'
case|:
name|discard_locals
operator|=
name|DISCARD_ALL
expr_stmt|;
return|return;
case|case
literal|'y'
case|:
block|{
specifier|register
name|symbol
modifier|*
name|sp
init|=
name|getsym
argument_list|(
operator|&
name|swt
index|[
literal|2
index|]
argument_list|)
decl_stmt|;
name|sp
operator|->
name|trace
operator|=
literal|1
expr_stmt|;
block|}
return|return;
case|case
literal|'z'
case|:
name|magic
operator|=
name|ZMAGIC
expr_stmt|;
return|return;
default|default:
name|fatal
argument_list|(
literal|"invalid command option `%s'"
argument_list|,
name|swt
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/** Convenient functions for operating on one or all files being */
end_comment

begin_comment
comment|/** loaded.  */
end_comment

begin_function_decl
name|void
name|print_file_name
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Call FUNCTION on each input file entry.    Do not call for entries for libraries;    instead, call once for each library member that is being loaded.     FUNCTION receives two arguments: the entry, and ARG.  */
end_comment

begin_decl_stmt
name|void
name|each_file
argument_list|(
name|function
argument_list|,
name|arg
argument_list|)
decl|register
name|void
argument_list|(
operator|*
name|function
argument_list|)
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|number_of_files
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|struct
name|file_entry
modifier|*
name|entry
init|=
operator|&
name|file_table
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|entry
operator|->
name|library_flag
condition|)
block|{
specifier|register
name|struct
name|file_entry
modifier|*
name|subentry
init|=
name|entry
operator|->
name|subfiles
decl_stmt|;
for|for
control|(
init|;
name|subentry
condition|;
name|subentry
operator|=
name|subentry
operator|->
name|chain
control|)
call|(
modifier|*
name|function
call|)
argument_list|(
name|subentry
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
else|else
call|(
modifier|*
name|function
call|)
argument_list|(
name|entry
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Call FUNCTION on each input file entry until it returns a non-zero    value.  Return this value.    Do not call for entries for libraries;    instead, call once for each library member that is being loaded.     FUNCTION receives two arguments: the entry, and ARG.  It must be a    function returning unsigned long (though this can probably be fudged). */
end_comment

begin_decl_stmt
name|unsigned
name|long
name|check_each_file
argument_list|(
name|function
argument_list|,
name|arg
argument_list|)
decl|register
name|unsigned
name|long
argument_list|(
operator|*
name|function
argument_list|)
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|unsigned
name|long
name|return_val
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|number_of_files
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|struct
name|file_entry
modifier|*
name|entry
init|=
operator|&
name|file_table
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|entry
operator|->
name|library_flag
condition|)
block|{
specifier|register
name|struct
name|file_entry
modifier|*
name|subentry
init|=
name|entry
operator|->
name|subfiles
decl_stmt|;
for|for
control|(
init|;
name|subentry
condition|;
name|subentry
operator|=
name|subentry
operator|->
name|chain
control|)
if|if
condition|(
name|return_val
operator|=
call|(
modifier|*
name|function
call|)
argument_list|(
name|subentry
argument_list|,
name|arg
argument_list|)
condition|)
return|return
name|return_val
return|;
block|}
elseif|else
if|if
condition|(
name|return_val
operator|=
call|(
modifier|*
name|function
call|)
argument_list|(
name|entry
argument_list|,
name|arg
argument_list|)
condition|)
return|return
name|return_val
return|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Like `each_file' but ignore files that were just for symbol definitions.  */
end_comment

begin_decl_stmt
name|void
name|each_full_file
argument_list|(
name|function
argument_list|,
name|arg
argument_list|)
decl|register
name|void
argument_list|(
operator|*
name|function
argument_list|)
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|number_of_files
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|struct
name|file_entry
modifier|*
name|entry
init|=
operator|&
name|file_table
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|entry
operator|->
name|just_syms_flag
condition|)
continue|continue;
if|if
condition|(
name|entry
operator|->
name|library_flag
condition|)
block|{
specifier|register
name|struct
name|file_entry
modifier|*
name|subentry
init|=
name|entry
operator|->
name|subfiles
decl_stmt|;
for|for
control|(
init|;
name|subentry
condition|;
name|subentry
operator|=
name|subentry
operator|->
name|chain
control|)
call|(
modifier|*
name|function
call|)
argument_list|(
name|subentry
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
else|else
call|(
modifier|*
name|function
call|)
argument_list|(
name|entry
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Close the input file that is now open.  */
end_comment

begin_function
name|void
name|file_close
parameter_list|()
block|{
name|close
argument_list|(
name|input_desc
argument_list|)
expr_stmt|;
name|input_desc
operator|=
literal|0
expr_stmt|;
name|input_file
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Open the input file specified by 'entry', and return a descriptor.    The open file is remembered; if the same file is opened twice in a row,    a new open is not actually done.  */
end_comment

begin_function
name|int
name|file_open
parameter_list|(
name|entry
parameter_list|)
specifier|register
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
block|{
specifier|register
name|int
name|desc
decl_stmt|;
if|if
condition|(
name|entry
operator|->
name|superfile
condition|)
return|return
name|file_open
argument_list|(
name|entry
operator|->
name|superfile
argument_list|)
return|;
if|if
condition|(
name|entry
operator|==
name|input_file
condition|)
return|return
name|input_desc
return|;
if|if
condition|(
name|input_file
condition|)
name|file_close
argument_list|()
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|search_dirs_flag
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_search_dirs
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|char
modifier|*
name|string
init|=
name|concat
argument_list|(
name|search_dirs
index|[
name|i
index|]
argument_list|,
literal|"/"
argument_list|,
name|entry
operator|->
name|filename
argument_list|)
decl_stmt|;
name|desc
operator|=
name|open
argument_list|(
name|string
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|>
literal|0
condition|)
block|{
name|entry
operator|->
name|filename
operator|=
name|string
expr_stmt|;
name|entry
operator|->
name|search_dirs_flag
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|free
argument_list|(
name|string
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|desc
operator|=
name|open
argument_list|(
name|entry
operator|->
name|filename
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|>
literal|0
condition|)
block|{
name|input_file
operator|=
name|entry
expr_stmt|;
name|input_desc
operator|=
name|desc
expr_stmt|;
return|return
name|desc
return|;
block|}
name|perror_file
argument_list|(
name|entry
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/* Print the filename of ENTRY on OUTFILE (a stdio stream),    and then a newline.  */
end_comment

begin_function
name|void
name|prline_file_name
parameter_list|(
name|entry
parameter_list|,
name|outfile
parameter_list|)
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
name|FILE
modifier|*
name|outfile
decl_stmt|;
block|{
name|print_file_name
argument_list|(
name|entry
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print the filename of ENTRY on OUTFILE (a stdio stream).  */
end_comment

begin_function
name|void
name|print_file_name
parameter_list|(
name|entry
parameter_list|,
name|outfile
parameter_list|)
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
name|FILE
modifier|*
name|outfile
decl_stmt|;
block|{
if|if
condition|(
name|entry
operator|->
name|superfile
condition|)
block|{
name|print_file_name
argument_list|(
name|entry
operator|->
name|superfile
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"(%s)"
argument_list|,
name|entry
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%s"
argument_list|,
name|entry
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the filename of entry as a string (malloc'd for the purpose) */
end_comment

begin_function
name|char
modifier|*
name|get_file_name
parameter_list|(
name|entry
parameter_list|)
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
block|{
name|char
modifier|*
name|result
decl_stmt|,
modifier|*
name|supfile
decl_stmt|;
if|if
condition|(
name|entry
operator|->
name|superfile
condition|)
block|{
name|supfile
operator|=
name|get_file_name
argument_list|(
name|entry
operator|->
name|superfile
argument_list|)
expr_stmt|;
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|supfile
argument_list|)
operator|+
name|strlen
argument_list|(
name|entry
operator|->
name|filename
argument_list|)
operator|+
literal|3
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|result
argument_list|,
literal|"%s(%s)"
argument_list|,
name|supfile
argument_list|,
name|entry
operator|->
name|filename
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|supfile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|entry
operator|->
name|filename
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|result
argument_list|,
name|entry
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Medium-level input routines for rel files.  */
end_comment

begin_comment
comment|/* Read a file's header into the proper place in the file_entry.    DESC is the descriptor on which the file is open.    ENTRY is the file's entry.  */
end_comment

begin_function
name|void
name|read_header
parameter_list|(
name|desc
parameter_list|,
name|entry
parameter_list|)
name|int
name|desc
decl_stmt|;
specifier|register
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
block|{
specifier|register
name|int
name|len
decl_stmt|;
name|struct
name|exec
modifier|*
name|loc
init|=
operator|(
expr|struct
name|exec
operator|*
operator|)
operator|&
name|entry
operator|->
name|header
decl_stmt|;
name|lseek
argument_list|(
name|desc
argument_list|,
name|entry
operator|->
name|starting_offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COFF_ENCAPSULATE
if|if
condition|(
name|entry
operator|->
name|just_syms_flag
condition|)
name|lseek
argument_list|(
name|desc
argument_list|,
sizeof|sizeof
argument_list|(
name|coffheader
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|len
operator|=
name|read
argument_list|(
name|desc
argument_list|,
name|loc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|exec
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|exec
argument_list|)
condition|)
name|fatal_with_file
argument_list|(
literal|"failure reading header of "
argument_list|,
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|N_BADMAG
argument_list|(
operator|*
name|loc
argument_list|)
condition|)
name|fatal_with_file
argument_list|(
literal|"bad magic number in "
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|entry
operator|->
name|header_read_flag
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read the symbols of file ENTRY into core.    Assume it is already open, on descriptor DESC.    Also read the length of the string table, which follows the symbol table,    but don't read the contents of the string table.  */
end_comment

begin_function
name|void
name|read_entry_symbols
parameter_list|(
name|desc
parameter_list|,
name|entry
parameter_list|)
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
name|int
name|desc
decl_stmt|;
block|{
name|int
name|str_size
decl_stmt|;
if|if
condition|(
operator|!
name|entry
operator|->
name|header_read_flag
condition|)
name|read_header
argument_list|(
name|desc
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|entry
operator|->
name|symbols
operator|=
operator|(
expr|struct
name|nlist
operator|*
operator|)
name|xmalloc
argument_list|(
name|entry
operator|->
name|header
operator|.
name|a_syms
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|desc
argument_list|,
name|N_SYMOFF
argument_list|(
name|entry
operator|->
name|header
argument_list|)
operator|+
name|entry
operator|->
name|starting_offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|header
operator|.
name|a_syms
operator|!=
name|read
argument_list|(
name|desc
argument_list|,
name|entry
operator|->
name|symbols
argument_list|,
name|entry
operator|->
name|header
operator|.
name|a_syms
argument_list|)
condition|)
name|fatal_with_file
argument_list|(
literal|"premature end of file in symbols of "
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|desc
argument_list|,
name|N_STROFF
argument_list|(
name|entry
operator|->
name|header
argument_list|)
operator|+
name|entry
operator|->
name|starting_offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
sizeof|sizeof
name|str_size
operator|!=
name|read
argument_list|(
name|desc
argument_list|,
operator|&
name|str_size
argument_list|,
sizeof|sizeof
name|str_size
argument_list|)
condition|)
name|fatal_with_file
argument_list|(
literal|"bad string table size in "
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|entry
operator|->
name|string_size
operator|=
name|str_size
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read the string table of file ENTRY into core.    Assume it is already open, on descriptor DESC.    Also record whether a GDB symbol segment follows the string table.  */
end_comment

begin_function
name|void
name|read_entry_strings
parameter_list|(
name|desc
parameter_list|,
name|entry
parameter_list|)
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
name|int
name|desc
decl_stmt|;
block|{
name|int
name|buffer
decl_stmt|;
if|if
condition|(
operator|!
name|entry
operator|->
name|header_read_flag
condition|)
name|read_header
argument_list|(
name|desc
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|desc
argument_list|,
name|N_STROFF
argument_list|(
name|entry
operator|->
name|header
argument_list|)
operator|+
name|entry
operator|->
name|starting_offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|string_size
operator|!=
name|read
argument_list|(
name|desc
argument_list|,
name|entry
operator|->
name|strings
argument_list|,
name|entry
operator|->
name|string_size
argument_list|)
condition|)
name|fatal_with_file
argument_list|(
literal|"premature end of file in strings of "
argument_list|,
name|entry
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* While we are here, see if the file has a symbol segment at the end.      For a separate file, just try reading some more.      For a library member, compare current pos against total size.  */
block|if (entry->superfile)     {       if (entry->total_size == N_STROFF (entry->header) + entry->string_size) 	return;     }   else     {       buffer = read (desc,&buffer, sizeof buffer);       if (buffer == 0) 	return;       if (buffer != sizeof buffer) 	fatal_with_file ("premature end of file in GDB symbol segment of ", entry);     }
endif|#
directive|endif
comment|/* Don't try to do anything with symsegs.  */
return|return;
if|#
directive|if
literal|0
comment|/* eliminate warning of `statement not reached'.  */
block|entry->symseg_offset = N_STROFF (entry->header) + entry->string_size;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read in the symbols of all input files.  */
end_comment

begin_decl_stmt
name|void
name|read_file_symbols
argument_list|()
decl_stmt|,
name|read_entry_symbols
argument_list|()
decl_stmt|,
name|read_entry_strings
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|enter_file_symbols
argument_list|()
decl_stmt|,
name|enter_global_ref
argument_list|()
decl_stmt|,
name|search_library
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|load_symbols
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|trace_files
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Loading symbols:\n\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|number_of_files
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|struct
name|file_entry
modifier|*
name|entry
init|=
operator|&
name|file_table
index|[
name|i
index|]
decl_stmt|;
name|read_file_symbols
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|trace_files
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If ENTRY is a rel file, read its symbol and string sections into core.    If it is a library, search it and load the appropriate members    (which means calling this function recursively on those members).  */
end_comment

begin_function
name|void
name|read_file_symbols
parameter_list|(
name|entry
parameter_list|)
specifier|register
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
block|{
specifier|register
name|int
name|desc
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
name|struct
name|exec
name|hdr
decl_stmt|;
name|desc
operator|=
name|file_open
argument_list|(
name|entry
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COFF_ENCAPSULATE
if|if
condition|(
name|entry
operator|->
name|just_syms_flag
condition|)
name|lseek
argument_list|(
name|desc
argument_list|,
sizeof|sizeof
argument_list|(
name|coffheader
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|len
operator|=
name|read
argument_list|(
name|desc
argument_list|,
operator|&
name|hdr
argument_list|,
sizeof|sizeof
name|hdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
sizeof|sizeof
name|hdr
condition|)
name|fatal_with_file
argument_list|(
literal|"failure reading header of "
argument_list|,
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|N_BADMAG
argument_list|(
name|hdr
argument_list|)
condition|)
block|{
name|read_entry_symbols
argument_list|(
name|desc
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|entry
operator|->
name|strings
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|entry
operator|->
name|string_size
argument_list|)
expr_stmt|;
name|read_entry_strings
argument_list|(
name|desc
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|enter_file_symbols
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|entry
operator|->
name|strings
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|char
name|armag
index|[
name|SARMAG
index|]
decl_stmt|;
name|lseek
argument_list|(
name|desc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|SARMAG
operator|!=
name|read
argument_list|(
name|desc
argument_list|,
name|armag
argument_list|,
name|SARMAG
argument_list|)
operator|||
name|strncmp
argument_list|(
name|armag
argument_list|,
name|ARMAG
argument_list|,
name|SARMAG
argument_list|)
condition|)
name|fatal_with_file
argument_list|(
literal|"malformed input file (not rel or archive) "
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|entry
operator|->
name|library_flag
operator|=
literal|1
expr_stmt|;
name|search_library
argument_list|(
name|desc
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
name|file_close
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Enter the external symbol defs and refs of ENTRY in the hash table.  */
end_comment

begin_function
name|void
name|enter_file_symbols
parameter_list|(
name|entry
parameter_list|)
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
block|{
specifier|register
name|struct
name|nlist
modifier|*
name|p
decl_stmt|,
modifier|*
name|end
init|=
name|entry
operator|->
name|symbols
operator|+
name|entry
operator|->
name|header
operator|.
name|a_syms
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
decl_stmt|;
if|if
condition|(
name|trace_files
condition|)
name|prline_file_name
argument_list|(
name|entry
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|entry
operator|->
name|symbols
init|;
name|p
operator|<
name|end
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|p
operator|->
name|n_type
operator|==
operator|(
name|N_SETV
operator||
name|N_EXT
operator|)
condition|)
continue|continue;
if|if
condition|(
name|set_element_prefixes
operator|&&
name|set_element_prefixed_p
argument_list|(
name|p
operator|->
name|n_un
operator|.
name|n_strx
operator|+
name|entry
operator|->
name|strings
argument_list|)
condition|)
name|p
operator|->
name|n_type
operator|+=
operator|(
name|N_SETA
operator|-
name|N_ABS
operator|)
expr_stmt|;
if|if
condition|(
name|SET_ELEMENT_P
argument_list|(
name|p
operator|->
name|n_type
argument_list|)
condition|)
block|{
name|set_symbol_count
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|relocatable_output
condition|)
name|enter_global_ref
argument_list|(
name|p
argument_list|,
name|p
operator|->
name|n_un
operator|.
name|n_strx
operator|+
name|entry
operator|->
name|strings
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|n_type
operator|==
name|N_WARNING
condition|)
block|{
name|char
modifier|*
name|name
init|=
name|p
operator|->
name|n_un
operator|.
name|n_strx
operator|+
name|entry
operator|->
name|strings
decl_stmt|;
comment|/* Grab the next entry.  */
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|n_type
operator|!=
operator|(
name|N_UNDF
operator||
name|N_EXT
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Warning symbol found in %s without external reference following.\n"
argument_list|,
name|progname
argument_list|,
name|entry
operator|->
name|filename
argument_list|)
expr_stmt|;
name|make_executable
operator|=
literal|0
expr_stmt|;
name|p
operator|--
expr_stmt|;
comment|/* Process normally.  */
block|}
else|else
block|{
name|symbol
modifier|*
name|sp
decl_stmt|;
name|char
modifier|*
name|sname
init|=
name|p
operator|->
name|n_un
operator|.
name|n_strx
operator|+
name|entry
operator|->
name|strings
decl_stmt|;
comment|/* Deal with the warning symbol.  */
name|enter_global_ref
argument_list|(
name|p
argument_list|,
name|p
operator|->
name|n_un
operator|.
name|n_strx
operator|+
name|entry
operator|->
name|strings
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|sp
operator|=
name|getsym
argument_list|(
name|sname
argument_list|)
expr_stmt|;
name|sp
operator|->
name|warning
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|sp
operator|->
name|warning
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|warning_count
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|n_type
operator|&
name|N_EXT
condition|)
name|enter_global_ref
argument_list|(
name|p
argument_list|,
name|p
operator|->
name|n_un
operator|.
name|n_strx
operator|+
name|entry
operator|->
name|strings
argument_list|,
name|entry
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|n_un
operator|.
name|n_strx
operator|&&
operator|!
operator|(
name|p
operator|->
name|n_type
operator|&
operator|(
name|N_STAB
operator||
name|N_EXT
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|p
operator|->
name|n_un
operator|.
name|n_strx
operator|+
name|entry
operator|->
name|strings
operator|)
index|[
literal|0
index|]
operator|!=
name|LPREFIX
condition|)
name|non_L_local_sym_count
operator|++
expr_stmt|;
name|local_sym_count
operator|++
expr_stmt|;
block|}
else|else
name|debugger_sym_count
operator|++
expr_stmt|;
block|}
comment|/* Count one for the local symbol that we generate,       whose name is the file's name (usually) and whose address       is the start of the file's text.  */
name|local_sym_count
operator|++
expr_stmt|;
name|non_L_local_sym_count
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Enter one global symbol in the hash table.    NLIST_P points to the `struct nlist' read from the file    that describes the global symbol.  NAME is the symbol's name.    ENTRY is the file entry for the file the symbol comes from.     The `struct nlist' is modified by placing it on a chain of    all such structs that refer to the same global symbol.    This chain starts in the `refs' field of the symbol table entry    and is chained through the `n_name'.  */
end_comment

begin_function
name|void
name|enter_global_ref
parameter_list|(
name|nlist_p
parameter_list|,
name|name
parameter_list|,
name|entry
parameter_list|)
specifier|register
name|struct
name|nlist
modifier|*
name|nlist_p
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
block|{
specifier|register
name|symbol
modifier|*
name|sp
init|=
name|getsym
argument_list|(
name|name
argument_list|)
decl_stmt|;
specifier|register
name|int
name|type
init|=
name|nlist_p
operator|->
name|n_type
decl_stmt|;
name|int
name|oldref
init|=
name|sp
operator|->
name|referenced
decl_stmt|;
name|int
name|olddef
init|=
name|sp
operator|->
name|defined
decl_stmt|;
name|nlist_p
operator|->
name|n_un
operator|.
name|n_name
operator|=
operator|(
name|char
operator|*
operator|)
name|sp
operator|->
name|refs
expr_stmt|;
name|sp
operator|->
name|refs
operator|=
name|nlist_p
expr_stmt|;
name|sp
operator|->
name|referenced
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|type
operator|!=
operator|(
name|N_UNDF
operator||
name|N_EXT
operator|)
operator|||
name|nlist_p
operator|->
name|n_value
condition|)
block|{
if|if
condition|(
operator|!
name|sp
operator|->
name|defined
operator|||
name|sp
operator|->
name|defined
operator|==
operator|(
name|N_UNDF
operator||
name|N_EXT
operator|)
condition|)
name|sp
operator|->
name|defined
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|oldref
operator|&&
operator|!
name|olddef
condition|)
comment|/* It used to be undefined and we're defining it.  */
name|undefined_global_sym_count
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|olddef
operator|&&
name|type
operator|==
operator|(
name|N_UNDF
operator||
name|N_EXT
operator|)
operator|&&
name|nlist_p
operator|->
name|n_value
condition|)
block|{
comment|/* First definition and it's common.  */
name|common_defined_global_count
operator|++
expr_stmt|;
name|sp
operator|->
name|max_common_size
operator|=
name|nlist_p
operator|->
name|n_value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|olddef
operator|&&
name|sp
operator|->
name|max_common_size
operator|&&
name|type
operator|!=
operator|(
name|N_UNDF
operator||
name|N_EXT
operator|)
condition|)
block|{
comment|/* It used to be common and we're defining it as 	     something else.  */
name|common_defined_global_count
operator|--
expr_stmt|;
name|sp
operator|->
name|max_common_size
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|olddef
operator|&&
name|sp
operator|->
name|max_common_size
operator|&&
name|type
operator|==
operator|(
name|N_UNDF
operator||
name|N_EXT
operator|)
operator|&&
name|sp
operator|->
name|max_common_size
operator|<
name|nlist_p
operator|->
name|n_value
condition|)
comment|/* It used to be common and this is a new common entry to 	   which we need to pay attention.  */
name|sp
operator|->
name|max_common_size
operator|=
name|nlist_p
operator|->
name|n_value
expr_stmt|;
comment|/* Are we defining it as a set element?  */
if|if
condition|(
name|SET_ELEMENT_P
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
operator|!
name|olddef
operator|||
operator|(
name|olddef
operator|&&
name|sp
operator|->
name|max_common_size
operator|)
operator|)
condition|)
name|set_vector_count
operator|++
expr_stmt|;
comment|/* As an indirection?  */
elseif|else
if|if
condition|(
name|type
operator|==
operator|(
name|N_INDR
operator||
name|N_EXT
operator|)
condition|)
block|{
comment|/* Indirect symbols value should be modified to point 	     a symbol being equivalenced to. */
name|nlist_p
operator|->
name|n_value
operator|=
operator|(
name|unsigned
name|int
operator|)
name|getsym
argument_list|(
operator|(
name|nlist_p
operator|+
literal|1
operator|)
operator|->
name|n_un
operator|.
name|n_strx
operator|+
name|entry
operator|->
name|strings
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|symbol
operator|*
operator|)
name|nlist_p
operator|->
name|n_value
operator|==
name|sp
condition|)
block|{
comment|/* Somebody redefined a symbol to be itself.  */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Symbol %s indirected to itself.\n"
argument_list|,
name|entry
operator|->
name|filename
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Rewrite this symbol as being a global text symbol 		 with value 0.  */
name|nlist_p
operator|->
name|n_type
operator|=
name|sp
operator|->
name|defined
operator|=
name|N_TEXT
operator||
name|N_EXT
expr_stmt|;
name|nlist_p
operator|->
name|n_value
operator|=
literal|0
expr_stmt|;
comment|/* Don't make the output executable.  */
name|make_executable
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|global_indirect_count
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|oldref
condition|)
ifndef|#
directive|ifndef
name|DOLLAR_KLUDGE
name|undefined_global_sym_count
operator|++
expr_stmt|;
else|#
directive|else
block|{
if|if
condition|(
name|entry
operator|->
name|superfile
operator|&&
name|type
operator|==
operator|(
name|N_UNDF
operator||
name|N_EXT
operator|)
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'$'
condition|)
block|{
comment|/* This is an (ISI?) $-conditional; skip it */
name|sp
operator|->
name|referenced
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|trace
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"symbol %s is a $-conditional ignored in "
argument_list|,
name|sp
operator|->
name|name
argument_list|)
expr_stmt|;
name|print_file_name
argument_list|(
name|entry
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
else|else
name|undefined_global_sym_count
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|sp
operator|==
name|end_symbol
operator|&&
name|entry
operator|->
name|just_syms_flag
operator|&&
operator|!
name|T_flag_specified
operator|&&
operator|!
name|screwballmode
condition|)
name|text_start
operator|=
name|nlist_p
operator|->
name|n_value
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|trace
condition|)
block|{
specifier|register
name|char
modifier|*
name|reftype
decl_stmt|;
switch|switch
condition|(
name|type
operator|&
name|N_TYPE
condition|)
block|{
case|case
name|N_UNDF
case|:
if|if
condition|(
name|nlist_p
operator|->
name|n_value
condition|)
name|reftype
operator|=
literal|"defined as common"
expr_stmt|;
else|else
name|reftype
operator|=
literal|"referenced"
expr_stmt|;
break|break;
case|case
name|N_ABS
case|:
name|reftype
operator|=
literal|"defined as absolute"
expr_stmt|;
break|break;
case|case
name|N_TEXT
case|:
name|reftype
operator|=
literal|"defined in text section"
expr_stmt|;
break|break;
case|case
name|N_DATA
case|:
name|reftype
operator|=
literal|"defined in data section"
expr_stmt|;
break|break;
case|case
name|N_BSS
case|:
name|reftype
operator|=
literal|"defined in BSS section"
expr_stmt|;
break|break;
case|case
name|N_SETT
case|:
name|reftype
operator|=
literal|"is a text set element"
expr_stmt|;
break|break;
case|case
name|N_SETD
case|:
name|reftype
operator|=
literal|"is a data set element"
expr_stmt|;
break|break;
case|case
name|N_SETB
case|:
name|reftype
operator|=
literal|"is a BSS set element"
expr_stmt|;
break|break;
case|case
name|N_SETA
case|:
name|reftype
operator|=
literal|"is an absolute set element"
expr_stmt|;
break|break;
case|case
name|N_SETV
case|:
name|reftype
operator|=
literal|"defined in data section as vector"
expr_stmt|;
break|break;
case|case
name|N_INDR
case|:
name|reftype
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|23
operator|+
name|strlen
argument_list|(
operator|(
name|nlist_p
operator|+
literal|1
operator|)
operator|->
name|n_un
operator|.
name|n_strx
operator|+
name|entry
operator|->
name|strings
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|reftype
argument_list|,
literal|"defined equivalent to %s"
argument_list|,
operator|(
name|nlist_p
operator|+
literal|1
operator|)
operator|->
name|n_un
operator|.
name|n_strx
operator|+
name|entry
operator|->
name|strings
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|sequent
case|case
name|N_SHUNDF
case|:
name|reftype
operator|=
literal|"shared undf"
expr_stmt|;
break|break;
comment|/* These conflict with cases above. 	case N_SHDATA: 	  reftype = "shared data"; 	  break;  	case N_SHBSS: 	  reftype = "shared BSS"; 	  break; */
default|default:
name|reftype
operator|=
literal|"I don't know this type"
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"symbol %s %s in "
argument_list|,
name|sp
operator|->
name|name
argument_list|,
name|reftype
argument_list|)
expr_stmt|;
name|print_file_name
argument_list|(
name|entry
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This return 0 if the given file entry's symbol table does *not*    contain the nlist point entry, and it returns the files entry    pointer (cast to unsigned long) if it does. */
end_comment

begin_function
name|unsigned
name|long
name|contains_symbol
parameter_list|(
name|entry
parameter_list|,
name|n_ptr
parameter_list|)
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
specifier|register
name|struct
name|nlist
modifier|*
name|n_ptr
decl_stmt|;
block|{
if|if
condition|(
name|n_ptr
operator|>=
name|entry
operator|->
name|symbols
operator|&&
name|n_ptr
operator|<
operator|(
name|entry
operator|->
name|symbols
operator|+
operator|(
name|entry
operator|->
name|header
operator|.
name|a_syms
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
operator|)
operator|)
condition|)
return|return
operator|(
name|unsigned
name|long
operator|)
name|entry
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Searching libraries */
end_comment

begin_function_decl
name|struct
name|file_entry
modifier|*
name|decode_library_subfile
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|void
name|linear_library
argument_list|()
decl_stmt|,
name|symdef_library
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Search the library ENTRY, already open on descriptor DESC.    This means deciding which library members to load,    making a chain of `struct file_entry' for those members,    and entering their global symbols in the hash table.  */
end_comment

begin_function
name|void
name|search_library
parameter_list|(
name|desc
parameter_list|,
name|entry
parameter_list|)
name|int
name|desc
decl_stmt|;
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
block|{
name|int
name|member_length
decl_stmt|;
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|struct
name|file_entry
modifier|*
name|subentry
decl_stmt|;
if|if
condition|(
operator|!
name|undefined_global_sym_count
condition|)
return|return;
comment|/* Examine its first member, which starts SARMAG bytes in.  */
name|subentry
operator|=
name|decode_library_subfile
argument_list|(
name|desc
argument_list|,
name|entry
argument_list|,
name|SARMAG
argument_list|,
operator|&
name|member_length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|subentry
condition|)
return|return;
name|name
operator|=
name|subentry
operator|->
name|filename
expr_stmt|;
name|free
argument_list|(
name|subentry
argument_list|)
expr_stmt|;
comment|/* Search via __.SYMDEF if that exists, else linearly.  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"__.SYMDEF"
argument_list|)
condition|)
name|symdef_library
argument_list|(
name|desc
argument_list|,
name|entry
argument_list|,
name|member_length
argument_list|)
expr_stmt|;
else|else
name|linear_library
argument_list|(
name|desc
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Construct and return a file_entry for a library member.    The library's file_entry is library_entry, and the library is open on DESC.    SUBFILE_OFFSET is the byte index in the library of this member's header.    We store the length of the member into *LENGTH_LOC.  */
end_comment

begin_function
name|struct
name|file_entry
modifier|*
name|decode_library_subfile
parameter_list|(
name|desc
parameter_list|,
name|library_entry
parameter_list|,
name|subfile_offset
parameter_list|,
name|length_loc
parameter_list|)
name|int
name|desc
decl_stmt|;
name|struct
name|file_entry
modifier|*
name|library_entry
decl_stmt|;
name|int
name|subfile_offset
decl_stmt|;
name|int
modifier|*
name|length_loc
decl_stmt|;
block|{
name|int
name|bytes_read
decl_stmt|;
specifier|register
name|int
name|namelen
decl_stmt|;
name|int
name|member_length
decl_stmt|;
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|ar_hdr
name|hdr1
decl_stmt|;
specifier|register
name|struct
name|file_entry
modifier|*
name|subentry
decl_stmt|;
name|lseek
argument_list|(
name|desc
argument_list|,
name|subfile_offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bytes_read
operator|=
name|read
argument_list|(
name|desc
argument_list|,
operator|&
name|hdr1
argument_list|,
sizeof|sizeof
name|hdr1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bytes_read
condition|)
return|return
literal|0
return|;
comment|/* end of archive */
if|if
condition|(
sizeof|sizeof
name|hdr1
operator|!=
name|bytes_read
condition|)
name|fatal_with_file
argument_list|(
literal|"malformed library archive "
argument_list|,
name|library_entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
name|hdr1
operator|.
name|ar_size
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|member_length
argument_list|)
operator|!=
literal|1
condition|)
name|fatal_with_file
argument_list|(
literal|"malformatted header of archive member in "
argument_list|,
name|library_entry
argument_list|)
expr_stmt|;
name|subentry
operator|=
operator|(
expr|struct
name|file_entry
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|file_entry
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|subentry
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|file_entry
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|namelen
operator|=
literal|0
init|;
name|namelen
operator|<
sizeof|sizeof
name|hdr1
operator|.
name|ar_name
operator|&&
name|hdr1
operator|.
name|ar_name
index|[
name|namelen
index|]
operator|!=
literal|0
operator|&&
name|hdr1
operator|.
name|ar_name
index|[
name|namelen
index|]
operator|!=
literal|' '
operator|&&
name|hdr1
operator|.
name|ar_name
index|[
name|namelen
index|]
operator|!=
literal|'/'
condition|;
name|namelen
operator|++
control|)
empty_stmt|;
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|namelen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|name
argument_list|,
name|hdr1
operator|.
name|ar_name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
name|name
index|[
name|namelen
index|]
operator|=
literal|0
expr_stmt|;
name|subentry
operator|->
name|filename
operator|=
name|name
expr_stmt|;
name|subentry
operator|->
name|local_sym_name
operator|=
name|name
expr_stmt|;
name|subentry
operator|->
name|symbols
operator|=
literal|0
expr_stmt|;
name|subentry
operator|->
name|strings
operator|=
literal|0
expr_stmt|;
name|subentry
operator|->
name|subfiles
operator|=
literal|0
expr_stmt|;
name|subentry
operator|->
name|starting_offset
operator|=
name|subfile_offset
operator|+
sizeof|sizeof
name|hdr1
expr_stmt|;
name|subentry
operator|->
name|superfile
operator|=
name|library_entry
expr_stmt|;
name|subentry
operator|->
name|library_flag
operator|=
literal|0
expr_stmt|;
name|subentry
operator|->
name|header_read_flag
operator|=
literal|0
expr_stmt|;
name|subentry
operator|->
name|just_syms_flag
operator|=
literal|0
expr_stmt|;
name|subentry
operator|->
name|chain
operator|=
literal|0
expr_stmt|;
name|subentry
operator|->
name|total_size
operator|=
name|member_length
expr_stmt|;
operator|(
operator|*
name|length_loc
operator|)
operator|=
name|member_length
expr_stmt|;
return|return
name|subentry
return|;
block|}
end_function

begin_escape
end_escape

begin_function_decl
name|int
name|subfile_wanted_p
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Search a library that has a __.SYMDEF member.    DESC is a descriptor on which the library is open.      The file pointer is assumed to point at the __.SYMDEF data.    ENTRY is the library's file_entry.    MEMBER_LENGTH is the length of the __.SYMDEF data.  */
end_comment

begin_function
name|void
name|symdef_library
parameter_list|(
name|desc
parameter_list|,
name|entry
parameter_list|,
name|member_length
parameter_list|)
name|int
name|desc
decl_stmt|;
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
name|int
name|member_length
decl_stmt|;
block|{
name|int
modifier|*
name|symdef_data
init|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|member_length
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|symdef
modifier|*
name|symdef_base
decl_stmt|;
name|char
modifier|*
name|sym_name_base
decl_stmt|;
name|int
name|number_of_symdefs
decl_stmt|;
name|int
name|length_of_strings
decl_stmt|;
name|int
name|not_finished
decl_stmt|;
name|int
name|bytes_read
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|file_entry
modifier|*
name|prev
init|=
literal|0
decl_stmt|;
name|int
name|prev_offset
init|=
literal|0
decl_stmt|;
name|bytes_read
operator|=
name|read
argument_list|(
name|desc
argument_list|,
name|symdef_data
argument_list|,
name|member_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_read
operator|!=
name|member_length
condition|)
name|fatal_with_file
argument_list|(
literal|"malformatted __.SYMDEF in "
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|number_of_symdefs
operator|=
operator|*
name|symdef_data
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|symdef
argument_list|)
expr_stmt|;
if|if
condition|(
name|number_of_symdefs
operator|<
literal|0
operator|||
name|number_of_symdefs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|symdef
argument_list|)
operator|+
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|>
name|member_length
condition|)
name|fatal_with_file
argument_list|(
literal|"malformatted __.SYMDEF in "
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|symdef_base
operator|=
operator|(
expr|struct
name|symdef
operator|*
operator|)
operator|(
name|symdef_data
operator|+
literal|1
operator|)
expr_stmt|;
name|length_of_strings
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|(
name|symdef_base
operator|+
name|number_of_symdefs
operator|)
expr_stmt|;
if|if
condition|(
name|length_of_strings
operator|<
literal|0
operator|||
name|number_of_symdefs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|symdef
argument_list|)
operator|+
name|length_of_strings
operator|+
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|>
name|member_length
condition|)
name|fatal_with_file
argument_list|(
literal|"malformatted __.SYMDEF in "
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|sym_name_base
operator|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|+
operator|(
name|char
operator|*
operator|)
operator|(
name|symdef_base
operator|+
name|number_of_symdefs
operator|)
expr_stmt|;
comment|/* Check all the string indexes for validity.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|number_of_symdefs
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|int
name|index
init|=
name|symdef_base
index|[
name|i
index|]
operator|.
name|symbol_name_string_index
decl_stmt|;
if|if
condition|(
name|index
operator|<
literal|0
operator|||
name|index
operator|>=
name|length_of_strings
operator|||
operator|(
name|index
operator|&&
operator|*
operator|(
name|sym_name_base
operator|+
name|index
operator|-
literal|1
operator|)
operator|)
condition|)
name|fatal_with_file
argument_list|(
literal|"malformatted __.SYMDEF in "
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
comment|/* Search the symdef data for members to load.      Do this until one whole pass finds nothing to load.  */
name|not_finished
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|not_finished
condition|)
block|{
name|not_finished
operator|=
literal|0
expr_stmt|;
comment|/* Scan all the symbols mentioned in the symdef for ones that we need. 	 Load the library members that contain such symbols.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|number_of_symdefs
operator|&&
operator|(
name|undefined_global_sym_count
operator|||
name|common_defined_global_count
operator|)
operator|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|symdef_base
index|[
name|i
index|]
operator|.
name|symbol_name_string_index
operator|>=
literal|0
condition|)
block|{
specifier|register
name|symbol
modifier|*
name|sp
decl_stmt|;
name|sp
operator|=
name|getsym_soft
argument_list|(
name|sym_name_base
operator|+
name|symdef_base
index|[
name|i
index|]
operator|.
name|symbol_name_string_index
argument_list|)
expr_stmt|;
comment|/* If we find a symbol that appears to be needed, think carefully 	       about the archive member that the symbol is in.  */
if|if
condition|(
name|sp
operator|&&
operator|(
operator|(
name|sp
operator|->
name|referenced
operator|&&
operator|!
name|sp
operator|->
name|defined
operator|)
operator|||
operator|(
name|sp
operator|->
name|defined
operator|&&
name|sp
operator|->
name|max_common_size
operator|)
operator|)
condition|)
block|{
name|int
name|junk
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|int
name|offset
init|=
name|symdef_base
index|[
name|i
index|]
operator|.
name|library_member_offset
decl_stmt|;
name|struct
name|file_entry
modifier|*
name|subentry
decl_stmt|;
comment|/* Don't think carefully about any archive member 		   more than once in a given pass.  */
if|if
condition|(
name|prev_offset
operator|==
name|offset
condition|)
continue|continue;
name|prev_offset
operator|=
name|offset
expr_stmt|;
comment|/* Read the symbol table of the archive member.  */
name|subentry
operator|=
name|decode_library_subfile
argument_list|(
name|desc
argument_list|,
name|entry
argument_list|,
name|offset
argument_list|,
operator|&
name|junk
argument_list|)
expr_stmt|;
if|if
condition|(
name|subentry
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"invalid offset for %s in symbol table of %s"
argument_list|,
name|sym_name_base
operator|+
name|symdef_base
index|[
name|i
index|]
operator|.
name|symbol_name_string_index
argument_list|,
name|entry
operator|->
name|filename
argument_list|)
expr_stmt|;
name|read_entry_symbols
argument_list|(
name|desc
argument_list|,
name|subentry
argument_list|)
expr_stmt|;
name|subentry
operator|->
name|strings
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|subentry
operator|->
name|string_size
argument_list|)
expr_stmt|;
name|read_entry_strings
argument_list|(
name|desc
argument_list|,
name|subentry
argument_list|)
expr_stmt|;
comment|/* Now scan the symbol table and decide whether to load.  */
if|if
condition|(
operator|!
name|subfile_wanted_p
argument_list|(
name|subentry
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|subentry
operator|->
name|symbols
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|subentry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This member is needed; load it. 		       Since we are loading something on this pass, 		       we must make another pass through the symdef data.  */
name|not_finished
operator|=
literal|1
expr_stmt|;
name|enter_file_symbols
argument_list|(
name|subentry
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|chain
operator|=
name|subentry
expr_stmt|;
else|else
name|entry
operator|->
name|subfiles
operator|=
name|subentry
expr_stmt|;
name|prev
operator|=
name|subentry
expr_stmt|;
comment|/* Clear out this member's symbols from the symdef data 		       so that following passes won't waste time on them.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|number_of_symdefs
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|symdef_base
index|[
name|j
index|]
operator|.
name|library_member_offset
operator|==
name|offset
condition|)
name|symdef_base
index|[
name|j
index|]
operator|.
name|symbol_name_string_index
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
comment|/* We'll read the strings again if we need them again.  */
name|free
argument_list|(
name|subentry
operator|->
name|strings
argument_list|)
expr_stmt|;
name|subentry
operator|->
name|strings
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
name|free
argument_list|(
name|symdef_data
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Search a library that has no __.SYMDEF.    ENTRY is the library's file_entry.    DESC is the descriptor it is open on.  */
end_comment

begin_function
name|void
name|linear_library
parameter_list|(
name|desc
parameter_list|,
name|entry
parameter_list|)
name|int
name|desc
decl_stmt|;
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
block|{
specifier|register
name|struct
name|file_entry
modifier|*
name|prev
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|this_subfile_offset
init|=
name|SARMAG
decl_stmt|;
while|while
condition|(
name|undefined_global_sym_count
operator|||
name|common_defined_global_count
condition|)
block|{
name|int
name|member_length
decl_stmt|;
specifier|register
name|struct
name|file_entry
modifier|*
name|subentry
decl_stmt|;
name|subentry
operator|=
name|decode_library_subfile
argument_list|(
name|desc
argument_list|,
name|entry
argument_list|,
name|this_subfile_offset
argument_list|,
operator|&
name|member_length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|subentry
condition|)
return|return;
name|read_entry_symbols
argument_list|(
name|desc
argument_list|,
name|subentry
argument_list|)
expr_stmt|;
name|subentry
operator|->
name|strings
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|subentry
operator|->
name|string_size
argument_list|)
expr_stmt|;
name|read_entry_strings
argument_list|(
name|desc
argument_list|,
name|subentry
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|subfile_wanted_p
argument_list|(
name|subentry
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|subentry
operator|->
name|symbols
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|subentry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|enter_file_symbols
argument_list|(
name|subentry
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|chain
operator|=
name|subentry
expr_stmt|;
else|else
name|entry
operator|->
name|subfiles
operator|=
name|subentry
expr_stmt|;
name|prev
operator|=
name|subentry
expr_stmt|;
name|subentry
operator|->
name|strings
operator|=
literal|0
expr_stmt|;
comment|/* Since space will dissapear on return */
block|}
name|this_subfile_offset
operator|+=
name|member_length
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_subfile_offset
operator|&
literal|1
condition|)
name|this_subfile_offset
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ENTRY is an entry for a library member.    Its symbols have been read into core, but not entered.    Return nonzero if we ought to load this member.  */
end_comment

begin_function
name|int
name|subfile_wanted_p
parameter_list|(
name|entry
parameter_list|)
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
block|{
specifier|register
name|struct
name|nlist
modifier|*
name|p
decl_stmt|;
specifier|register
name|struct
name|nlist
modifier|*
name|end
init|=
name|entry
operator|->
name|symbols
operator|+
name|entry
operator|->
name|header
operator|.
name|a_syms
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|DOLLAR_KLUDGE
specifier|register
name|int
name|dollar_cond
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
for|for
control|(
name|p
operator|=
name|entry
operator|->
name|symbols
init|;
name|p
operator|<
name|end
condition|;
name|p
operator|++
control|)
block|{
specifier|register
name|int
name|type
init|=
name|p
operator|->
name|n_type
decl_stmt|;
specifier|register
name|char
modifier|*
name|name
init|=
name|p
operator|->
name|n_un
operator|.
name|n_strx
operator|+
name|entry
operator|->
name|strings
decl_stmt|;
comment|/* If the symbol has an interesting definition, we could 	 potentially want it.  */
if|if
condition|(
name|type
operator|&
name|N_EXT
operator|&&
operator|(
name|type
operator|!=
operator|(
name|N_UNDF
operator||
name|N_EXT
operator|)
operator|||
name|p
operator|->
name|n_value
ifdef|#
directive|ifdef
name|DOLLAR_KLUDGE
operator|||
name|name
index|[
literal|1
index|]
operator|==
literal|'$'
endif|#
directive|endif
operator|)
operator|&&
operator|!
name|SET_ELEMENT_P
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|set_element_prefixed_p
argument_list|(
name|name
argument_list|)
condition|)
block|{
specifier|register
name|symbol
modifier|*
name|sp
init|=
name|getsym_soft
argument_list|(
name|name
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|DOLLAR_KLUDGE
if|if
condition|(
name|name
index|[
literal|1
index|]
operator|==
literal|'$'
condition|)
block|{
name|sp
operator|=
name|getsym_soft
argument_list|(
operator|&
name|name
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|dollar_cond
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|sp
condition|)
continue|continue;
if|if
condition|(
name|sp
operator|->
name|referenced
condition|)
block|{
if|if
condition|(
name|write_map
condition|)
block|{
name|print_file_name
argument_list|(
name|entry
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|" needed due to $-conditional %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
continue|continue;
block|}
endif|#
directive|endif
comment|/* If this symbol has not been hashed, we can't be looking for it. */
if|if
condition|(
operator|!
name|sp
condition|)
continue|continue;
if|if
condition|(
operator|(
name|sp
operator|->
name|referenced
operator|&&
operator|!
name|sp
operator|->
name|defined
operator|)
operator|||
operator|(
name|sp
operator|->
name|defined
operator|&&
name|sp
operator|->
name|max_common_size
operator|&&
operator|(
name|type
operator|&
name|N_TEXT
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* This is a symbol we are looking for.  It is either 	         not yet defined or defined as a common.  */
ifdef|#
directive|ifdef
name|DOLLAR_KLUDGE
if|if
condition|(
name|dollar_cond
condition|)
continue|continue;
endif|#
directive|endif
if|if
condition|(
name|type
operator|==
operator|(
name|N_UNDF
operator||
name|N_EXT
operator|)
condition|)
block|{
comment|/* Symbol being defined as common. 		     Remember this, but don't load subfile just for this.  */
comment|/* If it didn't used to be common, up the count of 		     common symbols.  */
if|if
condition|(
operator|!
name|sp
operator|->
name|max_common_size
condition|)
name|common_defined_global_count
operator|++
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|max_common_size
operator|<
name|p
operator|->
name|n_value
condition|)
name|sp
operator|->
name|max_common_size
operator|=
name|p
operator|->
name|n_value
expr_stmt|;
if|if
condition|(
operator|!
name|sp
operator|->
name|defined
condition|)
name|undefined_global_sym_count
operator|--
expr_stmt|;
name|sp
operator|->
name|defined
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|write_map
condition|)
block|{
name|print_file_name
argument_list|(
name|entry
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|" needed due to %s\n"
argument_list|,
name|sp
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
name|void
name|consider_file_section_lengths
argument_list|()
decl_stmt|,
name|relocate_file_addresses
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Having entered all the global symbols and found the sizes of sections    of all files to be linked, make all appropriate deductions from this data.     We propagate global symbol values from definitions to references.    We compute the layout of the output file and where each input file's    contents fit into it.  */
end_comment

begin_function
name|void
name|digest_symbols
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|setv_fill_count
decl_stmt|;
if|if
condition|(
name|trace_files
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Digesting symbol information:\n\n"
argument_list|)
expr_stmt|;
comment|/* Compute total size of sections */
name|each_file
argument_list|(
name|consider_file_section_lengths
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If necessary, pad text section to full page in the file.      Include the padding in the text segment size.  */
if|if
condition|(
name|magic
operator|==
name|ZMAGIC
condition|)
block|{
name|int
name|text_end
init|=
name|text_size
operator|+
name|N_TXTOFF
argument_list|(
name|outheader
argument_list|)
decl_stmt|;
name|text_pad
operator|=
operator|(
operator|(
name|text_end
operator|+
name|page_size
operator|-
literal|1
operator|)
operator|&
operator|(
operator|-
name|page_size
operator|)
operator|)
operator|-
name|text_end
expr_stmt|;
name|text_size
operator|+=
name|text_pad
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|_N_BASEADDR
comment|/* SunOS 4.1 N_TXTADDR depends on the value of outheader.a_entry.  */
name|outheader
operator|.
name|a_entry
operator|=
name|N_PAGSIZ
argument_list|(
name|outheader
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|outheader
operator|.
name|a_text
operator|=
name|text_size
expr_stmt|;
ifdef|#
directive|ifdef
name|sequent
name|outheader
operator|.
name|a_text
operator|+=
name|N_ADDRADJ
argument_list|(
name|outheader
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Make the data segment address start in memory on a suitable boundary.  */
if|if
condition|(
operator|!
name|Tdata_flag_specified
condition|)
name|data_start
operator|=
name|N_DATADDR
argument_list|(
name|outheader
argument_list|)
operator|+
name|text_start
operator|-
name|TEXT_START
argument_list|(
name|outheader
argument_list|)
expr_stmt|;
comment|/* Set up the set element vector */
if|if
condition|(
operator|!
name|relocatable_output
condition|)
block|{
comment|/* The set sector size is the number of set elements + a word          for each symbol for the length word at the beginning of the 	 vector, plus a word for each symbol for a zero at the end of 	 the vector (for incremental linking).  */
name|set_sect_size
operator|=
operator|(
literal|2
operator|*
name|set_symbol_count
operator|+
name|set_vector_count
operator|)
operator|*
expr|sizeof
operator|(
name|unsigned
name|long
operator|)
expr_stmt|;
name|set_sect_start
operator|=
name|data_start
operator|+
name|data_size
expr_stmt|;
name|data_size
operator|+=
name|set_sect_size
expr_stmt|;
name|set_vectors
operator|=
operator|(
name|unsigned
name|long
operator|*
operator|)
name|xmalloc
argument_list|(
name|set_sect_size
argument_list|)
expr_stmt|;
name|setv_fill_count
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Compute start addresses of each file's sections and symbols.  */
name|each_full_file
argument_list|(
name|relocate_file_addresses
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Now, for each symbol, verify that it is defined globally at most once.      Put the global value into the symbol entry.      Common symbols are allocated here, in the BSS section.      Each defined symbol is given a '->defined' field       which is the correct N_ code for its definition,       except in the case of common symbols with -r.      Then make all the references point at the symbol entry      instead of being chained together. */
name|defined_global_sym_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TABSIZE
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|symbol
modifier|*
name|sp
decl_stmt|;
for|for
control|(
name|sp
operator|=
name|symtab
index|[
name|i
index|]
init|;
name|sp
condition|;
name|sp
operator|=
name|sp
operator|->
name|link
control|)
block|{
comment|/* For each symbol */
specifier|register
name|struct
name|nlist
modifier|*
name|p
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|int
name|defs
init|=
literal|0
decl_stmt|,
name|com
init|=
name|sp
operator|->
name|max_common_size
decl_stmt|;
name|struct
name|nlist
modifier|*
name|first_definition
decl_stmt|;
for|for
control|(
name|p
operator|=
name|sp
operator|->
name|refs
init|;
name|p
condition|;
name|p
operator|=
name|next
control|)
block|{
specifier|register
name|int
name|type
init|=
name|p
operator|->
name|n_type
decl_stmt|;
if|if
condition|(
name|SET_ELEMENT_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|relocatable_output
condition|)
name|fatal
argument_list|(
literal|"internal: global ref to set element with -r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|defs
operator|++
condition|)
block|{
name|sp
operator|->
name|value
operator|=
name|set_sect_start
operator|+
name|setv_fill_count
operator|++
operator|*
expr|sizeof
operator|(
name|unsigned
name|long
operator|)
expr_stmt|;
name|sp
operator|->
name|defined
operator|=
name|N_SETV
operator||
name|N_EXT
expr_stmt|;
name|first_definition
operator|=
name|p
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|sp
operator|->
name|defined
operator|&
operator|~
name|N_EXT
operator|)
operator|!=
name|N_SETV
condition|)
block|{
name|sp
operator|->
name|multiply_defined
operator|=
literal|1
expr_stmt|;
name|multiple_def_count
operator|++
expr_stmt|;
block|}
name|set_vectors
index|[
name|setv_fill_count
operator|++
index|]
operator|=
name|p
operator|->
name|n_value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|type
operator|&
name|N_EXT
operator|)
operator|&&
name|type
operator|!=
operator|(
name|N_UNDF
operator||
name|N_EXT
operator|)
operator|&&
operator|(
name|type
operator|&
name|N_TYPE
operator|)
operator|!=
name|N_FN
condition|)
block|{
comment|/* non-common definition */
if|if
condition|(
name|defs
operator|++
operator|&&
name|sp
operator|->
name|value
operator|!=
name|p
operator|->
name|n_value
condition|)
block|{
name|sp
operator|->
name|multiply_defined
operator|=
literal|1
expr_stmt|;
name|multiple_def_count
operator|++
expr_stmt|;
block|}
name|sp
operator|->
name|value
operator|=
name|p
operator|->
name|n_value
expr_stmt|;
name|sp
operator|->
name|defined
operator|=
name|type
expr_stmt|;
name|first_definition
operator|=
name|p
expr_stmt|;
block|}
name|next
operator|=
operator|(
expr|struct
name|nlist
operator|*
operator|)
name|p
operator|->
name|n_un
operator|.
name|n_name
expr_stmt|;
name|p
operator|->
name|n_un
operator|.
name|n_name
operator|=
operator|(
name|char
operator|*
operator|)
name|sp
expr_stmt|;
block|}
comment|/* Allocate as common if defined as common and not defined for real */
if|if
condition|(
name|com
operator|&&
operator|!
name|defs
condition|)
block|{
if|if
condition|(
operator|!
name|relocatable_output
operator|||
name|force_common_definition
condition|)
block|{
name|int
name|align
init|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
decl_stmt|;
comment|/* Round up to nearest sizeof (int).  I don't know 		     whether this is necessary or not (given that 		     alignment is taken care of later), but it's 		     traditional, so I'll leave it in.  Note that if 		     this size alignment is ever removed, ALIGN above 		     will have to be initialized to 1 instead of 		     sizeof (int).  */
name|com
operator|=
operator|(
name|com
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
operator|)
operator|&
operator|(
operator|-
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|com
operator|&
name|align
operator|)
condition|)
name|align
operator|<<=
literal|1
expr_stmt|;
name|align
operator|=
name|align
operator|>
name|MAX_ALIGNMENT
condition|?
name|MAX_ALIGNMENT
else|:
name|align
expr_stmt|;
name|bss_size
operator|=
operator|(
operator|(
operator|(
operator|(
name|bss_size
operator|+
name|data_size
operator|+
name|data_start
operator|)
operator|+
operator|(
name|align
operator|-
literal|1
operator|)
operator|)
operator|&
operator|(
operator|-
name|align
operator|)
operator|)
operator|-
name|data_size
operator|-
name|data_start
operator|)
expr_stmt|;
name|sp
operator|->
name|value
operator|=
name|data_start
operator|+
name|data_size
operator|+
name|bss_size
expr_stmt|;
name|sp
operator|->
name|defined
operator|=
name|N_BSS
operator||
name|N_EXT
expr_stmt|;
name|bss_size
operator|+=
name|com
expr_stmt|;
if|if
condition|(
name|write_map
condition|)
name|printf
argument_list|(
literal|"Allocating common %s: %x at %x\n"
argument_list|,
name|sp
operator|->
name|name
argument_list|,
name|com
argument_list|,
name|sp
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sp
operator|->
name|defined
operator|=
literal|0
expr_stmt|;
name|undefined_global_sym_count
operator|++
expr_stmt|;
block|}
block|}
comment|/* Set length word at front of vector and zero byte at end. 	     Reverse the vector itself to put it in file order.  */
if|if
condition|(
operator|(
name|sp
operator|->
name|defined
operator|&
operator|~
name|N_EXT
operator|)
operator|==
name|N_SETV
condition|)
block|{
name|unsigned
name|long
name|length_word_index
init|=
operator|(
name|sp
operator|->
name|value
operator|-
name|set_sect_start
operator|)
operator|/
expr|sizeof
operator|(
name|unsigned
name|long
operator|)
decl_stmt|;
name|unsigned
name|long
name|i
decl_stmt|,
name|tmp
decl_stmt|;
name|set_vectors
index|[
name|length_word_index
index|]
operator|=
name|setv_fill_count
operator|-
literal|1
operator|-
name|length_word_index
expr_stmt|;
comment|/* Reverse the vector.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
operator|(
name|setv_fill_count
operator|-
name|length_word_index
operator|-
literal|1
operator|)
operator|/
literal|2
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|tmp
operator|=
name|set_vectors
index|[
name|length_word_index
operator|+
name|i
index|]
expr_stmt|;
name|set_vectors
index|[
name|length_word_index
operator|+
name|i
index|]
operator|=
name|set_vectors
index|[
name|setv_fill_count
operator|-
name|i
index|]
expr_stmt|;
name|set_vectors
index|[
name|setv_fill_count
operator|-
name|i
index|]
operator|=
name|tmp
expr_stmt|;
block|}
name|set_vectors
index|[
name|setv_fill_count
operator|++
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|->
name|defined
condition|)
name|defined_global_sym_count
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|end_symbol
condition|)
comment|/* These are null if -r.  */
block|{
name|etext_symbol
operator|->
name|value
operator|=
name|text_size
operator|+
name|text_start
expr_stmt|;
name|edata_symbol
operator|->
name|value
operator|=
name|data_start
operator|+
name|data_size
expr_stmt|;
name|end_symbol
operator|->
name|value
operator|=
name|data_start
operator|+
name|data_size
operator|+
name|bss_size
expr_stmt|;
block|}
comment|/* Figure the data_pad now, so that it overlaps with the bss addresses.  */
if|if
condition|(
name|specified_data_size
operator|&&
name|specified_data_size
operator|>
name|data_size
condition|)
name|data_pad
operator|=
name|specified_data_size
operator|-
name|data_size
expr_stmt|;
if|if
condition|(
name|magic
operator|==
name|ZMAGIC
condition|)
name|data_pad
operator|=
operator|(
operator|(
name|data_pad
operator|+
name|data_size
operator|+
name|page_size
operator|-
literal|1
operator|)
operator|&
operator|(
operator|-
name|page_size
operator|)
operator|)
operator|-
name|data_size
expr_stmt|;
name|bss_size
operator|-=
name|data_pad
expr_stmt|;
if|if
condition|(
name|bss_size
operator|<
literal|0
condition|)
name|bss_size
operator|=
literal|0
expr_stmt|;
name|data_size
operator|+=
name|data_pad
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Accumulate the section sizes of input file ENTRY    into the section sizes of the output file.  */
end_comment

begin_function
name|void
name|consider_file_section_lengths
parameter_list|(
name|entry
parameter_list|)
specifier|register
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
block|{
if|if
condition|(
name|entry
operator|->
name|just_syms_flag
condition|)
return|return;
name|entry
operator|->
name|text_start_address
operator|=
name|text_size
expr_stmt|;
comment|/* If there were any vectors, we need to chop them off */
name|text_size
operator|+=
name|entry
operator|->
name|header
operator|.
name|a_text
expr_stmt|;
name|entry
operator|->
name|data_start_address
operator|=
name|data_size
expr_stmt|;
name|data_size
operator|+=
name|entry
operator|->
name|header
operator|.
name|a_data
expr_stmt|;
name|entry
operator|->
name|bss_start_address
operator|=
name|bss_size
expr_stmt|;
name|bss_size
operator|+=
name|entry
operator|->
name|header
operator|.
name|a_bss
expr_stmt|;
name|text_reloc_size
operator|+=
name|entry
operator|->
name|header
operator|.
name|a_trsize
expr_stmt|;
name|data_reloc_size
operator|+=
name|entry
operator|->
name|header
operator|.
name|a_drsize
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Determine where the sections of ENTRY go into the output file,    whose total section sizes are already known.    Also relocate the addresses of the file's local and debugger symbols.  */
end_comment

begin_function
name|void
name|relocate_file_addresses
parameter_list|(
name|entry
parameter_list|)
specifier|register
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
block|{
name|entry
operator|->
name|text_start_address
operator|+=
name|text_start
expr_stmt|;
comment|/* Note that `data_start' and `data_size' have not yet been      adjusted for `data_pad'.  If they had been, we would get the wrong      results here.  */
name|entry
operator|->
name|data_start_address
operator|+=
name|data_start
expr_stmt|;
name|entry
operator|->
name|bss_start_address
operator|+=
name|data_start
operator|+
name|data_size
expr_stmt|;
block|{
specifier|register
name|struct
name|nlist
modifier|*
name|p
decl_stmt|;
specifier|register
name|struct
name|nlist
modifier|*
name|end
init|=
name|entry
operator|->
name|symbols
operator|+
name|entry
operator|->
name|header
operator|.
name|a_syms
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
decl_stmt|;
for|for
control|(
name|p
operator|=
name|entry
operator|->
name|symbols
init|;
name|p
operator|<
name|end
condition|;
name|p
operator|++
control|)
block|{
comment|/* If this belongs to a section, update it by the section's start address */
specifier|register
name|int
name|type
init|=
name|p
operator|->
name|n_type
operator|&
name|N_TYPE
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|N_TEXT
case|:
case|case
name|N_SETT
case|:
name|p
operator|->
name|n_value
operator|+=
name|entry
operator|->
name|text_start_address
expr_stmt|;
break|break;
case|case
name|N_DATA
case|:
case|case
name|N_SETV
case|:
case|case
name|N_SETD
case|:
comment|/* A symbol whose value is in the data section 	       is present in the input file as if the data section 	       started at an address equal to the length of the file's text.  */
name|p
operator|->
name|n_value
operator|+=
name|entry
operator|->
name|data_start_address
operator|-
name|entry
operator|->
name|header
operator|.
name|a_text
expr_stmt|;
break|break;
case|case
name|N_BSS
case|:
case|case
name|N_SETB
case|:
comment|/* likewise for symbols with value in BSS.  */
name|p
operator|->
name|n_value
operator|+=
name|entry
operator|->
name|bss_start_address
operator|-
name|entry
operator|->
name|header
operator|.
name|a_text
operator|-
name|entry
operator|->
name|header
operator|.
name|a_data
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
name|void
name|describe_file_sections
argument_list|()
decl_stmt|,
name|list_file_locals
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print a complete or partial map of the output file.  */
end_comment

begin_function
name|void
name|print_symbols
parameter_list|(
name|outfile
parameter_list|)
name|FILE
modifier|*
name|outfile
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\nFiles:\n\n"
argument_list|)
expr_stmt|;
name|each_file
argument_list|(
name|describe_file_sections
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\nGlobal symbols:\n\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TABSIZE
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|symbol
modifier|*
name|sp
decl_stmt|;
for|for
control|(
name|sp
operator|=
name|symtab
index|[
name|i
index|]
init|;
name|sp
condition|;
name|sp
operator|=
name|sp
operator|->
name|link
control|)
block|{
if|if
condition|(
name|sp
operator|->
name|defined
operator|==
literal|1
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"  %s: common, length 0x%x\n"
argument_list|,
name|sp
operator|->
name|name
argument_list|,
name|sp
operator|->
name|max_common_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|defined
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"  %s: 0x%x\n"
argument_list|,
name|sp
operator|->
name|name
argument_list|,
name|sp
operator|->
name|value
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sp
operator|->
name|referenced
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"  %s: undefined\n"
argument_list|,
name|sp
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
name|each_file
argument_list|(
name|list_file_locals
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|describe_file_sections
parameter_list|(
name|entry
parameter_list|,
name|outfile
parameter_list|)
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
name|FILE
modifier|*
name|outfile
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"  "
argument_list|)
expr_stmt|;
name|print_file_name
argument_list|(
name|entry
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|just_syms_flag
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|" symbols only\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|" text %x(%x), data %x(%x), bss %x(%x) hex\n"
argument_list|,
name|entry
operator|->
name|text_start_address
argument_list|,
name|entry
operator|->
name|header
operator|.
name|a_text
argument_list|,
name|entry
operator|->
name|data_start_address
argument_list|,
name|entry
operator|->
name|header
operator|.
name|a_data
argument_list|,
name|entry
operator|->
name|bss_start_address
argument_list|,
name|entry
operator|->
name|header
operator|.
name|a_bss
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|list_file_locals
parameter_list|(
name|entry
parameter_list|,
name|outfile
parameter_list|)
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
name|FILE
modifier|*
name|outfile
decl_stmt|;
block|{
specifier|register
name|struct
name|nlist
modifier|*
name|p
decl_stmt|,
modifier|*
name|end
init|=
name|entry
operator|->
name|symbols
operator|+
name|entry
operator|->
name|header
operator|.
name|a_syms
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
decl_stmt|;
name|entry
operator|->
name|strings
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|entry
operator|->
name|string_size
argument_list|)
expr_stmt|;
name|read_entry_strings
argument_list|(
name|file_open
argument_list|(
name|entry
argument_list|)
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\nLocal symbols of "
argument_list|)
expr_stmt|;
name|print_file_name
argument_list|(
name|entry
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|":\n\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|entry
operator|->
name|symbols
init|;
name|p
operator|<
name|end
condition|;
name|p
operator|++
control|)
comment|/* If this is a definition,        update it if necessary by this file's start address.  */
if|if
condition|(
operator|!
operator|(
name|p
operator|->
name|n_type
operator|&
operator|(
name|N_STAB
operator||
name|N_EXT
operator|)
operator|)
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"  %s: 0x%x\n"
argument_list|,
name|entry
operator|->
name|strings
operator|+
name|p
operator|->
name|n_un
operator|.
name|n_strx
argument_list|,
name|p
operator|->
name|n_value
argument_list|)
expr_stmt|;
name|entry
operator|->
name|strings
operator|=
literal|0
expr_stmt|;
comment|/* All done with them.  */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Static vars for do_warnings and subroutines of it */
end_comment

begin_decl_stmt
name|int
name|list_unresolved_refs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List unresolved refs */
end_comment

begin_decl_stmt
name|int
name|list_warning_symbols
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List warning syms */
end_comment

begin_decl_stmt
name|int
name|list_multiple_defs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List multiple definitions */
end_comment

begin_comment
comment|/*  * Structure for communication between do_file_warnings and it's  * helper routines.  Will in practice be an array of three of these:  * 0) Current line, 1) Next line, 2) Source file info.  */
end_comment

begin_struct
struct|struct
name|line_debug_entry
block|{
name|int
name|line
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|struct
name|nlist
modifier|*
name|sym
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
name|void
name|qsort
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * Helper routines for do_file_warnings.  */
end_comment

begin_comment
comment|/* Return an integer less than, equal to, or greater than 0 as per the    relation between the two relocation entries.  Used by qsort.  */
end_comment

begin_function
name|int
name|relocation_entries_relation
parameter_list|(
name|rel1
parameter_list|,
name|rel2
parameter_list|)
name|struct
name|relocation_info
modifier|*
name|rel1
decl_stmt|,
decl|*
name|rel2
decl_stmt|;
end_function

begin_block
block|{
return|return
name|RELOC_ADDRESS
argument_list|(
name|rel1
argument_list|)
operator|-
name|RELOC_ADDRESS
argument_list|(
name|rel2
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/* Moves to the next debugging symbol in the file.  USE_DATA_SYMBOLS    determines the type of the debugging symbol to look for (DSLINE or    SLINE).  STATE_POINTER keeps track of the old and new locatiosn in    the file.  It assumes that state_pointer[1] is valid; ie    that it.sym points into some entry in the symbol table.  If    state_pointer[1].sym == 0, this routine should not be called.  */
end_comment

begin_function
name|int
name|next_debug_entry
parameter_list|(
name|use_data_symbols
parameter_list|,
name|state_pointer
parameter_list|)
specifier|register
name|int
name|use_data_symbols
decl_stmt|;
comment|/* Next must be passed by reference! */
name|struct
name|line_debug_entry
name|state_pointer
index|[
literal|3
index|]
decl_stmt|;
block|{
specifier|register
name|struct
name|line_debug_entry
modifier|*
name|current
init|=
name|state_pointer
decl_stmt|,
modifier|*
name|next
init|=
name|state_pointer
operator|+
literal|1
decl_stmt|,
comment|/* Used to store source file */
modifier|*
name|source
init|=
name|state_pointer
operator|+
literal|2
decl_stmt|;
name|struct
name|file_entry
modifier|*
name|entry
init|=
operator|(
expr|struct
name|file_entry
operator|*
operator|)
name|source
operator|->
name|sym
decl_stmt|;
name|current
operator|->
name|sym
operator|=
name|next
operator|->
name|sym
expr_stmt|;
name|current
operator|->
name|line
operator|=
name|next
operator|->
name|line
expr_stmt|;
name|current
operator|->
name|filename
operator|=
name|next
operator|->
name|filename
expr_stmt|;
while|while
condition|(
operator|++
operator|(
name|next
operator|->
name|sym
operator|)
operator|<
operator|(
name|entry
operator|->
name|symbols
operator|+
name|entry
operator|->
name|header
operator|.
name|a_syms
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
operator|)
condition|)
block|{
comment|/* n_type is a char, and N_SOL, N_EINCL and N_BINCL are> 0x80, so        * may look negative...therefore, must mask to low bits        */
switch|switch
condition|(
name|next
operator|->
name|sym
operator|->
name|n_type
operator|&
literal|0xff
condition|)
block|{
case|case
name|N_SLINE
case|:
if|if
condition|(
name|use_data_symbols
condition|)
continue|continue;
name|next
operator|->
name|line
operator|=
name|next
operator|->
name|sym
operator|->
name|n_desc
expr_stmt|;
return|return
literal|1
return|;
case|case
name|N_DSLINE
case|:
if|if
condition|(
operator|!
name|use_data_symbols
condition|)
continue|continue;
name|next
operator|->
name|line
operator|=
name|next
operator|->
name|sym
operator|->
name|n_desc
expr_stmt|;
return|return
literal|1
return|;
ifdef|#
directive|ifdef
name|HAVE_SUN_STABS
case|case
name|N_EINCL
case|:
name|next
operator|->
name|filename
operator|=
name|source
operator|->
name|filename
expr_stmt|;
continue|continue;
endif|#
directive|endif
case|case
name|N_SO
case|:
name|source
operator|->
name|filename
operator|=
name|next
operator|->
name|sym
operator|->
name|n_un
operator|.
name|n_strx
operator|+
name|entry
operator|->
name|strings
expr_stmt|;
name|source
operator|->
name|line
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SUN_STABS
case|case
name|N_BINCL
case|:
endif|#
directive|endif
case|case
name|N_SOL
case|:
name|next
operator|->
name|filename
operator|=
name|next
operator|->
name|sym
operator|->
name|n_un
operator|.
name|n_strx
operator|+
name|entry
operator|->
name|strings
expr_stmt|;
default|default:
continue|continue;
block|}
block|}
name|next
operator|->
name|sym
operator|=
operator|(
expr|struct
name|nlist
operator|*
operator|)
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Create a structure to save the state of a scan through the debug    symbols.  USE_DATA_SYMBOLS is set if we should be scanning for    DSLINE's instead of SLINE's.  entry is the file entry which points    at the symbols to use.  */
end_comment

begin_function
name|struct
name|line_debug_entry
modifier|*
name|init_debug_scan
parameter_list|(
name|use_data_symbols
parameter_list|,
name|entry
parameter_list|)
name|int
name|use_data_symbols
decl_stmt|;
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
block|{
name|struct
name|line_debug_entry
modifier|*
name|state_pointer
init|=
operator|(
expr|struct
name|line_debug_entry
operator|*
operator|)
name|xmalloc
argument_list|(
literal|3
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|line_debug_entry
argument_list|)
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|line_debug_entry
modifier|*
name|current
init|=
name|state_pointer
decl_stmt|,
modifier|*
name|next
init|=
name|state_pointer
operator|+
literal|1
decl_stmt|,
modifier|*
name|source
init|=
name|state_pointer
operator|+
literal|2
decl_stmt|;
comment|/* Used to store source file */
name|struct
name|nlist
modifier|*
name|tmp
decl_stmt|;
for|for
control|(
name|tmp
operator|=
name|entry
operator|->
name|symbols
init|;
name|tmp
operator|<
operator|(
name|entry
operator|->
name|symbols
operator|+
name|entry
operator|->
name|header
operator|.
name|a_syms
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
operator|)
condition|;
name|tmp
operator|++
control|)
if|if
condition|(
name|tmp
operator|->
name|n_type
operator|==
operator|(
name|int
operator|)
name|N_SO
condition|)
break|break;
if|if
condition|(
name|tmp
operator|>=
operator|(
name|entry
operator|->
name|symbols
operator|+
name|entry
operator|->
name|header
operator|.
name|a_syms
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
operator|)
condition|)
block|{
comment|/* I believe this translates to "We lose" */
name|current
operator|->
name|filename
operator|=
name|next
operator|->
name|filename
operator|=
name|entry
operator|->
name|filename
expr_stmt|;
name|current
operator|->
name|line
operator|=
name|next
operator|->
name|line
operator|=
operator|-
literal|1
expr_stmt|;
name|current
operator|->
name|sym
operator|=
name|next
operator|->
name|sym
operator|=
operator|(
expr|struct
name|nlist
operator|*
operator|)
literal|0
expr_stmt|;
return|return
name|state_pointer
return|;
block|}
name|next
operator|->
name|line
operator|=
name|source
operator|->
name|line
operator|=
literal|0
expr_stmt|;
name|next
operator|->
name|filename
operator|=
name|source
operator|->
name|filename
operator|=
operator|(
name|tmp
operator|->
name|n_un
operator|.
name|n_strx
operator|+
name|entry
operator|->
name|strings
operator|)
expr_stmt|;
name|source
operator|->
name|sym
operator|=
operator|(
expr|struct
name|nlist
operator|*
operator|)
name|entry
expr_stmt|;
name|next
operator|->
name|sym
operator|=
name|tmp
expr_stmt|;
name|next_debug_entry
argument_list|(
name|use_data_symbols
argument_list|,
name|state_pointer
argument_list|)
expr_stmt|;
comment|/* To setup next */
if|if
condition|(
operator|!
name|next
operator|->
name|sym
condition|)
comment|/* No line numbers for this section; */
comment|/* setup output results as appropriate */
block|{
if|if
condition|(
name|source
operator|->
name|line
condition|)
block|{
name|current
operator|->
name|filename
operator|=
name|source
operator|->
name|filename
operator|=
name|entry
operator|->
name|filename
expr_stmt|;
name|current
operator|->
name|line
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Don't print lineno */
block|}
else|else
block|{
name|current
operator|->
name|filename
operator|=
name|source
operator|->
name|filename
expr_stmt|;
name|current
operator|->
name|line
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|state_pointer
return|;
block|}
name|next_debug_entry
argument_list|(
name|use_data_symbols
argument_list|,
name|state_pointer
argument_list|)
expr_stmt|;
comment|/* To setup current */
return|return
name|state_pointer
return|;
block|}
end_function

begin_comment
comment|/* Takes an ADDRESS (in either text or data space) and a STATE_POINTER    which describes the current location in the implied scan through    the debug symbols within the file which ADDRESS is within, and    returns the source line number which corresponds to ADDRESS.  */
end_comment

begin_function
name|int
name|address_to_line
parameter_list|(
name|address
parameter_list|,
name|state_pointer
parameter_list|)
name|unsigned
name|long
name|address
decl_stmt|;
comment|/* Next must be passed by reference! */
name|struct
name|line_debug_entry
name|state_pointer
index|[
literal|3
index|]
decl_stmt|;
block|{
name|struct
name|line_debug_entry
modifier|*
name|current
init|=
name|state_pointer
decl_stmt|,
modifier|*
name|next
init|=
name|state_pointer
operator|+
literal|1
decl_stmt|;
name|struct
name|line_debug_entry
modifier|*
name|tmp_pointer
decl_stmt|;
name|int
name|use_data_symbols
decl_stmt|;
if|if
condition|(
name|next
operator|->
name|sym
condition|)
name|use_data_symbols
operator|=
operator|(
name|next
operator|->
name|sym
operator|->
name|n_type
operator|&
name|N_TYPE
operator|)
operator|==
name|N_DATA
expr_stmt|;
else|else
return|return
name|current
operator|->
name|line
return|;
comment|/* Go back to the beginning if we've already passed it.  */
if|if
condition|(
name|current
operator|->
name|sym
operator|->
name|n_value
operator|>
name|address
condition|)
block|{
name|tmp_pointer
operator|=
name|init_debug_scan
argument_list|(
name|use_data_symbols
argument_list|,
operator|(
expr|struct
name|file_entry
operator|*
operator|)
operator|(
operator|(
name|state_pointer
operator|+
literal|2
operator|)
operator|->
name|sym
operator|)
argument_list|)
expr_stmt|;
name|state_pointer
index|[
literal|0
index|]
operator|=
name|tmp_pointer
index|[
literal|0
index|]
expr_stmt|;
name|state_pointer
index|[
literal|1
index|]
operator|=
name|tmp_pointer
index|[
literal|1
index|]
expr_stmt|;
name|state_pointer
index|[
literal|2
index|]
operator|=
name|tmp_pointer
index|[
literal|2
index|]
expr_stmt|;
name|free
argument_list|(
name|tmp_pointer
argument_list|)
expr_stmt|;
block|}
comment|/* If we're still in a bad way, return -1, meaning invalid line.  */
if|if
condition|(
name|current
operator|->
name|sym
operator|->
name|n_value
operator|>
name|address
condition|)
return|return
operator|-
literal|1
return|;
while|while
condition|(
name|next
operator|->
name|sym
operator|&&
name|next
operator|->
name|sym
operator|->
name|n_value
operator|<=
name|address
operator|&&
name|next_debug_entry
argument_list|(
name|use_data_symbols
argument_list|,
name|state_pointer
argument_list|)
condition|)
empty_stmt|;
return|return
name|current
operator|->
name|line
return|;
block|}
end_function

begin_comment
comment|/* Macros for manipulating bitvectors.  */
end_comment

begin_define
define|#
directive|define
name|BIT_SET_P
parameter_list|(
name|bv
parameter_list|,
name|index
parameter_list|)
value|((bv)[(index)>> 3]& 1<< ((index)& 0x7))
end_define

begin_define
define|#
directive|define
name|SET_BIT
parameter_list|(
name|bv
parameter_list|,
name|index
parameter_list|)
value|((bv)[(index)>> 3] |= 1<< ((index)& 0x7))
end_define

begin_comment
comment|/* This routine will scan through the relocation data of file ENTRY,    printing out references to undefined symbols and references to    symbols defined in files with N_WARNING symbols.  If DATA_SEGMENT    is non-zero, it will scan the data relocation segment (and use    N_DSLINE symbols to track line number); otherwise it will scan the    text relocation segment.  Warnings will be printed on the output    stream OUTFILE.  Eventually, every nlist symbol mapped through will    be marked in the NLIST_BITVECTOR, so we don't repeat ourselves when    we scan the nlists themselves.  */
end_comment

begin_macro
name|do_relocation_warnings
argument_list|(
argument|entry
argument_list|,
argument|data_segment
argument_list|,
argument|outfile
argument_list|,
argument|nlist_bitvector
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|data_segment
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|outfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
modifier|*
name|nlist_bitvector
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|relocation_info
modifier|*
name|reloc_start
init|=
name|data_segment
condition|?
name|entry
operator|->
name|datarel
else|:
name|entry
operator|->
name|textrel
decl_stmt|,
modifier|*
name|reloc
decl_stmt|;
name|int
name|reloc_size
init|=
operator|(
operator|(
name|data_segment
condition|?
name|entry
operator|->
name|header
operator|.
name|a_drsize
else|:
name|entry
operator|->
name|header
operator|.
name|a_trsize
operator|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|relocation_info
argument_list|)
operator|)
decl_stmt|;
name|int
name|start_of_segment
init|=
operator|(
name|data_segment
condition|?
name|entry
operator|->
name|data_start_address
else|:
name|entry
operator|->
name|text_start_address
operator|)
decl_stmt|;
name|struct
name|nlist
modifier|*
name|start_of_syms
init|=
name|entry
operator|->
name|symbols
decl_stmt|;
name|struct
name|line_debug_entry
modifier|*
name|state_pointer
init|=
name|init_debug_scan
argument_list|(
name|data_segment
operator|!=
literal|0
argument_list|,
name|entry
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|line_debug_entry
modifier|*
name|current
init|=
name|state_pointer
decl_stmt|;
comment|/* Assigned to generally static values; should not be written into.  */
name|char
modifier|*
name|errfmt
decl_stmt|;
comment|/* Assigned to alloca'd values cand copied into; should be freed      when done.  */
name|char
modifier|*
name|errmsg
decl_stmt|;
name|int
name|invalidate_line_number
decl_stmt|;
comment|/* We need to sort the relocation info here.  Sheesh, so much effort      for one lousy error optimization. */
name|qsort
argument_list|(
name|reloc_start
argument_list|,
name|reloc_size
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|relocation_info
argument_list|)
argument_list|,
name|relocation_entries_relation
argument_list|)
expr_stmt|;
for|for
control|(
name|reloc
operator|=
name|reloc_start
init|;
name|reloc
operator|<
operator|(
name|reloc_start
operator|+
name|reloc_size
operator|)
condition|;
name|reloc
operator|++
control|)
block|{
specifier|register
name|struct
name|nlist
modifier|*
name|s
decl_stmt|;
specifier|register
name|symbol
modifier|*
name|g
decl_stmt|;
comment|/* If the relocation isn't resolved through a symbol, continue */
if|if
condition|(
operator|!
name|RELOC_EXTERN_P
argument_list|(
name|reloc
argument_list|)
condition|)
continue|continue;
name|s
operator|=
operator|&
operator|(
name|entry
operator|->
name|symbols
index|[
name|RELOC_SYMBOL
argument_list|(
name|reloc
argument_list|)
index|]
operator|)
expr_stmt|;
comment|/* Local symbols shouldn't ever be used by relocation info, so 	 the next should be safe. 	 This is, of course, wrong.  References to local BSS symbols can be 	 the targets of relocation info, and they can (must) be 	 resolved through symbols.  However, these must be defined properly, 	 (the assembler would have caught it otherwise), so we can 	 ignore these cases.  */
if|if
condition|(
operator|!
operator|(
name|s
operator|->
name|n_type
operator|&
name|N_EXT
operator|)
condition|)
continue|continue;
name|g
operator|=
operator|(
name|symbol
operator|*
operator|)
name|s
operator|->
name|n_un
operator|.
name|n_name
expr_stmt|;
name|errmsg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|g
operator|->
name|defined
operator|&&
name|list_unresolved_refs
condition|)
comment|/* Reference */
block|{
comment|/* Mark as being noted by relocation warning pass.  */
name|SET_BIT
argument_list|(
name|nlist_bitvector
argument_list|,
name|s
operator|-
name|start_of_syms
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|undef_refs
operator|>=
name|MAX_UREFS_PRINTED
condition|)
comment|/* Listed too many */
continue|continue;
comment|/* Undefined symbol which we should mention */
if|if
condition|(
operator|++
operator|(
name|g
operator|->
name|undef_refs
operator|)
operator|==
name|MAX_UREFS_PRINTED
condition|)
block|{
name|errfmt
operator|=
literal|"More undefined symbol %s refs follow"
expr_stmt|;
name|invalidate_line_number
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|errfmt
operator|=
literal|"Undefined symbol %s referenced from %s segment"
expr_stmt|;
name|invalidate_line_number
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
comment|/* Defined */
block|{
comment|/* Potential symbol warning here */
if|if
condition|(
operator|!
name|g
operator|->
name|warning
condition|)
continue|continue;
comment|/* Mark as being noted by relocation warning pass.  */
name|SET_BIT
argument_list|(
name|nlist_bitvector
argument_list|,
name|s
operator|-
name|start_of_syms
argument_list|)
expr_stmt|;
name|errfmt
operator|=
literal|0
expr_stmt|;
name|errmsg
operator|=
name|g
operator|->
name|warning
expr_stmt|;
name|invalidate_line_number
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If errfmt == 0, errmsg has already been defined.  */
if|if
condition|(
name|errfmt
operator|!=
literal|0
condition|)
block|{
name|char
modifier|*
name|nm
decl_stmt|;
if|if
condition|(
name|demangler
operator|==
name|NULL
operator|||
operator|(
name|nm
operator|=
call|(
modifier|*
name|demangler
call|)
argument_list|(
name|g
operator|->
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|nm
operator|=
name|g
operator|->
name|name
expr_stmt|;
name|errmsg
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|errfmt
argument_list|)
operator|+
name|strlen
argument_list|(
name|nm
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|errmsg
argument_list|,
name|errfmt
argument_list|,
name|nm
argument_list|,
name|data_segment
condition|?
literal|"data"
else|:
literal|"text"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nm
operator|!=
name|g
operator|->
name|name
condition|)
name|free
argument_list|(
name|nm
argument_list|)
expr_stmt|;
block|}
name|address_to_line
argument_list|(
name|RELOC_ADDRESS
argument_list|(
name|reloc
argument_list|)
operator|+
name|start_of_segment
argument_list|,
name|state_pointer
argument_list|)
expr_stmt|;
if|if
condition|(
name|current
operator|->
name|line
operator|>=
literal|0
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%s:%d: %s\n"
argument_list|,
name|current
operator|->
name|filename
argument_list|,
name|invalidate_line_number
condition|?
literal|0
else|:
name|current
operator|->
name|line
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|current
operator|->
name|filename
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
if|if
condition|(
name|errfmt
operator|!=
literal|0
condition|)
name|free
argument_list|(
name|errmsg
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|state_pointer
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Print on OUTFILE a list of all warnings generated by references    and/or definitions in the file ENTRY.  List source file and line    number if possible, just the .o file if not. */
end_comment

begin_function
name|void
name|do_file_warnings
parameter_list|(
name|entry
parameter_list|,
name|outfile
parameter_list|)
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
name|FILE
modifier|*
name|outfile
decl_stmt|;
block|{
name|int
name|number_of_syms
init|=
name|entry
operator|->
name|header
operator|.
name|a_syms
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
decl_stmt|;
name|unsigned
name|char
modifier|*
name|nlist_bitvector
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|number_of_syms
operator|>>
literal|3
operator|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|struct
name|line_debug_entry
modifier|*
name|text_scan
decl_stmt|,
modifier|*
name|data_scan
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|errfmt
decl_stmt|,
modifier|*
name|file_name
decl_stmt|;
name|int
name|line_number
decl_stmt|;
name|int
name|dont_allow_symbol_name
decl_stmt|;
name|bzero
argument_list|(
name|nlist_bitvector
argument_list|,
operator|(
name|number_of_syms
operator|>>
literal|3
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Read in the files strings if they aren't available */
if|if
condition|(
operator|!
name|entry
operator|->
name|strings
condition|)
block|{
name|int
name|desc
decl_stmt|;
name|entry
operator|->
name|strings
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|entry
operator|->
name|string_size
argument_list|)
expr_stmt|;
name|desc
operator|=
name|file_open
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|read_entry_strings
argument_list|(
name|desc
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
name|read_file_relocation
argument_list|(
name|entry
argument_list|)
expr_stmt|;
comment|/* Do text warnings based on a scan through the relocation info.  */
name|do_relocation_warnings
argument_list|(
name|entry
argument_list|,
literal|0
argument_list|,
name|outfile
argument_list|,
name|nlist_bitvector
argument_list|)
expr_stmt|;
comment|/* Do data warnings based on a scan through the relocation info.  */
name|do_relocation_warnings
argument_list|(
name|entry
argument_list|,
literal|1
argument_list|,
name|outfile
argument_list|,
name|nlist_bitvector
argument_list|)
expr_stmt|;
comment|/* Scan through all of the nlist entries in this file and pick up      anything that the scan through the relocation stuff didn't.  */
name|text_scan
operator|=
name|init_debug_scan
argument_list|(
literal|0
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|data_scan
operator|=
name|init_debug_scan
argument_list|(
literal|1
argument_list|,
name|entry
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|number_of_syms
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|nlist
modifier|*
name|s
decl_stmt|;
name|struct
name|glosym
modifier|*
name|g
decl_stmt|;
name|s
operator|=
name|entry
operator|->
name|symbols
operator|+
name|i
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|s
operator|->
name|n_type
operator|&
name|N_EXT
operator|)
condition|)
continue|continue;
name|g
operator|=
operator|(
name|symbol
operator|*
operator|)
name|s
operator|->
name|n_un
operator|.
name|n_name
expr_stmt|;
name|dont_allow_symbol_name
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|list_multiple_defs
operator|&&
name|g
operator|->
name|multiply_defined
condition|)
block|{
name|errfmt
operator|=
literal|"Definition of symbol %s (multiply defined)"
expr_stmt|;
switch|switch
condition|(
name|s
operator|->
name|n_type
condition|)
block|{
case|case
name|N_TEXT
operator||
name|N_EXT
case|:
name|line_number
operator|=
name|address_to_line
argument_list|(
name|s
operator|->
name|n_value
argument_list|,
name|text_scan
argument_list|)
expr_stmt|;
name|file_name
operator|=
name|text_scan
index|[
literal|0
index|]
operator|.
name|filename
expr_stmt|;
break|break;
case|case
name|N_DATA
operator||
name|N_EXT
case|:
name|line_number
operator|=
name|address_to_line
argument_list|(
name|s
operator|->
name|n_value
argument_list|,
name|data_scan
argument_list|)
expr_stmt|;
name|file_name
operator|=
name|data_scan
index|[
literal|0
index|]
operator|.
name|filename
expr_stmt|;
break|break;
case|case
name|N_SETA
operator||
name|N_EXT
case|:
case|case
name|N_SETT
operator||
name|N_EXT
case|:
case|case
name|N_SETD
operator||
name|N_EXT
case|:
case|case
name|N_SETB
operator||
name|N_EXT
case|:
if|if
condition|(
name|g
operator|->
name|multiply_defined
operator|==
literal|2
condition|)
continue|continue;
name|errfmt
operator|=
literal|"First set element definition of symbol %s (multiply defined)"
expr_stmt|;
break|break;
default|default:
continue|continue;
comment|/* Don't print out multiple defs 				   at references.  */
block|}
block|}
elseif|else
if|if
condition|(
name|BIT_SET_P
argument_list|(
name|nlist_bitvector
argument_list|,
name|i
argument_list|)
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|list_unresolved_refs
operator|&&
operator|!
name|g
operator|->
name|defined
condition|)
block|{
if|if
condition|(
name|g
operator|->
name|undef_refs
operator|>=
name|MAX_UREFS_PRINTED
condition|)
continue|continue;
if|if
condition|(
operator|++
operator|(
name|g
operator|->
name|undef_refs
operator|)
operator|==
name|MAX_UREFS_PRINTED
condition|)
name|errfmt
operator|=
literal|"More undefined \"%s\" refs follow"
expr_stmt|;
else|else
name|errfmt
operator|=
literal|"Undefined symbol \"%s\" referenced"
expr_stmt|;
name|line_number
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|g
operator|->
name|warning
condition|)
block|{
comment|/* There are two cases in which we don't want to 	     do this.  The first is if this is a definition instead of 	     a reference.  The second is if it's the reference used by 	     the warning stabs itself.  */
if|if
condition|(
name|s
operator|->
name|n_type
operator|!=
operator|(
name|N_EXT
operator||
name|N_UNDF
operator|)
operator|||
operator|(
name|i
operator|&&
operator|(
name|s
operator|-
literal|1
operator|)
operator|->
name|n_type
operator|==
name|N_WARNING
operator|)
condition|)
continue|continue;
name|errfmt
operator|=
name|g
operator|->
name|warning
expr_stmt|;
name|line_number
operator|=
operator|-
literal|1
expr_stmt|;
name|dont_allow_symbol_name
operator|=
literal|1
expr_stmt|;
block|}
else|else
continue|continue;
if|if
condition|(
name|line_number
operator|==
operator|-
literal|1
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%s: "
argument_list|,
name|entry
operator|->
name|filename
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%s:%d: "
argument_list|,
name|file_name
argument_list|,
name|line_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|dont_allow_symbol_name
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%s"
argument_list|,
name|errfmt
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|nm
decl_stmt|;
if|if
condition|(
name|demangler
operator|!=
name|NULL
operator|&&
operator|(
name|nm
operator|=
call|(
modifier|*
name|demangler
call|)
argument_list|(
name|g
operator|->
name|name
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|outfile
argument_list|,
name|errfmt
argument_list|,
name|nm
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nm
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|outfile
argument_list|,
name|errfmt
argument_list|,
name|g
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|text_scan
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|data_scan
argument_list|)
expr_stmt|;
name|entry
operator|->
name|strings
operator|=
literal|0
expr_stmt|;
comment|/* Since it will dissapear anyway.  */
block|}
end_function

begin_escape
end_escape

begin_macro
name|do_warnings
argument_list|(
argument|outfile
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|outfile
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|list_unresolved_refs
operator|=
operator|!
name|relocatable_output
operator|&&
name|undefined_global_sym_count
expr_stmt|;
name|list_warning_symbols
operator|=
name|warning_count
expr_stmt|;
name|list_multiple_defs
operator|=
name|multiple_def_count
operator|!=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|list_unresolved_refs
operator|||
name|list_warning_symbols
operator|||
name|list_multiple_defs
operator|)
condition|)
comment|/* No need to run this routine */
return|return;
name|each_file
argument_list|(
name|do_file_warnings
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|list_unresolved_refs
operator|||
name|list_multiple_defs
condition|)
name|make_executable
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Write the output file */
end_comment

begin_function
name|void
name|write_output
parameter_list|()
block|{
name|struct
name|stat
name|statbuf
decl_stmt|;
name|int
name|filemode
decl_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|output_filename
argument_list|)
expr_stmt|;
name|outdesc
operator|=
name|open
argument_list|(
name|output_filename
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|outdesc
operator|<
literal|0
condition|)
name|perror_name
argument_list|(
name|output_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|outdesc
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|<
literal|0
condition|)
name|perror_name
argument_list|(
name|output_filename
argument_list|)
expr_stmt|;
name|filemode
operator|=
name|statbuf
operator|.
name|st_mode
expr_stmt|;
name|chmod
argument_list|(
name|output_filename
argument_list|,
name|filemode
operator|&
operator|~
literal|0111
argument_list|)
expr_stmt|;
comment|/* Output the a.out header.  */
name|write_header
argument_list|()
expr_stmt|;
comment|/* Output the text and data segments, relocating as we go.  */
name|write_text
argument_list|()
expr_stmt|;
name|write_data
argument_list|()
expr_stmt|;
comment|/* Output the merged relocation info, if requested with `-r'.  */
if|if
condition|(
name|relocatable_output
condition|)
name|write_rel
argument_list|()
expr_stmt|;
comment|/* Output the symbol table (both globals and locals).  */
name|write_syms
argument_list|()
expr_stmt|;
comment|/* Copy any GDB symbol segments from input files.  */
name|write_symsegs
argument_list|()
expr_stmt|;
name|close
argument_list|(
name|outdesc
argument_list|)
expr_stmt|;
if|if
condition|(
name|chmod
argument_list|(
name|output_filename
argument_list|,
name|filemode
operator||
literal|0111
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|perror_name
argument_list|(
name|output_filename
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
name|void
name|modify_location
argument_list|()
decl_stmt|,
name|perform_relocation
argument_list|()
decl_stmt|,
name|copy_text
argument_list|()
decl_stmt|,
name|copy_data
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|write_header
parameter_list|()
block|{
name|N_SET_MAGIC
argument_list|(
name|outheader
argument_list|,
name|magic
argument_list|)
expr_stmt|;
name|outheader
operator|.
name|a_text
operator|=
name|text_size
expr_stmt|;
ifdef|#
directive|ifdef
name|sequent
name|outheader
operator|.
name|a_text
operator|+=
name|N_ADDRADJ
argument_list|(
name|outheader
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry_symbol
operator|==
literal|0
condition|)
name|entry_symbol
operator|=
name|getsym
argument_list|(
literal|"start"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|outheader
operator|.
name|a_data
operator|=
name|data_size
expr_stmt|;
name|outheader
operator|.
name|a_bss
operator|=
name|bss_size
expr_stmt|;
name|outheader
operator|.
name|a_entry
operator|=
operator|(
name|entry_symbol
condition|?
name|entry_symbol
operator|->
name|value
else|:
name|text_start
operator|+
name|entry_offset
operator|)
expr_stmt|;
if|if
condition|(
name|screwballmode
condition|)
block|{
name|N_SET_MAGIC
argument_list|(
name|outheader
argument_list|,
name|ZMAGIC
argument_list|)
expr_stmt|;
name|outheader
operator|.
name|a_text
operator|=
literal|0
expr_stmt|;
name|outheader
operator|.
name|a_data
operator|=
name|text_size
operator|+
name|data_size
expr_stmt|;
name|outheader
operator|.
name|a_entry
operator|=
operator|(
name|entry_symbol
condition|?
name|entry_symbol
operator|->
name|value
else|:
sizeof|sizeof
argument_list|(
expr|struct
name|exec
argument_list|)
operator|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|COFF_ENCAPSULATE
if|if
condition|(
name|need_coff_header
condition|)
block|{
comment|/* We are encapsulating BSD format within COFF format.  */
name|struct
name|coffscn
modifier|*
name|tp
decl_stmt|,
modifier|*
name|dp
decl_stmt|,
modifier|*
name|bp
decl_stmt|;
name|tp
operator|=
operator|&
name|coffheader
operator|.
name|scns
index|[
literal|0
index|]
expr_stmt|;
name|dp
operator|=
operator|&
name|coffheader
operator|.
name|scns
index|[
literal|1
index|]
expr_stmt|;
name|bp
operator|=
operator|&
name|coffheader
operator|.
name|scns
index|[
literal|2
index|]
expr_stmt|;
name|strcpy
argument_list|(
name|tp
operator|->
name|s_name
argument_list|,
literal|".text"
argument_list|)
expr_stmt|;
name|tp
operator|->
name|s_paddr
operator|=
name|text_start
expr_stmt|;
name|tp
operator|->
name|s_vaddr
operator|=
name|text_start
expr_stmt|;
name|tp
operator|->
name|s_size
operator|=
name|text_size
expr_stmt|;
name|tp
operator|->
name|s_scnptr
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|coffheader
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|exec
argument_list|)
expr_stmt|;
name|tp
operator|->
name|s_relptr
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|s_lnnoptr
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|s_nreloc
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|s_nlnno
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|s_flags
operator|=
literal|0x20
expr_stmt|;
name|strcpy
argument_list|(
name|dp
operator|->
name|s_name
argument_list|,
literal|".data"
argument_list|)
expr_stmt|;
name|dp
operator|->
name|s_paddr
operator|=
name|data_start
expr_stmt|;
name|dp
operator|->
name|s_vaddr
operator|=
name|data_start
expr_stmt|;
name|dp
operator|->
name|s_size
operator|=
name|data_size
expr_stmt|;
name|dp
operator|->
name|s_scnptr
operator|=
name|tp
operator|->
name|s_scnptr
operator|+
name|tp
operator|->
name|s_size
expr_stmt|;
name|dp
operator|->
name|s_relptr
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|s_lnnoptr
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|s_nreloc
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|s_nlnno
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|s_flags
operator|=
literal|0x40
expr_stmt|;
name|strcpy
argument_list|(
name|bp
operator|->
name|s_name
argument_list|,
literal|".bss"
argument_list|)
expr_stmt|;
name|bp
operator|->
name|s_paddr
operator|=
name|dp
operator|->
name|s_vaddr
operator|+
name|dp
operator|->
name|s_size
expr_stmt|;
name|bp
operator|->
name|s_vaddr
operator|=
name|bp
operator|->
name|s_paddr
expr_stmt|;
name|bp
operator|->
name|s_size
operator|=
name|bss_size
expr_stmt|;
name|bp
operator|->
name|s_scnptr
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|s_relptr
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|s_lnnoptr
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|s_nreloc
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|s_nlnno
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|s_flags
operator|=
literal|0x80
expr_stmt|;
name|coffheader
operator|.
name|f_magic
operator|=
name|COFF_MAGIC
expr_stmt|;
name|coffheader
operator|.
name|f_nscns
operator|=
literal|3
expr_stmt|;
comment|/* store an unlikely time so programs can        * tell that there is a bsd header        */
name|coffheader
operator|.
name|f_timdat
operator|=
literal|1
expr_stmt|;
name|coffheader
operator|.
name|f_symptr
operator|=
literal|0
expr_stmt|;
name|coffheader
operator|.
name|f_nsyms
operator|=
literal|0
expr_stmt|;
name|coffheader
operator|.
name|f_opthdr
operator|=
literal|28
expr_stmt|;
name|coffheader
operator|.
name|f_flags
operator|=
literal|0x103
expr_stmt|;
comment|/* aouthdr */
name|coffheader
operator|.
name|magic
operator|=
name|ZMAGIC
expr_stmt|;
name|coffheader
operator|.
name|vstamp
operator|=
literal|0
expr_stmt|;
name|coffheader
operator|.
name|tsize
operator|=
name|tp
operator|->
name|s_size
expr_stmt|;
name|coffheader
operator|.
name|dsize
operator|=
name|dp
operator|->
name|s_size
expr_stmt|;
name|coffheader
operator|.
name|bsize
operator|=
name|bp
operator|->
name|s_size
expr_stmt|;
name|coffheader
operator|.
name|entry
operator|=
name|outheader
operator|.
name|a_entry
expr_stmt|;
name|coffheader
operator|.
name|text_start
operator|=
name|tp
operator|->
name|s_vaddr
expr_stmt|;
name|coffheader
operator|.
name|data_start
operator|=
name|dp
operator|->
name|s_vaddr
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INITIALIZE_HEADER
name|INITIALIZE_HEADER
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|strip_symbols
operator|==
name|STRIP_ALL
condition|)
name|nsyms
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|nsyms
operator|=
operator|(
name|defined_global_sym_count
operator|+
name|undefined_global_sym_count
operator|)
expr_stmt|;
if|if
condition|(
name|discard_locals
operator|==
name|DISCARD_L
condition|)
name|nsyms
operator|+=
name|non_L_local_sym_count
expr_stmt|;
elseif|else
if|if
condition|(
name|discard_locals
operator|==
name|DISCARD_NONE
condition|)
name|nsyms
operator|+=
name|local_sym_count
expr_stmt|;
comment|/* One extra for following reference on indirects */
if|if
condition|(
name|relocatable_output
condition|)
name|nsyms
operator|+=
name|set_symbol_count
operator|+
name|global_indirect_count
expr_stmt|;
block|}
if|if
condition|(
name|strip_symbols
operator|==
name|STRIP_NONE
condition|)
name|nsyms
operator|+=
name|debugger_sym_count
expr_stmt|;
name|outheader
operator|.
name|a_syms
operator|=
name|nsyms
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|relocatable_output
condition|)
block|{
name|outheader
operator|.
name|a_trsize
operator|=
name|text_reloc_size
expr_stmt|;
name|outheader
operator|.
name|a_drsize
operator|=
name|data_reloc_size
expr_stmt|;
block|}
else|else
block|{
name|outheader
operator|.
name|a_trsize
operator|=
literal|0
expr_stmt|;
name|outheader
operator|.
name|a_drsize
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|COFF_ENCAPSULATE
if|if
condition|(
name|need_coff_header
condition|)
name|mywrite
argument_list|(
operator|&
name|coffheader
argument_list|,
sizeof|sizeof
name|coffheader
argument_list|,
literal|1
argument_list|,
name|outdesc
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mywrite
argument_list|(
operator|&
name|outheader
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|exec
argument_list|)
argument_list|,
literal|1
argument_list|,
name|outdesc
argument_list|)
expr_stmt|;
if|if
condition|(
name|screwballmode
condition|)
name|N_SET_MAGIC
argument_list|(
name|outheader
argument_list|,
name|OMAGIC
argument_list|)
expr_stmt|;
comment|/* Output whatever padding is required in the executable file      between the header and the start of the text.  */
ifndef|#
directive|ifndef
name|COFF_ENCAPSULATE
name|padfile
argument_list|(
name|N_TXTOFF
argument_list|(
name|outheader
argument_list|)
operator|-
sizeof|sizeof
name|outheader
argument_list|,
name|outdesc
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Relocate the text segment of each input file    and write to the output file.  */
end_comment

begin_function
name|void
name|write_text
parameter_list|()
block|{
if|if
condition|(
name|trace_files
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Copying and relocating text:\n\n"
argument_list|)
expr_stmt|;
name|each_full_file
argument_list|(
name|copy_text
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|file_close
argument_list|()
expr_stmt|;
if|if
condition|(
name|trace_files
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|padfile
argument_list|(
name|text_pad
argument_list|,
name|outdesc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|text_offset
parameter_list|(
name|entry
parameter_list|)
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
block|{
return|return
name|entry
operator|->
name|starting_offset
operator|+
name|N_TXTOFF
argument_list|(
name|entry
operator|->
name|header
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Read in all of the relocation information */
end_comment

begin_function
name|void
name|read_relocation
parameter_list|()
block|{
name|each_full_file
argument_list|(
name|read_file_relocation
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read in the relocation sections of ENTRY if necessary */
end_comment

begin_function
name|void
name|read_file_relocation
parameter_list|(
name|entry
parameter_list|)
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
block|{
specifier|register
name|struct
name|relocation_info
modifier|*
name|reloc
decl_stmt|;
name|int
name|desc
decl_stmt|;
name|int
name|read_return
decl_stmt|;
name|desc
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|entry
operator|->
name|textrel
condition|)
block|{
name|reloc
operator|=
operator|(
expr|struct
name|relocation_info
operator|*
operator|)
name|xmalloc
argument_list|(
name|entry
operator|->
name|header
operator|.
name|a_trsize
argument_list|)
expr_stmt|;
name|desc
operator|=
name|file_open
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|desc
argument_list|,
name|text_offset
argument_list|(
name|entry
argument_list|)
operator|+
name|entry
operator|->
name|header
operator|.
name|a_text
operator|+
name|entry
operator|->
name|header
operator|.
name|a_data
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|header
operator|.
name|a_trsize
operator|!=
operator|(
name|read_return
operator|=
name|read
argument_list|(
name|desc
argument_list|,
name|reloc
argument_list|,
name|entry
operator|->
name|header
operator|.
name|a_trsize
argument_list|)
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Return from read: %d\n"
argument_list|,
name|read_return
argument_list|)
expr_stmt|;
name|fatal_with_file
argument_list|(
literal|"premature eof in text relocation of "
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
name|entry
operator|->
name|textrel
operator|=
name|reloc
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|entry
operator|->
name|datarel
condition|)
block|{
name|reloc
operator|=
operator|(
expr|struct
name|relocation_info
operator|*
operator|)
name|xmalloc
argument_list|(
name|entry
operator|->
name|header
operator|.
name|a_drsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|==
operator|-
literal|1
condition|)
name|desc
operator|=
name|file_open
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|desc
argument_list|,
name|text_offset
argument_list|(
name|entry
argument_list|)
operator|+
name|entry
operator|->
name|header
operator|.
name|a_text
operator|+
name|entry
operator|->
name|header
operator|.
name|a_data
operator|+
name|entry
operator|->
name|header
operator|.
name|a_trsize
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|header
operator|.
name|a_drsize
operator|!=
name|read
argument_list|(
name|desc
argument_list|,
name|reloc
argument_list|,
name|entry
operator|->
name|header
operator|.
name|a_drsize
argument_list|)
condition|)
name|fatal_with_file
argument_list|(
literal|"premature eof in data relocation of "
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|entry
operator|->
name|datarel
operator|=
name|reloc
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Read the text segment contents of ENTRY, relocate them,    and write the result to the output file.    If `-r', save the text relocation for later reuse.  */
end_comment

begin_function
name|void
name|copy_text
parameter_list|(
name|entry
parameter_list|)
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|bytes
decl_stmt|;
specifier|register
name|int
name|desc
decl_stmt|;
specifier|register
name|struct
name|relocation_info
modifier|*
name|reloc
decl_stmt|;
if|if
condition|(
name|trace_files
condition|)
name|prline_file_name
argument_list|(
name|entry
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|desc
operator|=
name|file_open
argument_list|(
name|entry
argument_list|)
expr_stmt|;
comment|/* Allocate space for the file's text section */
name|bytes
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|entry
operator|->
name|header
operator|.
name|a_text
argument_list|)
expr_stmt|;
comment|/* Deal with relocation information however is appropriate */
if|if
condition|(
name|entry
operator|->
name|textrel
condition|)
name|reloc
operator|=
name|entry
operator|->
name|textrel
expr_stmt|;
elseif|else
if|if
condition|(
name|relocatable_output
condition|)
block|{
name|read_file_relocation
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|reloc
operator|=
name|entry
operator|->
name|textrel
expr_stmt|;
block|}
else|else
block|{
name|reloc
operator|=
operator|(
expr|struct
name|relocation_info
operator|*
operator|)
name|alloca
argument_list|(
name|entry
operator|->
name|header
operator|.
name|a_trsize
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|desc
argument_list|,
name|text_offset
argument_list|(
name|entry
argument_list|)
operator|+
name|entry
operator|->
name|header
operator|.
name|a_text
operator|+
name|entry
operator|->
name|header
operator|.
name|a_data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|header
operator|.
name|a_trsize
operator|!=
name|read
argument_list|(
name|desc
argument_list|,
name|reloc
argument_list|,
name|entry
operator|->
name|header
operator|.
name|a_trsize
argument_list|)
condition|)
name|fatal_with_file
argument_list|(
literal|"premature eof in text relocation of "
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
comment|/* Read the text section into core.  */
name|lseek
argument_list|(
name|desc
argument_list|,
name|text_offset
argument_list|(
name|entry
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|header
operator|.
name|a_text
operator|!=
name|read
argument_list|(
name|desc
argument_list|,
name|bytes
argument_list|,
name|entry
operator|->
name|header
operator|.
name|a_text
argument_list|)
condition|)
name|fatal_with_file
argument_list|(
literal|"premature eof in text section of "
argument_list|,
name|entry
argument_list|)
expr_stmt|;
comment|/* Relocate the text according to the text relocation.  */
name|perform_relocation
argument_list|(
name|bytes
argument_list|,
name|entry
operator|->
name|text_start_address
argument_list|,
name|entry
operator|->
name|header
operator|.
name|a_text
argument_list|,
name|reloc
argument_list|,
name|entry
operator|->
name|header
operator|.
name|a_trsize
argument_list|,
name|entry
argument_list|)
expr_stmt|;
comment|/* Write the relocated text to the output file.  */
name|mywrite
argument_list|(
name|bytes
argument_list|,
literal|1
argument_list|,
name|entry
operator|->
name|header
operator|.
name|a_text
argument_list|,
name|outdesc
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Relocate the data segment of each input file    and write to the output file.  */
end_comment

begin_function
name|void
name|write_data
parameter_list|()
block|{
if|if
condition|(
name|trace_files
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Copying and relocating data:\n\n"
argument_list|)
expr_stmt|;
name|each_full_file
argument_list|(
name|copy_data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|file_close
argument_list|()
expr_stmt|;
comment|/* Write out the set element vectors.  See digest symbols for      description of length of the set vector section.  */
if|if
condition|(
name|set_vector_count
condition|)
name|mywrite
argument_list|(
name|set_vectors
argument_list|,
literal|2
operator|*
name|set_symbol_count
operator|+
name|set_vector_count
argument_list|,
expr|sizeof
operator|(
name|unsigned
name|long
operator|)
argument_list|,
name|outdesc
argument_list|)
expr_stmt|;
if|if
condition|(
name|trace_files
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|padfile
argument_list|(
name|data_pad
argument_list|,
name|outdesc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read the data segment contents of ENTRY, relocate them,    and write the result to the output file.    If `-r', save the data relocation for later reuse.    See comments in `copy_text'.  */
end_comment

begin_function
name|void
name|copy_data
parameter_list|(
name|entry
parameter_list|)
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
block|{
specifier|register
name|struct
name|relocation_info
modifier|*
name|reloc
decl_stmt|;
specifier|register
name|char
modifier|*
name|bytes
decl_stmt|;
specifier|register
name|int
name|desc
decl_stmt|;
if|if
condition|(
name|trace_files
condition|)
name|prline_file_name
argument_list|(
name|entry
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|desc
operator|=
name|file_open
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|bytes
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|entry
operator|->
name|header
operator|.
name|a_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|datarel
condition|)
name|reloc
operator|=
name|entry
operator|->
name|datarel
expr_stmt|;
elseif|else
if|if
condition|(
name|relocatable_output
condition|)
comment|/* Will need this again */
block|{
name|read_file_relocation
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|reloc
operator|=
name|entry
operator|->
name|datarel
expr_stmt|;
block|}
else|else
block|{
name|reloc
operator|=
operator|(
expr|struct
name|relocation_info
operator|*
operator|)
name|alloca
argument_list|(
name|entry
operator|->
name|header
operator|.
name|a_drsize
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|desc
argument_list|,
name|text_offset
argument_list|(
name|entry
argument_list|)
operator|+
name|entry
operator|->
name|header
operator|.
name|a_text
operator|+
name|entry
operator|->
name|header
operator|.
name|a_data
operator|+
name|entry
operator|->
name|header
operator|.
name|a_trsize
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|header
operator|.
name|a_drsize
operator|!=
name|read
argument_list|(
name|desc
argument_list|,
name|reloc
argument_list|,
name|entry
operator|->
name|header
operator|.
name|a_drsize
argument_list|)
condition|)
name|fatal_with_file
argument_list|(
literal|"premature eof in data relocation of "
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
name|lseek
argument_list|(
name|desc
argument_list|,
name|text_offset
argument_list|(
name|entry
argument_list|)
operator|+
name|entry
operator|->
name|header
operator|.
name|a_text
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|header
operator|.
name|a_data
operator|!=
name|read
argument_list|(
name|desc
argument_list|,
name|bytes
argument_list|,
name|entry
operator|->
name|header
operator|.
name|a_data
argument_list|)
condition|)
name|fatal_with_file
argument_list|(
literal|"premature eof in data section of "
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|perform_relocation
argument_list|(
name|bytes
argument_list|,
name|entry
operator|->
name|data_start_address
operator|-
name|entry
operator|->
name|header
operator|.
name|a_text
argument_list|,
name|entry
operator|->
name|header
operator|.
name|a_data
argument_list|,
name|reloc
argument_list|,
name|entry
operator|->
name|header
operator|.
name|a_drsize
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|mywrite
argument_list|(
name|bytes
argument_list|,
literal|1
argument_list|,
name|entry
operator|->
name|header
operator|.
name|a_data
argument_list|,
name|outdesc
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Relocate ENTRY's text or data section contents.    DATA is the address of the contents, in core.    DATA_SIZE is the length of the contents.    PC_RELOCATION is the difference between the address of the contents      in the output file and its address in the input file.    RELOC_INFO is the address of the relocation info, in core.    RELOC_SIZE is its length in bytes.  */
end_comment

begin_comment
comment|/* This version is about to be severly hacked by Randy.  Hope it    works afterwards. */
end_comment

begin_function
name|void
name|perform_relocation
parameter_list|(
name|data
parameter_list|,
name|pc_relocation
parameter_list|,
name|data_size
parameter_list|,
name|reloc_info
parameter_list|,
name|reloc_size
parameter_list|,
name|entry
parameter_list|)
name|char
modifier|*
name|data
decl_stmt|;
name|struct
name|relocation_info
modifier|*
name|reloc_info
decl_stmt|;
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
name|int
name|pc_relocation
decl_stmt|;
name|int
name|data_size
decl_stmt|;
name|int
name|reloc_size
decl_stmt|;
block|{
specifier|register
name|struct
name|relocation_info
modifier|*
name|p
init|=
name|reloc_info
decl_stmt|;
name|struct
name|relocation_info
modifier|*
name|end
init|=
name|reloc_info
operator|+
name|reloc_size
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|relocation_info
argument_list|)
decl_stmt|;
name|int
name|text_relocation
init|=
name|entry
operator|->
name|text_start_address
decl_stmt|;
name|int
name|data_relocation
init|=
name|entry
operator|->
name|data_start_address
operator|-
name|entry
operator|->
name|header
operator|.
name|a_text
decl_stmt|;
name|int
name|bss_relocation
init|=
name|entry
operator|->
name|bss_start_address
operator|-
name|entry
operator|->
name|header
operator|.
name|a_text
operator|-
name|entry
operator|->
name|header
operator|.
name|a_data
decl_stmt|;
for|for
control|(
init|;
name|p
operator|<
name|end
condition|;
name|p
operator|++
control|)
block|{
specifier|register
name|int
name|relocation
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|addr
init|=
name|RELOC_ADDRESS
argument_list|(
name|p
argument_list|)
decl_stmt|;
specifier|register
name|unsigned
name|int
name|mask
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|addr
operator|>=
name|data_size
condition|)
name|fatal_with_file
argument_list|(
literal|"relocation address out of range in "
argument_list|,
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|RELOC_EXTERN_P
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|int
name|symindex
init|=
name|RELOC_SYMBOL
argument_list|(
name|p
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
decl_stmt|;
name|symbol
modifier|*
name|sp
init|=
operator|(
operator|(
name|symbol
operator|*
operator|)
operator|(
operator|(
operator|(
expr|struct
name|nlist
operator|*
operator|)
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|entry
operator|->
name|symbols
operator|)
operator|+
name|symindex
operator|)
operator|)
operator|->
name|n_un
operator|.
name|n_name
operator|)
operator|)
decl_stmt|;
ifdef|#
directive|ifdef
name|N_INDR
comment|/* Resolve indirection */
if|if
condition|(
operator|(
name|sp
operator|->
name|defined
operator|&
operator|~
name|N_EXT
operator|)
operator|==
name|N_INDR
condition|)
name|sp
operator|=
operator|(
name|symbol
operator|*
operator|)
name|sp
operator|->
name|value
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|symindex
operator|>=
name|entry
operator|->
name|header
operator|.
name|a_syms
condition|)
name|fatal_with_file
argument_list|(
literal|"relocation symbolnum out of range in "
argument_list|,
name|entry
argument_list|)
expr_stmt|;
comment|/* If the symbol is undefined, leave it at zero.  */
if|if
condition|(
operator|!
name|sp
operator|->
name|defined
condition|)
name|relocation
operator|=
literal|0
expr_stmt|;
else|else
name|relocation
operator|=
name|sp
operator|->
name|value
expr_stmt|;
block|}
else|else
switch|switch
condition|(
name|RELOC_TYPE
argument_list|(
name|p
argument_list|)
condition|)
block|{
case|case
name|N_TEXT
case|:
case|case
name|N_TEXT
operator||
name|N_EXT
case|:
name|relocation
operator|=
name|text_relocation
expr_stmt|;
break|break;
case|case
name|N_DATA
case|:
case|case
name|N_DATA
operator||
name|N_EXT
case|:
comment|/* A word that points to beginning of the the data section 	     initially contains not 0 but rather the "address" of that section 	     in the input file, which is the length of the file's text.  */
name|relocation
operator|=
name|data_relocation
expr_stmt|;
break|break;
case|case
name|N_BSS
case|:
case|case
name|N_BSS
operator||
name|N_EXT
case|:
comment|/* Similarly, an input word pointing to the beginning of the bss 	     initially contains the length of text plus data of the file.  */
name|relocation
operator|=
name|bss_relocation
expr_stmt|;
break|break;
case|case
name|N_ABS
case|:
case|case
name|N_ABS
operator||
name|N_EXT
case|:
comment|/* Don't know why this code would occur, but apparently it does.  */
break|break;
default|default:
name|fatal_with_file
argument_list|(
literal|"nonexternal relocation code invalid in "
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|RELOC_ADD_EXTRA
name|relocation
operator|+=
name|RELOC_ADD_EXTRA
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|relocatable_output
condition|)
block|{
comment|/* Non-PC relative relocations which are absolute 	     or which have become non-external now have fixed 	     relocations.  Set the ADD_EXTRA of this relocation 	     to be the relocation we have now determined.  */
if|if
condition|(
operator|!
name|RELOC_PCREL_P
argument_list|(
name|p
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|int
operator|)
name|p
operator|->
name|r_type
operator|<=
name|RELOC_32
operator|||
name|RELOC_EXTERN_P
argument_list|(
name|p
argument_list|)
operator|==
literal|0
condition|)
name|RELOC_ADD_EXTRA
argument_list|(
name|p
argument_list|)
operator|=
name|relocation
expr_stmt|;
block|}
comment|/* External PC-relative relocations continue to move around; 	     update their relocations by the amount they have moved 	     so far.  */
elseif|else
if|if
condition|(
name|RELOC_EXTERN_P
argument_list|(
name|p
argument_list|)
condition|)
name|RELOC_ADD_EXTRA
argument_list|(
name|p
argument_list|)
operator|-=
name|pc_relocation
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
if|if
condition|(
name|RELOC_PCREL_P
argument_list|(
name|p
argument_list|)
condition|)
name|relocation
operator|-=
name|pc_relocation
expr_stmt|;
name|relocation
operator|>>=
name|RELOC_VALUE_RIGHTSHIFT
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Unshifted mask for relocation */
name|mask
operator|=
literal|1
operator|<<
name|RELOC_TARGET_BITSIZE
argument_list|(
name|p
argument_list|)
operator|-
literal|1
expr_stmt|;
name|mask
operator||=
name|mask
operator|-
literal|1
expr_stmt|;
name|relocation
operator|&=
name|mask
expr_stmt|;
comment|/* Shift everything up to where it's going to be used */
name|relocation
operator|<<=
name|RELOC_TARGET_BITPOS
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|mask
operator|<<=
name|RELOC_TARGET_BITPOS
argument_list|(
name|p
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|RELOC_TARGET_SIZE
argument_list|(
name|p
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
name|RELOC_MEMORY_SUB_P
argument_list|(
name|p
argument_list|)
condition|)
name|relocation
operator|-=
name|mask
operator|&
operator|*
operator|(
name|char
operator|*
operator|)
operator|(
name|data
operator|+
name|addr
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|RELOC_MEMORY_ADD_P
argument_list|(
name|p
argument_list|)
condition|)
name|relocation
operator|+=
name|mask
operator|&
operator|*
operator|(
name|char
operator|*
operator|)
operator|(
name|data
operator|+
name|addr
operator|)
expr_stmt|;
operator|*
operator|(
name|char
operator|*
operator|)
operator|(
name|data
operator|+
name|addr
operator|)
operator|&=
operator|~
name|mask
expr_stmt|;
operator|*
operator|(
name|char
operator|*
operator|)
operator|(
name|data
operator|+
name|addr
operator|)
operator||=
name|relocation
expr_stmt|;
break|break;
case|case
literal|1
case|:
ifdef|#
directive|ifdef
name|tahoe
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|data
operator|+
name|addr
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
endif|#
directive|endif
if|if
condition|(
name|RELOC_MEMORY_SUB_P
argument_list|(
name|p
argument_list|)
condition|)
name|relocation
operator|-=
name|mask
operator|&
operator|*
operator|(
name|short
operator|*
operator|)
operator|(
name|data
operator|+
name|addr
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|RELOC_MEMORY_ADD_P
argument_list|(
name|p
argument_list|)
condition|)
name|relocation
operator|+=
name|mask
operator|&
operator|*
operator|(
name|short
operator|*
operator|)
operator|(
name|data
operator|+
name|addr
operator|)
expr_stmt|;
operator|*
operator|(
name|short
operator|*
operator|)
operator|(
name|data
operator|+
name|addr
operator|)
operator|&=
operator|~
name|mask
expr_stmt|;
operator|*
operator|(
name|short
operator|*
operator|)
operator|(
name|data
operator|+
name|addr
operator|)
operator||=
name|relocation
expr_stmt|;
ifdef|#
directive|ifdef
name|tahoe
block|}
comment|/* 	   * The CCI Power 6 (aka Tahoe) architecture has byte-aligned 	   * instruction operands but requires data accesses to be aligned. 	   * Brain-damage... 	   */
else|else
block|{
name|unsigned
name|char
modifier|*
name|da
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|data
operator|+
name|addr
operator|)
decl_stmt|;
name|unsigned
name|short
name|s
init|=
name|da
index|[
literal|0
index|]
operator|<<
literal|8
operator||
name|da
index|[
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|RELOC_MEMORY_SUB_P
argument_list|(
name|p
argument_list|)
condition|)
name|relocation
operator|-=
name|mask
operator|&
name|s
expr_stmt|;
elseif|else
if|if
condition|(
name|RELOC_MEMORY_ADD_P
argument_list|(
name|p
argument_list|)
condition|)
name|relocation
operator|+=
name|mask
operator|&
name|s
expr_stmt|;
name|s
operator|&=
operator|~
name|mask
expr_stmt|;
name|s
operator||=
name|relocation
expr_stmt|;
name|da
index|[
literal|0
index|]
operator|=
name|s
operator|>>
literal|8
expr_stmt|;
name|da
index|[
literal|1
index|]
operator|=
name|s
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
case|case
literal|2
case|:
ifndef|#
directive|ifndef
name|_CROSS_TARGET_ARCH
ifdef|#
directive|ifdef
name|tahoe
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|data
operator|+
name|addr
operator|&
literal|3
operator|)
operator|==
literal|0
condition|)
block|{
endif|#
directive|endif
if|if
condition|(
name|RELOC_MEMORY_SUB_P
argument_list|(
name|p
argument_list|)
condition|)
name|relocation
operator|-=
name|mask
operator|&
operator|*
operator|(
name|long
operator|*
operator|)
operator|(
name|data
operator|+
name|addr
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|RELOC_MEMORY_ADD_P
argument_list|(
name|p
argument_list|)
condition|)
name|relocation
operator|+=
name|mask
operator|&
operator|*
operator|(
name|long
operator|*
operator|)
operator|(
name|data
operator|+
name|addr
operator|)
expr_stmt|;
operator|*
operator|(
name|long
operator|*
operator|)
operator|(
name|data
operator|+
name|addr
operator|)
operator|&=
operator|~
name|mask
expr_stmt|;
operator|*
operator|(
name|long
operator|*
operator|)
operator|(
name|data
operator|+
name|addr
operator|)
operator||=
name|relocation
expr_stmt|;
ifdef|#
directive|ifdef
name|tahoe
block|}
else|else
block|{
name|unsigned
name|char
modifier|*
name|da
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|data
operator|+
name|addr
operator|)
decl_stmt|;
name|unsigned
name|long
name|l
init|=
name|da
index|[
literal|0
index|]
operator|<<
literal|24
operator||
name|da
index|[
literal|1
index|]
operator|<<
literal|16
operator||
name|da
index|[
literal|2
index|]
operator|<<
literal|8
operator||
name|da
index|[
literal|3
index|]
decl_stmt|;
if|if
condition|(
name|RELOC_MEMORY_SUB_P
argument_list|(
name|p
argument_list|)
condition|)
name|relocation
operator|-=
name|mask
operator|&
name|l
expr_stmt|;
elseif|else
if|if
condition|(
name|RELOC_MEMORY_ADD_P
argument_list|(
name|p
argument_list|)
condition|)
name|relocation
operator|+=
name|mask
operator|&
name|l
expr_stmt|;
name|l
operator|&=
operator|~
name|mask
expr_stmt|;
name|l
operator||=
name|relocation
expr_stmt|;
name|da
index|[
literal|0
index|]
operator|=
name|l
operator|>>
literal|24
expr_stmt|;
name|da
index|[
literal|1
index|]
operator|=
name|l
operator|>>
literal|16
expr_stmt|;
name|da
index|[
literal|2
index|]
operator|=
name|l
operator|>>
literal|8
expr_stmt|;
name|da
index|[
literal|3
index|]
operator|=
name|l
expr_stmt|;
block|}
endif|#
directive|endif
else|#
directive|else
comment|/* Handle long word alignment requirements of SPARC architecture */
comment|/* WARNING:  This fix makes an assumption on byte ordering */
comment|/* Marc Ullman, Stanford University    Nov. 1 1989  */
if|if
condition|(
name|RELOC_MEMORY_SUB_P
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|relocation
operator|-=
name|mask
operator|&
operator|(
operator|(
operator|*
operator|(
name|unsigned
name|short
operator|*
operator|)
operator|(
name|data
operator|+
name|addr
operator|)
operator|<<
literal|16
operator|)
operator||
operator|*
operator|(
name|unsigned
name|short
operator|*
operator|)
operator|(
name|data
operator|+
name|addr
operator|+
literal|2
operator|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|RELOC_MEMORY_ADD_P
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|relocation
operator|+=
name|mask
operator|&
operator|(
operator|(
operator|*
operator|(
name|unsigned
name|short
operator|*
operator|)
operator|(
name|data
operator|+
name|addr
operator|)
operator|<<
literal|16
operator|)
operator||
operator|*
operator|(
name|unsigned
name|short
operator|*
operator|)
operator|(
name|data
operator|+
name|addr
operator|+
literal|2
operator|)
operator|)
expr_stmt|;
block|}
operator|*
operator|(
name|unsigned
name|short
operator|*
operator|)
operator|(
name|data
operator|+
name|addr
operator|)
operator|&=
operator|(
operator|~
name|mask
operator|>>
literal|16
operator|)
expr_stmt|;
operator|*
operator|(
name|unsigned
name|short
operator|*
operator|)
operator|(
name|data
operator|+
name|addr
operator|+
literal|2
operator|)
operator|&=
operator|(
operator|~
name|mask
operator|&
literal|0xffff
operator|)
expr_stmt|;
operator|*
operator|(
name|unsigned
name|short
operator|*
operator|)
operator|(
name|data
operator|+
name|addr
operator|)
operator||=
operator|(
name|relocation
operator|>>
literal|16
operator|)
expr_stmt|;
operator|*
operator|(
name|unsigned
name|short
operator|*
operator|)
operator|(
name|data
operator|+
name|addr
operator|+
literal|2
operator|)
operator||=
operator|(
name|relocation
operator|&
literal|0xffff
operator|)
expr_stmt|;
endif|#
directive|endif
break|break;
default|default:
name|fatal_with_file
argument_list|(
literal|"Unimplemented relocation field length in "
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* For relocatable_output only: write out the relocation,    relocating the addresses-to-be-relocated.  */
end_comment

begin_decl_stmt
name|void
name|coptxtrel
argument_list|()
decl_stmt|,
name|copdatrel
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|write_rel
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|count
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|trace_files
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Writing text relocation:\n\n"
argument_list|)
expr_stmt|;
comment|/* Assign each global symbol a sequence number, giving the order      in which `write_syms' will write it.      This is so we can store the proper symbolnum fields      in relocation entries we write.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TABSIZE
condition|;
name|i
operator|++
control|)
block|{
name|symbol
modifier|*
name|sp
decl_stmt|;
for|for
control|(
name|sp
operator|=
name|symtab
index|[
name|i
index|]
init|;
name|sp
condition|;
name|sp
operator|=
name|sp
operator|->
name|link
control|)
if|if
condition|(
name|sp
operator|->
name|referenced
operator|||
name|sp
operator|->
name|defined
condition|)
block|{
name|sp
operator|->
name|def_count
operator|=
name|count
operator|++
expr_stmt|;
comment|/* Leave room for the reference required by N_INDR, if 	       necessary.  */
if|if
condition|(
operator|(
name|sp
operator|->
name|defined
operator|&
operator|~
name|N_EXT
operator|)
operator|==
name|N_INDR
condition|)
name|count
operator|++
expr_stmt|;
block|}
block|}
comment|/* Correct, because if (relocatable_output), we will also be writing      whatever indirect blocks we have.  */
if|if
condition|(
name|count
operator|!=
name|defined_global_sym_count
operator|+
name|undefined_global_sym_count
operator|+
name|global_indirect_count
condition|)
name|fatal
argument_list|(
literal|"internal error"
argument_list|)
expr_stmt|;
comment|/* Write out the relocations of all files, remembered from copy_text.  */
name|each_full_file
argument_list|(
name|coptxtrel
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|trace_files
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nWriting data relocation:\n\n"
argument_list|)
expr_stmt|;
name|each_full_file
argument_list|(
name|copdatrel
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|trace_files
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|coptxtrel
parameter_list|(
name|entry
parameter_list|)
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
block|{
specifier|register
name|struct
name|relocation_info
modifier|*
name|p
decl_stmt|,
modifier|*
name|end
decl_stmt|;
specifier|register
name|int
name|reloc
init|=
name|entry
operator|->
name|text_start_address
decl_stmt|;
name|p
operator|=
name|entry
operator|->
name|textrel
expr_stmt|;
name|end
operator|=
operator|(
expr|struct
name|relocation_info
operator|*
operator|)
operator|(
name|entry
operator|->
name|header
operator|.
name|a_trsize
operator|+
operator|(
name|char
operator|*
operator|)
name|p
operator|)
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|end
condition|)
block|{
name|RELOC_ADDRESS
argument_list|(
name|p
argument_list|)
operator|+=
name|reloc
expr_stmt|;
if|if
condition|(
name|RELOC_EXTERN_P
argument_list|(
name|p
argument_list|)
condition|)
block|{
specifier|register
name|int
name|symindex
init|=
name|RELOC_SYMBOL
argument_list|(
name|p
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
decl_stmt|;
name|symbol
modifier|*
name|symptr
init|=
operator|(
operator|(
name|symbol
operator|*
operator|)
operator|(
operator|(
operator|(
expr|struct
name|nlist
operator|*
operator|)
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|entry
operator|->
name|symbols
operator|)
operator|+
name|symindex
operator|)
operator|)
operator|->
name|n_un
operator|.
name|n_name
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|symindex
operator|>=
name|entry
operator|->
name|header
operator|.
name|a_syms
condition|)
name|fatal_with_file
argument_list|(
literal|"relocation symbolnum out of range in "
argument_list|,
name|entry
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|N_INDR
comment|/* Resolve indirection.  */
if|if
condition|(
operator|(
name|symptr
operator|->
name|defined
operator|&
operator|~
name|N_EXT
operator|)
operator|==
name|N_INDR
condition|)
name|symptr
operator|=
operator|(
name|symbol
operator|*
operator|)
name|symptr
operator|->
name|value
expr_stmt|;
endif|#
directive|endif
comment|/* If the symbol is now defined, change the external relocation 	     to an internal one.  */
if|if
condition|(
name|symptr
operator|->
name|defined
condition|)
block|{
name|RELOC_EXTERN_P
argument_list|(
name|p
argument_list|)
operator|=
literal|0
expr_stmt|;
name|RELOC_SYMBOL
argument_list|(
name|p
argument_list|)
operator|=
operator|(
name|symptr
operator|->
name|defined
operator|&
name|N_TYPE
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RELOC_ADD_EXTRA
comment|/* If we aren't going to be adding in the value in 	         memory on the next pass of the loader, then we need 		 to add it in from the relocation entry.  Otherwise 	         the work we did in this pass is lost.  */
if|if
condition|(
operator|!
name|RELOC_MEMORY_ADD_P
argument_list|(
name|p
argument_list|)
condition|)
name|RELOC_ADD_EXTRA
argument_list|(
name|p
argument_list|)
operator|+=
name|symptr
operator|->
name|value
expr_stmt|;
endif|#
directive|endif
block|}
else|else
comment|/* Debugger symbols come first, so have to start this 	       after them.  */
name|RELOC_SYMBOL
argument_list|(
name|p
argument_list|)
operator|=
operator|(
name|symptr
operator|->
name|def_count
operator|+
name|nsyms
operator|-
name|defined_global_sym_count
operator|-
name|undefined_global_sym_count
operator|-
name|global_indirect_count
operator|)
expr_stmt|;
block|}
name|p
operator|++
expr_stmt|;
block|}
name|mywrite
argument_list|(
name|entry
operator|->
name|textrel
argument_list|,
literal|1
argument_list|,
name|entry
operator|->
name|header
operator|.
name|a_trsize
argument_list|,
name|outdesc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|copdatrel
parameter_list|(
name|entry
parameter_list|)
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
block|{
specifier|register
name|struct
name|relocation_info
modifier|*
name|p
decl_stmt|,
modifier|*
name|end
decl_stmt|;
comment|/* Relocate the address of the relocation.      Old address is relative to start of the input file's data section.      New address is relative to start of the output file's data section.  */
specifier|register
name|int
name|reloc
init|=
name|entry
operator|->
name|data_start_address
operator|-
name|text_size
decl_stmt|;
name|p
operator|=
name|entry
operator|->
name|datarel
expr_stmt|;
name|end
operator|=
operator|(
expr|struct
name|relocation_info
operator|*
operator|)
operator|(
name|entry
operator|->
name|header
operator|.
name|a_drsize
operator|+
operator|(
name|char
operator|*
operator|)
name|p
operator|)
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|end
condition|)
block|{
name|RELOC_ADDRESS
argument_list|(
name|p
argument_list|)
operator|+=
name|reloc
expr_stmt|;
if|if
condition|(
name|RELOC_EXTERN_P
argument_list|(
name|p
argument_list|)
condition|)
block|{
specifier|register
name|int
name|symindex
init|=
name|RELOC_SYMBOL
argument_list|(
name|p
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
decl_stmt|;
name|symbol
modifier|*
name|symptr
init|=
operator|(
operator|(
name|symbol
operator|*
operator|)
operator|(
operator|(
operator|(
expr|struct
name|nlist
operator|*
operator|)
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|entry
operator|->
name|symbols
operator|)
operator|+
name|symindex
operator|)
operator|)
operator|->
name|n_un
operator|.
name|n_name
operator|)
operator|)
decl_stmt|;
name|int
name|symtype
decl_stmt|;
if|if
condition|(
name|symindex
operator|>=
name|entry
operator|->
name|header
operator|.
name|a_syms
condition|)
name|fatal_with_file
argument_list|(
literal|"relocation symbolnum out of range in "
argument_list|,
name|entry
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|N_INDR
comment|/* Resolve indirection.  */
if|if
condition|(
operator|(
name|symptr
operator|->
name|defined
operator|&
operator|~
name|N_EXT
operator|)
operator|==
name|N_INDR
condition|)
name|symptr
operator|=
operator|(
name|symbol
operator|*
operator|)
name|symptr
operator|->
name|value
expr_stmt|;
endif|#
directive|endif
name|symtype
operator|=
name|symptr
operator|->
name|defined
operator|&
name|N_TYPE
expr_stmt|;
if|if
condition|(
name|force_common_definition
operator|||
name|symtype
operator|==
name|N_DATA
operator|||
name|symtype
operator|==
name|N_TEXT
operator|||
name|symtype
operator|==
name|N_ABS
condition|)
block|{
name|RELOC_EXTERN_P
argument_list|(
name|p
argument_list|)
operator|=
literal|0
expr_stmt|;
name|RELOC_SYMBOL
argument_list|(
name|p
argument_list|)
operator|=
name|symtype
expr_stmt|;
block|}
else|else
comment|/* Debugger symbols come first, so have to start this 	       after them.  */
name|RELOC_SYMBOL
argument_list|(
name|p
argument_list|)
operator|=
operator|(
operator|(
operator|(
name|symbol
operator|*
operator|)
operator|(
operator|(
operator|(
expr|struct
name|nlist
operator|*
operator|)
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|entry
operator|->
name|symbols
operator|)
operator|+
name|symindex
operator|)
operator|)
operator|->
name|n_un
operator|.
name|n_name
operator|)
operator|)
operator|->
name|def_count
operator|+
name|nsyms
operator|-
name|defined_global_sym_count
operator|-
name|undefined_global_sym_count
operator|-
name|global_indirect_count
operator|)
expr_stmt|;
block|}
name|p
operator|++
expr_stmt|;
block|}
name|mywrite
argument_list|(
name|entry
operator|->
name|datarel
argument_list|,
literal|1
argument_list|,
name|entry
operator|->
name|header
operator|.
name|a_drsize
argument_list|,
name|outdesc
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function_decl
name|void
name|write_file_syms
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|write_string_table
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Offsets and current lengths of symbol and string tables in output file. */
end_comment

begin_decl_stmt
name|int
name|symbol_table_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|symbol_table_len
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Address in output file where string table starts.  */
end_comment

begin_decl_stmt
name|int
name|string_table_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Offset within string table    where the strings in `strtab_vector' should be written.  */
end_comment

begin_decl_stmt
name|int
name|string_table_len
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Total size of string table strings allocated so far,    including strings in `strtab_vector'.  */
end_comment

begin_decl_stmt
name|int
name|strtab_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Vector whose elements are strings to be added to the string table.  */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|strtab_vector
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Vector whose elements are the lengths of those strings.  */
end_comment

begin_decl_stmt
name|int
modifier|*
name|strtab_lens
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index in `strtab_vector' at which the next string will be stored.  */
end_comment

begin_decl_stmt
name|int
name|strtab_index
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Add the string NAME to the output file string table.    Record it in `strtab_vector' to be output later.    Return the index within the string table that this string will have.  */
end_comment

begin_function
name|int
name|assign_string_table_index
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|int
name|index
init|=
name|strtab_size
decl_stmt|;
specifier|register
name|int
name|len
init|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
decl_stmt|;
name|strtab_size
operator|+=
name|len
expr_stmt|;
name|strtab_vector
index|[
name|strtab_index
index|]
operator|=
name|name
expr_stmt|;
name|strtab_lens
index|[
name|strtab_index
operator|++
index|]
operator|=
name|len
expr_stmt|;
return|return
name|index
return|;
block|}
end_function

begin_decl_stmt
name|FILE
modifier|*
name|outstream
init|=
operator|(
name|FILE
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Write the contents of `strtab_vector' into the string table.    This is done once for each file's local&debugger symbols    and once for the global symbols.  */
end_comment

begin_function
name|void
name|write_string_table
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|lseek
argument_list|(
name|outdesc
argument_list|,
name|string_table_offset
operator|+
name|string_table_len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|outstream
condition|)
name|outstream
operator|=
name|fdopen
argument_list|(
name|outdesc
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|strtab_index
condition|;
name|i
operator|++
control|)
block|{
name|fwrite
argument_list|(
name|strtab_vector
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|,
name|strtab_lens
index|[
name|i
index|]
argument_list|,
name|outstream
argument_list|)
expr_stmt|;
name|string_table_len
operator|+=
name|strtab_lens
index|[
name|i
index|]
expr_stmt|;
block|}
name|fflush
argument_list|(
name|outstream
argument_list|)
expr_stmt|;
comment|/* Report I/O error such as disk full.  */
if|if
condition|(
name|ferror
argument_list|(
name|outstream
argument_list|)
condition|)
name|perror_name
argument_list|(
name|output_filename
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Write the symbol table and string table of the output file.  */
end_comment

begin_function
name|void
name|write_syms
parameter_list|()
block|{
comment|/* Number of symbols written so far.  */
name|int
name|syms_written
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|symbol
modifier|*
name|sp
decl_stmt|;
comment|/* Buffer big enough for all the global symbols.  One      extra struct for each indirect symbol to hold the extra reference      following. */
name|struct
name|nlist
modifier|*
name|buf
init|=
operator|(
expr|struct
name|nlist
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|defined_global_sym_count
operator|+
name|undefined_global_sym_count
operator|+
name|global_indirect_count
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Pointer for storing into BUF.  */
specifier|register
name|struct
name|nlist
modifier|*
name|bufp
init|=
name|buf
decl_stmt|;
comment|/* Size of string table includes the bytes that store the size.  */
name|strtab_size
operator|=
sizeof|sizeof
name|strtab_size
expr_stmt|;
name|symbol_table_offset
operator|=
name|N_SYMOFF
argument_list|(
name|outheader
argument_list|)
expr_stmt|;
name|symbol_table_len
operator|=
literal|0
expr_stmt|;
name|string_table_offset
operator|=
name|N_STROFF
argument_list|(
name|outheader
argument_list|)
expr_stmt|;
name|string_table_len
operator|=
name|strtab_size
expr_stmt|;
if|if
condition|(
name|strip_symbols
operator|==
name|STRIP_ALL
condition|)
return|return;
comment|/* Write the local symbols defined by the various files.  */
name|each_file
argument_list|(
name|write_file_syms
argument_list|,
operator|&
name|syms_written
argument_list|)
expr_stmt|;
name|file_close
argument_list|()
expr_stmt|;
comment|/* Now write out the global symbols.  */
comment|/* Allocate two vectors that record the data to generate the string      table from the global symbols written so far.  This must include      extra space for the references following indirect outputs. */
name|strtab_vector
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|num_hash_tab_syms
operator|+
name|global_indirect_count
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|strtab_lens
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|num_hash_tab_syms
operator|+
name|global_indirect_count
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|strtab_index
operator|=
literal|0
expr_stmt|;
comment|/* Scan the symbol hash table, bucket by bucket.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TABSIZE
condition|;
name|i
operator|++
control|)
for|for
control|(
name|sp
operator|=
name|symtab
index|[
name|i
index|]
init|;
name|sp
condition|;
name|sp
operator|=
name|sp
operator|->
name|link
control|)
block|{
name|struct
name|nlist
name|nl
decl_stmt|;
name|nl
operator|.
name|n_other
operator|=
literal|0
expr_stmt|;
name|nl
operator|.
name|n_desc
operator|=
literal|0
expr_stmt|;
comment|/* Compute a `struct nlist' for the symbol.  */
if|if
condition|(
name|sp
operator|->
name|defined
operator|||
name|sp
operator|->
name|referenced
condition|)
block|{
comment|/* common condition needs to be before undefined condition */
comment|/* because unallocated commons are set undefined in */
comment|/* digest_symbols */
if|if
condition|(
name|sp
operator|->
name|defined
operator|>
literal|1
condition|)
comment|/* defined with known type */
block|{
comment|/* If the target of an indirect symbol has been 		   defined and we are outputting an executable, 		   resolve the indirection; it's no longer needed */
if|if
condition|(
operator|!
name|relocatable_output
operator|&&
operator|(
operator|(
name|sp
operator|->
name|defined
operator|&
name|N_TYPE
operator|)
operator|==
name|N_INDR
operator|)
operator|&&
operator|(
operator|(
operator|(
name|symbol
operator|*
operator|)
name|sp
operator|->
name|value
operator|)
operator|->
name|defined
operator|>
literal|1
operator|)
condition|)
block|{
name|symbol
modifier|*
name|newsp
init|=
operator|(
name|symbol
operator|*
operator|)
name|sp
operator|->
name|value
decl_stmt|;
name|nl
operator|.
name|n_type
operator|=
name|newsp
operator|->
name|defined
expr_stmt|;
name|nl
operator|.
name|n_value
operator|=
name|newsp
operator|->
name|value
expr_stmt|;
block|}
else|else
block|{
name|nl
operator|.
name|n_type
operator|=
name|sp
operator|->
name|defined
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|defined
operator|!=
operator|(
name|N_INDR
operator||
name|N_EXT
operator|)
condition|)
name|nl
operator|.
name|n_value
operator|=
name|sp
operator|->
name|value
expr_stmt|;
else|else
name|nl
operator|.
name|n_value
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sp
operator|->
name|max_common_size
condition|)
comment|/* defined as common but not allocated. */
block|{
comment|/* happens only with -r and not -d */
comment|/* write out a common definition */
name|nl
operator|.
name|n_type
operator|=
name|N_UNDF
operator||
name|N_EXT
expr_stmt|;
name|nl
operator|.
name|n_value
operator|=
name|sp
operator|->
name|max_common_size
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|sp
operator|->
name|defined
condition|)
comment|/* undefined -- legit only if -r */
block|{
name|nl
operator|.
name|n_type
operator|=
name|N_UNDF
operator||
name|N_EXT
expr_stmt|;
name|nl
operator|.
name|n_value
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|fatal
argument_list|(
literal|"internal error: %s defined in mysterious way"
argument_list|,
name|sp
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* Allocate string table space for the symbol name.  */
name|nl
operator|.
name|n_un
operator|.
name|n_strx
operator|=
name|assign_string_table_index
argument_list|(
name|sp
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* Output to the buffer and count it.  */
operator|*
name|bufp
operator|++
operator|=
name|nl
expr_stmt|;
name|syms_written
operator|++
expr_stmt|;
if|if
condition|(
name|nl
operator|.
name|n_type
operator|==
operator|(
name|N_INDR
operator||
name|N_EXT
operator|)
condition|)
block|{
name|struct
name|nlist
name|xtra_ref
decl_stmt|;
name|xtra_ref
operator|.
name|n_type
operator|=
name|N_EXT
operator||
name|N_UNDF
expr_stmt|;
name|xtra_ref
operator|.
name|n_un
operator|.
name|n_strx
operator|=
name|assign_string_table_index
argument_list|(
operator|(
operator|(
name|symbol
operator|*
operator|)
name|sp
operator|->
name|value
operator|)
operator|->
name|name
argument_list|)
expr_stmt|;
name|xtra_ref
operator|.
name|n_other
operator|=
literal|0
expr_stmt|;
name|xtra_ref
operator|.
name|n_desc
operator|=
literal|0
expr_stmt|;
name|xtra_ref
operator|.
name|n_value
operator|=
literal|0
expr_stmt|;
operator|*
name|bufp
operator|++
operator|=
name|xtra_ref
expr_stmt|;
name|syms_written
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/* Output the buffer full of `struct nlist's.  */
name|lseek
argument_list|(
name|outdesc
argument_list|,
name|symbol_table_offset
operator|+
name|symbol_table_len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mywrite
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
argument_list|,
name|bufp
operator|-
name|buf
argument_list|,
name|outdesc
argument_list|)
expr_stmt|;
name|symbol_table_len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
operator|*
operator|(
name|bufp
operator|-
name|buf
operator|)
expr_stmt|;
if|if
condition|(
name|syms_written
operator|!=
name|nsyms
condition|)
name|fatal
argument_list|(
literal|"internal error: wrong number of symbols written into output file"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbol_table_offset
operator|+
name|symbol_table_len
operator|!=
name|string_table_offset
condition|)
name|fatal
argument_list|(
literal|"internal error: inconsistent symbol table length"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Now the total string table size is known, so write it.      We are already positioned at the right place in the file.  */
name|mywrite
argument_list|(
operator|&
name|strtab_size
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
literal|1
argument_list|,
name|outdesc
argument_list|)
expr_stmt|;
comment|/* we're at right place */
comment|/* Write the strings for the global symbols.  */
name|write_string_table
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Write the local and debugger symbols of file ENTRY.    Increment *SYMS_WRITTEN_ADDR for each symbol that is written.  */
end_comment

begin_comment
comment|/* Note that we do not combine identical names of local symbols.    dbx or gdb would be confused if we did that.  */
end_comment

begin_function
name|void
name|write_file_syms
parameter_list|(
name|entry
parameter_list|,
name|syms_written_addr
parameter_list|)
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
name|int
modifier|*
name|syms_written_addr
decl_stmt|;
block|{
specifier|register
name|struct
name|nlist
modifier|*
name|p
init|=
name|entry
operator|->
name|symbols
decl_stmt|;
specifier|register
name|struct
name|nlist
modifier|*
name|end
init|=
name|p
operator|+
name|entry
operator|->
name|header
operator|.
name|a_syms
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
decl_stmt|;
comment|/* Buffer to accumulate all the syms before writing them.      It has one extra slot for the local symbol we generate here.  */
name|struct
name|nlist
modifier|*
name|buf
init|=
operator|(
expr|struct
name|nlist
operator|*
operator|)
name|alloca
argument_list|(
name|entry
operator|->
name|header
operator|.
name|a_syms
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|nlist
modifier|*
name|bufp
init|=
name|buf
decl_stmt|;
comment|/* Upper bound on number of syms to be written here.  */
name|int
name|max_syms
init|=
operator|(
name|entry
operator|->
name|header
operator|.
name|a_syms
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
operator|)
operator|+
literal|1
decl_stmt|;
comment|/* Make tables that record, for each symbol, its name and its name's length.      The elements are filled in by `assign_string_table_index'.  */
name|strtab_vector
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|alloca
argument_list|(
name|max_syms
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|strtab_lens
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|max_syms
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|strtab_index
operator|=
literal|0
expr_stmt|;
comment|/* Generate a local symbol for the start of this file's text.  */
if|if
condition|(
name|discard_locals
operator|!=
name|DISCARD_ALL
condition|)
block|{
name|struct
name|nlist
name|nl
decl_stmt|;
name|nl
operator|.
name|n_type
operator|=
name|N_FN
operator||
name|N_EXT
expr_stmt|;
name|nl
operator|.
name|n_un
operator|.
name|n_strx
operator|=
name|assign_string_table_index
argument_list|(
name|entry
operator|->
name|local_sym_name
argument_list|)
expr_stmt|;
name|nl
operator|.
name|n_value
operator|=
name|entry
operator|->
name|text_start_address
expr_stmt|;
name|nl
operator|.
name|n_desc
operator|=
literal|0
expr_stmt|;
name|nl
operator|.
name|n_other
operator|=
literal|0
expr_stmt|;
operator|*
name|bufp
operator|++
operator|=
name|nl
expr_stmt|;
operator|(
operator|*
name|syms_written_addr
operator|)
operator|++
expr_stmt|;
name|entry
operator|->
name|local_syms_offset
operator|=
operator|*
name|syms_written_addr
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
expr_stmt|;
block|}
comment|/* Read the file's string table.  */
name|entry
operator|->
name|strings
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|entry
operator|->
name|string_size
argument_list|)
expr_stmt|;
name|read_entry_strings
argument_list|(
name|file_open
argument_list|(
name|entry
argument_list|)
argument_list|,
name|entry
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|p
operator|<
name|end
condition|;
name|p
operator|++
control|)
block|{
specifier|register
name|int
name|type
init|=
name|p
operator|->
name|n_type
decl_stmt|;
specifier|register
name|int
name|write
init|=
literal|0
decl_stmt|;
comment|/* WRITE gets 1 for a non-global symbol that should be written.  */
if|if
condition|(
name|SET_ELEMENT_P
argument_list|(
name|type
argument_list|)
condition|)
comment|/* This occurs even if global.  These */
comment|/* types of symbols are never written */
comment|/* globally, though they are stored */
comment|/* globally.  */
name|write
operator|=
name|relocatable_output
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|type
operator|&
operator|(
name|N_STAB
operator||
name|N_EXT
operator|)
operator|)
condition|)
comment|/* ordinary local symbol */
name|write
operator|=
operator|(
operator|(
name|discard_locals
operator|!=
name|DISCARD_ALL
operator|)
operator|&&
operator|!
operator|(
name|discard_locals
operator|==
name|DISCARD_L
operator|&&
operator|(
name|p
operator|->
name|n_un
operator|.
name|n_strx
operator|+
name|entry
operator|->
name|strings
operator|)
index|[
literal|0
index|]
operator|==
name|LPREFIX
operator|)
operator|&&
name|type
operator|!=
name|N_WARNING
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|type
operator|&
name|N_EXT
operator|)
condition|)
comment|/* debugger symbol */
name|write
operator|=
operator|(
name|strip_symbols
operator|==
name|STRIP_NONE
operator|)
expr_stmt|;
if|if
condition|(
name|write
condition|)
block|{
comment|/* If this symbol has a name, 	     allocate space for it in the output string table.  */
if|if
condition|(
name|p
operator|->
name|n_un
operator|.
name|n_strx
condition|)
name|p
operator|->
name|n_un
operator|.
name|n_strx
operator|=
name|assign_string_table_index
argument_list|(
name|p
operator|->
name|n_un
operator|.
name|n_strx
operator|+
name|entry
operator|->
name|strings
argument_list|)
expr_stmt|;
comment|/* Output this symbol to the buffer and count it.  */
operator|*
name|bufp
operator|++
operator|=
operator|*
name|p
expr_stmt|;
operator|(
operator|*
name|syms_written_addr
operator|)
operator|++
expr_stmt|;
block|}
block|}
comment|/* All the symbols are now in BUF; write them.  */
name|lseek
argument_list|(
name|outdesc
argument_list|,
name|symbol_table_offset
operator|+
name|symbol_table_len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mywrite
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
argument_list|,
name|bufp
operator|-
name|buf
argument_list|,
name|outdesc
argument_list|)
expr_stmt|;
name|symbol_table_len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
operator|*
operator|(
name|bufp
operator|-
name|buf
operator|)
expr_stmt|;
comment|/* Write the string-table data for the symbols just written,      using the data in vectors `strtab_vector' and `strtab_lens'.  */
name|write_string_table
argument_list|()
expr_stmt|;
name|entry
operator|->
name|strings
operator|=
literal|0
expr_stmt|;
comment|/* Since it will dissapear anyway.  */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Copy any GDB symbol segments from the input files to the output file.    The contents of the symbol segment is copied without change    except that we store some information into the beginning of it.  */
end_comment

begin_function_decl
name|void
name|write_file_symseg
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|void
name|write_symsegs
parameter_list|()
block|{
name|each_file
argument_list|(
name|write_file_symseg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|write_file_symseg
parameter_list|(
name|entry
parameter_list|)
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
block|{
name|char
name|buffer
index|[
literal|4096
index|]
decl_stmt|;
name|struct
name|symbol_root
name|root
decl_stmt|;
name|int
name|indesc
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|entry
operator|->
name|symseg_offset
operator|==
literal|0
condition|)
return|return;
comment|/* This entry has a symbol segment.  Read the root of the segment.  */
name|indesc
operator|=
name|file_open
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|indesc
argument_list|,
name|entry
operator|->
name|symseg_offset
operator|+
name|entry
operator|->
name|starting_offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
sizeof|sizeof
name|root
operator|!=
name|read
argument_list|(
name|indesc
argument_list|,
operator|&
name|root
argument_list|,
sizeof|sizeof
name|root
argument_list|)
condition|)
name|fatal_with_file
argument_list|(
literal|"premature end of file in symbol segment of "
argument_list|,
name|entry
argument_list|)
expr_stmt|;
comment|/* Store some relocation info into the root.  */
name|root
operator|.
name|ldsymoff
operator|=
name|entry
operator|->
name|local_syms_offset
expr_stmt|;
name|root
operator|.
name|textrel
operator|=
name|entry
operator|->
name|text_start_address
expr_stmt|;
name|root
operator|.
name|datarel
operator|=
name|entry
operator|->
name|data_start_address
operator|-
name|entry
operator|->
name|header
operator|.
name|a_text
expr_stmt|;
name|root
operator|.
name|bssrel
operator|=
name|entry
operator|->
name|bss_start_address
operator|-
name|entry
operator|->
name|header
operator|.
name|a_text
operator|-
name|entry
operator|->
name|header
operator|.
name|a_data
expr_stmt|;
name|root
operator|.
name|databeg
operator|=
name|entry
operator|->
name|data_start_address
operator|-
name|root
operator|.
name|datarel
expr_stmt|;
name|root
operator|.
name|bssbeg
operator|=
name|entry
operator|->
name|bss_start_address
operator|-
name|root
operator|.
name|bssrel
expr_stmt|;
comment|/* Write the modified root into the output file.  */
name|mywrite
argument_list|(
operator|&
name|root
argument_list|,
sizeof|sizeof
name|root
argument_list|,
literal|1
argument_list|,
name|outdesc
argument_list|)
expr_stmt|;
comment|/* Copy the rest of the symbol segment unchanged.  */
if|if
condition|(
name|entry
operator|->
name|superfile
condition|)
block|{
comment|/* Library member: number of bytes to copy is determined 	 from the member's total size.  */
name|int
name|total
init|=
name|entry
operator|->
name|total_size
operator|-
name|entry
operator|->
name|symseg_offset
operator|-
sizeof|sizeof
name|root
decl_stmt|;
while|while
condition|(
name|total
operator|>
literal|0
condition|)
block|{
name|len
operator|=
name|read
argument_list|(
name|indesc
argument_list|,
name|buffer
argument_list|,
name|min
argument_list|(
sizeof|sizeof
name|buffer
argument_list|,
name|total
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
name|min
argument_list|(
sizeof|sizeof
name|buffer
argument_list|,
name|total
argument_list|)
condition|)
name|fatal_with_file
argument_list|(
literal|"premature end of file in symbol segment of "
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|total
operator|-=
name|len
expr_stmt|;
name|mywrite
argument_list|(
name|buffer
argument_list|,
name|len
argument_list|,
literal|1
argument_list|,
name|outdesc
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* A separate file: copy until end of file.  */
while|while
condition|(
name|len
operator|=
name|read
argument_list|(
name|indesc
argument_list|,
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|)
condition|)
block|{
name|mywrite
argument_list|(
name|buffer
argument_list|,
name|len
argument_list|,
literal|1
argument_list|,
name|outdesc
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
sizeof|sizeof
name|buffer
condition|)
break|break;
block|}
block|}
name|file_close
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create the symbol table entries for `etext', `edata' and `end'.  */
end_comment

begin_function
name|void
name|symtab_init
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|nounderscore
name|edata_symbol
operator|=
name|getsym
argument_list|(
literal|"_edata"
argument_list|)
expr_stmt|;
name|etext_symbol
operator|=
name|getsym
argument_list|(
literal|"_etext"
argument_list|)
expr_stmt|;
name|end_symbol
operator|=
name|getsym
argument_list|(
literal|"_end"
argument_list|)
expr_stmt|;
else|#
directive|else
name|edata_symbol
operator|=
name|getsym
argument_list|(
literal|"edata"
argument_list|)
expr_stmt|;
name|etext_symbol
operator|=
name|getsym
argument_list|(
literal|"etext"
argument_list|)
expr_stmt|;
name|end_symbol
operator|=
name|getsym
argument_list|(
literal|"end"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|sun
block|{
name|symbol
modifier|*
name|dynamic_symbol
init|=
name|getsym
argument_list|(
literal|"__DYNAMIC"
argument_list|)
decl_stmt|;
name|dynamic_symbol
operator|->
name|defined
operator|=
name|N_ABS
operator||
name|N_EXT
expr_stmt|;
name|dynamic_symbol
operator|->
name|referenced
operator|=
literal|1
expr_stmt|;
name|dynamic_symbol
operator|->
name|value
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|sequent
block|{
name|symbol
modifier|*
name|_387_flt_symbol
init|=
name|getsym
argument_list|(
literal|"_387_flt"
argument_list|)
decl_stmt|;
name|_387_flt_symbol
operator|->
name|defined
operator|=
name|N_ABS
operator||
name|N_EXT
expr_stmt|;
name|_387_flt_symbol
operator|->
name|referenced
operator|=
literal|1
expr_stmt|;
name|_387_flt_symbol
operator|->
name|value
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
name|edata_symbol
operator|->
name|defined
operator|=
name|N_DATA
operator||
name|N_EXT
expr_stmt|;
name|etext_symbol
operator|->
name|defined
operator|=
name|N_TEXT
operator||
name|N_EXT
expr_stmt|;
name|end_symbol
operator|->
name|defined
operator|=
name|N_BSS
operator||
name|N_EXT
expr_stmt|;
name|edata_symbol
operator|->
name|referenced
operator|=
literal|1
expr_stmt|;
name|etext_symbol
operator|->
name|referenced
operator|=
literal|1
expr_stmt|;
name|end_symbol
operator|->
name|referenced
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute the hash code for symbol name KEY.  */
end_comment

begin_function
name|int
name|hash_string
parameter_list|(
name|key
parameter_list|)
name|char
modifier|*
name|key
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|k
decl_stmt|;
name|cp
operator|=
name|key
expr_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|cp
condition|)
name|k
operator|=
operator|(
operator|(
operator|(
name|k
operator|<<
literal|1
operator|)
operator|+
operator|(
name|k
operator|>>
literal|14
operator|)
operator|)
operator|^
operator|(
operator|*
name|cp
operator|++
operator|)
operator|)
operator|&
literal|0x3fff
expr_stmt|;
return|return
name|k
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Get the symbol table entry for the global symbol named KEY.    Create one if there is none.  */
end_comment

begin_function
name|symbol
modifier|*
name|getsym
parameter_list|(
name|key
parameter_list|)
name|char
modifier|*
name|key
decl_stmt|;
block|{
specifier|register
name|int
name|hashval
decl_stmt|;
specifier|register
name|symbol
modifier|*
name|bp
decl_stmt|;
comment|/* Determine the proper bucket.  */
name|hashval
operator|=
name|hash_string
argument_list|(
name|key
argument_list|)
operator|%
name|TABSIZE
expr_stmt|;
comment|/* Search the bucket.  */
for|for
control|(
name|bp
operator|=
name|symtab
index|[
name|hashval
index|]
init|;
name|bp
condition|;
name|bp
operator|=
name|bp
operator|->
name|link
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|key
argument_list|,
name|bp
operator|->
name|name
argument_list|)
condition|)
return|return
name|bp
return|;
comment|/* Nothing was found; create a new symbol table entry.  */
name|bp
operator|=
operator|(
name|symbol
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|bp
operator|->
name|refs
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|key
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|bp
operator|->
name|name
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|bp
operator|->
name|defined
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|referenced
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|trace
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|value
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|max_common_size
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|warning
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|undef_refs
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|multiply_defined
operator|=
literal|0
expr_stmt|;
comment|/* Add the entry to the bucket.  */
name|bp
operator|->
name|link
operator|=
name|symtab
index|[
name|hashval
index|]
expr_stmt|;
name|symtab
index|[
name|hashval
index|]
operator|=
name|bp
expr_stmt|;
operator|++
name|num_hash_tab_syms
expr_stmt|;
return|return
name|bp
return|;
block|}
end_function

begin_comment
comment|/* Like `getsym' but return 0 if the symbol is not already known.  */
end_comment

begin_function
name|symbol
modifier|*
name|getsym_soft
parameter_list|(
name|key
parameter_list|)
name|char
modifier|*
name|key
decl_stmt|;
block|{
specifier|register
name|int
name|hashval
decl_stmt|;
specifier|register
name|symbol
modifier|*
name|bp
decl_stmt|;
comment|/* Determine which bucket.  */
name|hashval
operator|=
name|hash_string
argument_list|(
name|key
argument_list|)
operator|%
name|TABSIZE
expr_stmt|;
comment|/* Search the bucket.  */
for|for
control|(
name|bp
operator|=
name|symtab
index|[
name|hashval
index|]
init|;
name|bp
condition|;
name|bp
operator|=
name|bp
operator|->
name|link
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|key
argument_list|,
name|bp
operator|->
name|name
argument_list|)
condition|)
return|return
name|bp
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Report a fatal error.    STRING is a printf format string and ARG is one arg for it.  */
end_comment

begin_function
name|void
name|fatal
parameter_list|(
name|string
parameter_list|,
name|arg
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|,
decl|*
name|arg
decl_stmt|;
end_function

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ld: "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|string
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Report a fatal error.  The error message is STRING    followed by the filename of ENTRY.  */
end_comment

begin_function
name|void
name|fatal_with_file
parameter_list|(
name|string
parameter_list|,
name|entry
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ld: "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|print_file_name
argument_list|(
name|entry
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Report a fatal error using the message for the last failed system call,    followed by the string NAME.  */
end_comment

begin_function
name|void
name|perror_name
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|extern
name|int
name|errno
decl_stmt|,
name|sys_nerr
decl_stmt|;
specifier|extern
name|char
modifier|*
name|sys_errlist
index|[]
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|errno
operator|<
name|sys_nerr
condition|)
name|s
operator|=
name|concat
argument_list|(
literal|""
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|,
literal|" for %s"
argument_list|)
expr_stmt|;
else|else
name|s
operator|=
literal|"cannot open %s"
expr_stmt|;
name|fatal
argument_list|(
name|s
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Report a fatal error using the message for the last failed system call,    followed by the name of file ENTRY.  */
end_comment

begin_function
name|void
name|perror_file
parameter_list|(
name|entry
parameter_list|)
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
block|{
specifier|extern
name|int
name|errno
decl_stmt|,
name|sys_nerr
decl_stmt|;
specifier|extern
name|char
modifier|*
name|sys_errlist
index|[]
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|errno
operator|<
name|sys_nerr
condition|)
name|s
operator|=
name|concat
argument_list|(
literal|""
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|,
literal|" for "
argument_list|)
expr_stmt|;
else|else
name|s
operator|=
literal|"cannot open "
expr_stmt|;
name|fatal_with_file
argument_list|(
name|s
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Report a nonfatal error.    STRING is a format for printf, and ARG1 ... ARG3 are args for it.  */
end_comment

begin_function
name|void
name|error
parameter_list|(
name|string
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|,
name|arg3
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|,
decl|*
name|arg1
decl_stmt|,
modifier|*
name|arg2
decl_stmt|,
modifier|*
name|arg3
decl_stmt|;
end_function

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|string
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Output COUNT*ELTSIZE bytes of data at BUF    to the descriptor DESC.  */
end_comment

begin_function
name|void
name|mywrite
parameter_list|(
name|buf
parameter_list|,
name|count
parameter_list|,
name|eltsize
parameter_list|,
name|desc
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|eltsize
decl_stmt|;
name|int
name|desc
decl_stmt|;
block|{
specifier|register
name|int
name|val
decl_stmt|;
specifier|register
name|int
name|bytes
init|=
name|count
operator|*
name|eltsize
decl_stmt|;
while|while
condition|(
name|bytes
operator|>
literal|0
condition|)
block|{
name|val
operator|=
name|write
argument_list|(
name|desc
argument_list|,
name|buf
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<=
literal|0
condition|)
name|perror_name
argument_list|(
name|output_filename
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|val
expr_stmt|;
name|bytes
operator|-=
name|val
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Output PADDING zero-bytes to descriptor OUTDESC.    PADDING may be negative; in that case, do nothing.  */
end_comment

begin_function
name|void
name|padfile
parameter_list|(
name|padding
parameter_list|,
name|outdesc
parameter_list|)
name|int
name|padding
decl_stmt|;
name|int
name|outdesc
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|buf
decl_stmt|;
if|if
condition|(
name|padding
operator|<=
literal|0
condition|)
return|return;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|padding
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|buf
argument_list|,
name|padding
argument_list|)
expr_stmt|;
name|mywrite
argument_list|(
name|buf
argument_list|,
name|padding
argument_list|,
literal|1
argument_list|,
name|outdesc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a newly-allocated string    whose contents concatenate the strings S1, S2, S3.  */
end_comment

begin_function
name|char
modifier|*
name|concat
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|,
name|s3
parameter_list|)
name|char
modifier|*
name|s1
decl_stmt|,
decl|*
name|s2
decl_stmt|,
modifier|*
name|s3
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|len1
init|=
name|strlen
argument_list|(
name|s1
argument_list|)
decl_stmt|,
name|len2
init|=
name|strlen
argument_list|(
name|s2
argument_list|)
decl_stmt|,
name|len3
init|=
name|strlen
argument_list|(
name|s3
argument_list|)
decl_stmt|;
specifier|register
name|char
modifier|*
name|result
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|len1
operator|+
name|len2
operator|+
name|len3
operator|+
literal|1
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|result
argument_list|,
name|s1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|result
operator|+
name|len1
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|result
operator|+
name|len1
operator|+
name|len2
argument_list|,
name|s3
argument_list|)
expr_stmt|;
name|result
index|[
name|len1
operator|+
name|len2
operator|+
name|len3
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|result
return|;
block|}
end_block

begin_comment
comment|/* Parse the string ARG using scanf format FORMAT, and return the result.    If it does not parse, report fatal error    generating the error message using format string ERROR and ARG as arg.  */
end_comment

begin_function
name|int
name|parse
parameter_list|(
name|arg
parameter_list|,
name|format
parameter_list|,
name|error
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|,
decl|*
name|format
decl_stmt|;
end_function

begin_block
block|{
name|int
name|x
decl_stmt|;
if|if
condition|(
literal|1
operator|!=
name|sscanf
argument_list|(
name|arg
argument_list|,
name|format
argument_list|,
operator|&
name|x
argument_list|)
condition|)
name|fatal
argument_list|(
name|error
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
end_block

begin_comment
comment|/* Like malloc but get fatal error if memory is exhausted.  */
end_comment

begin_function
name|int
name|xmalloc
parameter_list|(
name|size
parameter_list|)
name|int
name|size
decl_stmt|;
block|{
specifier|register
name|int
name|result
init|=
name|malloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
name|fatal
argument_list|(
literal|"virtual memory exhausted"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Like realloc but get fatal error if memory is exhausted.  */
end_comment

begin_function
name|int
name|xrealloc
parameter_list|(
name|ptr
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
specifier|register
name|int
name|result
init|=
name|realloc
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
name|fatal
argument_list|(
literal|"virtual memory exhausted"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_function
name|void
name|bzero
parameter_list|(
name|p
parameter_list|,
name|n
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
block|{
name|memset
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bcopy
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|,
name|n
parameter_list|)
name|char
modifier|*
name|from
decl_stmt|,
decl|*
name|to
decl_stmt|;
end_function

begin_block
block|{
name|memcpy
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|getpagesize
argument_list|()
end_macro

begin_block
block|{
return|return
operator|(
literal|4096
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
operator|&&
operator|(
name|TARGET
operator|==
name|SUN4
operator|)
end_if

begin_comment
comment|/* Don't use local pagesize to build for Sparc.  */
end_comment

begin_macro
name|getpagesize
argument_list|()
end_macro

begin_block
block|{
return|return
operator|(
literal|8192
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

