begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * This code is derived from software copyrighted by the Free Software  * Foundation.  *  * Modified 1991 by Donn Seeley at UUNET Technologies, Inc.  *  * Modified 1993 by Paul Kranenburg, Erasmus University  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)ld.c	6.10 (Berkeley) 5/22/91"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/* Linker `ld' for GNU    Copyright (C) 1988 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 1, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* Written by Richard Stallman with some help from Eric Albert.    Set, indirect, and warning symbol features added by Randy Smith. */
end_comment

begin_comment
comment|/*  *	$FreeBSD$  */
end_comment

begin_comment
comment|/* Define how to initialize system-dependent header fields.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<ar.h>
end_include

begin_include
include|#
directive|include
file|<ranlib.h>
end_include

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_include
include|#
directive|include
file|<stab.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"ld.h"
end_include

begin_include
include|#
directive|include
file|"dynamic.h"
end_include

begin_comment
comment|/* Vector of entries for input files specified by arguments.    These are all the input files except for members of specified libraries. */
end_comment

begin_decl_stmt
name|struct
name|file_entry
modifier|*
name|file_table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|number_of_files
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 => write relocation into output file so can re-input it later. */
end_comment

begin_decl_stmt
name|int
name|relocatable_output
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 => building a shared object, set by `-Bshareable'. */
end_comment

begin_decl_stmt
name|int
name|building_shared_object
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 => create the output executable. */
end_comment

begin_decl_stmt
name|int
name|make_executable
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Force the executable to be output, even if there are non-fatal errors */
end_comment

begin_decl_stmt
name|int
name|force_executable
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 => assign space to common symbols even if `relocatable_output'.  */
end_comment

begin_decl_stmt
name|int
name|force_common_definition
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 => assign jmp slots to text symbols in shared objects even if non-PIC */
end_comment

begin_decl_stmt
name|int
name|force_alias_definition
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 => some files contain PIC code, affects relocation bits 	if `relocatable_output'. */
end_comment

begin_decl_stmt
name|int
name|pic_code_seen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 => segments must be page aligned (ZMAGIC, QMAGIC) */
end_comment

begin_decl_stmt
name|int
name|page_align_segments
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 => data segment must be page aligned, even if `-n' or `-N' */
end_comment

begin_decl_stmt
name|int
name|page_align_data
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 => do not use standard library search path */
end_comment

begin_decl_stmt
name|int
name|nostdlib
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Version number to put in __DYNAMIC (set by -V) */
end_comment

begin_decl_stmt
name|int
name|soversion
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|text_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* total size of text. */
end_comment

begin_decl_stmt
name|int
name|text_start
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* start of text */
end_comment

begin_decl_stmt
name|int
name|text_pad
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* clear space between text and data */
end_comment

begin_decl_stmt
name|int
name|data_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* total size of data. */
end_comment

begin_decl_stmt
name|int
name|data_start
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* start of data */
end_comment

begin_decl_stmt
name|int
name|data_pad
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* part of bss segment as part of data */
end_comment

begin_decl_stmt
name|int
name|bss_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* total size of bss. */
end_comment

begin_decl_stmt
name|int
name|bss_start
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* start of bss */
end_comment

begin_decl_stmt
name|int
name|text_reloc_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* total size of text relocation. */
end_comment

begin_decl_stmt
name|int
name|data_reloc_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* total size of data relocation. */
end_comment

begin_decl_stmt
name|int
name|rrs_section_type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* What's in the RRS section */
end_comment

begin_decl_stmt
name|int
name|rrs_text_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size of RRS text additions */
end_comment

begin_decl_stmt
name|int
name|rrs_text_start
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Location of above */
end_comment

begin_decl_stmt
name|int
name|rrs_data_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size of RRS data additions */
end_comment

begin_decl_stmt
name|int
name|rrs_data_start
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Location of above */
end_comment

begin_comment
comment|/* Specifications of start and length of the area reserved at the end    of the data segment for the set vectors.  Computed in 'digest_symbols' */
end_comment

begin_decl_stmt
name|int
name|set_sect_start
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* start of set element vectors */
end_comment

begin_decl_stmt
name|int
name|set_sect_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size of above */
end_comment

begin_decl_stmt
name|int
name|link_mode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current link mode */
end_comment

begin_decl_stmt
name|int
name|pic_type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* PIC type */
end_comment

begin_comment
comment|/*  * When loading the text and data, we can avoid doing a close  * and another open between members of the same library.  *  * These two variables remember the file that is currently open.  * Both are zero if no file is open.  *  * See `each_file' and `file_close'.  */
end_comment

begin_decl_stmt
name|struct
name|file_entry
modifier|*
name|input_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|input_desc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The name of the file to write; "a.out" by default. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|output_filename
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Output file name. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|real_output_filename
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Output file name. */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|outstream
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Output file descriptor. */
end_comment

begin_decl_stmt
name|struct
name|exec
name|outheader
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Output file header. */
end_comment

begin_decl_stmt
name|int
name|magic
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Output file magic. */
end_comment

begin_decl_stmt
name|int
name|oldmagic
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|relocatable_output
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* `-r'-ed output */
end_comment

begin_decl_stmt
name|symbol
modifier|*
name|entry_symbol
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* specified by `-e' */
end_comment

begin_decl_stmt
name|int
name|entry_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* program entry if no `-e' given */
end_comment

begin_decl_stmt
name|int
name|page_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size of a page (machine dependent) */
end_comment

begin_comment
comment|/*  * Keep a list of any symbols referenced from the command line (so  * that error messages for these guys can be generated). This list is  * zero terminated.  */
end_comment

begin_decl_stmt
name|symbol
modifier|*
modifier|*
name|cmdline_references
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cl_refs_allocated
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Which symbols should be stripped (omitted from the output): none, all, or  * debugger symbols.  */
end_comment

begin_enum
enum|enum
block|{
name|STRIP_NONE
block|,
name|STRIP_ALL
block|,
name|STRIP_DEBUGGER
block|}
name|strip_symbols
enum|;
end_enum

begin_comment
comment|/*  * Which local symbols should be omitted: none, all, or those starting with L.  * This is irrelevant if STRIP_NONE.  */
end_comment

begin_enum
enum|enum
block|{
name|DISCARD_NONE
block|,
name|DISCARD_ALL
block|,
name|DISCARD_L
block|}
name|discard_locals
enum|;
end_enum

begin_decl_stmt
name|int
name|global_sym_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # of nlist entries for global symbols */
end_comment

begin_decl_stmt
name|int
name|size_sym_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # of N_SIZE nlist entries for output 				  (relocatable_output only) */
end_comment

begin_decl_stmt
name|int
name|local_sym_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # of nlist entries for local symbols. */
end_comment

begin_decl_stmt
name|int
name|non_L_local_sym_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # of nlist entries for non-L symbols */
end_comment

begin_decl_stmt
name|int
name|debugger_sym_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # of nlist entries for debugger info. */
end_comment

begin_decl_stmt
name|int
name|undefined_global_sym_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # of global symbols referenced and 					   not defined. */
end_comment

begin_decl_stmt
name|int
name|undefined_shobj_sym_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # of undefined symbols referenced 					   by shared objects */
end_comment

begin_decl_stmt
name|int
name|multiple_def_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # of multiply defined symbols. */
end_comment

begin_decl_stmt
name|int
name|defined_global_sym_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # of defined global symbols. */
end_comment

begin_decl_stmt
name|int
name|common_defined_global_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # of common symbols. */
end_comment

begin_decl_stmt
name|int
name|undefined_weak_sym_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # of weak symbols referenced and 					   not defined. */
end_comment

begin_if
if|#
directive|if
name|notused
end_if

begin_decl_stmt
name|int
name|special_sym_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # of linker defined symbols. */
end_comment

begin_comment
comment|/* XXX - Currently, only __DYNAMIC and _G_O_T_ go here if required, 	 *  perhaps _etext, _edata and _end should go here too. 	 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|global_alias_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # of aliased symbols */
end_comment

begin_decl_stmt
name|int
name|set_symbol_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # of N_SET* symbols. */
end_comment

begin_decl_stmt
name|int
name|set_vector_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # of set vectors in output. */
end_comment

begin_decl_stmt
name|int
name|warn_sym_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # of warning symbols encountered. */
end_comment

begin_decl_stmt
name|int
name|list_warning_symbols
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 => warning symbols referenced */
end_comment

begin_decl_stmt
name|struct
name|string_list_element
modifier|*
name|set_element_prefixes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|trace_files
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* print names of input files as processed (`-t'). */
end_comment

begin_decl_stmt
name|int
name|write_map
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* write a load map (`-M') */
end_comment

begin_comment
comment|/*  * `text-start' address is normally this much plus a page boundary.  * This is not a user option; it is fixed for each system.  */
end_comment

begin_decl_stmt
name|int
name|text_start_alignment
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Nonzero if -T was specified in the command line.  * This prevents text_start from being set later to default values.  */
end_comment

begin_decl_stmt
name|int
name|T_flag_specified
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Nonzero if -Tdata was specified in the command line.  * This prevents data_start from being set later to default values.  */
end_comment

begin_decl_stmt
name|int
name|Tdata_flag_specified
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Size to pad data section up to.  * We simply increase the size of the data section, padding with zeros,  * and reduce the size of the bss section to match.  */
end_comment

begin_decl_stmt
name|int
name|specified_data_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
modifier|*
name|set_vectors
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|setv_fill_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|decode_option
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|decode_command
name|__P
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|classify_arg
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|load_symbols
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|enter_global_ref
name|__P
argument_list|(
operator|(
expr|struct
name|localsymbol
operator|*
operator|,
name|char
operator|*
operator|,
expr|struct
name|file_entry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|digest_symbols
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|digest_pass1
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|,
name|digest_pass2
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|consider_file_section_lengths
name|__P
argument_list|(
operator|(
expr|struct
name|file_entry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|relocate_file_addresses
name|__P
argument_list|(
operator|(
expr|struct
name|file_entry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|consider_relocation
name|__P
argument_list|(
operator|(
expr|struct
name|file_entry
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|consider_local_symbols
name|__P
argument_list|(
operator|(
expr|struct
name|file_entry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|perform_relocation
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
expr|struct
name|relocation_info
operator|*
operator|,
name|int
operator|,
expr|struct
name|file_entry
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|copy_text
name|__P
argument_list|(
operator|(
expr|struct
name|file_entry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|copy_data
name|__P
argument_list|(
operator|(
expr|struct
name|file_entry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|coptxtrel
name|__P
argument_list|(
operator|(
expr|struct
name|file_entry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|copdatrel
name|__P
argument_list|(
operator|(
expr|struct
name|file_entry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_output
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_header
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_text
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_data
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_rel
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_syms
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|assign_symbolnums
name|__P
argument_list|(
operator|(
expr|struct
name|file_entry
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cleanup
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|parse
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
comment|/* Added this to stop ld core-dumping on very large .o files.    */
ifdef|#
directive|ifdef
name|RLIMIT_STACK
comment|/* Get rid of any avoidable limit on stack size.  */
block|{
name|struct
name|rlimit
name|rlim
decl_stmt|;
comment|/* Set the stack limit huge so that alloca does not fail. */
if|if
condition|(
name|getrlimit
argument_list|(
name|RLIMIT_STACK
argument_list|,
operator|&
name|rlim
argument_list|)
operator|!=
literal|0
condition|)
name|warn
argument_list|(
literal|"getrlimit"
argument_list|)
expr_stmt|;
else|else
block|{
name|rlim
operator|.
name|rlim_cur
operator|=
name|rlim
operator|.
name|rlim_max
expr_stmt|;
if|if
condition|(
name|setrlimit
argument_list|(
name|RLIMIT_STACK
argument_list|,
operator|&
name|rlim
argument_list|)
operator|!=
literal|0
condition|)
name|warn
argument_list|(
literal|"setrlimit"
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* RLIMIT_STACK */
name|page_size
operator|=
name|PAGSIZ
expr_stmt|;
comment|/* Clear the cumulative info on the output file.  */
name|text_size
operator|=
literal|0
expr_stmt|;
name|data_size
operator|=
literal|0
expr_stmt|;
name|bss_size
operator|=
literal|0
expr_stmt|;
name|text_reloc_size
operator|=
literal|0
expr_stmt|;
name|data_reloc_size
operator|=
literal|0
expr_stmt|;
name|data_pad
operator|=
literal|0
expr_stmt|;
name|text_pad
operator|=
literal|0
expr_stmt|;
name|page_align_segments
operator|=
literal|0
expr_stmt|;
name|page_align_data
operator|=
literal|0
expr_stmt|;
comment|/* Initialize the data about options.  */
name|specified_data_size
operator|=
literal|0
expr_stmt|;
name|strip_symbols
operator|=
name|STRIP_NONE
expr_stmt|;
name|trace_files
operator|=
literal|0
expr_stmt|;
name|discard_locals
operator|=
name|DISCARD_NONE
expr_stmt|;
name|entry_symbol
operator|=
literal|0
expr_stmt|;
name|write_map
operator|=
literal|0
expr_stmt|;
name|relocatable_output
operator|=
literal|0
expr_stmt|;
name|force_common_definition
operator|=
literal|0
expr_stmt|;
name|T_flag_specified
operator|=
literal|0
expr_stmt|;
name|Tdata_flag_specified
operator|=
literal|0
expr_stmt|;
name|magic
operator|=
name|DEFAULT_MAGIC
expr_stmt|;
name|make_executable
operator|=
literal|1
expr_stmt|;
name|force_executable
operator|=
literal|0
expr_stmt|;
name|link_mode
operator|=
name|DYNAMIC
expr_stmt|;
ifdef|#
directive|ifdef
name|SUNOS4
name|link_mode
operator||=
name|SILLYARCHIVE
expr_stmt|;
endif|#
directive|endif
name|soversion
operator|=
name|DEFAULT_SOVERSION
expr_stmt|;
comment|/* Initialize the cumulative counts of symbols.  */
name|local_sym_count
operator|=
literal|0
expr_stmt|;
name|non_L_local_sym_count
operator|=
literal|0
expr_stmt|;
name|debugger_sym_count
operator|=
literal|0
expr_stmt|;
name|undefined_global_sym_count
operator|=
literal|0
expr_stmt|;
name|warn_sym_count
operator|=
literal|0
expr_stmt|;
name|list_warning_symbols
operator|=
literal|0
expr_stmt|;
name|multiple_def_count
operator|=
literal|0
expr_stmt|;
name|common_defined_global_count
operator|=
literal|0
expr_stmt|;
comment|/* Keep a list of symbols referenced from the command line */
name|cl_refs_allocated
operator|=
literal|10
expr_stmt|;
name|cmdline_references
operator|=
operator|(
name|symbol
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|cl_refs_allocated
operator|*
sizeof|sizeof
argument_list|(
name|symbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|cmdline_references
operator|=
literal|0
expr_stmt|;
comment|/* Completely decode ARGV.  */
name|decode_command
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|building_shared_object
operator|=
operator|(
operator|!
name|relocatable_output
operator|&&
operator|(
name|link_mode
operator|&
name|SHAREABLE
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|building_shared_object
operator|&&
name|entry_symbol
condition|)
block|{
name|errx
argument_list|(
literal|1
argument_list|,
literal|"`-Bshareable' and `-e' options are mutually exclusive"
argument_list|)
expr_stmt|;
block|}
comment|/* Create the symbols `etext', `edata' and `end'.  */
name|symtab_init
argument_list|(
name|relocatable_output
argument_list|)
expr_stmt|;
comment|/* 	 * Determine whether to count the header as part of the text size, 	 * and initialize the text size accordingly. This depends on the kind 	 * of system and on the output format selected. 	 */
if|if
condition|(
name|magic
operator|==
name|ZMAGIC
operator|||
name|magic
operator|==
name|QMAGIC
condition|)
name|page_align_segments
operator|=
literal|1
expr_stmt|;
name|md_init_header
argument_list|(
operator|&
name|outheader
argument_list|,
name|magic
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|text_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|exec
argument_list|)
expr_stmt|;
name|text_size
operator|-=
name|N_TXTOFF
argument_list|(
name|outheader
argument_list|)
expr_stmt|;
if|if
condition|(
name|text_size
operator|<
literal|0
condition|)
name|text_size
operator|=
literal|0
expr_stmt|;
name|entry_offset
operator|=
name|text_size
expr_stmt|;
if|if
condition|(
operator|!
name|T_flag_specified
operator|&&
operator|!
name|relocatable_output
condition|)
name|text_start
operator|=
name|TEXT_START
argument_list|(
name|outheader
argument_list|)
expr_stmt|;
comment|/* The text-start address is normally this far past a page boundary.  */
name|text_start_alignment
operator|=
name|text_start
operator|%
name|page_size
expr_stmt|;
comment|/* 	 * Load symbols of all input files. Also search all libraries and 	 * decide which library members to load. 	 */
name|load_symbols
argument_list|()
expr_stmt|;
comment|/* Compute where each file's sections go, and relocate symbols.  */
name|digest_symbols
argument_list|()
expr_stmt|;
comment|/* 	 * Print error messages for any missing symbols, for any warning 	 * symbols, and possibly multiple definitions 	 */
name|make_executable
operator|&=
name|do_warnings
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
comment|/* Print a map, if requested.  */
if|if
condition|(
name|write_map
condition|)
name|print_symbols
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* Write the output file.  */
if|if
condition|(
name|make_executable
operator|||
name|force_executable
condition|)
name|write_output
argument_list|()
expr_stmt|;
name|exit
argument_list|(
operator|!
name|make_executable
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Analyze a command line argument. Return 0 if the argument is a filename.  * Return 1 if the argument is a option complete in itself. Return 2 if the  * argument is a option which uses an argument.  *  * Thus, the value is the number of consecutive arguments that are part of  * options.  */
end_comment

begin_function
specifier|static
name|int
name|classify_arg
parameter_list|(
name|arg
parameter_list|)
specifier|register
name|char
modifier|*
name|arg
decl_stmt|;
block|{
if|if
condition|(
operator|*
name|arg
operator|!=
literal|'-'
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|arg
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'a'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|&
name|arg
index|[
literal|2
index|]
argument_list|,
literal|"ssert"
argument_list|)
condition|)
return|return
literal|2
return|;
case|case
literal|'A'
case|:
case|case
literal|'D'
case|:
case|case
literal|'e'
case|:
case|case
literal|'L'
case|:
case|case
literal|'l'
case|:
case|case
literal|'O'
case|:
case|case
literal|'o'
case|:
case|case
literal|'R'
case|:
case|case
literal|'u'
case|:
case|case
literal|'V'
case|:
case|case
literal|'y'
case|:
if|if
condition|(
name|arg
index|[
literal|2
index|]
condition|)
return|return
literal|1
return|;
return|return
literal|2
return|;
case|case
literal|'B'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|&
name|arg
index|[
literal|2
index|]
argument_list|,
literal|"static"
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|&
name|arg
index|[
literal|2
index|]
argument_list|,
literal|"dynamic"
argument_list|)
condition|)
return|return
literal|1
return|;
case|case
literal|'T'
case|:
if|if
condition|(
name|arg
index|[
literal|2
index|]
operator|==
literal|0
condition|)
return|return
literal|2
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|&
name|arg
index|[
literal|2
index|]
argument_list|,
literal|"text"
argument_list|)
condition|)
return|return
literal|2
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|&
name|arg
index|[
literal|2
index|]
argument_list|,
literal|"data"
argument_list|)
condition|)
return|return
literal|2
return|;
return|return
literal|1
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Process the command arguments, setting up file_table with an entry for  * each input file, and setting variables according to the options.  */
end_comment

begin_function
specifier|static
name|void
name|decode_command
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|file_entry
modifier|*
name|p
decl_stmt|;
name|number_of_files
operator|=
literal|0
expr_stmt|;
name|output_filename
operator|=
literal|"a.out"
expr_stmt|;
comment|/* 	 * First compute number_of_files so we know how long to make 	 * file_table. 	 * Also process most options completely. 	 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|int
name|code
init|=
name|classify_arg
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
condition|)
block|{
if|if
condition|(
name|i
operator|+
name|code
operator|>
name|argc
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"no argument following %s"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|decode_option
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|argv
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'l'
operator|||
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'A'
condition|)
name|number_of_files
operator|++
expr_stmt|;
name|i
operator|+=
name|code
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|number_of_files
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|number_of_files
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"No input files specified"
argument_list|)
expr_stmt|;
name|p
operator|=
name|file_table
operator|=
operator|(
expr|struct
name|file_entry
operator|*
operator|)
name|xmalloc
argument_list|(
name|number_of_files
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|file_entry
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|p
argument_list|,
name|number_of_files
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|file_entry
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now scan again and fill in file_table.  */
comment|/* All options except -A and -l are ignored here.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|string
decl_stmt|;
specifier|register
name|int
name|code
init|=
name|classify_arg
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
literal|0
condition|)
block|{
name|p
operator|->
name|filename
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
name|p
operator|->
name|local_sym_name
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
name|p
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|code
operator|==
literal|2
condition|)
name|string
operator|=
name|argv
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
else|else
name|string
operator|=
operator|&
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'B'
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|string
argument_list|,
literal|"static"
argument_list|)
operator|==
literal|0
condition|)
name|link_mode
operator|&=
operator|~
name|DYNAMIC
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|string
argument_list|,
literal|"dynamic"
argument_list|)
operator|==
literal|0
condition|)
name|link_mode
operator||=
name|DYNAMIC
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|string
argument_list|,
literal|"symbolic"
argument_list|)
operator|==
literal|0
condition|)
name|link_mode
operator||=
name|SYMBOLIC
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|string
argument_list|,
literal|"forcearchive"
argument_list|)
operator|==
literal|0
condition|)
name|link_mode
operator||=
name|FORCEARCHIVE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|string
argument_list|,
literal|"shareable"
argument_list|)
operator|==
literal|0
condition|)
name|link_mode
operator||=
name|SHAREABLE
expr_stmt|;
ifdef|#
directive|ifdef
name|SUN_COMPAT
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|string
argument_list|,
literal|"silly"
argument_list|)
operator|==
literal|0
condition|)
name|link_mode
operator||=
name|SILLYARCHIVE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|string
argument_list|,
literal|"~silly"
argument_list|)
operator|==
literal|0
condition|)
name|link_mode
operator|&=
operator|~
name|SILLYARCHIVE
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'A'
condition|)
block|{
if|if
condition|(
name|p
operator|!=
name|file_table
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"-A specified before an input file other than the first"
argument_list|)
expr_stmt|;
name|p
operator|->
name|filename
operator|=
name|string
expr_stmt|;
name|p
operator|->
name|local_sym_name
operator|=
name|string
expr_stmt|;
name|p
operator|->
name|flags
operator||=
name|E_JUST_SYMS
expr_stmt|;
name|link_mode
operator|&=
operator|~
name|DYNAMIC
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'l'
condition|)
block|{
name|p
operator|->
name|filename
operator|=
name|string
expr_stmt|;
name|p
operator|->
name|local_sym_name
operator|=
name|concat
argument_list|(
literal|"-l"
argument_list|,
name|string
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|p
operator|->
name|flags
operator||=
name|E_SEARCH_DIRS
expr_stmt|;
if|if
condition|(
name|link_mode
operator|&
name|DYNAMIC
operator|&&
operator|!
name|relocatable_output
condition|)
name|p
operator|->
name|flags
operator||=
name|E_SEARCH_DYNAMIC
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
name|i
operator|+=
name|code
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Now check some option settings for consistency.  */
if|if
condition|(
name|page_align_segments
operator|&&
operator|(
name|text_start
operator|-
name|text_start_alignment
operator|)
operator|&
operator|(
name|page_size
operator|-
literal|1
operator|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"incorrect alignment of text start address"
argument_list|)
expr_stmt|;
comment|/* Append the standard search directories to the user-specified ones. */
name|add_search_path
argument_list|(
name|getenv
argument_list|(
literal|"LD_LIBRARY_PATH"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nostdlib
condition|)
name|std_search_path
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|add_cmdline_ref
parameter_list|(
name|sp
parameter_list|)
name|symbol
modifier|*
name|sp
decl_stmt|;
block|{
name|symbol
modifier|*
modifier|*
name|ptr
decl_stmt|;
for|for
control|(
name|ptr
operator|=
name|cmdline_references
init|;
name|ptr
operator|<
name|cmdline_references
operator|+
name|cl_refs_allocated
operator|&&
operator|*
name|ptr
condition|;
name|ptr
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|ptr
operator|>=
name|cmdline_references
operator|+
name|cl_refs_allocated
operator|-
literal|1
condition|)
block|{
name|int
name|diff
init|=
name|ptr
operator|-
name|cmdline_references
decl_stmt|;
name|cl_refs_allocated
operator|*=
literal|2
expr_stmt|;
name|cmdline_references
operator|=
operator|(
name|symbol
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|cmdline_references
argument_list|,
name|cl_refs_allocated
operator|*
sizeof|sizeof
argument_list|(
name|symbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|cmdline_references
operator|+
name|diff
expr_stmt|;
block|}
operator|*
name|ptr
operator|++
operator|=
name|sp
expr_stmt|;
operator|*
name|ptr
operator|=
operator|(
name|symbol
operator|*
operator|)
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|int
name|set_element_prefixed_p
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|string_list_element
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|p
operator|=
name|set_element_prefixes
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|p
operator|->
name|str
index|[
name|i
index|]
operator|!=
literal|'\0'
operator|&&
operator|(
name|p
operator|->
name|str
index|[
name|i
index|]
operator|==
name|name
index|[
name|i
index|]
operator|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|p
operator|->
name|str
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Record an option and arrange to act on it later. ARG should be the  * following command argument, which may or may not be used by this option.  *  * The `l' and `A' options are ignored here since they actually specify input  * files.  */
end_comment

begin_function
specifier|static
name|void
name|decode_option
parameter_list|(
name|swt
parameter_list|,
name|arg
parameter_list|)
specifier|register
name|char
modifier|*
name|swt
decl_stmt|,
decl|*
name|arg
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|swt
operator|+
literal|1
argument_list|,
literal|"Bstatic"
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|swt
operator|+
literal|1
argument_list|,
literal|"Bdynamic"
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|swt
operator|+
literal|1
argument_list|,
literal|"Bsymbolic"
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|swt
operator|+
literal|1
argument_list|,
literal|"Bforcearchive"
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|swt
operator|+
literal|1
argument_list|,
literal|"Bshareable"
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|swt
operator|+
literal|1
argument_list|,
literal|"assert"
argument_list|)
condition|)
return|return;
ifdef|#
directive|ifdef
name|SUN_COMPAT
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|swt
operator|+
literal|1
argument_list|,
literal|"Bsilly"
argument_list|)
condition|)
return|return;
endif|#
directive|endif
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|swt
operator|+
literal|1
argument_list|,
literal|"Ttext"
argument_list|)
condition|)
block|{
name|text_start
operator|=
name|parse
argument_list|(
name|arg
argument_list|,
literal|"%x"
argument_list|,
literal|"invalid argument to -Ttext"
argument_list|)
expr_stmt|;
name|T_flag_specified
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|swt
operator|+
literal|1
argument_list|,
literal|"Tdata"
argument_list|)
condition|)
block|{
name|rrs_data_start
operator|=
name|parse
argument_list|(
name|arg
argument_list|,
literal|"%x"
argument_list|,
literal|"invalid argument to -Tdata"
argument_list|)
expr_stmt|;
name|Tdata_flag_specified
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|swt
operator|+
literal|1
argument_list|,
literal|"noinhibit-exec"
argument_list|)
condition|)
block|{
name|force_executable
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|swt
operator|+
literal|1
argument_list|,
literal|"nostdlib"
argument_list|)
condition|)
block|{
name|nostdlib
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|swt
index|[
literal|2
index|]
operator|!=
literal|0
condition|)
name|arg
operator|=
operator|&
name|swt
index|[
literal|2
index|]
expr_stmt|;
switch|switch
condition|(
name|swt
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'A'
case|:
return|return;
case|case
literal|'D'
case|:
name|specified_data_size
operator|=
name|parse
argument_list|(
name|arg
argument_list|,
literal|"%x"
argument_list|,
literal|"invalid argument to -D"
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'d'
case|:
if|if
condition|(
name|swt
index|[
literal|2
index|]
operator|==
literal|0
operator|||
operator|*
name|arg
operator|==
literal|'c'
condition|)
name|force_common_definition
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|arg
operator|==
literal|'p'
condition|)
name|force_alias_definition
operator|=
literal|1
expr_stmt|;
else|else
name|errx
argument_list|(
literal|1
argument_list|,
literal|"-d option takes 'c' or 'p' argument"
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'e'
case|:
name|entry_symbol
operator|=
name|getsym
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|entry_symbol
operator|->
name|defined
operator|&&
operator|!
operator|(
name|entry_symbol
operator|->
name|flags
operator|&
name|GS_REFERENCED
operator|)
condition|)
name|undefined_global_sym_count
operator|++
expr_stmt|;
name|entry_symbol
operator|->
name|flags
operator||=
name|GS_REFERENCED
expr_stmt|;
name|add_cmdline_ref
argument_list|(
name|entry_symbol
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'l'
case|:
return|return;
case|case
literal|'L'
case|:
name|add_search_dir
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'M'
case|:
name|write_map
operator|=
literal|1
expr_stmt|;
return|return;
case|case
literal|'N'
case|:
name|magic
operator|=
name|OMAGIC
expr_stmt|;
return|return;
case|case
literal|'n'
case|:
name|magic
operator|=
name|NMAGIC
expr_stmt|;
return|return;
case|case
literal|'O'
case|:
name|output_filename
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|arg
argument_list|)
operator|+
literal|5
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|output_filename
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|output_filename
argument_list|,
literal|".tmp"
argument_list|)
expr_stmt|;
name|real_output_filename
operator|=
name|arg
expr_stmt|;
return|return;
case|case
literal|'o'
case|:
name|output_filename
operator|=
name|arg
expr_stmt|;
return|return;
case|case
literal|'p'
case|:
name|page_align_data
operator|=
literal|1
expr_stmt|;
return|return;
ifdef|#
directive|ifdef
name|QMAGIC
case|case
literal|'Q'
case|:
name|magic
operator|=
name|QMAGIC
expr_stmt|;
return|return;
endif|#
directive|endif
case|case
literal|'r'
case|:
name|relocatable_output
operator|=
literal|1
expr_stmt|;
name|magic
operator|=
name|OMAGIC
expr_stmt|;
name|text_start
operator|=
literal|0
expr_stmt|;
return|return;
case|case
literal|'R'
case|:
name|rrs_search_paths
operator|=
operator|(
name|rrs_search_paths
operator|==
name|NULL
operator|)
condition|?
name|strdup
argument_list|(
name|arg
argument_list|)
else|:
name|concat
argument_list|(
name|rrs_search_paths
argument_list|,
literal|":"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'S'
case|:
name|strip_symbols
operator|=
name|STRIP_DEBUGGER
expr_stmt|;
return|return;
case|case
literal|'s'
case|:
name|strip_symbols
operator|=
name|STRIP_ALL
expr_stmt|;
return|return;
case|case
literal|'T'
case|:
name|text_start
operator|=
name|parse
argument_list|(
name|arg
argument_list|,
literal|"%x"
argument_list|,
literal|"invalid argument to -T"
argument_list|)
expr_stmt|;
name|T_flag_specified
operator|=
literal|1
expr_stmt|;
return|return;
case|case
literal|'t'
case|:
name|trace_files
operator|=
literal|1
expr_stmt|;
return|return;
case|case
literal|'u'
case|:
block|{
specifier|register
name|symbol
modifier|*
name|sp
init|=
name|getsym
argument_list|(
name|arg
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sp
operator|->
name|defined
operator|&&
operator|!
operator|(
name|sp
operator|->
name|flags
operator|&
name|GS_REFERENCED
operator|)
condition|)
name|undefined_global_sym_count
operator|++
expr_stmt|;
name|sp
operator|->
name|flags
operator||=
name|GS_REFERENCED
expr_stmt|;
name|add_cmdline_ref
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
return|return;
if|#
directive|if
literal|1
case|case
literal|'V'
case|:
name|soversion
operator|=
name|parse
argument_list|(
name|arg
argument_list|,
literal|"%d"
argument_list|,
literal|"invalid argument to -V"
argument_list|)
expr_stmt|;
return|return;
endif|#
directive|endif
case|case
literal|'X'
case|:
name|discard_locals
operator|=
name|DISCARD_L
expr_stmt|;
return|return;
case|case
literal|'x'
case|:
name|discard_locals
operator|=
name|DISCARD_ALL
expr_stmt|;
return|return;
case|case
literal|'y'
case|:
block|{
specifier|register
name|symbol
modifier|*
name|sp
init|=
name|getsym
argument_list|(
operator|&
name|swt
index|[
literal|2
index|]
argument_list|)
decl_stmt|;
name|sp
operator|->
name|flags
operator||=
name|GS_TRACE
expr_stmt|;
block|}
return|return;
case|case
literal|'z'
case|:
name|magic
operator|=
name|ZMAGIC
expr_stmt|;
name|oldmagic
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
name|netzmagic
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
return|return;
case|case
literal|'Z'
case|:
name|magic
operator|=
name|oldmagic
operator|=
name|ZMAGIC
expr_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
name|netzmagic
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
return|return;
default|default:
name|errx
argument_list|(
literal|1
argument_list|,
literal|"invalid command option `%s'"
argument_list|,
name|swt
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Convenient functions for operating on one or all files being loaded. */
end_comment

begin_comment
comment|/*  * Call FUNCTION on each input file entry. Do not call for entries for  * libraries; instead, call once for each library member that is being  * loaded.  *  * FUNCTION receives two arguments: the entry, and ARG.  */
end_comment

begin_decl_stmt
name|void
name|each_file
argument_list|(
name|function
argument_list|,
name|arg
argument_list|)
decl|register
name|void
argument_list|(
operator|*
name|function
argument_list|)
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|void
modifier|*
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|number_of_files
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|struct
name|file_entry
modifier|*
name|entry
init|=
operator|&
name|file_table
index|[
name|i
index|]
decl_stmt|;
specifier|register
name|struct
name|file_entry
modifier|*
name|subentry
decl_stmt|;
if|if
condition|(
name|entry
operator|->
name|flags
operator|&
name|E_SCRAPPED
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|entry
operator|->
name|flags
operator|&
name|E_IS_LIBRARY
operator|)
condition|)
call|(
modifier|*
name|function
call|)
argument_list|(
name|entry
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|subentry
operator|=
name|entry
operator|->
name|subfiles
expr_stmt|;
for|for
control|(
init|;
name|subentry
condition|;
name|subentry
operator|=
name|subentry
operator|->
name|chain
control|)
block|{
if|if
condition|(
name|subentry
operator|->
name|flags
operator|&
name|E_SCRAPPED
condition|)
continue|continue;
call|(
modifier|*
name|function
call|)
argument_list|(
name|subentry
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SUN_COMPAT
if|if
condition|(
name|entry
operator|->
name|silly_archive
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|entry
operator|->
name|flags
operator|&
name|E_DYNAMIC
operator|)
condition|)
name|warnx
argument_list|(
literal|"Silly"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|entry
operator|->
name|silly_archive
operator|->
name|flags
operator|&
name|E_IS_LIBRARY
operator|)
condition|)
name|warnx
argument_list|(
literal|"Sillier"
argument_list|)
expr_stmt|;
name|subentry
operator|=
name|entry
operator|->
name|silly_archive
operator|->
name|subfiles
expr_stmt|;
for|for
control|(
init|;
name|subentry
condition|;
name|subentry
operator|=
name|subentry
operator|->
name|chain
control|)
block|{
if|if
condition|(
name|subentry
operator|->
name|flags
operator|&
name|E_SCRAPPED
condition|)
continue|continue;
call|(
modifier|*
name|function
call|)
argument_list|(
name|subentry
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
block|}
end_block

begin_comment
comment|/*  * Call FUNCTION on each input file entry until it returns a non-zero value.  * Return this value. Do not call for entries for libraries; instead, call  * once for each library member that is being loaded.  *  * FUNCTION receives two arguments: the entry, and ARG.  It must be a function  * returning unsigned long (though this can probably be fudged).  */
end_comment

begin_decl_stmt
name|unsigned
name|long
name|check_each_file
argument_list|(
name|function
argument_list|,
name|arg
argument_list|)
decl|register
name|unsigned
name|long
argument_list|(
operator|*
name|function
argument_list|)
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|void
modifier|*
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|unsigned
name|long
name|return_val
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|number_of_files
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|struct
name|file_entry
modifier|*
name|entry
init|=
operator|&
name|file_table
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|entry
operator|->
name|flags
operator|&
name|E_SCRAPPED
condition|)
continue|continue;
if|if
condition|(
name|entry
operator|->
name|flags
operator|&
name|E_IS_LIBRARY
condition|)
block|{
specifier|register
name|struct
name|file_entry
modifier|*
name|subentry
init|=
name|entry
operator|->
name|subfiles
decl_stmt|;
for|for
control|(
init|;
name|subentry
condition|;
name|subentry
operator|=
name|subentry
operator|->
name|chain
control|)
block|{
if|if
condition|(
name|subentry
operator|->
name|flags
operator|&
name|E_SCRAPPED
condition|)
continue|continue;
if|if
condition|(
operator|(
name|return_val
operator|=
call|(
modifier|*
name|function
call|)
argument_list|(
name|subentry
argument_list|,
name|arg
argument_list|)
operator|)
condition|)
return|return
name|return_val
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|return_val
operator|=
call|(
modifier|*
name|function
call|)
argument_list|(
name|entry
argument_list|,
name|arg
argument_list|)
operator|)
condition|)
return|return
name|return_val
return|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Like `each_file' but ignore files that were just for symbol definitions.  */
end_comment

begin_decl_stmt
name|void
name|each_full_file
argument_list|(
name|function
argument_list|,
name|arg
argument_list|)
decl|register
name|void
argument_list|(
operator|*
name|function
argument_list|)
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|void
modifier|*
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|number_of_files
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|struct
name|file_entry
modifier|*
name|entry
init|=
operator|&
name|file_table
index|[
name|i
index|]
decl_stmt|;
specifier|register
name|struct
name|file_entry
modifier|*
name|subentry
decl_stmt|;
if|if
condition|(
name|entry
operator|->
name|flags
operator|&
operator|(
name|E_SCRAPPED
operator||
name|E_JUST_SYMS
operator|)
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|SUN_COMPAT
if|if
condition|(
name|entry
operator|->
name|silly_archive
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|entry
operator|->
name|flags
operator|&
name|E_DYNAMIC
operator|)
condition|)
name|warnx
argument_list|(
literal|"Silly"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|entry
operator|->
name|silly_archive
operator|->
name|flags
operator|&
name|E_IS_LIBRARY
operator|)
condition|)
name|warnx
argument_list|(
literal|"Sillier"
argument_list|)
expr_stmt|;
name|subentry
operator|=
name|entry
operator|->
name|silly_archive
operator|->
name|subfiles
expr_stmt|;
for|for
control|(
init|;
name|subentry
condition|;
name|subentry
operator|=
name|subentry
operator|->
name|chain
control|)
block|{
if|if
condition|(
name|subentry
operator|->
name|flags
operator|&
name|E_SCRAPPED
condition|)
continue|continue;
call|(
modifier|*
name|function
call|)
argument_list|(
name|subentry
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|entry
operator|->
name|flags
operator|&
name|E_DYNAMIC
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|entry
operator|->
name|flags
operator|&
name|E_IS_LIBRARY
operator|)
condition|)
call|(
modifier|*
name|function
call|)
argument_list|(
name|entry
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|subentry
operator|=
name|entry
operator|->
name|subfiles
expr_stmt|;
for|for
control|(
init|;
name|subentry
condition|;
name|subentry
operator|=
name|subentry
operator|->
name|chain
control|)
block|{
if|if
condition|(
name|subentry
operator|->
name|flags
operator|&
name|E_SCRAPPED
condition|)
continue|continue;
call|(
modifier|*
name|function
call|)
argument_list|(
name|subentry
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/* Close the input file that is now open.  */
end_comment

begin_function
name|void
name|file_close
parameter_list|()
block|{
name|close
argument_list|(
name|input_desc
argument_list|)
expr_stmt|;
name|input_desc
operator|=
literal|0
expr_stmt|;
name|input_file
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Open the input file specified by 'entry', and return a descriptor. The  * open file is remembered; if the same file is opened twice in a row, a new  * open is not actually done.  */
end_comment

begin_function
name|int
name|file_open
parameter_list|(
name|entry
parameter_list|)
specifier|register
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
block|{
specifier|register
name|int
name|fd
decl_stmt|;
if|if
condition|(
name|entry
operator|->
name|superfile
operator|&&
operator|(
name|entry
operator|->
name|superfile
operator|->
name|flags
operator|&
name|E_IS_LIBRARY
operator|)
condition|)
return|return
name|file_open
argument_list|(
name|entry
operator|->
name|superfile
argument_list|)
return|;
if|if
condition|(
name|entry
operator|==
name|input_file
condition|)
return|return
name|input_desc
return|;
if|if
condition|(
name|input_file
condition|)
name|file_close
argument_list|()
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|flags
operator|&
name|E_SEARCH_DIRS
condition|)
block|{
name|fd
operator|=
name|findlib
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
else|else
name|fd
operator|=
name|open
argument_list|(
name|entry
operator|->
name|filename
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
block|{
name|input_file
operator|=
name|entry
expr_stmt|;
name|input_desc
operator|=
name|fd
expr_stmt|;
return|return
name|fd
return|;
block|}
if|if
condition|(
name|entry
operator|->
name|flags
operator|&
name|E_SEARCH_DIRS
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: no match"
argument_list|,
name|entry
operator|->
name|local_sym_name
argument_list|)
expr_stmt|;
else|else
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|entry
operator|->
name|filename
argument_list|)
expr_stmt|;
return|return
name|fd
return|;
block|}
end_function

begin_function
name|int
name|text_offset
parameter_list|(
name|entry
parameter_list|)
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
block|{
return|return
name|entry
operator|->
name|starting_offset
operator|+
name|N_TXTOFF
argument_list|(
name|entry
operator|->
name|header
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/*  * Read a file's header into the proper place in the file_entry. FD is the  * descriptor on which the file is open. ENTRY is the file's entry.  */
end_comment

begin_function
name|void
name|read_header
parameter_list|(
name|fd
parameter_list|,
name|entry
parameter_list|)
name|int
name|fd
decl_stmt|;
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
block|{
specifier|register
name|int
name|len
decl_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
name|entry
operator|->
name|starting_offset
argument_list|,
name|L_SET
argument_list|)
operator|!=
name|entry
operator|->
name|starting_offset
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s: read_header: lseek"
argument_list|,
name|get_file_name
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|read
argument_list|(
name|fd
argument_list|,
operator|&
name|entry
operator|->
name|header
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|exec
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|exec
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s: read_header: read"
argument_list|,
name|get_file_name
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|md_swapin_exec_hdr
argument_list|(
operator|&
name|entry
operator|->
name|header
argument_list|)
expr_stmt|;
if|if
condition|(
name|N_BADMAG
argument_list|(
name|entry
operator|->
name|header
argument_list|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: bad magic"
argument_list|,
name|get_file_name
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|N_BADMID
argument_list|(
name|entry
operator|->
name|header
argument_list|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: non-native input file"
argument_list|,
name|get_file_name
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|flags
operator||=
name|E_HEADER_VALID
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Read the symbols of file ENTRY into core. Assume it is already open, on  * descriptor FD. Also read the length of the string table, which follows  * the symbol table, but don't read the contents of the string table.  */
end_comment

begin_function
name|void
name|read_entry_symbols
parameter_list|(
name|fd
parameter_list|,
name|entry
parameter_list|)
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
name|int
name|fd
decl_stmt|;
block|{
name|int
name|str_size
decl_stmt|;
name|struct
name|nlist
modifier|*
name|np
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|entry
operator|->
name|flags
operator|&
name|E_HEADER_VALID
operator|)
condition|)
name|read_header
argument_list|(
name|fd
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|np
operator|=
operator|(
expr|struct
name|nlist
operator|*
operator|)
name|alloca
argument_list|(
name|entry
operator|->
name|header
operator|.
name|a_syms
argument_list|)
expr_stmt|;
name|entry
operator|->
name|nsymbols
operator|=
name|entry
operator|->
name|header
operator|.
name|a_syms
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|nsymbols
operator|==
literal|0
condition|)
return|return;
name|entry
operator|->
name|symbols
operator|=
operator|(
expr|struct
name|localsymbol
operator|*
operator|)
name|xmalloc
argument_list|(
name|entry
operator|->
name|nsymbols
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|localsymbol
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
name|N_SYMOFF
argument_list|(
name|entry
operator|->
name|header
argument_list|)
operator|+
name|entry
operator|->
name|starting_offset
argument_list|,
name|L_SET
argument_list|)
operator|!=
name|N_SYMOFF
argument_list|(
name|entry
operator|->
name|header
argument_list|)
operator|+
name|entry
operator|->
name|starting_offset
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s: read_symbols: lseek(syms)"
argument_list|,
name|get_file_name
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|header
operator|.
name|a_syms
operator|!=
name|read
argument_list|(
name|fd
argument_list|,
name|np
argument_list|,
name|entry
operator|->
name|header
operator|.
name|a_syms
argument_list|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: read_symbols: premature end of file in symbols"
argument_list|,
name|get_file_name
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|md_swapin_symbols
argument_list|(
name|np
argument_list|,
name|entry
operator|->
name|header
operator|.
name|a_syms
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|entry
operator|->
name|nsymbols
condition|;
name|i
operator|++
control|)
block|{
name|entry
operator|->
name|symbols
index|[
name|i
index|]
operator|.
name|nzlist
operator|.
name|nlist
operator|=
operator|*
name|np
operator|++
expr_stmt|;
name|entry
operator|->
name|symbols
index|[
name|i
index|]
operator|.
name|nzlist
operator|.
name|nz_size
operator|=
literal|0
expr_stmt|;
name|entry
operator|->
name|symbols
index|[
name|i
index|]
operator|.
name|symbol
operator|=
name|NULL
expr_stmt|;
name|entry
operator|->
name|symbols
index|[
name|i
index|]
operator|.
name|next
operator|=
name|NULL
expr_stmt|;
name|entry
operator|->
name|symbols
index|[
name|i
index|]
operator|.
name|entry
operator|=
name|entry
expr_stmt|;
name|entry
operator|->
name|symbols
index|[
name|i
index|]
operator|.
name|gotslot_offset
operator|=
operator|-
literal|1
expr_stmt|;
name|entry
operator|->
name|symbols
index|[
name|i
index|]
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
block|}
name|entry
operator|->
name|strings_offset
operator|=
name|N_STROFF
argument_list|(
name|entry
operator|->
name|header
argument_list|)
operator|+
name|entry
operator|->
name|starting_offset
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
name|entry
operator|->
name|strings_offset
argument_list|,
literal|0
argument_list|)
operator|==
operator|(
name|off_t
operator|)
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s: read_symbols: lseek(strings)"
argument_list|,
name|get_file_name
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
sizeof|sizeof
name|str_size
operator|!=
name|read
argument_list|(
name|fd
argument_list|,
operator|&
name|str_size
argument_list|,
sizeof|sizeof
name|str_size
argument_list|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: read_symbols: cannot read string table size"
argument_list|,
name|get_file_name
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|string_size
operator|=
name|md_swap_long
argument_list|(
name|str_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Read the string table of file ENTRY open on descriptor FD, into core.  */
end_comment

begin_function
name|void
name|read_entry_strings
parameter_list|(
name|fd
parameter_list|,
name|entry
parameter_list|)
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
name|int
name|fd
decl_stmt|;
block|{
if|if
condition|(
name|entry
operator|->
name|string_size
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
operator|!
operator|(
name|entry
operator|->
name|flags
operator|&
name|E_HEADER_VALID
operator|)
operator|||
operator|!
name|entry
operator|->
name|strings_offset
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: read_strings: string table unavailable"
argument_list|,
name|get_file_name
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
name|entry
operator|->
name|strings_offset
argument_list|,
name|L_SET
argument_list|)
operator|!=
name|entry
operator|->
name|strings_offset
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s: read_strings: lseek"
argument_list|,
name|get_file_name
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
name|entry
operator|->
name|strings
argument_list|,
name|entry
operator|->
name|string_size
argument_list|)
operator|!=
name|entry
operator|->
name|string_size
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: read_strings: premature end of file in strings"
argument_list|,
name|get_file_name
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Read in the relocation sections of ENTRY if necessary */
end_comment

begin_function
name|void
name|read_entry_relocation
parameter_list|(
name|fd
parameter_list|,
name|entry
parameter_list|)
name|int
name|fd
decl_stmt|;
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
block|{
specifier|register
name|struct
name|relocation_info
modifier|*
name|reloc
decl_stmt|;
name|off_t
name|pos
decl_stmt|;
if|if
condition|(
operator|!
name|entry
operator|->
name|textrel
condition|)
block|{
name|reloc
operator|=
operator|(
expr|struct
name|relocation_info
operator|*
operator|)
name|xmalloc
argument_list|(
name|entry
operator|->
name|header
operator|.
name|a_trsize
argument_list|)
expr_stmt|;
name|pos
operator|=
name|text_offset
argument_list|(
name|entry
argument_list|)
operator|+
name|entry
operator|->
name|header
operator|.
name|a_text
operator|+
name|entry
operator|->
name|header
operator|.
name|a_data
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
name|pos
argument_list|,
name|L_SET
argument_list|)
operator|!=
name|pos
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s: read_reloc(text): lseek"
argument_list|,
name|get_file_name
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
name|reloc
argument_list|,
name|entry
operator|->
name|header
operator|.
name|a_trsize
argument_list|)
operator|!=
name|entry
operator|->
name|header
operator|.
name|a_trsize
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: read_reloc(text): premature EOF"
argument_list|,
name|get_file_name
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|md_swapin_reloc
argument_list|(
name|reloc
argument_list|,
name|entry
operator|->
name|header
operator|.
name|a_trsize
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|reloc
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|textrel
operator|=
name|reloc
expr_stmt|;
name|entry
operator|->
name|ntextrel
operator|=
name|entry
operator|->
name|header
operator|.
name|a_trsize
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|reloc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|entry
operator|->
name|datarel
condition|)
block|{
name|reloc
operator|=
operator|(
expr|struct
name|relocation_info
operator|*
operator|)
name|xmalloc
argument_list|(
name|entry
operator|->
name|header
operator|.
name|a_drsize
argument_list|)
expr_stmt|;
name|pos
operator|=
name|text_offset
argument_list|(
name|entry
argument_list|)
operator|+
name|entry
operator|->
name|header
operator|.
name|a_text
operator|+
name|entry
operator|->
name|header
operator|.
name|a_data
operator|+
name|entry
operator|->
name|header
operator|.
name|a_trsize
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
name|pos
argument_list|,
name|L_SET
argument_list|)
operator|!=
name|pos
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s: read_reloc(data): lseek"
argument_list|,
name|get_file_name
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
name|reloc
argument_list|,
name|entry
operator|->
name|header
operator|.
name|a_drsize
argument_list|)
operator|!=
name|entry
operator|->
name|header
operator|.
name|a_drsize
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: read_reloc(data): premature EOF"
argument_list|,
name|get_file_name
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|md_swapin_reloc
argument_list|(
name|reloc
argument_list|,
name|entry
operator|->
name|header
operator|.
name|a_drsize
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|reloc
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|datarel
operator|=
name|reloc
expr_stmt|;
name|entry
operator|->
name|ndatarel
operator|=
name|entry
operator|->
name|header
operator|.
name|a_drsize
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|reloc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/*  * Read in the symbols of all input files.  */
end_comment

begin_function
specifier|static
name|void
name|load_symbols
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|trace_files
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Loading symbols:\n\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|number_of_files
condition|;
name|i
operator|++
control|)
name|read_file_symbols
argument_list|(
operator|&
name|file_table
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|trace_files
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * If ENTRY is a rel file, read its symbol and string sections into core. If  * it is a library, search it and load the appropriate members (which means  * calling this function recursively on those members).  */
end_comment

begin_function
name|void
name|read_file_symbols
parameter_list|(
name|entry
parameter_list|)
specifier|register
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
block|{
specifier|register
name|int
name|fd
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
name|struct
name|exec
name|hdr
decl_stmt|;
name|fd
operator|=
name|file_open
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|len
operator|=
name|read
argument_list|(
name|fd
argument_list|,
operator|&
name|hdr
argument_list|,
sizeof|sizeof
name|hdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
sizeof|sizeof
name|hdr
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: read_file_symbols(header): premature EOF"
argument_list|,
name|get_file_name
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|md_swapin_exec_hdr
argument_list|(
operator|&
name|hdr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|N_BADMAG
argument_list|(
name|hdr
argument_list|)
condition|)
block|{
if|if
condition|(
name|N_IS_DYNAMIC
argument_list|(
name|hdr
argument_list|)
operator|&&
operator|!
operator|(
name|entry
operator|->
name|flags
operator|&
name|E_JUST_SYMS
operator|)
condition|)
block|{
if|if
condition|(
name|relocatable_output
condition|)
block|{
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: -r and shared objects currently not supported"
argument_list|,
name|get_file_name
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|#
directive|if
name|notyet
comment|/* Compatibility */
if|if
condition|(
operator|!
operator|(
name|N_GETFLAG
argument_list|(
name|hdr
argument_list|)
operator|&
name|EX_PIC
operator|)
condition|)
name|warnx
argument_list|(
literal|"%s: EX_PIC not set"
argument_list|,
name|get_file_name
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|entry
operator|->
name|flags
operator||=
name|E_DYNAMIC
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|superfile
operator|||
name|rrs_add_shobj
argument_list|(
name|entry
argument_list|)
condition|)
name|read_shared_object
argument_list|(
name|fd
argument_list|,
name|entry
argument_list|)
expr_stmt|;
else|else
name|entry
operator|->
name|flags
operator||=
name|E_SCRAPPED
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|N_GETFLAG
argument_list|(
name|hdr
argument_list|)
operator|&
name|EX_PIC
condition|)
name|pic_code_seen
operator|=
literal|1
expr_stmt|;
name|read_entry_symbols
argument_list|(
name|fd
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|entry
operator|->
name|strings
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|entry
operator|->
name|string_size
argument_list|)
expr_stmt|;
name|read_entry_strings
argument_list|(
name|fd
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|read_entry_relocation
argument_list|(
name|fd
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|enter_file_symbols
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|entry
operator|->
name|strings
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|char
name|armag
index|[
name|SARMAG
index|]
decl_stmt|;
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|SARMAG
operator|!=
name|read
argument_list|(
name|fd
argument_list|,
name|armag
argument_list|,
name|SARMAG
argument_list|)
operator|||
name|strncmp
argument_list|(
name|armag
argument_list|,
name|ARMAG
argument_list|,
name|SARMAG
argument_list|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: malformed input file (not rel or archive)"
argument_list|,
name|get_file_name
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|flags
operator||=
name|E_IS_LIBRARY
expr_stmt|;
name|search_library
argument_list|(
name|fd
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
name|file_close
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Enter the external symbol defs and refs of ENTRY in the hash table.  */
end_comment

begin_function
name|void
name|enter_file_symbols
parameter_list|(
name|entry
parameter_list|)
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
block|{
name|struct
name|localsymbol
modifier|*
name|lsp
decl_stmt|,
modifier|*
name|lspend
decl_stmt|;
if|if
condition|(
name|trace_files
condition|)
name|prline_file_name
argument_list|(
name|entry
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|lspend
operator|=
name|entry
operator|->
name|symbols
operator|+
name|entry
operator|->
name|nsymbols
expr_stmt|;
for|for
control|(
name|lsp
operator|=
name|entry
operator|->
name|symbols
init|;
name|lsp
operator|<
name|lspend
condition|;
name|lsp
operator|++
control|)
block|{
specifier|register
name|struct
name|nlist
modifier|*
name|p
init|=
operator|&
name|lsp
operator|->
name|nzlist
operator|.
name|nlist
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|n_type
operator|==
operator|(
name|N_SETV
operator||
name|N_EXT
operator|)
condition|)
continue|continue;
comment|/* 		 * Turn magically prefixed symbols into set symbols of 		 * a corresponding type. 		 */
if|if
condition|(
name|set_element_prefixes
operator|&&
name|set_element_prefixed_p
argument_list|(
name|entry
operator|->
name|strings
operator|+
name|lsp
operator|->
name|nzlist
operator|.
name|nz_strx
argument_list|)
condition|)
name|lsp
operator|->
name|nzlist
operator|.
name|nz_type
operator|+=
operator|(
name|N_SETA
operator|-
name|N_ABS
operator|)
expr_stmt|;
if|if
condition|(
name|SET_ELEMENT_P
argument_list|(
name|p
operator|->
name|n_type
argument_list|)
condition|)
block|{
name|set_symbol_count
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|relocatable_output
condition|)
name|enter_global_ref
argument_list|(
name|lsp
argument_list|,
name|p
operator|->
name|n_un
operator|.
name|n_strx
operator|+
name|entry
operator|->
name|strings
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|n_type
operator|==
name|N_WARNING
condition|)
block|{
name|char
modifier|*
name|msg
init|=
name|p
operator|->
name|n_un
operator|.
name|n_strx
operator|+
name|entry
operator|->
name|strings
decl_stmt|;
comment|/* Grab the next entry.  */
name|lsp
operator|++
expr_stmt|;
name|p
operator|=
operator|&
name|lsp
operator|->
name|nzlist
operator|.
name|nlist
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|n_type
operator|!=
operator|(
name|N_UNDF
operator||
name|N_EXT
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: Warning symbol without external reference following."
argument_list|,
name|get_file_name
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|make_executable
operator|=
literal|0
expr_stmt|;
name|lsp
operator|--
expr_stmt|;
comment|/* Process normally.  */
block|}
else|else
block|{
name|symbol
modifier|*
name|sp
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|p
operator|->
name|n_un
operator|.
name|n_strx
operator|+
name|entry
operator|->
name|strings
decl_stmt|;
comment|/* Deal with the warning symbol.  */
name|lsp
operator|->
name|flags
operator||=
name|LS_WARNING
expr_stmt|;
name|enter_global_ref
argument_list|(
name|lsp
argument_list|,
name|name
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|sp
operator|=
name|getsym
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|warning
operator|==
name|NULL
condition|)
block|{
name|sp
operator|->
name|warning
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|msg
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|sp
operator|->
name|warning
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|warn_sym_count
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|sp
operator|->
name|warning
argument_list|,
name|msg
argument_list|)
condition|)
name|warnx
argument_list|(
literal|"%s: multiple definitions for warning symbol `%s'"
argument_list|,
name|get_file_name
argument_list|(
name|entry
argument_list|)
argument_list|,
name|demangle
argument_list|(
name|sp
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|n_type
operator|&
name|N_EXT
condition|)
block|{
name|enter_global_ref
argument_list|(
name|lsp
argument_list|,
name|p
operator|->
name|n_un
operator|.
name|n_strx
operator|+
name|entry
operator|->
name|strings
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|n_un
operator|.
name|n_strx
operator|&&
operator|(
name|p
operator|->
name|n_un
operator|.
name|n_strx
operator|+
name|entry
operator|->
name|strings
operator|)
index|[
literal|0
index|]
operator|==
name|LPREFIX
condition|)
name|lsp
operator|->
name|flags
operator||=
name|LS_L_SYMBOL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Enter one global symbol in the hash table. LSP points to the `struct  * localsymbol' from the file that describes the global symbol.  NAME is the  * symbol's name. ENTRY is the file entry for the file the symbol comes from.  *  * LSP is put on the chain of all such structs that refer to the same symbol.  * This chain starts in the `refs' for symbols from relocatable objects. A  * backpointer to the global symbol is kept in LSP.  *  * Symbols from shared objects are linked through `soref'. For such symbols  * that's all we do at this stage, with the exception of the case where the  * symbol is a common. The `referenced' bit is only set for references from  * relocatable objects.  *  */
end_comment

begin_function
specifier|static
name|void
name|enter_global_ref
parameter_list|(
name|lsp
parameter_list|,
name|name
parameter_list|,
name|entry
parameter_list|)
name|struct
name|localsymbol
modifier|*
name|lsp
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
block|{
specifier|register
name|struct
name|nzlist
modifier|*
name|nzp
init|=
operator|&
name|lsp
operator|->
name|nzlist
decl_stmt|;
specifier|register
name|symbol
modifier|*
name|sp
init|=
name|getsym
argument_list|(
name|name
argument_list|)
decl_stmt|;
specifier|register
name|int
name|type
init|=
name|nzp
operator|->
name|nz_type
decl_stmt|;
name|int
name|oldref
init|=
operator|(
name|sp
operator|->
name|flags
operator|&
name|GS_REFERENCED
operator|)
decl_stmt|;
name|int
name|olddef
init|=
name|sp
operator|->
name|defined
decl_stmt|;
name|int
name|com
init|=
name|sp
operator|->
name|defined
operator|&&
name|sp
operator|->
name|common_size
decl_stmt|;
if|if
condition|(
name|type
operator|==
operator|(
name|N_INDR
operator||
name|N_EXT
operator|)
operator|&&
operator|!
name|olddef
condition|)
block|{
name|sp
operator|->
name|alias
operator|=
name|getsym
argument_list|(
name|entry
operator|->
name|strings
operator|+
operator|(
name|lsp
operator|+
literal|1
operator|)
operator|->
name|nzlist
operator|.
name|nz_strx
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|sp
operator|->
name|alias
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: %s is alias for itself"
argument_list|,
name|get_file_name
argument_list|(
name|entry
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Rewrite symbol as global text symbol with value 0 */
name|lsp
operator|->
name|nzlist
operator|.
name|nz_type
operator|=
name|N_TEXT
operator||
name|N_EXT
expr_stmt|;
name|lsp
operator|->
name|nzlist
operator|.
name|nz_value
operator|=
literal|0
expr_stmt|;
name|make_executable
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|global_alias_count
operator|++
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|if (sp->flags& GS_REFERENCED) 			sp->alias->flags |= GS_REFERENCED;
endif|#
directive|endif
block|}
if|if
condition|(
name|entry
operator|->
name|flags
operator|&
name|E_DYNAMIC
condition|)
block|{
name|lsp
operator|->
name|next
operator|=
name|sp
operator|->
name|sorefs
expr_stmt|;
name|sp
operator|->
name|sorefs
operator|=
name|lsp
expr_stmt|;
name|lsp
operator|->
name|symbol
operator|=
name|sp
expr_stmt|;
comment|/* 		 * Handle commons from shared objects: 		 *   1) If symbol hitherto undefined, turn it into a common. 		 *   2) If symbol already common, update size if necessary. 		 */
comment|/*XXX - look at case where commons are only in shared objects */
if|if
condition|(
name|type
operator|==
operator|(
name|N_UNDF
operator||
name|N_EXT
operator|)
operator|&&
name|nzp
operator|->
name|nz_value
condition|)
block|{
if|if
condition|(
operator|!
name|olddef
condition|)
block|{
if|if
condition|(
name|oldref
condition|)
name|undefined_global_sym_count
operator|--
expr_stmt|;
name|common_defined_global_count
operator|++
expr_stmt|;
name|sp
operator|->
name|common_size
operator|=
name|nzp
operator|->
name|nz_value
expr_stmt|;
name|sp
operator|->
name|defined
operator|=
name|N_UNDF
operator||
name|N_EXT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|com
operator|&&
name|sp
operator|->
name|common_size
operator|<
name|nzp
operator|->
name|nz_value
condition|)
block|{
name|sp
operator|->
name|common_size
operator|=
name|nzp
operator|->
name|nz_value
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|type
operator|!=
operator|(
name|N_UNDF
operator||
name|N_EXT
operator|)
operator|&&
operator|!
name|oldref
condition|)
block|{
comment|/* 			 * This is an ex common... 			 */
if|if
condition|(
name|com
condition|)
name|common_defined_global_count
operator|--
expr_stmt|;
name|sp
operator|->
name|common_size
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|defined
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 		 * Handle size information in shared objects. 		 */
if|if
condition|(
name|nzp
operator|->
name|nz_size
operator|>
name|sp
operator|->
name|size
condition|)
name|sp
operator|->
name|size
operator|=
name|nzp
operator|->
name|nz_size
expr_stmt|;
if|if
condition|(
operator|(
name|lsp
operator|->
name|flags
operator|&
name|LS_WARNING
operator|)
operator|&&
operator|(
name|sp
operator|->
name|flags
operator|&
name|GS_REFERENCED
operator|)
condition|)
comment|/* 			 * Prevent warning symbols from getting 			 * gratuitously referenced. 			 */
name|list_warning_symbols
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|lsp
operator|->
name|next
operator|=
name|sp
operator|->
name|refs
expr_stmt|;
name|sp
operator|->
name|refs
operator|=
name|lsp
expr_stmt|;
name|lsp
operator|->
name|symbol
operator|=
name|sp
expr_stmt|;
if|if
condition|(
name|lsp
operator|->
name|flags
operator|&
name|LS_WARNING
condition|)
block|{
comment|/* 		 * Prevent warning symbols from getting 		 * gratuitously referenced. 		 */
if|if
condition|(
name|sp
operator|->
name|flags
operator|&
name|GS_REFERENCED
condition|)
name|list_warning_symbols
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sp
operator|->
name|warning
condition|)
name|list_warning_symbols
operator|=
literal|1
expr_stmt|;
name|sp
operator|->
name|flags
operator||=
name|GS_REFERENCED
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|dynamic_symbol
operator|||
name|sp
operator|==
name|got_symbol
condition|)
block|{
if|if
condition|(
name|type
operator|!=
operator|(
name|N_UNDF
operator||
name|N_EXT
operator|)
operator|&&
operator|!
operator|(
name|entry
operator|->
name|flags
operator|&
name|E_JUST_SYMS
operator|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Linker reserved symbol %s defined as type %x "
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|olddef
operator|&&
name|N_ISWEAK
argument_list|(
operator|&
name|nzp
operator|->
name|nlist
argument_list|)
operator|&&
operator|!
operator|(
name|sp
operator|->
name|flags
operator|&
name|GS_WEAK
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"%s: not overridden by weak symbol from %s\n"
argument_list|,
name|demangle
argument_list|(
name|sp
operator|->
name|name
argument_list|)
argument_list|,
name|get_file_name
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
if|if
condition|(
name|type
operator|==
operator|(
name|N_SIZE
operator||
name|N_EXT
operator|)
condition|)
block|{
if|if
condition|(
name|relocatable_output
operator|&&
name|nzp
operator|->
name|nz_value
operator|!=
literal|0
operator|&&
name|sp
operator|->
name|size
operator|==
literal|0
condition|)
name|size_sym_count
operator|++
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|size
operator|<
name|nzp
operator|->
name|nz_value
condition|)
name|sp
operator|->
name|size
operator|=
name|nzp
operator|->
name|nz_value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|!=
operator|(
name|N_UNDF
operator||
name|N_EXT
operator|)
operator|||
name|nzp
operator|->
name|nz_value
condition|)
block|{
comment|/* 		 * Set `->defined' here, so commons and undefined globals 		 * can be counted correctly. 		 */
if|if
condition|(
operator|!
name|sp
operator|->
name|defined
operator|||
name|sp
operator|->
name|defined
operator|==
operator|(
name|N_UNDF
operator||
name|N_EXT
operator|)
condition|)
block|{
name|sp
operator|->
name|defined
operator|=
name|type
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sp
operator|->
name|flags
operator|&
name|GS_WEAK
operator|)
operator|&&
operator|!
name|N_ISWEAK
argument_list|(
operator|&
name|nzp
operator|->
name|nlist
argument_list|)
condition|)
block|{
comment|/* 			 * Upgrade an existing weak definition. 			 * We fake it by pretending the symbol is undefined; 			 * must undo any common fiddling, however. 			 */
if|if
condition|(
operator|!
name|oldref
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"internal error: enter_glob_ref: "
literal|"weak symbol not referenced"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|olddef
operator|&&
operator|!
name|com
condition|)
name|undefined_weak_sym_count
operator|--
expr_stmt|;
name|undefined_global_sym_count
operator|++
expr_stmt|;
name|sp
operator|->
name|defined
operator|=
name|type
expr_stmt|;
name|sp
operator|->
name|flags
operator|&=
operator|~
name|GS_WEAK
expr_stmt|;
name|olddef
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|com
condition|)
name|common_defined_global_count
operator|--
expr_stmt|;
name|com
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|common_size
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|oldref
operator|&&
operator|!
name|olddef
condition|)
block|{
comment|/* 			 * It used to be undefined and we're defining it. 			 */
name|undefined_global_sym_count
operator|--
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|flags
operator|&
name|GS_WEAK
condition|)
comment|/* Used to be a weak reference */
name|undefined_weak_sym_count
operator|--
expr_stmt|;
if|if
condition|(
name|undefined_global_sym_count
operator|<
literal|0
operator|||
name|undefined_weak_sym_count
operator|<
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"internal error: enter_glob_ref: "
literal|"undefined_global_sym_count = %d, "
literal|"undefined_weak_sym_count = %d"
argument_list|,
name|undefined_global_sym_count
argument_list|,
name|undefined_weak_sym_count
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|N_ISWEAK
argument_list|(
operator|&
name|nzp
operator|->
name|nlist
argument_list|)
condition|)
comment|/* The definition is weak */
name|sp
operator|->
name|flags
operator||=
name|GS_WEAK
expr_stmt|;
if|if
condition|(
operator|!
name|olddef
operator|&&
name|type
operator|==
operator|(
name|N_UNDF
operator||
name|N_EXT
operator|)
operator|&&
name|nzp
operator|->
name|nz_value
condition|)
block|{
comment|/* 			 * First definition and it's common. 			 */
name|common_defined_global_count
operator|++
expr_stmt|;
name|sp
operator|->
name|common_size
operator|=
name|nzp
operator|->
name|nz_value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|com
operator|&&
name|type
operator|!=
operator|(
name|N_UNDF
operator||
name|N_EXT
operator|)
condition|)
block|{
comment|/* 			 * It used to be common and we're defining 			 * it as something else. 			 */
name|common_defined_global_count
operator|--
expr_stmt|;
name|sp
operator|->
name|common_size
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|com
operator|&&
name|type
operator|==
operator|(
name|N_UNDF
operator||
name|N_EXT
operator|)
operator|&&
name|sp
operator|->
name|common_size
operator|<
name|nzp
operator|->
name|nz_value
condition|)
comment|/* 			 * It used to be common and this is a new common entry 			 * to which we need to pay attention. 			 */
name|sp
operator|->
name|common_size
operator|=
name|nzp
operator|->
name|nz_value
expr_stmt|;
if|if
condition|(
name|SET_ELEMENT_P
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
operator|!
name|olddef
operator|||
name|com
operator|)
condition|)
name|set_vector_count
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|oldref
operator|&&
operator|!
name|com
condition|)
block|{
comment|/* 		 * An unreferenced symbol can already be defined 		 * as common by shared objects. 		 */
name|undefined_global_sym_count
operator|++
expr_stmt|;
if|if
condition|(
name|N_ISWEAK
argument_list|(
operator|&
name|nzp
operator|->
name|nlist
argument_list|)
condition|)
block|{
comment|/* The reference is weak */
name|sp
operator|->
name|flags
operator||=
name|GS_WEAK
expr_stmt|;
name|undefined_weak_sym_count
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sp
operator|==
name|end_symbol
operator|&&
operator|(
name|entry
operator|->
name|flags
operator|&
name|E_JUST_SYMS
operator|)
operator|&&
operator|!
name|T_flag_specified
condition|)
name|text_start
operator|=
name|nzp
operator|->
name|nz_value
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|flags
operator|&
name|GS_TRACE
condition|)
block|{
specifier|register
name|char
modifier|*
name|reftype
decl_stmt|;
switch|switch
condition|(
name|type
operator|&
name|N_TYPE
condition|)
block|{
case|case
name|N_UNDF
case|:
name|reftype
operator|=
name|nzp
operator|->
name|nz_value
condition|?
literal|"defined as common"
else|:
literal|"referenced"
expr_stmt|;
break|break;
case|case
name|N_ABS
case|:
name|reftype
operator|=
literal|"defined as absolute"
expr_stmt|;
break|break;
case|case
name|N_TEXT
case|:
name|reftype
operator|=
literal|"defined in text section"
expr_stmt|;
break|break;
case|case
name|N_DATA
case|:
name|reftype
operator|=
literal|"defined in data section"
expr_stmt|;
break|break;
case|case
name|N_BSS
case|:
name|reftype
operator|=
literal|"defined in BSS section"
expr_stmt|;
break|break;
case|case
name|N_INDR
case|:
name|reftype
operator|=
literal|"alias"
expr_stmt|;
break|break;
case|case
name|N_SIZE
case|:
name|reftype
operator|=
literal|"size spec"
expr_stmt|;
break|break;
default|default:
name|reftype
operator|=
literal|"I don't know this type"
expr_stmt|;
break|break;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"symbol %s %s%s in "
argument_list|,
name|demangle
argument_list|(
name|sp
operator|->
name|name
argument_list|)
argument_list|,
operator|(
name|N_ISWEAK
argument_list|(
operator|&
name|nzp
operator|->
name|nlist
argument_list|)
operator|)
condition|?
literal|"weakly "
else|:
literal|""
argument_list|,
name|reftype
argument_list|)
expr_stmt|;
name|print_file_name
argument_list|(
name|entry
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * This returns 0 if the given file entry's symbol table does *not* contain  * the nlist point entry, and it returns the files entry pointer (cast to  * unsigned long) if it does.  */
end_comment

begin_function
name|unsigned
name|long
name|contains_symbol
parameter_list|(
name|entry
parameter_list|,
name|np
parameter_list|)
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
specifier|register
name|struct
name|nlist
modifier|*
name|np
decl_stmt|;
block|{
if|if
condition|(
name|np
operator|>=
operator|&
name|entry
operator|->
name|symbols
operator|->
name|nzlist
operator|.
name|nlist
operator|&&
name|np
operator|<
operator|&
operator|(
name|entry
operator|->
name|symbols
operator|+
name|entry
operator|->
name|nsymbols
operator|)
operator|->
name|nzlist
operator|.
name|nlist
condition|)
return|return
operator|(
name|unsigned
name|long
operator|)
name|entry
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Having entered all the global symbols and found the sizes of sections of  * all files to be linked, make all appropriate deductions from this data.  *  * We propagate global symbol values from definitions to references. We compute  * the layout of the output file and where each input file's contents fit  * into it.  *  * This is now done in several stages.  *  * 1) All global symbols are examined for definitions in relocatable (.o)  *    files. The symbols' type is set according to the definition found,  *    but its value can not yet be determined. In stead, we keep a pointer  *    to the file entry's localsymbol that bequeathed the global symbol with  *    its definition. Also, multiple (incompatible) definitions are checked  *    for in this pass. If no definition comes forward, the set of local  *    symbols originating from shared objects is searched for a definition.  *  * 2) Then the relocation information of each relocatable file is examined  *    for possible contributions to the RRS section.  *  * 3) When this is done, the sizes and start addresses are set of all segments  *    that will appear in the output file (including the RRS segment).  *  * 4) Finally, all symbols are relocated according according to the start  *    of the entry they are part of. Then global symbols are assigned their  *    final values. Also, space for commons and imported data are allocated  *    during this pass, if the link mode in effect so demands.  *  */
end_comment

begin_function
specifier|static
name|void
name|digest_symbols
parameter_list|()
block|{
if|if
condition|(
name|trace_files
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Digesting symbol information:\n\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|relocatable_output
condition|)
block|{
comment|/* 		 * The set sector size is the number of set elements + a word 		 * for each symbol for the length word at the beginning of 		 * the vector, plus a word for each symbol for a zero at the 		 * end of the vector (for incremental linking). 		 */
name|set_sect_size
operator|=
operator|(
name|set_symbol_count
operator|+
literal|2
operator|*
name|set_vector_count
operator|)
operator|*
expr|sizeof
operator|(
name|unsigned
name|long
operator|)
expr_stmt|;
name|set_vectors
operator|=
operator|(
name|long
operator|*
operator|)
name|xmalloc
argument_list|(
name|set_sect_size
argument_list|)
expr_stmt|;
name|setv_fill_count
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Pass 1: check and define symbols */
name|defined_global_sym_count
operator|=
literal|0
expr_stmt|;
name|digest_pass1
argument_list|()
expr_stmt|;
name|each_full_file
argument_list|(
name|consider_relocation
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* Text */
name|each_full_file
argument_list|(
name|consider_relocation
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|1
argument_list|)
expr_stmt|;
comment|/* Data */
name|each_file
argument_list|(
name|consider_local_symbols
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Compute total size of sections. 	 * RRS data is the first output data section, RRS text is the last 	 * text section. Thus, DATA_START is calculated from RRS_DATA_START 	 * and RRS_DATA_SIZE, while RRS_TEXT_START is derived from TEXT_START 	 * and TEXT_SIZE. 	 */
name|consider_rrs_section_lengths
argument_list|()
expr_stmt|;
name|each_full_file
argument_list|(
name|consider_file_section_lengths
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rrs_text_start
operator|=
name|text_start
operator|+
name|text_size
expr_stmt|;
name|text_size
operator|+=
name|rrs_text_size
expr_stmt|;
name|data_size
operator|+=
name|rrs_data_size
expr_stmt|;
comment|/* 	 * If necessary, pad text section to full page in the file. Include 	 * the padding in the text segment size. 	 */
if|if
condition|(
name|page_align_segments
operator|||
name|page_align_data
condition|)
block|{
name|int
name|text_end
init|=
name|text_size
operator|+
name|N_TXTOFF
argument_list|(
name|outheader
argument_list|)
decl_stmt|;
name|text_pad
operator|=
name|PALIGN
argument_list|(
name|text_end
argument_list|,
name|page_size
argument_list|)
operator|-
name|text_end
expr_stmt|;
name|text_size
operator|+=
name|text_pad
expr_stmt|;
block|}
name|outheader
operator|.
name|a_text
operator|=
name|text_size
expr_stmt|;
comment|/* 	 * Make the data segment address start in memory on a suitable 	 * boundary. 	 */
if|if
condition|(
operator|!
name|Tdata_flag_specified
condition|)
name|rrs_data_start
operator|=
name|text_start
operator|+
name|DATA_START
argument_list|(
name|outheader
argument_list|)
operator|-
name|TEXT_START
argument_list|(
name|outheader
argument_list|)
expr_stmt|;
name|data_start
operator|=
name|rrs_data_start
operator|+
name|rrs_data_size
expr_stmt|;
if|if
condition|(
operator|!
name|relocatable_output
condition|)
block|{
name|set_sect_start
operator|=
name|rrs_data_start
operator|+
name|data_size
expr_stmt|;
name|data_size
operator|+=
name|MALIGN
argument_list|(
name|set_sect_size
argument_list|)
expr_stmt|;
block|}
name|bss_start
operator|=
name|rrs_data_start
operator|+
name|data_size
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"textstart = %#x, textsize = %#x, rrs_text_start = %#x, rrs_text_size %#x\n"
argument_list|,
name|text_start
argument_list|,
name|text_size
argument_list|,
name|rrs_text_start
argument_list|,
name|rrs_text_size
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"datastart = %#x, datasize = %#x, rrs_data_start %#x, rrs_data_size %#x\n"
argument_list|,
name|data_start
argument_list|,
name|data_size
argument_list|,
name|rrs_data_start
argument_list|,
name|rrs_data_size
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"bssstart = %#x, bsssize = %#x\n"
argument_list|,
name|bss_start
argument_list|,
name|bss_size
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"set_sect_start = %#x, set_sect_size = %#x\n"
argument_list|,
name|set_sect_start
argument_list|,
name|set_sect_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Compute start addresses of each file's sections and symbols.  */
name|each_full_file
argument_list|(
name|relocate_file_addresses
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|relocate_rrs_addresses
argument_list|()
expr_stmt|;
comment|/* Pass 2: assign values to symbols */
name|digest_pass2
argument_list|()
expr_stmt|;
if|if
condition|(
name|end_symbol
condition|)
block|{
comment|/* These are null if -r.  */
name|etext_symbol
operator|->
name|value
operator|=
name|text_start
operator|+
name|text_size
operator|-
name|text_pad
expr_stmt|;
name|edata_symbol
operator|->
name|value
operator|=
name|rrs_data_start
operator|+
name|data_size
expr_stmt|;
name|end_symbol
operator|->
name|value
operator|=
name|rrs_data_start
operator|+
name|data_size
operator|+
name|bss_size
expr_stmt|;
block|}
comment|/* 	 * Figure the data_pad now, so that it overlaps with the bss 	 * addresses. 	 */
if|if
condition|(
name|specified_data_size
operator|&&
name|specified_data_size
operator|>
name|data_size
condition|)
name|data_pad
operator|=
name|specified_data_size
operator|-
name|data_size
expr_stmt|;
if|if
condition|(
name|page_align_segments
condition|)
name|data_pad
operator|=
name|PALIGN
argument_list|(
name|data_pad
operator|+
name|data_size
argument_list|,
name|page_size
argument_list|)
operator|-
name|data_size
expr_stmt|;
name|bss_size
operator|-=
name|data_pad
expr_stmt|;
if|if
condition|(
name|bss_size
operator|<
literal|0
condition|)
name|bss_size
operator|=
literal|0
expr_stmt|;
name|data_size
operator|+=
name|data_pad
expr_stmt|;
comment|/* 	 * Calculate total number of symbols that will go into 	 * the output symbol table (barring DISCARD_* settings). 	 */
name|global_sym_count
operator|=
name|defined_global_sym_count
operator|+
name|undefined_global_sym_count
expr_stmt|;
if|if
condition|(
name|dynamic_symbol
operator|->
name|flags
operator|&
name|GS_REFERENCED
condition|)
name|global_sym_count
operator|++
expr_stmt|;
if|if
condition|(
name|got_symbol
operator|->
name|flags
operator|&
name|GS_REFERENCED
condition|)
name|global_sym_count
operator|++
expr_stmt|;
if|if
condition|(
name|relocatable_output
operator|||
name|building_shared_object
condition|)
block|{
comment|/* For each alias we write out two struct nlists */
name|global_sym_count
operator|+=
name|global_alias_count
expr_stmt|;
comment|/* Propagate warning symbols; costs two extra struct nlists */
name|global_sym_count
operator|+=
literal|2
operator|*
name|warn_sym_count
expr_stmt|;
block|}
if|if
condition|(
name|relocatable_output
condition|)
comment|/* We write out the original N_SIZE symbols */
name|global_sym_count
operator|+=
name|size_sym_count
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"global symbols %d "
literal|"(defined %d, undefined %d, weak %d, aliases %d, warnings 2 * %d, "
literal|"size symbols %d)\ncommons %d, locals: %d, debug symbols: %d, set_symbols %d\n"
argument_list|,
name|global_sym_count
argument_list|,
name|defined_global_sym_count
argument_list|,
name|undefined_global_sym_count
argument_list|,
name|undefined_weak_sym_count
argument_list|,
name|global_alias_count
argument_list|,
name|warn_sym_count
argument_list|,
name|size_sym_count
argument_list|,
name|common_defined_global_count
argument_list|,
name|local_sym_count
argument_list|,
name|debugger_sym_count
argument_list|,
name|set_symbol_count
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Determine the definition of each global symbol.  */
end_comment

begin_function
specifier|static
name|void
name|digest_pass1
parameter_list|()
block|{
comment|/* 	 * For each symbol, verify that it is defined globally at most 	 * once within relocatable files (except when building a shared lib). 	 * and set the `defined' field if there is a definition. 	 * 	 * Then check the shared object symbol chain for any remaining 	 * undefined symbols. Set the `so_defined' field for any 	 * definition find this way. 	 */
name|FOR_EACH_SYMBOL
argument_list|(
argument|i
argument_list|,
argument|sp
argument_list|)
block|{
name|symbol
modifier|*
name|spsave
decl_stmt|;
name|struct
name|localsymbol
modifier|*
name|lsp
decl_stmt|;
name|int
name|defs
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|sp
operator|->
name|flags
operator|&
name|GS_REFERENCED
operator|)
condition|)
block|{
if|#
directive|if
literal|0
comment|/* Check for undefined symbols in shared objects */
block|int type; 			for (lsp = sp->sorefs; lsp; lsp = lsp->next) { 				type = lsp->nzlist.nlist.n_type; 				if ((type& N_EXT)&& type != (N_UNDF | N_EXT)) 					break; 			} 			if ((type& N_EXT)&& type == (N_UNDF | N_EXT)) 				undefined_shobj_sym_count++;
endif|#
directive|endif
comment|/* Superfluous symbol from shared object */
continue|continue;
block|}
if|if
condition|(
name|sp
operator|->
name|so_defined
condition|)
comment|/* Already examined; must have been an alias */
continue|continue;
if|if
condition|(
name|sp
operator|==
name|got_symbol
operator|||
name|sp
operator|==
name|dynamic_symbol
condition|)
continue|continue;
for|for
control|(
name|lsp
operator|=
name|sp
operator|->
name|refs
init|;
name|lsp
condition|;
name|lsp
operator|=
name|lsp
operator|->
name|next
control|)
block|{
specifier|register
name|struct
name|nlist
modifier|*
name|p
init|=
operator|&
name|lsp
operator|->
name|nzlist
operator|.
name|nlist
decl_stmt|;
specifier|register
name|int
name|type
init|=
name|p
operator|->
name|n_type
decl_stmt|;
if|if
condition|(
name|SET_ELEMENT_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|relocatable_output
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"internal error: global ref to set el %s with -r"
argument_list|,
name|demangle
argument_list|(
name|sp
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|defs
operator|++
condition|)
block|{
name|sp
operator|->
name|defined
operator|=
name|N_SETV
operator||
name|N_EXT
expr_stmt|;
name|sp
operator|->
name|value
operator|=
name|setv_fill_count
operator|++
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|sp
operator|->
name|defined
operator|&
name|N_TYPE
operator|)
operator|!=
name|N_SETV
condition|)
block|{
name|sp
operator|->
name|mult_defs
operator|=
literal|1
expr_stmt|;
name|multiple_def_count
operator|++
expr_stmt|;
block|}
comment|/* Keep count and remember symbol */
name|sp
operator|->
name|setv_count
operator|++
expr_stmt|;
name|set_vectors
index|[
name|setv_fill_count
operator|++
index|]
operator|=
operator|(
name|long
operator|)
name|p
expr_stmt|;
if|if
condition|(
name|building_shared_object
condition|)
block|{
name|struct
name|relocation_info
name|reloc
decl_stmt|;
comment|/* 					 * Make sure to relocate the contents 					 * of this set vector. 					 */
name|bzero
argument_list|(
operator|&
name|reloc
argument_list|,
sizeof|sizeof
argument_list|(
name|reloc
argument_list|)
argument_list|)
expr_stmt|;
name|RELOC_INIT_SEGMENT_RELOC
argument_list|(
operator|&
name|reloc
argument_list|)
expr_stmt|;
name|RELOC_ADDRESS
argument_list|(
operator|&
name|reloc
argument_list|)
operator|=
name|setv_fill_count
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
name|alloc_rrs_segment_reloc
argument_list|(
name|NULL
argument_list|,
operator|&
name|reloc
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|type
operator|&
name|N_EXT
operator|)
operator|&&
name|type
operator|!=
operator|(
name|N_UNDF
operator||
name|N_EXT
operator|)
operator|&&
operator|(
name|type
operator|&
name|N_TYPE
operator|)
operator|!=
name|N_FN
operator|&&
operator|(
name|type
operator|&
name|N_TYPE
operator|)
operator|!=
name|N_SIZE
condition|)
block|{
comment|/* non-common definition */
if|if
condition|(
operator|!
name|N_ISWEAK
argument_list|(
name|p
argument_list|)
condition|)
operator|++
name|defs
expr_stmt|;
if|if
condition|(
name|defs
operator|>
literal|1
condition|)
block|{
name|sp
operator|->
name|mult_defs
operator|=
literal|1
expr_stmt|;
name|multiple_def_count
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|N_ISWEAK
argument_list|(
name|p
argument_list|)
operator|||
operator|(
operator|!
name|sp
operator|->
name|def_lsp
operator|&&
operator|!
name|sp
operator|->
name|common_size
operator|)
condition|)
block|{
name|sp
operator|->
name|def_lsp
operator|=
name|lsp
expr_stmt|;
name|lsp
operator|->
name|entry
operator|->
name|flags
operator||=
name|E_SYMBOLS_USED
expr_stmt|;
name|sp
operator|->
name|defined
operator|=
name|type
expr_stmt|;
name|sp
operator|->
name|aux
operator|=
name|N_AUX
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 		 * If this symbol has acquired final definition, we're done. 		 * Commons must be allowed to bind to shared object data 		 * definitions. 		 */
if|if
condition|(
name|sp
operator|->
name|defined
operator|&&
operator|(
name|sp
operator|->
name|common_size
operator|==
literal|0
operator|||
name|relocatable_output
operator|||
name|building_shared_object
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|sp
operator|->
name|defined
operator|&
name|N_TYPE
operator|)
operator|==
name|N_SETV
condition|)
comment|/* Allocate zero entry in set vector */
name|setv_fill_count
operator|++
expr_stmt|;
comment|/* 			 * At this stage, we do not know whether an alias 			 * is going to be defined for real here, or whether 			 * it refers to a shared object symbol. The decision 			 * is deferred until digest_pass2(). 			 */
if|if
condition|(
operator|!
name|sp
operator|->
name|alias
condition|)
name|defined_global_sym_count
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|relocatable_output
condition|)
comment|/* We're done */
continue|continue;
comment|/* 		 * Still undefined, search the shared object symbols for a 		 * definition. This symbol must go into the RRS. 		 */
if|if
condition|(
name|building_shared_object
condition|)
block|{
comment|/* Just punt for now */
name|undefined_global_sym_count
operator|--
expr_stmt|;
if|if
condition|(
name|undefined_global_sym_count
operator|<
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"internal error: digest_pass1,1: %s: undefined_global_sym_count = %d"
argument_list|,
name|demangle
argument_list|(
name|sp
operator|->
name|name
argument_list|)
argument_list|,
name|undefined_global_sym_count
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|spsave
operator|=
name|sp
expr_stmt|;
comment|/*XXX*/
name|again
label|:
for|for
control|(
name|lsp
operator|=
name|sp
operator|->
name|sorefs
init|;
name|lsp
condition|;
name|lsp
operator|=
name|lsp
operator|->
name|next
control|)
block|{
specifier|register
name|struct
name|nlist
modifier|*
name|p
init|=
operator|&
name|lsp
operator|->
name|nzlist
operator|.
name|nlist
decl_stmt|;
specifier|register
name|int
name|type
init|=
name|p
operator|->
name|n_type
decl_stmt|;
if|if
condition|(
operator|(
name|type
operator|&
name|N_EXT
operator|)
operator|&&
name|type
operator|!=
operator|(
name|N_UNDF
operator||
name|N_EXT
operator|)
operator|&&
operator|(
name|type
operator|&
name|N_TYPE
operator|)
operator|!=
name|N_FN
condition|)
block|{
comment|/* non-common definition */
if|if
condition|(
name|sp
operator|->
name|common_size
condition|)
block|{
comment|/* 					 * This common has an so defn; switch 					 * to it iff defn is: data, first-class 					 * and not weak. 					 */
if|if
condition|(
name|N_AUX
argument_list|(
name|p
argument_list|)
operator|!=
name|AUX_OBJECT
operator|||
name|N_ISWEAK
argument_list|(
name|p
argument_list|)
operator|||
operator|(
name|lsp
operator|->
name|entry
operator|->
name|flags
operator|&
name|E_SECONDCLASS
operator|)
condition|)
continue|continue;
comment|/* 					 * Change common to so ref. First, 					 * downgrade common to undefined. 					 */
name|sp
operator|->
name|common_size
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|defined
operator|=
literal|0
expr_stmt|;
name|common_defined_global_count
operator|--
expr_stmt|;
name|undefined_global_sym_count
operator|++
expr_stmt|;
block|}
name|sp
operator|->
name|def_lsp
operator|=
name|lsp
expr_stmt|;
name|sp
operator|->
name|so_defined
operator|=
name|type
expr_stmt|;
name|sp
operator|->
name|aux
operator|=
name|N_AUX
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|lsp
operator|->
name|entry
operator|->
name|flags
operator|&
name|E_SECONDCLASS
condition|)
comment|/* Keep looking for something better */
continue|continue;
if|if
condition|(
name|N_ISWEAK
argument_list|(
name|p
argument_list|)
condition|)
comment|/* Keep looking for something better */
continue|continue;
break|break;
block|}
block|}
if|if
condition|(
name|sp
operator|->
name|def_lsp
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"pass1: SO definition for %s, type %x in %s at %#x\n"
argument_list|,
name|demangle
argument_list|(
name|sp
operator|->
name|name
argument_list|)
argument_list|,
name|sp
operator|->
name|so_defined
argument_list|,
name|get_file_name
argument_list|(
name|sp
operator|->
name|def_lsp
operator|->
name|entry
argument_list|)
argument_list|,
name|sp
operator|->
name|def_lsp
operator|->
name|nzlist
operator|.
name|nz_value
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sp
operator|->
name|def_lsp
operator|->
name|entry
operator|->
name|flags
operator||=
name|E_SYMBOLS_USED
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|flags
operator|&
name|GS_REFERENCED
condition|)
block|{
name|undefined_global_sym_count
operator|--
expr_stmt|;
block|}
else|else
name|sp
operator|->
name|flags
operator||=
name|GS_REFERENCED
expr_stmt|;
if|if
condition|(
name|undefined_global_sym_count
operator|<
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"internal error: digest_pass1,2: "
literal|"%s: undefined_global_sym_count = %d"
argument_list|,
name|demangle
argument_list|(
name|sp
operator|->
name|name
argument_list|)
argument_list|,
name|undefined_global_sym_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|alias
operator|&&
operator|!
operator|(
name|sp
operator|->
name|alias
operator|->
name|flags
operator|&
name|GS_REFERENCED
operator|)
condition|)
block|{
name|sp
operator|=
name|sp
operator|->
name|alias
expr_stmt|;
goto|goto
name|again
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|sp
operator|->
name|defined
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|common_size
operator|==
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"internal error: digest_pass1,3: "
literal|"%s: not a common: %x"
argument_list|,
name|demangle
argument_list|(
name|sp
operator|->
name|name
argument_list|)
argument_list|,
name|sp
operator|->
name|defined
argument_list|)
expr_stmt|;
comment|/* 			 * Common not bound to shared object data; treat 			 * it now like other defined symbols were above. 			 */
if|if
condition|(
operator|!
name|sp
operator|->
name|alias
condition|)
name|defined_global_sym_count
operator|++
expr_stmt|;
block|}
name|sp
operator|=
name|spsave
expr_stmt|;
comment|/*XXX*/
block|}
name|END_EACH_SYMBOL
expr_stmt|;
if|if
condition|(
name|setv_fill_count
operator|!=
name|set_sect_size
operator|/
sizeof|sizeof
argument_list|(
name|long
argument_list|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"internal error: allocated set symbol space (%d) "
literal|"doesn't match actual (%d)"
argument_list|,
name|set_sect_size
operator|/
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|,
name|setv_fill_count
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Scan relocation info in ENTRY for contributions to the RRS section  * of the output file.  */
end_comment

begin_function
specifier|static
name|void
name|consider_relocation
parameter_list|(
name|entry
parameter_list|,
name|dataseg
parameter_list|)
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
name|int
name|dataseg
decl_stmt|;
block|{
name|struct
name|relocation_info
modifier|*
name|reloc
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|struct
name|localsymbol
modifier|*
name|lsp
decl_stmt|;
name|symbol
modifier|*
name|sp
decl_stmt|;
if|if
condition|(
name|dataseg
operator|==
literal|0
condition|)
block|{
comment|/* Text relocations */
name|reloc
operator|=
name|entry
operator|->
name|textrel
expr_stmt|;
name|end
operator|=
name|entry
operator|->
name|textrel
operator|+
name|entry
operator|->
name|ntextrel
expr_stmt|;
block|}
else|else
block|{
comment|/* Data relocations */
name|reloc
operator|=
name|entry
operator|->
name|datarel
expr_stmt|;
name|end
operator|=
name|entry
operator|->
name|datarel
operator|+
name|entry
operator|->
name|ndatarel
expr_stmt|;
block|}
for|for
control|(
init|;
name|reloc
operator|<
name|end
condition|;
name|reloc
operator|++
control|)
block|{
if|if
condition|(
name|relocatable_output
condition|)
block|{
name|lsp
operator|=
operator|&
name|entry
operator|->
name|symbols
index|[
name|reloc
operator|->
name|r_symbolnum
index|]
expr_stmt|;
if|if
condition|(
name|RELOC_BASEREL_P
argument_list|(
name|reloc
argument_list|)
condition|)
block|{
name|pic_code_seen
operator|=
literal|1
expr_stmt|;
comment|/* Compatibility */
if|if
condition|(
operator|!
name|RELOC_EXTERN_P
argument_list|(
name|reloc
argument_list|)
condition|)
name|lsp
operator|->
name|flags
operator||=
name|LS_RENAME
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* 		 * First, do the PIC specific relocs. 		 * r_relative and r_copy should not occur at this point 		 * (we do output them). The others break down to these 		 * combinations: 		 * 		 * jmptab:	extern:		needs jmp slot 		 *		!extern:	"intersegment" jump/call, 		 *				should get resolved in output 		 * 		 * baserel:	extern:		need GOT entry 		 *		!extern:	may need GOT entry, 		 *				machine dependent 		 * 		 * baserel's always refer to symbol through `r_symbolnum' 		 * whether extern or not. Internal baserels refer to statics 		 * that must be accessed either *through* the GOT table like 		 * global data, or by means of an offset from the GOT table. 		 * The macro RELOC_STATICS_THROUGH_GOT_P() determines which 		 * applies, since this is a machine (compiler?) dependent 		 * addressing mode. 		 */
if|if
condition|(
name|RELOC_JMPTAB_P
argument_list|(
name|reloc
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|RELOC_EXTERN_P
argument_list|(
name|reloc
argument_list|)
condition|)
continue|continue;
name|lsp
operator|=
operator|&
name|entry
operator|->
name|symbols
index|[
name|reloc
operator|->
name|r_symbolnum
index|]
expr_stmt|;
name|sp
operator|=
name|lsp
operator|->
name|symbol
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|alias
condition|)
name|sp
operator|=
name|sp
operator|->
name|alias
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|flags
operator|&
name|GS_TRACE
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"symbol %s has jmpslot in %s\n"
argument_list|,
name|demangle
argument_list|(
name|sp
operator|->
name|name
argument_list|)
argument_list|,
name|get_file_name
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|alloc_rrs_jmpslot
argument_list|(
name|entry
argument_list|,
name|sp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|RELOC_BASEREL_P
argument_list|(
name|reloc
argument_list|)
condition|)
block|{
name|lsp
operator|=
operator|&
name|entry
operator|->
name|symbols
index|[
name|reloc
operator|->
name|r_symbolnum
index|]
expr_stmt|;
name|alloc_rrs_gotslot
argument_list|(
name|entry
argument_list|,
name|reloc
argument_list|,
name|lsp
argument_list|)
expr_stmt|;
if|if
condition|(
name|pic_type
operator|!=
name|PIC_TYPE_NONE
operator|&&
name|RELOC_PIC_TYPE
argument_list|(
name|reloc
argument_list|)
operator|!=
name|pic_type
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: illegal reloc type mix"
argument_list|,
name|get_file_name
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|pic_type
operator|=
name|RELOC_PIC_TYPE
argument_list|(
name|reloc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|RELOC_EXTERN_P
argument_list|(
name|reloc
argument_list|)
condition|)
block|{
comment|/* 			 * Non-PIC relocations. 			 * If the definition comes from a shared object 			 * we need a relocation entry in RRS. 			 * 			 * If the .so definition is N_TEXT a jmpslot is 			 * allocated. 			 * 			 * If it is N_DATA we allocate an address in BSS (?) 			 * and arrange for the data to be copied at run-time. 			 * The symbol is temporarily marked with N_SIZE in 			 * the `defined' field, so we know what to do in 			 * pass2() and during actual relocation. We convert 			 * the type back to something real again when writing 			 * out the symbols. 			 * 			 */
name|lsp
operator|=
operator|&
name|entry
operator|->
name|symbols
index|[
name|reloc
operator|->
name|r_symbolnum
index|]
expr_stmt|;
name|sp
operator|=
name|lsp
operator|->
name|symbol
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: bogus relocation record"
argument_list|,
name|get_file_name
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|alias
condition|)
name|sp
operator|=
name|sp
operator|->
name|alias
expr_stmt|;
comment|/* 			 * Skip refs to _GLOBAL_OFFSET_TABLE_ and __DYNAMIC 			 */
if|if
condition|(
name|sp
operator|==
name|got_symbol
condition|)
block|{
if|if
condition|(
operator|!
name|CHECK_GOT_RELOC
argument_list|(
name|reloc
argument_list|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: Unexpected relocation type for GOT symbol"
argument_list|,
name|get_file_name
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 			 * This symbol gives rise to a RRS entry 			 */
if|if
condition|(
name|building_shared_object
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|flags
operator|&
name|GS_TRACE
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"symbol %s RRS entry in %s\n"
argument_list|,
name|demangle
argument_list|(
name|sp
operator|->
name|name
argument_list|)
argument_list|,
name|get_file_name
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|alloc_rrs_reloc
argument_list|(
name|entry
argument_list|,
name|sp
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|force_alias_definition
operator|&&
name|sp
operator|->
name|so_defined
operator|&&
name|sp
operator|->
name|aux
operator|==
name|AUX_FUNC
condition|)
block|{
comment|/* Call to shared library procedure */
name|alloc_rrs_jmpslot
argument_list|(
name|entry
argument_list|,
name|sp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sp
operator|->
name|size
operator|&&
name|sp
operator|->
name|so_defined
operator|&&
name|sp
operator|->
name|aux
operator|==
name|AUX_OBJECT
condition|)
block|{
comment|/* Reference to shared library data */
name|alloc_rrs_cpy_reloc
argument_list|(
name|entry
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|->
name|defined
operator|=
name|N_SIZE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|sp
operator|->
name|defined
operator|&&
name|sp
operator|->
name|common_size
operator|==
literal|0
operator|&&
name|sp
operator|->
name|so_defined
condition|)
name|alloc_rrs_reloc
argument_list|(
name|entry
argument_list|,
name|sp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Segment relocation. 			 * Prepare an RRS relocation as these are load 			 * address dependent. 			 */
if|if
condition|(
name|building_shared_object
operator|&&
operator|!
name|RELOC_PCREL_P
argument_list|(
name|reloc
argument_list|)
condition|)
block|{
name|alloc_rrs_segment_reloc
argument_list|(
name|entry
argument_list|,
name|reloc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Determine the disposition of each local symbol.  */
end_comment

begin_function
specifier|static
name|void
name|consider_local_symbols
parameter_list|(
name|entry
parameter_list|)
specifier|register
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
block|{
specifier|register
name|struct
name|localsymbol
modifier|*
name|lsp
decl_stmt|,
modifier|*
name|lspend
decl_stmt|;
if|if
condition|(
name|entry
operator|->
name|flags
operator|&
name|E_DYNAMIC
condition|)
return|return;
name|lspend
operator|=
name|entry
operator|->
name|symbols
operator|+
name|entry
operator|->
name|nsymbols
expr_stmt|;
comment|/* 	 * For each symbol determine whether it should go 	 * in the output symbol table. 	 */
for|for
control|(
name|lsp
operator|=
name|entry
operator|->
name|symbols
init|;
name|lsp
operator|<
name|lspend
condition|;
name|lsp
operator|++
control|)
block|{
specifier|register
name|struct
name|nlist
modifier|*
name|p
init|=
operator|&
name|lsp
operator|->
name|nzlist
operator|.
name|nlist
decl_stmt|;
specifier|register
name|int
name|type
init|=
name|p
operator|->
name|n_type
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|N_WARNING
condition|)
continue|continue;
if|if
condition|(
name|SET_ELEMENT_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* 			 * This occurs even if global. These types of 			 * symbols are never written globally, though 			 * they are stored globally. 			 */
if|if
condition|(
name|relocatable_output
condition|)
name|lsp
operator|->
name|flags
operator||=
name|LS_WRITE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|type
operator|&
operator|(
name|N_STAB
operator||
name|N_EXT
operator|)
operator|)
condition|)
block|{
comment|/* 			 * Ordinary local symbol 			 */
if|if
condition|(
operator|(
name|lsp
operator|->
name|flags
operator|&
name|LS_RENAME
operator|)
operator|||
operator|(
name|discard_locals
operator|!=
name|DISCARD_ALL
operator|&&
operator|!
operator|(
name|discard_locals
operator|==
name|DISCARD_L
operator|&&
operator|(
name|lsp
operator|->
name|flags
operator|&
name|LS_L_SYMBOL
operator|)
operator|)
operator|)
condition|)
block|{
name|lsp
operator|->
name|flags
operator||=
name|LS_WRITE
expr_stmt|;
name|local_sym_count
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|type
operator|&
name|N_EXT
operator|)
condition|)
block|{
comment|/* 			 * Debugger symbol 			 */
if|if
condition|(
name|strip_symbols
operator|==
name|STRIP_NONE
condition|)
block|{
name|lsp
operator|->
name|flags
operator||=
name|LS_WRITE
expr_stmt|;
name|debugger_sym_count
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Count one for the local symbol that we generate, 	 * whose name is the file's name (usually) and whose address 	 * is the start of the file's text. 	 */
if|if
condition|(
name|discard_locals
operator|!=
name|DISCARD_ALL
condition|)
name|local_sym_count
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Accumulate the section sizes of input file ENTRY into the section sizes of  * the output file.  */
end_comment

begin_function
specifier|static
name|void
name|consider_file_section_lengths
parameter_list|(
name|entry
parameter_list|)
specifier|register
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
block|{
name|entry
operator|->
name|text_start_address
operator|=
name|text_size
expr_stmt|;
comment|/* If there were any vectors, we need to chop them off */
name|text_size
operator|+=
name|entry
operator|->
name|header
operator|.
name|a_text
expr_stmt|;
name|entry
operator|->
name|data_start_address
operator|=
name|data_size
expr_stmt|;
name|data_size
operator|+=
name|entry
operator|->
name|header
operator|.
name|a_data
expr_stmt|;
name|entry
operator|->
name|bss_start_address
operator|=
name|bss_size
expr_stmt|;
name|bss_size
operator|+=
name|MALIGN
argument_list|(
name|entry
operator|->
name|header
operator|.
name|a_bss
argument_list|)
expr_stmt|;
name|text_reloc_size
operator|+=
name|entry
operator|->
name|header
operator|.
name|a_trsize
expr_stmt|;
name|data_reloc_size
operator|+=
name|entry
operator|->
name|header
operator|.
name|a_drsize
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Determine where the sections of ENTRY go into the output file,  * whose total section sizes are already known.  * Also relocate the addresses of the file's local and debugger symbols.  */
end_comment

begin_function
specifier|static
name|void
name|relocate_file_addresses
parameter_list|(
name|entry
parameter_list|)
specifier|register
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
block|{
specifier|register
name|struct
name|localsymbol
modifier|*
name|lsp
decl_stmt|,
modifier|*
name|lspend
decl_stmt|;
name|entry
operator|->
name|text_start_address
operator|+=
name|text_start
expr_stmt|;
comment|/* 	 * Note that `data_start' and `data_size' have not yet been 	 * adjusted for `data_pad'.  If they had been, we would get the wrong 	 * results here. 	 */
name|entry
operator|->
name|data_start_address
operator|+=
name|data_start
expr_stmt|;
name|entry
operator|->
name|bss_start_address
operator|+=
name|bss_start
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"%s: datastart: %#x, bss %#x\n"
argument_list|,
name|get_file_name
argument_list|(
name|entry
argument_list|)
argument_list|,
name|entry
operator|->
name|data_start_address
argument_list|,
name|entry
operator|->
name|bss_start_address
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|lspend
operator|=
name|entry
operator|->
name|symbols
operator|+
name|entry
operator|->
name|nsymbols
expr_stmt|;
for|for
control|(
name|lsp
operator|=
name|entry
operator|->
name|symbols
init|;
name|lsp
operator|<
name|lspend
condition|;
name|lsp
operator|++
control|)
block|{
specifier|register
name|struct
name|nlist
modifier|*
name|p
init|=
operator|&
name|lsp
operator|->
name|nzlist
operator|.
name|nlist
decl_stmt|;
specifier|register
name|int
name|type
init|=
name|p
operator|->
name|n_type
decl_stmt|;
comment|/* 		 * If this belongs to a section, update it 		 * by the section's start address 		 */
switch|switch
condition|(
name|type
operator|&
name|N_TYPE
condition|)
block|{
case|case
name|N_TEXT
case|:
case|case
name|N_SETT
case|:
name|p
operator|->
name|n_value
operator|+=
name|entry
operator|->
name|text_start_address
expr_stmt|;
break|break;
case|case
name|N_DATA
case|:
case|case
name|N_SETD
case|:
case|case
name|N_SETV
case|:
comment|/* 			 * A symbol whose value is in the data section is 			 * present in the input file as if the data section 			 * started at an address equal to the length of the 			 * file's text. 			 */
name|p
operator|->
name|n_value
operator|+=
name|entry
operator|->
name|data_start_address
operator|-
name|entry
operator|->
name|header
operator|.
name|a_text
expr_stmt|;
break|break;
case|case
name|N_BSS
case|:
case|case
name|N_SETB
case|:
comment|/* likewise for symbols with value in BSS.  */
name|p
operator|->
name|n_value
operator|+=
name|entry
operator|->
name|bss_start_address
operator|-
operator|(
name|entry
operator|->
name|header
operator|.
name|a_text
operator|+
name|entry
operator|->
name|header
operator|.
name|a_data
operator|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Assign a value to each global symbol.  */
end_comment

begin_function
specifier|static
name|void
name|digest_pass2
parameter_list|()
block|{
name|FOR_EACH_SYMBOL
argument_list|(
argument|i
argument_list|,
argument|sp
argument_list|)
block|{
name|int
name|size
decl_stmt|;
name|int
name|align
init|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|sp
operator|->
name|flags
operator|&
name|GS_REFERENCED
operator|)
condition|)
continue|continue;
if|if
condition|(
name|sp
operator|->
name|alias
operator|&&
operator|(
name|relocatable_output
operator|||
name|building_shared_object
operator|||
operator|(
name|sp
operator|->
name|alias
operator|->
name|defined
operator|&&
operator|!
name|sp
operator|->
name|alias
operator|->
name|so_defined
operator|)
operator|)
condition|)
block|{
comment|/* 			 * The alias points at a defined symbol, so it 			 * must itself be counted as one too, in order to 			 * compute the correct number of symbol table entries. 			 */
if|if
condition|(
operator|!
name|sp
operator|->
name|defined
condition|)
block|{
comment|/* 				 * Change aliased symbol's definition too. 				 * These things happen if shared object commons 				 * or data is going into our symbol table. 				 */
if|if
condition|(
name|sp
operator|->
name|so_defined
operator|!=
operator|(
name|N_INDR
operator|+
name|N_EXT
operator|)
condition|)
name|warnx
argument_list|(
literal|"pass2: %s: alias isn't"
argument_list|,
name|demangle
argument_list|(
name|sp
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|->
name|defined
operator|=
name|sp
operator|->
name|so_defined
expr_stmt|;
name|sp
operator|->
name|so_defined
operator|=
literal|0
expr_stmt|;
block|}
name|defined_global_sym_count
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sp
operator|->
name|defined
operator|&
name|N_TYPE
operator|)
operator|==
name|N_SETV
condition|)
block|{
comment|/* 			 * Set length word at front of vector and zero byte 			 * at end. Reverse the vector itself to put it in 			 * file order. 			 */
name|unsigned
name|long
name|i
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|unsigned
name|long
name|length_word_index
init|=
name|sp
operator|->
name|value
operator|/
sizeof|sizeof
argument_list|(
name|long
argument_list|)
decl_stmt|;
comment|/* Relocate symbol value */
name|sp
operator|->
name|value
operator|+=
name|set_sect_start
expr_stmt|;
name|set_vectors
index|[
name|length_word_index
index|]
operator|=
name|sp
operator|->
name|setv_count
expr_stmt|;
comment|/* 			 * Relocate vector to final address. 			 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sp
operator|->
name|setv_count
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|nlist
modifier|*
name|p
init|=
operator|(
expr|struct
name|nlist
operator|*
operator|)
name|set_vectors
index|[
literal|1
operator|+
name|i
operator|+
name|length_word_index
index|]
decl_stmt|;
name|set_vectors
index|[
literal|1
operator|+
name|i
operator|+
name|length_word_index
index|]
operator|=
name|p
operator|->
name|n_value
expr_stmt|;
if|if
condition|(
name|building_shared_object
condition|)
block|{
name|struct
name|relocation_info
name|reloc
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|reloc
argument_list|,
sizeof|sizeof
argument_list|(
name|reloc
argument_list|)
argument_list|)
expr_stmt|;
name|RELOC_INIT_SEGMENT_RELOC
argument_list|(
operator|&
name|reloc
argument_list|)
expr_stmt|;
name|RELOC_ADDRESS
argument_list|(
operator|&
name|reloc
argument_list|)
operator|=
operator|(
literal|1
operator|+
name|i
operator|+
name|length_word_index
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|+
name|set_sect_start
expr_stmt|;
name|RELOC_TYPE
argument_list|(
operator|&
name|reloc
argument_list|)
operator|=
operator|(
name|p
operator|->
name|n_type
operator|-
operator|(
name|N_SETA
operator|-
name|N_ABS
operator|)
operator|)
operator|&
name|N_TYPE
expr_stmt|;
name|claim_rrs_segment_reloc
argument_list|(
name|NULL
argument_list|,
operator|&
name|reloc
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 			 * Reverse the vector. 			 */
name|p
operator|=
operator|&
name|set_vectors
index|[
name|length_word_index
operator|+
literal|1
index|]
expr_stmt|;
name|q
operator|=
operator|&
name|set_vectors
index|[
name|length_word_index
operator|+
name|sp
operator|->
name|setv_count
index|]
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|q
condition|)
block|{
name|unsigned
name|long
name|tmp
init|=
operator|*
name|p
decl_stmt|;
operator|*
name|p
operator|++
operator|=
operator|*
name|q
expr_stmt|;
operator|*
name|q
operator|--
operator|=
name|tmp
expr_stmt|;
block|}
comment|/* Clear terminating entry */
name|set_vectors
index|[
name|length_word_index
operator|+
name|sp
operator|->
name|setv_count
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|sp
operator|->
name|def_lsp
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|defined
operator|&&
operator|(
name|sp
operator|->
name|defined
operator|&
operator|~
name|N_EXT
operator|)
operator|!=
name|N_SETV
condition|)
name|sp
operator|->
name|value
operator|=
name|sp
operator|->
name|def_lsp
operator|->
name|nzlist
operator|.
name|nz_value
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|so_defined
operator|&&
operator|(
name|sp
operator|->
name|def_lsp
operator|->
name|entry
operator|->
name|flags
operator|&
name|E_SECONDCLASS
operator|)
condition|)
comment|/* Flag second-hand definitions */
name|undefined_global_sym_count
operator|++
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|flags
operator|&
name|GS_TRACE
condition|)
name|printf
argument_list|(
literal|"symbol %s assigned to location %#lx\n"
argument_list|,
name|demangle
argument_list|(
name|sp
operator|->
name|name
argument_list|)
argument_list|,
name|sp
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If not -r'ing, allocate common symbols in the BSS section. 		 */
if|if
condition|(
name|building_shared_object
operator|&&
operator|!
operator|(
name|link_mode
operator|&
name|SYMBOLIC
operator|)
condition|)
comment|/* No common allocation in shared objects */
continue|continue;
if|if
condition|(
operator|(
name|size
operator|=
name|sp
operator|->
name|common_size
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * It's a common. 			 */
if|if
condition|(
name|sp
operator|->
name|defined
operator|!=
operator|(
name|N_UNDF
operator|+
name|N_EXT
operator|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: common isn't"
argument_list|,
name|demangle
argument_list|(
name|sp
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|size
operator|=
name|sp
operator|->
name|size
operator|)
operator|!=
literal|0
operator|&&
name|sp
operator|->
name|defined
operator|==
name|N_SIZE
condition|)
block|{
comment|/* 			 * It's data from shared object with size info. 			 */
if|if
condition|(
operator|!
name|sp
operator|->
name|so_defined
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: Bogus N_SIZE item"
argument_list|,
name|demangle
argument_list|(
name|sp
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* 			 * It's neither 			 */
continue|continue;
if|if
condition|(
name|relocatable_output
operator|&&
operator|!
name|force_common_definition
condition|)
block|{
name|sp
operator|->
name|defined
operator|=
literal|0
expr_stmt|;
name|undefined_global_sym_count
operator|++
expr_stmt|;
name|defined_global_sym_count
operator|--
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Round up to nearest sizeof (int). I don't know whether 		 * this is necessary or not (given that alignment is taken 		 * care of later), but it's traditional, so I'll leave it in. 		 * Note that if this size alignment is ever removed, ALIGN 		 * above will have to be initialized to 1 instead of sizeof 		 * (int). 		 */
name|size
operator|=
name|PALIGN
argument_list|(
name|size
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|align
operator|<
name|MAX_ALIGNMENT
operator|&&
operator|!
operator|(
name|size
operator|&
name|align
operator|)
condition|)
name|align
operator|<<=
literal|1
expr_stmt|;
name|bss_size
operator|=
name|PALIGN
argument_list|(
name|bss_size
operator|+
name|data_size
operator|+
name|rrs_data_start
argument_list|,
name|align
argument_list|)
operator|-
operator|(
name|data_size
operator|+
name|rrs_data_start
operator|)
expr_stmt|;
name|sp
operator|->
name|value
operator|=
name|rrs_data_start
operator|+
name|data_size
operator|+
name|bss_size
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|defined
operator|==
operator|(
name|N_UNDF
operator||
name|N_EXT
operator|)
condition|)
name|sp
operator|->
name|defined
operator|=
name|N_BSS
operator||
name|N_EXT
expr_stmt|;
else|else
block|{
name|sp
operator|->
name|so_defined
operator|=
literal|0
expr_stmt|;
name|defined_global_sym_count
operator|++
expr_stmt|;
block|}
name|bss_size
operator|+=
name|size
expr_stmt|;
if|if
condition|(
name|write_map
condition|)
name|printf
argument_list|(
literal|"Allocating %s %s: %x at %lx\n"
argument_list|,
name|sp
operator|->
name|defined
operator|==
operator|(
name|N_BSS
operator||
name|N_EXT
operator|)
condition|?
literal|"common"
else|:
literal|"data"
argument_list|,
name|demangle
argument_list|(
name|sp
operator|->
name|name
argument_list|)
argument_list|,
name|size
argument_list|,
name|sp
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
name|END_EACH_SYMBOL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* -------------------------------------------------------------------*/
end_comment

begin_comment
comment|/* Write the output file */
end_comment

begin_function
name|void
name|write_output
parameter_list|()
block|{
name|struct
name|stat
name|statbuf
decl_stmt|;
name|int
name|filemode
decl_stmt|;
name|mode_t
name|u_mask
decl_stmt|;
if|if
condition|(
name|lstat
argument_list|(
name|output_filename
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|S_ISREG
argument_list|(
name|statbuf
operator|.
name|st_mode
argument_list|)
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|output_filename
argument_list|)
expr_stmt|;
block|}
name|u_mask
operator|=
name|umask
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|umask
argument_list|(
name|u_mask
argument_list|)
expr_stmt|;
name|outstream
operator|=
name|fopen
argument_list|(
name|output_filename
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|outstream
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"fopen: %s"
argument_list|,
name|output_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|atexit
argument_list|(
name|cleanup
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"atexit"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|outstream
argument_list|)
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"fstat: %s"
argument_list|,
name|output_filename
argument_list|)
expr_stmt|;
name|filemode
operator|=
name|statbuf
operator|.
name|st_mode
expr_stmt|;
if|if
condition|(
name|S_ISREG
argument_list|(
name|statbuf
operator|.
name|st_mode
argument_list|)
operator|&&
name|chmod
argument_list|(
name|output_filename
argument_list|,
name|filemode
operator|&
operator|~
literal|0111
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"chmod: %s"
argument_list|,
name|output_filename
argument_list|)
expr_stmt|;
comment|/* Output the a.out header.  */
name|write_header
argument_list|()
expr_stmt|;
comment|/* Output the text and data segments, relocating as we go.  */
name|write_text
argument_list|()
expr_stmt|;
name|write_data
argument_list|()
expr_stmt|;
comment|/* Output the merged relocation info, if requested with `-r'.  */
if|if
condition|(
name|relocatable_output
condition|)
name|write_rel
argument_list|()
expr_stmt|;
comment|/* Output the symbol table (both globals and locals).  */
name|write_syms
argument_list|()
expr_stmt|;
comment|/* Output the RSS section */
name|write_rrs
argument_list|()
expr_stmt|;
if|if
condition|(
name|chmod
argument_list|(
name|output_filename
argument_list|,
name|filemode
operator||
operator|(
literal|0111
operator|&
operator|~
name|u_mask
operator|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"chmod: %s"
argument_list|,
name|output_filename
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|outstream
argument_list|)
expr_stmt|;
comment|/* Report I/O error such as disk full.  */
if|if
condition|(
name|ferror
argument_list|(
name|outstream
argument_list|)
operator|||
name|fclose
argument_list|(
name|outstream
argument_list|)
operator|!=
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"write_output: %s"
argument_list|,
name|output_filename
argument_list|)
expr_stmt|;
name|outstream
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|real_output_filename
condition|)
if|if
condition|(
name|rename
argument_list|(
name|output_filename
argument_list|,
name|real_output_filename
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"rename output: %s to %s"
argument_list|,
name|output_filename
argument_list|,
name|real_output_filename
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Total number of symbols to be written in the output file. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nsyms
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|write_header
parameter_list|()
block|{
name|int
name|flags
decl_stmt|;
if|if
condition|(
name|link_mode
operator|&
name|SHAREABLE
condition|)
comment|/* Output is shared object */
name|flags
operator|=
name|EX_DYNAMIC
operator||
name|EX_PIC
expr_stmt|;
elseif|else
if|if
condition|(
name|relocatable_output
operator|&&
name|pic_code_seen
condition|)
comment|/* Output is relocatable and contains PIC code */
name|flags
operator|=
name|EX_PIC
expr_stmt|;
elseif|else
if|if
condition|(
name|rrs_section_type
operator|==
name|RRS_FULL
condition|)
comment|/* Output is a dynamic executable */
name|flags
operator|=
name|EX_DYNAMIC
expr_stmt|;
else|else
comment|/* 		 * Output is a static executable 		 * or a non-PIC relocatable object 		 */
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|oldmagic
operator|&&
operator|(
name|flags
operator|&
name|EX_DPMASK
operator|)
condition|)
name|warnx
argument_list|(
literal|"Cannot set flag in old magic headers\n"
argument_list|)
expr_stmt|;
name|N_SET_FLAG
argument_list|(
name|outheader
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|outheader
operator|.
name|a_text
operator|=
name|text_size
expr_stmt|;
name|outheader
operator|.
name|a_data
operator|=
name|data_size
expr_stmt|;
name|outheader
operator|.
name|a_bss
operator|=
name|bss_size
expr_stmt|;
name|outheader
operator|.
name|a_entry
operator|=
operator|(
name|entry_symbol
condition|?
name|entry_symbol
operator|->
name|value
else|:
name|text_start
operator|+
name|entry_offset
operator|)
expr_stmt|;
if|if
condition|(
name|strip_symbols
operator|==
name|STRIP_ALL
condition|)
name|nsyms
operator|=
literal|0
expr_stmt|;
else|else
name|nsyms
operator|=
name|global_sym_count
operator|+
name|local_sym_count
operator|+
name|debugger_sym_count
expr_stmt|;
if|if
condition|(
name|relocatable_output
condition|)
name|nsyms
operator|+=
name|set_symbol_count
expr_stmt|;
name|outheader
operator|.
name|a_syms
operator|=
name|nsyms
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|relocatable_output
condition|)
block|{
name|outheader
operator|.
name|a_trsize
operator|=
name|text_reloc_size
expr_stmt|;
name|outheader
operator|.
name|a_drsize
operator|=
name|data_reloc_size
expr_stmt|;
block|}
else|else
block|{
name|outheader
operator|.
name|a_trsize
operator|=
literal|0
expr_stmt|;
name|outheader
operator|.
name|a_drsize
operator|=
literal|0
expr_stmt|;
block|}
name|md_swapout_exec_hdr
argument_list|(
operator|&
name|outheader
argument_list|)
expr_stmt|;
name|mywrite
argument_list|(
operator|&
name|outheader
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|exec
argument_list|)
argument_list|,
name|outstream
argument_list|)
expr_stmt|;
name|md_swapin_exec_hdr
argument_list|(
operator|&
name|outheader
argument_list|)
expr_stmt|;
comment|/* 	 * Output whatever padding is required in the executable file 	 * between the header and the start of the text. 	 */
ifndef|#
directive|ifndef
name|COFF_ENCAPSULATE
name|padfile
argument_list|(
name|N_TXTOFF
argument_list|(
name|outheader
argument_list|)
operator|-
sizeof|sizeof
name|outheader
argument_list|,
name|outstream
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Relocate the text segment of each input file  * and write to the output file.  */
end_comment

begin_function
name|void
name|write_text
parameter_list|()
block|{
if|if
condition|(
name|trace_files
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Copying and relocating text:\n\n"
argument_list|)
expr_stmt|;
name|each_full_file
argument_list|(
name|copy_text
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|file_close
argument_list|()
expr_stmt|;
if|if
condition|(
name|trace_files
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|padfile
argument_list|(
name|text_pad
argument_list|,
name|outstream
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Read the text segment contents of ENTRY, relocate them, and write the  * result to the output file.  If `-r', save the text relocation for later  * reuse.  */
end_comment

begin_function
name|void
name|copy_text
parameter_list|(
name|entry
parameter_list|)
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|bytes
decl_stmt|;
specifier|register
name|int
name|fd
decl_stmt|;
if|if
condition|(
name|trace_files
condition|)
name|prline_file_name
argument_list|(
name|entry
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fd
operator|=
name|file_open
argument_list|(
name|entry
argument_list|)
expr_stmt|;
comment|/* Allocate space for the file's text section */
name|bytes
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|entry
operator|->
name|header
operator|.
name|a_text
argument_list|)
expr_stmt|;
comment|/* Deal with relocation information however is appropriate */
if|if
condition|(
name|entry
operator|->
name|textrel
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: no text relocation"
argument_list|,
name|get_file_name
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Read the text section into core.  */
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
name|text_offset
argument_list|(
name|entry
argument_list|)
argument_list|,
name|L_SET
argument_list|)
operator|==
operator|(
name|off_t
operator|)
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s: copy_text: lseek"
argument_list|,
name|get_file_name
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|header
operator|.
name|a_text
operator|!=
name|read
argument_list|(
name|fd
argument_list|,
name|bytes
argument_list|,
name|entry
operator|->
name|header
operator|.
name|a_text
argument_list|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: copy_text: premature EOF"
argument_list|,
name|get_file_name
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Relocate the text according to the text relocation.  */
name|perform_relocation
argument_list|(
name|bytes
argument_list|,
name|entry
operator|->
name|header
operator|.
name|a_text
argument_list|,
name|entry
operator|->
name|textrel
argument_list|,
name|entry
operator|->
name|ntextrel
argument_list|,
name|entry
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Write the relocated text to the output file.  */
name|mywrite
argument_list|(
name|bytes
argument_list|,
name|entry
operator|->
name|header
operator|.
name|a_text
argument_list|,
literal|1
argument_list|,
name|outstream
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Relocate the data segment of each input file  * and write to the output file.  */
end_comment

begin_function
name|void
name|write_data
parameter_list|()
block|{
name|off_t
name|pos
decl_stmt|;
if|if
condition|(
name|trace_files
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Copying and relocating data:\n\n"
argument_list|)
expr_stmt|;
name|pos
operator|=
name|N_DATOFF
argument_list|(
name|outheader
argument_list|)
operator|+
name|data_start
operator|-
name|rrs_data_start
expr_stmt|;
if|if
condition|(
name|fseek
argument_list|(
name|outstream
argument_list|,
name|pos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"write_data: fseek"
argument_list|)
expr_stmt|;
name|each_full_file
argument_list|(
name|copy_data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|file_close
argument_list|()
expr_stmt|;
comment|/* 	 * Write out the set element vectors.  See digest symbols for 	 * description of length of the set vector section. 	 */
if|if
condition|(
name|set_vector_count
condition|)
block|{
name|swap_longs
argument_list|(
name|set_vectors
argument_list|,
name|set_symbol_count
operator|+
literal|2
operator|*
name|set_vector_count
argument_list|)
expr_stmt|;
name|mywrite
argument_list|(
name|set_vectors
argument_list|,
name|set_symbol_count
operator|+
literal|2
operator|*
name|set_vector_count
argument_list|,
expr|sizeof
operator|(
name|unsigned
name|long
operator|)
argument_list|,
name|outstream
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|trace_files
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|padfile
argument_list|(
name|data_pad
argument_list|,
name|outstream
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Read the data segment contents of ENTRY, relocate them, and write the  * result to the output file. If `-r', save the data relocation for later  * reuse. See comments in `copy_text'.  */
end_comment

begin_function
name|void
name|copy_data
parameter_list|(
name|entry
parameter_list|)
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|bytes
decl_stmt|;
specifier|register
name|int
name|fd
decl_stmt|;
if|if
condition|(
name|trace_files
condition|)
name|prline_file_name
argument_list|(
name|entry
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fd
operator|=
name|file_open
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|bytes
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|entry
operator|->
name|header
operator|.
name|a_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|datarel
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: no data relocation"
argument_list|,
name|get_file_name
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
name|text_offset
argument_list|(
name|entry
argument_list|)
operator|+
name|entry
operator|->
name|header
operator|.
name|a_text
argument_list|,
name|L_SET
argument_list|)
operator|==
operator|(
name|off_t
operator|)
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s: copy_data: lseek"
argument_list|,
name|get_file_name
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|header
operator|.
name|a_data
operator|!=
name|read
argument_list|(
name|fd
argument_list|,
name|bytes
argument_list|,
name|entry
operator|->
name|header
operator|.
name|a_data
argument_list|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: copy_data: premature EOF"
argument_list|,
name|get_file_name
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|perform_relocation
argument_list|(
name|bytes
argument_list|,
name|entry
operator|->
name|header
operator|.
name|a_data
argument_list|,
name|entry
operator|->
name|datarel
argument_list|,
name|entry
operator|->
name|ndatarel
argument_list|,
name|entry
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mywrite
argument_list|(
name|bytes
argument_list|,
name|entry
operator|->
name|header
operator|.
name|a_data
argument_list|,
literal|1
argument_list|,
name|outstream
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Relocate ENTRY's text or data section contents. DATA is the address of the  * contents, in core. DATA_SIZE is the length of the contents. PC_RELOCATION  * is the difference between the address of the contents in the output file  * and its address in the input file. RELOC is the address of the  * relocation info, in core. NRELOC says how many there are.  */
end_comment

begin_decl_stmt
name|int
name|pc_relocation
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|perform_relocation
parameter_list|(
name|data
parameter_list|,
name|data_size
parameter_list|,
name|reloc
parameter_list|,
name|nreloc
parameter_list|,
name|entry
parameter_list|,
name|dataseg
parameter_list|)
name|char
modifier|*
name|data
decl_stmt|;
name|int
name|data_size
decl_stmt|;
name|struct
name|relocation_info
modifier|*
name|reloc
decl_stmt|;
name|int
name|nreloc
decl_stmt|;
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
name|int
name|dataseg
decl_stmt|;
block|{
specifier|register
name|struct
name|relocation_info
modifier|*
name|r
init|=
name|reloc
decl_stmt|;
name|struct
name|relocation_info
modifier|*
name|end
init|=
name|reloc
operator|+
name|nreloc
decl_stmt|;
name|int
name|text_relocation
init|=
name|entry
operator|->
name|text_start_address
decl_stmt|;
name|int
name|data_relocation
init|=
name|entry
operator|->
name|data_start_address
operator|-
name|entry
operator|->
name|header
operator|.
name|a_text
decl_stmt|;
name|int
name|bss_relocation
init|=
name|entry
operator|->
name|bss_start_address
operator|-
name|entry
operator|->
name|header
operator|.
name|a_text
operator|-
name|entry
operator|->
name|header
operator|.
name|a_data
decl_stmt|;
name|pc_relocation
operator|=
name|dataseg
condition|?
name|entry
operator|->
name|data_start_address
operator|-
name|entry
operator|->
name|header
operator|.
name|a_text
else|:
name|entry
operator|->
name|text_start_address
expr_stmt|;
for|for
control|(
init|;
name|r
operator|<
name|end
condition|;
name|r
operator|++
control|)
block|{
name|int
name|addr
init|=
name|RELOC_ADDRESS
argument_list|(
name|r
argument_list|)
decl_stmt|;
name|long
name|addend
init|=
name|md_get_addend
argument_list|(
name|r
argument_list|,
name|data
operator|+
name|addr
argument_list|)
decl_stmt|;
name|long
name|relocation
decl_stmt|;
comment|/* 		 * Loop over the relocations again as we did in 		 * consider_relocation(), claiming the reserved RRS 		 * relocations. 		 */
if|if
condition|(
name|addr
operator|>=
name|data_size
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: relocation address out of range"
argument_list|,
name|get_file_name
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|RELOC_JMPTAB_P
argument_list|(
name|r
argument_list|)
condition|)
block|{
name|int
name|symindex
init|=
name|RELOC_SYMBOL
argument_list|(
name|r
argument_list|)
decl_stmt|;
name|struct
name|localsymbol
modifier|*
name|lsp
init|=
operator|&
name|entry
operator|->
name|symbols
index|[
name|symindex
index|]
decl_stmt|;
name|symbol
modifier|*
name|sp
decl_stmt|;
if|if
condition|(
name|symindex
operator|>=
name|entry
operator|->
name|nsymbols
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: relocation symbolnum out of range"
argument_list|,
name|get_file_name
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|=
name|lsp
operator|->
name|symbol
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: bogus relocation record"
argument_list|,
name|get_file_name
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|alias
condition|)
name|sp
operator|=
name|sp
operator|->
name|alias
expr_stmt|;
if|if
condition|(
name|relocatable_output
condition|)
name|relocation
operator|=
name|addend
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|RELOC_EXTERN_P
argument_list|(
name|r
argument_list|)
condition|)
block|{
name|relocation
operator|=
name|addend
operator|+
name|data_relocation
operator|-
name|text_relocation
expr_stmt|;
block|}
else|else
name|relocation
operator|=
name|addend
operator|+
name|claim_rrs_jmpslot
argument_list|(
name|entry
argument_list|,
name|r
argument_list|,
name|sp
argument_list|,
name|addend
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|RELOC_BASEREL_P
argument_list|(
name|r
argument_list|)
condition|)
block|{
name|int
name|symindex
init|=
name|RELOC_SYMBOL
argument_list|(
name|r
argument_list|)
decl_stmt|;
name|struct
name|localsymbol
modifier|*
name|lsp
init|=
operator|&
name|entry
operator|->
name|symbols
index|[
name|symindex
index|]
decl_stmt|;
if|if
condition|(
name|symindex
operator|>=
name|entry
operator|->
name|nsymbols
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: relocation symbolnum out of range"
argument_list|,
name|get_file_name
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|relocatable_output
condition|)
name|relocation
operator|=
name|addend
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|RELOC_EXTERN_P
argument_list|(
name|r
argument_list|)
condition|)
name|relocation
operator|=
name|claim_rrs_internal_gotslot
argument_list|(
name|entry
argument_list|,
name|r
argument_list|,
name|lsp
argument_list|,
name|addend
argument_list|)
expr_stmt|;
else|else
name|relocation
operator|=
name|claim_rrs_gotslot
argument_list|(
name|entry
argument_list|,
name|r
argument_list|,
name|lsp
argument_list|,
name|addend
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|RELOC_EXTERN_P
argument_list|(
name|r
argument_list|)
condition|)
block|{
name|int
name|symindex
init|=
name|RELOC_SYMBOL
argument_list|(
name|r
argument_list|)
decl_stmt|;
name|symbol
modifier|*
name|sp
decl_stmt|;
if|if
condition|(
name|symindex
operator|>=
name|entry
operator|->
name|nsymbols
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: relocation symbolnum out of range"
argument_list|,
name|get_file_name
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|=
name|entry
operator|->
name|symbols
index|[
name|symindex
index|]
operator|.
name|symbol
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: bogus relocation record"
argument_list|,
name|get_file_name
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|alias
condition|)
name|sp
operator|=
name|sp
operator|->
name|alias
expr_stmt|;
if|if
condition|(
name|relocatable_output
condition|)
block|{
name|relocation
operator|=
name|addend
expr_stmt|;
comment|/* 				 * In PIC code, we keep the reference to the 				 * external symbol, even if defined now. 				 */
if|if
condition|(
operator|!
name|pic_code_seen
condition|)
name|relocation
operator|+=
name|sp
operator|->
name|value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sp
operator|->
name|defined
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|flags
operator|&
name|GS_TRACE
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"symbol %s defined as %x in %s\n"
argument_list|,
name|demangle
argument_list|(
name|sp
operator|->
name|name
argument_list|)
argument_list|,
name|sp
operator|->
name|defined
argument_list|,
name|get_file_name
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|==
name|got_symbol
condition|)
block|{
comment|/* Handle _GOT_ refs */
name|relocation
operator|=
name|addend
operator|+
name|sp
operator|->
name|value
operator|+
name|md_got_reloc
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|building_shared_object
condition|)
block|{
comment|/* 					 * Normal (non-PIC) relocation needs 					 * to be converted into an RRS reloc 					 * when building a shared object. 					 */
name|r
operator|->
name|r_address
operator|+=
name|dataseg
condition|?
name|entry
operator|->
name|data_start_address
else|:
name|entry
operator|->
name|text_start_address
expr_stmt|;
name|relocation
operator|=
name|addend
expr_stmt|;
if|if
condition|(
name|claim_rrs_reloc
argument_list|(
name|entry
argument_list|,
name|r
argument_list|,
name|sp
argument_list|,
operator|&
name|relocation
argument_list|)
condition|)
continue|continue;
block|}
elseif|else
if|if
condition|(
name|sp
operator|->
name|defined
operator|==
name|N_SIZE
condition|)
block|{
comment|/* 					 * If size is known, arrange a 					 * run-time copy. 					 */
if|if
condition|(
operator|!
name|sp
operator|->
name|size
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Copy item isn't: %s"
argument_list|,
name|demangle
argument_list|(
name|sp
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|relocation
operator|=
name|addend
operator|+
name|sp
operator|->
name|value
expr_stmt|;
name|r
operator|->
name|r_address
operator|=
name|sp
operator|->
name|value
expr_stmt|;
name|claim_rrs_cpy_reloc
argument_list|(
name|entry
argument_list|,
name|r
argument_list|,
name|sp
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Plain old relocation */
name|relocation
operator|=
name|addend
operator|+
name|sp
operator|->
name|value
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * If the symbol is undefined, we relocate it 				 * in a way similar to -r case. We use an 				 * RRS relocation to resolve the symbol at 				 * run-time. The r_address field is updated 				 * to reflect the changed position in the 				 * output file. 				 */
if|if
condition|(
name|sp
operator|->
name|flags
operator|&
name|GS_TRACE
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"symbol %s claims RRS in %s%s\n"
argument_list|,
name|demangle
argument_list|(
name|sp
operator|->
name|name
argument_list|)
argument_list|,
name|get_file_name
argument_list|(
name|entry
argument_list|)
argument_list|,
operator|(
name|sp
operator|->
name|so_defined
operator|==
operator|(
name|N_TEXT
operator|+
name|N_EXT
operator|)
operator|&&
name|sp
operator|->
name|flags
operator|&
name|GS_HASJMPSLOT
operator|)
condition|?
literal|" (JMPSLOT)"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|->
name|so_defined
operator|==
operator|(
name|N_TEXT
operator|+
name|N_EXT
operator|)
operator|&&
name|sp
operator|->
name|flags
operator|&
name|GS_HASJMPSLOT
condition|)
block|{
comment|/* 					 * Claim a jmpslot if one was allocated. 					 * 					 * At this point, a jmpslot can only 					 * result from a shared object reference 					 * while `force_alias' is in effect. 					 */
name|relocation
operator|=
name|addend
operator|+
name|claim_rrs_jmpslot
argument_list|(
name|entry
argument_list|,
name|r
argument_list|,
name|sp
argument_list|,
name|addend
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|r
operator|->
name|r_address
operator|+=
name|dataseg
condition|?
name|entry
operator|->
name|data_start_address
else|:
name|entry
operator|->
name|text_start_address
expr_stmt|;
name|relocation
operator|=
name|addend
expr_stmt|;
if|if
condition|(
operator|(
name|building_shared_object
operator|||
name|sp
operator|->
name|so_defined
operator|)
operator|&&
name|claim_rrs_reloc
argument_list|(
name|entry
argument_list|,
name|r
argument_list|,
name|sp
argument_list|,
operator|&
name|relocation
argument_list|)
condition|)
continue|continue;
block|}
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|RELOC_TYPE
argument_list|(
name|r
argument_list|)
condition|)
block|{
case|case
name|N_TEXT
case|:
case|case
name|N_TEXT
operator||
name|N_EXT
case|:
name|relocation
operator|=
name|addend
operator|+
name|text_relocation
expr_stmt|;
break|break;
case|case
name|N_DATA
case|:
case|case
name|N_DATA
operator||
name|N_EXT
case|:
comment|/* 				 * A word that points to beginning of the the 				 * data section initially contains not 0 but 				 * rather the "address" of that section in 				 * the input file, which is the length of the 				 * file's text. 				 */
name|relocation
operator|=
name|addend
operator|+
name|data_relocation
expr_stmt|;
break|break;
case|case
name|N_BSS
case|:
case|case
name|N_BSS
operator||
name|N_EXT
case|:
comment|/* 				 * Similarly, an input word pointing to the 				 * beginning of the bss initially contains 				 * the length of text plus data of the file. 				 */
name|relocation
operator|=
name|addend
operator|+
name|bss_relocation
expr_stmt|;
break|break;
case|case
name|N_ABS
case|:
case|case
name|N_ABS
operator||
name|N_EXT
case|:
comment|/* 				 * Don't know why this code would occur, but 				 * apparently it does. 				 */
break|break;
default|default:
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: nonexternal relocation invalid"
argument_list|,
name|get_file_name
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * When building a shared object, these segment 			 * relocations need a "load address relative" 			 * RRS fixup. 			 */
if|if
condition|(
name|building_shared_object
operator|&&
operator|!
name|RELOC_PCREL_P
argument_list|(
name|r
argument_list|)
condition|)
block|{
name|r
operator|->
name|r_address
operator|+=
name|dataseg
condition|?
name|entry
operator|->
name|data_start_address
else|:
name|entry
operator|->
name|text_start_address
expr_stmt|;
name|claim_rrs_segment_reloc
argument_list|(
name|entry
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|RELOC_PCREL_P
argument_list|(
name|r
argument_list|)
condition|)
name|relocation
operator|-=
name|pc_relocation
expr_stmt|;
name|md_relocate
argument_list|(
name|r
argument_list|,
name|relocation
argument_list|,
name|data
operator|+
name|addr
argument_list|,
name|relocatable_output
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * For relocatable_output only: write out the relocation,  * relocating the addresses-to-be-relocated.  */
end_comment

begin_function
name|void
name|write_rel
parameter_list|()
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|trace_files
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Writing text relocation:\n\n"
argument_list|)
expr_stmt|;
comment|/* 	 * Assign each global symbol a sequence number, giving the order 	 * in which `write_syms' will write it. 	 * This is so we can store the proper symbolnum fields 	 * in relocation entries we write. 	 */
comment|/* BLECH - Assign number 0 to __DYNAMIC (!! Sun compatibility) */
if|if
condition|(
name|dynamic_symbol
operator|->
name|flags
operator|&
name|GS_REFERENCED
condition|)
name|dynamic_symbol
operator|->
name|symbolnum
operator|=
name|count
operator|++
expr_stmt|;
name|FOR_EACH_SYMBOL
argument_list|(
argument|i
argument_list|,
argument|sp
argument_list|)
block|{
if|if
condition|(
name|sp
operator|==
name|dynamic_symbol
condition|)
continue|continue;
if|if
condition|(
name|sp
operator|->
name|warning
condition|)
name|count
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sp
operator|->
name|flags
operator|&
name|GS_REFERENCED
operator|)
condition|)
continue|continue;
name|sp
operator|->
name|symbolnum
operator|=
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|size
condition|)
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|alias
condition|)
name|count
operator|++
expr_stmt|;
block|}
name|END_EACH_SYMBOL
expr_stmt|;
if|if
condition|(
name|count
operator|!=
name|global_sym_count
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"internal error: write_rel: count = %d"
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|each_full_file
argument_list|(
name|assign_symbolnums
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
comment|/* Write out the relocations of all files, remembered from copy_text. */
name|each_full_file
argument_list|(
name|coptxtrel
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|trace_files
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nWriting data relocation:\n\n"
argument_list|)
expr_stmt|;
name|each_full_file
argument_list|(
name|copdatrel
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|trace_files
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Assign symbol ordinal numbers to local symbols in each entry.  */
end_comment

begin_function
specifier|static
name|void
name|assign_symbolnums
parameter_list|(
name|entry
parameter_list|,
name|countp
parameter_list|)
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
name|int
modifier|*
name|countp
decl_stmt|;
block|{
name|struct
name|localsymbol
modifier|*
name|lsp
decl_stmt|,
modifier|*
name|lspend
decl_stmt|;
name|int
name|n
init|=
operator|*
name|countp
decl_stmt|;
name|lspend
operator|=
name|entry
operator|->
name|symbols
operator|+
name|entry
operator|->
name|nsymbols
expr_stmt|;
if|if
condition|(
name|discard_locals
operator|!=
name|DISCARD_ALL
condition|)
comment|/* Count the N_FN symbol for this entry */
name|n
operator|++
expr_stmt|;
for|for
control|(
name|lsp
operator|=
name|entry
operator|->
name|symbols
init|;
name|lsp
operator|<
name|lspend
condition|;
name|lsp
operator|++
control|)
block|{
if|if
condition|(
name|lsp
operator|->
name|flags
operator|&
name|LS_WRITE
condition|)
name|lsp
operator|->
name|symbolnum
operator|=
name|n
operator|++
expr_stmt|;
block|}
operator|*
name|countp
operator|=
name|n
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|coptxtrel
parameter_list|(
name|entry
parameter_list|)
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
block|{
specifier|register
name|struct
name|relocation_info
modifier|*
name|r
decl_stmt|,
modifier|*
name|end
decl_stmt|;
specifier|register
name|int
name|reloc
init|=
name|entry
operator|->
name|text_start_address
decl_stmt|;
name|r
operator|=
name|entry
operator|->
name|textrel
expr_stmt|;
name|end
operator|=
name|r
operator|+
name|entry
operator|->
name|ntextrel
expr_stmt|;
for|for
control|(
init|;
name|r
operator|<
name|end
condition|;
name|r
operator|++
control|)
block|{
specifier|register
name|int
name|symindex
decl_stmt|;
name|struct
name|localsymbol
modifier|*
name|lsp
decl_stmt|;
name|symbol
modifier|*
name|sp
decl_stmt|;
name|RELOC_ADDRESS
argument_list|(
name|r
argument_list|)
operator|+=
name|reloc
expr_stmt|;
name|symindex
operator|=
name|RELOC_SYMBOL
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|lsp
operator|=
operator|&
name|entry
operator|->
name|symbols
index|[
name|symindex
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|RELOC_EXTERN_P
argument_list|(
name|r
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|pic_code_seen
condition|)
continue|continue;
if|if
condition|(
name|RELOC_BASEREL_P
argument_list|(
name|r
argument_list|)
condition|)
name|RELOC_SYMBOL
argument_list|(
name|r
argument_list|)
operator|=
name|lsp
operator|->
name|symbolnum
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|symindex
operator|>=
name|entry
operator|->
name|nsymbols
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: relocation symbolnum out of range"
argument_list|,
name|get_file_name
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|=
name|lsp
operator|->
name|symbol
expr_stmt|;
ifdef|#
directive|ifdef
name|N_INDR
comment|/* Resolve indirection.  */
if|if
condition|(
operator|(
name|sp
operator|->
name|defined
operator|&
operator|~
name|N_EXT
operator|)
operator|==
name|N_INDR
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|alias
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"internal error: alias in hyperspace"
argument_list|)
expr_stmt|;
name|sp
operator|=
name|sp
operator|->
name|alias
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 		 * If the symbol is now defined, change the external 		 * relocation to an internal one. 		 */
if|if
condition|(
name|sp
operator|->
name|defined
condition|)
block|{
if|if
condition|(
operator|!
name|pic_code_seen
condition|)
block|{
name|RELOC_EXTERN_P
argument_list|(
name|r
argument_list|)
operator|=
literal|0
expr_stmt|;
name|RELOC_SYMBOL
argument_list|(
name|r
argument_list|)
operator|=
operator|(
name|sp
operator|->
name|defined
operator|&
name|N_TYPE
operator|)
expr_stmt|;
block|}
else|else
name|RELOC_SYMBOL
argument_list|(
name|r
argument_list|)
operator|=
name|sp
operator|->
name|symbolnum
expr_stmt|;
block|}
else|else
comment|/* 			 * Global symbols come first. 			 */
name|RELOC_SYMBOL
argument_list|(
name|r
argument_list|)
operator|=
name|sp
operator|->
name|symbolnum
expr_stmt|;
block|}
name|md_swapout_reloc
argument_list|(
name|entry
operator|->
name|textrel
argument_list|,
name|entry
operator|->
name|ntextrel
argument_list|)
expr_stmt|;
name|mywrite
argument_list|(
name|entry
operator|->
name|textrel
argument_list|,
name|entry
operator|->
name|ntextrel
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|relocation_info
argument_list|)
argument_list|,
name|outstream
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|copdatrel
parameter_list|(
name|entry
parameter_list|)
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
block|{
specifier|register
name|struct
name|relocation_info
modifier|*
name|r
decl_stmt|,
modifier|*
name|end
decl_stmt|;
comment|/* 	 * Relocate the address of the relocation. Old address is relative to 	 * start of the input file's data section. New address is relative to 	 * start of the output file's data section. 	 */
specifier|register
name|int
name|reloc
init|=
name|entry
operator|->
name|data_start_address
operator|-
name|text_size
decl_stmt|;
name|r
operator|=
name|entry
operator|->
name|datarel
expr_stmt|;
name|end
operator|=
name|r
operator|+
name|entry
operator|->
name|ndatarel
expr_stmt|;
for|for
control|(
init|;
name|r
operator|<
name|end
condition|;
name|r
operator|++
control|)
block|{
specifier|register
name|int
name|symindex
decl_stmt|;
name|symbol
modifier|*
name|sp
decl_stmt|;
name|int
name|symtype
decl_stmt|;
name|RELOC_ADDRESS
argument_list|(
name|r
argument_list|)
operator|+=
name|reloc
expr_stmt|;
if|if
condition|(
operator|!
name|RELOC_EXTERN_P
argument_list|(
name|r
argument_list|)
condition|)
block|{
if|if
condition|(
name|RELOC_BASEREL_P
argument_list|(
name|r
argument_list|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: Unsupported relocation type"
argument_list|,
name|get_file_name
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|symindex
operator|=
name|RELOC_SYMBOL
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|sp
operator|=
name|entry
operator|->
name|symbols
index|[
name|symindex
index|]
operator|.
name|symbol
expr_stmt|;
if|if
condition|(
name|symindex
operator|>=
name|entry
operator|->
name|header
operator|.
name|a_syms
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: relocation symbolnum out of range"
argument_list|,
name|get_file_name
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|N_INDR
comment|/* Resolve indirection.  */
if|if
condition|(
operator|(
name|sp
operator|->
name|defined
operator|&
operator|~
name|N_EXT
operator|)
operator|==
name|N_INDR
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|alias
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"internal error: alias in hyperspace"
argument_list|)
expr_stmt|;
name|sp
operator|=
name|sp
operator|->
name|alias
expr_stmt|;
block|}
endif|#
directive|endif
name|symtype
operator|=
name|sp
operator|->
name|defined
operator|&
name|N_TYPE
expr_stmt|;
if|if
condition|(
operator|!
name|pic_code_seen
operator|&&
operator|(
name|symtype
operator|==
name|N_BSS
operator|||
name|symtype
operator|==
name|N_DATA
operator|||
name|symtype
operator|==
name|N_TEXT
operator|||
name|symtype
operator|==
name|N_ABS
operator|)
condition|)
block|{
name|RELOC_EXTERN_P
argument_list|(
name|r
argument_list|)
operator|=
literal|0
expr_stmt|;
name|RELOC_SYMBOL
argument_list|(
name|r
argument_list|)
operator|=
name|symtype
expr_stmt|;
block|}
else|else
comment|/* 			 * Global symbols come first. 			 */
name|RELOC_SYMBOL
argument_list|(
name|r
argument_list|)
operator|=
name|entry
operator|->
name|symbols
index|[
name|symindex
index|]
operator|.
name|symbol
operator|->
name|symbolnum
expr_stmt|;
block|}
name|md_swapout_reloc
argument_list|(
name|entry
operator|->
name|datarel
argument_list|,
name|entry
operator|->
name|ndatarel
argument_list|)
expr_stmt|;
name|mywrite
argument_list|(
name|entry
operator|->
name|datarel
argument_list|,
name|entry
operator|->
name|ndatarel
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|relocation_info
argument_list|)
argument_list|,
name|outstream
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|void
name|write_file_syms
name|__P
argument_list|(
operator|(
expr|struct
name|file_entry
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|write_string_table
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Offsets and current lengths of symbol and string tables in output file. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|symtab_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|symtab_len
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Address in output file where string table starts. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|strtab_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Offset within string table    where the strings in `strtab_vector' should be written. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|strtab_len
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Total size of string table strings allocated so far,    including strings in `strtab_vector'. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|strtab_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Vector whose elements are strings to be added to the string table. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|strtab_vector
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Vector whose elements are the lengths of those strings. */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|strtab_lens
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index in `strtab_vector' at which the next string will be stored. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|strtab_index
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Add the string NAME to the output file string table. Record it in  * `strtab_vector' to be output later. Return the index within the string  * table that this string will have.  */
end_comment

begin_function
specifier|static
name|int
name|assign_string_table_index
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|int
name|index
init|=
name|strtab_size
decl_stmt|;
specifier|register
name|int
name|len
init|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
decl_stmt|;
name|strtab_size
operator|+=
name|len
expr_stmt|;
name|strtab_vector
index|[
name|strtab_index
index|]
operator|=
name|name
expr_stmt|;
name|strtab_lens
index|[
name|strtab_index
operator|++
index|]
operator|=
name|len
expr_stmt|;
return|return
name|index
return|;
block|}
end_function

begin_comment
comment|/*  * Write the contents of `strtab_vector' into the string table. This is done  * once for each file's local&debugger symbols and once for the global  * symbols.  */
end_comment

begin_function
name|void
name|write_string_table
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|fseek
argument_list|(
name|outstream
argument_list|,
name|strtab_offset
operator|+
name|strtab_len
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"write_string_table: %s: fseek"
argument_list|,
name|output_filename
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|strtab_index
condition|;
name|i
operator|++
control|)
block|{
name|mywrite
argument_list|(
name|strtab_vector
index|[
name|i
index|]
argument_list|,
name|strtab_lens
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|,
name|outstream
argument_list|)
expr_stmt|;
name|strtab_len
operator|+=
name|strtab_lens
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Write the symbol table and string table of the output file. */
end_comment

begin_function
name|void
name|write_syms
parameter_list|()
block|{
comment|/* Number of symbols written so far.  */
name|int
name|syms_written
init|=
literal|0
decl_stmt|;
name|struct
name|nlist
name|nl
decl_stmt|;
comment|/* 	 * Buffer big enough for all the global symbols.  One extra struct 	 * for each indirect symbol to hold the extra reference following. 	 */
name|struct
name|nlist
modifier|*
name|buf
init|=
operator|(
expr|struct
name|nlist
operator|*
operator|)
name|alloca
argument_list|(
name|global_sym_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Pointer for storing into BUF.  */
specifier|register
name|struct
name|nlist
modifier|*
name|bufp
init|=
name|buf
decl_stmt|;
comment|/* Size of string table includes the bytes that store the size.  */
name|strtab_size
operator|=
sizeof|sizeof
name|strtab_size
expr_stmt|;
name|symtab_offset
operator|=
name|N_SYMOFF
argument_list|(
name|outheader
argument_list|)
expr_stmt|;
name|symtab_len
operator|=
literal|0
expr_stmt|;
name|strtab_offset
operator|=
name|N_STROFF
argument_list|(
name|outheader
argument_list|)
expr_stmt|;
name|strtab_len
operator|=
name|strtab_size
expr_stmt|;
if|if
condition|(
name|strip_symbols
operator|==
name|STRIP_ALL
condition|)
return|return;
comment|/* First, write out the global symbols.  */
comment|/* 	 * Allocate two vectors that record the data to generate the string 	 * table from the global symbols written so far.  This must include 	 * extra space for the references following indirect outputs. 	 */
name|strtab_vector
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|global_sym_count
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|strtab_lens
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|global_sym_count
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|strtab_index
operator|=
literal|0
expr_stmt|;
comment|/* 	 * __DYNAMIC symbol *must* be first for Sun compatibility, as Sun's 	 * ld.so reads the shared object's first symbol. This means that 	 * (Sun's) shared libraries cannot be stripped! (We only assume 	 * that __DYNAMIC is the first item in the data segment) 	 * 	 * If defined (ie. not relocatable_output), make it look 	 * like an internal symbol. 	 */
if|if
condition|(
name|dynamic_symbol
operator|->
name|flags
operator|&
name|GS_REFERENCED
condition|)
block|{
name|nl
operator|.
name|n_other
operator|=
literal|0
expr_stmt|;
name|nl
operator|.
name|n_desc
operator|=
literal|0
expr_stmt|;
name|nl
operator|.
name|n_type
operator|=
name|dynamic_symbol
operator|->
name|defined
expr_stmt|;
if|if
condition|(
name|nl
operator|.
name|n_type
operator|==
name|N_UNDF
condition|)
name|nl
operator|.
name|n_type
operator||=
name|N_EXT
expr_stmt|;
else|else
name|nl
operator|.
name|n_type
operator|&=
operator|~
name|N_EXT
expr_stmt|;
name|nl
operator|.
name|n_value
operator|=
name|dynamic_symbol
operator|->
name|value
expr_stmt|;
name|nl
operator|.
name|n_un
operator|.
name|n_strx
operator|=
name|assign_string_table_index
argument_list|(
name|dynamic_symbol
operator|->
name|name
argument_list|)
expr_stmt|;
operator|*
name|bufp
operator|++
operator|=
name|nl
expr_stmt|;
name|syms_written
operator|++
expr_stmt|;
block|}
comment|/* Scan the symbol hash table, bucket by bucket.  */
name|FOR_EACH_SYMBOL
argument_list|(
argument|i
argument_list|,
argument|sp
argument_list|)
block|{
if|if
condition|(
name|sp
operator|==
name|dynamic_symbol
condition|)
comment|/* Already dealt with above */
continue|continue;
comment|/* 		 * Propagate N_WARNING symbols. 		 */
if|if
condition|(
operator|(
name|relocatable_output
operator|||
name|building_shared_object
operator|)
operator|&&
name|sp
operator|->
name|warning
condition|)
block|{
name|nl
operator|.
name|n_type
operator|=
name|N_WARNING
expr_stmt|;
name|nl
operator|.
name|n_un
operator|.
name|n_strx
operator|=
name|assign_string_table_index
argument_list|(
name|sp
operator|->
name|warning
argument_list|)
expr_stmt|;
name|nl
operator|.
name|n_value
operator|=
literal|0
expr_stmt|;
name|nl
operator|.
name|n_other
operator|=
literal|0
expr_stmt|;
name|nl
operator|.
name|n_desc
operator|=
literal|0
expr_stmt|;
operator|*
name|bufp
operator|++
operator|=
name|nl
expr_stmt|;
name|syms_written
operator|++
expr_stmt|;
name|nl
operator|.
name|n_type
operator|=
name|N_UNDF
operator|+
name|N_EXT
expr_stmt|;
name|nl
operator|.
name|n_un
operator|.
name|n_strx
operator|=
name|assign_string_table_index
argument_list|(
name|sp
operator|->
name|name
argument_list|)
expr_stmt|;
name|nl
operator|.
name|n_value
operator|=
literal|0
expr_stmt|;
name|nl
operator|.
name|n_other
operator|=
literal|0
expr_stmt|;
name|nl
operator|.
name|n_desc
operator|=
literal|0
expr_stmt|;
operator|*
name|bufp
operator|++
operator|=
name|nl
expr_stmt|;
name|syms_written
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|sp
operator|->
name|flags
operator|&
name|GS_REFERENCED
operator|)
condition|)
comment|/* Came from shared object but was not used */
continue|continue;
if|if
condition|(
name|sp
operator|->
name|so_defined
operator|||
operator|(
name|sp
operator|->
name|alias
operator|&&
name|sp
operator|->
name|alias
operator|->
name|so_defined
operator|)
condition|)
comment|/* 			 * Definition came from shared object, 			 * don't mention it here 			 */
continue|continue;
if|if
condition|(
operator|!
name|sp
operator|->
name|defined
operator|&&
operator|!
name|relocatable_output
condition|)
block|{
comment|/* 			 * We're building a shared object and there 			 * are still undefined symbols. Don't output 			 * these, symbol was discounted in digest_pass1() 			 * (they are in the RRS symbol table). 			 */
if|if
condition|(
name|building_shared_object
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|sp
operator|->
name|flags
operator|&
name|GS_WEAK
operator|)
condition|)
name|warnx
argument_list|(
literal|"symbol %s remains undefined"
argument_list|,
name|demangle
argument_list|(
name|sp
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|syms_written
operator|>=
name|global_sym_count
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"internal error: number of symbols exceeds alloc'd %d"
argument_list|,
name|global_sym_count
argument_list|)
expr_stmt|;
comment|/* 		 * Construct a `struct nlist' for the symbol. 		 */
name|nl
operator|.
name|n_other
operator|=
literal|0
expr_stmt|;
name|nl
operator|.
name|n_desc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|defined
operator|>
literal|1
condition|)
block|{
comment|/* 			 * defined with known type 			 */
if|if
condition|(
operator|!
name|relocatable_output
operator|&&
operator|!
name|building_shared_object
operator|&&
name|sp
operator|->
name|alias
operator|&&
name|sp
operator|->
name|alias
operator|->
name|defined
operator|>
literal|1
condition|)
block|{
comment|/* 				 * If the target of an indirect symbol has 				 * been defined and we are outputting an 				 * executable, resolve the indirection; it's 				 * no longer needed. 				 */
name|nl
operator|.
name|n_type
operator|=
name|sp
operator|->
name|alias
operator|->
name|defined
expr_stmt|;
name|nl
operator|.
name|n_value
operator|=
name|sp
operator|->
name|alias
operator|->
name|value
expr_stmt|;
name|nl
operator|.
name|n_other
operator|=
name|N_OTHER
argument_list|(
literal|0
argument_list|,
name|sp
operator|->
name|alias
operator|->
name|aux
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|bind
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|sp
operator|->
name|defined
operator|==
name|N_SIZE
condition|)
name|nl
operator|.
name|n_type
operator|=
name|N_DATA
operator||
name|N_EXT
expr_stmt|;
else|else
name|nl
operator|.
name|n_type
operator|=
name|sp
operator|->
name|defined
expr_stmt|;
if|if
condition|(
name|nl
operator|.
name|n_type
operator|==
operator|(
name|N_INDR
operator||
name|N_EXT
operator|)
operator|&&
name|sp
operator|->
name|value
operator|!=
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: N_INDR has value %#x"
argument_list|,
name|demangle
argument_list|(
name|sp
operator|->
name|name
argument_list|)
argument_list|,
name|sp
operator|->
name|value
argument_list|)
expr_stmt|;
name|nl
operator|.
name|n_value
operator|=
name|sp
operator|->
name|value
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|def_lsp
condition|)
name|bind
operator|=
name|N_BIND
argument_list|(
operator|&
name|sp
operator|->
name|def_lsp
operator|->
name|nzlist
operator|.
name|nlist
argument_list|)
expr_stmt|;
name|nl
operator|.
name|n_other
operator|=
name|N_OTHER
argument_list|(
name|bind
argument_list|,
name|sp
operator|->
name|aux
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sp
operator|->
name|common_size
condition|)
block|{
comment|/* 			 * defined as common but not allocated, 			 * happens only with -r and not -d, write out 			 * a common definition. 			 * 			 * common condition needs to be before undefined 			 * condition because unallocated commons are set 			 * undefined in digest_symbols. 			 */
name|nl
operator|.
name|n_type
operator|=
name|N_UNDF
operator||
name|N_EXT
expr_stmt|;
name|nl
operator|.
name|n_value
operator|=
name|sp
operator|->
name|common_size
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|sp
operator|->
name|defined
condition|)
block|{
comment|/* undefined -- legit only if -r */
name|nl
operator|.
name|n_type
operator|=
name|N_UNDF
operator||
name|N_EXT
expr_stmt|;
name|nl
operator|.
name|n_value
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|errx
argument_list|(
literal|1
argument_list|,
literal|"internal error: %s defined in mysterious way"
argument_list|,
name|demangle
argument_list|(
name|sp
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * Allocate string table space for the symbol name. 		 */
name|nl
operator|.
name|n_un
operator|.
name|n_strx
operator|=
name|assign_string_table_index
argument_list|(
name|sp
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* Output to the buffer and count it.  */
operator|*
name|bufp
operator|++
operator|=
name|nl
expr_stmt|;
name|syms_written
operator|++
expr_stmt|;
comment|/* 		 * Write second symbol of an alias pair. 		 */
if|if
condition|(
name|nl
operator|.
name|n_type
operator|==
name|N_INDR
operator|+
name|N_EXT
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|alias
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"internal error: alias in hyperspace"
argument_list|)
expr_stmt|;
name|nl
operator|.
name|n_type
operator|=
name|N_UNDF
operator|+
name|N_EXT
expr_stmt|;
name|nl
operator|.
name|n_un
operator|.
name|n_strx
operator|=
name|assign_string_table_index
argument_list|(
name|sp
operator|->
name|alias
operator|->
name|name
argument_list|)
expr_stmt|;
name|nl
operator|.
name|n_value
operator|=
literal|0
expr_stmt|;
name|nl
operator|.
name|n_other
operator|=
literal|0
expr_stmt|;
name|nl
operator|.
name|n_desc
operator|=
literal|0
expr_stmt|;
operator|*
name|bufp
operator|++
operator|=
name|nl
expr_stmt|;
name|syms_written
operator|++
expr_stmt|;
block|}
comment|/* 		 * Write N_SIZE symbol for a symbol with a known size. 		 */
if|if
condition|(
name|relocatable_output
operator|&&
name|sp
operator|->
name|size
condition|)
block|{
name|nl
operator|.
name|n_type
operator|=
name|N_SIZE
operator|+
name|N_EXT
expr_stmt|;
name|nl
operator|.
name|n_un
operator|.
name|n_strx
operator|=
name|assign_string_table_index
argument_list|(
name|sp
operator|->
name|name
argument_list|)
expr_stmt|;
name|nl
operator|.
name|n_value
operator|=
name|sp
operator|->
name|size
expr_stmt|;
name|nl
operator|.
name|n_other
operator|=
literal|0
expr_stmt|;
name|nl
operator|.
name|n_desc
operator|=
literal|0
expr_stmt|;
operator|*
name|bufp
operator|++
operator|=
name|nl
expr_stmt|;
name|syms_written
operator|++
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"writesym(#%d): %s, type %x\n"
argument_list|,
name|syms_written
argument_list|,
name|demangle
argument_list|(
name|sp
operator|->
name|name
argument_list|)
argument_list|,
name|sp
operator|->
name|defined
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|END_EACH_SYMBOL
expr_stmt|;
if|if
condition|(
name|syms_written
operator|!=
name|strtab_index
operator|||
name|strtab_index
operator|!=
name|global_sym_count
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"internal error: wrong number (%d) of global symbols "
literal|"written into output file, should be %d"
argument_list|,
name|syms_written
argument_list|,
name|global_sym_count
argument_list|)
expr_stmt|;
comment|/* Output the buffer full of `struct nlist's.  */
if|if
condition|(
name|fseek
argument_list|(
name|outstream
argument_list|,
name|symtab_offset
operator|+
name|symtab_len
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"write_syms: fseek"
argument_list|)
expr_stmt|;
name|md_swapout_symbols
argument_list|(
name|buf
argument_list|,
name|bufp
operator|-
name|buf
argument_list|)
expr_stmt|;
name|mywrite
argument_list|(
name|buf
argument_list|,
name|bufp
operator|-
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
argument_list|,
name|outstream
argument_list|)
expr_stmt|;
name|symtab_len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
operator|*
operator|(
name|bufp
operator|-
name|buf
operator|)
expr_stmt|;
comment|/* Write the strings for the global symbols.  */
name|write_string_table
argument_list|()
expr_stmt|;
comment|/* Write the local symbols defined by the various files.  */
name|each_file
argument_list|(
name|write_file_syms
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|syms_written
argument_list|)
expr_stmt|;
name|file_close
argument_list|()
expr_stmt|;
if|if
condition|(
name|syms_written
operator|!=
name|nsyms
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"internal error: wrong number of symbols (%d) "
literal|"written into output file, should be %d"
argument_list|,
name|syms_written
argument_list|,
name|nsyms
argument_list|)
expr_stmt|;
if|if
condition|(
name|symtab_offset
operator|+
name|symtab_len
operator|!=
name|strtab_offset
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"internal error: inconsistent symbol table length: %d vs %s"
argument_list|,
name|symtab_offset
operator|+
name|symtab_len
argument_list|,
name|strtab_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|fseek
argument_list|(
name|outstream
argument_list|,
name|strtab_offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"write_syms: fseek"
argument_list|)
expr_stmt|;
name|strtab_size
operator|=
name|md_swap_long
argument_list|(
name|strtab_size
argument_list|)
expr_stmt|;
name|mywrite
argument_list|(
operator|&
name|strtab_size
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
literal|1
argument_list|,
name|outstream
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Write the local and debugger symbols of file ENTRY. Increment  * *SYMS_WRITTEN_ADDR for each symbol that is written.  */
end_comment

begin_comment
comment|/*  * Note that we do not combine identical names of local symbols. dbx or gdb  * would be confused if we did that.  */
end_comment

begin_function
name|void
name|write_file_syms
parameter_list|(
name|entry
parameter_list|,
name|syms_written_addr
parameter_list|)
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
name|int
modifier|*
name|syms_written_addr
decl_stmt|;
block|{
name|struct
name|localsymbol
modifier|*
name|lsp
decl_stmt|,
modifier|*
name|lspend
decl_stmt|;
comment|/* Upper bound on number of syms to be written here.  */
name|int
name|max_syms
init|=
name|entry
operator|->
name|nsymbols
operator|+
literal|1
decl_stmt|;
comment|/* 	 * Buffer to accumulate all the syms before writing them. It has one 	 * extra slot for the local symbol we generate here. 	 */
name|struct
name|nlist
modifier|*
name|buf
init|=
operator|(
expr|struct
name|nlist
operator|*
operator|)
name|alloca
argument_list|(
name|max_syms
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|nlist
modifier|*
name|bufp
init|=
name|buf
decl_stmt|;
if|if
condition|(
name|entry
operator|->
name|flags
operator|&
name|E_DYNAMIC
condition|)
return|return;
comment|/* 	 * Make tables that record, for each symbol, its name and its name's 	 * length. The elements are filled in by `assign_string_table_index'. 	 */
name|strtab_vector
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|alloca
argument_list|(
name|max_syms
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|strtab_lens
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|max_syms
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|strtab_index
operator|=
literal|0
expr_stmt|;
comment|/* Generate a local symbol for the start of this file's text.  */
if|if
condition|(
name|discard_locals
operator|!=
name|DISCARD_ALL
condition|)
block|{
name|struct
name|nlist
name|nl
decl_stmt|;
name|nl
operator|.
name|n_type
operator|=
name|N_FN
operator||
name|N_EXT
expr_stmt|;
name|nl
operator|.
name|n_un
operator|.
name|n_strx
operator|=
name|assign_string_table_index
argument_list|(
name|entry
operator|->
name|local_sym_name
argument_list|)
expr_stmt|;
name|nl
operator|.
name|n_value
operator|=
name|entry
operator|->
name|text_start_address
expr_stmt|;
name|nl
operator|.
name|n_desc
operator|=
literal|0
expr_stmt|;
name|nl
operator|.
name|n_other
operator|=
literal|0
expr_stmt|;
operator|*
name|bufp
operator|++
operator|=
name|nl
expr_stmt|;
operator|(
operator|*
name|syms_written_addr
operator|)
operator|++
expr_stmt|;
block|}
comment|/* Read the file's string table.  */
name|entry
operator|->
name|strings
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|entry
operator|->
name|string_size
argument_list|)
expr_stmt|;
name|read_entry_strings
argument_list|(
name|file_open
argument_list|(
name|entry
argument_list|)
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|lspend
operator|=
name|entry
operator|->
name|symbols
operator|+
name|entry
operator|->
name|nsymbols
expr_stmt|;
for|for
control|(
name|lsp
operator|=
name|entry
operator|->
name|symbols
init|;
name|lsp
operator|<
name|lspend
condition|;
name|lsp
operator|++
control|)
block|{
specifier|register
name|struct
name|nlist
modifier|*
name|p
init|=
operator|&
name|lsp
operator|->
name|nzlist
operator|.
name|nlist
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|lsp
operator|->
name|flags
operator|&
name|LS_WRITE
operator|)
condition|)
continue|continue;
if|if
condition|(
name|discard_locals
operator|==
name|DISCARD_ALL
operator|||
operator|(
name|discard_locals
operator|==
name|DISCARD_L
operator|&&
operator|(
name|lsp
operator|->
name|flags
operator|&
name|LS_L_SYMBOL
operator|)
operator|)
condition|)
block|{
comment|/* 			 * The user wants to discard this symbol, but it 			 * is referenced by a relocation.  We can still 			 * save some file space by suppressing the unique 			 * renaming of the symbol. 			 */
name|lsp
operator|->
name|flags
operator|&=
operator|~
name|LS_RENAME
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|n_un
operator|.
name|n_strx
operator|==
literal|0
condition|)
name|name
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|lsp
operator|->
name|flags
operator|&
name|LS_RENAME
operator|)
condition|)
name|name
operator|=
name|p
operator|->
name|n_un
operator|.
name|n_strx
operator|+
name|entry
operator|->
name|strings
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|cp
init|=
name|p
operator|->
name|n_un
operator|.
name|n_strx
operator|+
name|entry
operator|->
name|strings
decl_stmt|;
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|entry
operator|->
name|local_sym_name
argument_list|)
operator|+
name|strlen
argument_list|(
name|cp
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"%s.%s"
argument_list|,
name|entry
operator|->
name|local_sym_name
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If this symbol has a name, allocate space for it 		 * in the output string table. 		 */
if|if
condition|(
name|name
condition|)
name|p
operator|->
name|n_un
operator|.
name|n_strx
operator|=
name|assign_string_table_index
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* Output this symbol to the buffer and count it.  */
operator|*
name|bufp
operator|++
operator|=
operator|*
name|p
expr_stmt|;
operator|(
operator|*
name|syms_written_addr
operator|)
operator|++
expr_stmt|;
block|}
comment|/* All the symbols are now in BUF; write them.  */
if|if
condition|(
name|fseek
argument_list|(
name|outstream
argument_list|,
name|symtab_offset
operator|+
name|symtab_len
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"write local symbols: fseek"
argument_list|)
expr_stmt|;
name|md_swapout_symbols
argument_list|(
name|buf
argument_list|,
name|bufp
operator|-
name|buf
argument_list|)
expr_stmt|;
name|mywrite
argument_list|(
name|buf
argument_list|,
name|bufp
operator|-
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
argument_list|,
name|outstream
argument_list|)
expr_stmt|;
name|symtab_len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
operator|*
operator|(
name|bufp
operator|-
name|buf
operator|)
expr_stmt|;
comment|/* 	 * Write the string-table data for the symbols just written, using 	 * the data in vectors `strtab_vector' and `strtab_lens'. 	 */
name|write_string_table
argument_list|()
expr_stmt|;
name|entry
operator|->
name|strings
operator|=
literal|0
expr_stmt|;
comment|/* Since it will disappear anyway.  */
block|}
end_function

begin_comment
comment|/*  * Parse the string ARG using scanf format FORMAT, and return the result.  * If it does not parse, report fatal error  * generating the error message using format string ERROR and ARG as arg.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|parse
argument_list|(
name|arg
argument_list|,
name|format
argument_list|,
name|error
argument_list|)
name|char
modifier|*
name|arg
decl_stmt|,
modifier|*
name|format
decl_stmt|,
modifier|*
name|error
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|x
decl_stmt|;
if|if
condition|(
literal|1
operator|!=
name|sscanf
argument_list|(
name|arg
argument_list|,
name|format
argument_list|,
operator|&
name|x
argument_list|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
name|error
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
end_block

begin_comment
comment|/*  * Output COUNT*ELTSIZE bytes of data at BUF to the descriptor FD.  */
end_comment

begin_function
name|void
name|mywrite
parameter_list|(
name|buf
parameter_list|,
name|count
parameter_list|,
name|eltsize
parameter_list|,
name|fd
parameter_list|)
name|void
modifier|*
name|buf
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|eltsize
decl_stmt|;
name|FILE
modifier|*
name|fd
decl_stmt|;
block|{
if|if
condition|(
name|fwrite
argument_list|(
name|buf
argument_list|,
name|eltsize
argument_list|,
name|count
argument_list|,
name|fd
argument_list|)
operator|!=
name|count
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"write"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cleanup
parameter_list|()
block|{
name|struct
name|stat
name|statbuf
decl_stmt|;
if|if
condition|(
name|outstream
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|outstream
argument_list|)
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|S_ISREG
argument_list|(
name|statbuf
operator|.
name|st_mode
argument_list|)
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|output_filename
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Output PADDING zero-bytes to descriptor FD.  * PADDING may be negative; in that case, do nothing.  */
end_comment

begin_function
name|void
name|padfile
parameter_list|(
name|padding
parameter_list|,
name|fd
parameter_list|)
name|int
name|padding
decl_stmt|;
name|FILE
modifier|*
name|fd
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|buf
decl_stmt|;
if|if
condition|(
name|padding
operator|<=
literal|0
condition|)
return|return;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|padding
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|buf
argument_list|,
name|padding
argument_list|)
expr_stmt|;
name|mywrite
argument_list|(
name|buf
argument_list|,
name|padding
argument_list|,
literal|1
argument_list|,
name|fd
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

