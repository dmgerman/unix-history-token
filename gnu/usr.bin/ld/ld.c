begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * This code is derived from software copyrighted by the Free Software  * Foundation.  *  * Modified 1991 by Donn Seeley at UUNET Technologies, Inc.  *  * Modified 1993 by Paul Kranenburg, Erasmus University  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)ld.c	6.10 (Berkeley) 5/22/91"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/* Linker `ld' for GNU    Copyright (C) 1988 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 1, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* Written by Richard Stallman with some help from Eric Albert.    Set, indirect, and warning symbol features added by Randy Smith. */
end_comment

begin_comment
comment|/*  *	$Id: ld.c,v 1.11 1993/11/05 12:47:11 pk Exp $  */
end_comment

begin_comment
comment|/* Define how to initialize system-dependent header fields.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<ar.h>
end_include

begin_include
include|#
directive|include
file|<ranlib.h>
end_include

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_include
include|#
directive|include
file|<stab.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|"ld.h"
end_include

begin_decl_stmt
name|int
name|building_shared_object
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 => write relocation into output file so can re-input it later.  */
end_comment

begin_decl_stmt
name|int
name|relocatable_output
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non zero means to create the output executable. */
end_comment

begin_comment
comment|/* Cleared by nonfatal errors.  */
end_comment

begin_decl_stmt
name|int
name|make_executable
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Force the executable to be output, even if there are non-fatal errors */
end_comment

begin_decl_stmt
name|int
name|force_executable
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 => assign space to common symbols even if `relocatable_output'.  */
end_comment

begin_decl_stmt
name|int
name|force_common_definition
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 => assign jmp slots to text symbols in shared objects even if non-PIC */
end_comment

begin_decl_stmt
name|int
name|force_alias_definition
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Which symbols should be stripped (omitted from the output): none, all, or  * debugger symbols.  */
end_comment

begin_enum
enum|enum
block|{
name|STRIP_NONE
block|,
name|STRIP_ALL
block|,
name|STRIP_DEBUGGER
block|}
name|strip_symbols
enum|;
end_enum

begin_comment
comment|/*  * Which local symbols should be omitted: none, all, or those starting with L.  * This is irrelevant if STRIP_NONE.  */
end_comment

begin_enum
enum|enum
block|{
name|DISCARD_NONE
block|,
name|DISCARD_ALL
block|,
name|DISCARD_L
block|}
name|discard_locals
enum|;
end_enum

begin_comment
comment|/* Nonzero means print names of input files as processed.  */
end_comment

begin_decl_stmt
name|int
name|trace_files
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Magic number to use for the output file, set by switch.  */
end_comment

begin_decl_stmt
name|int
name|magic
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * `text-start' address is normally this much plus a page boundary.  * This is not a user option; it is fixed for each system.  */
end_comment

begin_decl_stmt
name|int
name|text_start_alignment
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Nonzero if -T was specified in the command line.  * This prevents text_start from being set later to default values.  */
end_comment

begin_decl_stmt
name|int
name|T_flag_specified
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Nonzero if -Tdata was specified in the command line.  * This prevents data_start from being set later to default values.  */
end_comment

begin_decl_stmt
name|int
name|Tdata_flag_specified
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Size to pad data section up to.  * We simply increase the size of the data section, padding with zeros,  * and reduce the size of the bss section to match.  */
end_comment

begin_decl_stmt
name|int
name|specified_data_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
modifier|*
name|set_vectors
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|setv_fill_count
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|int
name|argc
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|progname
operator|=
name|strrchr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|progname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
else|else
name|progname
operator|++
expr_stmt|;
comment|/* Added this to stop ld core-dumping on very large .o files.    */
ifdef|#
directive|ifdef
name|RLIMIT_STACK
comment|/* Get rid of any avoidable limit on stack size.  */
block|{
name|struct
name|rlimit
name|rlim
decl_stmt|;
comment|/* Set the stack limit huge so that alloca does not fail. */
name|getrlimit
argument_list|(
name|RLIMIT_STACK
argument_list|,
operator|&
name|rlim
argument_list|)
expr_stmt|;
name|rlim
operator|.
name|rlim_cur
operator|=
name|rlim
operator|.
name|rlim_max
expr_stmt|;
name|setrlimit
argument_list|(
name|RLIMIT_STACK
argument_list|,
operator|&
name|rlim
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* RLIMIT_STACK */
name|page_size
operator|=
name|PAGSIZ
expr_stmt|;
comment|/* Clear the cumulative info on the output file.  */
name|text_size
operator|=
literal|0
expr_stmt|;
name|data_size
operator|=
literal|0
expr_stmt|;
name|bss_size
operator|=
literal|0
expr_stmt|;
name|text_reloc_size
operator|=
literal|0
expr_stmt|;
name|data_reloc_size
operator|=
literal|0
expr_stmt|;
name|data_pad
operator|=
literal|0
expr_stmt|;
name|text_pad
operator|=
literal|0
expr_stmt|;
comment|/* Initialize the data about options.  */
name|specified_data_size
operator|=
literal|0
expr_stmt|;
name|strip_symbols
operator|=
name|STRIP_NONE
expr_stmt|;
name|trace_files
operator|=
literal|0
expr_stmt|;
name|discard_locals
operator|=
name|DISCARD_NONE
expr_stmt|;
name|entry_symbol
operator|=
literal|0
expr_stmt|;
name|write_map
operator|=
literal|0
expr_stmt|;
name|relocatable_output
operator|=
literal|0
expr_stmt|;
name|force_common_definition
operator|=
literal|0
expr_stmt|;
name|T_flag_specified
operator|=
literal|0
expr_stmt|;
name|Tdata_flag_specified
operator|=
literal|0
expr_stmt|;
name|magic
operator|=
name|DEFAULT_MAGIC
expr_stmt|;
name|make_executable
operator|=
literal|1
expr_stmt|;
name|force_executable
operator|=
literal|0
expr_stmt|;
name|link_mode
operator|=
name|DYNAMIC
expr_stmt|;
name|soversion
operator|=
name|LD_VERSION_BSD
expr_stmt|;
comment|/* Initialize the cumulative counts of symbols.  */
name|local_sym_count
operator|=
literal|0
expr_stmt|;
name|non_L_local_sym_count
operator|=
literal|0
expr_stmt|;
name|debugger_sym_count
operator|=
literal|0
expr_stmt|;
name|undefined_global_sym_count
operator|=
literal|0
expr_stmt|;
name|warning_count
operator|=
literal|0
expr_stmt|;
name|multiple_def_count
operator|=
literal|0
expr_stmt|;
name|common_defined_global_count
operator|=
literal|0
expr_stmt|;
comment|/* Keep a list of symbols referenced from the command line */
name|cl_refs_allocated
operator|=
literal|10
expr_stmt|;
name|cmdline_references
operator|=
operator|(
expr|struct
name|glosym
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|cl_refs_allocated
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|glosym
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|cmdline_references
operator|=
literal|0
expr_stmt|;
comment|/* Completely decode ARGV.  */
name|decode_command
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|building_shared_object
operator|=
operator|(
operator|!
name|relocatable_output
operator|&&
operator|(
name|link_mode
operator|&
name|SHAREABLE
operator|)
operator|)
expr_stmt|;
comment|/* Create the symbols `etext', `edata' and `end'.  */
name|symtab_init
argument_list|(
name|relocatable_output
argument_list|)
expr_stmt|;
comment|/* Prepare for the run-time linking support. */
name|init_rrs
argument_list|()
expr_stmt|;
comment|/* 	 * Determine whether to count the header as part of the text size, 	 * and initialize the text size accordingly. This depends on the kind 	 * of system and on the output format selected. 	 */
name|md_init_header
argument_list|(
operator|&
name|outheader
argument_list|,
name|magic
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|text_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|exec
argument_list|)
expr_stmt|;
name|text_size
operator|-=
name|N_TXTOFF
argument_list|(
name|outheader
argument_list|)
expr_stmt|;
if|if
condition|(
name|text_size
operator|<
literal|0
condition|)
name|text_size
operator|=
literal|0
expr_stmt|;
name|entry_offset
operator|=
name|text_size
expr_stmt|;
if|if
condition|(
operator|!
name|T_flag_specified
operator|&&
operator|!
name|relocatable_output
condition|)
name|text_start
operator|=
name|TEXT_START
argument_list|(
name|outheader
argument_list|)
expr_stmt|;
comment|/* The text-start address is normally this far past a page boundary.  */
name|text_start_alignment
operator|=
name|text_start
operator|%
name|page_size
expr_stmt|;
comment|/* 	 * Load symbols of all input files. Also search all libraries and 	 * decide which library members to load. 	 */
name|load_symbols
argument_list|()
expr_stmt|;
comment|/* Compute where each file's sections go, and relocate symbols.  */
name|digest_symbols
argument_list|()
expr_stmt|;
comment|/* 	 * Print error messages for any missing symbols, for any warning 	 * symbols, and possibly multiple definitions 	 */
name|make_executable
operator|=
name|do_warnings
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
comment|/* Print a map, if requested.  */
if|if
condition|(
name|write_map
condition|)
name|print_symbols
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* Write the output file.  */
if|if
condition|(
name|make_executable
operator|||
name|force_executable
condition|)
name|write_output
argument_list|()
expr_stmt|;
name|exit
argument_list|(
operator|!
name|make_executable
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
name|void
name|decode_option
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * Analyze a command line argument. Return 0 if the argument is a filename.  * Return 1 if the argument is a option complete in itself. Return 2 if the  * argument is a option which uses an argument.  *   * Thus, the value is the number of consecutive arguments that are part of  * options.  */
end_comment

begin_function
name|int
name|classify_arg
parameter_list|(
name|arg
parameter_list|)
specifier|register
name|char
modifier|*
name|arg
decl_stmt|;
block|{
if|if
condition|(
operator|*
name|arg
operator|!=
literal|'-'
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|arg
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'a'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|&
name|arg
index|[
literal|2
index|]
argument_list|,
literal|"ssert"
argument_list|)
condition|)
return|return
literal|2
return|;
case|case
literal|'A'
case|:
case|case
literal|'D'
case|:
case|case
literal|'e'
case|:
case|case
literal|'L'
case|:
case|case
literal|'l'
case|:
case|case
literal|'o'
case|:
case|case
literal|'u'
case|:
case|case
literal|'V'
case|:
case|case
literal|'y'
case|:
if|if
condition|(
name|arg
index|[
literal|2
index|]
condition|)
return|return
literal|1
return|;
return|return
literal|2
return|;
case|case
literal|'B'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|&
name|arg
index|[
literal|2
index|]
argument_list|,
literal|"static"
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|&
name|arg
index|[
literal|2
index|]
argument_list|,
literal|"dynamic"
argument_list|)
condition|)
return|return
literal|1
return|;
case|case
literal|'T'
case|:
if|if
condition|(
name|arg
index|[
literal|2
index|]
operator|==
literal|0
condition|)
return|return
literal|2
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|&
name|arg
index|[
literal|2
index|]
argument_list|,
literal|"text"
argument_list|)
condition|)
return|return
literal|2
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|&
name|arg
index|[
literal|2
index|]
argument_list|,
literal|"data"
argument_list|)
condition|)
return|return
literal|2
return|;
return|return
literal|1
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Process the command arguments, setting up file_table with an entry for  * each input file, and setting variables according to the options.  */
end_comment

begin_function
name|void
name|decode_command
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|int
name|argc
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|file_entry
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|number_of_files
operator|=
literal|0
expr_stmt|;
name|output_filename
operator|=
literal|"a.out"
expr_stmt|;
comment|/* 	 * First compute number_of_files so we know how long to make 	 * file_table. 	 * Also process most options completely. 	 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|int
name|code
init|=
name|classify_arg
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
condition|)
block|{
if|if
condition|(
name|i
operator|+
name|code
operator|>
name|argc
condition|)
name|fatal
argument_list|(
literal|"no argument following %s\n"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|decode_option
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|argv
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'l'
operator|||
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'A'
condition|)
name|number_of_files
operator|++
expr_stmt|;
name|i
operator|+=
name|code
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|number_of_files
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|number_of_files
condition|)
name|fatal
argument_list|(
literal|"no input files"
argument_list|)
expr_stmt|;
name|p
operator|=
name|file_table
operator|=
operator|(
expr|struct
name|file_entry
operator|*
operator|)
name|xmalloc
argument_list|(
name|number_of_files
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|file_entry
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|p
argument_list|,
name|number_of_files
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|file_entry
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now scan again and fill in file_table.  */
comment|/* All options except -A and -l are ignored here.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|string
decl_stmt|;
specifier|register
name|int
name|code
init|=
name|classify_arg
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
literal|0
condition|)
block|{
name|p
operator|->
name|filename
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
name|p
operator|->
name|local_sym_name
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
name|p
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|code
operator|==
literal|2
condition|)
name|string
operator|=
name|argv
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
else|else
name|string
operator|=
operator|&
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'B'
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|string
argument_list|,
literal|"static"
argument_list|)
operator|==
literal|0
condition|)
name|link_mode
operator|&=
operator|~
name|DYNAMIC
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|string
argument_list|,
literal|"dynamic"
argument_list|)
operator|==
literal|0
condition|)
name|link_mode
operator||=
name|DYNAMIC
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|string
argument_list|,
literal|"symbolic"
argument_list|)
operator|==
literal|0
condition|)
name|link_mode
operator||=
name|SYMBOLIC
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|string
argument_list|,
literal|"forcearchive"
argument_list|)
operator|==
literal|0
condition|)
name|link_mode
operator||=
name|FORCEARCHIVE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|string
argument_list|,
literal|"shareable"
argument_list|)
operator|==
literal|0
condition|)
name|link_mode
operator||=
name|SHAREABLE
expr_stmt|;
block|}
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'A'
condition|)
block|{
if|if
condition|(
name|p
operator|!=
name|file_table
condition|)
name|fatal
argument_list|(
literal|"-A specified before an input file other than the first"
argument_list|)
expr_stmt|;
name|p
operator|->
name|filename
operator|=
name|string
expr_stmt|;
name|p
operator|->
name|local_sym_name
operator|=
name|string
expr_stmt|;
name|p
operator|->
name|just_syms_flag
operator|=
literal|1
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'l'
condition|)
block|{
name|p
operator|->
name|filename
operator|=
name|string
expr_stmt|;
name|p
operator|->
name|local_sym_name
operator|=
name|concat
argument_list|(
literal|"-l"
argument_list|,
name|string
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|p
operator|->
name|search_dirs_flag
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|link_mode
operator|&
name|DYNAMIC
operator|&&
operator|!
name|relocatable_output
condition|)
name|p
operator|->
name|search_dynamic_flag
operator|=
literal|1
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
name|i
operator|+=
name|code
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Now check some option settings for consistency.  */
if|if
condition|(
operator|(
name|magic
operator|!=
name|OMAGIC
operator|)
operator|&&
operator|(
name|text_start
operator|-
name|text_start_alignment
operator|)
operator|&
operator|(
name|page_size
operator|-
literal|1
operator|)
condition|)
name|fatal
argument_list|(
literal|"-T argument not multiple of page size, with sharable output"
argument_list|)
expr_stmt|;
comment|/* Append the standard search directories to the user-specified ones. */
name|std_search_dirs
argument_list|(
name|getenv
argument_list|(
literal|"LD_LIBRARY_PATH"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|add_cmdline_ref
parameter_list|(
name|sp
parameter_list|)
name|struct
name|glosym
modifier|*
name|sp
decl_stmt|;
block|{
name|struct
name|glosym
modifier|*
modifier|*
name|ptr
decl_stmt|;
for|for
control|(
name|ptr
operator|=
name|cmdline_references
init|;
name|ptr
operator|<
name|cmdline_references
operator|+
name|cl_refs_allocated
operator|&&
operator|*
name|ptr
condition|;
name|ptr
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|ptr
operator|>=
name|cmdline_references
operator|+
name|cl_refs_allocated
operator|-
literal|1
condition|)
block|{
name|int
name|diff
init|=
name|ptr
operator|-
name|cmdline_references
decl_stmt|;
name|cl_refs_allocated
operator|*=
literal|2
expr_stmt|;
name|cmdline_references
operator|=
operator|(
expr|struct
name|glosym
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|cmdline_references
argument_list|,
name|cl_refs_allocated
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|glosym
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|cmdline_references
operator|+
name|diff
expr_stmt|;
block|}
operator|*
name|ptr
operator|++
operator|=
name|sp
expr_stmt|;
operator|*
name|ptr
operator|=
operator|(
expr|struct
name|glosym
operator|*
operator|)
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|int
name|set_element_prefixed_p
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|string_list_element
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|p
operator|=
name|set_element_prefixes
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|p
operator|->
name|str
index|[
name|i
index|]
operator|!=
literal|'\0'
operator|&&
operator|(
name|p
operator|->
name|str
index|[
name|i
index|]
operator|==
name|name
index|[
name|i
index|]
operator|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|p
operator|->
name|str
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Record an option and arrange to act on it later. ARG should be the  * following command argument, which may or may not be used by this option.  *   * The `l' and `A' options are ignored here since they actually specify input  * files.  */
end_comment

begin_function
name|void
name|decode_option
parameter_list|(
name|swt
parameter_list|,
name|arg
parameter_list|)
specifier|register
name|char
modifier|*
name|swt
decl_stmt|,
decl|*
name|arg
decl_stmt|;
end_function

begin_block
block|{
comment|/* We get Bstatic from gcc on suns.  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|swt
operator|+
literal|1
argument_list|,
literal|"Bstatic"
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|swt
operator|+
literal|1
argument_list|,
literal|"Bdynamic"
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|swt
operator|+
literal|1
argument_list|,
literal|"Bsymbolic"
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|swt
operator|+
literal|1
argument_list|,
literal|"Bforcearchive"
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|swt
operator|+
literal|1
argument_list|,
literal|"Bshareable"
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|swt
operator|+
literal|1
argument_list|,
literal|"assert"
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|swt
operator|+
literal|1
argument_list|,
literal|"Ttext"
argument_list|)
condition|)
block|{
name|text_start
operator|=
name|parse
argument_list|(
name|arg
argument_list|,
literal|"%x"
argument_list|,
literal|"invalid argument to -Ttext"
argument_list|)
expr_stmt|;
name|T_flag_specified
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|swt
operator|+
literal|1
argument_list|,
literal|"Tdata"
argument_list|)
condition|)
block|{
name|rrs_data_start
operator|=
name|parse
argument_list|(
name|arg
argument_list|,
literal|"%x"
argument_list|,
literal|"invalid argument to -Tdata"
argument_list|)
expr_stmt|;
name|Tdata_flag_specified
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|swt
operator|+
literal|1
argument_list|,
literal|"noinhibit-exec"
argument_list|)
condition|)
block|{
name|force_executable
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|swt
index|[
literal|2
index|]
operator|!=
literal|0
condition|)
name|arg
operator|=
operator|&
name|swt
index|[
literal|2
index|]
expr_stmt|;
switch|switch
condition|(
name|swt
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'A'
case|:
return|return;
case|case
literal|'D'
case|:
name|specified_data_size
operator|=
name|parse
argument_list|(
name|arg
argument_list|,
literal|"%x"
argument_list|,
literal|"invalid argument to -D"
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'d'
case|:
if|if
condition|(
operator|*
name|arg
operator|==
literal|'c'
condition|)
name|force_common_definition
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|arg
operator|==
literal|'p'
condition|)
name|force_alias_definition
operator|=
literal|1
expr_stmt|;
else|else
name|fatal
argument_list|(
literal|"-d option takes 'c' or 'p' argument"
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'e'
case|:
name|entry_symbol
operator|=
name|getsym
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|entry_symbol
operator|->
name|defined
operator|&&
operator|!
name|entry_symbol
operator|->
name|referenced
condition|)
name|undefined_global_sym_count
operator|++
expr_stmt|;
name|entry_symbol
operator|->
name|referenced
operator|=
literal|1
expr_stmt|;
name|add_cmdline_ref
argument_list|(
name|entry_symbol
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'l'
case|:
return|return;
case|case
literal|'L'
case|:
name|add_search_dir
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'M'
case|:
name|write_map
operator|=
literal|1
expr_stmt|;
return|return;
case|case
literal|'N'
case|:
name|magic
operator|=
name|OMAGIC
expr_stmt|;
return|return;
ifdef|#
directive|ifdef
name|NMAGIC
case|case
literal|'n'
case|:
name|magic
operator|=
name|NMAGIC
expr_stmt|;
return|return;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|QMAGIC
case|case
literal|'Q'
case|:
name|magic
operator|=
name|oldmagic
operator|=
name|QMAGIC
expr_stmt|;
return|return;
case|case
literal|'Z'
case|:
name|magic
operator|=
name|oldmagic
operator|=
name|ZMAGIC
expr_stmt|;
return|return;
endif|#
directive|endif
case|case
literal|'o'
case|:
name|output_filename
operator|=
name|arg
expr_stmt|;
return|return;
case|case
literal|'r'
case|:
name|relocatable_output
operator|=
literal|1
expr_stmt|;
name|magic
operator|=
name|OMAGIC
expr_stmt|;
name|text_start
operator|=
literal|0
expr_stmt|;
return|return;
case|case
literal|'S'
case|:
name|strip_symbols
operator|=
name|STRIP_DEBUGGER
expr_stmt|;
return|return;
case|case
literal|'s'
case|:
name|strip_symbols
operator|=
name|STRIP_ALL
expr_stmt|;
return|return;
case|case
literal|'T'
case|:
name|text_start
operator|=
name|parse
argument_list|(
name|arg
argument_list|,
literal|"%x"
argument_list|,
literal|"invalid argument to -T"
argument_list|)
expr_stmt|;
name|T_flag_specified
operator|=
literal|1
expr_stmt|;
return|return;
case|case
literal|'t'
case|:
name|trace_files
operator|=
literal|1
expr_stmt|;
return|return;
case|case
literal|'u'
case|:
block|{
specifier|register
name|symbol
modifier|*
name|sp
init|=
name|getsym
argument_list|(
name|arg
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sp
operator|->
name|defined
operator|&&
operator|!
name|sp
operator|->
name|referenced
condition|)
name|undefined_global_sym_count
operator|++
expr_stmt|;
name|sp
operator|->
name|referenced
operator|=
literal|1
expr_stmt|;
name|add_cmdline_ref
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
return|return;
if|#
directive|if
literal|1
case|case
literal|'V'
case|:
name|soversion
operator|=
name|parse
argument_list|(
name|arg
argument_list|,
literal|"%d"
argument_list|,
literal|"invalid argument to -V"
argument_list|)
expr_stmt|;
return|return;
endif|#
directive|endif
case|case
literal|'X'
case|:
name|discard_locals
operator|=
name|DISCARD_L
expr_stmt|;
return|return;
case|case
literal|'x'
case|:
name|discard_locals
operator|=
name|DISCARD_ALL
expr_stmt|;
return|return;
case|case
literal|'y'
case|:
block|{
specifier|register
name|symbol
modifier|*
name|sp
init|=
name|getsym
argument_list|(
operator|&
name|swt
index|[
literal|2
index|]
argument_list|)
decl_stmt|;
name|sp
operator|->
name|trace
operator|=
literal|1
expr_stmt|;
block|}
return|return;
case|case
literal|'z'
case|:
name|magic
operator|=
name|ZMAGIC
expr_stmt|;
return|return;
default|default:
name|fatal
argument_list|(
literal|"invalid command option `%s'"
argument_list|,
name|swt
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Convenient functions for operating on one or all files being loaded. */
end_comment

begin_comment
comment|/*  * Call FUNCTION on each input file entry. Do not call for entries for  * libraries; instead, call once for each library member that is being  * loaded.  *   * FUNCTION receives two arguments: the entry, and ARG.  */
end_comment

begin_decl_stmt
name|void
name|each_file
argument_list|(
name|function
argument_list|,
name|arg
argument_list|)
decl|register
name|void
argument_list|(
operator|*
name|function
argument_list|)
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|number_of_files
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|struct
name|file_entry
modifier|*
name|entry
init|=
operator|&
name|file_table
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|entry
operator|->
name|library_flag
condition|)
block|{
specifier|register
name|struct
name|file_entry
modifier|*
name|subentry
init|=
name|entry
operator|->
name|subfiles
decl_stmt|;
for|for
control|(
init|;
name|subentry
condition|;
name|subentry
operator|=
name|subentry
operator|->
name|chain
control|)
call|(
modifier|*
name|function
call|)
argument_list|(
name|subentry
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
else|else
call|(
modifier|*
name|function
call|)
argument_list|(
name|entry
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Call FUNCTION on each input file entry until it returns a non-zero value.  * Return this value. Do not call for entries for libraries; instead, call  * once for each library member that is being loaded.  *   * FUNCTION receives two arguments: the entry, and ARG.  It must be a function  * returning unsigned long (though this can probably be fudged).  */
end_comment

begin_decl_stmt
name|unsigned
name|long
name|check_each_file
argument_list|(
name|function
argument_list|,
name|arg
argument_list|)
decl|register
name|unsigned
name|long
argument_list|(
operator|*
name|function
argument_list|)
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|unsigned
name|long
name|return_val
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|number_of_files
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|struct
name|file_entry
modifier|*
name|entry
init|=
operator|&
name|file_table
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|entry
operator|->
name|library_flag
condition|)
block|{
specifier|register
name|struct
name|file_entry
modifier|*
name|subentry
init|=
name|entry
operator|->
name|subfiles
decl_stmt|;
for|for
control|(
init|;
name|subentry
condition|;
name|subentry
operator|=
name|subentry
operator|->
name|chain
control|)
if|if
condition|(
name|return_val
operator|=
call|(
modifier|*
name|function
call|)
argument_list|(
name|subentry
argument_list|,
name|arg
argument_list|)
condition|)
return|return
name|return_val
return|;
block|}
elseif|else
if|if
condition|(
name|return_val
operator|=
call|(
modifier|*
name|function
call|)
argument_list|(
name|entry
argument_list|,
name|arg
argument_list|)
condition|)
return|return
name|return_val
return|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Like `each_file' but ignore files that were just for symbol definitions.  */
end_comment

begin_decl_stmt
name|void
name|each_full_file
argument_list|(
name|function
argument_list|,
name|arg
argument_list|)
decl|register
name|void
argument_list|(
operator|*
name|function
argument_list|)
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|number_of_files
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|struct
name|file_entry
modifier|*
name|entry
init|=
operator|&
name|file_table
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|entry
operator|->
name|just_syms_flag
operator|||
name|entry
operator|->
name|is_dynamic
condition|)
continue|continue;
if|if
condition|(
name|entry
operator|->
name|library_flag
condition|)
block|{
specifier|register
name|struct
name|file_entry
modifier|*
name|subentry
init|=
name|entry
operator|->
name|subfiles
decl_stmt|;
for|for
control|(
init|;
name|subentry
condition|;
name|subentry
operator|=
name|subentry
operator|->
name|chain
control|)
call|(
modifier|*
name|function
call|)
argument_list|(
name|subentry
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
else|else
call|(
modifier|*
name|function
call|)
argument_list|(
name|entry
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Close the input file that is now open.  */
end_comment

begin_function
name|void
name|file_close
parameter_list|()
block|{
name|close
argument_list|(
name|input_desc
argument_list|)
expr_stmt|;
name|input_desc
operator|=
literal|0
expr_stmt|;
name|input_file
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Open the input file specified by 'entry', and return a descriptor. The  * open file is remembered; if the same file is opened twice in a row, a new  * open is not actually done.  */
end_comment

begin_function
name|int
name|file_open
parameter_list|(
name|entry
parameter_list|)
specifier|register
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
block|{
specifier|register
name|int
name|desc
decl_stmt|;
if|if
condition|(
name|entry
operator|->
name|superfile
condition|)
return|return
name|file_open
argument_list|(
name|entry
operator|->
name|superfile
argument_list|)
return|;
if|if
condition|(
name|entry
operator|==
name|input_file
condition|)
return|return
name|input_desc
return|;
if|if
condition|(
name|input_file
condition|)
name|file_close
argument_list|()
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|search_dirs_flag
condition|)
block|{
name|desc
operator|=
name|findlib
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
else|else
name|desc
operator|=
name|open
argument_list|(
name|entry
operator|->
name|filename
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|>
literal|0
condition|)
block|{
name|input_file
operator|=
name|entry
expr_stmt|;
name|input_desc
operator|=
name|desc
expr_stmt|;
return|return
name|desc
return|;
block|}
name|perror_file
argument_list|(
name|entry
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_function
name|int
name|text_offset
parameter_list|(
name|entry
parameter_list|)
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
block|{
return|return
name|entry
operator|->
name|starting_offset
operator|+
name|N_TXTOFF
argument_list|(
name|entry
operator|->
name|header
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Medium-level input routines for rel files.  */
end_comment

begin_comment
comment|/*  * Read a file's header into the proper place in the file_entry. DESC is the  * descriptor on which the file is open. ENTRY is the file's entry.  */
end_comment

begin_function
name|void
name|read_header
parameter_list|(
name|desc
parameter_list|,
name|entry
parameter_list|)
name|int
name|desc
decl_stmt|;
specifier|register
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
block|{
specifier|register
name|int
name|len
decl_stmt|;
name|struct
name|exec
modifier|*
name|loc
init|=
operator|(
expr|struct
name|exec
operator|*
operator|)
operator|&
name|entry
operator|->
name|header
decl_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|desc
argument_list|,
name|entry
operator|->
name|starting_offset
argument_list|,
name|L_SET
argument_list|)
operator|!=
name|entry
operator|->
name|starting_offset
condition|)
name|fatal_with_file
argument_list|(
literal|"read_header: lseek failure "
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|len
operator|=
name|read
argument_list|(
name|desc
argument_list|,
operator|&
name|entry
operator|->
name|header
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|exec
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|exec
argument_list|)
condition|)
name|fatal_with_file
argument_list|(
literal|"failure reading header of "
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|md_swapin_exec_hdr
argument_list|(
operator|&
name|entry
operator|->
name|header
argument_list|)
expr_stmt|;
if|if
condition|(
name|N_BADMAG
argument_list|(
operator|*
name|loc
argument_list|)
condition|)
name|fatal_with_file
argument_list|(
literal|"bad magic number in "
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|entry
operator|->
name|header_read_flag
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Read the symbols of file ENTRY into core. Assume it is already open, on  * descriptor DESC. Also read the length of the string table, which follows  * the symbol table, but don't read the contents of the string table.  */
end_comment

begin_function
name|void
name|read_entry_symbols
parameter_list|(
name|desc
parameter_list|,
name|entry
parameter_list|)
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
name|int
name|desc
decl_stmt|;
block|{
name|int
name|str_size
decl_stmt|;
name|struct
name|nlist
modifier|*
name|np
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|entry
operator|->
name|header_read_flag
condition|)
name|read_header
argument_list|(
name|desc
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|np
operator|=
operator|(
expr|struct
name|nlist
operator|*
operator|)
name|alloca
argument_list|(
name|entry
operator|->
name|header
operator|.
name|a_syms
argument_list|)
expr_stmt|;
name|entry
operator|->
name|nsymbols
operator|=
name|entry
operator|->
name|header
operator|.
name|a_syms
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
expr_stmt|;
name|entry
operator|->
name|symbols
operator|=
operator|(
expr|struct
name|localsymbol
operator|*
operator|)
name|xmalloc
argument_list|(
name|entry
operator|->
name|nsymbols
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|localsymbol
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|desc
argument_list|,
name|N_SYMOFF
argument_list|(
name|entry
operator|->
name|header
argument_list|)
operator|+
name|entry
operator|->
name|starting_offset
argument_list|,
name|L_SET
argument_list|)
operator|!=
name|N_SYMOFF
argument_list|(
name|entry
operator|->
name|header
argument_list|)
operator|+
name|entry
operator|->
name|starting_offset
condition|)
name|fatal_with_file
argument_list|(
literal|"read_symbols(h): lseek failure "
argument_list|,
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|header
operator|.
name|a_syms
operator|!=
name|read
argument_list|(
name|desc
argument_list|,
name|np
argument_list|,
name|entry
operator|->
name|header
operator|.
name|a_syms
argument_list|)
condition|)
name|fatal_with_file
argument_list|(
literal|"premature end of file in symbols of "
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|md_swapin_symbols
argument_list|(
name|np
argument_list|,
name|entry
operator|->
name|header
operator|.
name|a_syms
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|entry
operator|->
name|nsymbols
condition|;
name|i
operator|++
control|)
block|{
name|entry
operator|->
name|symbols
index|[
name|i
index|]
operator|.
name|nzlist
operator|.
name|nlist
operator|=
operator|*
name|np
operator|++
expr_stmt|;
name|entry
operator|->
name|symbols
index|[
name|i
index|]
operator|.
name|nzlist
operator|.
name|nz_size
operator|=
literal|0
expr_stmt|;
name|entry
operator|->
name|symbols
index|[
name|i
index|]
operator|.
name|symbol
operator|=
name|NULL
expr_stmt|;
name|entry
operator|->
name|symbols
index|[
name|i
index|]
operator|.
name|next
operator|=
name|NULL
expr_stmt|;
name|entry
operator|->
name|symbols
index|[
name|i
index|]
operator|.
name|gotslot_offset
operator|=
operator|-
literal|1
expr_stmt|;
name|entry
operator|->
name|symbols
index|[
name|i
index|]
operator|.
name|gotslot_claimed
operator|=
literal|0
expr_stmt|;
block|}
name|entry
operator|->
name|strings_offset
operator|=
name|N_STROFF
argument_list|(
name|entry
operator|->
name|header
argument_list|)
operator|+
name|entry
operator|->
name|starting_offset
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|desc
argument_list|,
name|entry
operator|->
name|strings_offset
argument_list|,
literal|0
argument_list|)
operator|==
operator|(
name|off_t
operator|)
operator|-
literal|1
condition|)
name|fatal_with_file
argument_list|(
literal|"read_symbols(s): lseek failure "
argument_list|,
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
sizeof|sizeof
name|str_size
operator|!=
name|read
argument_list|(
name|desc
argument_list|,
operator|&
name|str_size
argument_list|,
sizeof|sizeof
name|str_size
argument_list|)
condition|)
name|fatal_with_file
argument_list|(
literal|"bad string table size in "
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|entry
operator|->
name|string_size
operator|=
name|md_swap_long
argument_list|(
name|str_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Read the string table of file ENTRY into core. Assume it is already open,  * on descriptor DESC.  */
end_comment

begin_function
name|void
name|read_entry_strings
parameter_list|(
name|desc
parameter_list|,
name|entry
parameter_list|)
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
name|int
name|desc
decl_stmt|;
block|{
name|int
name|buffer
decl_stmt|;
if|if
condition|(
operator|!
name|entry
operator|->
name|header_read_flag
operator|||
operator|!
name|entry
operator|->
name|strings_offset
condition|)
name|fatal
argument_list|(
literal|"internal error: %s"
argument_list|,
literal|"cannot read string table"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|desc
argument_list|,
name|entry
operator|->
name|strings_offset
argument_list|,
name|L_SET
argument_list|)
operator|!=
name|entry
operator|->
name|strings_offset
condition|)
name|fatal_with_file
argument_list|(
literal|"read_strings: lseek failure "
argument_list|,
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|string_size
operator|!=
name|read
argument_list|(
name|desc
argument_list|,
name|entry
operator|->
name|strings
argument_list|,
name|entry
operator|->
name|string_size
argument_list|)
condition|)
name|fatal_with_file
argument_list|(
literal|"premature end of file in strings of "
argument_list|,
name|entry
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* DEAD - Read in all of the relocation information */
end_comment

begin_function
name|void
name|read_relocation
parameter_list|()
block|{
name|each_full_file
argument_list|(
name|read_entry_relocation
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read in the relocation sections of ENTRY if necessary */
end_comment

begin_function
name|void
name|read_entry_relocation
parameter_list|(
name|desc
parameter_list|,
name|entry
parameter_list|)
name|int
name|desc
decl_stmt|;
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
block|{
specifier|register
name|struct
name|relocation_info
modifier|*
name|reloc
decl_stmt|;
name|off_t
name|pos
decl_stmt|;
if|if
condition|(
operator|!
name|entry
operator|->
name|textrel
condition|)
block|{
name|reloc
operator|=
operator|(
expr|struct
name|relocation_info
operator|*
operator|)
name|xmalloc
argument_list|(
name|entry
operator|->
name|header
operator|.
name|a_trsize
argument_list|)
expr_stmt|;
name|pos
operator|=
name|text_offset
argument_list|(
name|entry
argument_list|)
operator|+
name|entry
operator|->
name|header
operator|.
name|a_text
operator|+
name|entry
operator|->
name|header
operator|.
name|a_data
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|desc
argument_list|,
name|pos
argument_list|,
name|L_SET
argument_list|)
operator|!=
name|pos
condition|)
name|fatal_with_file
argument_list|(
literal|"read_reloc(t): lseek failure "
argument_list|,
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|header
operator|.
name|a_trsize
operator|!=
name|read
argument_list|(
name|desc
argument_list|,
name|reloc
argument_list|,
name|entry
operator|->
name|header
operator|.
name|a_trsize
argument_list|)
condition|)
block|{
name|fatal_with_file
argument_list|(
literal|"premature eof in text relocation of "
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
name|md_swapin_reloc
argument_list|(
name|reloc
argument_list|,
name|entry
operator|->
name|header
operator|.
name|a_trsize
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|reloc
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|textrel
operator|=
name|reloc
expr_stmt|;
name|entry
operator|->
name|ntextrel
operator|=
name|entry
operator|->
name|header
operator|.
name|a_trsize
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|reloc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|entry
operator|->
name|datarel
condition|)
block|{
name|reloc
operator|=
operator|(
expr|struct
name|relocation_info
operator|*
operator|)
name|xmalloc
argument_list|(
name|entry
operator|->
name|header
operator|.
name|a_drsize
argument_list|)
expr_stmt|;
name|pos
operator|=
name|text_offset
argument_list|(
name|entry
argument_list|)
operator|+
name|entry
operator|->
name|header
operator|.
name|a_text
operator|+
name|entry
operator|->
name|header
operator|.
name|a_data
operator|+
name|entry
operator|->
name|header
operator|.
name|a_trsize
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|desc
argument_list|,
name|pos
argument_list|,
name|L_SET
argument_list|)
operator|!=
name|pos
condition|)
name|fatal_with_file
argument_list|(
literal|"read_reloc(d): lseek failure "
argument_list|,
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|header
operator|.
name|a_drsize
operator|!=
name|read
argument_list|(
name|desc
argument_list|,
name|reloc
argument_list|,
name|entry
operator|->
name|header
operator|.
name|a_drsize
argument_list|)
condition|)
block|{
name|fatal_with_file
argument_list|(
literal|"premature eof in data relocation of "
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
name|md_swapin_reloc
argument_list|(
name|reloc
argument_list|,
name|entry
operator|->
name|header
operator|.
name|a_drsize
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|reloc
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|datarel
operator|=
name|reloc
expr_stmt|;
name|entry
operator|->
name|ndatarel
operator|=
name|entry
operator|->
name|header
operator|.
name|a_drsize
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|reloc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read in the symbols of all input files.  */
end_comment

begin_decl_stmt
name|void
name|read_file_symbols
argument_list|()
decl_stmt|,
name|read_entry_symbols
argument_list|()
decl_stmt|,
name|read_entry_strings
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|enter_file_symbols
argument_list|()
decl_stmt|,
name|enter_global_ref
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|load_symbols
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|trace_files
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Loading symbols:\n\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|number_of_files
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|struct
name|file_entry
modifier|*
name|entry
init|=
operator|&
name|file_table
index|[
name|i
index|]
decl_stmt|;
name|read_file_symbols
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|trace_files
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * If ENTRY is a rel file, read its symbol and string sections into core. If  * it is a library, search it and load the appropriate members (which means  * calling this function recursively on those members).  */
end_comment

begin_function
name|void
name|read_file_symbols
parameter_list|(
name|entry
parameter_list|)
specifier|register
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
block|{
specifier|register
name|int
name|desc
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
name|struct
name|exec
name|hdr
decl_stmt|;
name|desc
operator|=
name|file_open
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|len
operator|=
name|read
argument_list|(
name|desc
argument_list|,
operator|&
name|hdr
argument_list|,
sizeof|sizeof
name|hdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
sizeof|sizeof
name|hdr
condition|)
name|fatal_with_file
argument_list|(
literal|"failure reading header of "
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|md_swapin_exec_hdr
argument_list|(
operator|&
name|hdr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|N_BADMAG
argument_list|(
name|hdr
argument_list|)
condition|)
block|{
if|if
condition|(
name|N_IS_DYNAMIC
argument_list|(
name|hdr
argument_list|)
condition|)
block|{
if|if
condition|(
name|relocatable_output
condition|)
block|{
name|fatal_with_file
argument_list|(
literal|"-r and shared objects currently not supported "
argument_list|,
name|entry
argument_list|)
expr_stmt|;
return|return;
block|}
name|entry
operator|->
name|is_dynamic
operator|=
literal|1
expr_stmt|;
name|read_shared_object
argument_list|(
name|desc
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|rrs_add_shobj
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|read_entry_symbols
argument_list|(
name|desc
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|entry
operator|->
name|strings
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|entry
operator|->
name|string_size
argument_list|)
expr_stmt|;
name|read_entry_strings
argument_list|(
name|desc
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|read_entry_relocation
argument_list|(
name|desc
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|enter_file_symbols
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|entry
operator|->
name|strings
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|char
name|armag
index|[
name|SARMAG
index|]
decl_stmt|;
name|lseek
argument_list|(
name|desc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|SARMAG
operator|!=
name|read
argument_list|(
name|desc
argument_list|,
name|armag
argument_list|,
name|SARMAG
argument_list|)
operator|||
name|strncmp
argument_list|(
name|armag
argument_list|,
name|ARMAG
argument_list|,
name|SARMAG
argument_list|)
condition|)
name|fatal_with_file
argument_list|(
literal|"malformed input file (not rel or archive) "
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|entry
operator|->
name|library_flag
operator|=
literal|1
expr_stmt|;
name|search_library
argument_list|(
name|desc
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
name|file_close
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Enter the external symbol defs and refs of ENTRY in the hash table.  */
end_comment

begin_function
name|void
name|enter_file_symbols
parameter_list|(
name|entry
parameter_list|)
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
block|{
name|struct
name|localsymbol
modifier|*
name|lsp
decl_stmt|,
modifier|*
name|lspend
decl_stmt|;
if|if
condition|(
name|trace_files
condition|)
name|prline_file_name
argument_list|(
name|entry
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|lspend
operator|=
name|entry
operator|->
name|symbols
operator|+
name|entry
operator|->
name|nsymbols
expr_stmt|;
for|for
control|(
name|lsp
operator|=
name|entry
operator|->
name|symbols
init|;
name|lsp
operator|<
name|lspend
condition|;
name|lsp
operator|++
control|)
block|{
specifier|register
name|struct
name|nlist
modifier|*
name|p
init|=
operator|&
name|lsp
operator|->
name|nzlist
operator|.
name|nlist
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|n_type
operator|==
operator|(
name|N_SETV
operator||
name|N_EXT
operator|)
condition|)
continue|continue;
comment|/* 		 * Turn magically prefixed symbols into set symbols of 		 * a corresponding type. 		 */
if|if
condition|(
name|set_element_prefixes
operator|&&
name|set_element_prefixed_p
argument_list|(
name|entry
operator|->
name|strings
operator|+
name|lsp
operator|->
name|nzlist
operator|.
name|nz_strx
argument_list|)
condition|)
name|lsp
operator|->
name|nzlist
operator|.
name|nz_type
operator|+=
operator|(
name|N_SETA
operator|-
name|N_ABS
operator|)
expr_stmt|;
if|if
condition|(
name|SET_ELEMENT_P
argument_list|(
name|p
operator|->
name|n_type
argument_list|)
condition|)
block|{
name|set_symbol_count
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|relocatable_output
condition|)
name|enter_global_ref
argument_list|(
name|lsp
argument_list|,
name|p
operator|->
name|n_un
operator|.
name|n_strx
operator|+
name|entry
operator|->
name|strings
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|n_type
operator|==
name|N_WARNING
condition|)
block|{
name|char
modifier|*
name|name
init|=
name|p
operator|->
name|n_un
operator|.
name|n_strx
operator|+
name|entry
operator|->
name|strings
decl_stmt|;
comment|/* Grab the next entry.  */
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|n_type
operator|!=
operator|(
name|N_UNDF
operator||
name|N_EXT
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"Warning symbol found in %s without external reference following."
argument_list|,
name|get_file_name
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|make_executable
operator|=
literal|0
expr_stmt|;
name|p
operator|--
expr_stmt|;
comment|/* Process normally.  */
block|}
else|else
block|{
name|symbol
modifier|*
name|sp
decl_stmt|;
name|char
modifier|*
name|sname
init|=
name|p
operator|->
name|n_un
operator|.
name|n_strx
operator|+
name|entry
operator|->
name|strings
decl_stmt|;
comment|/* Deal with the warning symbol.  */
name|enter_global_ref
argument_list|(
name|lsp
argument_list|,
name|p
operator|->
name|n_un
operator|.
name|n_strx
operator|+
name|entry
operator|->
name|strings
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|sp
operator|=
name|getsym
argument_list|(
name|sname
argument_list|)
expr_stmt|;
name|sp
operator|->
name|warning
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|sp
operator|->
name|warning
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|warning_count
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|n_type
operator|&
name|N_EXT
condition|)
block|{
name|enter_global_ref
argument_list|(
name|lsp
argument_list|,
name|p
operator|->
name|n_un
operator|.
name|n_strx
operator|+
name|entry
operator|->
name|strings
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|n_un
operator|.
name|n_strx
operator|&&
operator|!
operator|(
name|p
operator|->
name|n_type
operator|&
operator|(
name|N_STAB
operator||
name|N_EXT
operator|)
operator|)
operator|&&
operator|!
name|entry
operator|->
name|is_dynamic
condition|)
block|{
if|if
condition|(
operator|(
name|p
operator|->
name|n_un
operator|.
name|n_strx
operator|+
name|entry
operator|->
name|strings
operator|)
index|[
literal|0
index|]
operator|!=
name|LPREFIX
condition|)
name|non_L_local_sym_count
operator|++
expr_stmt|;
name|local_sym_count
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|entry
operator|->
name|is_dynamic
condition|)
name|debugger_sym_count
operator|++
expr_stmt|;
block|}
comment|/* 	 * Count one for the local symbol that we generate, 	 * whose name is the file's name (usually) and whose address 	 * is the start of the file's text. 	 */
if|if
condition|(
operator|!
name|entry
operator|->
name|is_dynamic
condition|)
block|{
name|local_sym_count
operator|++
expr_stmt|;
name|non_L_local_sym_count
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Enter one global symbol in the hash table. LSP points to the `struct  * localsymbol' from the file that describes the global symbol.  NAME is the  * symbol's name. ENTRY is the file entry for the file the symbol comes from.  *   * LSP is put on the chain of all such structs that refer to the same symbol.  * This chain starts in the `refs' for symbols from relocatable objects. A  * backpointer to the global symbol is kept in LSP.  *  * Symbols from shared objects are linked through `dynref'. For such symbols  * that's all we do at this stage, with the exception of the case where the  * symbol is a common. The `referenced' bit is only set for references from  * relocatable objects.  *  */
end_comment

begin_function
name|void
name|enter_global_ref
parameter_list|(
name|lsp
parameter_list|,
name|name
parameter_list|,
name|entry
parameter_list|)
name|struct
name|localsymbol
modifier|*
name|lsp
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
block|{
specifier|register
name|struct
name|nzlist
modifier|*
name|nzp
init|=
operator|&
name|lsp
operator|->
name|nzlist
decl_stmt|;
specifier|register
name|symbol
modifier|*
name|sp
init|=
name|getsym
argument_list|(
name|name
argument_list|)
decl_stmt|;
specifier|register
name|int
name|type
init|=
name|nzp
operator|->
name|nz_type
decl_stmt|;
name|int
name|oldref
init|=
name|sp
operator|->
name|referenced
decl_stmt|;
name|int
name|olddef
init|=
name|sp
operator|->
name|defined
decl_stmt|;
name|int
name|com
init|=
name|sp
operator|->
name|defined
operator|&&
name|sp
operator|->
name|max_common_size
decl_stmt|;
if|if
condition|(
name|type
operator|==
operator|(
name|N_INDR
operator||
name|N_EXT
operator|)
condition|)
block|{
name|sp
operator|->
name|alias
operator|=
name|getsym
argument_list|(
name|entry
operator|->
name|strings
operator|+
operator|(
name|lsp
operator|+
literal|1
operator|)
operator|->
name|nzlist
operator|.
name|nz_strx
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|sp
operator|->
name|alias
condition|)
block|{
name|error
argument_list|(
literal|"%s: %s is alias for itself"
argument_list|,
name|get_file_name
argument_list|(
name|entry
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Rewrite symbol as global text symbol with value 0 */
name|lsp
operator|->
name|nzlist
operator|.
name|nz_type
operator|=
name|N_TEXT
operator||
name|N_EXT
expr_stmt|;
name|lsp
operator|->
name|nzlist
operator|.
name|nz_value
operator|=
literal|0
expr_stmt|;
name|make_executable
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|global_alias_count
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|entry
operator|->
name|is_dynamic
condition|)
block|{
name|lsp
operator|->
name|next
operator|=
name|sp
operator|->
name|sorefs
expr_stmt|;
name|sp
operator|->
name|sorefs
operator|=
name|lsp
expr_stmt|;
comment|/* 		 * Handle commons from shared objects: 		 *   1) If symbol hitherto undefined, turn it into a common. 		 *   2) If symbol already common, update size if necessary. 		 */
comment|/*XXX - look at case where commons are only in shared objects */
if|if
condition|(
name|type
operator|==
operator|(
name|N_UNDF
operator||
name|N_EXT
operator|)
operator|&&
name|nzp
operator|->
name|nz_value
condition|)
block|{
if|if
condition|(
operator|!
name|olddef
condition|)
block|{
if|if
condition|(
name|oldref
condition|)
name|undefined_global_sym_count
operator|--
expr_stmt|;
name|common_defined_global_count
operator|++
expr_stmt|;
name|sp
operator|->
name|max_common_size
operator|=
name|nzp
operator|->
name|nz_value
expr_stmt|;
name|sp
operator|->
name|defined
operator|=
name|N_UNDF
operator||
name|N_EXT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|com
operator|&&
name|sp
operator|->
name|max_common_size
operator|<
name|nzp
operator|->
name|nz_value
condition|)
block|{
name|sp
operator|->
name|max_common_size
operator|=
name|nzp
operator|->
name|nz_value
expr_stmt|;
block|}
block|}
comment|/* 		 * Handle size information in shared objects. 		 */
if|if
condition|(
name|nzp
operator|->
name|nz_size
operator|>
name|sp
operator|->
name|size
condition|)
name|sp
operator|->
name|size
operator|=
name|nzp
operator|->
name|nz_size
expr_stmt|;
name|lsp
operator|->
name|symbol
operator|=
name|sp
expr_stmt|;
return|return;
block|}
name|lsp
operator|->
name|next
operator|=
name|sp
operator|->
name|refs
expr_stmt|;
name|sp
operator|->
name|refs
operator|=
name|lsp
expr_stmt|;
name|lsp
operator|->
name|symbol
operator|=
name|sp
expr_stmt|;
name|sp
operator|->
name|referenced
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|dynamic_symbol
operator|||
name|sp
operator|==
name|got_symbol
condition|)
block|{
if|if
condition|(
name|type
operator|!=
operator|(
name|N_UNDF
operator||
name|N_EXT
operator|)
operator|&&
operator|!
name|entry
operator|->
name|just_syms_flag
condition|)
name|fatal
argument_list|(
literal|"Linker reserved symbol %s defined as type %x "
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|N_SIZE
if|if
condition|(
name|type
operator|==
operator|(
name|N_SIZE
operator||
name|N_EXT
operator|)
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|size
operator|<
name|nzp
operator|->
name|nz_value
condition|)
name|sp
operator|->
name|size
operator|=
name|nzp
operator|->
name|nz_value
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
name|type
operator|!=
operator|(
name|N_UNDF
operator||
name|N_EXT
operator|)
operator|||
name|nzp
operator|->
name|nz_value
condition|)
block|{
comment|/* 		 * Set `->defined' here, so commons and undefined globals 		 * can be counted correctly. 		 */
if|if
condition|(
operator|!
name|sp
operator|->
name|defined
operator|||
name|sp
operator|->
name|defined
operator|==
operator|(
name|N_UNDF
operator||
name|N_EXT
operator|)
condition|)
name|sp
operator|->
name|defined
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|oldref
operator|&&
operator|!
name|olddef
condition|)
comment|/* 			 * It used to be undefined and we're defining it. 			 */
name|undefined_global_sym_count
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|olddef
operator|&&
name|type
operator|==
operator|(
name|N_UNDF
operator||
name|N_EXT
operator|)
operator|&&
name|nzp
operator|->
name|nz_value
condition|)
block|{
comment|/* 			 * First definition and it's common. 			 */
name|common_defined_global_count
operator|++
expr_stmt|;
name|sp
operator|->
name|max_common_size
operator|=
name|nzp
operator|->
name|nz_value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|com
operator|&&
name|type
operator|!=
operator|(
name|N_UNDF
operator||
name|N_EXT
operator|)
condition|)
block|{
comment|/* 			 * It used to be common and we're defining 			 * it as something else. 			 */
name|common_defined_global_count
operator|--
expr_stmt|;
name|sp
operator|->
name|max_common_size
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|com
operator|&&
name|type
operator|==
operator|(
name|N_UNDF
operator||
name|N_EXT
operator|)
operator|&&
name|sp
operator|->
name|max_common_size
operator|<
name|nzp
operator|->
name|nz_value
condition|)
comment|/* 			 * It used to be common and this is a new common entry 			 * to which we need to pay attention. 			 */
name|sp
operator|->
name|max_common_size
operator|=
name|nzp
operator|->
name|nz_value
expr_stmt|;
if|if
condition|(
name|SET_ELEMENT_P
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
operator|!
name|olddef
operator|||
name|com
operator|)
condition|)
name|set_vector_count
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|oldref
condition|)
name|undefined_global_sym_count
operator|++
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|end_symbol
operator|&&
name|entry
operator|->
name|just_syms_flag
operator|&&
operator|!
name|T_flag_specified
condition|)
name|text_start
operator|=
name|nzp
operator|->
name|nz_value
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|trace
condition|)
block|{
specifier|register
name|char
modifier|*
name|reftype
decl_stmt|;
switch|switch
condition|(
name|type
operator|&
name|N_TYPE
condition|)
block|{
case|case
name|N_UNDF
case|:
name|reftype
operator|=
name|nzp
operator|->
name|nz_value
condition|?
literal|"defined as common"
else|:
literal|"referenced"
expr_stmt|;
break|break;
case|case
name|N_ABS
case|:
name|reftype
operator|=
literal|"defined as absolute"
expr_stmt|;
break|break;
case|case
name|N_TEXT
case|:
name|reftype
operator|=
literal|"defined in text section"
expr_stmt|;
break|break;
case|case
name|N_DATA
case|:
name|reftype
operator|=
literal|"defined in data section"
expr_stmt|;
break|break;
case|case
name|N_BSS
case|:
name|reftype
operator|=
literal|"defined in BSS section"
expr_stmt|;
break|break;
default|default:
name|reftype
operator|=
literal|"I don't know this type"
expr_stmt|;
break|break;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"symbol %s %s in "
argument_list|,
name|sp
operator|->
name|name
argument_list|,
name|reftype
argument_list|)
expr_stmt|;
name|print_file_name
argument_list|(
name|entry
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * This return 0 if the given file entry's symbol table does *not* contain  * the nlist point entry, and it returns the files entry pointer (cast to  * unsigned long) if it does.  */
end_comment

begin_function
name|unsigned
name|long
name|contains_symbol
parameter_list|(
name|entry
parameter_list|,
name|np
parameter_list|)
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
specifier|register
name|struct
name|nlist
modifier|*
name|np
decl_stmt|;
block|{
if|if
condition|(
name|np
operator|>=
operator|&
name|entry
operator|->
name|symbols
operator|->
name|nzlist
operator|.
name|nlist
operator|&&
name|np
operator|<
operator|&
operator|(
name|entry
operator|->
name|symbols
operator|+
name|entry
operator|->
name|nsymbols
operator|)
operator|->
name|nzlist
operator|.
name|nlist
condition|)
return|return
operator|(
name|unsigned
name|long
operator|)
name|entry
return|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|void
name|consider_file_section_lengths
argument_list|()
decl_stmt|,
name|relocate_file_addresses
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|consider_relocation
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * Having entered all the global symbols and found the sizes of sections of  * all files to be linked, make all appropriate deductions from this data.  *   * We propagate global symbol values from definitions to references. We compute  * the layout of the output file and where each input file's contents fit  * into it.  *   * This is now done in several stages.  *  * 1) All global symbols are examined for definitions in relocatable (.o)  *    files. The symbols' type is set according to the definition found,  *    but its value can not yet be determined. In stead, we keep a pointer  *    to the file entry's localsymbol that bequeathed the global symbol with  *    its definition. Also, multiple (incompatible) definitions are checked  *    for in this pass. If no definition comes forward, the set of local  *    symbols originating from shared objects is searched for a definition.  *  * 2) Then the relocation information of each relocatable file is examined  *    for for possible contributions to the RRS section.  *  * 3) When this is done, the sizes and start addresses are set of all segments  *    that will appear in the output file (including the RRS segment).  *  * 4) Finally, all symbols are relocated according according to the start  *    of the entry they are part of. Then global symbols are assigned their  *    final values. Also, space for commons and imported data are allocated  *    during this pass, if the link mode in effect so demands.  *  */
end_comment

begin_decl_stmt
name|void
name|digest_pass1
argument_list|()
decl_stmt|,
name|digest_pass2
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|digest_symbols
parameter_list|()
block|{
if|if
condition|(
name|trace_files
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Digesting symbol information:\n\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|relocatable_output
condition|)
block|{
comment|/* 		 * The set sector size is the number of set elements + a word 		 * for each symbol for the length word at the beginning of 		 * the vector, plus a word for each symbol for a zero at the 		 * end of the vector (for incremental linking). 		 */
name|set_sect_size
operator|=
operator|(
literal|2
operator|*
name|set_symbol_count
operator|+
name|set_vector_count
operator|)
operator|*
expr|sizeof
operator|(
name|unsigned
name|long
operator|)
expr_stmt|;
name|set_vectors
operator|=
operator|(
name|unsigned
name|long
operator|*
operator|)
name|xmalloc
argument_list|(
name|set_sect_size
argument_list|)
expr_stmt|;
name|setv_fill_count
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Pass 1: check and define symbols */
name|defined_global_sym_count
operator|=
literal|0
expr_stmt|;
name|digest_pass1
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|relocatable_output
condition|)
block|{
name|each_full_file
argument_list|(
name|consider_relocation
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Text */
name|each_full_file
argument_list|(
name|consider_relocation
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Data */
block|}
comment|/* 	 * Compute total size of sections. 	 * RRS data is the first output data section, RRS text is the last 	 * text section. Thus, DATA_START is calculated from RRS_DATA_START 	 * and RRS_DATA_SIZE, while RRS_TEXT_START is derived from TEXT_START 	 * and TEXT_SIZE. 	 */
name|consider_rrs_section_lengths
argument_list|()
expr_stmt|;
name|each_full_file
argument_list|(
name|consider_file_section_lengths
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rrs_text_start
operator|=
name|text_start
operator|+
name|text_size
expr_stmt|;
name|text_size
operator|+=
name|rrs_text_size
expr_stmt|;
name|data_size
operator|+=
name|rrs_data_size
expr_stmt|;
comment|/* 	 * If necessary, pad text section to full page in the file. Include 	 * the padding in the text segment size. 	 */
if|if
condition|(
name|magic
operator|==
name|ZMAGIC
condition|)
block|{
name|int
name|text_end
init|=
name|text_size
operator|+
name|N_TXTOFF
argument_list|(
name|outheader
argument_list|)
decl_stmt|;
name|text_pad
operator|=
name|PALIGN
argument_list|(
name|text_end
argument_list|,
name|page_size
argument_list|)
operator|-
name|text_end
expr_stmt|;
name|text_size
operator|+=
name|text_pad
expr_stmt|;
block|}
name|outheader
operator|.
name|a_text
operator|=
name|text_size
expr_stmt|;
comment|/* 	 * Make the data segment address start in memory on a suitable 	 * boundary. 	 */
if|if
condition|(
operator|!
name|Tdata_flag_specified
condition|)
name|rrs_data_start
operator|=
name|text_start
operator|+
name|DATA_START
argument_list|(
name|outheader
argument_list|)
operator|-
name|TEXT_START
argument_list|(
name|outheader
argument_list|)
expr_stmt|;
name|data_start
operator|=
name|rrs_data_start
operator|+
name|rrs_data_size
expr_stmt|;
if|if
condition|(
operator|!
name|relocatable_output
condition|)
block|{
name|set_sect_start
operator|=
name|rrs_data_start
operator|+
name|data_size
expr_stmt|;
name|data_size
operator|+=
name|set_sect_size
expr_stmt|;
block|}
name|bss_start
operator|=
name|rrs_data_start
operator|+
name|data_size
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"textstart = %#x, textsize = %#x, rrs_text_start = %#x, rrs_text_size %#x\n"
argument_list|,
name|text_start
argument_list|,
name|text_size
argument_list|,
name|rrs_text_start
argument_list|,
name|rrs_text_size
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"datastart = %#x, datasize = %#x, rrs_data_start %#x, rrs_data_size %#x\n"
argument_list|,
name|data_start
argument_list|,
name|data_size
argument_list|,
name|rrs_data_start
argument_list|,
name|rrs_data_size
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"bssstart = %#x, bsssize = %#x\n"
argument_list|,
name|bss_start
argument_list|,
name|bss_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Compute start addresses of each file's sections and symbols.  */
name|each_full_file
argument_list|(
name|relocate_file_addresses
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|relocate_rrs_addresses
argument_list|()
expr_stmt|;
comment|/* Pass 2: assign values to symbols */
name|digest_pass2
argument_list|()
expr_stmt|;
if|if
condition|(
name|end_symbol
condition|)
block|{
comment|/* These are null if -r.  */
name|etext_symbol
operator|->
name|value
operator|=
name|text_start
operator|+
name|text_size
operator|-
name|text_pad
expr_stmt|;
name|edata_symbol
operator|->
name|value
operator|=
name|rrs_data_start
operator|+
name|data_size
expr_stmt|;
name|end_symbol
operator|->
name|value
operator|=
name|rrs_data_start
operator|+
name|data_size
operator|+
name|bss_size
expr_stmt|;
block|}
comment|/* 	 * Figure the data_pad now, so that it overlaps with the bss 	 * addresses. 	 */
if|if
condition|(
name|specified_data_size
operator|&&
name|specified_data_size
operator|>
name|data_size
condition|)
name|data_pad
operator|=
name|specified_data_size
operator|-
name|data_size
expr_stmt|;
if|if
condition|(
name|magic
operator|==
name|ZMAGIC
condition|)
name|data_pad
operator|=
name|PALIGN
argument_list|(
name|data_pad
operator|+
name|data_size
argument_list|,
name|page_size
argument_list|)
operator|-
name|data_size
expr_stmt|;
name|bss_size
operator|-=
name|data_pad
expr_stmt|;
if|if
condition|(
name|bss_size
operator|<
literal|0
condition|)
name|bss_size
operator|=
literal|0
expr_stmt|;
name|data_size
operator|+=
name|data_pad
expr_stmt|;
block|}
end_function

begin_function
name|void
name|digest_pass1
parameter_list|()
block|{
comment|/* 	 * Now, for each symbol, verify that it is defined globally at most 	 * once within relocatable files (except when building a shared lib). 	 * and set the `defined' field if there is a definition. 	 * 	 * Then check the shared object symbol chain for any remaining 	 * undefined symbols. Set the `so_defined' field for any 	 * definition find this way. 	 */
name|FOR_EACH_SYMBOL
argument_list|(
argument|i
argument_list|,
argument|sp
argument_list|)
block|{
name|struct
name|localsymbol
modifier|*
name|lsp
decl_stmt|;
name|int
name|defs
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|sp
operator|->
name|referenced
condition|)
block|{
if|#
directive|if
literal|0
comment|/* Check for undefined symbols in shared objects */
block|int type; 			for (lsp = sp->sorefs; lsp; lsp = lsp->next) { 				type = lsp->nzlist.nlist.n_type; 				if ((type& N_EXT)&& type != (N_UNDF | N_EXT)) 					break; 			} 			if ((type& N_EXT)&& type == (N_UNDF | N_EXT)) 				undefined_shobj_sym_count++;
endif|#
directive|endif
comment|/* Superfluous symbol from shared object */
continue|continue;
block|}
if|if
condition|(
name|sp
operator|==
name|got_symbol
operator|||
name|sp
operator|==
name|dynamic_symbol
condition|)
continue|continue;
for|for
control|(
name|lsp
operator|=
name|sp
operator|->
name|refs
init|;
name|lsp
condition|;
name|lsp
operator|=
name|lsp
operator|->
name|next
control|)
block|{
specifier|register
name|struct
name|nlist
modifier|*
name|p
init|=
operator|&
name|lsp
operator|->
name|nzlist
operator|.
name|nlist
decl_stmt|;
specifier|register
name|int
name|type
init|=
name|p
operator|->
name|n_type
decl_stmt|;
if|if
condition|(
name|SET_ELEMENT_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|relocatable_output
condition|)
name|fatal
argument_list|(
literal|"internal error: global ref to set el %s with -r"
argument_list|,
name|sp
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|defs
operator|++
condition|)
block|{
name|sp
operator|->
name|defined
operator|=
name|N_SETV
operator||
name|N_EXT
expr_stmt|;
name|sp
operator|->
name|value
operator|=
name|setv_fill_count
operator|++
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|sp
operator|->
name|defined
operator|&
name|N_TYPE
operator|)
operator|!=
name|N_SETV
condition|)
block|{
name|sp
operator|->
name|multiply_defined
operator|=
literal|1
expr_stmt|;
name|multiple_def_count
operator|++
expr_stmt|;
block|}
comment|/* Keep count and remember symbol */
name|sp
operator|->
name|setv_count
operator|++
expr_stmt|;
name|set_vectors
index|[
name|setv_fill_count
operator|++
index|]
operator|=
operator|(
name|long
operator|)
name|p
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|type
operator|&
name|N_EXT
operator|)
operator|&&
name|type
operator|!=
operator|(
name|N_UNDF
operator||
name|N_EXT
operator|)
operator|&&
operator|(
name|type
operator|&
name|N_TYPE
operator|)
operator|!=
name|N_FN
operator|&&
operator|(
name|type
operator|&
name|N_TYPE
operator|)
operator|!=
name|N_SIZE
condition|)
block|{
comment|/* non-common definition */
if|if
condition|(
name|defs
operator|++
operator|&&
name|sp
operator|->
name|value
operator|!=
name|p
operator|->
name|n_value
operator|&&
name|entry_symbol
condition|)
block|{
name|sp
operator|->
name|multiply_defined
operator|=
literal|1
expr_stmt|;
name|multiple_def_count
operator|++
expr_stmt|;
block|}
name|sp
operator|->
name|def_nlist
operator|=
name|p
expr_stmt|;
name|sp
operator|->
name|defined
operator|=
name|type
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sp
operator|->
name|defined
condition|)
block|{
if|if
condition|(
operator|(
name|sp
operator|->
name|defined
operator|&
name|N_TYPE
operator|)
operator|==
name|N_SETV
condition|)
comment|/* Allocate zero entry in set vector */
name|setv_fill_count
operator|++
expr_stmt|;
name|defined_global_sym_count
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|relocatable_output
condition|)
comment|/* We're done */
continue|continue;
comment|/* 		 * Still undefined, search the shared object symbols for a 		 * definition. This symbol must go into the RRS. 		 */
if|if
condition|(
name|building_shared_object
condition|)
block|{
comment|/* Just punt for now */
name|undefined_global_sym_count
operator|--
expr_stmt|;
continue|continue;
block|}
for|for
control|(
name|lsp
operator|=
name|sp
operator|->
name|sorefs
init|;
name|lsp
condition|;
name|lsp
operator|=
name|lsp
operator|->
name|next
control|)
block|{
specifier|register
name|struct
name|nlist
modifier|*
name|p
init|=
operator|&
name|lsp
operator|->
name|nzlist
operator|.
name|nlist
decl_stmt|;
specifier|register
name|int
name|type
init|=
name|p
operator|->
name|n_type
decl_stmt|;
if|if
condition|(
operator|(
name|type
operator|&
name|N_EXT
operator|)
operator|&&
name|type
operator|!=
operator|(
name|N_UNDF
operator||
name|N_EXT
operator|)
operator|&&
operator|(
name|type
operator|&
name|N_TYPE
operator|)
operator|!=
name|N_FN
condition|)
block|{
comment|/* non-common definition */
name|sp
operator|->
name|def_nlist
operator|=
name|p
expr_stmt|;
name|sp
operator|->
name|so_defined
operator|=
name|type
expr_stmt|;
name|undefined_global_sym_count
operator|--
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"shr: %s gets defined to %x with value %x\n"
argument_list|,
name|sp
operator|->
name|name
argument_list|,
name|type
argument_list|,
name|sp
operator|->
name|value
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
block|}
block|}
name|END_EACH_SYMBOL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|digest_pass2
parameter_list|()
block|{
comment|/* 	 * Assign each symbol its final value. 	 * If not -r'ing, allocate common symbols in the BSS section. 	 */
name|FOR_EACH_SYMBOL
argument_list|(
argument|i
argument_list|,
argument|sp
argument_list|)
block|{
name|int
name|size
decl_stmt|;
name|int
name|align
init|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sp
operator|->
name|referenced
condition|)
continue|continue;
if|if
condition|(
operator|(
name|sp
operator|->
name|defined
operator|&
name|N_TYPE
operator|)
operator|==
name|N_SETV
condition|)
block|{
comment|/* 			 * Set length word at front of vector and zero byte 			 * at end. Reverse the vector itself to put it in 			 * file order. 			 */
name|unsigned
name|long
name|i
decl_stmt|,
name|tmp
decl_stmt|;
name|unsigned
name|long
name|length_word_index
init|=
name|sp
operator|->
name|value
operator|/
sizeof|sizeof
argument_list|(
name|long
argument_list|)
decl_stmt|;
comment|/* Relocate symbol value */
name|sp
operator|->
name|value
operator|+=
name|set_sect_start
expr_stmt|;
name|set_vectors
index|[
name|length_word_index
index|]
operator|=
name|sp
operator|->
name|setv_count
expr_stmt|;
comment|/* 			 * Relocate vector to final address. 			 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sp
operator|->
name|setv_count
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|nlist
modifier|*
name|p
init|=
operator|(
expr|struct
name|nlist
operator|*
operator|)
name|set_vectors
index|[
literal|1
operator|+
name|i
operator|+
name|length_word_index
index|]
decl_stmt|;
name|set_vectors
index|[
literal|1
operator|+
name|i
operator|+
name|length_word_index
index|]
operator|=
name|p
operator|->
name|n_value
expr_stmt|;
block|}
comment|/* 			 * Reverse the vector. 			 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
operator|(
name|sp
operator|->
name|setv_count
operator|-
literal|1
operator|)
operator|/
literal|2
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|tmp
operator|=
name|set_vectors
index|[
name|length_word_index
operator|+
name|i
index|]
expr_stmt|;
name|set_vectors
index|[
name|length_word_index
operator|+
name|i
index|]
operator|=
name|set_vectors
index|[
name|length_word_index
operator|+
name|sp
operator|->
name|setv_count
operator|+
literal|1
operator|-
name|i
index|]
expr_stmt|;
name|set_vectors
index|[
name|length_word_index
operator|+
name|sp
operator|->
name|setv_count
operator|+
literal|1
operator|-
name|i
index|]
operator|=
name|tmp
expr_stmt|;
block|}
comment|/* Clear terminating entry */
name|set_vectors
index|[
name|length_word_index
operator|+
name|sp
operator|->
name|setv_count
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|sp
operator|->
name|defined
operator|&&
name|sp
operator|->
name|def_nlist
operator|&&
operator|(
operator|(
name|sp
operator|->
name|defined
operator|&
operator|~
name|N_EXT
operator|)
operator|!=
name|N_SETV
operator|)
condition|)
name|sp
operator|->
name|value
operator|=
name|sp
operator|->
name|def_nlist
operator|->
name|n_value
expr_stmt|;
if|if
condition|(
name|building_shared_object
operator|&&
operator|!
operator|(
name|link_mode
operator|&
name|SYMBOLIC
operator|)
condition|)
comment|/* No common allocation in shared objects */
continue|continue;
if|if
condition|(
operator|(
name|size
operator|=
name|sp
operator|->
name|max_common_size
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * It's a common. 			 */
if|if
condition|(
name|sp
operator|->
name|defined
operator|!=
operator|(
name|N_UNDF
operator|+
name|N_EXT
operator|)
condition|)
name|fatal
argument_list|(
literal|"%s: common isn't"
argument_list|,
name|sp
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|size
operator|=
name|sp
operator|->
name|size
operator|)
operator|!=
literal|0
operator|&&
name|sp
operator|->
name|defined
operator|==
name|N_SIZE
condition|)
block|{
comment|/* 			 * It's data from shared object with size info. 			 */
if|if
condition|(
operator|!
name|sp
operator|->
name|so_defined
condition|)
name|fatal
argument_list|(
literal|"%s: Bogus N_SIZE item"
argument_list|,
name|sp
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* 			 * It's neither 			 */
continue|continue;
if|if
condition|(
name|relocatable_output
operator|&&
operator|!
name|force_common_definition
condition|)
block|{
name|sp
operator|->
name|defined
operator|=
literal|0
expr_stmt|;
name|undefined_global_sym_count
operator|++
expr_stmt|;
name|defined_global_sym_count
operator|--
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Round up to nearest sizeof (int). I don't know whether 		 * this is necessary or not (given that alignment is taken 		 * care of later), but it's traditional, so I'll leave it in. 		 * Note that if this size alignment is ever removed, ALIGN 		 * above will have to be initialized to 1 instead of sizeof 		 * (int). 		 */
name|size
operator|=
name|PALIGN
argument_list|(
name|size
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|size
operator|&
name|align
operator|)
condition|)
name|align
operator|<<=
literal|1
expr_stmt|;
name|align
operator|=
name|align
operator|>
name|MAX_ALIGNMENT
condition|?
name|MAX_ALIGNMENT
else|:
name|align
expr_stmt|;
name|bss_size
operator|=
name|PALIGN
argument_list|(
name|bss_size
operator|+
name|data_size
operator|+
name|rrs_data_start
argument_list|,
name|align
argument_list|)
operator|-
operator|(
name|data_size
operator|+
name|rrs_data_start
operator|)
expr_stmt|;
name|sp
operator|->
name|value
operator|=
name|rrs_data_start
operator|+
name|data_size
operator|+
name|bss_size
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|defined
operator|==
operator|(
name|N_UNDF
operator||
name|N_EXT
operator|)
condition|)
name|sp
operator|->
name|defined
operator|=
name|N_BSS
operator||
name|N_EXT
expr_stmt|;
else|else
block|{
name|sp
operator|->
name|so_defined
operator|=
literal|0
expr_stmt|;
name|defined_global_sym_count
operator|++
expr_stmt|;
block|}
name|bss_size
operator|+=
name|size
expr_stmt|;
if|if
condition|(
name|write_map
condition|)
name|printf
argument_list|(
literal|"Allocating %s %s: %x at %x\n"
argument_list|,
name|sp
operator|->
name|defined
operator|==
operator|(
name|N_BSS
operator||
name|N_EXT
operator|)
condition|?
literal|"common"
else|:
literal|"data"
argument_list|,
name|sp
operator|->
name|name
argument_list|,
name|size
argument_list|,
name|sp
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
name|END_EACH_SYMBOL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Scan relocation info in ENTRY for contributions to the dynamic section of  * the output file.  */
end_comment

begin_function
name|void
name|consider_relocation
parameter_list|(
name|entry
parameter_list|,
name|dataseg
parameter_list|)
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
name|int
name|dataseg
decl_stmt|;
block|{
name|struct
name|relocation_info
modifier|*
name|reloc
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|struct
name|localsymbol
modifier|*
name|lsp
decl_stmt|;
name|symbol
modifier|*
name|sp
decl_stmt|;
if|if
condition|(
name|dataseg
operator|==
literal|0
condition|)
block|{
comment|/* Text relocations */
name|reloc
operator|=
name|entry
operator|->
name|textrel
expr_stmt|;
name|end
operator|=
name|entry
operator|->
name|textrel
operator|+
name|entry
operator|->
name|ntextrel
expr_stmt|;
block|}
else|else
block|{
comment|/* Data relocations */
name|reloc
operator|=
name|entry
operator|->
name|datarel
expr_stmt|;
name|end
operator|=
name|entry
operator|->
name|datarel
operator|+
name|entry
operator|->
name|ndatarel
expr_stmt|;
block|}
for|for
control|(
init|;
name|reloc
operator|<
name|end
condition|;
name|reloc
operator|++
control|)
block|{
comment|/* 		 * First, do the PIC specific relocs. 		 * r_relative and r_copy should not occur at this point 		 * (we do output them). The others break down to these 		 * combinations: 		 * 		 * jmptab:	extern:		needs jmp slot 		 *		!extern:	"intersegment" jump/call, 		 *				should get resolved in output 		 * 		 * baserel:	extern:		need GOT entry 		 *		!extern:	may need GOT entry, 		 *				machine dependent 		 * 		 * baserel's always refer to symbol through `r_symbolnum' 		 * whether extern or not. Internal baserels refer to statics 		 * that must be accessed either *through* the GOT table like 		 * global data, or by means of an offset from the GOT table. 		 * The macro RELOC_STATICS_THROUGH_GOT_P() determines which 		 * applies, since this is a machine (compiler?) dependent 		 * addressing mode. 		 */
if|if
condition|(
name|RELOC_JMPTAB_P
argument_list|(
name|reloc
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|RELOC_EXTERN_P
argument_list|(
name|reloc
argument_list|)
condition|)
continue|continue;
name|lsp
operator|=
operator|&
name|entry
operator|->
name|symbols
index|[
name|reloc
operator|->
name|r_symbolnum
index|]
expr_stmt|;
name|sp
operator|=
name|lsp
operator|->
name|symbol
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|alias
condition|)
name|sp
operator|=
name|sp
operator|->
name|alias
expr_stmt|;
name|alloc_rrs_jmpslot
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|RELOC_BASEREL_P
argument_list|(
name|reloc
argument_list|)
condition|)
block|{
name|lsp
operator|=
operator|&
name|entry
operator|->
name|symbols
index|[
name|reloc
operator|->
name|r_symbolnum
index|]
expr_stmt|;
name|alloc_rrs_gotslot
argument_list|(
name|reloc
argument_list|,
name|lsp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|RELOC_EXTERN_P
argument_list|(
name|reloc
argument_list|)
condition|)
block|{
comment|/* 			 * Non-PIC relocations. 			 * If the definition comes from a shared object 			 * we need a relocation entry in RRS. 			 * 			 * If the .so definition is N_TEXT a jmpslot is 			 * allocated. 			 * 			 * If it is N_DATA we allocate an address in BSS (?) 			 * and arrange for the data to be copied at run-time. 			 * The symbol is temporarily marked with N_SIZE in 			 * the `defined' field, so we know what to do in 			 * pass2() and during actual relocation. We convert 			 * the type back to something real again when writing 			 * out the symbols. 			 *  			 */
name|lsp
operator|=
operator|&
name|entry
operator|->
name|symbols
index|[
name|reloc
operator|->
name|r_symbolnum
index|]
expr_stmt|;
name|sp
operator|=
name|lsp
operator|->
name|symbol
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
name|fatal_with_file
argument_list|(
literal|"internal error, sp==NULL"
argument_list|,
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|alias
condition|)
name|sp
operator|=
name|sp
operator|->
name|alias
expr_stmt|;
comment|/* 			 * Skip refs to _GLOBAL_OFFSET_TABLE_ and __DYNAMIC 			 */
if|if
condition|(
name|sp
operator|==
name|got_symbol
condition|)
block|{
if|if
condition|(
operator|!
name|CHECK_GOT_RELOC
argument_list|(
name|reloc
argument_list|)
condition|)
name|fatal_with_file
argument_list|(
literal|"Unexpected relocation type "
argument_list|,
name|entry
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 			 * This symbol gives rise to a RRS entry 			 */
if|if
condition|(
name|building_shared_object
condition|)
block|{
name|alloc_rrs_reloc
argument_list|(
name|sp
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 			 * Only allocate an alias for function calls. Use 			 * sp->size here as a heuristic to discriminate 			 * between function definitions and data residing 			 * in the text segment. 			 * NOTE THAT THE COMPILER MUST NOT GENERATE ".size" 			 * DIRECTIVES FOR FUNCTIONS. 			 * In the future we might go for ".type" directives. 			 */
if|if
condition|(
name|force_alias_definition
operator|&&
name|sp
operator|->
name|size
operator|==
literal|0
operator|&&
name|sp
operator|->
name|so_defined
operator|==
name|N_TEXT
operator|+
name|N_EXT
condition|)
block|{
comment|/* Call to shared library procedure */
name|alloc_rrs_jmpslot
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sp
operator|->
name|size
operator|&&
operator|(
name|sp
operator|->
name|so_defined
operator|==
name|N_DATA
operator|+
name|N_EXT
operator|||
name|sp
operator|->
name|so_defined
operator|==
name|N_TEXT
operator|+
name|N_EXT
operator|)
condition|)
block|{
comment|/* Reference to shared library data */
name|alloc_rrs_cpy_reloc
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|->
name|defined
operator|=
name|N_SIZE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|sp
operator|->
name|defined
operator|&&
name|sp
operator|->
name|max_common_size
operator|==
literal|0
condition|)
name|alloc_rrs_reloc
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Segment relocation. 			 * Prepare an RRS relocation as these are load 			 * address dependent. 			 */
if|if
condition|(
name|building_shared_object
condition|)
block|{
name|alloc_rrs_segment_reloc
argument_list|(
name|reloc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Accumulate the section sizes of input file ENTRY into the section sizes of  * the output file.  */
end_comment

begin_function
name|void
name|consider_file_section_lengths
parameter_list|(
name|entry
parameter_list|)
specifier|register
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
block|{
if|if
condition|(
name|entry
operator|->
name|just_syms_flag
condition|)
return|return;
name|entry
operator|->
name|text_start_address
operator|=
name|text_size
expr_stmt|;
comment|/* If there were any vectors, we need to chop them off */
name|text_size
operator|+=
name|entry
operator|->
name|header
operator|.
name|a_text
expr_stmt|;
name|entry
operator|->
name|data_start_address
operator|=
name|data_size
expr_stmt|;
name|data_size
operator|+=
name|entry
operator|->
name|header
operator|.
name|a_data
expr_stmt|;
name|entry
operator|->
name|bss_start_address
operator|=
name|bss_size
expr_stmt|;
name|bss_size
operator|+=
name|entry
operator|->
name|header
operator|.
name|a_bss
expr_stmt|;
name|text_reloc_size
operator|+=
name|entry
operator|->
name|header
operator|.
name|a_trsize
expr_stmt|;
name|data_reloc_size
operator|+=
name|entry
operator|->
name|header
operator|.
name|a_drsize
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Determine where the sections of ENTRY go into the output file,  * whose total section sizes are already known.  * Also relocate the addresses of the file's local and debugger symbols.  */
end_comment

begin_function
name|void
name|relocate_file_addresses
parameter_list|(
name|entry
parameter_list|)
specifier|register
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
block|{
specifier|register
name|struct
name|localsymbol
modifier|*
name|lsp
decl_stmt|,
modifier|*
name|lspend
decl_stmt|;
name|entry
operator|->
name|text_start_address
operator|+=
name|text_start
expr_stmt|;
comment|/* 	 * Note that `data_start' and `data_size' have not yet been 	 * adjusted for `data_pad'.  If they had been, we would get the wrong 	 * results here. 	 */
name|entry
operator|->
name|data_start_address
operator|+=
name|data_start
expr_stmt|;
name|entry
operator|->
name|bss_start_address
operator|+=
name|bss_start
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"%s: datastart: %#x, bss %#x\n"
argument_list|,
name|get_file_name
argument_list|(
name|entry
argument_list|)
argument_list|,
name|entry
operator|->
name|data_start_address
argument_list|,
name|entry
operator|->
name|bss_start_address
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|lspend
operator|=
name|entry
operator|->
name|symbols
operator|+
name|entry
operator|->
name|nsymbols
expr_stmt|;
for|for
control|(
name|lsp
operator|=
name|entry
operator|->
name|symbols
init|;
name|lsp
operator|<
name|lspend
condition|;
name|lsp
operator|++
control|)
block|{
specifier|register
name|struct
name|nlist
modifier|*
name|p
init|=
operator|&
name|lsp
operator|->
name|nzlist
operator|.
name|nlist
decl_stmt|;
comment|/* 		 * If this belongs to a section, update it 		 * by the section's start address 		 */
specifier|register
name|int
name|type
init|=
name|p
operator|->
name|n_type
operator|&
name|N_TYPE
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|N_TEXT
case|:
case|case
name|N_SETT
case|:
name|p
operator|->
name|n_value
operator|+=
name|entry
operator|->
name|text_start_address
expr_stmt|;
break|break;
case|case
name|N_DATA
case|:
case|case
name|N_SETD
case|:
case|case
name|N_SETV
case|:
comment|/* 			 * A symbol whose value is in the data section is 			 * present in the input file as if the data section 			 * started at an address equal to the length of the 			 * file's text. 			 */
name|p
operator|->
name|n_value
operator|+=
name|entry
operator|->
name|data_start_address
operator|-
name|entry
operator|->
name|header
operator|.
name|a_text
expr_stmt|;
break|break;
case|case
name|N_BSS
case|:
case|case
name|N_SETB
case|:
comment|/* likewise for symbols with value in BSS.  */
name|p
operator|->
name|n_value
operator|+=
name|entry
operator|->
name|bss_start_address
operator|-
name|entry
operator|->
name|header
operator|.
name|a_text
operator|-
name|entry
operator|->
name|header
operator|.
name|a_data
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Write the output file */
end_comment

begin_function
name|void
name|write_output
parameter_list|()
block|{
name|struct
name|stat
name|statbuf
decl_stmt|;
name|int
name|filemode
decl_stmt|;
if|if
condition|(
name|lstat
argument_list|(
name|output_filename
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|S_ISDIR
argument_list|(
name|statbuf
operator|.
name|st_mode
argument_list|)
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|output_filename
argument_list|)
expr_stmt|;
block|}
name|outdesc
operator|=
name|open
argument_list|(
name|output_filename
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|outdesc
operator|<
literal|0
condition|)
name|perror_name
argument_list|(
name|output_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|outdesc
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|<
literal|0
condition|)
name|perror_name
argument_list|(
name|output_filename
argument_list|)
expr_stmt|;
name|filemode
operator|=
name|statbuf
operator|.
name|st_mode
expr_stmt|;
name|chmod
argument_list|(
name|output_filename
argument_list|,
name|filemode
operator|&
operator|~
literal|0111
argument_list|)
expr_stmt|;
comment|/* Output the a.out header.  */
name|write_header
argument_list|()
expr_stmt|;
comment|/* Output the text and data segments, relocating as we go.  */
name|write_text
argument_list|()
expr_stmt|;
name|write_data
argument_list|()
expr_stmt|;
comment|/* Output the merged relocation info, if requested with `-r'.  */
if|if
condition|(
name|relocatable_output
condition|)
name|write_rel
argument_list|()
expr_stmt|;
comment|/* Output the symbol table (both globals and locals).  */
name|write_syms
argument_list|()
expr_stmt|;
comment|/* Output the RSS section */
name|write_rrs
argument_list|()
expr_stmt|;
name|close
argument_list|(
name|outdesc
argument_list|)
expr_stmt|;
if|if
condition|(
name|chmod
argument_list|(
name|output_filename
argument_list|,
name|filemode
operator||
literal|0111
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|perror_name
argument_list|(
name|output_filename
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
name|void
name|modify_location
argument_list|()
decl_stmt|,
name|perform_relocation
argument_list|()
decl_stmt|,
name|copy_text
argument_list|()
decl_stmt|,
name|copy_data
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Total number of symbols to be written in the output file. */
end_comment

begin_decl_stmt
name|int
name|nsyms
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|write_header
parameter_list|()
block|{
name|int
name|flags
init|=
operator|(
name|rrs_section_type
operator|==
name|RRS_FULL
operator|)
condition|?
name|EX_DYNAMIC
else|:
literal|0
decl_stmt|;
name|N_SET_FLAG
argument_list|(
name|outheader
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|outheader
operator|.
name|a_text
operator|=
name|text_size
expr_stmt|;
name|outheader
operator|.
name|a_data
operator|=
name|data_size
expr_stmt|;
name|outheader
operator|.
name|a_bss
operator|=
name|bss_size
expr_stmt|;
name|outheader
operator|.
name|a_entry
operator|=
operator|(
name|entry_symbol
condition|?
name|entry_symbol
operator|->
name|value
else|:
name|text_start
operator|+
name|entry_offset
operator|)
expr_stmt|;
if|if
condition|(
name|strip_symbols
operator|==
name|STRIP_ALL
condition|)
name|nsyms
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|nsyms
operator|=
operator|(
name|defined_global_sym_count
operator|+
name|undefined_global_sym_count
operator|)
expr_stmt|;
if|if
condition|(
name|discard_locals
operator|==
name|DISCARD_L
condition|)
name|nsyms
operator|+=
name|non_L_local_sym_count
expr_stmt|;
elseif|else
if|if
condition|(
name|discard_locals
operator|==
name|DISCARD_NONE
condition|)
name|nsyms
operator|+=
name|local_sym_count
expr_stmt|;
if|if
condition|(
name|relocatable_output
condition|)
comment|/* For each alias we write out two struct nlists */
name|nsyms
operator|+=
name|set_symbol_count
operator|+
name|global_alias_count
expr_stmt|;
if|if
condition|(
name|dynamic_symbol
operator|->
name|referenced
condition|)
name|nsyms
operator|++
operator|,
name|special_sym_count
operator|++
expr_stmt|;
if|if
condition|(
name|got_symbol
operator|->
name|referenced
condition|)
name|nsyms
operator|++
operator|,
name|special_sym_count
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|strip_symbols
operator|==
name|STRIP_NONE
condition|)
name|nsyms
operator|+=
name|debugger_sym_count
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"defined globals: %d, undefined globals %d, locals: %d (non_L: %d), \ debug symbols: %d, special: %d --> nsyms %d\n"
argument_list|,
name|defined_global_sym_count
argument_list|,
name|undefined_global_sym_count
argument_list|,
name|local_sym_count
argument_list|,
name|non_L_local_sym_count
argument_list|,
name|debugger_sym_count
argument_list|,
name|special_sym_count
argument_list|,
name|nsyms
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|outheader
operator|.
name|a_syms
operator|=
name|nsyms
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|relocatable_output
condition|)
block|{
name|outheader
operator|.
name|a_trsize
operator|=
name|text_reloc_size
expr_stmt|;
name|outheader
operator|.
name|a_drsize
operator|=
name|data_reloc_size
expr_stmt|;
block|}
else|else
block|{
name|outheader
operator|.
name|a_trsize
operator|=
literal|0
expr_stmt|;
name|outheader
operator|.
name|a_drsize
operator|=
literal|0
expr_stmt|;
block|}
name|md_swapout_exec_hdr
argument_list|(
operator|&
name|outheader
argument_list|)
expr_stmt|;
name|mywrite
argument_list|(
operator|&
name|outheader
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|exec
argument_list|)
argument_list|,
literal|1
argument_list|,
name|outdesc
argument_list|)
expr_stmt|;
name|md_swapin_exec_hdr
argument_list|(
operator|&
name|outheader
argument_list|)
expr_stmt|;
comment|/* 	 * Output whatever padding is required in the executable file 	 * between the header and the start of the text. 	 */
ifndef|#
directive|ifndef
name|COFF_ENCAPSULATE
name|padfile
argument_list|(
name|N_TXTOFF
argument_list|(
name|outheader
argument_list|)
operator|-
sizeof|sizeof
name|outheader
argument_list|,
name|outdesc
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Relocate the text segment of each input file    and write to the output file.  */
end_comment

begin_function
name|void
name|write_text
parameter_list|()
block|{
if|if
condition|(
name|trace_files
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Copying and relocating text:\n\n"
argument_list|)
expr_stmt|;
name|each_full_file
argument_list|(
name|copy_text
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|file_close
argument_list|()
expr_stmt|;
if|if
condition|(
name|trace_files
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|padfile
argument_list|(
name|text_pad
argument_list|,
name|outdesc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Read the text segment contents of ENTRY, relocate them, and write the  * result to the output file.  If `-r', save the text relocation for later  * reuse.  */
end_comment

begin_function
name|void
name|copy_text
parameter_list|(
name|entry
parameter_list|)
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|bytes
decl_stmt|;
specifier|register
name|int
name|desc
decl_stmt|;
if|if
condition|(
name|trace_files
condition|)
name|prline_file_name
argument_list|(
name|entry
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|desc
operator|=
name|file_open
argument_list|(
name|entry
argument_list|)
expr_stmt|;
comment|/* Allocate space for the file's text section */
name|bytes
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|entry
operator|->
name|header
operator|.
name|a_text
argument_list|)
expr_stmt|;
comment|/* Deal with relocation information however is appropriate */
if|if
condition|(
name|entry
operator|->
name|textrel
operator|==
name|NULL
condition|)
name|fatal_with_file
argument_list|(
literal|"no text relocation of "
argument_list|,
name|entry
argument_list|)
expr_stmt|;
comment|/* Read the text section into core.  */
name|lseek
argument_list|(
name|desc
argument_list|,
name|text_offset
argument_list|(
name|entry
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|header
operator|.
name|a_text
operator|!=
name|read
argument_list|(
name|desc
argument_list|,
name|bytes
argument_list|,
name|entry
operator|->
name|header
operator|.
name|a_text
argument_list|)
condition|)
name|fatal_with_file
argument_list|(
literal|"premature eof in text section of "
argument_list|,
name|entry
argument_list|)
expr_stmt|;
comment|/* Relocate the text according to the text relocation.  */
name|perform_relocation
argument_list|(
name|bytes
argument_list|,
name|entry
operator|->
name|header
operator|.
name|a_text
argument_list|,
name|entry
operator|->
name|textrel
argument_list|,
name|entry
operator|->
name|ntextrel
argument_list|,
name|entry
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Write the relocated text to the output file.  */
name|mywrite
argument_list|(
name|bytes
argument_list|,
literal|1
argument_list|,
name|entry
operator|->
name|header
operator|.
name|a_text
argument_list|,
name|outdesc
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Relocate the data segment of each input file    and write to the output file.  */
end_comment

begin_function
name|void
name|write_data
parameter_list|()
block|{
name|long
name|pos
decl_stmt|;
if|if
condition|(
name|trace_files
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Copying and relocating data:\n\n"
argument_list|)
expr_stmt|;
name|pos
operator|=
name|N_DATOFF
argument_list|(
name|outheader
argument_list|)
operator|+
name|data_start
operator|-
name|rrs_data_start
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|outdesc
argument_list|,
name|pos
argument_list|,
name|L_SET
argument_list|)
operator|!=
name|pos
condition|)
name|fatal
argument_list|(
literal|"write_data: lseek: cant position data offset"
argument_list|)
expr_stmt|;
name|each_full_file
argument_list|(
name|copy_data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|file_close
argument_list|()
expr_stmt|;
comment|/* 	 * Write out the set element vectors.  See digest symbols for 	 * description of length of the set vector section. 	 */
if|if
condition|(
name|set_vector_count
condition|)
block|{
name|swap_longs
argument_list|(
name|set_vectors
argument_list|,
literal|2
operator|*
name|set_symbol_count
operator|+
name|set_vector_count
argument_list|)
expr_stmt|;
name|mywrite
argument_list|(
name|set_vectors
argument_list|,
literal|2
operator|*
name|set_symbol_count
operator|+
name|set_vector_count
argument_list|,
expr|sizeof
operator|(
name|unsigned
name|long
operator|)
argument_list|,
name|outdesc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|trace_files
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|padfile
argument_list|(
name|data_pad
argument_list|,
name|outdesc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Read the data segment contents of ENTRY, relocate them, and write the  * result to the output file. If `-r', save the data relocation for later  * reuse. See comments in `copy_text'.  */
end_comment

begin_function
name|void
name|copy_data
parameter_list|(
name|entry
parameter_list|)
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|bytes
decl_stmt|;
specifier|register
name|int
name|desc
decl_stmt|;
if|if
condition|(
name|trace_files
condition|)
name|prline_file_name
argument_list|(
name|entry
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|desc
operator|=
name|file_open
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|bytes
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|entry
operator|->
name|header
operator|.
name|a_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|datarel
operator|==
name|NULL
condition|)
name|fatal_with_file
argument_list|(
literal|"no data relocation of "
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|desc
argument_list|,
name|text_offset
argument_list|(
name|entry
argument_list|)
operator|+
name|entry
operator|->
name|header
operator|.
name|a_text
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|header
operator|.
name|a_data
operator|!=
name|read
argument_list|(
name|desc
argument_list|,
name|bytes
argument_list|,
name|entry
operator|->
name|header
operator|.
name|a_data
argument_list|)
condition|)
name|fatal_with_file
argument_list|(
literal|"premature eof in data section of "
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|perform_relocation
argument_list|(
name|bytes
argument_list|,
name|entry
operator|->
name|header
operator|.
name|a_data
argument_list|,
name|entry
operator|->
name|datarel
argument_list|,
name|entry
operator|->
name|ndatarel
argument_list|,
name|entry
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mywrite
argument_list|(
name|bytes
argument_list|,
literal|1
argument_list|,
name|entry
operator|->
name|header
operator|.
name|a_data
argument_list|,
name|outdesc
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Relocate ENTRY's text or data section contents. DATA is the address of the  * contents, in core. DATA_SIZE is the length of the contents. PC_RELOCATION  * is the difference between the address of the contents in the output file  * and its address in the input file. RELOC is the address of the  * relocation info, in core. NRELOC says how many there are.  */
end_comment

begin_function
name|void
name|perform_relocation
parameter_list|(
name|data
parameter_list|,
name|data_size
parameter_list|,
name|reloc
parameter_list|,
name|nreloc
parameter_list|,
name|entry
parameter_list|,
name|dataseg
parameter_list|)
name|char
modifier|*
name|data
decl_stmt|;
name|int
name|data_size
decl_stmt|;
name|struct
name|relocation_info
modifier|*
name|reloc
decl_stmt|;
name|int
name|nreloc
decl_stmt|;
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
name|int
name|dataseg
decl_stmt|;
block|{
specifier|register
name|struct
name|relocation_info
modifier|*
name|r
init|=
name|reloc
decl_stmt|;
name|struct
name|relocation_info
modifier|*
name|end
init|=
name|reloc
operator|+
name|nreloc
decl_stmt|;
name|text_relocation
operator|=
name|entry
operator|->
name|text_start_address
expr_stmt|;
name|data_relocation
operator|=
name|entry
operator|->
name|data_start_address
operator|-
name|entry
operator|->
name|header
operator|.
name|a_text
expr_stmt|;
name|bss_relocation
operator|=
name|entry
operator|->
name|bss_start_address
operator|-
name|entry
operator|->
name|header
operator|.
name|a_text
operator|-
name|entry
operator|->
name|header
operator|.
name|a_data
expr_stmt|;
name|pc_relocation
operator|=
name|dataseg
condition|?
name|entry
operator|->
name|data_start_address
operator|-
name|entry
operator|->
name|header
operator|.
name|a_text
else|:
name|entry
operator|->
name|text_start_address
expr_stmt|;
for|for
control|(
init|;
name|r
operator|<
name|end
condition|;
name|r
operator|++
control|)
block|{
name|int
name|addr
init|=
name|RELOC_ADDRESS
argument_list|(
name|r
argument_list|)
decl_stmt|;
name|long
name|addend
init|=
name|md_get_addend
argument_list|(
name|r
argument_list|,
name|data
operator|+
name|addr
argument_list|)
decl_stmt|;
name|long
name|relocation
decl_stmt|;
comment|/* 		 * Loop over the relocations again as we did in 		 * consider_relocation(), claiming the reserved RRS 		 * relocations. 		 */
if|if
condition|(
name|addr
operator|>=
name|data_size
condition|)
name|fatal_with_file
argument_list|(
literal|"relocation address out of range in "
argument_list|,
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|RELOC_JMPTAB_P
argument_list|(
name|r
argument_list|)
condition|)
block|{
name|int
name|symindex
init|=
name|RELOC_SYMBOL
argument_list|(
name|r
argument_list|)
decl_stmt|;
name|struct
name|localsymbol
modifier|*
name|lsp
init|=
operator|&
name|entry
operator|->
name|symbols
index|[
name|symindex
index|]
decl_stmt|;
name|symbol
modifier|*
name|sp
decl_stmt|;
if|if
condition|(
name|symindex
operator|>=
name|entry
operator|->
name|nsymbols
condition|)
name|fatal_with_file
argument_list|(
literal|"relocation symbolnum out of range in "
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|sp
operator|=
name|lsp
operator|->
name|symbol
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|alias
condition|)
name|sp
operator|=
name|sp
operator|->
name|alias
expr_stmt|;
if|if
condition|(
name|relocatable_output
condition|)
name|relocation
operator|=
name|addend
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|RELOC_EXTERN_P
argument_list|(
name|r
argument_list|)
condition|)
block|{
name|relocation
operator|=
name|addend
operator|+
name|data_relocation
operator|-
name|text_relocation
expr_stmt|;
block|}
else|else
name|relocation
operator|=
name|addend
operator|+
name|claim_rrs_jmpslot
argument_list|(
name|r
argument_list|,
name|sp
argument_list|,
name|addend
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|RELOC_BASEREL_P
argument_list|(
name|r
argument_list|)
condition|)
block|{
name|int
name|symindex
init|=
name|RELOC_SYMBOL
argument_list|(
name|r
argument_list|)
decl_stmt|;
name|struct
name|localsymbol
modifier|*
name|lsp
init|=
operator|&
name|entry
operator|->
name|symbols
index|[
name|symindex
index|]
decl_stmt|;
if|if
condition|(
name|symindex
operator|>=
name|entry
operator|->
name|nsymbols
condition|)
name|fatal_with_file
argument_list|(
literal|"relocation symbolnum out of range in "
argument_list|,
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|relocatable_output
condition|)
name|relocation
operator|=
name|addend
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|RELOC_EXTERN_P
argument_list|(
name|r
argument_list|)
condition|)
name|relocation
operator|=
name|claim_rrs_internal_gotslot
argument_list|(
name|entry
argument_list|,
name|r
argument_list|,
name|lsp
argument_list|,
name|addend
argument_list|)
expr_stmt|;
else|else
name|relocation
operator|=
name|claim_rrs_gotslot
argument_list|(
name|r
argument_list|,
name|lsp
argument_list|,
name|addend
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|RELOC_EXTERN_P
argument_list|(
name|r
argument_list|)
condition|)
block|{
name|int
name|symindex
init|=
name|RELOC_SYMBOL
argument_list|(
name|r
argument_list|)
decl_stmt|;
name|symbol
modifier|*
name|sp
decl_stmt|;
if|if
condition|(
name|symindex
operator|>=
name|entry
operator|->
name|nsymbols
condition|)
name|fatal_with_file
argument_list|(
literal|"relocation symbolnum out of range in "
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|sp
operator|=
name|entry
operator|->
name|symbols
index|[
name|symindex
index|]
operator|.
name|symbol
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|alias
condition|)
name|sp
operator|=
name|sp
operator|->
name|alias
expr_stmt|;
if|if
condition|(
name|relocatable_output
condition|)
block|{
name|relocation
operator|=
name|addend
operator|+
name|sp
operator|->
name|value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sp
operator|->
name|defined
condition|)
block|{
if|if
condition|(
name|sp
operator|==
name|got_symbol
condition|)
block|{
comment|/* Handle _GOT_ refs */
name|relocation
operator|=
name|addend
operator|+
name|sp
operator|->
name|value
operator|+
name|md_got_reloc
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|building_shared_object
condition|)
block|{
comment|/* 					 * Normal (non-PIC) relocation needs 					 * to be converted into an RRS reloc 					 * when building a shared object. 					 */
name|r
operator|->
name|r_address
operator|+=
name|dataseg
condition|?
name|entry
operator|->
name|data_start_address
else|:
name|entry
operator|->
name|text_start_address
expr_stmt|;
name|relocation
operator|=
name|addend
expr_stmt|;
if|if
condition|(
name|claim_rrs_reloc
argument_list|(
name|r
argument_list|,
name|sp
argument_list|,
operator|&
name|relocation
argument_list|)
condition|)
continue|continue;
block|}
elseif|else
if|if
condition|(
name|sp
operator|->
name|defined
operator|==
name|N_SIZE
condition|)
block|{
comment|/* 					 * If size is known, arrange a 					 * run-time copy. 					 */
if|if
condition|(
operator|!
name|sp
operator|->
name|size
condition|)
name|fatal
argument_list|(
literal|"Copy item isn't: %s"
argument_list|,
name|sp
operator|->
name|name
argument_list|)
expr_stmt|;
name|relocation
operator|=
name|addend
operator|+
name|sp
operator|->
name|value
expr_stmt|;
name|r
operator|->
name|r_address
operator|=
name|sp
operator|->
name|value
expr_stmt|;
name|claim_rrs_cpy_reloc
argument_list|(
name|r
argument_list|,
name|sp
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Plain old relocation */
name|relocation
operator|=
name|addend
operator|+
name|sp
operator|->
name|value
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * If the symbol is undefined, we relocate it 				 * in a way similar to -r case. We use an 				 * RRS relocation to resolve the symbol at 				 * run-time. The r_address field is updated 				 * to reflect the changed position in the 				 * output file. 				 * 				 * In case the symbol is defined in a shared 				 * object as N_TEXT or N_DATA, an appropriate 				 * jmpslot or copy relocation is generated. 				 */
switch|switch
condition|(
name|sp
operator|->
name|so_defined
condition|)
block|{
case|case
name|N_TEXT
operator|+
name|N_EXT
case|:
comment|/* 					 * Claim a jmpslot if one was 					 * allocated (dependent on 					 * `force_alias_flag'). 					 */
if|if
condition|(
name|sp
operator|->
name|jmpslot_offset
operator|==
operator|-
literal|1
condition|)
goto|goto
name|undefined
goto|;
name|relocation
operator|=
name|addend
operator|+
name|claim_rrs_jmpslot
argument_list|(
name|r
argument_list|,
name|sp
argument_list|,
name|addend
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_DATA
operator|+
name|N_EXT
case|:
comment|/*FALLTHROUGH*/
case|case
literal|0
case|:
name|undefined
label|:
name|r
operator|->
name|r_address
operator|+=
name|dataseg
condition|?
name|entry
operator|->
name|data_start_address
else|:
name|entry
operator|->
name|text_start_address
expr_stmt|;
name|relocation
operator|=
name|addend
expr_stmt|;
if|if
condition|(
name|claim_rrs_reloc
argument_list|(
name|r
argument_list|,
name|sp
argument_list|,
operator|&
name|relocation
argument_list|)
condition|)
continue|continue;
break|break;
case|case
name|N_BSS
operator|+
name|N_EXT
case|:
name|printf
argument_list|(
literal|"%s: BSS found in so_defined\n"
argument_list|,
name|sp
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/*break;*/
default|default:
name|fatal
argument_list|(
literal|"%s: shobj symbol with unknown type %#x"
argument_list|,
name|sp
operator|->
name|name
argument_list|,
name|sp
operator|->
name|so_defined
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|RELOC_TYPE
argument_list|(
name|r
argument_list|)
condition|)
block|{
case|case
name|N_TEXT
case|:
case|case
name|N_TEXT
operator||
name|N_EXT
case|:
name|relocation
operator|=
name|addend
operator|+
name|text_relocation
expr_stmt|;
break|break;
case|case
name|N_DATA
case|:
case|case
name|N_DATA
operator||
name|N_EXT
case|:
comment|/* 				 * A word that points to beginning of the the 				 * data section initially contains not 0 but 				 * rather the "address" of that section in 				 * the input file, which is the length of the 				 * file's text. 				 */
name|relocation
operator|=
name|addend
operator|+
name|data_relocation
expr_stmt|;
break|break;
case|case
name|N_BSS
case|:
case|case
name|N_BSS
operator||
name|N_EXT
case|:
comment|/* 				 * Similarly, an input word pointing to the 				 * beginning of the bss initially contains 				 * the length of text plus data of the file. 				 */
name|relocation
operator|=
name|addend
operator|+
name|bss_relocation
expr_stmt|;
break|break;
case|case
name|N_ABS
case|:
case|case
name|N_ABS
operator||
name|N_EXT
case|:
comment|/* 				 * Don't know why this code would occur, but 				 * apparently it does. 				 */
break|break;
default|default:
name|fatal_with_file
argument_list|(
literal|"nonexternal relocation code invalid in "
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * When building a shared object, these segment 			 * relocations need a "load address relative" 			 * RRS fixup. 			 */
if|if
condition|(
name|building_shared_object
condition|)
block|{
name|r
operator|->
name|r_address
operator|+=
name|dataseg
condition|?
name|entry
operator|->
name|data_start_address
else|:
name|entry
operator|->
name|text_start_address
expr_stmt|;
name|claim_rrs_segment_reloc
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|RELOC_PCREL_P
argument_list|(
name|r
argument_list|)
condition|)
name|relocation
operator|-=
name|pc_relocation
expr_stmt|;
name|md_relocate
argument_list|(
name|r
argument_list|,
name|relocation
argument_list|,
name|data
operator|+
name|addr
argument_list|,
name|relocatable_output
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* For relocatable_output only: write out the relocation,    relocating the addresses-to-be-relocated.  */
end_comment

begin_decl_stmt
name|void
name|coptxtrel
argument_list|()
decl_stmt|,
name|copdatrel
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|write_rel
parameter_list|()
block|{
specifier|register
name|int
name|count
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|trace_files
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Writing text relocation:\n\n"
argument_list|)
expr_stmt|;
comment|/* 	 * Assign each global symbol a sequence number, giving the order 	 * in which `write_syms' will write it. 	 * This is so we can store the proper symbolnum fields 	 * in relocation entries we write. 	 *  	/* BLECH - Assign number 0 to __DYNAMIC (!! Sun compatibility) */
if|if
condition|(
name|dynamic_symbol
operator|->
name|referenced
condition|)
name|dynamic_symbol
operator|->
name|symbolnum
operator|=
name|count
operator|++
expr_stmt|;
name|FOR_EACH_SYMBOL
argument_list|(
argument|i
argument_list|,
argument|sp
argument_list|)
block|{
if|if
condition|(
name|sp
operator|!=
name|dynamic_symbol
operator|&&
name|sp
operator|->
name|referenced
condition|)
block|{
name|sp
operator|->
name|symbolnum
operator|=
name|count
operator|++
expr_stmt|;
block|}
block|}
name|END_EACH_SYMBOL
expr_stmt|;
comment|/* Correct, because if (relocatable_output), we will also be writing 	whatever indirect blocks we have.  */
if|if
condition|(
name|count
operator|!=
name|defined_global_sym_count
operator|+
name|undefined_global_sym_count
operator|+
name|special_sym_count
condition|)
name|fatal
argument_list|(
literal|"internal error: write_rel: count = %d"
argument_list|,
name|count
argument_list|)
expr_stmt|;
comment|/* Write out the relocations of all files, remembered from copy_text. */
name|each_full_file
argument_list|(
name|coptxtrel
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|trace_files
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nWriting data relocation:\n\n"
argument_list|)
expr_stmt|;
name|each_full_file
argument_list|(
name|copdatrel
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|trace_files
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|coptxtrel
parameter_list|(
name|entry
parameter_list|)
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
block|{
specifier|register
name|struct
name|relocation_info
modifier|*
name|r
decl_stmt|,
modifier|*
name|end
decl_stmt|;
specifier|register
name|int
name|reloc
init|=
name|entry
operator|->
name|text_start_address
decl_stmt|;
name|r
operator|=
name|entry
operator|->
name|textrel
expr_stmt|;
name|end
operator|=
name|r
operator|+
name|entry
operator|->
name|ntextrel
expr_stmt|;
for|for
control|(
init|;
name|r
operator|<
name|end
condition|;
name|r
operator|++
control|)
block|{
specifier|register
name|int
name|symindex
decl_stmt|;
name|symbol
modifier|*
name|sp
decl_stmt|;
name|RELOC_ADDRESS
argument_list|(
name|r
argument_list|)
operator|+=
name|reloc
expr_stmt|;
if|if
condition|(
operator|!
name|RELOC_EXTERN_P
argument_list|(
name|r
argument_list|)
condition|)
continue|continue;
name|symindex
operator|=
name|RELOC_SYMBOL
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|sp
operator|=
name|entry
operator|->
name|symbols
index|[
name|symindex
index|]
operator|.
name|symbol
expr_stmt|;
if|if
condition|(
name|symindex
operator|>=
name|entry
operator|->
name|nsymbols
condition|)
name|fatal_with_file
argument_list|(
literal|"relocation symbolnum out of range in "
argument_list|,
name|entry
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|N_INDR
comment|/* Resolve indirection.  */
if|if
condition|(
operator|(
name|sp
operator|->
name|defined
operator|&
operator|~
name|N_EXT
operator|)
operator|==
name|N_INDR
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|alias
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"internal error: alias in hyperspace"
argument_list|)
expr_stmt|;
name|sp
operator|=
name|sp
operator|->
name|alias
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 		 * If the symbol is now defined, change the external 		 * relocation to an internal one. 		 */
if|if
condition|(
name|sp
operator|->
name|defined
condition|)
block|{
name|RELOC_EXTERN_P
argument_list|(
name|r
argument_list|)
operator|=
literal|0
expr_stmt|;
name|RELOC_SYMBOL
argument_list|(
name|r
argument_list|)
operator|=
operator|(
name|sp
operator|->
name|defined
operator|&
name|N_TYPE
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RELOC_ADD_EXTRA
comment|/* 			 * If we aren't going to be adding in the 			 * value in memory on the next pass of the 			 * loader, then we need to add it in from the 			 * relocation entry.  Otherwise the work we 			 * did in this pass is lost. 			 */
if|if
condition|(
operator|!
name|RELOC_MEMORY_ADD_P
argument_list|(
name|r
argument_list|)
condition|)
name|RELOC_ADD_EXTRA
argument_list|(
name|r
argument_list|)
operator|+=
name|sp
operator|->
name|value
expr_stmt|;
endif|#
directive|endif
block|}
else|else
comment|/* 			 * Global symbols come first. 			 */
name|RELOC_SYMBOL
argument_list|(
name|r
argument_list|)
operator|=
name|sp
operator|->
name|symbolnum
expr_stmt|;
block|}
name|md_swapout_reloc
argument_list|(
name|entry
operator|->
name|textrel
argument_list|,
name|entry
operator|->
name|ntextrel
argument_list|)
expr_stmt|;
name|mywrite
argument_list|(
name|entry
operator|->
name|textrel
argument_list|,
name|entry
operator|->
name|ntextrel
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|relocation_info
argument_list|)
argument_list|,
name|outdesc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|copdatrel
parameter_list|(
name|entry
parameter_list|)
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
block|{
specifier|register
name|struct
name|relocation_info
modifier|*
name|r
decl_stmt|,
modifier|*
name|end
decl_stmt|;
comment|/* 	 * Relocate the address of the relocation. Old address is relative to 	 * start of the input file's data section. New address is relative to 	 * start of the output file's data section. 	 */
specifier|register
name|int
name|reloc
init|=
name|entry
operator|->
name|data_start_address
operator|-
name|text_size
decl_stmt|;
name|r
operator|=
name|entry
operator|->
name|datarel
expr_stmt|;
name|end
operator|=
name|r
operator|+
name|entry
operator|->
name|ndatarel
expr_stmt|;
for|for
control|(
init|;
name|r
operator|<
name|end
condition|;
name|r
operator|++
control|)
block|{
specifier|register
name|int
name|symindex
decl_stmt|;
name|symbol
modifier|*
name|sp
decl_stmt|;
name|int
name|symtype
decl_stmt|;
name|RELOC_ADDRESS
argument_list|(
name|r
argument_list|)
operator|+=
name|reloc
expr_stmt|;
if|if
condition|(
operator|!
name|RELOC_EXTERN_P
argument_list|(
name|r
argument_list|)
condition|)
continue|continue;
name|symindex
operator|=
name|RELOC_SYMBOL
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|sp
operator|=
name|entry
operator|->
name|symbols
index|[
name|symindex
index|]
operator|.
name|symbol
expr_stmt|;
if|if
condition|(
name|symindex
operator|>=
name|entry
operator|->
name|header
operator|.
name|a_syms
condition|)
name|fatal_with_file
argument_list|(
literal|"relocation symbolnum out of range in "
argument_list|,
name|entry
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|N_INDR
comment|/* Resolve indirection.  */
if|if
condition|(
operator|(
name|sp
operator|->
name|defined
operator|&
operator|~
name|N_EXT
operator|)
operator|==
name|N_INDR
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|alias
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"internal error: alias in hyperspace"
argument_list|)
expr_stmt|;
name|sp
operator|=
name|sp
operator|->
name|alias
expr_stmt|;
block|}
endif|#
directive|endif
name|symtype
operator|=
name|sp
operator|->
name|defined
operator|&
name|N_TYPE
expr_stmt|;
if|if
condition|(
name|force_common_definition
operator|||
name|symtype
operator|==
name|N_DATA
operator|||
name|symtype
operator|==
name|N_TEXT
operator|||
name|symtype
operator|==
name|N_ABS
condition|)
block|{
name|RELOC_EXTERN_P
argument_list|(
name|r
argument_list|)
operator|=
literal|0
expr_stmt|;
name|RELOC_SYMBOL
argument_list|(
name|r
argument_list|)
operator|=
name|symtype
expr_stmt|;
block|}
else|else
comment|/* 			 * Global symbols come first. 			 */
name|RELOC_SYMBOL
argument_list|(
name|r
argument_list|)
operator|=
name|entry
operator|->
name|symbols
index|[
name|symindex
index|]
operator|.
name|symbol
operator|->
name|symbolnum
expr_stmt|;
block|}
name|md_swapout_reloc
argument_list|(
name|entry
operator|->
name|datarel
argument_list|,
name|entry
operator|->
name|ndatarel
argument_list|)
expr_stmt|;
name|mywrite
argument_list|(
name|entry
operator|->
name|datarel
argument_list|,
name|entry
operator|->
name|ndatarel
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|relocation_info
argument_list|)
argument_list|,
name|outdesc
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function_decl
name|void
name|write_file_syms
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|write_string_table
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Offsets and current lengths of symbol and string tables in output file. */
end_comment

begin_decl_stmt
name|int
name|symbol_table_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|symbol_table_len
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Address in output file where string table starts.  */
end_comment

begin_decl_stmt
name|int
name|string_table_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Offset within string table    where the strings in `strtab_vector' should be written.  */
end_comment

begin_decl_stmt
name|int
name|string_table_len
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Total size of string table strings allocated so far,    including strings in `strtab_vector'.  */
end_comment

begin_decl_stmt
name|int
name|strtab_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Vector whose elements are strings to be added to the string table.  */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|strtab_vector
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Vector whose elements are the lengths of those strings.  */
end_comment

begin_decl_stmt
name|int
modifier|*
name|strtab_lens
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index in `strtab_vector' at which the next string will be stored.  */
end_comment

begin_decl_stmt
name|int
name|strtab_index
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Add the string NAME to the output file string table. Record it in  * `strtab_vector' to be output later. Return the index within the string  * table that this string will have.  */
end_comment

begin_function
name|int
name|assign_string_table_index
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|int
name|index
init|=
name|strtab_size
decl_stmt|;
specifier|register
name|int
name|len
init|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
decl_stmt|;
name|strtab_size
operator|+=
name|len
expr_stmt|;
name|strtab_vector
index|[
name|strtab_index
index|]
operator|=
name|name
expr_stmt|;
name|strtab_lens
index|[
name|strtab_index
operator|++
index|]
operator|=
name|len
expr_stmt|;
return|return
name|index
return|;
block|}
end_function

begin_decl_stmt
name|FILE
modifier|*
name|outstream
init|=
operator|(
name|FILE
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Write the contents of `strtab_vector' into the string table. This is done  * once for each file's local&debugger symbols and once for the global  * symbols.  */
end_comment

begin_function
name|void
name|write_string_table
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|lseek
argument_list|(
name|outdesc
argument_list|,
name|string_table_offset
operator|+
name|string_table_len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|outstream
condition|)
name|outstream
operator|=
name|fdopen
argument_list|(
name|outdesc
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|strtab_index
condition|;
name|i
operator|++
control|)
block|{
name|fwrite
argument_list|(
name|strtab_vector
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|,
name|strtab_lens
index|[
name|i
index|]
argument_list|,
name|outstream
argument_list|)
expr_stmt|;
name|string_table_len
operator|+=
name|strtab_lens
index|[
name|i
index|]
expr_stmt|;
block|}
name|fflush
argument_list|(
name|outstream
argument_list|)
expr_stmt|;
comment|/* Report I/O error such as disk full.  */
if|if
condition|(
name|ferror
argument_list|(
name|outstream
argument_list|)
condition|)
name|perror_name
argument_list|(
name|output_filename
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Write the symbol table and string table of the output file.  */
end_comment

begin_function
name|void
name|write_syms
parameter_list|()
block|{
comment|/* Number of symbols written so far.  */
name|int
name|non_local_syms
init|=
name|defined_global_sym_count
operator|+
name|undefined_global_sym_count
operator|+
name|global_alias_count
operator|+
name|special_sym_count
decl_stmt|;
name|int
name|syms_written
init|=
literal|0
decl_stmt|;
name|struct
name|nlist
name|nl
decl_stmt|;
comment|/* 	 * Buffer big enough for all the global symbols.  One extra struct 	 * for each indirect symbol to hold the extra reference following. 	 */
name|struct
name|nlist
modifier|*
name|buf
init|=
operator|(
expr|struct
name|nlist
operator|*
operator|)
name|alloca
argument_list|(
name|non_local_syms
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Pointer for storing into BUF.  */
specifier|register
name|struct
name|nlist
modifier|*
name|bufp
init|=
name|buf
decl_stmt|;
comment|/* Size of string table includes the bytes that store the size.  */
name|strtab_size
operator|=
sizeof|sizeof
name|strtab_size
expr_stmt|;
name|symbol_table_offset
operator|=
name|N_SYMOFF
argument_list|(
name|outheader
argument_list|)
expr_stmt|;
name|symbol_table_len
operator|=
literal|0
expr_stmt|;
name|string_table_offset
operator|=
name|N_STROFF
argument_list|(
name|outheader
argument_list|)
expr_stmt|;
name|string_table_len
operator|=
name|strtab_size
expr_stmt|;
if|if
condition|(
name|strip_symbols
operator|==
name|STRIP_ALL
condition|)
return|return;
comment|/* First, write out the global symbols.  */
comment|/* 	 * Allocate two vectors that record the data to generate the string 	 * table from the global symbols written so far.  This must include 	 * extra space for the references following indirect outputs. 	 */
name|strtab_vector
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|non_local_syms
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|strtab_lens
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|non_local_syms
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|strtab_index
operator|=
literal|0
expr_stmt|;
comment|/* 	 * __DYNAMIC symbol *must* be first for Sun compatibility, as Sun's 	 * ld.so reads the shared object's first symbol. This means that 	 * (Sun's) shared libraries cannot be stripped! (We only assume 	 * that __DYNAMIC is the first item in the data segment) 	 * 	 * If defined (ie. not relocatable_output), make it look 	 * like an internal symbol. 	 */
if|if
condition|(
name|dynamic_symbol
operator|->
name|referenced
condition|)
block|{
name|nl
operator|.
name|n_other
operator|=
literal|0
expr_stmt|;
name|nl
operator|.
name|n_desc
operator|=
literal|0
expr_stmt|;
name|nl
operator|.
name|n_type
operator|=
name|dynamic_symbol
operator|->
name|defined
expr_stmt|;
if|if
condition|(
name|nl
operator|.
name|n_type
operator|==
name|N_UNDF
condition|)
name|nl
operator|.
name|n_type
operator||=
name|N_EXT
expr_stmt|;
else|else
name|nl
operator|.
name|n_type
operator|&=
operator|~
name|N_EXT
expr_stmt|;
name|nl
operator|.
name|n_value
operator|=
name|dynamic_symbol
operator|->
name|value
expr_stmt|;
name|nl
operator|.
name|n_un
operator|.
name|n_strx
operator|=
name|assign_string_table_index
argument_list|(
name|dynamic_symbol
operator|->
name|name
argument_list|)
expr_stmt|;
operator|*
name|bufp
operator|++
operator|=
name|nl
expr_stmt|;
name|syms_written
operator|++
expr_stmt|;
block|}
comment|/* Scan the symbol hash table, bucket by bucket.  */
name|FOR_EACH_SYMBOL
argument_list|(
argument|i
argument_list|,
argument|sp
argument_list|)
block|{
if|if
condition|(
name|sp
operator|==
name|dynamic_symbol
condition|)
comment|/* Already dealt with above */
continue|continue;
if|if
condition|(
operator|!
name|sp
operator|->
name|referenced
condition|)
comment|/* Came from shared object but was not used */
continue|continue;
if|if
condition|(
name|sp
operator|->
name|so_defined
condition|)
comment|/* 			 * Definition came from shared object, 			 * don't mention it here 			 */
continue|continue;
if|if
condition|(
operator|!
name|sp
operator|->
name|defined
operator|&&
operator|!
name|relocatable_output
condition|)
block|{
comment|/* 			 * We're building a shared object and there 			 * are still undefined symbols. Don't output 			 * these, symbol was discounted in digest_pass1() 			 * (they are in the RRS symbol table). 			 */
if|if
condition|(
operator|!
name|building_shared_object
condition|)
name|error
argument_list|(
literal|"symbol %s remains undefined"
argument_list|,
name|sp
operator|->
name|name
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Construct a `struct nlist' for the symbol.  */
name|nl
operator|.
name|n_other
operator|=
literal|0
expr_stmt|;
name|nl
operator|.
name|n_desc
operator|=
literal|0
expr_stmt|;
comment|/* 		 * common condition needs to be before undefined 		 * condition because unallocated commons are set 		 * undefined in digest_symbols 		 */
if|if
condition|(
name|sp
operator|->
name|defined
operator|>
literal|1
condition|)
block|{
comment|/* defined with known type */
if|if
condition|(
operator|!
name|relocatable_output
operator|&&
name|sp
operator|->
name|alias
operator|&&
name|sp
operator|->
name|alias
operator|->
name|defined
operator|>
literal|1
condition|)
block|{
comment|/* 				 * If the target of an indirect symbol has 				 * been defined and we are outputting an 				 * executable, resolve the indirection; it's 				 * no longer needed 				 */
name|nl
operator|.
name|n_type
operator|=
name|sp
operator|->
name|alias
operator|->
name|defined
expr_stmt|;
name|nl
operator|.
name|n_type
operator|=
name|sp
operator|->
name|alias
operator|->
name|value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sp
operator|->
name|defined
operator|==
name|N_SIZE
condition|)
name|nl
operator|.
name|n_type
operator|=
name|N_DATA
operator||
name|N_EXT
expr_stmt|;
else|else
name|nl
operator|.
name|n_type
operator|=
name|sp
operator|->
name|defined
expr_stmt|;
name|nl
operator|.
name|n_value
operator|=
name|sp
operator|->
name|value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sp
operator|->
name|max_common_size
condition|)
block|{
comment|/* 			 * defined as common but not allocated, 			 * happens only with -r and not -d, write out 			 * a common definition 			 */
name|nl
operator|.
name|n_type
operator|=
name|N_UNDF
operator||
name|N_EXT
expr_stmt|;
name|nl
operator|.
name|n_value
operator|=
name|sp
operator|->
name|max_common_size
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|sp
operator|->
name|defined
condition|)
block|{
comment|/* undefined -- legit only if -r */
name|nl
operator|.
name|n_type
operator|=
name|N_UNDF
operator||
name|N_EXT
expr_stmt|;
name|nl
operator|.
name|n_value
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|fatal
argument_list|(
literal|"internal error: %s defined in mysterious way"
argument_list|,
name|sp
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* 		 * Allocate string table space for the symbol name. 		 */
name|nl
operator|.
name|n_un
operator|.
name|n_strx
operator|=
name|assign_string_table_index
argument_list|(
name|sp
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* Output to the buffer and count it.  */
if|if
condition|(
name|syms_written
operator|>=
name|non_local_syms
condition|)
name|fatal
argument_list|(
literal|"internal error: number of symbols exceeds allocated %d"
argument_list|,
name|non_local_syms
argument_list|)
expr_stmt|;
operator|*
name|bufp
operator|++
operator|=
name|nl
expr_stmt|;
name|syms_written
operator|++
expr_stmt|;
if|if
condition|(
name|nl
operator|.
name|n_type
operator|==
name|N_INDR
operator|+
name|N_EXT
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|alias
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"internal error: alias in hyperspace"
argument_list|)
expr_stmt|;
name|nl
operator|.
name|n_type
operator|=
name|N_UNDF
operator|+
name|N_EXT
expr_stmt|;
name|nl
operator|.
name|n_un
operator|.
name|n_strx
operator|=
name|assign_string_table_index
argument_list|(
name|sp
operator|->
name|alias
operator|->
name|name
argument_list|)
expr_stmt|;
name|nl
operator|.
name|n_value
operator|=
literal|0
expr_stmt|;
operator|*
name|bufp
operator|++
operator|=
name|nl
expr_stmt|;
name|syms_written
operator|++
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"writesym(#%d): %s, type %x\n"
argument_list|,
name|syms_written
argument_list|,
name|sp
operator|->
name|name
argument_list|,
name|sp
operator|->
name|defined
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|END_EACH_SYMBOL
expr_stmt|;
if|if
condition|(
name|syms_written
operator|!=
name|strtab_index
operator|||
name|strtab_index
operator|!=
name|non_local_syms
condition|)
name|fatal
argument_list|(
literal|"internal error:\ wrong number (%d) of global symbols written into output file, should be %d"
argument_list|,
name|syms_written
argument_list|,
name|non_local_syms
argument_list|)
expr_stmt|;
comment|/* Output the buffer full of `struct nlist's.  */
name|lseek
argument_list|(
name|outdesc
argument_list|,
name|symbol_table_offset
operator|+
name|symbol_table_len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|md_swapout_symbols
argument_list|(
name|buf
argument_list|,
name|bufp
operator|-
name|buf
argument_list|)
expr_stmt|;
name|mywrite
argument_list|(
name|buf
argument_list|,
name|bufp
operator|-
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
argument_list|,
name|outdesc
argument_list|)
expr_stmt|;
name|symbol_table_len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
operator|*
operator|(
name|bufp
operator|-
name|buf
operator|)
expr_stmt|;
comment|/* Write the strings for the global symbols.  */
name|write_string_table
argument_list|()
expr_stmt|;
comment|/* Write the local symbols defined by the various files.  */
name|each_file
argument_list|(
name|write_file_syms
argument_list|,
operator|&
name|syms_written
argument_list|)
expr_stmt|;
name|file_close
argument_list|()
expr_stmt|;
if|if
condition|(
name|syms_written
operator|!=
name|nsyms
condition|)
name|fatal
argument_list|(
literal|"internal error:\ wrong number of symbols (%d) written into output file, should be %d"
argument_list|,
name|syms_written
argument_list|,
name|nsyms
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbol_table_offset
operator|+
name|symbol_table_len
operator|!=
name|string_table_offset
condition|)
name|fatal
argument_list|(
literal|"internal error: inconsistent symbol table length: %d vs %s"
argument_list|,
name|symbol_table_offset
operator|+
name|symbol_table_len
argument_list|,
name|string_table_offset
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|outdesc
argument_list|,
name|string_table_offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|strtab_size
operator|=
name|md_swap_long
argument_list|(
name|strtab_size
argument_list|)
expr_stmt|;
name|mywrite
argument_list|(
operator|&
name|strtab_size
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
literal|1
argument_list|,
name|outdesc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Write the local and debugger symbols of file ENTRY. Increment  * *SYMS_WRITTEN_ADDR for each symbol that is written.  */
end_comment

begin_comment
comment|/*  * Note that we do not combine identical names of local symbols. dbx or gdb  * would be confused if we did that.  */
end_comment

begin_function
name|void
name|write_file_syms
parameter_list|(
name|entry
parameter_list|,
name|syms_written_addr
parameter_list|)
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
name|int
modifier|*
name|syms_written_addr
decl_stmt|;
block|{
name|struct
name|localsymbol
modifier|*
name|lsp
decl_stmt|,
modifier|*
name|lspend
decl_stmt|;
comment|/* Upper bound on number of syms to be written here.  */
name|int
name|max_syms
init|=
name|entry
operator|->
name|nsymbols
operator|+
literal|1
decl_stmt|;
comment|/* 	 * Buffer to accumulate all the syms before writing them. It has one 	 * extra slot for the local symbol we generate here. 	 */
name|struct
name|nlist
modifier|*
name|buf
init|=
operator|(
expr|struct
name|nlist
operator|*
operator|)
name|alloca
argument_list|(
name|max_syms
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|nlist
modifier|*
name|bufp
init|=
name|buf
decl_stmt|;
if|if
condition|(
name|entry
operator|->
name|is_dynamic
condition|)
return|return;
comment|/* 	 * Make tables that record, for each symbol, its name and its name's 	 * length. The elements are filled in by `assign_string_table_index'. 	 */
name|strtab_vector
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|alloca
argument_list|(
name|max_syms
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|strtab_lens
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|max_syms
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|strtab_index
operator|=
literal|0
expr_stmt|;
comment|/* Generate a local symbol for the start of this file's text.  */
if|if
condition|(
name|discard_locals
operator|!=
name|DISCARD_ALL
condition|)
block|{
name|struct
name|nlist
name|nl
decl_stmt|;
name|nl
operator|.
name|n_type
operator|=
name|N_FN
operator||
name|N_EXT
expr_stmt|;
name|nl
operator|.
name|n_un
operator|.
name|n_strx
operator|=
name|assign_string_table_index
argument_list|(
name|entry
operator|->
name|local_sym_name
argument_list|)
expr_stmt|;
name|nl
operator|.
name|n_value
operator|=
name|entry
operator|->
name|text_start_address
expr_stmt|;
name|nl
operator|.
name|n_desc
operator|=
literal|0
expr_stmt|;
name|nl
operator|.
name|n_other
operator|=
literal|0
expr_stmt|;
operator|*
name|bufp
operator|++
operator|=
name|nl
expr_stmt|;
operator|(
operator|*
name|syms_written_addr
operator|)
operator|++
expr_stmt|;
name|entry
operator|->
name|local_syms_offset
operator|=
operator|*
name|syms_written_addr
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
expr_stmt|;
block|}
comment|/* Read the file's string table.  */
name|entry
operator|->
name|strings
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|entry
operator|->
name|string_size
argument_list|)
expr_stmt|;
name|read_entry_strings
argument_list|(
name|file_open
argument_list|(
name|entry
argument_list|)
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|lspend
operator|=
name|entry
operator|->
name|symbols
operator|+
name|entry
operator|->
name|nsymbols
expr_stmt|;
for|for
control|(
name|lsp
operator|=
name|entry
operator|->
name|symbols
init|;
name|lsp
operator|<
name|lspend
condition|;
name|lsp
operator|++
control|)
block|{
specifier|register
name|struct
name|nlist
modifier|*
name|p
init|=
operator|&
name|lsp
operator|->
name|nzlist
operator|.
name|nlist
decl_stmt|;
specifier|register
name|int
name|type
init|=
name|p
operator|->
name|n_type
decl_stmt|;
specifier|register
name|int
name|write
init|=
literal|0
decl_stmt|;
comment|/* 		 * WRITE gets 1 for a non-global symbol that should be 		 * written. 		 */
if|if
condition|(
name|SET_ELEMENT_P
argument_list|(
name|type
argument_list|)
condition|)
comment|/* 			 * This occurs even if global. These types of 			 * symbols are never written globally, though 			 * they are stored globally. 			 */
name|write
operator|=
name|relocatable_output
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|type
operator|&
operator|(
name|N_STAB
operator||
name|N_EXT
operator|)
operator|)
condition|)
comment|/* ordinary local symbol */
name|write
operator|=
operator|(
operator|(
name|discard_locals
operator|!=
name|DISCARD_ALL
operator|)
operator|&&
operator|!
operator|(
name|discard_locals
operator|==
name|DISCARD_L
operator|&&
operator|(
name|p
operator|->
name|n_un
operator|.
name|n_strx
operator|+
name|entry
operator|->
name|strings
operator|)
index|[
literal|0
index|]
operator|==
name|LPREFIX
operator|)
operator|&&
name|type
operator|!=
name|N_WARNING
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|type
operator|&
name|N_EXT
operator|)
condition|)
comment|/* debugger symbol */
name|write
operator|=
operator|(
name|strip_symbols
operator|==
name|STRIP_NONE
operator|)
operator|&&
operator|!
operator|(
name|discard_locals
operator|==
name|DISCARD_L
operator|&&
operator|(
name|p
operator|->
name|n_un
operator|.
name|n_strx
operator|+
name|entry
operator|->
name|strings
operator|)
index|[
literal|0
index|]
operator|==
name|LPREFIX
operator|)
expr_stmt|;
if|if
condition|(
name|write
condition|)
block|{
comment|/* 			 * If this symbol has a name, allocate space for it 			 * in the output string table. 			 */
if|if
condition|(
name|p
operator|->
name|n_un
operator|.
name|n_strx
condition|)
name|p
operator|->
name|n_un
operator|.
name|n_strx
operator|=
name|assign_string_table_index
argument_list|(
name|p
operator|->
name|n_un
operator|.
name|n_strx
operator|+
name|entry
operator|->
name|strings
argument_list|)
expr_stmt|;
comment|/* Output this symbol to the buffer and count it.  */
operator|*
name|bufp
operator|++
operator|=
operator|*
name|p
expr_stmt|;
operator|(
operator|*
name|syms_written_addr
operator|)
operator|++
expr_stmt|;
block|}
block|}
comment|/* All the symbols are now in BUF; write them.  */
name|lseek
argument_list|(
name|outdesc
argument_list|,
name|symbol_table_offset
operator|+
name|symbol_table_len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|md_swapout_symbols
argument_list|(
name|buf
argument_list|,
name|bufp
operator|-
name|buf
argument_list|)
expr_stmt|;
name|mywrite
argument_list|(
name|buf
argument_list|,
name|bufp
operator|-
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
argument_list|,
name|outdesc
argument_list|)
expr_stmt|;
name|symbol_table_len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
operator|*
operator|(
name|bufp
operator|-
name|buf
operator|)
expr_stmt|;
comment|/* 	 * Write the string-table data for the symbols just written, using 	 * the data in vectors `strtab_vector' and `strtab_lens'. 	 */
name|write_string_table
argument_list|()
expr_stmt|;
name|entry
operator|->
name|strings
operator|=
literal|0
expr_stmt|;
comment|/* Since it will disappear anyway.  */
block|}
end_function

end_unit

