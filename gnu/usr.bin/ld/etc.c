begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * $Id: etc.c,v 1.2 1993/10/21 00:52:52 pk Exp $  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<ar.h>
end_include

begin_include
include|#
directive|include
file|<ranlib.h>
end_include

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_include
include|#
directive|include
file|<stab.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ld.h"
end_include

begin_comment
comment|/*  * Report a nonfatal error.  */
end_comment

begin_decl_stmt
name|void
if|#
directive|if
name|__STDC__
name|error
argument_list|(
name|char
operator|*
name|fmt
argument_list|,
operator|...
argument_list|)
else|#
directive|else
name|error
argument_list|(
name|fmt
argument_list|,
name|va_alist
argument_list|)
name|char
modifier|*
name|fmt
decl_stmt|;
end_decl_stmt

begin_macro
name|va_dcl
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|va_list
name|ap
decl_stmt|;
if|#
directive|if
name|__STDC__
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
else|#
directive|else
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|progname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Report a fatal error.  */
end_comment

begin_function
name|void
if|#
directive|if
name|__STDC__
name|fatal
parameter_list|(
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
function|fatal
parameter_list|(
name|fmt
parameter_list|,
name|va_alist
parameter_list|)
name|char
modifier|*
name|fmt
decl_stmt|;
function|va_dcl
endif|#
directive|endif
block|{
name|va_list
name|ap
decl_stmt|;
if|#
directive|if
name|__STDC__
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
else|#
directive|else
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|progname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|outdesc
operator|>=
literal|0
condition|)
name|unlink
argument_list|(
name|output_filename
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return a newly-allocated string whose contents concatenate  * the strings S1, S2, S3.  */
end_comment

begin_function
name|char
modifier|*
name|concat
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|,
name|s3
parameter_list|)
name|char
modifier|*
name|s1
decl_stmt|,
decl|*
name|s2
decl_stmt|,
modifier|*
name|s3
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|len1
init|=
name|strlen
argument_list|(
name|s1
argument_list|)
decl_stmt|,
name|len2
init|=
name|strlen
argument_list|(
name|s2
argument_list|)
decl_stmt|,
name|len3
init|=
name|strlen
argument_list|(
name|s3
argument_list|)
decl_stmt|;
specifier|register
name|char
modifier|*
name|result
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|len1
operator|+
name|len2
operator|+
name|len3
operator|+
literal|1
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|result
argument_list|,
name|s1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|result
operator|+
name|len1
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|result
operator|+
name|len1
operator|+
name|len2
argument_list|,
name|s3
argument_list|)
expr_stmt|;
name|result
index|[
name|len1
operator|+
name|len2
operator|+
name|len3
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|result
return|;
block|}
end_block

begin_comment
comment|/* Parse the string ARG using scanf format FORMAT, and return the result.    If it does not parse, report fatal error    generating the error message using format string ERROR and ARG as arg.  */
end_comment

begin_decl_stmt
name|int
name|parse
argument_list|(
name|arg
argument_list|,
name|format
argument_list|,
name|error
argument_list|)
name|char
modifier|*
name|arg
decl_stmt|,
modifier|*
name|format
decl_stmt|,
modifier|*
name|error
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|x
decl_stmt|;
if|if
condition|(
literal|1
operator|!=
name|sscanf
argument_list|(
name|arg
argument_list|,
name|format
argument_list|,
operator|&
name|x
argument_list|)
condition|)
name|fatal
argument_list|(
name|error
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
end_block

begin_comment
comment|/* Like malloc but get fatal error if memory is exhausted.  */
end_comment

begin_function
name|void
modifier|*
name|xmalloc
parameter_list|(
name|size
parameter_list|)
name|int
name|size
decl_stmt|;
block|{
specifier|register
name|void
modifier|*
name|result
init|=
operator|(
name|void
operator|*
operator|)
name|malloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
name|fatal
argument_list|(
literal|"virtual memory exhausted"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Like realloc but get fatal error if memory is exhausted.  */
end_comment

begin_function
name|void
modifier|*
name|xrealloc
parameter_list|(
name|ptr
parameter_list|,
name|size
parameter_list|)
name|void
modifier|*
name|ptr
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
specifier|register
name|void
modifier|*
name|result
decl_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
name|result
operator|=
operator|(
name|void
operator|*
operator|)
name|malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
operator|(
name|void
operator|*
operator|)
name|realloc
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
name|fatal
argument_list|(
literal|"virtual memory exhausted"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_function
name|void
name|bzero
parameter_list|(
name|p
parameter_list|,
name|n
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
block|{
name|memset
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bcopy
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|,
name|n
parameter_list|)
name|char
modifier|*
name|from
decl_stmt|,
decl|*
name|to
decl_stmt|;
end_function

begin_block
block|{
name|memcpy
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* These must move */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|RTLD
end_ifndef

begin_comment
comment|/*  * Output COUNT*ELTSIZE bytes of data at BUF to the descriptor DESC.  */
end_comment

begin_function
name|void
name|mywrite
parameter_list|(
name|buf
parameter_list|,
name|count
parameter_list|,
name|eltsize
parameter_list|,
name|desc
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|eltsize
decl_stmt|;
name|int
name|desc
decl_stmt|;
block|{
specifier|register
name|int
name|val
decl_stmt|;
specifier|register
name|int
name|bytes
init|=
name|count
operator|*
name|eltsize
decl_stmt|;
while|while
condition|(
name|bytes
operator|>
literal|0
condition|)
block|{
name|val
operator|=
name|write
argument_list|(
name|desc
argument_list|,
name|buf
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<=
literal|0
condition|)
name|perror
argument_list|(
name|output_filename
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|val
expr_stmt|;
name|bytes
operator|-=
name|val
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Output PADDING zero-bytes to descriptor OUTDESC.    PADDING may be negative; in that case, do nothing.  */
end_comment

begin_function
name|void
name|padfile
parameter_list|(
name|padding
parameter_list|,
name|outdesc
parameter_list|)
name|int
name|padding
decl_stmt|;
name|int
name|outdesc
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|buf
decl_stmt|;
if|if
condition|(
name|padding
operator|<=
literal|0
condition|)
return|return;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|padding
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|buf
argument_list|,
name|padding
argument_list|)
expr_stmt|;
name|mywrite
argument_list|(
name|buf
argument_list|,
name|padding
argument_list|,
literal|1
argument_list|,
name|outdesc
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

