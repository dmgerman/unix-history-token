begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * $Id: etc.c,v 1.6 1993/12/11 11:58:22 jkh Exp $  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<ar.h>
end_include

begin_include
include|#
directive|include
file|<ranlib.h>
end_include

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_include
include|#
directive|include
file|<stab.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ld.h"
end_include

begin_comment
comment|/*  * Report a nonfatal error.  */
end_comment

begin_decl_stmt
name|void
if|#
directive|if
name|__STDC__
name|error
argument_list|(
name|char
operator|*
name|fmt
argument_list|,
operator|...
argument_list|)
else|#
directive|else
name|error
argument_list|(
name|fmt
argument_list|,
name|va_alist
argument_list|)
name|char
modifier|*
name|fmt
decl_stmt|;
end_decl_stmt

begin_macro
name|va_dcl
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|va_list
name|ap
decl_stmt|;
if|#
directive|if
name|__STDC__
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
else|#
directive|else
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|progname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|void
argument_list|(
argument|*fatal_cleanup_hook
argument_list|)
end_macro

begin_expr_stmt
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Report a fatal error.  */
end_comment

begin_function
name|void
if|#
directive|if
name|__STDC__
name|fatal
parameter_list|(
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
function|fatal
parameter_list|(
name|fmt
parameter_list|,
name|va_alist
parameter_list|)
name|char
modifier|*
name|fmt
decl_stmt|;
function|va_dcl
endif|#
directive|endif
block|{
name|va_list
name|ap
decl_stmt|;
if|#
directive|if
name|__STDC__
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
else|#
directive|else
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|progname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|fatal_cleanup_hook
condition|)
call|(
modifier|*
name|fatal_cleanup_hook
call|)
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return a newly-allocated string whose contents concatenate  * the strings S1, S2, S3.  */
end_comment

begin_function
name|char
modifier|*
name|concat
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|,
name|s3
parameter_list|)
specifier|const
name|char
modifier|*
name|s1
decl_stmt|,
decl|*
name|s2
decl_stmt|,
modifier|*
name|s3
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|len1
init|=
name|strlen
argument_list|(
name|s1
argument_list|)
decl_stmt|,
name|len2
init|=
name|strlen
argument_list|(
name|s2
argument_list|)
decl_stmt|,
name|len3
init|=
name|strlen
argument_list|(
name|s3
argument_list|)
decl_stmt|;
specifier|register
name|char
modifier|*
name|result
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|len1
operator|+
name|len2
operator|+
name|len3
operator|+
literal|1
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|result
argument_list|,
name|s1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|result
operator|+
name|len1
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|result
operator|+
name|len1
operator|+
name|len2
argument_list|,
name|s3
argument_list|)
expr_stmt|;
name|result
index|[
name|len1
operator|+
name|len2
operator|+
name|len3
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|result
return|;
block|}
end_block

begin_comment
comment|/* Parse the string ARG using scanf format FORMAT, and return the result.    If it does not parse, report fatal error    generating the error message using format string ERROR and ARG as arg.  */
end_comment

begin_decl_stmt
name|int
name|parse
argument_list|(
name|arg
argument_list|,
name|format
argument_list|,
name|error
argument_list|)
name|char
modifier|*
name|arg
decl_stmt|,
modifier|*
name|format
decl_stmt|,
modifier|*
name|error
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|x
decl_stmt|;
if|if
condition|(
literal|1
operator|!=
name|sscanf
argument_list|(
name|arg
argument_list|,
name|format
argument_list|,
operator|&
name|x
argument_list|)
condition|)
name|fatal
argument_list|(
name|error
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
end_block

begin_comment
comment|/* Like malloc but get fatal error if memory is exhausted.  */
end_comment

begin_function
name|void
modifier|*
name|xmalloc
parameter_list|(
name|size
parameter_list|)
name|int
name|size
decl_stmt|;
block|{
specifier|register
name|void
modifier|*
name|result
init|=
operator|(
name|void
operator|*
operator|)
name|malloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
name|fatal
argument_list|(
literal|"virtual memory exhausted"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Like realloc but get fatal error if memory is exhausted.  */
end_comment

begin_function
name|void
modifier|*
name|xrealloc
parameter_list|(
name|ptr
parameter_list|,
name|size
parameter_list|)
name|void
modifier|*
name|ptr
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
specifier|register
name|void
modifier|*
name|result
decl_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
name|result
operator|=
operator|(
name|void
operator|*
operator|)
name|malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
operator|(
name|void
operator|*
operator|)
name|realloc
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
name|fatal
argument_list|(
literal|"virtual memory exhausted"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

end_unit

