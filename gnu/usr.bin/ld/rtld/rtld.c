begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1993 Paul Kranenburg  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *      This product includes software developed by Paul Kranenburg.  * 4. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  *	$Id: rtld.c,v 1.49 1997/09/18 13:55:45 phk Exp $  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|MAP_COPY
end_ifndef

begin_define
define|#
directive|define
name|MAP_COPY
value|MAP_PRIVATE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dlfcn.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_include
include|#
directive|include
file|<stab.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<link.h>
end_include

begin_include
include|#
directive|include
file|"md.h"
end_include

begin_include
include|#
directive|include
file|"shlib.h"
end_include

begin_include
include|#
directive|include
file|"support.h"
end_include

begin_include
include|#
directive|include
file|"dynamic.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|MAP_ANON
end_ifndef

begin_define
define|#
directive|define
name|MAP_ANON
value|0
end_define

begin_define
define|#
directive|define
name|anon_open
parameter_list|()
value|do {					\ 	if ((anon_fd = open("/dev/zero", O_RDWR, 0)) == -1)	\ 		err("open: %s", "/dev/zero");			\ } while (0)
end_define

begin_define
define|#
directive|define
name|anon_close
parameter_list|()
value|do {	\ 	(void)close(anon_fd);	\ 	anon_fd = -1;		\ } while (0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|anon_open
parameter_list|()
end_define

begin_define
define|#
directive|define
name|anon_close
parameter_list|()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Structure for building a list of shared objects.  */
end_comment

begin_struct
struct|struct
name|so_list
block|{
name|struct
name|so_map
modifier|*
name|sol_map
decl_stmt|;
comment|/* Link map for shared object */
name|struct
name|so_list
modifier|*
name|sol_next
decl_stmt|;
comment|/* Next entry in the list */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Loader private data, hung off<so_map>->som_spd  */
end_comment

begin_struct
struct|struct
name|somap_private
block|{
name|int
name|spd_version
decl_stmt|;
name|struct
name|so_map
modifier|*
name|spd_parent
decl_stmt|;
name|struct
name|so_list
modifier|*
name|spd_children
decl_stmt|;
name|struct
name|so_map
modifier|*
name|spd_prev
decl_stmt|;
name|dev_t
name|spd_dev
decl_stmt|;
name|ino_t
name|spd_ino
decl_stmt|;
name|int
name|spd_refcount
decl_stmt|;
name|int
name|spd_flags
decl_stmt|;
define|#
directive|define
name|RTLD_MAIN
value|0x01
define|#
directive|define
name|RTLD_RTLD
value|0x02
define|#
directive|define
name|RTLD_DL
value|0x04
define|#
directive|define
name|RTLD_INIT
value|0x08
name|unsigned
name|long
name|a_text
decl_stmt|;
comment|/* text size, if known     */
name|unsigned
name|long
name|a_data
decl_stmt|;
comment|/* initialized data size   */
name|unsigned
name|long
name|a_bss
decl_stmt|;
comment|/* uninitialized data size */
ifdef|#
directive|ifdef
name|SUN_COMPAT
name|long
name|spd_offset
decl_stmt|;
comment|/* Correction for Sun main programs */
endif|#
directive|endif
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|LM_PRIVATE
parameter_list|(
name|smp
parameter_list|)
value|((struct somap_private *)(smp)->som_spd)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|SUN_COMPAT
end_ifdef

begin_define
define|#
directive|define
name|LM_OFFSET
parameter_list|(
name|smp
parameter_list|)
value|(LM_PRIVATE(smp)->spd_offset)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|LM_OFFSET
parameter_list|(
name|smp
parameter_list|)
value|(0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Base address for section_dispatch_table entries */
end_comment

begin_define
define|#
directive|define
name|LM_LDBASE
parameter_list|(
name|smp
parameter_list|)
value|(smp->som_addr + LM_OFFSET(smp))
end_define

begin_comment
comment|/* Start of text segment */
end_comment

begin_define
define|#
directive|define
name|LM_TXTADDR
parameter_list|(
name|smp
parameter_list|)
value|(smp->som_addr == (caddr_t)0 ? PAGSIZ : 0)
end_define

begin_comment
comment|/* Start of run-time relocation_info */
end_comment

begin_define
define|#
directive|define
name|LM_REL
parameter_list|(
name|smp
parameter_list|)
value|((struct relocation_info *) \ 	(smp->som_addr + LM_OFFSET(smp) + LD_REL((smp)->som_dynamic)))
end_define

begin_comment
comment|/* Start of symbols */
end_comment

begin_define
define|#
directive|define
name|LM_SYMBOL
parameter_list|(
name|smp
parameter_list|,
name|i
parameter_list|)
value|((struct nzlist *) \ 	(smp->som_addr + LM_OFFSET(smp) + LD_SYMBOL((smp)->som_dynamic) + \ 		i * (LD_VERSION_NZLIST_P(smp->som_dynamic->d_version) ? \ 			sizeof(struct nzlist) : sizeof(struct nlist))))
end_define

begin_comment
comment|/* Start of hash table */
end_comment

begin_define
define|#
directive|define
name|LM_HASH
parameter_list|(
name|smp
parameter_list|)
value|((struct rrs_hash *) \ 	((smp)->som_addr + LM_OFFSET(smp) + LD_HASH((smp)->som_dynamic)))
end_define

begin_comment
comment|/* Start of strings */
end_comment

begin_define
define|#
directive|define
name|LM_STRINGS
parameter_list|(
name|smp
parameter_list|)
value|((char *) \ 	((smp)->som_addr + LM_OFFSET(smp) + LD_STRINGS((smp)->som_dynamic)))
end_define

begin_comment
comment|/* Start of search paths */
end_comment

begin_define
define|#
directive|define
name|LM_PATHS
parameter_list|(
name|smp
parameter_list|)
value|((char *) \ 	((smp)->som_addr + LM_OFFSET(smp) + LD_PATHS((smp)->som_dynamic)))
end_define

begin_comment
comment|/* End of text */
end_comment

begin_define
define|#
directive|define
name|LM_ETEXT
parameter_list|(
name|smp
parameter_list|)
value|((char *) \ 	((smp)->som_addr + LM_TXTADDR(smp) + LD_TEXTSZ((smp)->som_dynamic)))
end_define

begin_comment
comment|/* Needed shared objects */
end_comment

begin_define
define|#
directive|define
name|LM_NEED
parameter_list|(
name|smp
parameter_list|)
value|((struct sod *) \ 	((smp)->som_addr + LM_TXTADDR(smp) + LD_NEED((smp)->som_dynamic)))
end_define

begin_comment
comment|/* PLT is in data segment, so don't use LM_OFFSET here */
end_comment

begin_define
define|#
directive|define
name|LM_PLT
parameter_list|(
name|smp
parameter_list|)
value|((jmpslot_t *) \ 	((smp)->som_addr + LD_PLT((smp)->som_dynamic)))
end_define

begin_comment
comment|/* Parent of link map */
end_comment

begin_define
define|#
directive|define
name|LM_PARENT
parameter_list|(
name|smp
parameter_list|)
value|(LM_PRIVATE(smp)->spd_parent)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|RELOC_EXTERN_P
end_ifndef

begin_define
define|#
directive|define
name|RELOC_EXTERN_P
parameter_list|(
name|s
parameter_list|)
value|((s)->r_extern)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|RELOC_SYMBOL
end_ifndef

begin_define
define|#
directive|define
name|RELOC_SYMBOL
parameter_list|(
name|s
parameter_list|)
value|((s)->r_symbolnum)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|RELOC_PCREL_P
end_ifndef

begin_define
define|#
directive|define
name|RELOC_PCREL_P
parameter_list|(
name|s
parameter_list|)
value|((s)->r_pcrel)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|char
name|__main_progname
index|[]
init|=
literal|"main"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|main_progname
init|=
name|__main_progname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|us
index|[]
init|=
literal|"/usr/libexec/ld.so"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|__progname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uid_t
name|uid
decl_stmt|,
name|euid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gid_t
name|gid
decl_stmt|,
name|egid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|careful
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|anon_fd
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ld_bind_now
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ld_ignore_missing_objects
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ld_library_path
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ld_preload
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ld_tracing
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ld_suppress_warnings
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ld_warn_non_pure_code
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|so_map
modifier|*
name|link_map_head
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|so_map
modifier|*
name|link_map_tail
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rt_symbol
modifier|*
name|rt_symbol_head
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
modifier|*
name|__dlopen
name|__P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|__dlclose
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
modifier|*
name|__dlsym
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|__dlerror
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|__dlexit
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
modifier|*
name|__dlsym3
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ld_entry
name|ld_entry
init|=
block|{
name|__dlopen
block|,
name|__dlclose
block|,
name|__dlsym
block|,
name|__dlerror
block|,
name|__dlexit
block|,
name|__dlsym3
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|xprintf
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|so_map
modifier|*
name|map_object
name|__P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
expr|struct
name|sod
operator|*
operator|,
expr|struct
name|so_map
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|map_preload
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|map_sods
name|__P
argument_list|(
operator|(
expr|struct
name|so_map
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reloc_dag
name|__P
argument_list|(
operator|(
expr|struct
name|so_map
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|unmap_object
name|__P
argument_list|(
operator|(
expr|struct
name|so_map
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|so_map
modifier|*
name|alloc_link_map
name|__P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
expr|struct
name|sod
operator|*
operator|,
expr|struct
name|so_map
operator|*
operator|,
name|caddr_t
operator|,
expr|struct
name|_dynamic
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_link_map
name|__P
argument_list|(
operator|(
expr|struct
name|so_map
operator|*
operator|,
expr|struct
name|somap_private
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
expr|struct
name|sod
operator|*
operator|,
expr|struct
name|so_map
operator|*
operator|,
name|caddr_t
operator|,
expr|struct
name|_dynamic
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_link_map
name|__P
argument_list|(
operator|(
expr|struct
name|so_map
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|int
name|check_text_reloc
name|__P
argument_list|(
operator|(
expr|struct
name|relocation_info
operator|*
operator|,
expr|struct
name|so_map
operator|*
operator|,
name|caddr_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reloc_map
name|__P
argument_list|(
operator|(
expr|struct
name|so_map
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|reloc_copy
name|__P
argument_list|(
operator|(
expr|struct
name|so_map
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_dag
name|__P
argument_list|(
operator|(
expr|struct
name|so_map
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_sods
name|__P
argument_list|(
operator|(
expr|struct
name|so_list
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_internal_malloc
name|__P
argument_list|(
operator|(
expr|struct
name|_dynamic
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_external_malloc
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|call_map
name|__P
argument_list|(
operator|(
expr|struct
name|so_map
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|findhint
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rtfindlib
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rtfindfile
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|binder_entry
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|binder
name|__P
argument_list|(
operator|(
name|jmpslot_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|nzlist
modifier|*
name|lookup
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
expr|struct
name|so_map
operator|*
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|struct
name|rt_symbol
modifier|*
name|lookup_rts
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|nzlist
modifier|*
name|lookup_in_obj
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|unsigned
name|long
operator|,
expr|struct
name|so_map
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|rt_symbol
modifier|*
name|enter_rts
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|unsigned
name|long
operator|,
name|long
operator|,
name|int
operator|,
name|caddr_t
operator|,
name|long
operator|,
expr|struct
name|so_map
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
modifier|*
name|sym_addr
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|die
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|generror
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|maphints
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|unmaphints
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ld_trace
name|__P
argument_list|(
operator|(
expr|struct
name|so_map
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|rt_readenv
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hinthash
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rtld
name|__P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|crt_ldso
operator|*
operator|,
expr|struct
name|_dynamic
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Compute a hash value for symbol tables.  Don't change this -- the  * algorithm is dictated by the way the linker builds the symbol  * tables in the shared objects.  */
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|long
name|sym_hash
parameter_list|(
name|s
parameter_list|)
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|unsigned
name|long
name|h
decl_stmt|;
name|h
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|!=
literal|'\0'
condition|)
name|h
operator|=
operator|(
name|h
operator|<<
literal|1
operator|)
operator|+
operator|*
name|s
operator|++
expr_stmt|;
return|return
name|h
operator|&
literal|0x7fffffffUL
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|strcmp
parameter_list|(
specifier|register
specifier|const
name|char
modifier|*
name|s1
parameter_list|,
specifier|register
specifier|const
name|char
modifier|*
name|s2
parameter_list|)
block|{
while|while
condition|(
operator|*
name|s1
operator|==
operator|*
name|s2
operator|++
condition|)
if|if
condition|(
operator|*
name|s1
operator|++
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s1
operator|-
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|--
name|s2
operator|)
return|;
block|}
end_function

begin_include
include|#
directive|include
file|"md-static-funcs.c"
end_include

begin_comment
comment|/*  * Called from assembler stub that has set up crtp (passed from crt0)  * and dp (our __DYNAMIC).  */
end_comment

begin_function
name|int
name|rtld
parameter_list|(
name|version
parameter_list|,
name|crtp
parameter_list|,
name|dp
parameter_list|)
name|int
name|version
decl_stmt|;
name|struct
name|crt_ldso
modifier|*
name|crtp
decl_stmt|;
name|struct
name|_dynamic
modifier|*
name|dp
decl_stmt|;
block|{
name|struct
name|relocation_info
modifier|*
name|reloc
decl_stmt|;
name|struct
name|relocation_info
modifier|*
name|reloc_limit
decl_stmt|;
comment|/* End+1 of relocation */
name|struct
name|so_debug
modifier|*
name|ddp
decl_stmt|;
name|struct
name|so_map
modifier|*
name|main_map
decl_stmt|;
name|struct
name|so_map
modifier|*
name|smp
decl_stmt|;
name|char
modifier|*
name|add_paths
decl_stmt|;
comment|/* Check version */
if|if
condition|(
name|version
operator|!=
name|CRT_VERSION_BSD_2
operator|&&
name|version
operator|!=
name|CRT_VERSION_BSD_3
operator|&&
name|version
operator|!=
name|CRT_VERSION_BSD_4
operator|&&
name|version
operator|!=
name|CRT_VERSION_SUN
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Fixup __DYNAMIC structure */
operator|(
name|long
operator|)
name|dp
operator|->
name|d_un
operator|.
name|d_sdt
operator|+=
name|crtp
operator|->
name|crt_ba
expr_stmt|;
comment|/* Relocate ourselves */
name|reloc
operator|=
operator|(
expr|struct
name|relocation_info
operator|*
operator|)
operator|(
name|LD_REL
argument_list|(
name|dp
argument_list|)
operator|+
name|crtp
operator|->
name|crt_ba
operator|)
expr_stmt|;
name|reloc_limit
operator|=
operator|(
expr|struct
name|relocation_info
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|reloc
operator|+
name|LD_RELSZ
argument_list|(
name|dp
argument_list|)
operator|)
expr_stmt|;
while|while
condition|(
name|reloc
operator|<
name|reloc_limit
condition|)
block|{
comment|/* 		 * Objects linked with "-Bsymbolic" (in particular, ld.so 		 * itself) can end up having unused relocation entries at 		 * the end.  These can be detected by the fact that they 		 * have an address of 0. 		 */
if|if
condition|(
name|reloc
operator|->
name|r_address
operator|==
literal|0
condition|)
comment|/* We're done */
break|break;
name|md_relocate_simple
argument_list|(
name|reloc
argument_list|,
name|crtp
operator|->
name|crt_ba
argument_list|,
name|reloc
operator|->
name|r_address
operator|+
name|crtp
operator|->
name|crt_ba
argument_list|)
expr_stmt|;
operator|++
name|reloc
expr_stmt|;
block|}
if|if
condition|(
name|version
operator|>=
name|CRT_VERSION_BSD_4
condition|)
name|__progname
operator|=
name|crtp
operator|->
name|crt_ldso
expr_stmt|;
if|if
condition|(
name|version
operator|>=
name|CRT_VERSION_BSD_3
condition|)
name|main_progname
operator|=
name|crtp
operator|->
name|crt_prog
expr_stmt|;
comment|/* Some buggy versions of crt0.o have crt_ldso filled in as NULL. */
if|if
condition|(
name|__progname
operator|==
name|NULL
condition|)
name|__progname
operator|=
name|us
expr_stmt|;
comment|/* Fill in some fields in _DYNAMIC or crt structure */
if|if
condition|(
name|version
operator|>=
name|CRT_VERSION_BSD_4
condition|)
name|crtp
operator|->
name|crt_ldentry
operator|=
operator|&
name|ld_entry
expr_stmt|;
comment|/* crt */
else|else
name|crtp
operator|->
name|crt_dp
operator|->
name|d_entry
operator|=
operator|&
name|ld_entry
expr_stmt|;
comment|/* _DYNAMIC */
comment|/* Initialize our internal malloc package. */
name|init_internal_malloc
argument_list|(
name|crtp
operator|->
name|crt_dp
argument_list|)
expr_stmt|;
comment|/* Setup out (private) environ variable */
name|environ
operator|=
name|crtp
operator|->
name|crt_ep
expr_stmt|;
comment|/* Get user and group identifiers */
name|uid
operator|=
name|getuid
argument_list|()
expr_stmt|;
name|euid
operator|=
name|geteuid
argument_list|()
expr_stmt|;
name|gid
operator|=
name|getgid
argument_list|()
expr_stmt|;
name|egid
operator|=
name|getegid
argument_list|()
expr_stmt|;
name|careful
operator|=
operator|(
name|uid
operator|!=
name|euid
operator|)
operator|||
operator|(
name|gid
operator|!=
name|egid
operator|)
expr_stmt|;
name|rt_readenv
argument_list|()
expr_stmt|;
name|anon_open
argument_list|()
expr_stmt|;
comment|/* Make a link map entry for the main program */
name|main_map
operator|=
name|alloc_link_map
argument_list|(
name|main_progname
argument_list|,
operator|(
expr|struct
name|sod
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|so_map
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
name|crtp
operator|->
name|crt_dp
argument_list|)
expr_stmt|;
name|LM_PRIVATE
argument_list|(
name|main_map
argument_list|)
operator|->
name|spd_refcount
operator|++
expr_stmt|;
name|LM_PRIVATE
argument_list|(
name|main_map
argument_list|)
operator|->
name|spd_flags
operator||=
name|RTLD_MAIN
expr_stmt|;
comment|/* Make a link map entry for ourselves */
name|smp
operator|=
name|alloc_link_map
argument_list|(
name|us
argument_list|,
operator|(
expr|struct
name|sod
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|so_map
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|caddr_t
operator|)
name|crtp
operator|->
name|crt_ba
argument_list|,
name|dp
argument_list|)
expr_stmt|;
name|LM_PRIVATE
argument_list|(
name|smp
argument_list|)
operator|->
name|spd_refcount
operator|++
expr_stmt|;
name|LM_PRIVATE
argument_list|(
name|smp
argument_list|)
operator|->
name|spd_flags
operator||=
name|RTLD_RTLD
expr_stmt|;
comment|/* 	 * Setup the executable's run path 	 */
if|if
condition|(
name|version
operator|>=
name|CRT_VERSION_BSD_4
condition|)
block|{
name|add_paths
operator|=
name|LM_PATHS
argument_list|(
name|main_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|add_paths
condition|)
name|add_search_path
argument_list|(
name|add_paths
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Setup the directory search list for findshlib.  We use only 	 * the standard search path.  Any extra directories from 	 * LD_LIBRARY_PATH are searched explicitly, in rtfindlib. 	 */
name|std_search_path
argument_list|()
expr_stmt|;
comment|/* Map in LD_PRELOADs before the main program's shared objects so we 	   can intercept those calls */
if|if
condition|(
name|ld_preload
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|map_preload
argument_list|()
operator|==
operator|-
literal|1
condition|)
comment|/* Failed */
name|die
argument_list|()
expr_stmt|;
block|}
comment|/* Map all the shared objects that the main program depends upon */
if|if
condition|(
name|map_sods
argument_list|(
name|main_map
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|die
argument_list|()
expr_stmt|;
if|if
condition|(
name|ld_tracing
condition|)
block|{
comment|/* We're done */
name|ld_trace
argument_list|(
name|link_map_head
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|crtp
operator|->
name|crt_dp
operator|->
name|d_un
operator|.
name|d_sdt
operator|->
name|sdt_loaded
operator|=
name|link_map_head
operator|->
name|som_next
expr_stmt|;
comment|/* Relocate all mapped objects. */
if|if
condition|(
name|reloc_dag
argument_list|(
name|main_map
argument_list|,
name|ld_bind_now
operator|!=
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
comment|/* Failed */
name|die
argument_list|()
expr_stmt|;
comment|/*          * Switch to the same malloc that the program uses.  We do          * this before initializing the loaded objects, because their          * initialization functions may well call malloc, and it won't          * work right until we have set it up. 	 */
name|init_external_malloc
argument_list|()
expr_stmt|;
comment|/* Initialize all mapped objects. */
name|init_dag
argument_list|(
name|main_map
argument_list|)
expr_stmt|;
name|ddp
operator|=
name|crtp
operator|->
name|crt_dp
operator|->
name|d_debug
expr_stmt|;
name|ddp
operator|->
name|dd_cc
operator|=
name|rt_symbol_head
expr_stmt|;
if|if
condition|(
name|ddp
operator|->
name|dd_in_debugger
condition|)
block|{
name|caddr_t
name|addr
init|=
call|(
name|caddr_t
call|)
argument_list|(
operator|(
name|long
operator|)
name|crtp
operator|->
name|crt_bp
operator|&
operator|(
operator|~
operator|(
name|PAGSIZ
operator|-
literal|1
operator|)
operator|)
argument_list|)
decl_stmt|;
comment|/* Set breakpoint for the benefit of debuggers */
if|if
condition|(
name|mprotect
argument_list|(
name|addr
argument_list|,
name|PAGSIZ
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
operator||
name|PROT_EXEC
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|err
argument_list|(
literal|1
argument_list|,
literal|"Cannot set breakpoint (%s)"
argument_list|,
name|main_progname
argument_list|)
expr_stmt|;
block|}
name|md_set_breakpoint
argument_list|(
operator|(
name|long
operator|)
name|crtp
operator|->
name|crt_bp
argument_list|,
operator|(
name|long
operator|*
operator|)
operator|&
name|ddp
operator|->
name|dd_bpt_shadow
argument_list|)
expr_stmt|;
if|if
condition|(
name|mprotect
argument_list|(
name|addr
argument_list|,
name|PAGSIZ
argument_list|,
name|PROT_READ
operator||
name|PROT_EXEC
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|err
argument_list|(
literal|1
argument_list|,
literal|"Cannot re-protect breakpoint (%s)"
argument_list|,
name|main_progname
argument_list|)
expr_stmt|;
block|}
name|ddp
operator|->
name|dd_bpt_addr
operator|=
name|crtp
operator|->
name|crt_bp
expr_stmt|;
if|if
condition|(
name|link_map_head
condition|)
name|ddp
operator|->
name|dd_sym_loaded
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Close the hints file */
name|unmaphints
argument_list|()
expr_stmt|;
comment|/* Close our file descriptor */
operator|(
name|void
operator|)
name|close
argument_list|(
name|crtp
operator|->
name|crt_ldfd
argument_list|)
expr_stmt|;
name|anon_close
argument_list|()
expr_stmt|;
return|return
name|LDSO_VERSION_HAS_DLSYM3
return|;
block|}
end_function

begin_function
name|void
name|ld_trace
parameter_list|(
name|smp
parameter_list|)
name|struct
name|so_map
modifier|*
name|smp
decl_stmt|;
block|{
name|char
modifier|*
name|fmt1
decl_stmt|,
modifier|*
name|fmt2
decl_stmt|,
modifier|*
name|fmt
decl_stmt|,
modifier|*
name|main_local
decl_stmt|;
name|int
name|c
decl_stmt|;
if|if
condition|(
operator|(
name|main_local
operator|=
name|getenv
argument_list|(
literal|"LD_TRACE_LOADED_OBJECTS_PROGNAME"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|main_local
operator|=
literal|""
expr_stmt|;
if|if
condition|(
operator|(
name|fmt1
operator|=
name|getenv
argument_list|(
literal|"LD_TRACE_LOADED_OBJECTS_FMT1"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|fmt1
operator|=
literal|"\t-l%o.%m => %p (%x)\n"
expr_stmt|;
if|if
condition|(
operator|(
name|fmt2
operator|=
name|getenv
argument_list|(
literal|"LD_TRACE_LOADED_OBJECTS_FMT2"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|fmt2
operator|=
literal|"\t%o (%x)\n"
expr_stmt|;
for|for
control|(
init|;
name|smp
condition|;
name|smp
operator|=
name|smp
operator|->
name|som_next
control|)
block|{
name|struct
name|sod
modifier|*
name|sodp
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|path
decl_stmt|;
if|if
condition|(
operator|(
name|sodp
operator|=
name|smp
operator|->
name|som_sod
operator|)
operator|==
name|NULL
condition|)
continue|continue;
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|sodp
operator|->
name|sod_name
expr_stmt|;
if|if
condition|(
name|LM_PARENT
argument_list|(
name|smp
argument_list|)
condition|)
name|name
operator|+=
operator|(
name|long
operator|)
name|LM_LDBASE
argument_list|(
name|LM_PARENT
argument_list|(
name|smp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|path
operator|=
name|smp
operator|->
name|som_path
operator|)
operator|==
name|NULL
condition|)
name|path
operator|=
literal|"not found"
expr_stmt|;
name|fmt
operator|=
name|sodp
operator|->
name|sod_library
condition|?
name|fmt1
else|:
name|fmt2
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|fmt
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
default|default:
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'\\'
case|:
switch|switch
condition|(
name|c
operator|=
operator|*
name|fmt
condition|)
block|{
case|case
literal|'\0'
case|:
continue|continue;
case|case
literal|'n'
case|:
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'%'
case|:
switch|switch
condition|(
name|c
operator|=
operator|*
name|fmt
condition|)
block|{
case|case
literal|'\0'
case|:
continue|continue;
case|case
literal|'%'
case|:
default|default:
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|main_local
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|main_progname
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|printf
argument_list|(
literal|"%d"
argument_list|,
name|sodp
operator|->
name|sod_major
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|printf
argument_list|(
literal|"%d"
argument_list|,
name|sodp
operator|->
name|sod_minor
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|path
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|printf
argument_list|(
literal|"%p"
argument_list|,
name|smp
operator|->
name|som_addr
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
block|}
operator|++
name|fmt
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Allocate a new link map and return a pointer to it.  *  * PATH is the pathname of the shared object.  *  * SODP is a pointer to the shared object dependency structure responsible  * for causing the new object to be loaded.  PARENT is the shared object  * into which SODP points.  Both can be NULL if the new object is not  * being loaded as a result of a shared object dependency.  *  * ADDR is the address at which the object has been mapped.  DP is a pointer  * to its _dynamic structure.  */
end_comment

begin_function
specifier|static
name|struct
name|so_map
modifier|*
name|alloc_link_map
parameter_list|(
name|path
parameter_list|,
name|sodp
parameter_list|,
name|parent
parameter_list|,
name|addr
parameter_list|,
name|dp
parameter_list|)
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|struct
name|sod
modifier|*
name|sodp
decl_stmt|;
name|struct
name|so_map
modifier|*
name|parent
decl_stmt|;
name|caddr_t
name|addr
decl_stmt|;
name|struct
name|_dynamic
modifier|*
name|dp
decl_stmt|;
block|{
name|struct
name|so_map
modifier|*
name|smp
decl_stmt|;
name|struct
name|somap_private
modifier|*
name|smpp
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
comment|/* { */
name|xprintf
argument_list|(
literal|"alloc_link_map: \"%s\" at %p\n"
argument_list|,
name|path
argument_list|,
name|addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* } */
name|smp
operator|=
operator|(
expr|struct
name|so_map
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|so_map
argument_list|)
argument_list|)
expr_stmt|;
name|smpp
operator|=
operator|(
expr|struct
name|somap_private
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|somap_private
argument_list|)
argument_list|)
expr_stmt|;
name|init_link_map
argument_list|(
name|smp
argument_list|,
name|smpp
argument_list|,
name|path
argument_list|,
name|sodp
argument_list|,
name|parent
argument_list|,
name|addr
argument_list|,
name|dp
argument_list|)
expr_stmt|;
comment|/* Link the new entry into the list of link maps */
name|smpp
operator|->
name|spd_prev
operator|=
name|link_map_tail
expr_stmt|;
if|if
condition|(
name|link_map_tail
operator|==
name|NULL
condition|)
comment|/* First link map entered into list */
name|link_map_head
operator|=
name|link_map_tail
operator|=
name|smp
expr_stmt|;
else|else
block|{
comment|/* Append to end of list */
name|link_map_tail
operator|->
name|som_next
operator|=
name|smp
expr_stmt|;
name|link_map_tail
operator|=
name|smp
expr_stmt|;
block|}
return|return
name|smp
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize a link map entry that has already been allocated.  */
end_comment

begin_function
specifier|static
name|void
name|init_link_map
parameter_list|(
name|smp
parameter_list|,
name|smpp
parameter_list|,
name|path
parameter_list|,
name|sodp
parameter_list|,
name|parent
parameter_list|,
name|addr
parameter_list|,
name|dp
parameter_list|)
name|struct
name|so_map
modifier|*
name|smp
decl_stmt|;
name|struct
name|somap_private
modifier|*
name|smpp
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|struct
name|sod
modifier|*
name|sodp
decl_stmt|;
name|struct
name|so_map
modifier|*
name|parent
decl_stmt|;
name|caddr_t
name|addr
decl_stmt|;
name|struct
name|_dynamic
modifier|*
name|dp
decl_stmt|;
block|{
name|memset
argument_list|(
name|smp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|smp
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|smpp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|smpp
argument_list|)
expr_stmt|;
name|smp
operator|->
name|som_spd
operator|=
operator|(
name|caddr_t
operator|)
name|smpp
expr_stmt|;
name|smp
operator|->
name|som_addr
operator|=
name|addr
expr_stmt|;
name|smp
operator|->
name|som_path
operator|=
name|path
condition|?
name|strdup
argument_list|(
name|path
argument_list|)
else|:
name|NULL
expr_stmt|;
name|smp
operator|->
name|som_sod
operator|=
name|sodp
expr_stmt|;
name|smp
operator|->
name|som_dynamic
operator|=
name|dp
expr_stmt|;
name|smpp
operator|->
name|spd_parent
operator|=
name|parent
expr_stmt|;
ifdef|#
directive|ifdef
name|SUN_COMPAT
name|smpp
operator|->
name|spd_offset
operator|=
operator|(
name|addr
operator|==
literal|0
operator|&&
name|dp
operator|&&
name|dp
operator|->
name|d_version
operator|==
name|LD_VERSION_SUN
operator|)
condition|?
name|PAGSIZ
else|:
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Remove the specified link map entry from the list of link maps, and free  * the associated storage.  */
end_comment

begin_function
specifier|static
name|void
name|free_link_map
parameter_list|(
name|smp
parameter_list|)
name|struct
name|so_map
modifier|*
name|smp
decl_stmt|;
block|{
name|struct
name|somap_private
modifier|*
name|smpp
init|=
name|LM_PRIVATE
argument_list|(
name|smp
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
comment|/* { */
name|xprintf
argument_list|(
literal|"free_link_map: \"%s\"\n"
argument_list|,
name|smp
operator|->
name|som_path
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* } */
if|if
condition|(
name|smpp
operator|->
name|spd_prev
operator|==
name|NULL
condition|)
comment|/* Removing first entry in list */
name|link_map_head
operator|=
name|smp
operator|->
name|som_next
expr_stmt|;
else|else
comment|/* Update link of previous entry */
name|smpp
operator|->
name|spd_prev
operator|->
name|som_next
operator|=
name|smp
operator|->
name|som_next
expr_stmt|;
if|if
condition|(
name|smp
operator|->
name|som_next
operator|==
name|NULL
condition|)
comment|/* Removing last entry in list */
name|link_map_tail
operator|=
name|smpp
operator|->
name|spd_prev
expr_stmt|;
else|else
comment|/* Update back link of next entry */
name|LM_PRIVATE
argument_list|(
name|smp
operator|->
name|som_next
argument_list|)
operator|->
name|spd_prev
operator|=
name|smpp
operator|->
name|spd_prev
expr_stmt|;
if|if
condition|(
name|smp
operator|->
name|som_path
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|smp
operator|->
name|som_path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|smpp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|smp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Map the shared object specified by PATH into memory, if it is not  * already mapped.  Increment the object's reference count, and return a  * pointer to its link map.  *  * As a special case, if PATH is NULL, it is taken to refer to the main  * program.  *  * SODP is a pointer to the shared object dependency structure that caused  * this object to be requested.  PARENT is a pointer to the link map of  * the shared object containing that structure.  For a shared object not  * being mapped as a result of a shared object dependency, these pointers  * should be NULL.  An example of this is a shared object that is explicitly  * loaded via dlopen().  *  * The return value is a pointer to the link map for the requested object.  * If the operation failed, the return value is NULL.  In that case, an  * error message can be retrieved by calling dlerror().  */
end_comment

begin_function
specifier|static
name|struct
name|so_map
modifier|*
name|map_object
parameter_list|(
name|path
parameter_list|,
name|sodp
parameter_list|,
name|parent
parameter_list|)
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|struct
name|sod
modifier|*
name|sodp
decl_stmt|;
name|struct
name|so_map
modifier|*
name|parent
decl_stmt|;
block|{
name|struct
name|so_map
modifier|*
name|smp
decl_stmt|;
name|struct
name|stat
name|statbuf
decl_stmt|;
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
comment|/* Special case for the main program itself */
name|smp
operator|=
name|link_map_head
expr_stmt|;
else|else
block|{
comment|/* 		 * Check whether the shared object is already mapped. 		 * We check first for an exact match by pathname.  That 		 * will detect the usual case.  If no match is found by 		 * pathname, then stat the file, and check for a match by 		 * device and inode.  That will detect the less common case 		 * involving multiple links to the same library. 		 */
for|for
control|(
name|smp
operator|=
name|link_map_head
init|;
name|smp
operator|!=
name|NULL
condition|;
name|smp
operator|=
name|smp
operator|->
name|som_next
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|LM_PRIVATE
argument_list|(
name|smp
argument_list|)
operator|->
name|spd_flags
operator|&
operator|(
name|RTLD_MAIN
operator||
name|RTLD_RTLD
operator|)
operator|)
operator|&&
name|smp
operator|->
name|som_path
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|smp
operator|->
name|som_path
argument_list|,
name|path
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|smp
operator|==
name|NULL
condition|)
block|{
comment|/* Check for a match by device and inode */
if|if
condition|(
name|stat
argument_list|(
name|path
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|generror
argument_list|(
literal|"cannot stat \"%s\" : %s"
argument_list|,
name|path
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
for|for
control|(
name|smp
operator|=
name|link_map_head
init|;
name|smp
operator|!=
name|NULL
condition|;
name|smp
operator|=
name|smp
operator|->
name|som_next
control|)
block|{
name|struct
name|somap_private
modifier|*
name|smpp
init|=
name|LM_PRIVATE
argument_list|(
name|smp
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|smpp
operator|->
name|spd_flags
operator|&
operator|(
name|RTLD_MAIN
operator||
name|RTLD_RTLD
operator|)
operator|)
operator|&&
name|smpp
operator|->
name|spd_ino
operator|==
name|statbuf
operator|.
name|st_ino
operator|&&
name|smpp
operator|->
name|spd_dev
operator|==
name|statbuf
operator|.
name|st_dev
condition|)
break|break;
block|}
block|}
block|}
if|if
condition|(
name|smp
operator|==
name|NULL
condition|)
block|{
comment|/* We must map the object */
name|struct
name|_dynamic
modifier|*
name|dp
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|caddr_t
name|addr
decl_stmt|;
name|struct
name|exec
name|hdr
decl_stmt|;
name|struct
name|somap_private
modifier|*
name|smpp
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|path
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|generror
argument_list|(
literal|"open failed for \"%s\" : %s"
argument_list|,
name|path
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
operator|&
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
condition|)
block|{
name|generror
argument_list|(
literal|"header read failed for \"%s\""
argument_list|,
name|path
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|N_BADMAG
argument_list|(
name|hdr
argument_list|)
condition|)
block|{
name|generror
argument_list|(
literal|"bad magic number in \"%s\""
argument_list|,
name|path
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* 		 * Map the entire address space of the object.  It is 		 * tempting to map just the text segment at first, in 		 * order to avoid having to use mprotect to change the 		 * protections of the data segment.  But that would not 		 * be correct.  Mmap might find a group of free pages 		 * large enough to hold the text segment, but not large 		 * enough for the entire object.  When we then mapped 		 * in the data and BSS segments, they would either be 		 * non-contiguous with the text segment (if we didn't 		 * specify MAP_FIXED), or they would map over some 		 * previously mapped region (if we did use MAP_FIXED). 		 * The only way we can be sure of getting a contigous 		 * region that is large enough is to map the entire 		 * region at once. 		 */
if|if
condition|(
operator|(
name|addr
operator|=
name|mmap
argument_list|(
literal|0
argument_list|,
name|hdr
operator|.
name|a_text
operator|+
name|hdr
operator|.
name|a_data
operator|+
name|hdr
operator|.
name|a_bss
argument_list|,
name|PROT_READ
operator||
name|PROT_EXEC
argument_list|,
name|MAP_COPY
argument_list|,
name|fd
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|(
name|caddr_t
operator|)
operator|-
literal|1
condition|)
block|{
name|generror
argument_list|(
literal|"mmap failed for \"%s\" : %s"
argument_list|,
name|path
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
comment|/* Change the data segment to writable */
if|if
condition|(
name|mprotect
argument_list|(
name|addr
operator|+
name|hdr
operator|.
name|a_text
argument_list|,
name|hdr
operator|.
name|a_data
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
operator||
name|PROT_EXEC
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|generror
argument_list|(
literal|"mprotect failed for \"%s\" : %s"
argument_list|,
name|path
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|munmap
argument_list|(
name|addr
argument_list|,
name|hdr
operator|.
name|a_text
operator|+
name|hdr
operator|.
name|a_data
operator|+
name|hdr
operator|.
name|a_bss
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Map in pages of zeros for the BSS segment */
if|if
condition|(
name|mmap
argument_list|(
name|addr
operator|+
name|hdr
operator|.
name|a_text
operator|+
name|hdr
operator|.
name|a_data
argument_list|,
name|hdr
operator|.
name|a_bss
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
operator||
name|PROT_EXEC
argument_list|,
name|MAP_ANON
operator||
name|MAP_COPY
operator||
name|MAP_FIXED
argument_list|,
name|anon_fd
argument_list|,
literal|0
argument_list|)
operator|==
operator|(
name|caddr_t
operator|)
operator|-
literal|1
condition|)
block|{
name|generror
argument_list|(
literal|"mmap failed for \"%s\" : %s"
argument_list|,
name|path
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|munmap
argument_list|(
name|addr
argument_list|,
name|hdr
operator|.
name|a_text
operator|+
name|hdr
operator|.
name|a_data
operator|+
name|hdr
operator|.
name|a_bss
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Assume _DYNAMIC is the first data item */
name|dp
operator|=
operator|(
expr|struct
name|_dynamic
operator|*
operator|)
operator|(
name|addr
operator|+
name|hdr
operator|.
name|a_text
operator|)
expr_stmt|;
comment|/* Fixup __DYNAMIC structure */
operator|(
name|long
operator|)
name|dp
operator|->
name|d_un
operator|.
name|d_sdt
operator|+=
operator|(
name|long
operator|)
name|addr
expr_stmt|;
name|smp
operator|=
name|alloc_link_map
argument_list|(
name|path
argument_list|,
name|sodp
argument_list|,
name|parent
argument_list|,
name|addr
argument_list|,
name|dp
argument_list|)
expr_stmt|;
comment|/* save segment sizes for unmap. */
name|smpp
operator|=
name|LM_PRIVATE
argument_list|(
name|smp
argument_list|)
expr_stmt|;
name|smpp
operator|->
name|a_text
operator|=
name|hdr
operator|.
name|a_text
expr_stmt|;
name|smpp
operator|->
name|a_data
operator|=
name|hdr
operator|.
name|a_data
expr_stmt|;
name|smpp
operator|->
name|a_bss
operator|=
name|hdr
operator|.
name|a_bss
expr_stmt|;
comment|/* 		 * Save the device and inode, so we can detect multiple links 		 * to the same library.  Note, if we reach this point, then 		 * statbuf is guaranteed to have been filled in. 		 */
name|smpp
operator|->
name|spd_dev
operator|=
name|statbuf
operator|.
name|st_dev
expr_stmt|;
name|smpp
operator|->
name|spd_ino
operator|=
name|statbuf
operator|.
name|st_ino
expr_stmt|;
block|}
name|LM_PRIVATE
argument_list|(
name|smp
argument_list|)
operator|->
name|spd_refcount
operator|++
expr_stmt|;
if|if
condition|(
name|LM_PRIVATE
argument_list|(
name|smp
argument_list|)
operator|->
name|spd_refcount
operator|==
literal|1
condition|)
block|{
comment|/* First use of object */
comment|/* 		 * Recursively map all of the shared objects that this 		 * one depends upon. 		 */
if|if
condition|(
name|map_sods
argument_list|(
name|smp
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* Failed */
name|unmap_object
argument_list|(
name|smp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Clean up */
return|return
name|NULL
return|;
block|}
block|}
return|return
name|smp
return|;
block|}
end_function

begin_comment
comment|/*  * Map all the shared libraries named in the LD_PRELOAD environment  * variable.  *  * Returns 0 on success, -1 on failure.  On failure, an error message can  * be gotten via dlerror().  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|map_preload
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
block|{
name|char
modifier|*
name|ld_name
init|=
name|ld_preload
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
while|while
condition|(
operator|(
name|name
operator|=
name|strsep
argument_list|(
operator|&
name|ld_name
argument_list|,
literal|":"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|path
init|=
name|NULL
decl_stmt|;
name|struct
name|so_map
modifier|*
name|smp
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|*
name|name
operator|!=
literal|'\0'
condition|)
block|{
name|path
operator|=
operator|(
name|strchr
argument_list|(
name|name
argument_list|,
literal|'/'
argument_list|)
operator|!=
name|NULL
operator|)
condition|?
name|strdup
argument_list|(
name|name
argument_list|)
else|:
name|rtfindfile
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
block|{
name|generror
argument_list|(
literal|"Can't find LD_PRELOAD shared"
literal|" library \"%s\""
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|smp
operator|=
name|map_object
argument_list|(
name|path
argument_list|,
operator|(
expr|struct
name|sod
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|so_map
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ld_name
operator|!=
name|NULL
condition|)
operator|*
operator|(
name|ld_name
operator|-
literal|1
operator|)
operator|=
literal|':'
expr_stmt|;
if|if
condition|(
name|smp
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * We don't bother to unmap already-loaded libraries 			 * on failure, because in that case the program is 			 * about to die anyway. 			 */
return|return
operator|-
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_comment
comment|/*  * Map all of the shared objects that a given object depends upon.  PARENT is  * a pointer to the link map for the shared object whose dependencies are  * to be mapped.  *  * Returns 0 on success.  Returns -1 on failure.  In that case, an error  * message can be retrieved by calling dlerror().  */
end_comment

begin_function
specifier|static
name|int
name|map_sods
parameter_list|(
name|parent
parameter_list|)
name|struct
name|so_map
modifier|*
name|parent
decl_stmt|;
block|{
name|struct
name|somap_private
modifier|*
name|parpp
init|=
name|LM_PRIVATE
argument_list|(
name|parent
argument_list|)
decl_stmt|;
name|struct
name|so_list
modifier|*
modifier|*
name|soltail
init|=
operator|&
name|parpp
operator|->
name|spd_children
decl_stmt|;
name|long
name|next
init|=
name|LD_NEED
argument_list|(
name|parent
operator|->
name|som_dynamic
argument_list|)
decl_stmt|;
while|while
condition|(
name|next
operator|!=
literal|0
condition|)
block|{
name|struct
name|sod
modifier|*
name|sodp
init|=
operator|(
expr|struct
name|sod
operator|*
operator|)
operator|(
name|LM_LDBASE
argument_list|(
name|parent
argument_list|)
operator|+
name|next
operator|)
decl_stmt|;
name|char
modifier|*
name|name
init|=
operator|(
name|char
operator|*
operator|)
operator|(
name|LM_LDBASE
argument_list|(
name|parent
argument_list|)
operator|+
name|sodp
operator|->
name|sod_name
operator|)
decl_stmt|;
name|char
modifier|*
name|path
init|=
name|NULL
decl_stmt|;
name|struct
name|so_map
modifier|*
name|smp
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|sodp
operator|->
name|sod_library
condition|)
block|{
name|path
operator|=
name|rtfindlib
argument_list|(
name|name
argument_list|,
name|sodp
operator|->
name|sod_major
argument_list|,
name|sodp
operator|->
name|sod_minor
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|==
name|NULL
operator|&&
operator|!
name|ld_tracing
condition|)
block|{
name|generror
argument_list|(
literal|"Can't find shared library"
literal|" \"lib%s.so.%d.%d\""
argument_list|,
name|name
argument_list|,
name|sodp
operator|->
name|sod_major
argument_list|,
name|sodp
operator|->
name|sod_minor
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|careful
operator|&&
name|name
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
block|{
name|generror
argument_list|(
literal|"Shared library path must start"
literal|" with \"/\" for \"%s\""
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
name|path
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|path
operator|!=
name|NULL
condition|)
block|{
name|smp
operator|=
name|map_object
argument_list|(
name|path
argument_list|,
name|sodp
argument_list|,
name|parent
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|smp
operator|!=
name|NULL
condition|)
block|{
name|struct
name|so_list
modifier|*
name|solp
init|=
operator|(
expr|struct
name|so_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|so_list
argument_list|)
argument_list|)
decl_stmt|;
name|solp
operator|->
name|sol_map
operator|=
name|smp
expr_stmt|;
name|solp
operator|->
name|sol_next
operator|=
name|NULL
expr_stmt|;
operator|*
name|soltail
operator|=
name|solp
expr_stmt|;
name|soltail
operator|=
operator|&
name|solp
operator|->
name|sol_next
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ld_tracing
condition|)
block|{
comment|/* 			 * Allocate a dummy map entry so that we will get the 			 * "not found" message. 			 */
operator|(
name|void
operator|)
name|alloc_link_map
argument_list|(
name|NULL
argument_list|,
name|sodp
argument_list|,
name|parent
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ld_ignore_missing_objects
condition|)
block|{
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
comment|/* 			 * Call __dlerror() even it we're not going to use 			 * the message, in order to clear the saved message. 			 */
name|msg
operator|=
name|__dlerror
argument_list|()
expr_stmt|;
comment|/* Should never be NULL */
if|if
condition|(
operator|!
name|ld_suppress_warnings
condition|)
name|warnx
argument_list|(
literal|"warning: %s"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Give up */
break|break;
name|next
operator|=
name|sodp
operator|->
name|sod_next
expr_stmt|;
block|}
if|if
condition|(
name|next
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Oh drat, we have to clean up a mess. 		 * 		 * We failed to load a shared object that we depend upon. 		 * So now we have to unload any dependencies that we had 		 * already successfully loaded prior to the error. 		 * 		 * Cleaning up doesn't matter so much for the initial 		 * loading of the program, since any failure is going to 		 * terminate the program anyway.  But it is very important 		 * to clean up properly when something is being loaded 		 * via dlopen(). 		 */
name|struct
name|so_list
modifier|*
name|solp
decl_stmt|;
while|while
condition|(
operator|(
name|solp
operator|=
name|parpp
operator|->
name|spd_children
operator|)
operator|!=
name|NULL
condition|)
block|{
name|unmap_object
argument_list|(
name|solp
operator|->
name|sol_map
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|parpp
operator|->
name|spd_children
operator|=
name|solp
operator|->
name|sol_next
expr_stmt|;
name|free
argument_list|(
name|solp
argument_list|)
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Relocate the DAG of shared objects rooted at the given link map  * entry.  Returns 0 on success, or -1 on failure.  On failure, an  * error message can be retrieved via dlerror().  */
end_comment

begin_function
specifier|static
name|int
name|reloc_dag
parameter_list|(
name|root
parameter_list|,
name|bind_now
parameter_list|)
name|struct
name|so_map
modifier|*
name|root
decl_stmt|;
name|int
name|bind_now
decl_stmt|;
block|{
name|struct
name|so_map
modifier|*
name|smp
decl_stmt|;
comment|/* 	 * Relocate all newly-loaded objects.  We avoid recursion for this 	 * step by taking advantage of a few facts.  This function is called 	 * only when there are in fact some newly-loaded objects to process. 	 * Furthermore, all newly-loaded objects will have their link map 	 * entries at the end of the link map list.  And, the root of the 	 * tree of objects just loaded will have been the first to be loaded 	 * and therefore the first new object in the link map list.  Finally, 	 * we take advantage of the fact that we can relocate the newly-loaded 	 * objects in any order. 	 * 	 * All these facts conspire to let us simply loop over the tail 	 * portion of the link map list, relocating each object so 	 * encountered. 	 */
for|for
control|(
name|smp
operator|=
name|root
init|;
name|smp
operator|!=
name|NULL
condition|;
name|smp
operator|=
name|smp
operator|->
name|som_next
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|LM_PRIVATE
argument_list|(
name|smp
argument_list|)
operator|->
name|spd_flags
operator|&
name|RTLD_RTLD
operator|)
condition|)
block|{
if|if
condition|(
name|reloc_map
argument_list|(
name|smp
argument_list|,
name|bind_now
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|/* 	 * Copy any relocated initialized data.  Again, we can just loop 	 * over the appropriate portion of the link map list. 	 */
for|for
control|(
name|smp
operator|=
name|root
init|;
name|smp
operator|!=
name|NULL
condition|;
name|smp
operator|=
name|smp
operator|->
name|som_next
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|LM_PRIVATE
argument_list|(
name|smp
argument_list|)
operator|->
name|spd_flags
operator|&
name|RTLD_RTLD
operator|)
condition|)
name|reloc_copy
argument_list|(
name|smp
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Remove a reference to the shared object specified by SMP.  If no  * references remain, unmap the object and, recursively, its descendents.  * This function also takes care of calling the finalization routines for  * objects that are removed.  *  * If KEEP is true, then the actual calls to munmap() are skipped,  * and the object is kept in memory.  That is used only for finalization,  * from dlexit(), when the program is exiting.  There are two reasons  * for it.  First, the program is exiting and there is no point in  * spending the time to explicitly unmap its shared objects.  Second,  * even after dlexit() has been called, there are still a couple of  * calls that are made to functions in libc.  (This is really a bug  * in crt0.)  So libc and the main program, at least, must remain  * mapped in that situation.  *  * Under no reasonable circumstances should this function fail.  If  * anything goes wrong, we consider it an internal error, and report  * it with err().  */
end_comment

begin_function
specifier|static
name|void
name|unmap_object
parameter_list|(
name|smp
parameter_list|,
name|keep
parameter_list|)
name|struct
name|so_map
modifier|*
name|smp
decl_stmt|;
name|int
name|keep
decl_stmt|;
block|{
name|struct
name|somap_private
modifier|*
name|smpp
init|=
name|LM_PRIVATE
argument_list|(
name|smp
argument_list|)
decl_stmt|;
name|smpp
operator|->
name|spd_refcount
operator|--
expr_stmt|;
if|if
condition|(
name|smpp
operator|->
name|spd_refcount
operator|==
literal|0
condition|)
block|{
comment|/* Finished with this object */
name|struct
name|so_list
modifier|*
name|solp
decl_stmt|;
if|if
condition|(
name|smpp
operator|->
name|spd_flags
operator|&
name|RTLD_INIT
condition|)
block|{
comment|/* Was initialized */
comment|/* 			 * Call the object's finalization routine.  For 			 * backward compatibility, we first try to call 			 * ".fini".  If that does not exist, we call 			 * "__fini". 			 */
if|if
condition|(
name|call_map
argument_list|(
name|smp
argument_list|,
literal|".fini"
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|call_map
argument_list|(
name|smp
argument_list|,
literal|"__fini"
argument_list|)
expr_stmt|;
block|}
comment|/* Recursively unreference the object's descendents */
while|while
condition|(
operator|(
name|solp
operator|=
name|smpp
operator|->
name|spd_children
operator|)
operator|!=
name|NULL
condition|)
block|{
name|unmap_object
argument_list|(
name|solp
operator|->
name|sol_map
argument_list|,
name|keep
argument_list|)
expr_stmt|;
name|smpp
operator|->
name|spd_children
operator|=
name|solp
operator|->
name|sol_next
expr_stmt|;
name|free
argument_list|(
name|solp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|keep
condition|)
block|{
comment|/* Unmap the object from memory */
if|if
condition|(
name|munmap
argument_list|(
name|smp
operator|->
name|som_addr
argument_list|,
name|smpp
operator|->
name|a_text
operator|+
name|smpp
operator|->
name|a_data
operator|+
name|smpp
operator|->
name|a_bss
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"internal error 1: munmap failed"
argument_list|)
expr_stmt|;
comment|/* Unlink and free the object's link map entry */
name|free_link_map
argument_list|(
name|smp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|check_text_reloc
parameter_list|(
name|r
parameter_list|,
name|smp
parameter_list|,
name|addr
parameter_list|)
name|struct
name|relocation_info
modifier|*
name|r
decl_stmt|;
name|struct
name|so_map
modifier|*
name|smp
decl_stmt|;
name|caddr_t
name|addr
decl_stmt|;
block|{
name|char
modifier|*
name|sym
decl_stmt|;
if|if
condition|(
name|addr
operator|>=
name|LM_ETEXT
argument_list|(
name|smp
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|RELOC_EXTERN_P
argument_list|(
name|r
argument_list|)
condition|)
name|sym
operator|=
name|LM_STRINGS
argument_list|(
name|smp
argument_list|)
operator|+
name|LM_SYMBOL
argument_list|(
name|smp
argument_list|,
name|RELOC_SYMBOL
argument_list|(
name|r
argument_list|)
argument_list|)
operator|->
name|nz_strx
expr_stmt|;
else|else
name|sym
operator|=
literal|""
expr_stmt|;
if|if
condition|(
operator|!
name|ld_suppress_warnings
operator|&&
name|ld_warn_non_pure_code
condition|)
name|warnx
argument_list|(
literal|"warning: non pure code in %s at %x (%s)"
argument_list|,
name|smp
operator|->
name|som_path
argument_list|,
name|r
operator|->
name|r_address
argument_list|,
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|smp
operator|->
name|som_write
operator|==
literal|0
operator|&&
name|mprotect
argument_list|(
name|smp
operator|->
name|som_addr
operator|+
name|LM_TXTADDR
argument_list|(
name|smp
argument_list|)
argument_list|,
name|LD_TEXTSZ
argument_list|(
name|smp
operator|->
name|som_dynamic
argument_list|)
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
operator||
name|PROT_EXEC
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|generror
argument_list|(
literal|"mprotect failed for \"%s\" : %s"
argument_list|,
name|smp
operator|->
name|som_path
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|smp
operator|->
name|som_write
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|reloc_map
parameter_list|(
name|smp
parameter_list|,
name|bind_now
parameter_list|)
name|struct
name|so_map
modifier|*
name|smp
decl_stmt|;
name|int
name|bind_now
decl_stmt|;
block|{
comment|/* 	 * Caching structure for reducing the number of calls to 	 * lookup() during relocation. 	 * 	 * While relocating a given shared object, the dynamic linker 	 * maintains a caching vector that is directly indexed by 	 * the symbol number in the relocation entry.  The first time 	 * a given symbol is looked up, the caching vector is 	 * filled in with a pointer to the symbol table entry, and 	 * a pointer to the so_map of the shared object in which the 	 * symbol was defined.  On subsequent uses of the same symbol, 	 * that information is retrieved directly from the caching 	 * vector, without calling lookup() again. 	 * 	 * A symbol that is referenced in a relocation entry is 	 * typically referenced in many relocation entries, so this 	 * caching reduces the number of calls to lookup() 	 * dramatically.  The overall improvement in the speed of 	 * dynamic linking is also dramatic -- as much as a factor 	 * of three for programs that use many shared libaries. 	 */
struct|struct
name|cacheent
block|{
name|struct
name|nzlist
modifier|*
name|np
decl_stmt|;
comment|/* Pointer to symbol entry */
name|struct
name|so_map
modifier|*
name|src_map
decl_stmt|;
comment|/* Shared object that defined symbol */
block|}
struct|;
name|struct
name|_dynamic
modifier|*
name|dp
init|=
name|smp
operator|->
name|som_dynamic
decl_stmt|;
name|struct
name|relocation_info
modifier|*
name|r
init|=
name|LM_REL
argument_list|(
name|smp
argument_list|)
decl_stmt|;
name|struct
name|relocation_info
modifier|*
name|rend
init|=
name|r
operator|+
name|LD_RELSZ
argument_list|(
name|dp
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|r
argument_list|)
decl_stmt|;
name|long
name|symbolbase
init|=
operator|(
name|long
operator|)
name|LM_SYMBOL
argument_list|(
name|smp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|char
modifier|*
name|stringbase
init|=
name|LM_STRINGS
argument_list|(
name|smp
argument_list|)
decl_stmt|;
name|int
name|symsize
init|=
name|LD_VERSION_NZLIST_P
argument_list|(
name|dp
operator|->
name|d_version
argument_list|)
condition|?
sizeof|sizeof
argument_list|(
expr|struct
name|nzlist
argument_list|)
else|:
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
decl_stmt|;
name|long
name|numsyms
init|=
name|LD_STABSZ
argument_list|(
name|dp
argument_list|)
operator|/
name|symsize
decl_stmt|;
name|size_t
name|cachebytes
init|=
name|numsyms
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|cacheent
argument_list|)
decl_stmt|;
name|struct
name|cacheent
modifier|*
name|symcache
init|=
operator|(
expr|struct
name|cacheent
operator|*
operator|)
name|alloca
argument_list|(
name|cachebytes
argument_list|)
decl_stmt|;
if|if
condition|(
name|symcache
operator|==
name|NULL
condition|)
block|{
name|generror
argument_list|(
literal|"Cannot allocate symbol caching vector for %s"
argument_list|,
name|smp
operator|->
name|som_path
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|bzero
argument_list|(
name|symcache
argument_list|,
name|cachebytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|LD_PLTSZ
argument_list|(
name|dp
argument_list|)
condition|)
name|md_fix_jmpslot
argument_list|(
name|LM_PLT
argument_list|(
name|smp
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|LM_PLT
argument_list|(
name|smp
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|binder_entry
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|r
operator|<
name|rend
condition|;
name|r
operator|++
control|)
block|{
name|char
modifier|*
name|sym
decl_stmt|;
name|caddr_t
name|addr
decl_stmt|;
comment|/* 		 * Objects linked with "-Bsymbolic" can end up having unused 		 * relocation entries at the end.  These can be detected by 		 * the fact that they have an address of 0. 		 */
if|if
condition|(
name|r
operator|->
name|r_address
operator|==
literal|0
condition|)
comment|/* Finished relocating this object */
break|break;
name|addr
operator|=
name|smp
operator|->
name|som_addr
operator|+
name|r
operator|->
name|r_address
expr_stmt|;
if|if
condition|(
name|check_text_reloc
argument_list|(
name|r
argument_list|,
name|smp
argument_list|,
name|addr
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|RELOC_EXTERN_P
argument_list|(
name|r
argument_list|)
condition|)
block|{
name|struct
name|so_map
modifier|*
name|src_map
init|=
name|NULL
decl_stmt|;
name|struct
name|nzlist
modifier|*
name|p
decl_stmt|,
modifier|*
name|np
decl_stmt|;
name|long
name|relocation
decl_stmt|;
if|if
condition|(
name|RELOC_JMPTAB_P
argument_list|(
name|r
argument_list|)
operator|&&
operator|!
name|bind_now
condition|)
continue|continue;
name|p
operator|=
operator|(
expr|struct
name|nzlist
operator|*
operator|)
operator|(
name|symbolbase
operator|+
name|symsize
operator|*
name|RELOC_SYMBOL
argument_list|(
name|r
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|nz_type
operator|==
operator|(
name|N_SETV
operator|+
name|N_EXT
operator|)
condition|)
name|src_map
operator|=
name|smp
expr_stmt|;
name|sym
operator|=
name|stringbase
operator|+
name|p
operator|->
name|nz_strx
expr_stmt|;
comment|/* 			 * Look up the symbol, checking the caching 			 * vector first. 			 */
name|np
operator|=
name|symcache
index|[
name|RELOC_SYMBOL
argument_list|(
name|r
argument_list|)
index|]
operator|.
name|np
expr_stmt|;
if|if
condition|(
name|np
operator|!=
name|NULL
condition|)
comment|/* Symbol already cached */
name|src_map
operator|=
name|symcache
index|[
name|RELOC_SYMBOL
argument_list|(
name|r
argument_list|)
index|]
operator|.
name|src_map
expr_stmt|;
else|else
block|{
comment|/* Symbol not cached yet */
name|np
operator|=
name|lookup
argument_list|(
name|sym
argument_list|,
operator|&
name|src_map
argument_list|,
name|RELOC_JMPTAB_P
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 				 * Record the needed information about 				 * the symbol in the caching vector, 				 * so that we won't have to call 				 * lookup the next time we encounter 				 * the symbol. 				 */
name|symcache
index|[
name|RELOC_SYMBOL
argument_list|(
name|r
argument_list|)
index|]
operator|.
name|np
operator|=
name|np
expr_stmt|;
name|symcache
index|[
name|RELOC_SYMBOL
argument_list|(
name|r
argument_list|)
index|]
operator|.
name|src_map
operator|=
name|src_map
expr_stmt|;
block|}
if|if
condition|(
name|np
operator|==
name|NULL
condition|)
block|{
name|generror
argument_list|(
literal|"Undefined symbol \"%s\" in %s:%s"
argument_list|,
name|sym
argument_list|,
name|main_progname
argument_list|,
name|smp
operator|->
name|som_path
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* 			 * Found symbol definition. 			 * If it's in a link map, adjust value 			 * according to the load address of that map. 			 * Otherwise it's a run-time allocated common 			 * whose value is already up-to-date. 			 */
name|relocation
operator|=
name|np
operator|->
name|nz_value
expr_stmt|;
if|if
condition|(
name|src_map
condition|)
name|relocation
operator|+=
operator|(
name|long
operator|)
name|src_map
operator|->
name|som_addr
expr_stmt|;
if|if
condition|(
name|RELOC_JMPTAB_P
argument_list|(
name|r
argument_list|)
condition|)
block|{
name|md_bind_jmpslot
argument_list|(
name|relocation
argument_list|,
name|addr
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|relocation
operator|+=
name|md_get_addend
argument_list|(
name|r
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|RELOC_PCREL_P
argument_list|(
name|r
argument_list|)
condition|)
name|relocation
operator|-=
operator|(
name|long
operator|)
name|smp
operator|->
name|som_addr
expr_stmt|;
if|if
condition|(
name|RELOC_COPY_P
argument_list|(
name|r
argument_list|)
operator|&&
name|src_map
condition|)
block|{
operator|(
name|void
operator|)
name|enter_rts
argument_list|(
name|sym
argument_list|,
name|sym_hash
argument_list|(
name|sym
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|addr
argument_list|,
name|N_DATA
operator|+
name|N_EXT
argument_list|,
name|src_map
operator|->
name|som_addr
operator|+
name|np
operator|->
name|nz_value
argument_list|,
name|np
operator|->
name|nz_size
argument_list|,
name|src_map
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|md_relocate
argument_list|(
name|r
argument_list|,
name|relocation
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|md_relocate
argument_list|(
name|r
argument_list|,
ifdef|#
directive|ifdef
name|SUN_COMPAT
name|md_get_rt_segment_addend
argument_list|(
argument|r
argument_list|,
argument|addr
argument_list|)
else|#
directive|else
name|md_get_addend
argument_list|(
name|r
argument_list|,
name|addr
argument_list|)
endif|#
directive|endif
operator|+
operator|(
name|long
operator|)
name|smp
operator|->
name|som_addr
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|smp
operator|->
name|som_write
condition|)
block|{
if|if
condition|(
name|mprotect
argument_list|(
name|smp
operator|->
name|som_addr
operator|+
name|LM_TXTADDR
argument_list|(
name|smp
argument_list|)
argument_list|,
name|LD_TEXTSZ
argument_list|(
name|smp
operator|->
name|som_dynamic
argument_list|)
argument_list|,
name|PROT_READ
operator||
name|PROT_EXEC
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|generror
argument_list|(
literal|"mprotect failed for \"%s\" : %s"
argument_list|,
name|smp
operator|->
name|som_path
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|smp
operator|->
name|som_write
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|reloc_copy
parameter_list|(
name|smp
parameter_list|)
name|struct
name|so_map
modifier|*
name|smp
decl_stmt|;
block|{
name|struct
name|rt_symbol
modifier|*
name|rtsp
decl_stmt|;
for|for
control|(
name|rtsp
operator|=
name|rt_symbol_head
init|;
name|rtsp
condition|;
name|rtsp
operator|=
name|rtsp
operator|->
name|rt_next
control|)
if|if
condition|(
operator|(
name|rtsp
operator|->
name|rt_smp
operator|==
name|NULL
operator|||
name|rtsp
operator|->
name|rt_smp
operator|==
name|smp
operator|)
operator|&&
name|rtsp
operator|->
name|rt_sp
operator|->
name|nz_type
operator|==
name|N_DATA
operator|+
name|N_EXT
condition|)
block|{
name|bcopy
argument_list|(
name|rtsp
operator|->
name|rt_srcaddr
argument_list|,
operator|(
name|caddr_t
operator|)
name|rtsp
operator|->
name|rt_sp
operator|->
name|nz_value
argument_list|,
name|rtsp
operator|->
name|rt_sp
operator|->
name|nz_size
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Initialize the DAG of shared objects rooted at the given object.  */
end_comment

begin_function
specifier|static
name|void
name|init_dag
parameter_list|(
name|smp
parameter_list|)
name|struct
name|so_map
modifier|*
name|smp
decl_stmt|;
block|{
name|struct
name|somap_private
modifier|*
name|smpp
init|=
name|LM_PRIVATE
argument_list|(
name|smp
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|smpp
operator|->
name|spd_flags
operator|&
name|RTLD_INIT
operator|)
condition|)
block|{
comment|/* Not initialized yet */
name|smpp
operator|->
name|spd_flags
operator||=
name|RTLD_INIT
expr_stmt|;
comment|/* Make sure all the children are initialized */
if|if
condition|(
name|smpp
operator|->
name|spd_children
operator|!=
name|NULL
condition|)
name|init_sods
argument_list|(
name|smpp
operator|->
name|spd_children
argument_list|)
expr_stmt|;
if|if
condition|(
name|call_map
argument_list|(
name|smp
argument_list|,
literal|".init"
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|call_map
argument_list|(
name|smp
argument_list|,
literal|"__init"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|init_sods
parameter_list|(
name|solp
parameter_list|)
name|struct
name|so_list
modifier|*
name|solp
decl_stmt|;
block|{
comment|/* Recursively initialize the rest of the list */
if|if
condition|(
name|solp
operator|->
name|sol_next
operator|!=
name|NULL
condition|)
name|init_sods
argument_list|(
name|solp
operator|->
name|sol_next
argument_list|)
expr_stmt|;
comment|/* Initialize the first element of the list */
name|init_dag
argument_list|(
name|solp
operator|->
name|sol_map
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Call a function in a given shared object.  SMP is the shared object, and  * SYM is the name of the function.  *  * Returns 0 on success, or -1 if the symbol was not found.  Failure is not  * necessarily an error condition, so no error message is generated.  */
end_comment

begin_function
specifier|static
name|int
name|call_map
parameter_list|(
name|smp
parameter_list|,
name|sym
parameter_list|)
name|struct
name|so_map
modifier|*
name|smp
decl_stmt|;
name|char
modifier|*
name|sym
decl_stmt|;
block|{
name|struct
name|so_map
modifier|*
name|src_map
init|=
name|smp
decl_stmt|;
name|struct
name|nzlist
modifier|*
name|np
decl_stmt|;
name|np
operator|=
name|lookup
argument_list|(
name|sym
argument_list|,
operator|&
name|src_map
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
condition|)
block|{
operator|(
operator|*
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
operator|(
name|src_map
operator|->
name|som_addr
operator|+
name|np
operator|->
name|nz_value
operator|)
operator|)
operator|(
operator|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Run-time common symbol table.  */
end_comment

begin_define
define|#
directive|define
name|RTC_TABSIZE
value|57
end_define

begin_decl_stmt
specifier|static
name|struct
name|rt_symbol
modifier|*
name|rt_symtab
index|[
name|RTC_TABSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Look up a symbol in the run-time common symbol table.  For efficiency,  * the symbol's hash value must be passed in too.  */
end_comment

begin_function
specifier|static
specifier|inline
name|struct
name|rt_symbol
modifier|*
name|lookup_rts
parameter_list|(
name|name
parameter_list|,
name|hash
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|long
name|hash
decl_stmt|;
block|{
specifier|register
name|struct
name|rt_symbol
modifier|*
name|rtsp
decl_stmt|;
for|for
control|(
name|rtsp
operator|=
name|rt_symtab
index|[
name|hash
operator|%
name|RTC_TABSIZE
index|]
init|;
name|rtsp
condition|;
name|rtsp
operator|=
name|rtsp
operator|->
name|rt_link
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|rtsp
operator|->
name|rt_sp
operator|->
name|nz_name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|rtsp
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Enter a symbol into the run-time common symbol table.  For efficiency,  * the symbol's hash value must be passed in too.  */
end_comment

begin_function
specifier|static
name|struct
name|rt_symbol
modifier|*
name|enter_rts
parameter_list|(
name|name
parameter_list|,
name|hash
parameter_list|,
name|value
parameter_list|,
name|type
parameter_list|,
name|srcaddr
parameter_list|,
name|size
parameter_list|,
name|smp
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|long
name|hash
decl_stmt|;
name|long
name|value
decl_stmt|;
name|int
name|type
decl_stmt|;
name|caddr_t
name|srcaddr
decl_stmt|;
name|long
name|size
decl_stmt|;
name|struct
name|so_map
modifier|*
name|smp
decl_stmt|;
block|{
specifier|register
name|struct
name|rt_symbol
modifier|*
name|rtsp
decl_stmt|,
modifier|*
modifier|*
name|rpp
decl_stmt|;
comment|/* Find end of bucket */
for|for
control|(
name|rpp
operator|=
operator|&
name|rt_symtab
index|[
name|hash
operator|%
name|RTC_TABSIZE
index|]
init|;
operator|*
name|rpp
condition|;
name|rpp
operator|=
operator|&
operator|(
operator|*
name|rpp
operator|)
operator|->
name|rt_link
control|)
continue|continue;
comment|/* Allocate new common symbol */
name|rtsp
operator|=
operator|(
expr|struct
name|rt_symbol
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|rt_symbol
argument_list|)
argument_list|)
expr_stmt|;
name|rtsp
operator|->
name|rt_sp
operator|=
operator|(
expr|struct
name|nzlist
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nzlist
argument_list|)
argument_list|)
expr_stmt|;
name|rtsp
operator|->
name|rt_sp
operator|->
name|nz_name
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|rtsp
operator|->
name|rt_sp
operator|->
name|nz_value
operator|=
name|value
expr_stmt|;
name|rtsp
operator|->
name|rt_sp
operator|->
name|nz_type
operator|=
name|type
expr_stmt|;
name|rtsp
operator|->
name|rt_sp
operator|->
name|nz_size
operator|=
name|size
expr_stmt|;
name|rtsp
operator|->
name|rt_srcaddr
operator|=
name|srcaddr
expr_stmt|;
name|rtsp
operator|->
name|rt_smp
operator|=
name|smp
expr_stmt|;
name|rtsp
operator|->
name|rt_link
operator|=
name|NULL
expr_stmt|;
comment|/* Link onto linear list as well */
name|rtsp
operator|->
name|rt_next
operator|=
name|rt_symbol_head
expr_stmt|;
name|rt_symbol_head
operator|=
name|rtsp
expr_stmt|;
operator|*
name|rpp
operator|=
name|rtsp
expr_stmt|;
return|return
name|rtsp
return|;
block|}
end_function

begin_comment
comment|/*  * Lookup NAME in the link maps. The link map producing a definition  * is returned in SRC_MAP. If SRC_MAP is not NULL on entry the search  * is confined to that map.  *  * REAL_DEF_ONLY is a boolean which specifies whether certain special  * symbols for functions should satisfy the lookup or not.  The  * reasons behind it are somewhat complicated.  They are motivated  * by the scenario in which the address of a single function is  * taken from several shared objects.  The address should come out  * the same in all cases, because the application code might decide  * to use it in comparisons.  To make this work, the linker creates  * a symbol entry for the function in the main executable, with a  * type of N_UNDF+N_EXT, an N_AUX of AUX_FUNC, and a value that  * refers to the PLT entry for the function in the main executable.  * If REAL_DEF_ONLY is false, then this kind of special symbol is  * considered a "definition" when lookup up the symbol.  Since the  * main executable is at the beginning of the shared object search  * list, the result is that references from all shared objects will  * resolve to the main program's PLT entry, and thus the function  * addresses will compare equal as they should.  *  * When relocating the PLT entry itself, we obviously must match  * only the true defining symbol for the function.  In that case, we  * set REAL_DEF_ONLY to true, which disables matching the special  * N_UNDF+N_EXT entries.  *  * It is not so clear how to set this flag for a lookup done from  * dlsym.  If the lookup specifies a particular shared object other  * than the main executable, the flag makes no difference -- only the  * true definition will be matched.  (That is because the special  * symbols are only present in the main executable, which will not  * be searched.)  But when the lookup is over all the shared objects  * (i.e., dlsym's "fd" parameter is NULL), then the flag does have an  * effect.  We elect to match only the true definition even in that  * case.  *  * The upshot of all this is the following rule of thumb: Set  * REAL_DEF_ONLY in all cases except when processing a non-PLT  * relocation.  */
end_comment

begin_function
specifier|static
name|struct
name|nzlist
modifier|*
name|lookup
parameter_list|(
name|name
parameter_list|,
name|src_map
parameter_list|,
name|real_def_only
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|so_map
modifier|*
modifier|*
name|src_map
decl_stmt|;
comment|/* IN/OUT */
name|int
name|real_def_only
decl_stmt|;
block|{
name|unsigned
name|long
name|hash
decl_stmt|;
name|hash
operator|=
name|sym_hash
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|src_map
operator|!=
name|NULL
condition|)
comment|/* Look in just one specific object */
return|return
name|lookup_in_obj
argument_list|(
name|name
argument_list|,
name|hash
argument_list|,
operator|*
name|src_map
argument_list|,
name|real_def_only
argument_list|)
return|;
else|else
block|{
comment|/* Search runtime symbols and all loaded objects */
name|unsigned
name|long
name|common_size
decl_stmt|;
name|struct
name|so_map
modifier|*
name|smp
decl_stmt|;
name|struct
name|rt_symbol
modifier|*
name|rtsp
decl_stmt|;
name|struct
name|nzlist
modifier|*
name|np
decl_stmt|;
if|if
condition|(
operator|(
name|rtsp
operator|=
name|lookup_rts
argument_list|(
name|name
argument_list|,
name|hash
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
name|rtsp
operator|->
name|rt_sp
return|;
name|common_size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|smp
operator|=
name|link_map_head
init|;
name|smp
condition|;
name|smp
operator|=
name|smp
operator|->
name|som_next
control|)
block|{
if|if
condition|(
name|LM_PRIVATE
argument_list|(
name|smp
argument_list|)
operator|->
name|spd_flags
operator|&
name|RTLD_RTLD
condition|)
continue|continue;
name|np
operator|=
name|lookup_in_obj
argument_list|(
name|name
argument_list|,
name|hash
argument_list|,
name|smp
argument_list|,
name|real_def_only
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|==
name|NULL
condition|)
continue|continue;
comment|/* We know that np->nz_value> 0 at this point. */
if|if
condition|(
name|np
operator|->
name|nz_type
operator|==
name|N_UNDF
operator|+
name|N_EXT
operator|&&
name|N_AUX
argument_list|(
operator|&
name|np
operator|->
name|nlist
argument_list|)
operator|!=
name|AUX_FUNC
condition|)
block|{
comment|/* Common */
if|if
condition|(
name|common_size
operator|<
name|np
operator|->
name|nz_value
condition|)
name|common_size
operator|=
name|np
operator|->
name|nz_value
expr_stmt|;
continue|continue;
block|}
comment|/* We found the symbol definition. */
operator|*
name|src_map
operator|=
name|smp
expr_stmt|;
return|return
name|np
return|;
block|}
if|if
condition|(
name|common_size
operator|>
literal|0
condition|)
block|{
comment|/* It is a common symbol. */
name|void
modifier|*
name|mem
decl_stmt|;
name|mem
operator|=
name|memset
argument_list|(
name|xmalloc
argument_list|(
name|common_size
argument_list|)
argument_list|,
literal|0
argument_list|,
name|common_size
argument_list|)
expr_stmt|;
name|rtsp
operator|=
name|enter_rts
argument_list|(
name|name
argument_list|,
name|hash
argument_list|,
operator|(
name|long
operator|)
name|mem
argument_list|,
name|N_UNDF
operator|+
name|N_EXT
argument_list|,
literal|0
argument_list|,
name|common_size
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|rtsp
operator|->
name|rt_sp
return|;
block|}
comment|/* No definition was found for the symbol. */
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Lookup a symbol in one specific shared object.  The hash  * value is passed in for efficiency.  For an explanation of the  * "real_def_only" flag, see the comment preceding the "lookup"  * function.  */
end_comment

begin_function
specifier|static
name|struct
name|nzlist
modifier|*
name|lookup_in_obj
parameter_list|(
name|name
parameter_list|,
name|hash
parameter_list|,
name|smp
parameter_list|,
name|real_def_only
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|long
name|hash
decl_stmt|;
name|struct
name|so_map
modifier|*
name|smp
decl_stmt|;
name|int
name|real_def_only
decl_stmt|;
block|{
name|unsigned
name|long
name|buckets
decl_stmt|;
name|struct
name|rrs_hash
modifier|*
name|hp
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|struct
name|nzlist
modifier|*
name|np
decl_stmt|;
name|char
modifier|*
name|symbolbase
decl_stmt|;
name|struct
name|rrs_hash
modifier|*
name|hashbase
decl_stmt|;
name|char
modifier|*
name|stringbase
decl_stmt|;
name|size_t
name|symsize
decl_stmt|;
if|if
condition|(
operator|(
name|buckets
operator|=
name|LD_BUCKETS
argument_list|(
name|smp
operator|->
name|som_dynamic
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
name|hashbase
operator|=
name|LM_HASH
argument_list|(
name|smp
argument_list|)
expr_stmt|;
name|restart
label|:
name|hp
operator|=
operator|&
name|hashbase
index|[
name|hash
operator|%
name|buckets
index|]
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|rh_symbolnum
operator|==
operator|-
literal|1
condition|)
return|return
name|NULL
return|;
name|symbolbase
operator|=
operator|(
name|char
operator|*
operator|)
name|LM_SYMBOL
argument_list|(
name|smp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stringbase
operator|=
name|LM_STRINGS
argument_list|(
name|smp
argument_list|)
expr_stmt|;
name|symsize
operator|=
name|LD_VERSION_NZLIST_P
argument_list|(
name|smp
operator|->
name|som_dynamic
operator|->
name|d_version
argument_list|)
condition|?
sizeof|sizeof
argument_list|(
expr|struct
name|nzlist
argument_list|)
else|:
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|np
operator|=
operator|(
expr|struct
name|nzlist
operator|*
operator|)
operator|(
name|symbolbase
operator|+
name|hp
operator|->
name|rh_symbolnum
operator|*
name|symsize
operator|)
expr_stmt|;
name|cp
operator|=
name|stringbase
operator|+
name|np
operator|->
name|nz_strx
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|hp
operator|->
name|rh_next
operator|==
literal|0
condition|)
comment|/* End of hash chain */
return|return
name|NULL
return|;
name|hp
operator|=
name|hashbase
operator|+
name|hp
operator|->
name|rh_next
expr_stmt|;
block|}
comment|/* 	 * We have a symbol with the name we're looking for. 	 */
if|if
condition|(
name|np
operator|->
name|nz_type
operator|==
name|N_INDR
operator|+
name|N_EXT
condition|)
block|{
comment|/* 		 * Next symbol gives the aliased name. Restart 		 * search with new name. 		 */
name|name
operator|=
name|stringbase
operator|+
operator|(
operator|++
name|np
operator|)
operator|->
name|nz_strx
expr_stmt|;
name|hash
operator|=
name|sym_hash
argument_list|(
name|name
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
if|if
condition|(
name|np
operator|->
name|nz_value
operator|==
literal|0
condition|)
comment|/* It's not a definition */
return|return
name|NULL
return|;
if|if
condition|(
name|real_def_only
condition|)
comment|/* Don't match special function symbols. */
if|if
condition|(
name|np
operator|->
name|nz_type
operator|==
name|N_UNDF
operator|+
name|N_EXT
operator|&&
name|N_AUX
argument_list|(
operator|&
name|np
operator|->
name|nlist
argument_list|)
operator|==
name|AUX_FUNC
condition|)
return|return
name|NULL
return|;
return|return
name|np
return|;
block|}
end_function

begin_comment
comment|/*  * Return the value of a symbol in the user's program.  This is used  * internally for a few symbols which must exist.  If the requested  * symbol is not found, this simply exits with a fatal error.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|sym_addr
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|so_map
modifier|*
name|smp
decl_stmt|;
name|struct
name|nzlist
modifier|*
name|np
decl_stmt|;
name|smp
operator|=
name|NULL
expr_stmt|;
name|np
operator|=
name|lookup
argument_list|(
name|name
argument_list|,
operator|&
name|smp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Program has no symbol \"%s\""
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|smp
operator|==
name|NULL
operator|)
condition|?
name|NULL
else|:
name|smp
operator|->
name|som_addr
operator|)
operator|+
name|np
operator|->
name|nz_value
return|;
block|}
end_function

begin_comment
comment|/*  * This routine is called from the jumptable to resolve  * procedure calls to shared objects.  */
end_comment

begin_function
name|long
name|binder
parameter_list|(
name|jsp
parameter_list|)
name|jmpslot_t
modifier|*
name|jsp
decl_stmt|;
block|{
name|struct
name|so_map
modifier|*
name|smp
decl_stmt|,
modifier|*
name|src_map
init|=
name|NULL
decl_stmt|;
name|long
name|addr
decl_stmt|;
name|char
modifier|*
name|sym
decl_stmt|;
name|struct
name|nzlist
modifier|*
name|np
decl_stmt|;
name|int
name|index
decl_stmt|;
comment|/* 	 * Find the PLT map that contains JSP. 	 */
for|for
control|(
name|smp
operator|=
name|link_map_head
init|;
name|smp
condition|;
name|smp
operator|=
name|smp
operator|->
name|som_next
control|)
block|{
if|if
condition|(
name|LM_PLT
argument_list|(
name|smp
argument_list|)
operator|<
name|jsp
operator|&&
name|jsp
operator|<
name|LM_PLT
argument_list|(
name|smp
argument_list|)
operator|+
name|LD_PLTSZ
argument_list|(
name|smp
operator|->
name|som_dynamic
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|jsp
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|smp
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Call to binder from unknown location: %p\n"
argument_list|,
name|jsp
argument_list|)
expr_stmt|;
name|index
operator|=
name|jsp
operator|->
name|reloc_index
operator|&
name|JMPSLOT_RELOC_MASK
expr_stmt|;
comment|/* Get the local symbol this jmpslot refers to */
name|sym
operator|=
name|LM_STRINGS
argument_list|(
name|smp
argument_list|)
operator|+
name|LM_SYMBOL
argument_list|(
name|smp
argument_list|,
name|RELOC_SYMBOL
argument_list|(
operator|&
name|LM_REL
argument_list|(
name|smp
argument_list|)
index|[
name|index
index|]
argument_list|)
argument_list|)
operator|->
name|nz_strx
expr_stmt|;
name|np
operator|=
name|lookup
argument_list|(
name|sym
argument_list|,
operator|&
name|src_map
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Undefined symbol \"%s\" called from %s:%s at %p"
argument_list|,
name|sym
argument_list|,
name|main_progname
argument_list|,
name|smp
operator|->
name|som_path
argument_list|,
name|jsp
argument_list|)
expr_stmt|;
comment|/* Fixup jmpslot so future calls transfer directly to target */
name|addr
operator|=
name|np
operator|->
name|nz_value
expr_stmt|;
if|if
condition|(
name|src_map
condition|)
name|addr
operator|+=
operator|(
name|long
operator|)
name|src_map
operator|->
name|som_addr
expr_stmt|;
name|md_fix_jmpslot
argument_list|(
name|jsp
argument_list|,
operator|(
name|long
operator|)
name|jsp
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|#
directive|if
name|DEBUG
name|xprintf
argument_list|(
literal|" BINDER: %s located at = %#x in %s\n"
argument_list|,
name|sym
argument_list|,
name|addr
argument_list|,
name|src_map
operator|->
name|som_path
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|addr
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|hints_header
modifier|*
name|hheader
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* NULL means not mapped */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hints_bucket
modifier|*
name|hbuckets
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|hstrtab
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Map the hints file into memory, if it is not already mapped.  Returns  * 0 on success, or -1 on failure.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|maphints
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
block|{
specifier|static
name|int
name|hints_bad
decl_stmt|;
comment|/* TRUE if hints are unusable */
specifier|static
name|int
name|paths_added
decl_stmt|;
name|int
name|hfd
decl_stmt|;
name|struct
name|hints_header
name|hdr
decl_stmt|;
name|caddr_t
name|addr
decl_stmt|;
if|if
condition|(
name|hheader
operator|!=
name|NULL
condition|)
comment|/* Already mapped */
return|return
literal|0
return|;
if|if
condition|(
name|hints_bad
condition|)
comment|/* Known to be corrupt or unavailable */
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|(
name|hfd
operator|=
name|open
argument_list|(
name|_PATH_LD_HINTS
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|hints_bad
operator|=
literal|1
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Read the header and check it */
if|if
condition|(
name|read
argument_list|(
name|hfd
argument_list|,
operator|&
name|hdr
argument_list|,
sizeof|sizeof
name|hdr
argument_list|)
operator|!=
sizeof|sizeof
name|hdr
operator|||
name|HH_BADMAG
argument_list|(
name|hdr
argument_list|)
operator|||
operator|(
name|hdr
operator|.
name|hh_version
operator|!=
name|LD_HINTS_VERSION_1
operator|&&
name|hdr
operator|.
name|hh_version
operator|!=
name|LD_HINTS_VERSION_2
operator|)
condition|)
block|{
name|close
argument_list|(
name|hfd
argument_list|)
expr_stmt|;
name|hints_bad
operator|=
literal|1
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Map the hints into memory */
name|addr
operator|=
name|mmap
argument_list|(
literal|0
argument_list|,
name|hdr
operator|.
name|hh_ehints
argument_list|,
name|PROT_READ
argument_list|,
name|MAP_SHARED
argument_list|,
name|hfd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|==
operator|(
name|caddr_t
operator|)
operator|-
literal|1
condition|)
block|{
name|close
argument_list|(
name|hfd
argument_list|)
expr_stmt|;
name|hints_bad
operator|=
literal|1
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|close
argument_list|(
name|hfd
argument_list|)
expr_stmt|;
name|hheader
operator|=
operator|(
expr|struct
name|hints_header
operator|*
operator|)
name|addr
expr_stmt|;
name|hbuckets
operator|=
operator|(
expr|struct
name|hints_bucket
operator|*
operator|)
operator|(
name|addr
operator|+
name|hheader
operator|->
name|hh_hashtab
operator|)
expr_stmt|;
name|hstrtab
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|addr
operator|+
name|hheader
operator|->
name|hh_strtab
operator|)
expr_stmt|;
comment|/* pluck out the system ldconfig path */
if|if
condition|(
name|hheader
operator|->
name|hh_version
operator|>=
name|LD_HINTS_VERSION_2
operator|&&
operator|!
name|paths_added
condition|)
block|{
name|add_search_path
argument_list|(
name|hstrtab
operator|+
name|hheader
operator|->
name|hh_dirlist
argument_list|)
expr_stmt|;
name|paths_added
operator|=
literal|1
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_comment
comment|/*  * Unmap the hints file, if it is currently mapped.  */
end_comment

begin_function
specifier|static
name|void
name|unmaphints
parameter_list|()
block|{
if|if
condition|(
name|hheader
operator|!=
name|NULL
condition|)
block|{
name|munmap
argument_list|(
operator|(
name|caddr_t
operator|)
name|hheader
argument_list|,
name|hheader
operator|->
name|hh_ehints
argument_list|)
expr_stmt|;
name|hheader
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|hinthash
parameter_list|(
name|cp
parameter_list|,
name|vmajor
parameter_list|)
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|vmajor
decl_stmt|;
block|{
name|int
name|k
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|cp
condition|)
name|k
operator|=
operator|(
operator|(
operator|(
name|k
operator|<<
literal|1
operator|)
operator|+
operator|(
name|k
operator|>>
literal|14
operator|)
operator|)
operator|^
operator|(
operator|*
name|cp
operator|++
operator|)
operator|)
operator|&
literal|0x3fff
expr_stmt|;
name|k
operator|=
operator|(
operator|(
operator|(
name|k
operator|<<
literal|1
operator|)
operator|+
operator|(
name|k
operator|>>
literal|14
operator|)
operator|)
operator|^
operator|(
name|vmajor
operator|*
literal|257
operator|)
operator|)
operator|&
literal|0x3fff
expr_stmt|;
return|return
name|k
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|major
end_undef

begin_undef
undef|#
directive|undef
name|minor
end_undef

begin_comment
comment|/*  * Search for a library in the hints generated by ldconfig.  On success,  * returns the full pathname of the matching library.  This string is  * always dynamically allocated on the heap.  *  * Returns the minor number of the matching library via the pointer  * argument MINORP.  *  * Returns NULL if the library cannot be found.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|findhint
parameter_list|(
name|name
parameter_list|,
name|major
parameter_list|,
name|minorp
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|major
decl_stmt|;
name|int
modifier|*
name|minorp
decl_stmt|;
block|{
name|struct
name|hints_bucket
modifier|*
name|bp
init|=
name|hbuckets
operator|+
operator|(
name|hinthash
argument_list|(
name|name
argument_list|,
name|major
argument_list|)
operator|%
name|hheader
operator|->
name|hh_nbucket
operator|)
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Sanity check */
if|if
condition|(
name|bp
operator|->
name|hi_namex
operator|>=
name|hheader
operator|->
name|hh_strtab_sz
condition|)
block|{
name|warnx
argument_list|(
literal|"Bad name index: %#x\n"
argument_list|,
name|bp
operator|->
name|hi_namex
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|bp
operator|->
name|hi_pathx
operator|>=
name|hheader
operator|->
name|hh_strtab_sz
condition|)
block|{
name|warnx
argument_list|(
literal|"Bad path index: %#x\n"
argument_list|,
name|bp
operator|->
name|hi_pathx
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * We accept the current hints entry if its name matches 		 * and its major number matches.  We don't have to search 		 * for the best minor number, because that was already 		 * done by "ldconfig" when it built the hints file. 		 */
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|hstrtab
operator|+
name|bp
operator|->
name|hi_namex
argument_list|)
operator|==
literal|0
operator|&&
name|bp
operator|->
name|hi_major
operator|==
name|major
condition|)
block|{
name|struct
name|stat
name|s
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|hstrtab
operator|+
name|bp
operator|->
name|hi_pathx
argument_list|,
operator|&
name|s
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
name|NULL
return|;
comment|/* Doesn't actually exist */
operator|*
name|minorp
operator|=
name|bp
operator|->
name|hi_ndewey
operator|>=
literal|2
condition|?
name|bp
operator|->
name|hi_minor
else|:
operator|-
literal|1
expr_stmt|;
return|return
name|strdup
argument_list|(
name|hstrtab
operator|+
name|bp
operator|->
name|hi_pathx
argument_list|)
return|;
block|}
if|if
condition|(
name|bp
operator|->
name|hi_next
operator|==
operator|-
literal|1
condition|)
break|break;
comment|/* Move on to next in bucket */
name|bp
operator|=
operator|&
name|hbuckets
index|[
name|bp
operator|->
name|hi_next
index|]
expr_stmt|;
block|}
comment|/* No hints available for name */
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Search for the given shared library.  On success, returns a string  * containing the full pathname for the library.  This string is always  * dynamically allocated on the heap.  *  * Returns NULL if the library cannot be found.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|rtfindlib
parameter_list|(
name|name
parameter_list|,
name|major
parameter_list|,
name|minor
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|major
decl_stmt|,
name|minor
decl_stmt|;
block|{
name|char
modifier|*
name|ld_path
init|=
name|ld_library_path
decl_stmt|;
name|char
modifier|*
name|path
init|=
name|NULL
decl_stmt|;
name|int
name|realminor
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|ld_path
operator|!=
name|NULL
condition|)
block|{
comment|/* First, search the directories in ld_path */
comment|/* 		 * There is no point in trying to use the hints file for this. 		 */
name|char
modifier|*
name|dir
decl_stmt|;
while|while
condition|(
name|path
operator|==
name|NULL
operator|&&
operator|(
name|dir
operator|=
name|strsep
argument_list|(
operator|&
name|ld_path
argument_list|,
literal|":"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|path
operator|=
name|search_lib_dir
argument_list|(
name|dir
argument_list|,
name|name
argument_list|,
operator|&
name|major
argument_list|,
operator|&
name|realminor
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ld_path
operator|!=
name|NULL
condition|)
operator|*
operator|(
name|ld_path
operator|-
literal|1
operator|)
operator|=
literal|':'
expr_stmt|;
block|}
block|}
if|if
condition|(
name|path
operator|==
name|NULL
operator|&&
name|maphints
argument_list|()
operator|==
literal|0
condition|)
comment|/* Search the hints file */
name|path
operator|=
name|findhint
argument_list|(
name|name
argument_list|,
name|major
argument_list|,
operator|&
name|realminor
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
comment|/* Search the standard directories */
name|path
operator|=
name|findshlib
argument_list|(
name|name
argument_list|,
operator|&
name|major
argument_list|,
operator|&
name|realminor
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|!=
name|NULL
operator|&&
name|realminor
operator|<
name|minor
operator|&&
operator|!
name|ld_suppress_warnings
condition|)
block|{
name|warnx
argument_list|(
literal|"warning: %s: minor version %d"
literal|" older than expected %d, using it anyway"
argument_list|,
name|path
argument_list|,
name|realminor
argument_list|,
name|minor
argument_list|)
expr_stmt|;
block|}
return|return
name|path
return|;
block|}
end_function

begin_comment
comment|/*  * Search for the given shared library file.  This is similar to rtfindlib,  * except that the argument is the actual name of the desired library file.  * Thus there is no need to worry about version numbers.  The return value  * is a string containing the full pathname for the library.  This string  * is always dynamically allocated on the heap.  *  * Returns NULL if the library cannot be found.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|rtfindfile
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|char
modifier|*
name|ld_path
init|=
name|ld_library_path
decl_stmt|;
name|char
modifier|*
name|path
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|ld_path
operator|!=
name|NULL
condition|)
block|{
comment|/* First, search the directories in ld_path */
name|char
modifier|*
name|dir
decl_stmt|;
while|while
condition|(
name|path
operator|==
name|NULL
operator|&&
operator|(
name|dir
operator|=
name|strsep
argument_list|(
operator|&
name|ld_path
argument_list|,
literal|":"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|struct
name|stat
name|sb
decl_stmt|;
name|path
operator|=
name|concat
argument_list|(
name|dir
argument_list|,
literal|"/"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|lstat
argument_list|(
name|path
argument_list|,
operator|&
name|sb
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* Does not exist */
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|path
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ld_path
operator|!=
name|NULL
condition|)
operator|*
operator|(
name|ld_path
operator|-
literal|1
operator|)
operator|=
literal|':'
expr_stmt|;
block|}
block|}
comment|/* 	 * We don't search the hints file.  It is organized around major 	 * and minor version numbers, so it is not suitable for finding 	 * a specific file name. 	 */
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
comment|/* Search the standard directories */
name|path
operator|=
name|find_lib_file
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|path
return|;
block|}
end_function

begin_comment
comment|/*  * Buffer for error messages and a pointer that is set to point to the buffer  * when a error occurs.  It acts as a last error flag, being set to NULL  * after an error is returned.  */
end_comment

begin_define
define|#
directive|define
name|DLERROR_BUF_SIZE
value|512
end_define

begin_decl_stmt
specifier|static
name|char
name|dlerror_buf
index|[
name|DLERROR_BUF_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|dlerror_msg
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
modifier|*
name|__dlopen
parameter_list|(
name|path
parameter_list|,
name|mode
parameter_list|)
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|int
name|mode
decl_stmt|;
block|{
name|struct
name|so_map
modifier|*
name|old_tail
init|=
name|link_map_tail
decl_stmt|;
name|struct
name|so_map
modifier|*
name|smp
decl_stmt|;
name|int
name|bind_now
init|=
name|mode
operator|==
name|RTLD_NOW
decl_stmt|;
comment|/* 	 * path == NULL is handled by map_object() 	 */
name|anon_open
argument_list|()
expr_stmt|;
comment|/* Map the object, and the objects on which it depends */
name|smp
operator|=
name|map_object
argument_list|(
name|path
argument_list|,
operator|(
expr|struct
name|sod
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|so_map
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|smp
operator|==
name|NULL
condition|)
comment|/* Failed */
return|return
name|NULL
return|;
name|LM_PRIVATE
argument_list|(
name|smp
argument_list|)
operator|->
name|spd_flags
operator||=
name|RTLD_DL
expr_stmt|;
comment|/* Relocate and initialize all newly-mapped objects */
if|if
condition|(
name|link_map_tail
operator|!=
name|old_tail
condition|)
block|{
comment|/* We have mapped some new objects */
if|if
condition|(
name|reloc_dag
argument_list|(
name|smp
argument_list|,
name|bind_now
argument_list|)
operator|==
operator|-
literal|1
condition|)
comment|/* Failed */
return|return
name|NULL
return|;
name|init_dag
argument_list|(
name|smp
argument_list|)
expr_stmt|;
block|}
name|unmaphints
argument_list|()
expr_stmt|;
name|anon_close
argument_list|()
expr_stmt|;
return|return
name|smp
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__dlclose
parameter_list|(
name|fd
parameter_list|)
name|void
modifier|*
name|fd
decl_stmt|;
block|{
name|struct
name|so_map
modifier|*
name|smp
init|=
operator|(
expr|struct
name|so_map
operator|*
operator|)
name|fd
decl_stmt|;
name|struct
name|so_map
modifier|*
name|scanp
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|xprintf
argument_list|(
literal|"dlclose(%s): refcount = %d\n"
argument_list|,
name|smp
operator|->
name|som_path
argument_list|,
name|LM_PRIVATE
argument_list|(
name|smp
argument_list|)
operator|->
name|spd_refcount
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Check the argument for validity */
for|for
control|(
name|scanp
operator|=
name|link_map_head
init|;
name|scanp
operator|!=
name|NULL
condition|;
name|scanp
operator|=
name|scanp
operator|->
name|som_next
control|)
if|if
condition|(
name|scanp
operator|==
name|smp
condition|)
comment|/* We found the map in the list */
break|break;
if|if
condition|(
name|scanp
operator|==
name|NULL
operator|||
operator|!
operator|(
name|LM_PRIVATE
argument_list|(
name|smp
argument_list|)
operator|->
name|spd_flags
operator|&
name|RTLD_DL
operator|)
condition|)
block|{
name|generror
argument_list|(
literal|"Invalid argument to dlclose"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|unmap_object
argument_list|(
name|smp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * This form of dlsym is obsolete.  Current versions of crt0 don't call  * it.  It can still be called by old executables that were linked with  * old versions of crt0.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|__dlsym
parameter_list|(
name|fd
parameter_list|,
name|sym
parameter_list|)
name|void
modifier|*
name|fd
decl_stmt|;
specifier|const
name|char
modifier|*
name|sym
decl_stmt|;
block|{
if|if
condition|(
name|fd
operator|==
name|RTLD_NEXT
condition|)
block|{
name|generror
argument_list|(
literal|"RTLD_NEXT not supported by this version of"
literal|" /usr/lib/crt0.o"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|__dlsym3
argument_list|(
name|fd
argument_list|,
name|sym
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|resolvesym
parameter_list|(
name|fd
parameter_list|,
name|sym
parameter_list|,
name|retaddr
parameter_list|)
name|void
modifier|*
name|fd
decl_stmt|;
name|char
modifier|*
name|sym
decl_stmt|;
name|void
modifier|*
name|retaddr
decl_stmt|;
block|{
name|struct
name|so_map
modifier|*
name|smp
decl_stmt|;
name|struct
name|so_map
modifier|*
name|src_map
decl_stmt|;
name|struct
name|nzlist
modifier|*
name|np
decl_stmt|;
name|long
name|addr
decl_stmt|;
if|if
condition|(
name|fd
operator|==
name|RTLD_NEXT
condition|)
block|{
comment|/* Find the shared object that contains the caller. */
for|for
control|(
name|smp
operator|=
name|link_map_head
init|;
name|smp
operator|!=
name|NULL
condition|;
name|smp
operator|=
name|smp
operator|->
name|som_next
control|)
block|{
name|void
modifier|*
name|textbase
init|=
name|smp
operator|->
name|som_addr
operator|+
name|LM_TXTADDR
argument_list|(
name|smp
argument_list|)
decl_stmt|;
name|void
modifier|*
name|textlimit
init|=
name|LM_ETEXT
argument_list|(
name|smp
argument_list|)
decl_stmt|;
if|if
condition|(
name|textbase
operator|<=
name|retaddr
operator|&&
name|retaddr
operator|<
name|textlimit
condition|)
break|break;
block|}
if|if
condition|(
name|smp
operator|==
name|NULL
condition|)
block|{
name|generror
argument_list|(
literal|"Cannot determine caller's shared object"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|smp
operator|=
name|smp
operator|->
name|som_next
expr_stmt|;
if|if
condition|(
name|smp
operator|!=
name|NULL
operator|&&
name|LM_PRIVATE
argument_list|(
name|smp
argument_list|)
operator|->
name|spd_flags
operator|&
name|RTLD_RTLD
condition|)
name|smp
operator|=
name|smp
operator|->
name|som_next
expr_stmt|;
if|if
condition|(
name|smp
operator|==
name|NULL
condition|)
block|{
name|generror
argument_list|(
literal|"No next shared object for RTLD_NEXT"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
do|do
block|{
name|src_map
operator|=
name|smp
expr_stmt|;
name|np
operator|=
name|lookup
argument_list|(
name|sym
argument_list|,
operator|&
name|src_map
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|np
operator|==
name|NULL
operator|&&
operator|(
name|smp
operator|=
name|smp
operator|->
name|som_next
operator|)
operator|!=
name|NULL
condition|)
do|;
block|}
else|else
block|{
name|smp
operator|=
operator|(
expr|struct
name|so_map
operator|*
operator|)
name|fd
expr_stmt|;
name|src_map
operator|=
name|NULL
expr_stmt|;
comment|/* 		 * Restrict search to passed map if dlopen()ed. 		 */
if|if
condition|(
name|smp
operator|!=
name|NULL
operator|&&
name|LM_PRIVATE
argument_list|(
name|smp
argument_list|)
operator|->
name|spd_flags
operator|&
name|RTLD_DL
condition|)
name|src_map
operator|=
name|smp
expr_stmt|;
name|np
operator|=
name|lookup
argument_list|(
name|sym
argument_list|,
operator|&
name|src_map
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|np
operator|==
name|NULL
condition|)
block|{
name|generror
argument_list|(
literal|"Undefined symbol"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|addr
operator|=
name|np
operator|->
name|nz_value
expr_stmt|;
if|if
condition|(
name|src_map
condition|)
name|addr
operator|+=
operator|(
name|long
operator|)
name|src_map
operator|->
name|som_addr
expr_stmt|;
return|return
operator|(
name|void
operator|*
operator|)
name|addr
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|__dlsym3
parameter_list|(
name|fd
parameter_list|,
name|sym
parameter_list|,
name|retaddr
parameter_list|)
name|void
modifier|*
name|fd
decl_stmt|;
specifier|const
name|char
modifier|*
name|sym
decl_stmt|;
name|void
modifier|*
name|retaddr
decl_stmt|;
block|{
name|void
modifier|*
name|result
decl_stmt|;
name|result
operator|=
name|resolvesym
argument_list|(
name|fd
argument_list|,
name|sym
argument_list|,
name|retaddr
argument_list|)
expr_stmt|;
comment|/* 	 * XXX - Ugly, but it makes the least impact on the run-time loader 	 * sources.  We assume that most of the time the error is a 	 * undefined symbol error from above, so we try again.  If it's 	 * not an undefined symbol we end up getting the same error twice, 	 * but that's acceptable. 	 */
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
block|{
comment|/* Prepend an underscore and try again */
name|char
modifier|*
name|newsym
init|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|sym
argument_list|)
operator|+
literal|2
argument_list|)
decl_stmt|;
name|newsym
index|[
literal|0
index|]
operator|=
literal|'_'
expr_stmt|;
name|strcpy
argument_list|(
operator|&
name|newsym
index|[
literal|1
index|]
argument_list|,
name|sym
argument_list|)
expr_stmt|;
name|result
operator|=
name|resolvesym
argument_list|(
name|fd
argument_list|,
name|newsym
argument_list|,
name|retaddr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|newsym
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|__dlerror
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
block|{
specifier|const
name|char
modifier|*
name|err
decl_stmt|;
name|err
operator|=
name|dlerror_msg
expr_stmt|;
name|dlerror_msg
operator|=
name|NULL
expr_stmt|;
comment|/* Next call will return NULL */
return|return
name|err
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|__dlexit
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|xprintf
argument_list|(
literal|"__dlexit called\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|unmap_object
argument_list|(
name|link_map_head
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/*  * Print the current error message and exit with failure status.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|die
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
block|{
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ld.so failed"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|msg
operator|=
name|__dlerror
argument_list|()
operator|)
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|": %s"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/*  * Generate an error message that can be later be retrieved via dlerror.  */
end_comment

begin_function
specifier|static
name|void
if|#
directive|if
name|__STDC__
name|generror
parameter_list|(
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
function|generror
parameter_list|(
name|fmt
parameter_list|,
name|va_alist
parameter_list|)
name|char
modifier|*
name|fmt
decl_stmt|;
endif|#
directive|endif
block|{
name|va_list
name|ap
decl_stmt|;
if|#
directive|if
name|__STDC__
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
else|#
directive|else
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vsnprintf
argument_list|(
name|dlerror_buf
argument_list|,
name|DLERROR_BUF_SIZE
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|dlerror_msg
operator|=
name|dlerror_buf
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
if|#
directive|if
name|__STDC__
name|xprintf
parameter_list|(
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
function|xprintf
parameter_list|(
name|fmt
parameter_list|,
name|va_alist
parameter_list|)
name|char
modifier|*
name|fmt
decl_stmt|;
endif|#
directive|endif
block|{
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
if|#
directive|if
name|__STDC__
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
else|#
directive|else
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vsnprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|write
argument_list|(
literal|1
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * rt_readenv() etc.  *  * Do a sweep over the environment once only, pick up what  * looks interesting.  *  * This is pretty obscure, but is relatively simple.  Simply  * look at each environment variable, if it starts with "LD_" then  * look closer at it.  If it's in our table, set the variable  * listed.  effectively, this is like:  *    ld_preload = careful ? NULL : getenv("LD_PRELOAD");  * except that the environment is scanned once only to pick up all  * known variables, rather than scanned multiple times for each  * variable.  *  * If an environment variable of interest is set to the empty string, we  * treat it as if it were unset.  */
end_comment

begin_define
define|#
directive|define
name|L
parameter_list|(
name|n
parameter_list|,
name|u
parameter_list|,
name|v
parameter_list|)
value|{ n, sizeof(n) - 1, u, v },
end_define

begin_struct
struct|struct
name|env_scan_tab
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|unsafe
decl_stmt|;
name|char
modifier|*
modifier|*
name|value
decl_stmt|;
block|}
name|scan_tab
index|[]
init|=
block|{
name|L
argument_list|(
literal|"LD_LIBRARY_PATH="
argument_list|,
literal|1
argument_list|,
argument|&ld_library_path
argument_list|)
name|L
argument_list|(
literal|"LD_PRELOAD="
argument_list|,
literal|1
argument_list|,
argument|&ld_preload
argument_list|)
name|L
argument_list|(
literal|"LD_IGNORE_MISSING_OBJECTS="
argument_list|,
literal|1
argument_list|,
argument|&ld_ignore_missing_objects
argument_list|)
name|L
argument_list|(
literal|"LD_TRACE_LOADED_OBJECTS="
argument_list|,
literal|0
argument_list|,
argument|&ld_tracing
argument_list|)
name|L
argument_list|(
literal|"LD_BIND_NOW="
argument_list|,
literal|0
argument_list|,
argument|&ld_bind_now
argument_list|)
name|L
argument_list|(
literal|"LD_SUPPRESS_WARNINGS="
argument_list|,
literal|0
argument_list|,
argument|&ld_suppress_warnings
argument_list|)
name|L
argument_list|(
literal|"LD_WARN_NON_PURE_CODE="
argument_list|,
literal|0
argument_list|,
argument|&ld_warn_non_pure_code
argument_list|)
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|}
block|}
struct|;
end_struct

begin_undef
undef|#
directive|undef
name|L
end_undef

begin_function
specifier|static
name|void
name|rt_readenv
parameter_list|()
block|{
name|char
modifier|*
modifier|*
name|p
init|=
name|environ
decl_stmt|;
name|char
modifier|*
name|v
decl_stmt|;
name|struct
name|env_scan_tab
modifier|*
name|t
decl_stmt|;
comment|/* for each string in the environment... */
while|while
condition|(
operator|(
name|v
operator|=
operator|*
name|p
operator|++
operator|)
condition|)
block|{
comment|/* check for LD_xxx */
if|if
condition|(
name|v
index|[
literal|0
index|]
operator|!=
literal|'L'
operator|||
name|v
index|[
literal|1
index|]
operator|!=
literal|'D'
operator|||
name|v
index|[
literal|2
index|]
operator|!=
literal|'_'
condition|)
continue|continue;
for|for
control|(
name|t
operator|=
name|scan_tab
init|;
name|t
operator|->
name|name
condition|;
name|t
operator|++
control|)
block|{
if|if
condition|(
name|careful
operator|&&
name|t
operator|->
name|unsafe
condition|)
continue|continue;
comment|/* skip for set[ug]id */
if|if
condition|(
name|strncmp
argument_list|(
name|t
operator|->
name|name
argument_list|,
name|v
argument_list|,
name|t
operator|->
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|v
operator|+
name|t
operator|->
name|len
operator|)
operator|!=
literal|'\0'
condition|)
comment|/* Not empty */
operator|*
name|t
operator|->
name|value
operator|=
name|v
operator|+
name|t
operator|->
name|len
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Malloc implementation for use within the dynamic linker.  At first  * we do a simple allocation using sbrk.  After the user's program  * has been loaded, we switch to using whatever malloc functions are  * defined there.  */
end_comment

begin_comment
comment|/* Symbols related to the sbrk and brk implementations. */
end_comment

begin_define
define|#
directive|define
name|CURBRK_SYM
value|"curbrk"
end_define

begin_define
define|#
directive|define
name|MINBRK_SYM
value|"minbrk"
end_define

begin_define
define|#
directive|define
name|END_SYM
value|"_end"
end_define

begin_comment
comment|/* Symbols related to malloc. */
end_comment

begin_define
define|#
directive|define
name|FREE_SYM
value|"_free"
end_define

begin_define
define|#
directive|define
name|MALLOC_SYM
value|"_malloc"
end_define

begin_define
define|#
directive|define
name|REALLOC_SYM
value|"_realloc"
end_define

begin_comment
comment|/* Hooks into the implementation of sbrk and brk. */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|curbrk
name|__asm__
parameter_list|(
name|CURBRK_SYM
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|minbrk
name|__asm__
parameter_list|(
name|MINBRK_SYM
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Pointers to the user program's malloc functions. */
end_comment

begin_expr_stmt
specifier|static
name|void
operator|*
operator|(
operator|*
name|p_malloc
operator|)
name|__P
argument_list|(
operator|(
name|size_t
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|void
operator|*
operator|(
operator|*
name|p_realloc
operator|)
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|,
name|size_t
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|void
argument_list|(
argument|*p_free
argument_list|)
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Upper limit of the memory allocated by our internal malloc. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rtld_alloc_lev
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Set up the internal malloc so that it will take its memory from the  * main program's sbrk arena.  */
end_comment

begin_function
specifier|static
name|void
name|init_internal_malloc
parameter_list|(
name|dp
parameter_list|)
name|struct
name|_dynamic
modifier|*
name|dp
decl_stmt|;
block|{
name|struct
name|so_map
name|tmp_map
decl_stmt|;
name|struct
name|somap_private
name|map_private
decl_stmt|;
name|struct
name|nzlist
modifier|*
name|np
decl_stmt|;
comment|/*          * Before anything calls sbrk or brk, we have to initialize          * its idea of the current break level to the main program's          * "_end" symbol, rather than that of the dynamic linker.  In          * order to do that, we need to look up the value of the main          * program's "_end" symbol.  We set up a temporary link map          * entry for the main program so that we can do the lookup. 	 */
name|init_link_map
argument_list|(
operator|&
name|tmp_map
argument_list|,
operator|&
name|map_private
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|dp
argument_list|)
expr_stmt|;
name|np
operator|=
name|lookup_in_obj
argument_list|(
name|END_SYM
argument_list|,
name|sym_hash
argument_list|(
name|END_SYM
argument_list|)
argument_list|,
operator|&
name|tmp_map
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Main program has no symbol \"%s\""
argument_list|,
name|END_SYM
argument_list|)
expr_stmt|;
name|rtld_alloc_lev
operator|=
name|curbrk
operator|=
name|minbrk
operator|=
operator|(
name|char
operator|*
operator|)
name|np
operator|->
name|nz_value
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set things up so that the dynamic linker can use the program's  * malloc functions.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|init_external_malloc
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
block|{
comment|/*          * Patch the program's idea of the current break address to          * what it really is as a result of the allocations we have          * already done. 	 */
operator|*
operator|(
name|char
operator|*
operator|*
operator|)
operator|(
name|sym_addr
argument_list|(
name|CURBRK_SYM
argument_list|)
operator|)
operator|=
name|curbrk
expr_stmt|;
comment|/* 	 * Set up pointers to the program's allocation functions, so 	 * that we can use them from now on. 	 */
name|p_malloc
operator|=
operator|(
name|void
operator|*
call|(
modifier|*
call|)
argument_list|(
name|size_t
argument_list|)
operator|)
operator|(
name|sym_addr
argument_list|(
name|MALLOC_SYM
argument_list|)
operator|)
expr_stmt|;
name|p_free
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|)
operator|(
name|sym_addr
argument_list|(
name|FREE_SYM
argument_list|)
operator|)
expr_stmt|;
name|p_realloc
operator|=
operator|(
name|void
operator|*
call|(
modifier|*
call|)
argument_list|(
name|void
operator|*
argument_list|,
name|size_t
argument_list|)
operator|)
operator|(
name|sym_addr
argument_list|(
name|REALLOC_SYM
argument_list|)
operator|)
expr_stmt|;
block|}
end_decl_stmt

begin_function
name|void
modifier|*
name|malloc
parameter_list|(
name|size
parameter_list|)
name|size_t
name|size
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
comment|/* If we are far enough along, we can use the system malloc. */
if|if
condition|(
name|p_malloc
operator|!=
name|NULL
condition|)
return|return
call|(
modifier|*
name|p_malloc
call|)
argument_list|(
name|size
argument_list|)
return|;
comment|/*          * Otherwise we use our simple built-in malloc.  We get the          * memory from brk() in increments of one page.  We store the          * allocated size in the first word, so that realloc can be          * made to work. 	 */
if|if
condition|(
name|rtld_alloc_lev
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Internal error: internal malloc called before"
literal|" being initialized"
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|ALIGN
argument_list|(
name|rtld_alloc_lev
argument_list|)
expr_stmt|;
name|rtld_alloc_lev
operator|=
name|p
operator|+
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
operator|+
name|size
expr_stmt|;
if|if
condition|(
name|rtld_alloc_lev
operator|>
name|curbrk
condition|)
block|{
comment|/* Get memory from system */
name|char
modifier|*
name|newbrk
decl_stmt|;
name|newbrk
operator|=
operator|(
name|char
operator|*
operator|)
name|roundup2
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|rtld_alloc_lev
argument_list|,
name|PAGSIZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|brk
argument_list|(
name|newbrk
argument_list|)
operator|==
operator|(
name|char
operator|*
operator|)
operator|-
literal|1
condition|)
return|return
name|NULL
return|;
block|}
operator|*
operator|(
name|size_t
operator|*
operator|)
name|p
operator|=
name|size
expr_stmt|;
return|return
name|p
operator|+
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|realloc
parameter_list|(
name|ptr
parameter_list|,
name|size
parameter_list|)
name|void
modifier|*
name|ptr
decl_stmt|;
name|size_t
name|size
decl_stmt|;
block|{
name|size_t
name|old_size
decl_stmt|;
name|void
modifier|*
name|new_ptr
decl_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
return|return
name|malloc
argument_list|(
name|size
argument_list|)
return|;
comment|/* 	 * If we are far enough along, and if the memory originally came 	 * from the system malloc, we can use the system realloc. 	 */
if|if
condition|(
name|p_realloc
operator|!=
name|NULL
operator|&&
operator|(
name|char
operator|*
operator|)
name|ptr
operator|>=
name|rtld_alloc_lev
condition|)
return|return
call|(
modifier|*
name|p_realloc
call|)
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|)
return|;
name|old_size
operator|=
operator|*
operator|(
operator|(
name|size_t
operator|*
operator|)
name|ptr
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|old_size
operator|>=
name|size
condition|)
comment|/* Not expanding the region */
return|return
name|ptr
return|;
name|new_ptr
operator|=
name|malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_ptr
operator|!=
name|NULL
condition|)
name|memcpy
argument_list|(
name|new_ptr
argument_list|,
name|ptr
argument_list|,
name|old_size
argument_list|)
expr_stmt|;
return|return
name|new_ptr
return|;
block|}
end_function

begin_function
name|void
name|free
parameter_list|(
name|ptr
parameter_list|)
name|void
modifier|*
name|ptr
decl_stmt|;
block|{
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
return|return;
comment|/* 	 * If we are far enough along, and if the memory originally came 	 * from the system malloc, we can use the system free.  Otherwise 	 * we can't free the memory and we just let it go to waste. 	 */
if|if
condition|(
name|p_free
operator|!=
name|NULL
operator|&&
operator|(
name|char
operator|*
operator|)
name|ptr
operator|>=
name|rtld_alloc_lev
condition|)
call|(
modifier|*
name|p_free
call|)
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

