begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1993 Paul Kranenburg  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *      This product includes software developed by Paul Kranenburg.  * 4. The name of the author may not be used to endorse or promote products  *    derived from this software withough specific prior written permission  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  *	$Id: rtld.c,v 1.4 1993/11/22 19:05:27 jkh Exp $  */
end_comment

begin_include
include|#
directive|include
file|<machine/vmparam.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|BSD
end_ifndef

begin_define
define|#
directive|define
name|MAP_COPY
value|MAP_PRIVATE
end_define

begin_define
define|#
directive|define
name|MAP_FILE
value|0
end_define

begin_define
define|#
directive|define
name|MAP_ANON
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_include
include|#
directive|include
file|<stab.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ld.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|BSD
end_ifndef

begin_comment
comment|/* Need do better than this */
end_comment

begin_define
define|#
directive|define
name|NEED_DEV_ZERO
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Loader private data, hung off link_map->lm_lpd  */
end_comment

begin_struct
struct|struct
name|lm_private
block|{
name|int
name|lpd_version
decl_stmt|;
name|struct
name|link_map
modifier|*
name|lpd_parent
decl_stmt|;
ifdef|#
directive|ifdef
name|SUN_COMPAT
name|long
name|lpd_offset
decl_stmt|;
comment|/* Correction for Sun main programs */
endif|#
directive|endif
block|}
struct|;
end_struct

begin_ifdef
ifdef|#
directive|ifdef
name|SUN_COMPAT
end_ifdef

begin_define
define|#
directive|define
name|LM_OFFSET
parameter_list|(
name|lmp
parameter_list|)
value|(((struct lm_private *)((lmp)->lm_lpd))->lpd_offset)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|LM_OFFSET
parameter_list|(
name|lmp
parameter_list|)
value|(0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Base address for link_dynamic_2 entries */
end_comment

begin_define
define|#
directive|define
name|LM_LDBASE
parameter_list|(
name|lmp
parameter_list|)
value|(lmp->lm_addr + LM_OFFSET(lmp))
end_define

begin_comment
comment|/* Start of text segment */
end_comment

begin_define
define|#
directive|define
name|LM_TXTADDR
parameter_list|(
name|lmp
parameter_list|)
value|(lmp->lm_addr == (caddr_t)0 ? PAGSIZ : 0)
end_define

begin_comment
comment|/* Start of run-time relocation_info */
end_comment

begin_define
define|#
directive|define
name|LM_REL
parameter_list|(
name|lmp
parameter_list|)
value|((struct relocation_info *) \ 			(lmp->lm_addr + LM_OFFSET(lmp) + LD_REL((lmp)->lm_ld)))
end_define

begin_comment
comment|/* Start of symbols */
end_comment

begin_define
define|#
directive|define
name|LM_SYMBOL
parameter_list|(
name|lmp
parameter_list|,
name|i
parameter_list|)
value|((struct nzlist *) \ 		(lmp->lm_addr + LM_OFFSET(lmp) + LD_SYMBOL((lmp)->lm_ld) + \ 			i * (LD_VERSION_NZLIST_P(lmp->lm_ld->ld_version) ? \ 				sizeof(struct nzlist) : sizeof(struct nlist))))
end_define

begin_comment
comment|/* Start of hash table */
end_comment

begin_define
define|#
directive|define
name|LM_HASH
parameter_list|(
name|lmp
parameter_list|)
value|((struct rrs_hash *) \ 		(lmp->lm_addr + LM_OFFSET(lmp) + LD_HASH((lmp)->lm_ld)))
end_define

begin_comment
comment|/* Start of strings */
end_comment

begin_define
define|#
directive|define
name|LM_STRINGS
parameter_list|(
name|lmp
parameter_list|)
value|((char *) \ 		(lmp->lm_addr + LM_OFFSET(lmp) + LD_STRINGS((lmp)->lm_ld)))
end_define

begin_comment
comment|/* End of text */
end_comment

begin_define
define|#
directive|define
name|LM_ETEXT
parameter_list|(
name|lmp
parameter_list|)
value|((char *) \ 		(lmp->lm_addr + LM_TXTADDR(lmp) + LD_TEXTSZ((lmp)->lm_ld)))
end_define

begin_comment
comment|/* PLT is in data segment, so don't use LM_OFFSET here */
end_comment

begin_define
define|#
directive|define
name|LM_PLT
parameter_list|(
name|lmp
parameter_list|)
value|((jmpslot_t *) \ 		(lmp->lm_addr + LD_PLT((lmp)->lm_ld)))
end_define

begin_comment
comment|/* Parent of link map */
end_comment

begin_define
define|#
directive|define
name|LM_PARENT
parameter_list|(
name|lmp
parameter_list|)
value|(((struct lm_private *)((lmp)->lm_lpd))->lpd_parent)
end_define

begin_decl_stmt
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uid_t
name|uid
decl_stmt|,
name|euid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|gid_t
name|gid
decl_stmt|,
name|egid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|careful
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|link_map
modifier|*
name|link_map_head
decl_stmt|,
modifier|*
name|main_map
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|link_map
modifier|*
modifier|*
name|link_map_tail
init|=
operator|&
name|link_map_head
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rt_symbol
modifier|*
name|rt_symbol_head
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dlopen
argument_list|()
decl_stmt|,
name|dlclose
argument_list|()
decl_stmt|,
name|dlsym
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ld_entry
name|ld_entry
init|=
block|{
name|dlopen
block|,
name|dlclose
block|,
name|dlsym
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|xprintf
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_brk
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|load_maps
name|__P
argument_list|(
operator|(
expr|struct
name|crt_ldso
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|map_object
name|__P
argument_list|(
operator|(
expr|struct
name|link_object
operator|*
operator|,
expr|struct
name|link_map
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|alloc_link_map
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
expr|struct
name|link_object
operator|*
operator|,
expr|struct
name|link_map
operator|*
operator|,
name|caddr_t
operator|,
expr|struct
name|link_dynamic
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|check_text_reloc
name|__P
argument_list|(
operator|(
expr|struct
name|relocation_info
operator|*
operator|,
expr|struct
name|link_map
operator|*
operator|,
name|caddr_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|reloc_maps
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|reloc_copy
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rtfindlib
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|binder_entry
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|binder
name|__P
argument_list|(
operator|(
name|jmpslot_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|nzlist
modifier|*
name|lookup
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
expr|struct
name|link_map
operator|*
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|rt_symbol
modifier|*
name|lookup_rts
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|rt_symbol
modifier|*
name|enter_rts
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|long
operator|,
name|int
operator|,
name|caddr_t
operator|,
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|"md-static-funcs.c"
end_include

begin_comment
comment|/*  * Called from assembler stub that has set up crtp (passed from crt0)  * and dp (our __DYNAMIC).  */
end_comment

begin_function
name|void
name|rtld
parameter_list|(
name|version
parameter_list|,
name|crtp
parameter_list|,
name|dp
parameter_list|)
name|int
name|version
decl_stmt|;
name|struct
name|crt_ldso
modifier|*
name|crtp
decl_stmt|;
name|struct
name|link_dynamic
modifier|*
name|dp
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
name|int
name|nreloc
decl_stmt|;
comment|/* # of ld.so relocations */
name|struct
name|relocation_info
modifier|*
name|reloc
decl_stmt|;
name|char
modifier|*
modifier|*
name|envp
decl_stmt|;
name|struct
name|ld_debug
modifier|*
name|ldp
decl_stmt|;
comment|/* Check version */
if|if
condition|(
name|version
operator|!=
name|CRT_VERSION_BSD
operator|&&
name|version
operator|!=
name|CRT_VERSION_SUN
condition|)
return|return;
comment|/* Fixup __DYNAMIC structure */
operator|(
name|long
operator|)
name|dp
operator|->
name|ld_un
operator|.
name|ld_2
operator|+=
name|crtp
operator|->
name|crt_ba
expr_stmt|;
comment|/* Be careful not to use .div routine from library */
for|for
control|(
name|nreloc
operator|=
literal|0
operator|,
name|n
operator|=
name|LD_RELSZ
argument_list|(
name|dp
argument_list|)
init|;
name|n
operator|>
literal|0
condition|;
name|n
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|relocation_info
argument_list|)
control|)
name|nreloc
operator|++
expr_stmt|;
comment|/* Relocate ourselves */
for|for
control|(
name|reloc
operator|=
operator|(
expr|struct
name|relocation_info
operator|*
operator|)
operator|(
name|dp
operator|->
name|ld_un
operator|.
name|ld_2
operator|->
name|ld_rel
operator|+
name|crtp
operator|->
name|crt_ba
operator|)
init|;
name|nreloc
condition|;
name|nreloc
operator|--
operator|,
name|reloc
operator|++
control|)
block|{
specifier|register
name|long
name|addr
init|=
name|reloc
operator|->
name|r_address
operator|+
name|crtp
operator|->
name|crt_ba
decl_stmt|;
name|md_relocate_simple
argument_list|(
name|reloc
argument_list|,
name|crtp
operator|->
name|crt_ba
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
name|progname
operator|=
literal|"ld.so"
expr_stmt|;
comment|/* Setup out (private) environ variable */
name|environ
operator|=
name|crtp
operator|->
name|crt_ep
expr_stmt|;
comment|/* Get user and group identifiers */
name|uid
operator|=
name|getuid
argument_list|()
expr_stmt|;
name|euid
operator|=
name|geteuid
argument_list|()
expr_stmt|;
name|gid
operator|=
name|getgid
argument_list|()
expr_stmt|;
name|egid
operator|=
name|getegid
argument_list|()
expr_stmt|;
name|careful
operator|=
operator|(
name|uid
operator|!=
name|euid
operator|)
operator|||
operator|(
name|gid
operator|!=
name|egid
operator|)
expr_stmt|;
if|if
condition|(
name|careful
condition|)
block|{
name|unsetenv
argument_list|(
literal|"LD_LIBRARY_PATH"
argument_list|)
expr_stmt|;
name|unsetenv
argument_list|(
literal|"LD_PRELOAD"
argument_list|)
expr_stmt|;
name|unsetenv
argument_list|(
literal|"LD_RUN_PATH"
argument_list|)
expr_stmt|;
comment|/* In case we ever implement this */
block|}
comment|/* Setup directory search */
name|std_search_dirs
argument_list|(
name|getenv
argument_list|(
literal|"LD_LIBRARY_PATH"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Load required objects into the process address space */
name|load_maps
argument_list|(
name|crtp
argument_list|)
expr_stmt|;
comment|/* Relocate all loaded objects according to their RRS segments */
name|reloc_maps
argument_list|()
expr_stmt|;
name|reloc_copy
argument_list|()
expr_stmt|;
comment|/* Fill in some field in main's __DYNAMIC structure */
name|crtp
operator|->
name|crt_dp
operator|->
name|ld_entry
operator|=
operator|&
name|ld_entry
expr_stmt|;
name|ldp
operator|=
name|crtp
operator|->
name|crt_dp
operator|->
name|ldd
expr_stmt|;
name|ldp
operator|->
name|ldd_cp
operator|=
name|rt_symbol_head
expr_stmt|;
if|if
condition|(
name|ldp
operator|->
name|ldd_in_debugger
condition|)
block|{
name|caddr_t
name|addr
init|=
call|(
name|caddr_t
call|)
argument_list|(
operator|(
name|long
operator|)
name|crtp
operator|->
name|crt_bp
operator|&
operator|(
operator|~
operator|(
name|PAGSIZ
operator|-
literal|1
operator|)
operator|)
argument_list|)
decl_stmt|;
comment|/* Set breakpoint for the benefit of debuggers */
if|if
condition|(
name|mprotect
argument_list|(
name|addr
argument_list|,
name|PAGSIZ
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
operator||
name|PROT_EXEC
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"mprotect"
argument_list|)
operator|,
name|fatal
argument_list|(
literal|"Cannot set breakpoint\n"
argument_list|)
expr_stmt|;
block|}
name|md_set_breakpoint
argument_list|(
name|crtp
operator|->
name|crt_bp
argument_list|,
operator|&
name|ldp
operator|->
name|ldd_bp_inst
argument_list|)
expr_stmt|;
if|if
condition|(
name|mprotect
argument_list|(
name|addr
argument_list|,
name|PAGSIZ
argument_list|,
name|PROT_READ
operator||
name|PROT_EXEC
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"mprotect"
argument_list|)
expr_stmt|;
block|}
name|ldp
operator|->
name|ldd_bp_addr
operator|=
name|crtp
operator|->
name|crt_bp
expr_stmt|;
if|if
condition|(
name|link_map_head
condition|)
name|ldp
operator|->
name|ldd_sym_loaded
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Close our file descriptor */
operator|(
name|void
operator|)
name|close
argument_list|(
name|crtp
operator|->
name|crt_ldfd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|load_maps
parameter_list|(
name|crtp
parameter_list|)
name|struct
name|crt_ldso
modifier|*
name|crtp
decl_stmt|;
block|{
name|struct
name|link_map
modifier|*
name|lmp
decl_stmt|;
name|int
name|tracing
init|=
operator|(
name|int
operator|)
name|getenv
argument_list|(
literal|"LD_TRACE_LOADED_OBJECTS"
argument_list|)
decl_stmt|;
comment|/* Handle LD_PRELOAD's here */
comment|/* Make an entry for the main program */
name|alloc_link_map
argument_list|(
literal|"main"
argument_list|,
operator|(
expr|struct
name|link_object
operator|*
operator|)
literal|0
argument_list|,
operator|(
expr|struct
name|link_map
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
name|crtp
operator|->
name|crt_dp
argument_list|)
expr_stmt|;
for|for
control|(
name|lmp
operator|=
name|link_map_head
init|;
name|lmp
condition|;
name|lmp
operator|=
name|lmp
operator|->
name|lm_next
control|)
block|{
name|struct
name|link_object
modifier|*
name|lop
decl_stmt|;
name|long
name|next
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|lmp
operator|->
name|lm_ld
condition|)
name|next
operator|=
name|LD_NEED
argument_list|(
name|lmp
operator|->
name|lm_ld
argument_list|)
expr_stmt|;
while|while
condition|(
name|next
condition|)
block|{
name|lop
operator|=
operator|(
expr|struct
name|link_object
operator|*
operator|)
operator|(
name|LM_LDBASE
argument_list|(
name|lmp
argument_list|)
operator|+
name|next
operator|)
expr_stmt|;
name|map_object
argument_list|(
name|lop
argument_list|,
name|lmp
argument_list|)
expr_stmt|;
name|next
operator|=
name|lop
operator|->
name|lo_next
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|tracing
condition|)
return|return;
for|for
control|(
name|lmp
operator|=
name|link_map_head
init|;
name|lmp
condition|;
name|lmp
operator|=
name|lmp
operator|->
name|lm_next
control|)
block|{
name|struct
name|link_object
modifier|*
name|lop
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|path
decl_stmt|;
if|if
condition|(
operator|(
name|lop
operator|=
name|lmp
operator|->
name|lm_lop
operator|)
operator|==
name|NULL
condition|)
continue|continue;
name|name
operator|=
name|lop
operator|->
name|lo_name
operator|+
name|LM_LDBASE
argument_list|(
name|LM_PARENT
argument_list|(
name|lmp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|path
operator|=
name|lmp
operator|->
name|lm_name
operator|)
operator|==
name|NULL
condition|)
name|path
operator|=
literal|"not found"
expr_stmt|;
if|if
condition|(
name|lop
operator|->
name|lo_library
condition|)
name|printf
argument_list|(
literal|"\t-l%s.%d => %s (%#x)\n"
argument_list|,
name|name
argument_list|,
name|lop
operator|->
name|lo_major
argument_list|,
name|path
argument_list|,
name|lmp
operator|->
name|lm_addr
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"\t%s => %s (%#x)\n"
argument_list|,
name|name
argument_list|,
name|path
argument_list|,
name|lmp
operator|->
name|lm_addr
argument_list|)
expr_stmt|;
block|}
name|_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate a new link map for an shared object NAME loaded at ADDR as a  * result of the presence of link object LOP in the link map PARENT.  */
end_comment

begin_function
specifier|static
name|void
name|alloc_link_map
parameter_list|(
name|name
parameter_list|,
name|lop
parameter_list|,
name|parent
parameter_list|,
name|addr
parameter_list|,
name|dp
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|link_map
modifier|*
name|parent
decl_stmt|;
name|struct
name|link_object
modifier|*
name|lop
decl_stmt|;
name|caddr_t
name|addr
decl_stmt|;
name|struct
name|link_dynamic
modifier|*
name|dp
decl_stmt|;
block|{
name|struct
name|link_map
modifier|*
name|lmp
decl_stmt|;
name|struct
name|lm_private
modifier|*
name|lmpp
decl_stmt|;
name|lmpp
operator|=
operator|(
expr|struct
name|lm_private
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|lm_private
argument_list|)
argument_list|)
expr_stmt|;
name|lmp
operator|=
operator|(
expr|struct
name|link_map
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|link_map
argument_list|)
argument_list|)
expr_stmt|;
name|lmp
operator|->
name|lm_next
operator|=
name|NULL
expr_stmt|;
operator|*
name|link_map_tail
operator|=
name|lmp
expr_stmt|;
name|link_map_tail
operator|=
operator|&
name|lmp
operator|->
name|lm_next
expr_stmt|;
name|lmp
operator|->
name|lm_addr
operator|=
name|addr
expr_stmt|;
name|lmp
operator|->
name|lm_name
operator|=
name|name
expr_stmt|;
name|lmp
operator|->
name|lm_lop
operator|=
name|lop
expr_stmt|;
name|lmp
operator|->
name|lm_ld
operator|=
name|dp
expr_stmt|;
name|lmp
operator|->
name|lm_lpd
operator|=
operator|(
name|caddr_t
operator|)
name|lmpp
expr_stmt|;
comment|/*XXX*/
if|if
condition|(
name|addr
operator|==
literal|0
condition|)
name|main_map
operator|=
name|lmp
expr_stmt|;
name|lmpp
operator|->
name|lpd_parent
operator|=
name|parent
expr_stmt|;
ifdef|#
directive|ifdef
name|SUN_COMPAT
name|lmpp
operator|->
name|lpd_offset
operator|=
operator|(
name|addr
operator|==
literal|0
operator|&&
name|dp
operator|->
name|ld_version
operator|==
name|LD_VERSION_SUN
operator|)
condition|?
name|PAGSIZ
else|:
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Map object identified by link object LOP which was found  * in link map LMP.  */
end_comment

begin_function
specifier|static
name|void
name|map_object
parameter_list|(
name|lop
parameter_list|,
name|lmp
parameter_list|)
name|struct
name|link_object
modifier|*
name|lop
decl_stmt|;
name|struct
name|link_map
modifier|*
name|lmp
decl_stmt|;
block|{
name|struct
name|link_dynamic
modifier|*
name|dp
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|,
modifier|*
name|name
init|=
operator|(
name|char
operator|*
operator|)
operator|(
name|lop
operator|->
name|lo_name
operator|+
name|LM_LDBASE
argument_list|(
name|lmp
argument_list|)
operator|)
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|caddr_t
name|addr
decl_stmt|;
name|struct
name|exec
name|hdr
decl_stmt|;
name|int
name|usehints
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|lop
operator|->
name|lo_library
condition|)
block|{
name|usehints
operator|=
literal|1
expr_stmt|;
name|again
label|:
name|path
operator|=
name|rtfindlib
argument_list|(
name|name
argument_list|,
name|lop
operator|->
name|lo_major
argument_list|,
name|lop
operator|->
name|lo_minor
argument_list|,
operator|&
name|usehints
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"Cannot find lib%s.so.%d.%d\n"
argument_list|,
name|name
argument_list|,
name|lop
operator|->
name|lo_major
argument_list|,
name|lop
operator|->
name|lo_minor
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|path
operator|=
name|name
expr_stmt|;
block|}
name|fd
operator|=
name|open
argument_list|(
name|path
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|usehints
condition|)
block|{
name|usehints
operator|=
literal|0
expr_stmt|;
goto|goto
name|again
goto|;
block|}
name|fatal
argument_list|(
literal|"%s not found"
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
operator|&
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
condition|)
block|{
name|fatal
argument_list|(
literal|"%s: Cannot read exec header"
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|N_BADMAG
argument_list|(
name|hdr
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"%s: Incorrect format"
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|addr
operator|=
name|mmap
argument_list|(
literal|0
argument_list|,
name|hdr
operator|.
name|a_text
operator|+
name|hdr
operator|.
name|a_data
argument_list|,
name|PROT_READ
operator||
name|PROT_EXEC
argument_list|,
name|MAP_FILE
operator||
name|MAP_COPY
argument_list|,
name|fd
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|(
name|caddr_t
operator|)
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"Cannot map %s text\n"
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|mmap
argument_list|(
name|addr
operator|+
name|hdr
operator|.
name|a_text
argument_list|,
name|hdr
operator|.
name|a_data
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
operator||
name|PROT_EXEC
argument_list|,
name|MAP_FILE
operator||
name|MAP_FIXED
operator||
name|MAP_COPY
argument_list|,
name|fd
argument_list|,
name|hdr
operator|.
name|a_text
argument_list|)
operator|==
operator|(
name|caddr_t
operator|)
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"Cannot map %s data"
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|NEED_DEV_ZERO
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
literal|"/dev/zero"
argument_list|,
name|O_RDWR
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|perror
argument_list|(
literal|"/dev/zero"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|hdr
operator|.
name|a_bss
operator|&&
name|mmap
argument_list|(
name|addr
operator|+
name|hdr
operator|.
name|a_text
operator|+
name|hdr
operator|.
name|a_data
argument_list|,
name|hdr
operator|.
name|a_bss
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
operator||
name|PROT_EXEC
argument_list|,
name|MAP_ANON
operator||
name|MAP_FIXED
operator||
name|MAP_COPY
argument_list|,
name|fd
argument_list|,
name|hdr
operator|.
name|a_text
operator|+
name|hdr
operator|.
name|a_data
argument_list|)
operator|==
operator|(
name|caddr_t
operator|)
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"Cannot map %s bss"
argument_list|,
name|path
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NEED_DEV_ZERO
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Assume _DYNAMIC is the first data item */
name|dp
operator|=
operator|(
expr|struct
name|link_dynamic
operator|*
operator|)
operator|(
name|addr
operator|+
name|hdr
operator|.
name|a_text
operator|)
expr_stmt|;
comment|/* Fixup __DYNAMIC structure */
operator|(
name|long
operator|)
name|dp
operator|->
name|ld_un
operator|.
name|ld_2
operator|+=
operator|(
name|long
operator|)
name|addr
expr_stmt|;
name|alloc_link_map
argument_list|(
name|path
argument_list|,
name|lop
argument_list|,
name|lmp
argument_list|,
name|addr
argument_list|,
name|dp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|reloc_maps
parameter_list|()
block|{
name|struct
name|link_map
modifier|*
name|lmp
decl_stmt|;
for|for
control|(
name|lmp
operator|=
name|link_map_head
init|;
name|lmp
condition|;
name|lmp
operator|=
name|lmp
operator|->
name|lm_next
control|)
block|{
name|struct
name|link_dynamic
modifier|*
name|dp
init|=
name|lmp
operator|->
name|lm_ld
decl_stmt|;
name|struct
name|relocation_info
modifier|*
name|r
init|=
name|LM_REL
argument_list|(
name|lmp
argument_list|)
decl_stmt|;
name|struct
name|relocation_info
modifier|*
name|rend
init|=
name|r
operator|+
name|LD_RELSZ
argument_list|(
name|dp
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|r
argument_list|)
decl_stmt|;
if|if
condition|(
name|LD_PLTSZ
argument_list|(
name|dp
argument_list|)
condition|)
name|md_fix_jmpslot
argument_list|(
name|LM_PLT
argument_list|(
name|lmp
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|LM_PLT
argument_list|(
name|lmp
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|binder_entry
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|r
operator|<
name|rend
condition|;
name|r
operator|++
control|)
block|{
name|char
modifier|*
name|sym
decl_stmt|;
name|caddr_t
name|addr
init|=
name|lmp
operator|->
name|lm_addr
operator|+
name|r
operator|->
name|r_address
decl_stmt|;
name|check_text_reloc
argument_list|(
name|r
argument_list|,
name|lmp
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|RELOC_EXTERN_P
argument_list|(
name|r
argument_list|)
condition|)
block|{
name|struct
name|link_map
modifier|*
name|src_map
decl_stmt|;
name|struct
name|nzlist
modifier|*
name|np
decl_stmt|;
name|long
name|relocation
init|=
name|md_get_addend
argument_list|(
name|r
argument_list|,
name|addr
argument_list|)
decl_stmt|;
if|if
condition|(
name|RELOC_LAZY_P
argument_list|(
name|r
argument_list|)
condition|)
continue|continue;
name|sym
operator|=
name|LM_STRINGS
argument_list|(
name|lmp
argument_list|)
operator|+
name|LM_SYMBOL
argument_list|(
name|lmp
argument_list|,
name|RELOC_SYMBOL
argument_list|(
name|r
argument_list|)
argument_list|)
operator|->
name|nz_strx
expr_stmt|;
name|np
operator|=
name|lookup
argument_list|(
name|sym
argument_list|,
operator|&
name|src_map
argument_list|,
literal|0
comment|/*XXX-jumpslots!*/
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"Undefined symbol \"%s\" in %s\n"
argument_list|,
name|sym
argument_list|,
name|lmp
operator|->
name|lm_name
argument_list|)
expr_stmt|;
comment|/* 				 * Found symbol definition. 				 * If it's in a link map, adjust value 				 * according to the load address of that map. 				 * Otherwise it's a run-time allocated common 				 * whose value is already up-to-date. 				 */
name|relocation
operator|+=
name|np
operator|->
name|nz_value
expr_stmt|;
if|if
condition|(
name|src_map
condition|)
name|relocation
operator|+=
operator|(
name|long
operator|)
name|src_map
operator|->
name|lm_addr
expr_stmt|;
if|if
condition|(
name|RELOC_PCREL_P
argument_list|(
name|r
argument_list|)
condition|)
name|relocation
operator|-=
operator|(
name|long
operator|)
name|lmp
operator|->
name|lm_addr
expr_stmt|;
if|if
condition|(
name|RELOC_COPY_P
argument_list|(
name|r
argument_list|)
operator|&&
name|src_map
condition|)
block|{
if|#
directive|if
name|DEBUG
name|xprintf
argument_list|(
literal|"RELOCATE(%s) copy: from %s at %#x(%#x+%#x) to %s at %#x, reloc = %#x, size %d\n"
argument_list|,
name|lmp
operator|->
name|lm_name
argument_list|,
name|src_map
operator|->
name|lm_name
argument_list|,
name|src_map
operator|->
name|lm_addr
operator|+
name|np
operator|->
name|nz_value
argument_list|,
name|src_map
operator|->
name|lm_addr
argument_list|,
name|np
operator|->
name|nz_value
argument_list|,
name|sym
argument_list|,
name|addr
argument_list|,
name|relocation
argument_list|,
name|np
operator|->
name|nz_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|enter_rts
argument_list|(
name|sym
argument_list|,
operator|(
name|long
operator|)
name|addr
argument_list|,
name|N_DATA
operator|+
name|N_EXT
argument_list|,
name|src_map
operator|->
name|lm_addr
operator|+
name|np
operator|->
name|nz_value
argument_list|,
name|np
operator|->
name|nz_size
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|#
directive|if
name|DEBUG
name|xprintf
argument_list|(
literal|"RELOCATE(%s) external: %s at %#x, reloc = %#x\n"
argument_list|,
name|lmp
operator|->
name|lm_name
argument_list|,
name|sym
argument_list|,
name|addr
argument_list|,
name|relocation
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|md_relocate
argument_list|(
name|r
argument_list|,
name|relocation
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
name|DEBUG
name|xprintf
argument_list|(
literal|"RELOCATE(%s) internal at %#x, reloc = %#x\n"
argument_list|,
name|lmp
operator|->
name|lm_name
argument_list|,
name|addr
argument_list|,
name|md_get_rt_segment_addend
argument_list|(
name|r
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|md_relocate
argument_list|(
name|r
argument_list|,
ifdef|#
directive|ifdef
name|SUN_COMPAT
name|md_get_rt_segment_addend
argument_list|(
argument|r
argument_list|,
argument|addr
argument_list|)
else|#
directive|else
name|md_get_addend
argument_list|(
name|r
argument_list|,
name|addr
argument_list|)
endif|#
directive|endif
operator|+
operator|(
name|long
operator|)
name|lmp
operator|->
name|lm_addr
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|lmp
operator|->
name|lm_rwt
condition|)
block|{
if|if
condition|(
name|mprotect
argument_list|(
name|lmp
operator|->
name|lm_addr
operator|+
name|LM_TXTADDR
argument_list|(
name|lmp
argument_list|)
argument_list|,
name|LD_TEXTSZ
argument_list|(
name|lmp
operator|->
name|lm_ld
argument_list|)
argument_list|,
name|PROT_READ
operator||
name|PROT_EXEC
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"mprotect"
argument_list|)
operator|,
name|fatal
argument_list|(
literal|"Cannot disable writes to %s\n"
argument_list|,
name|lmp
operator|->
name|lm_name
argument_list|)
expr_stmt|;
block|}
name|lmp
operator|->
name|lm_rwt
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|reloc_copy
parameter_list|()
block|{
name|struct
name|rt_symbol
modifier|*
name|rtsp
decl_stmt|;
for|for
control|(
name|rtsp
operator|=
name|rt_symbol_head
init|;
name|rtsp
condition|;
name|rtsp
operator|=
name|rtsp
operator|->
name|rt_next
control|)
if|if
condition|(
name|rtsp
operator|->
name|rt_sp
operator|->
name|nz_type
operator|==
name|N_DATA
operator|+
name|N_EXT
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|xprintf
argument_list|(
literal|"reloc_copy: from %#x to %#x, size %d\n"
argument_list|,
name|rtsp
operator|->
name|rt_srcaddr
argument_list|,
name|rtsp
operator|->
name|rt_sp
operator|->
name|nz_value
argument_list|,
name|rtsp
operator|->
name|rt_sp
operator|->
name|nz_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bcopy
argument_list|(
name|rtsp
operator|->
name|rt_srcaddr
argument_list|,
operator|(
name|caddr_t
operator|)
name|rtsp
operator|->
name|rt_sp
operator|->
name|nz_value
argument_list|,
name|rtsp
operator|->
name|rt_sp
operator|->
name|nz_size
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|check_text_reloc
parameter_list|(
name|r
parameter_list|,
name|lmp
parameter_list|,
name|addr
parameter_list|)
name|struct
name|relocation_info
modifier|*
name|r
decl_stmt|;
name|struct
name|link_map
modifier|*
name|lmp
decl_stmt|;
name|caddr_t
name|addr
decl_stmt|;
block|{
name|char
modifier|*
name|sym
decl_stmt|;
if|if
condition|(
name|addr
operator|>=
name|LM_ETEXT
argument_list|(
name|lmp
argument_list|)
condition|)
return|return;
if|if
condition|(
name|RELOC_EXTERN_P
argument_list|(
name|r
argument_list|)
condition|)
name|sym
operator|=
name|LM_STRINGS
argument_list|(
name|lmp
argument_list|)
operator|+
name|LM_SYMBOL
argument_list|(
name|lmp
argument_list|,
name|RELOC_SYMBOL
argument_list|(
name|r
argument_list|)
argument_list|)
operator|->
name|nz_strx
expr_stmt|;
else|else
name|sym
operator|=
literal|""
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ld.so: warning: non pure code in %s at %x (%s)\n"
argument_list|,
name|lmp
operator|->
name|lm_name
argument_list|,
name|r
operator|->
name|r_address
argument_list|,
name|sym
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|lmp
operator|->
name|lm_rwt
operator|==
literal|0
operator|&&
name|mprotect
argument_list|(
name|lmp
operator|->
name|lm_addr
operator|+
name|LM_TXTADDR
argument_list|(
name|lmp
argument_list|)
argument_list|,
name|LD_TEXTSZ
argument_list|(
name|lmp
operator|->
name|lm_ld
argument_list|)
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
operator||
name|PROT_EXEC
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"mprotect"
argument_list|)
operator|,
name|fatal
argument_list|(
literal|"Cannot enable writes to %s\n"
argument_list|,
name|lmp
operator|->
name|lm_name
argument_list|)
expr_stmt|;
block|}
name|lmp
operator|->
name|lm_rwt
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Lookup NAME in the link maps. The link map producing a definition  * is returned in SRC_MAP. If STRONG is set, the symbol returned must  * have a proper type (used by binder()).  */
end_comment

begin_function
specifier|static
name|struct
name|nzlist
modifier|*
name|lookup
parameter_list|(
name|name
parameter_list|,
name|src_map
parameter_list|,
name|strong
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|link_map
modifier|*
modifier|*
name|src_map
decl_stmt|;
name|int
name|strong
decl_stmt|;
block|{
name|long
name|common_size
init|=
literal|0
decl_stmt|;
name|struct
name|link_map
modifier|*
name|lmp
decl_stmt|;
name|struct
name|rt_symbol
modifier|*
name|rtsp
decl_stmt|;
operator|*
name|src_map
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|rtsp
operator|=
name|lookup_rts
argument_list|(
name|name
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
name|rtsp
operator|->
name|rt_sp
return|;
comment|/* 	 * Search all maps for a definition of NAME 	 */
for|for
control|(
name|lmp
operator|=
name|link_map_head
init|;
name|lmp
condition|;
name|lmp
operator|=
name|lmp
operator|->
name|lm_next
control|)
block|{
name|int
name|buckets
init|=
name|LD_BUCKETS
argument_list|(
name|lmp
operator|->
name|lm_ld
argument_list|)
decl_stmt|;
name|long
name|hashval
init|=
literal|0
decl_stmt|;
name|struct
name|rrs_hash
modifier|*
name|hp
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|struct
name|nzlist
modifier|*
name|np
decl_stmt|;
comment|/* 		 * Compute bucket in which the symbol might be found. 		 */
for|for
control|(
name|cp
operator|=
name|name
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
name|hashval
operator|=
operator|(
name|hashval
operator|<<
literal|1
operator|)
operator|+
operator|*
name|cp
expr_stmt|;
name|hashval
operator|=
operator|(
name|hashval
operator|&
literal|0x7fffffff
operator|)
operator|%
name|buckets
expr_stmt|;
name|hp
operator|=
name|LM_HASH
argument_list|(
name|lmp
argument_list|)
operator|+
name|hashval
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|rh_symbolnum
operator|==
operator|-
literal|1
condition|)
comment|/* Nothing in this bucket */
continue|continue;
while|while
condition|(
name|hp
condition|)
block|{
name|np
operator|=
name|LM_SYMBOL
argument_list|(
name|lmp
argument_list|,
name|hp
operator|->
name|rh_symbolnum
argument_list|)
expr_stmt|;
name|cp
operator|=
name|LM_STRINGS
argument_list|(
name|lmp
argument_list|)
operator|+
name|np
operator|->
name|nz_strx
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|hp
operator|->
name|rh_next
operator|==
literal|0
condition|)
name|hp
operator|=
name|NULL
expr_stmt|;
else|else
name|hp
operator|=
name|LM_HASH
argument_list|(
name|lmp
argument_list|)
operator|+
name|hp
operator|->
name|rh_next
expr_stmt|;
block|}
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
comment|/* Nothing in this bucket */
continue|continue;
comment|/* 		 * We have a symbol with the name we're looking for. 		 */
if|if
condition|(
name|np
operator|->
name|nz_value
operator|==
literal|0
condition|)
comment|/* It's not a definition */
continue|continue;
if|if
condition|(
name|np
operator|->
name|nz_type
operator|==
name|N_UNDF
operator|+
name|N_EXT
operator|&&
name|np
operator|->
name|nz_value
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|np
operator|->
name|nz_other
operator|==
name|RRS_FUNC
condition|)
block|{
comment|/* It's a weak function definition */
if|if
condition|(
name|strong
condition|)
continue|continue;
block|}
else|else
block|{
comment|/* It's a common, note value and continue search */
if|if
condition|(
name|common_size
operator|<
name|np
operator|->
name|nz_value
condition|)
name|common_size
operator|=
name|np
operator|->
name|nz_value
expr_stmt|;
continue|continue;
block|}
block|}
operator|*
name|src_map
operator|=
name|lmp
expr_stmt|;
return|return
name|np
return|;
block|}
if|if
condition|(
name|common_size
operator|==
literal|0
condition|)
comment|/* Not found */
return|return
name|NULL
return|;
comment|/* 	 * It's a common, enter into run-time common symbol table. 	 */
name|rtsp
operator|=
name|enter_rts
argument_list|(
name|name
argument_list|,
operator|(
name|long
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
name|common_size
argument_list|)
argument_list|,
name|N_UNDF
operator|+
name|N_EXT
argument_list|,
literal|0
argument_list|,
name|common_size
argument_list|)
expr_stmt|;
if|#
directive|if
name|DEBUG
name|xprintf
argument_list|(
literal|"Allocating common: %s size %d at %#x\n"
argument_list|,
name|name
argument_list|,
name|common_size
argument_list|,
name|rtsp
operator|->
name|rt_sp
operator|->
name|nz_value
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|rtsp
operator|->
name|rt_sp
return|;
block|}
end_function

begin_comment
comment|/*  * This routine is called from the jumptable to resolve  * procedure calls to shared objects.  */
end_comment

begin_function
name|long
name|binder
parameter_list|(
name|jsp
parameter_list|)
name|jmpslot_t
modifier|*
name|jsp
decl_stmt|;
block|{
name|struct
name|link_map
modifier|*
name|lmp
decl_stmt|,
modifier|*
name|src_map
decl_stmt|;
name|long
name|addr
decl_stmt|;
name|char
modifier|*
name|sym
decl_stmt|;
name|struct
name|nzlist
modifier|*
name|np
decl_stmt|;
name|int
name|index
decl_stmt|;
comment|/* 	 * Find the PLT map that contains JSP. 	 */
for|for
control|(
name|lmp
operator|=
name|link_map_head
init|;
name|lmp
condition|;
name|lmp
operator|=
name|lmp
operator|->
name|lm_next
control|)
block|{
if|if
condition|(
name|LM_PLT
argument_list|(
name|lmp
argument_list|)
operator|<
name|jsp
operator|&&
name|jsp
operator|<
name|LM_PLT
argument_list|(
name|lmp
argument_list|)
operator|+
name|LD_PLTSZ
argument_list|(
name|lmp
operator|->
name|lm_ld
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|jsp
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|lmp
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"Call to binder from unknown location: %#x\n"
argument_list|,
name|jsp
argument_list|)
expr_stmt|;
name|index
operator|=
name|jsp
operator|->
name|reloc_index
operator|&
name|JMPSLOT_RELOC_MASK
expr_stmt|;
comment|/* Get the local symbol this jmpslot refers to */
name|sym
operator|=
name|LM_STRINGS
argument_list|(
name|lmp
argument_list|)
operator|+
name|LM_SYMBOL
argument_list|(
name|lmp
argument_list|,
name|RELOC_SYMBOL
argument_list|(
operator|&
name|LM_REL
argument_list|(
name|lmp
argument_list|)
index|[
name|index
index|]
argument_list|)
argument_list|)
operator|->
name|nz_strx
expr_stmt|;
name|np
operator|=
name|lookup
argument_list|(
name|sym
argument_list|,
operator|&
name|src_map
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"Undefined symbol \"%s\" called from %s at %#x"
argument_list|,
name|sym
argument_list|,
name|lmp
operator|->
name|lm_name
argument_list|,
name|jsp
argument_list|)
expr_stmt|;
comment|/* Fixup jmpslot so future calls transfer directly to target */
name|addr
operator|=
name|np
operator|->
name|nz_value
expr_stmt|;
if|if
condition|(
name|src_map
condition|)
name|addr
operator|+=
operator|(
name|long
operator|)
name|src_map
operator|->
name|lm_addr
expr_stmt|;
name|md_fix_jmpslot
argument_list|(
name|jsp
argument_list|,
operator|(
name|long
operator|)
name|jsp
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|#
directive|if
name|DEBUG
name|xprintf
argument_list|(
literal|" BINDER: %s located at = %#x in %s\n"
argument_list|,
name|sym
argument_list|,
name|addr
argument_list|,
name|src_map
operator|->
name|lm_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|addr
return|;
block|}
end_function

begin_comment
comment|/*  * Run-time common symbol table.  */
end_comment

begin_define
define|#
directive|define
name|RTC_TABSIZE
value|57
end_define

begin_decl_stmt
specifier|static
name|struct
name|rt_symbol
modifier|*
name|rt_symtab
index|[
name|RTC_TABSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Compute hash value for run-time symbol table  */
end_comment

begin_function
specifier|static
name|int
name|hash_string
parameter_list|(
name|key
parameter_list|)
name|char
modifier|*
name|key
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|k
decl_stmt|;
name|cp
operator|=
name|key
expr_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|cp
condition|)
name|k
operator|=
operator|(
operator|(
operator|(
name|k
operator|<<
literal|1
operator|)
operator|+
operator|(
name|k
operator|>>
literal|14
operator|)
operator|)
operator|^
operator|(
operator|*
name|cp
operator|++
operator|)
operator|)
operator|&
literal|0x3fff
expr_stmt|;
return|return
name|k
return|;
block|}
end_function

begin_comment
comment|/*  * Lookup KEY in the run-time common symbol table.  */
end_comment

begin_function
specifier|static
name|struct
name|rt_symbol
modifier|*
name|lookup_rts
parameter_list|(
name|key
parameter_list|)
name|char
modifier|*
name|key
decl_stmt|;
block|{
specifier|register
name|int
name|hashval
decl_stmt|;
specifier|register
name|struct
name|rt_symbol
modifier|*
name|rtsp
decl_stmt|;
comment|/* Determine which bucket.  */
name|hashval
operator|=
name|hash_string
argument_list|(
name|key
argument_list|)
operator|%
name|RTC_TABSIZE
expr_stmt|;
comment|/* Search the bucket.  */
for|for
control|(
name|rtsp
operator|=
name|rt_symtab
index|[
name|hashval
index|]
init|;
name|rtsp
condition|;
name|rtsp
operator|=
name|rtsp
operator|->
name|rt_link
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
name|rtsp
operator|->
name|rt_sp
operator|->
name|nz_name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|rtsp
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|rt_symbol
modifier|*
name|enter_rts
parameter_list|(
name|name
parameter_list|,
name|value
parameter_list|,
name|type
parameter_list|,
name|srcaddr
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|long
name|value
decl_stmt|;
name|int
name|type
decl_stmt|;
name|caddr_t
name|srcaddr
decl_stmt|;
name|long
name|size
decl_stmt|;
block|{
specifier|register
name|int
name|hashval
decl_stmt|;
specifier|register
name|struct
name|rt_symbol
modifier|*
name|rtsp
decl_stmt|,
modifier|*
modifier|*
name|rpp
decl_stmt|;
comment|/* Determine which bucket */
name|hashval
operator|=
name|hash_string
argument_list|(
name|name
argument_list|)
operator|%
name|RTC_TABSIZE
expr_stmt|;
comment|/* Find end of bucket */
for|for
control|(
name|rpp
operator|=
operator|&
name|rt_symtab
index|[
name|hashval
index|]
init|;
operator|*
name|rpp
condition|;
name|rpp
operator|=
operator|&
operator|(
operator|*
name|rpp
operator|)
operator|->
name|rt_link
control|)
empty_stmt|;
comment|/* Allocate new common symbol */
name|rtsp
operator|=
operator|(
expr|struct
name|rt_symbol
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|rt_symbol
argument_list|)
argument_list|)
expr_stmt|;
name|rtsp
operator|->
name|rt_sp
operator|=
operator|(
expr|struct
name|nzlist
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nzlist
argument_list|)
argument_list|)
expr_stmt|;
name|rtsp
operator|->
name|rt_sp
operator|->
name|nz_name
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|rtsp
operator|->
name|rt_sp
operator|->
name|nz_value
operator|=
name|value
expr_stmt|;
name|rtsp
operator|->
name|rt_sp
operator|->
name|nz_type
operator|=
name|type
expr_stmt|;
name|rtsp
operator|->
name|rt_sp
operator|->
name|nz_size
operator|=
name|size
expr_stmt|;
name|rtsp
operator|->
name|rt_srcaddr
operator|=
name|srcaddr
expr_stmt|;
name|rtsp
operator|->
name|rt_link
operator|=
name|NULL
expr_stmt|;
comment|/* Link onto linear list as well */
name|rtsp
operator|->
name|rt_next
operator|=
name|rt_symbol_head
expr_stmt|;
name|rt_symbol_head
operator|=
name|rtsp
expr_stmt|;
operator|*
name|rpp
operator|=
name|rtsp
expr_stmt|;
return|return
name|rtsp
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|hints_header
modifier|*
name|hheader
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hints_bucket
modifier|*
name|hbuckets
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|hstrtab
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|HINTS_VALID
value|(hheader != NULL&& hheader != (struct hints_header *)-1)
end_define

begin_function
specifier|static
name|void
name|maphints
parameter_list|()
block|{
name|caddr_t
name|addr
decl_stmt|;
name|long
name|msize
decl_stmt|;
name|int
name|fd
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|_PATH_LD_HINTS
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|hheader
operator|=
operator|(
expr|struct
name|hints_header
operator|*
operator|)
operator|-
literal|1
expr_stmt|;
return|return;
block|}
name|msize
operator|=
name|PAGSIZ
expr_stmt|;
name|addr
operator|=
name|mmap
argument_list|(
literal|0
argument_list|,
name|msize
argument_list|,
name|PROT_READ
argument_list|,
name|MAP_FILE
operator||
name|MAP_COPY
argument_list|,
name|fd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|==
operator|(
name|caddr_t
operator|)
operator|-
literal|1
condition|)
block|{
name|hheader
operator|=
operator|(
expr|struct
name|hints_header
operator|*
operator|)
operator|-
literal|1
expr_stmt|;
return|return;
block|}
name|hheader
operator|=
operator|(
expr|struct
name|hints_header
operator|*
operator|)
name|addr
expr_stmt|;
if|if
condition|(
name|HH_BADMAG
argument_list|(
operator|*
name|hheader
argument_list|)
condition|)
block|{
name|munmap
argument_list|(
name|addr
argument_list|,
name|msize
argument_list|)
expr_stmt|;
name|hheader
operator|=
operator|(
expr|struct
name|hints_header
operator|*
operator|)
operator|-
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|hheader
operator|->
name|hh_version
operator|!=
name|LD_HINTS_VERSION_1
condition|)
block|{
name|munmap
argument_list|(
name|addr
argument_list|,
name|msize
argument_list|)
expr_stmt|;
name|hheader
operator|=
operator|(
expr|struct
name|hints_header
operator|*
operator|)
operator|-
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|hheader
operator|->
name|hh_ehints
operator|>
name|msize
condition|)
block|{
if|if
condition|(
name|mmap
argument_list|(
name|addr
operator|+
name|msize
argument_list|,
name|hheader
operator|->
name|hh_ehints
operator|-
name|msize
argument_list|,
name|PROT_READ
argument_list|,
name|MAP_FILE
operator||
name|MAP_COPY
operator||
name|MAP_FIXED
argument_list|,
name|fd
argument_list|,
name|msize
argument_list|)
operator|!=
call|(
name|caddr_t
call|)
argument_list|(
name|addr
operator|+
name|msize
argument_list|)
condition|)
block|{
name|munmap
argument_list|(
operator|(
name|caddr_t
operator|)
name|hheader
argument_list|,
name|msize
argument_list|)
expr_stmt|;
name|hheader
operator|=
operator|(
expr|struct
name|hints_header
operator|*
operator|)
operator|-
literal|1
expr_stmt|;
return|return;
block|}
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|hbuckets
operator|=
operator|(
expr|struct
name|hints_bucket
operator|*
operator|)
operator|(
name|addr
operator|+
name|hheader
operator|->
name|hh_hashtab
operator|)
expr_stmt|;
name|hstrtab
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|addr
operator|+
name|hheader
operator|->
name|hh_strtab
operator|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|hinthash
parameter_list|(
name|cp
parameter_list|,
name|vmajor
parameter_list|,
name|vminor
parameter_list|)
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|vmajor
decl_stmt|,
name|vminor
decl_stmt|;
block|{
name|int
name|k
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|cp
condition|)
name|k
operator|=
operator|(
operator|(
operator|(
name|k
operator|<<
literal|1
operator|)
operator|+
operator|(
name|k
operator|>>
literal|14
operator|)
operator|)
operator|^
operator|(
operator|*
name|cp
operator|++
operator|)
operator|)
operator|&
literal|0x3fff
expr_stmt|;
name|k
operator|=
operator|(
operator|(
operator|(
name|k
operator|<<
literal|1
operator|)
operator|+
operator|(
name|k
operator|>>
literal|14
operator|)
operator|)
operator|^
operator|(
name|vmajor
operator|*
literal|257
operator|)
operator|)
operator|&
literal|0x3fff
expr_stmt|;
name|k
operator|=
operator|(
operator|(
operator|(
name|k
operator|<<
literal|1
operator|)
operator|+
operator|(
name|k
operator|>>
literal|14
operator|)
operator|)
operator|^
operator|(
name|vminor
operator|*
literal|167
operator|)
operator|)
operator|&
literal|0x3fff
expr_stmt|;
return|return
name|k
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|major
end_undef

begin_undef
undef|#
directive|undef
name|minor
end_undef

begin_function
specifier|static
name|char
modifier|*
name|findhint
parameter_list|(
name|name
parameter_list|,
name|major
parameter_list|,
name|minor
parameter_list|,
name|preferred_path
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|major
decl_stmt|,
name|minor
decl_stmt|;
name|char
modifier|*
name|preferred_path
decl_stmt|;
block|{
name|struct
name|hints_bucket
modifier|*
name|bp
decl_stmt|;
name|bp
operator|=
name|hbuckets
operator|+
operator|(
name|hinthash
argument_list|(
name|name
argument_list|,
name|major
argument_list|,
name|minor
argument_list|)
operator|%
name|hheader
operator|->
name|hh_nbucket
operator|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Sanity check */
if|if
condition|(
name|bp
operator|->
name|hi_namex
operator|>=
name|hheader
operator|->
name|hh_strtab_sz
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Bad name index: %#x\n"
argument_list|,
name|bp
operator|->
name|hi_namex
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|bp
operator|->
name|hi_pathx
operator|>=
name|hheader
operator|->
name|hh_strtab_sz
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Bad path index: %#x\n"
argument_list|,
name|bp
operator|->
name|hi_pathx
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|hstrtab
operator|+
name|bp
operator|->
name|hi_namex
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* It's `name', check version numbers */
if|if
condition|(
name|bp
operator|->
name|hi_major
operator|==
name|major
operator|&&
operator|(
name|bp
operator|->
name|hi_ndewey
operator|<
literal|2
operator|||
name|bp
operator|->
name|hi_minor
operator|==
name|minor
operator|)
condition|)
block|{
if|if
condition|(
name|preferred_path
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|preferred_path
argument_list|,
name|hstrtab
operator|+
name|bp
operator|->
name|hi_pathx
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|hstrtab
operator|+
name|bp
operator|->
name|hi_pathx
return|;
block|}
block|}
block|}
if|if
condition|(
name|bp
operator|->
name|hi_next
operator|==
operator|-
literal|1
condition|)
break|break;
comment|/* Move on to next in bucket */
name|bp
operator|=
operator|&
name|hbuckets
index|[
name|bp
operator|->
name|hi_next
index|]
expr_stmt|;
block|}
comment|/* No hints available for name */
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|rtfindlib
parameter_list|(
name|name
parameter_list|,
name|major
parameter_list|,
name|minor
parameter_list|,
name|usehints
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|major
decl_stmt|,
name|minor
decl_stmt|;
name|int
modifier|*
name|usehints
decl_stmt|;
block|{
name|char
modifier|*
name|hint
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|ld_path
init|=
name|getenv
argument_list|(
literal|"LD_LIBRARY_PATH"
argument_list|)
decl_stmt|;
if|if
condition|(
name|hheader
operator|==
name|NULL
condition|)
name|maphints
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|HINTS_VALID
operator|||
operator|!
operator|(
operator|*
name|usehints
operator|)
condition|)
block|{
operator|*
name|usehints
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
name|findshlib
argument_list|(
name|name
argument_list|,
operator|&
name|major
argument_list|,
operator|&
name|minor
argument_list|)
return|;
block|}
if|if
condition|(
name|ld_path
operator|!=
name|NULL
condition|)
block|{
comment|/* Prefer paths from LD_LIBRARY_PATH */
while|while
condition|(
operator|(
name|cp
operator|=
name|strsep
argument_list|(
operator|&
name|ld_path
argument_list|,
literal|":"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|hint
operator|=
name|findhint
argument_list|(
name|name
argument_list|,
name|major
argument_list|,
name|minor
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ld_path
condition|)
operator|*
operator|(
name|ld_path
operator|-
literal|1
operator|)
operator|=
literal|':'
expr_stmt|;
if|if
condition|(
name|hint
condition|)
return|return
name|hint
return|;
block|}
block|}
else|else
block|{
comment|/* No LD_LIBRARY_PATH, check default */
name|hint
operator|=
name|findhint
argument_list|(
name|name
argument_list|,
name|major
argument_list|,
name|minor
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|hint
condition|)
return|return
name|hint
return|;
block|}
comment|/* No hints available for name */
operator|*
name|usehints
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
name|findshlib
argument_list|(
name|name
argument_list|,
operator|&
name|major
argument_list|,
operator|&
name|minor
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dlopen
parameter_list|(
name|name
parameter_list|,
name|mode
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|mode
decl_stmt|;
block|{
name|xprintf
argument_list|(
literal|"dlopen(%s, %x)\n"
argument_list|,
name|name
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dlclose
parameter_list|(
name|fd
parameter_list|)
name|int
name|fd
decl_stmt|;
block|{
name|xprintf
argument_list|(
literal|"dlclose(%d)\n"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dlsym
parameter_list|(
name|fd
parameter_list|,
name|sym
parameter_list|)
name|int
name|fd
decl_stmt|;
name|char
modifier|*
name|sym
decl_stmt|;
block|{
name|xprintf
argument_list|(
literal|"dlsym(%d, %s)\n"
argument_list|,
name|fd
argument_list|,
name|sym
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Private heap functions.  */
end_comment

begin_decl_stmt
specifier|static
name|caddr_t
name|curbrk
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|init_brk
parameter_list|()
block|{
name|struct
name|rlimit
name|rlim
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
modifier|*
name|cpp
init|=
name|environ
decl_stmt|;
if|if
condition|(
name|getrlimit
argument_list|(
name|RLIMIT_STACK
argument_list|,
operator|&
name|rlim
argument_list|)
operator|<
literal|0
condition|)
block|{
name|xprintf
argument_list|(
literal|"ld.so: brk: getrlimit failure\n"
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|environ
operator|<
name|USRSTACK
operator|-
name|MAXSSIZ
condition|)
block|{
name|curbrk
operator|=
call|(
name|caddr_t
call|)
argument_list|(
operator|(
call|(
name|long
call|)
argument_list|(
name|USRSTACK
operator|-
name|MAXSSIZ
operator|-
name|rlim
operator|.
name|rlim_cur
argument_list|)
operator|+
name|PAGSIZ
operator|)
operator|&
operator|~
operator|(
name|PAGSIZ
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|curbrk
operator|=
call|(
name|caddr_t
call|)
argument_list|(
operator|(
call|(
name|long
call|)
argument_list|(
name|USRSTACK
operator|-
name|rlim
operator|.
name|rlim_cur
argument_list|)
operator|+
name|PAGSIZ
operator|)
operator|&
operator|~
operator|(
name|PAGSIZ
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
if|#
directive|if
name|__STDC__
name|xprintf
parameter_list|(
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
function|xprintf
parameter_list|(
name|fmt
parameter_list|,
name|va_alist
parameter_list|)
name|char
modifier|*
name|fmt
decl_stmt|;
endif|#
directive|endif
block|{
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
if|#
directive|if
name|__STDC__
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
else|#
directive|else
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vsprintf
argument_list|(
name|buf
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|write
argument_list|(
literal|1
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|caddr_t
name|sbrk
parameter_list|(
name|incr
parameter_list|)
name|int
name|incr
decl_stmt|;
block|{
name|int
name|fd
init|=
operator|-
literal|1
decl_stmt|;
name|caddr_t
name|oldbrk
decl_stmt|;
if|if
condition|(
name|curbrk
operator|==
literal|0
condition|)
name|init_brk
argument_list|()
expr_stmt|;
if|#
directive|if
name|DEBUG
name|xprintf
argument_list|(
literal|"sbrk: incr = %#x, curbrk = %#x\n"
argument_list|,
name|incr
argument_list|,
name|curbrk
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|incr
operator|==
literal|0
condition|)
return|return
name|curbrk
return|;
name|incr
operator|=
operator|(
name|incr
operator|+
name|PAGSIZ
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|PAGSIZ
operator|-
literal|1
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NEED_DEV_ZERO
name|fd
operator|=
name|open
argument_list|(
literal|"/dev/zero"
argument_list|,
name|O_RDWR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
name|perror
argument_list|(
literal|"/dev/zero"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|mmap
argument_list|(
name|curbrk
argument_list|,
name|incr
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_ANON
operator||
name|MAP_FIXED
operator||
name|MAP_COPY
argument_list|,
name|fd
argument_list|,
literal|0
argument_list|)
operator|==
operator|(
name|caddr_t
operator|)
operator|-
literal|1
condition|)
block|{
name|xprintf
argument_list|(
literal|"Cannot map anonymous memory"
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|NEED_DEV_ZERO
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|oldbrk
operator|=
name|curbrk
expr_stmt|;
if|#
directive|if
name|TRY_THIS_FOR_A_CHANGE
name|curbrk
operator|-=
name|incr
expr_stmt|;
else|#
directive|else
name|curbrk
operator|+=
name|incr
expr_stmt|;
endif|#
directive|endif
return|return
name|oldbrk
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
name|caddr_t
name|sbrk
parameter_list|(
name|incr
parameter_list|)
name|int
name|incr
decl_stmt|;
block|{
name|int
name|fd
init|=
operator|-
literal|1
decl_stmt|;
name|caddr_t
name|oldbrk
decl_stmt|;
name|xprintf
argument_list|(
literal|"sbrk: incr = %#x, curbrk = %#x\n"
argument_list|,
name|incr
argument_list|,
name|curbrk
argument_list|)
expr_stmt|;
if|#
directive|if
name|DEBUG
name|xprintf
argument_list|(
literal|"sbrk: incr = %#x, curbrk = %#x\n"
argument_list|,
name|incr
argument_list|,
name|curbrk
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|curbrk
operator|==
literal|0
operator|&&
operator|(
name|curbrk
operator|=
name|mmap
argument_list|(
literal|0
argument_list|,
name|PAGSIZ
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_ANON
operator||
name|MAP_COPY
argument_list|,
name|fd
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|(
name|caddr_t
operator|)
operator|-
literal|1
condition|)
block|{
name|xprintf
argument_list|(
literal|"Cannot map anonymous memory"
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* There's valid memory from `curbrk' to next page boundary */
if|if
condition|(
operator|(
name|long
operator|)
name|curbrk
operator|+
name|incr
operator|<=
operator|(
operator|(
operator|(
name|long
operator|)
name|curbrk
operator|+
name|PAGSIZ
operator|)
operator|&
operator|~
operator|(
name|PAGSIZ
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
name|oldbrk
operator|=
name|curbrk
expr_stmt|;
name|curbrk
operator|+=
name|incr
expr_stmt|;
return|return
name|oldbrk
return|;
block|}
comment|/* 	 * If asking for than currently left in this chunk, 	 * go somewhere completely different. 	 */
ifdef|#
directive|ifdef
name|NEED_DEV_ZERO
name|fd
operator|=
name|open
argument_list|(
literal|"/dev/zero"
argument_list|,
name|O_RDWR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
name|perror
argument_list|(
literal|"/dev/zero"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|curbrk
operator|=
name|mmap
argument_list|(
literal|0
argument_list|,
name|incr
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_ANON
operator||
name|MAP_COPY
argument_list|,
name|fd
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|(
name|caddr_t
operator|)
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"Cannot map anonymous memory"
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|NEED_DEV_ZERO
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|oldbrk
operator|=
name|curbrk
expr_stmt|;
name|curbrk
operator|+=
name|incr
expr_stmt|;
return|return
name|oldbrk
return|;
block|}
end_function

end_unit

